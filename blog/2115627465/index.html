<!DOCTYPE html><html lang="ru"><head><meta charset="UTF-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Spiiin's blog | Устройство интерпретаторов lua-jit и daScript</title><meta name="description" content="&lt;p&gt;Устройство виртуальных машин для самых быстрых скриптовых языков — &lt;a href=&quot;https://luajit.org/&quot;&gt;lua-jit&lt;/a&gt; и &lt;a href=&quot;https://dascript.org/&quot;&gt;daScript&lt;/a&gt;.&lt;br&gt;Более развёрнутое продолжение беглой заметки &lt;a href=&quot;/blog/1067581840/&quot; title=&quot;daScript - скорость&quot;&gt;daScript - скорость&lt;/a&gt;&lt;/p&gt;"><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=PT+Serif&amp;display=swap"><link rel="stylesheet" href="/css/highlights/darkula.css"><link rel="stylesheet" href="/css/main.css"><link rel="search" type="application/opensearchdescription+xml" href="http://spiiin.github.io/atom.xml" title="Spiiin's blog"><script>(function (i, s, o, g, r, a, m) {
  i['GoogleAnalyticsObject'] = r;
  i[r] = i[r] || function () {
    (i[r].q = i[r].q || []).push(arguments)
  }, i[r].l = 1 * new Date();
  a = s.createElement(o),
    m = s.getElementsByTagName(o)[0];
  a.async = 1;
  a.src = g;
  m.parentNode.insertBefore(a, m)
})(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');
ga('create', 'UA-00000000-0', 'auto');
ga('send', 'pageview');</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-shiki-plugin@latest/lib/codeblock.css">
<style>:root{--hl-color:#abb2bf;--hl-bg:#282c34;--hltools-bg:#21252b;--hltools-color:#bbbbbc;--hlnumber-bg:#282c34;--hlnumber-color:#495162;--hlscrollbar-bg:#373c47;--hlexpand-bg:linear-gradient(180deg,rgba(40,44,52,0.1),rgba(40,44,52,0.9))}</style><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Spiiin's blog" type="application/atom+xml">
</head><body><div class="container"><header class="main-header"><h1 class="main-header__title uplize"><a class="main-header__title__link" href="/"><img class="header-image" src="/images/favicon.png" width="36" height="36">Spiiin's blog</a></h1><nav class="main-header__nav"><ul class="main-nav"><li class="main-nav__list"><a class="main-nav__list__link" href="/" target="_self">HOME</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/archives/" target="_self">ARCHIVE</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/tags/meta" target="_self">TAGS</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/blog/1" target="_self">ABOUT</a></li></ul></nav></header><main class="container__wrapper"><div class="pagination"><a class="pagination__link pagination__prev" href="/blog/2385889062/">Позже</a><a class="pagination__link pagination__next" href="/blog/3121981810/">Раньше</a></div><article class="article post"><h3 class="article__title">Устройство интерпретаторов lua-jit и daScript</h3><div class="article__date metadata"><div class="post-info">2022/10/14</div></div><div class="article__tags metadata">Tags:
<a class="article__tags__link metadata" href="/tags/lua/">lua</a><a class="article__tags__link metadata" href="/tags/longread/">longread</a><a class="article__tags__link metadata" href="/tags/llvm/">llvm</a><a class="article__tags__link metadata" href="/tags/dascript/">dascript</a></div><div class="article__body"><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Устройство виртуальных машин для самых быстрых скриптовых языков — <a target="_blank" rel="noopener" href="https://luajit.org/">lua-jit</a> и <a target="_blank" rel="noopener" href="https://dascript.org/">daScript</a>.<br>Более развёрнутое продолжение беглой заметки <a href="/blog/1067581840/" title="daScript - скорость">daScript - скорость</a></p>
<span id="more"></span>
<h2><span id="lua">Lua</span><a href="#lua" class="header-anchor">#</a></h2><p>По <a target="_blank" rel="noopener" href="https://github.com/r-lyeh-archived/scriptorium">бенчмаркам языков</a> <code>lua</code> находится высоко даже в режиме интерпретации.</p>
<p>Первые стадии трансформации текста скрипта — лексический и синтаксический анализ. Текст разбивается на отдельные лексемы/токены, которые затем собираются парсером во что-то, что можно интерпретировать. Чаще всего это или поток последовательных инструкций (байт код для интерпретатора) в случае с <code>lua</code>, или AST(дерево, которое будет обходить интерпретатор) в случае с <code>daScript</code>.</p>
<p>Я не буду заострять внимание на отличиях типов интерпретаторов, детально можно прочитать про это в книге <a target="_blank" rel="noopener" href="http://craftinginterpreters.com/">Crafting Interpreters</a>, с примерами интерпретаторов обоих типов (или даже более <a target="_blank" rel="noopener" href="https://gameprogrammingpatterns.com/bytecode.html">сжато</a>). Интереснее следующий шаг — посмотреть почему именно эти интерпретаторы быстрее других.</p>
<p>“Традиционный” подход к дизайну языков с байт-кодом — динамическая типизация, управление памятью с помощью подсчёта ссылок/garbage collector, небольшой набор базовых типов (примитивы + строки + массивы + функции/замыкания + таблицы, опционально - итераторы, корутины, исключения). Из таблиц (пары ключ-значения) можно построить объекты и “собрать” классы — некоторые ключи таблицы делаем зарезервированными, вызывая их для создания/удаления объектов, ссылки на родительскую таблицу, перегрузки операторов и т.п.</p>
<p>Возможные оптимизации:</p>
<ul>
<li>Так как чаще всего данные группируются в объекты (представленные таблицами) — то очень важна быстрая реализация этих хеш-таблиц, в чём lua традиционна считается хорошей.</li>
<li><a target="_blank" rel="noopener" href="http://craftinginterpreters.com/optimization.html#nan-boxing">Nan-tagging</a> — распространённая паковка базовых типов языка виртуальной машины в тип <code>double</code>. Возникает отчасти из желания хранить примитивные типы в той же форме, что и сложные — в динамически типизированном языке нужно где-то сохранить в том числе и тип аргумента, чтобы знать, как его интерпретировать, и при этом не хочется иметь оверхед для примитивных типов. </li>
</ul>
<p>Отчасти из этой оптимизаций возникает ограничение на количество базовых типов языка — с точки зрения скриптового языка два класса будут иметь разные типы, но для интерпретатора виртуальной машины они оба будут представлены типом “таблица”, и отличаться только значением ключа “название класса”. Также любой вызов метода означает поиск его в таблице. Ещё один минус — требование “раскодировать” аргументы из запакованной формы при взаимодействии с нативным кодом, из-за чего замедляется передача управления в хост язык и обратно. Т.е. нельзя оптимизировать код, просто переносом мелких функций в хост-язык — необходимо переписывать сразу большие куски кода.</p>
<ul>
<li>Поиск частых паттернов в инструкциях. <a target="_blank" rel="noopener" href="http://craftinginterpreters.com/methods-and-initializers.html#optimized-invocations">Optimizing invocation</a> — пример слияния пары инструкций “получение метода класса + вызов метода”. В общем случае, метод может быть получен не для вызова, а для сохранения в переменную, но чаще всего вызывается напрямую, так что две инструкции, идущие подряд, можно “слить” в одну. В lua вроде не применяется, но повсеместно юзается в daScript, примеры приведу дальше. Оптимизация известна под названиями <code>Instruction fusion</code> или <code>Super-instructions</code>.</li>
</ul>
<h2><span id="tracing-jit">Tracing JIT</span><a href="#tracing-jit" class="header-anchor">#</a></h2><p>Основная сила lut-jit - just-in-time компиляция. Каждый раз, при вызовах функций и циклов (<code>thermal function/cycle</code>), интерпретатор подсчитывает количество таких вызовов, и таким образом, определяет “горячий” код. Алгоритм подсчёта (NLF region-selection) также умеет обнаруживать вложенные циклы и вызовы.</p>
<p>При достижении предельного количества вызовов, интерпретатор выполняет отмеченный участок кода с “трассированием”, то есть кроме выполнения инструкции дополнительно сохраняет её же в список инструкций — уже на другом байт-код языке (intermediate representation, <a target="_blank" rel="noopener" href="http://webcache.googleusercontent.com/search?q=cache:U5V-zQuM-ikJ:wiki.luajit.org/SSA-IR-2.0&amp;cd=1&amp;hl=ru&amp;ct=clnk&amp;gl=am">спек</a>).</p>
<p>После записи всех инструкций из IR генерируется машинный код, и следующий вызов этого участка кода уже приведёт к тому, чтобы будет вызвана нативная версия кода. Подмена способов вызова функции реализована с помощью патчинга оп-кодов байт-кода lua (call gates).</p>
<p>Генерация нативного машинного кода разрешена не на всех платформах/ОС (память для выполнения нативного кода защищена от записи), поэтому недоступна для части платформ. Также нативный код для различных архитектур отличается, поэтому добавление новой платформы может требовать написания отдельного генератора кода.</p>
<p><a target="_blank" rel="noopener" href="http://lua-users.org/lists/lua-l/2009-11/msg00089.html">Список особенностей</a> jit-компилятора lua:</p>
<ul>
<li>оптимизация IR-кода - сворачивание и выбрасывание неиспользуемых блоков</li>
<li>при возврате из нативной части кода в интерпретируемую, оптимизиуется восстановление состояния виртуальной машины, сохраняются “дифы” между состояниями</li>
<li>типизация аргументов, при трассировании кода записываются реальные типы переменных</li>
</ul>
<p>Тривиальный пример, с неизвестными типами аргументов:<br><figure class="shiki lua"><div class="codeblock"><div class="code"><pre class="shiki slack-dark"><code><span class="line"><span style="color: #C586C0">function</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">foo</span><span style="color: #E6E6E6">(</span><span style="color: #9CDCFE">t</span><span style="color: #E6E6E6">, </span><span style="color: #9CDCFE">k</span><span style="color: #E6E6E6">)</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">return</span><span style="color: #E6E6E6"> </span><span style="color: #9CDCFE">t</span><span style="color: #E6E6E6">[</span><span style="color: #9CDCFE">k</span><span style="color: #E6E6E6">]</span></span>
<span class="line"><span style="color: #C586C0">end</span></span></code></pre></div></div></figure><br>Может быть интерпретирован различными способами - t может быть таблицей или любым типом, у которого установлена метатаблица, k - числом, строкой или любым типом, и даже [] - метаметодом. В принципе, этот код может со всеми возможными комбинациями задействовать половину ветвей интерпретации ядра lua. Но если трассирующий компилятор запишет реально используемые типы, то он может сгенерировать быстрый нативный код, к примеру индексации массива (сгенерировав предварительно код проверки типов аргументов). Это даёт ускорение ~3 раза, по <a target="_blank" rel="noopener" href="https://staff.fnwi.uva.nl/h.vandermeer/docs/lua/luajit/luajit_intro.html#:~:text=As%20the%20name%20says%20LuaJIT,are%20not%20compiled%20at%20all.">замерам</a> авторов.</p>
<h2><span id="dascript">daScript</span><a href="#dascript" class="header-anchor">#</a></h2><p>daScript серьёзно отличается от “традиционных” скриптовых языков.</p>
<p>В первую очередь — на выходе синтаксического анализатора получается на байт-код, а абстрактное синтаксическое дерево, причём типизированное.</p>
<p>Типизация немного усложняет изучение языка, но позволяет избавиться от огромного количества ошибок типов. Если рассмотреть синтетический пример на lua, то обнаружить фактические типы аргменутов t и k может быть сложно в цепочке вызовов, а проверить их корректность можно только в рантайме. Представьте, что <code>foo</code> ожидает в качестве t список из строк и выбирает из него первый элемент (допустим, сортированный список допустимых фраз персонажа игры). Список составляется и сортируется динамически. На каком-то этапе в ходе рефактора программист добавляет дополнительную функцию в цепочку вызовов, которая проверяет граничное условие (не то, чтобы это хороший код или пример, но подобную ошибку с подменой списка строкой встречал много раз):</p>
<figure class="shiki lua"><div class="codeblock"><div class="code"><pre class="shiki slack-dark"><code><span class="line"><span style="color: #C586C0">function</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">checkIfGameOver</span><span style="color: #E6E6E6">(</span><span style="color: #9CDCFE">t</span><span style="color: #E6E6E6">, </span><span style="color: #9CDCFE">k</span><span style="color: #E6E6E6">)</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">if</span><span style="color: #E6E6E6"> </span><span style="color: #9CDCFE">life</span><span style="color: #E6E6E6"> </span><span style="color: #D4D4D4">&lt;=</span><span style="color: #E6E6E6"> </span><span style="color: #B5CEA8">0</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">then</span><span style="color: #E6E6E6"> </span></span>
<span class="line"><span style="color: #E6E6E6">        </span><span style="color: #DCDCAA">foo</span><span style="color: #E6E6E6">(</span><span style="color: #CE9178">&quot;game over!&quot;</span><span style="color: #E6E6E6">, </span><span style="color: #9CDCFE">k</span><span style="color: #E6E6E6">) </span><span style="color: #D4D4D4">//</span><span style="color: #E6E6E6">вместо </span><span style="color: #DCDCAA">foo</span><span style="color: #E6E6E6">([</span><span style="color: #CE9178">&quot;game over!&quot;</span><span style="color: #E6E6E6">], </span><span style="color: #9CDCFE">k</span><span style="color: #E6E6E6">)</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">else</span></span>
<span class="line"><span style="color: #E6E6E6">        </span><span style="color: #DCDCAA">foo</span><span style="color: #E6E6E6">(</span><span style="color: #9CDCFE">t</span><span style="color: #E6E6E6">, </span><span style="color: #9CDCFE">k</span><span style="color: #E6E6E6">)</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">end</span></span>
<span class="line"><span style="color: #C586C0">end</span></span></code></pre></div></div></figure>
<p>Если условие редкое, и код кажется программисту слишком тривиальным, чтобы его проверить в рантайме, баг может остаться незамеченным для ревьюера, а то и для QA. В типизированном языке ошибка бы скорее всего обнаружилась компилятором.</p>
<p>Представление в виде AST, а не байт-кода, упрощает генерацию и анализ кода, например — с ним работают <a href="/blog/1547564887/" title="daScript macro">макросы</a>, а также упрощается написание тулзов, анализирующих код.</p>
<p>На уровне AST намного удобнее проводить оптимизации, в этот момент интерпретатор иметь достаточно много информации о коде. <code>daScript</code> позволяет изучить код на каждом шаге оптимизации. Простейший пример:</p>
<figure class="shiki dascript"><div class="codeblock"><div class="code"><pre class="shiki slack-dark"><code><span class="line"><span style="color: #6A9955">//log_optimization_passes - выводит результаты всех промежуточных стадий оптимизации AST</span></span>
<span class="line"><span style="color: #C586C0">options</span><span style="color: #E6E6E6"> optimize</span><span style="color: #D4D4D4">=</span><span style="color: #C586C0">true</span><span style="color: #E6E6E6">, log_optimization_passes </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">true</span></span>
<span class="line"></span>
<span class="line"><span style="color: #569CD6">def</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">test</span><span style="color: #E6E6E6">(cond, a, </span><span style="color: #9CDCFE">b</span><span style="color: #E6E6E6">)</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">if</span><span style="color: #E6E6E6"> cond</span></span>
<span class="line"><span style="color: #E6E6E6">        </span><span style="color: #C586C0">return</span><span style="color: #E6E6E6"> a </span><span style="color: #D4D4D4">+</span><span style="color: #E6E6E6"> b</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">else</span></span>
<span class="line"><span style="color: #E6E6E6">        </span><span style="color: #C586C0">return</span><span style="color: #E6E6E6"> </span><span style="color: #B5CEA8">0</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E6E6E6">[</span><span style="color: #569CD6">export</span><span style="color: #E6E6E6">]</span></span>
<span class="line"><span style="color: #569CD6">def</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">main</span><span style="color: #E6E6E6">()</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #DCDCAA">print</span><span style="color: #E6E6E6">(</span><span style="color: #CE9178">&quot;{test(</span><span style="color: #C586C0">true</span><span style="color: #CE9178">, </span><span style="color: #B5CEA8">2</span><span style="color: #CE9178">, </span><span style="color: #B5CEA8">2</span><span style="color: #CE9178">)}</span><span style="color: #D7BA7D">\n</span><span style="color: #CE9178">&quot;</span><span style="color: #E6E6E6">)</span></span></code></pre></div></div></figure>
<p>После стадии <code>CONST_FOLDING</code> можно увидеть, что AST “свернулся” до:<br><figure class="shiki dascript"><div class="codeblock"><div class="code"><pre class="shiki slack-dark"><code><span class="line"><span style="color: #569CD6">def</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">main</span><span style="color: #E6E6E6">()</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #DCDCAA">print</span><span style="color: #E6E6E6">(</span><span style="color: #CE9178">&quot;{</span><span style="color: #B5CEA8">4</span><span style="color: #CE9178">}</span><span style="color: #D7BA7D">\n</span><span style="color: #CE9178">&quot;</span><span style="color: #E6E6E6">)</span></span></code></pre></div></div></figure></p>
<p>После оптимизаций <code>daScript</code> <strong>не интерпретирует AST</strong> и <strong>не генерирует</strong> байт-код. Вместо этого генерируется <a target="_blank" rel="noopener" href="https://github.com/GaijinEntertainment/daScript/blob/master/src/ast/ast_simulate.cpp#L2912">дерево симуляции</a>. На этом этапе также происходит оптимизация — AST ноды “отбрасывают” ненужную для симуляции информацию, например, информацию о типах (она больше не нужна, типы известны и статически проверены на уровне AST), и умеют генерировать более оптимизированные частные случаи (<a href="simulate">симуляция</a> simulate-ноды из ast-ноды ifThenElse, ветка <em>//good old if</em> - дефолтный вариант, остальные — оптимизированные).</p>
<p>Базовый класс нод simulate-ноды<br><figure class="shiki cpp"><div class="codeblock"><div class="code"><pre class="shiki slack-dark"><code><span class="line"><span style="color: #569CD6">struct</span><span style="color: #E6E6E6"> </span><span style="color: #4EC9B0">SimNode</span><span style="color: #E6E6E6"> {</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #DCDCAA">SimNode</span><span style="color: #E6E6E6"> ( </span><span style="color: #569CD6">const</span><span style="color: #E6E6E6"> LineInfo </span><span style="color: #D4D4D4">&amp;</span><span style="color: #E6E6E6"> at ) : </span><span style="color: #DCDCAA">debugInfo</span><span style="color: #E6E6E6">(at) {}</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #569CD6">virtual</span><span style="color: #E6E6E6"> </span><span style="color: #4EC9B0">SimNode</span><span style="color: #E6E6E6"> </span><span style="color: #569CD6">*</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">copyNode</span><span style="color: #E6E6E6"> ( </span><span style="color: #4EC9B0">Context</span><span style="color: #E6E6E6"> </span><span style="color: #569CD6">&amp;</span><span style="color: #E6E6E6"> </span><span style="color: #9CDCFE">context</span><span style="color: #E6E6E6">, </span><span style="color: #4EC9B0">NodeAllocator</span><span style="color: #E6E6E6"> </span><span style="color: #569CD6">*</span><span style="color: #E6E6E6"> </span><span style="color: #9CDCFE">code</span><span style="color: #E6E6E6"> );</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #569CD6">virtual</span><span style="color: #E6E6E6"> </span><span style="color: #4EC9B0">vec4f</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">eval</span><span style="color: #E6E6E6"> ( </span><span style="color: #4EC9B0">Context</span><span style="color: #E6E6E6"> </span><span style="color: #569CD6">&amp;</span><span style="color: #E6E6E6"> ) </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #B5CEA8">0</span><span style="color: #E6E6E6">;</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #569CD6">virtual</span><span style="color: #E6E6E6"> </span><span style="color: #4EC9B0">SimNode</span><span style="color: #E6E6E6"> </span><span style="color: #569CD6">*</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">visit</span><span style="color: #E6E6E6"> ( </span><span style="color: #4EC9B0">SimVisitor</span><span style="color: #E6E6E6"> </span><span style="color: #569CD6">&amp;</span><span style="color: #E6E6E6"> </span><span style="color: #9CDCFE">vis</span><span style="color: #E6E6E6"> );</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #569CD6">virtual</span><span style="color: #E6E6E6"> </span><span style="color: #569CD6">char</span><span style="color: #E6E6E6"> </span><span style="color: #569CD6">*</span><span style="color: #E6E6E6">      </span><span style="color: #DCDCAA">evalPtr</span><span style="color: #E6E6E6"> ( </span><span style="color: #4EC9B0">Context</span><span style="color: #E6E6E6"> </span><span style="color: #569CD6">&amp;</span><span style="color: #E6E6E6"> </span><span style="color: #9CDCFE">context</span><span style="color: #E6E6E6"> );</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #569CD6">virtual</span><span style="color: #E6E6E6"> </span><span style="color: #569CD6">bool</span><span style="color: #E6E6E6">        </span><span style="color: #DCDCAA">evalBool</span><span style="color: #E6E6E6"> ( </span><span style="color: #4EC9B0">Context</span><span style="color: #E6E6E6"> </span><span style="color: #569CD6">&amp;</span><span style="color: #E6E6E6"> </span><span style="color: #9CDCFE">context</span><span style="color: #E6E6E6"> );</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #569CD6">virtual</span><span style="color: #E6E6E6"> </span><span style="color: #569CD6">float</span><span style="color: #E6E6E6">       </span><span style="color: #DCDCAA">evalFloat</span><span style="color: #E6E6E6"> ( </span><span style="color: #4EC9B0">Context</span><span style="color: #E6E6E6"> </span><span style="color: #569CD6">&amp;</span><span style="color: #E6E6E6"> </span><span style="color: #9CDCFE">context</span><span style="color: #E6E6E6"> );</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #569CD6">virtual</span><span style="color: #E6E6E6"> </span><span style="color: #569CD6">double</span><span style="color: #E6E6E6">      </span><span style="color: #DCDCAA">evalDouble</span><span style="color: #E6E6E6"> ( </span><span style="color: #4EC9B0">Context</span><span style="color: #E6E6E6"> </span><span style="color: #569CD6">&amp;</span><span style="color: #E6E6E6"> </span><span style="color: #9CDCFE">context</span><span style="color: #E6E6E6"> );</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #569CD6">virtual</span><span style="color: #E6E6E6"> </span><span style="color: #569CD6">int32_t</span><span style="color: #E6E6E6">     </span><span style="color: #DCDCAA">evalInt</span><span style="color: #E6E6E6"> ( </span><span style="color: #4EC9B0">Context</span><span style="color: #E6E6E6"> </span><span style="color: #569CD6">&amp;</span><span style="color: #E6E6E6"> </span><span style="color: #9CDCFE">context</span><span style="color: #E6E6E6"> );</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #569CD6">virtual</span><span style="color: #E6E6E6"> </span><span style="color: #569CD6">uint32_t</span><span style="color: #E6E6E6">    </span><span style="color: #DCDCAA">evalUInt</span><span style="color: #E6E6E6"> ( </span><span style="color: #4EC9B0">Context</span><span style="color: #E6E6E6"> </span><span style="color: #569CD6">&amp;</span><span style="color: #E6E6E6"> </span><span style="color: #9CDCFE">context</span><span style="color: #E6E6E6"> );</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #569CD6">virtual</span><span style="color: #E6E6E6"> </span><span style="color: #569CD6">int64_t</span><span style="color: #E6E6E6">     </span><span style="color: #DCDCAA">evalInt64</span><span style="color: #E6E6E6"> ( </span><span style="color: #4EC9B0">Context</span><span style="color: #E6E6E6"> </span><span style="color: #569CD6">&amp;</span><span style="color: #E6E6E6"> </span><span style="color: #9CDCFE">context</span><span style="color: #E6E6E6"> );</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #569CD6">virtual</span><span style="color: #E6E6E6"> </span><span style="color: #569CD6">uint64_t</span><span style="color: #E6E6E6">    </span><span style="color: #DCDCAA">evalUInt64</span><span style="color: #E6E6E6"> ( </span><span style="color: #4EC9B0">Context</span><span style="color: #E6E6E6"> </span><span style="color: #569CD6">&amp;</span><span style="color: #E6E6E6"> </span><span style="color: #9CDCFE">context</span><span style="color: #E6E6E6"> );</span></span>
<span class="line"><span style="color: #E6E6E6">    LineInfo debugInfo;</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #569CD6">virtual</span><span style="color: #E6E6E6"> </span><span style="color: #569CD6">bool</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">rtti_node_isSourceBase</span><span style="color: #E6E6E6">() </span><span style="color: #569CD6">const</span><span style="color: #E6E6E6"> { </span><span style="color: #C586C0">return</span><span style="color: #E6E6E6"> </span><span style="color: #569CD6">false</span><span style="color: #E6E6E6">;  }</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #569CD6">virtual</span><span style="color: #E6E6E6"> </span><span style="color: #569CD6">bool</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">rtti_node_isBlock</span><span style="color: #E6E6E6">() </span><span style="color: #569CD6">const</span><span style="color: #E6E6E6"> { </span><span style="color: #C586C0">return</span><span style="color: #E6E6E6"> </span><span style="color: #569CD6">false</span><span style="color: #E6E6E6">; }</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #569CD6">virtual</span><span style="color: #E6E6E6"> </span><span style="color: #569CD6">bool</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">rtti_node_isInstrument</span><span style="color: #E6E6E6">() </span><span style="color: #569CD6">const</span><span style="color: #E6E6E6"> { </span><span style="color: #C586C0">return</span><span style="color: #E6E6E6"> </span><span style="color: #569CD6">false</span><span style="color: #E6E6E6">; }</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #569CD6">virtual</span><span style="color: #E6E6E6"> </span><span style="color: #569CD6">bool</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">rtti_node_isInstrumentFunction</span><span style="color: #E6E6E6">() </span><span style="color: #569CD6">const</span><span style="color: #E6E6E6"> { </span><span style="color: #C586C0">return</span><span style="color: #E6E6E6"> </span><span style="color: #569CD6">false</span><span style="color: #E6E6E6">; }</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #569CD6">virtual</span><span style="color: #E6E6E6"> </span><span style="color: #569CD6">bool</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">rtti_node_isJit</span><span style="color: #E6E6E6">() </span><span style="color: #569CD6">const</span><span style="color: #E6E6E6"> { </span><span style="color: #C586C0">return</span><span style="color: #E6E6E6"> </span><span style="color: #569CD6">false</span><span style="color: #E6E6E6">; }</span></span>
<span class="line"><span style="color: #E6E6E6">  </span><span style="color: #569CD6">protected:</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #569CD6">virtual</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">~SimNode</span><span style="color: #E6E6E6">() {}</span></span>
<span class="line"><span style="color: #E6E6E6">};</span></span></code></pre></div></div></figure><br>У Sim-ноды есть универсальная функция <code>eval</code>, и частные случаи <code>evalXXX</code> для того, чтобы не делать лишние касты. <code>vec4f</code> в данном случае можно рассматривать не только как конкретный тип (очень полезный именно в геймдеве), но и как 128-битный “передатчик” данных, который в случае необходимости кастится в другим типам с помощью библиотеки <a target="_blank" rel="noopener" href="https://github.com/GaijinEntertainment/vecmath">vecmath</a>, в которой реализован быстрый каст для различных архитектур (HAL) вызовом интринсик-функций.</p>
<p>Сравнение дерева симуляции и байт-код представления:</p>
<ul>
<li>Ноды лежат в памяти плоско в линейном аллокаторе, как и байт-код</li>
<li>Обход дерева не требует интерпретации. Т.е. 1) не нужно сопоставлять байт-коду функцию, и 2) связь между нодами осуществляется по указателям, а не байт-кодом команд передачи управления/через регистры/стек</li>
<li>Типы данных хранятся также, как и в нативном коде, нет кодирования/декодирования аргументов, результатов</li>
<li>Нет ограничения на количество типов нод, когда bind-ится функция, то создаётся кастомная нода, за счёт чего вызов функций быстрый</li>
</ul>
<p>С таким дизайном возможны оптимизации добавлением частных случаев новых типов нод:</p>
<ul>
<li>Упомянутые выше уникальные типы нод для вызова функции</li>
<li>Специализированные версии нод для отдельных типов для чуть более быстрой математики, конкретных специализаций контейнеров (<a target="_blank" rel="noopener" href="https://github.com/GaijinEntertainment/daScript/blob/master/include/daScript/simulate/sim_policy.h">SimPolicy</a>)</li>
<li>Из-за того, что можно не экономить на типах нод, можно в полную силу использовать fusion нескольких нод в одну специализированную</li>
</ul>
<p>Цена большого количества специализированных версий нод — увеличение размера бинарника приложения, поэтому уровень “сплава” нескольких нод в одну регулируется через дефайн <code>DAS_FUSION</code>. 0 - не включать fusion-движок, 1 - “нормальный” уровень слияния, 2 - максимальное количество специализированных нод.</p>
<p>Пример работы fusion-движка:<br><figure class="shiki dascript"><div class="codeblock"><div class="code"><pre class="shiki slack-dark"><code><span class="line"><span style="color: #C586C0">options</span><span style="color: #E6E6E6"> log_nodes</span><span style="color: #D4D4D4">=</span><span style="color: #C586C0">true</span><span style="color: #E6E6E6">, optimize</span><span style="color: #D4D4D4">=</span><span style="color: #C586C0">false</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E6E6E6">[</span><span style="color: #569CD6">export</span><span style="color: #E6E6E6">] </span><span style="color: #6A9955">//оставляем, чтобы оптимизатор не выбросил функцию</span></span>
<span class="line"><span style="color: #569CD6">def</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">test</span><span style="color: #E6E6E6">(a, </span><span style="color: #9CDCFE">b</span><span style="color: #E6E6E6">)</span></span>
<span class="line"><span style="color: #E6E6E6">  </span><span style="color: #C586C0">return</span><span style="color: #E6E6E6"> a </span><span style="color: #D4D4D4">+</span><span style="color: #E6E6E6"> b</span></span></code></pre></div></div></figure></p>
<p>Если изменить значение <code>optimize=true</code>, можно увидеть разницу в количестве нод:</p>
<figure class="shiki"><div class="codeblock"><div class="code"><pre class="shiki slack-dark"><code><span class="line"><span style="color: #E6E6E6">// неоптимизированная версия, 6 нод</span></span>
<span class="line"><span style="color: #E6E6E6">(Return (Add_TT&lt;int&gt; (Ref2Value_TT&lt;int&gt; (GetArgumentRef #0)) (Ref2Value_TT&lt;int&gt; (GetArgumentRef #1))))</span></span>
<span class="line"><span style="color: #E6E6E6"></span></span>
<span class="line"><span style="color: #E6E6E6">// оптимизированная версия, 2 ноды</span></span>
<span class="line"><span style="color: #E6E6E6">(Return (AddArgArg_TT&lt;int&gt; #0 #1))</span></span></code></pre></div></div></figure>
<p>Резюмируя — на скорость в режиме симуляции тут влияют:</p>
<ul>
<li>линейное расположение в памяти</li>
<li>отсутствие оверхеда интерпретации байт-кода</li>
<li>быстрый интероп с хост-языком - отсутствие конвертации аргументов, быстрые вызовы функций</li>
<li>уменьшение количества нод - проходы оптимизации, специализированные и объединённые ноды</li>
</ul>
<p>В сумме это позволяет в режиме интерпретации (без jit, и aot) обогнать самые быстрые интерпретаторы байт-кода с jit-компиляцией.</p>
<p>Опционально ещё:</p>
<ul>
<li>возможность с помощью макросов обработать AST и изменить семантику объявлений для более оптимального расположения в памяти</li>
<li>переопределить для своих типов кастомный <code>simulate</code> для генерации кастомного быстрого кода для их обработки</li>
</ul>
<h2><span id="dajit">daJIT</span><a href="#dajit" class="header-anchor">#</a></h2><p>Кроме режима интерпретации, daScript тоже немного умеет jit-титься:<br><a target="_blank" rel="noopener" href="https://github.com/borisbat/dasXbyak">dasXbyak</a> - для x84/x64 (приостановлен, можно допилить при наличии энтузиазма)<br><a target="_blank" rel="noopener" href="https://github.com/borisbat/dasLLVM">dasLLVM</a> - для всего что может llvm (пока на начальной стадии, перспективнее)<br>jit-компиляция разрешена на PC/Unix/Mac/Web, запрещена на телефонах и консолях (везде, где разрешен запуск только подписанного кода)</p>
<p>А также хорошо AoT транспилироваться в C++-код. Перегонка “руками”:<br><code>daScript.exe -aot test.das test.das.cpp</code><br>или на уровне <a target="_blank" rel="noopener" href="https://github.com/GaijinEntertainment/daScript/blob/master/examples/tutorial/CMakeLists.txt#L36">cmake сборки</a>, настройки AoT кастомизируется на уровне отдельных модулей, функций и типов.<br><a href="/blog/1160489034/" title="daScript in imaginery world">daScript in imaginery world</a> - немного про прирост скорости от AoT-прекомпиляции. В отличие от jit, этим можно воспользоваться на всех платформах.</p>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"Ov23liG1mZbiQOIdi91X","clientSecret":"e05812685eb741a752982b89dcf6f5b58dc10251","repo":"spiiin.github.io","owner":"spiiin","admin":["spiiin"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script></div></article><div class="pagination"><a class="pagination__link pagination__prev" href="/blog/2385889062/">Позже</a><a class="pagination__link pagination__next" href="/blog/3121981810/">Раньше</a></div></main><footer class="footer metadata"><p class="footer__text">© 2024 spiiin</p><p class="footer__text">Powered by <a class="footer__text__link" href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a class="footer__text__link" href="https://pages.github.com/" target="_blank">Github Page</a></p></footer></div><!-- hexo injector body_end start -->
  <script>
  const CODE_CONFIG = {
    beautify: undefined,
    highlightCopy: undefined,
    highlightLang: undefined,
    highlightHeightLimit: undefined,
    isHighlightShrink: undefined,
    copy: {
      success: 'undefined',
      error: 'undefined',
      noSupport: 'undefined',
    }
  };
  console.log(
    `%c hexo-shiki-plugin %c v1.0.27 %c https://github.com/nova1751/hexo-shiki-plugin`,
    "color: #fff; background: #5f5f5f",
    "color: #fff; background: #80c8f8",
    ""
  );
  </script>
  <!-- hexo injector body_end end --></body></html>