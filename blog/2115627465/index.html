<!DOCTYPE html><html lang="ru"><head><meta charset="UTF-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Spiiin's blog | Устройство интерпретаторов lua-jit и daScript</title><meta name="description" content="&lt;p&gt;Устройство виртуальных машин для самых быстрых скриптовых языков — &lt;a href=&quot;https://luajit.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;lua-jit&lt;/a&gt; и &lt;a href=&quot;https://dascript.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;daScript&lt;/a&gt;.&lt;br&gt;Более развёрнутое продолжение беглой заметки &lt;a href=&quot;/blog/1067581840/&quot; title=&quot;daScript - скорость&quot;&gt;daScript - скорость&lt;/a&gt;&lt;/p&gt;"><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=PT+Serif&amp;display=swap"><link rel="stylesheet" href="/css/highlights/darkula.css"><link rel="stylesheet" href="/css/main.css"><link rel="search" type="application/opensearchdescription+xml" href="http://spiiin.github.io/atom.xml" title="Spiiin's blog"><script>(function (i, s, o, g, r, a, m) {
  i['GoogleAnalyticsObject'] = r;
  i[r] = i[r] || function () {
    (i[r].q = i[r].q || []).push(arguments)
  }, i[r].l = 1 * new Date();
  a = s.createElement(o),
    m = s.getElementsByTagName(o)[0];
  a.async = 1;
  a.src = g;
  m.parentNode.insertBefore(a, m)
})(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');
ga('create', 'UA-00000000-0', 'auto');
ga('send', 'pageview');</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Spiiin's blog" type="application/atom+xml">
</head><body><div class="container"><header class="main-header"><h1 class="main-header__title uplize"><a class="main-header__title__link" href="/"><img class="header-image" src="/images/favicon.png" width="36" height="36">Spiiin's blog</a></h1><nav class="main-header__nav"><ul class="main-nav"><li class="main-nav__list"><a class="main-nav__list__link" href="/" target="_self">HOME</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/archives/" target="_self">ARCHIVE</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/tags/meta" target="_self">TAGS</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/blog/1" target="_self">ABOUT</a></li></ul></nav></header><main class="container__wrapper"><div class="pagination"><a class="pagination__link pagination__next" href="/blog/3121981810/">Раньше</a></div><article class="article post"><h3 class="article__title">Устройство интерпретаторов lua-jit и daScript</h3><div class="article__date metadata"><div class="post-info">2022/10/14</div></div><div class="article__tags metadata">Tags:
<a class="article__tags__link metadata" href="/tags/lua/">lua</a><a class="article__tags__link metadata" href="/tags/dascript/">dascript</a></div><div class="article__body"><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Устройство виртуальных машин для самых быстрых скриптовых языков — <a href="https://luajit.org/" target="_blank" rel="noopener">lua-jit</a> и <a href="https://dascript.org/" target="_blank" rel="noopener">daScript</a>.<br>Более развёрнутое продолжение беглой заметки <a href="/blog/1067581840/" title="daScript - скорость">daScript - скорость</a></p>
<a id="more"></a>
<h2 id="Lua"><a href="#Lua" class="headerlink" title="Lua"></a>Lua</h2><p>По <a href="https://github.com/r-lyeh-archived/scriptorium" target="_blank" rel="noopener">бенчмаркам языков</a> <code>lua</code> находится высоко даже в режиме интерпретации.</p>
<p>Первые стадии трансформации текста скрипта — лексический и синтаксический анализ. Текст разбивается на отдельные лексемы/токены, которые затем собираются парсером во что-то, что можно интерпретировать. Чаще всего это или поток последовательных инструкций (байт код для интерпретатора) в случае с <code>lua</code>, или AST(дерево, которое будет обходить интерпретатор) в случае с <code>daScript</code>.</p>
<p>Я не буду заострять внимание на отличиях типов интерпретаторов, детально можно прочитать про это в книге <a href="http://craftinginterpreters.com/" target="_blank" rel="noopener">Crafting Interpreters</a>, с примерами интерпретаторов обоих типов (или даже более <a href="https://gameprogrammingpatterns.com/bytecode.html" target="_blank" rel="noopener">сжато</a>). Интереснее следующий шаг — посмотреть почему именно эти интерпретаторы быстрее других.</p>
<p>“Традиционный” подход к дизайну языков с байт-кодом — динамическая типизация, управление памятью с помощью подсчёта ссылок/garbage collector, небольшой набор базовых типов (примитивы + строки + массивы + функции/замыкания + таблицы, опционально - итераторы, корутины, исключения). Из таблиц (пары ключ-значения) можно построить объекты и “собрать” классы — некоторые ключи таблицы делаем зарезервированными, вызывая их для создания/удаления объектов, ссылки на родительскую таблицу, перегрузки операторов и т.п.</p>
<p>Возможные оптимизации:</p>
<ul>
<li>Так как чаще всего данные группируются в объекты (представленные таблицами) — то очень важна быстрая реализация этих хеш-таблиц, в чём lua традиционна считается хорошей.</li>
<li><a href="http://craftinginterpreters.com/optimization.html#nan-boxing" target="_blank" rel="noopener">Nan-tagging</a> — распространённая паковка базовых типов языка виртуальной машины в тип <code>double</code>. Возникает отчасти из желания хранить примитивные типы в той же форме, что и сложные — в динамически типизированном языке нужно где-то сохранить в том числе и тип аргумента, чтобы знать, как его интерпретировать, и при этом не хочется иметь оверхед для примитивных типов. </li>
</ul>
<p>Отчасти из этой оптимизаций возникает ограничение на количество базовых типов языка — с точки зрения скриптового языка два класса будут иметь разные типы, но для интерпретатора виртуальной машины они оба будут представлены типом “таблица”, и отличаться только значением ключа “название класса”. Также любой вызов метода означает поиск его в таблице. Ещё один минус — требование “раскодировать” аргументы из запакованной формы при взаимодействии с нативным кодом, из-за чего замедляется передача управления в хост язык и обратно. Т.е. нельзя оптимизировать код, просто переносом мелких функций в хост-язык — необходимо переписывать сразу большие куски кода.</p>
<ul>
<li>Поиск частых паттернов в инструкциях. <a href="http://craftinginterpreters.com/methods-and-initializers.html#optimized-invocations" target="_blank" rel="noopener">Optimizing invocation</a> — пример слияния пары инструкций “получение метода класса + вызов метода”. В общем случае, метод может быть получен не для вызова, а для сохранения в переменную, но чаще всего вызывается напрямую, так что две инструкции, идущие подряд, можно “слить” в одну. В lua вроде не применяется, но повсеместно юзается в daScript, примеры приведу дальше. Оптимизация известна под названиями <code>Instruction fusion</code> или <code>Super-instructions</code>.</li>
</ul>
<h2 id="Tracing-JIT"><a href="#Tracing-JIT" class="headerlink" title="Tracing JIT"></a>Tracing JIT</h2><p>Основная сила lut-jit - just-in-time компиляция. Каждый раз, при вызовах функций и циклов (<code>thermal function/cycle</code>), интерпретатор подсчитывает количество таких вызовов, и таким образом, определяет “горячий” код. Алгоритм подсчёта (NLF region-selection) также умеет обнаруживать вложенные циклы и вызовы.</p>
<p>При достижении предельного количества вызовов, интерпретатор выполняет отмеченный участок кода с “трассированием”, то есть кроме выполнения инструкции дополнительно сохраняет её же в список инструкций — уже на другом байт-код языке (intermediate representation, <a href="http://webcache.googleusercontent.com/search?q=cache:U5V-zQuM-ikJ:wiki.luajit.org/SSA-IR-2.0&amp;cd=1&amp;hl=ru&amp;ct=clnk&amp;gl=am" target="_blank" rel="noopener">спек</a>).</p>
<p>После записи всех инструкций из IR генерируется машинный код, и следующий вызов этого участка кода уже приведёт к тому, чтобы будет вызвана нативная версия кода. Подмена способов вызова функции реализована с помощью патчинга оп-кодов байт-кода lua (call gates).</p>
<p>Генерация нативного машинного кода разрешена не на всех платформах/ОС (память для выполнения нативного кода защищена от записи), поэтому недоступна для части платформ. Также нативный код для различных архитектур отличается, поэтому добавление новой платформы может требовать написания отдельного генератора кода.</p>
<p><a href="http://lua-users.org/lists/lua-l/2009-11/msg00089.html" target="_blank" rel="noopener">Список особенностей</a> jit-компилятора lua:</p>
<ul>
<li>оптимизация IR-кода - сворачивание и выбрасывание неиспользуемых блоков</li>
<li>при возврате из нативной части кода в интерпретируемую, оптимизиуется восстановление состояния виртуальной машины, сохраняются “дифы” между состояниями</li>
<li>типизация аргументов, при трассировании кода записываются реальные типы переменных</li>
</ul>
<p>Тривиальный пример, с неизвестными типами аргументов:<br><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(t, k)</span></span></span><br><span class="line">    <span class="keyword">return</span> t[k]</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><br>Может быть интерпретирован различными способами - t может быть таблицей или любым типом, у которого установлена метатаблица, k - числом, строкой или любым типом, и даже [] - метаметодом. В принципе, этот код может со всеми возможными комбинациями задействовать половину ветвей интерпретации ядра lua. Но если трассирующий компилятор запишет реально используемые типы, то он может сгенерировать быстрый нативный код, к примеру индексации массива (сгенерировав предварительно код проверки типов аргументов). Это даёт ускорение ~3 раза, по <a href="https://staff.fnwi.uva.nl/h.vandermeer/docs/lua/luajit/luajit_intro.html#:~:text=As%20the%20name%20says%20LuaJIT,are%20not%20compiled%20at%20all." target="_blank" rel="noopener">замерам</a> авторов.</p>
<h2 id="daScript"><a href="#daScript" class="headerlink" title="daScript"></a>daScript</h2><p>daScript серьёзно отличается от “традиционных” скриптовых языков.</p>
<p>В первую очередь — на выходе синтаксического анализатора получается на байт-код, а абстрактное синтаксическое дерево, причём типизированное.</p>
<p>Типизация немного усложняет изучение языка, но позволяет избавиться от огромного количества ошибок типов. Если рассмотреть синтетический пример на lua, то обнаружить фактические типы аргменутов t и k может быть сложно в цепочке вызовов, а проверить их корректность можно только в рантайме. Представьте, что <code>foo</code> ожидает в качестве t список из строк и выбирает из него первый элемент (допустим, сортированный список допустимых фраз персонажа игры). Список составляется и сортируется динамически. На каком-то этапе в ходе рефактора программист добавляет дополнительную функцию в цепочку вызовов, которая проверяет граничное условие (не то, чтобы это хороший код или пример, но подобную ошибку с подменой списка строкой встречал много раз):</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkIfGameOver</span><span class="params">(t, k)</span></span></span><br><span class="line">    <span class="keyword">if</span> life &lt;= <span class="number">0</span> <span class="keyword">then</span> </span><br><span class="line">        foo(<span class="string">"game over!"</span>, k) //вместо foo([<span class="string">"game over!"</span>], k)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        foo(t, k)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>Если условие редкое, и код кажется программисту слишком тривиальным, чтобы его проверить в рантайме, баг может остаться незамеченным для ревьюера, а то и для QA. В типизированном языке ошибка бы скорее всего обнаружилась компилятором.</p>
<p>Представление в виде AST, а не байт-кода, упрощает генерацию и анализ кода, например — с ним работают <a href="/blog/1547564887/" title="макросы">макросы</a>, а также упрощается написание тулзов, анализирующих код.</p>
<p>На уровне AST намного удобнее проводить оптимизации, в этот момент интерпретатор иметь достаточно много информации о коде. <code>daScript</code> позволяет изучить код на каждом шаге оптимизации. Простейший пример:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//log_optimization_passes - выводит результаты всех промежуточных стадий оптимизации AST</span></span><br><span class="line">options optimize=<span class="literal">true</span>, log_optimization_passes = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">def test(cond, a, b)</span><br><span class="line">    <span class="keyword">if</span> cond</span><br><span class="line">        <span class="keyword">return</span> a + b</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main()</span><br><span class="line">    print(<span class="string">"&#123;test(true, 2, 2)&#125;\n"</span>)</span><br></pre></td></tr></table></figure>
<p>После стадии <code>CONST_FOLDING</code> можно увидеть, что AST “свернулся” до:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;4&#125;\n"</span>)</span></span></span><br></pre></td></tr></table></figure></p>
<p>После оптимизаций <code>daScript</code> <strong>не интерпретирует AST</strong> и <strong>не генерирует</strong> байт-код. Вместо этого генерируется <a href="https://github.com/GaijinEntertainment/daScript/blob/master/src/ast/ast_simulate.cpp#L2912" target="_blank" rel="noopener">дерево симуляции</a>. На этом этапе также происходит оптимизация — AST ноды “отбрасывают” ненужную для симуляции информацию, например, информацию о типах (она больше не нужна, типы известны и статически проверены на уровне AST), и умеют генерировать более оптимизированные частные случаи (<a href="simulate">симуляция</a> simulate-ноды из ast-ноды ifThenElse, ветка <em>//good old if</em> - дефолтный вариант, остальные — оптимизированные).</p>
<p>Базовый класс нод simulate-ноды<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SimNode</span> &#123;</span></span><br><span class="line">    SimNode ( <span class="keyword">const</span> LineInfo &amp; at ) : debugInfo(at) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> SimNode * <span class="title">copyNode</span> <span class="params">( Context &amp; context, NodeAllocator * code )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> vec4f <span class="title">eval</span> <span class="params">( Context &amp; )</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> SimNode * <span class="title">visit</span> <span class="params">( SimVisitor &amp; vis )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> *      <span class="title">evalPtr</span> <span class="params">( Context &amp; context )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span>        <span class="title">evalBool</span> <span class="params">( Context &amp; context )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span>       <span class="title">evalFloat</span> <span class="params">( Context &amp; context )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span>      <span class="title">evalDouble</span> <span class="params">( Context &amp; context )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int32_t</span>     <span class="title">evalInt</span> <span class="params">( Context &amp; context )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">uint32_t</span>    <span class="title">evalUInt</span> <span class="params">( Context &amp; context )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int64_t</span>     <span class="title">evalInt64</span> <span class="params">( Context &amp; context )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">uint64_t</span>    <span class="title">evalUInt64</span> <span class="params">( Context &amp; context )</span></span>;</span><br><span class="line">    LineInfo debugInfo;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">rtti_node_isSourceBase</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>;  &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">rtti_node_isBlock</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">rtti_node_isInstrument</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">rtti_node_isInstrumentFunction</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">rtti_node_isJit</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~SimNode() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>У Sim-ноды есть универсальная функция <code>eval</code>, и частные случаи <code>evalXXX</code> для того, чтобы не делать лишние касты. <code>vec4f</code> в данном случае можно рассматривать не только как конкретный тип (очень полезный именно в геймдеве), но и как 128-битный “передатчик” данных, который в случае необходимости кастится в другим типам с помощью библиотеки <a href="https://github.com/GaijinEntertainment/vecmath" target="_blank" rel="noopener">vecmath</a>, в которой реализован быстрый каст для различных архитектур (HAL) вызовом интринсик-функций.</p>
<p>Сравнение дерева симуляции и байт-код представления:</p>
<ul>
<li>Ноды лежат в памяти плоско в линейном аллокаторе, как и байт-код</li>
<li>Обход дерева не требует интерпретации. Т.е. 1) не нужно сопоставлять байт-коду функцию, и 2) связь между нодами осуществляется по указателям, а не байт-кодом команд передачи управления/через регистры/стек</li>
<li>Типы данных хранятся также, как и в нативном коде, нет кодирования/декодирования аргументов, результатов</li>
<li>Нет ограничения на количество типов нод, когда bind-ится функция, то создаётся кастомная нода, за счёт чего вызов функций быстрый</li>
</ul>
<p>С таким дизайном возможны оптимизации добавлением частных случаев новых типов нод:</p>
<ul>
<li>Упомянутые выше уникальные типы нод для вызова функции</li>
<li>Специализированные версии нод для отдельных типов для чуть более быстрой математики, конкретных специализаций контейнеров (<a href="https://github.com/GaijinEntertainment/daScript/blob/master/include/daScript/simulate/sim_policy.h" target="_blank" rel="noopener">SimPolicy</a>)</li>
<li>Из-за того, что можно не экономить на типах нод, можно в полную силу использовать fusion нескольких нод в одну специализированную</li>
</ul>
<p>Цена большого количества специализированных версий нод — увеличение размера бинарника приложения, поэтому уровень “сплава” нескольких нод в одну регулируется через дефайн <code>DAS_FUSION</code>. 0 - не включать fusion-движок, 1 - “нормальный” уровень слияния, 2 - максимальное количество специализированных нод.</p>
<p>Пример работы fusion-движка:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">options log_nodes=<span class="literal">true</span>, optimize=<span class="literal">false</span></span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>] <span class="comment">//оставляем, чтобы оптимизатор не выбросил функцию</span></span><br><span class="line">def test(a, b)</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br></pre></td></tr></table></figure></p>
<p>Если изменить значение <code>optimize=true</code>, можно увидеть разницу в количестве нод:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; неоптимизированная версия, 6 нод</span><br><span class="line">(Return (Add_TT&lt;int&gt; (Ref2Value_TT&lt;int&gt; (GetArgumentRef #0)) (Ref2Value_TT&lt;int&gt; (GetArgumentRef #1))))</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; оптимизированная версия, 2 ноды</span><br><span class="line">(Return (AddArgArg_TT&lt;int&gt; #0 #1))</span><br></pre></td></tr></table></figure>
<p>Резюмируя — на скорость в режиме симуляции тут влияют:</p>
<ul>
<li>линейное расположение в памяти</li>
<li>отсутствие оверхеда интерпретации байт-кода</li>
<li>быстрый интероп с хост-языком - отсутствие конвертации аргументов, быстрые вызовы функций</li>
<li>уменьшение количества нод - проходы оптимизации, специализированные и объединённые ноды</li>
</ul>
<p>В сумме это позволяет в режиме интерпретации (без jit, и aot) обогнать самые быстрые интерпретаторы байт-кода с jit-компиляцией.</p>
<p>Опционально ещё:</p>
<ul>
<li>возможность с помощью макросов обработать AST и изменить семантику объявлений для более оптимального расположения в памяти</li>
<li>переопределить для своих типов кастомный <code>simulate</code> для генерации кастомного быстрого кода для их обработки</li>
</ul>
<h2 id="daJIT"><a href="#daJIT" class="headerlink" title="daJIT"></a>daJIT</h2><p>Кроме режима интерпретации, daScript тоже немного умеет jit-титься:<br><a href="https://github.com/borisbat/dasXbyak" target="_blank" rel="noopener">dasXbyak</a> - для x84/x64 (приостановлен, можно допилить при наличии энтузиазма)<br><a href="https://github.com/borisbat/dasLLVM" target="_blank" rel="noopener">dasLLVM</a> - для всего что может llvm (пока на начальной стадии, перспективнее)<br>jit-компиляция разрешена на PC/Unix/Mac/Web, запрещена на телефонах и консолях (везде, где разрешен запуск только подписанного кода)</p>
<p>А также хорошо AoT транспилироваться в C++-код. Перегонка “руками”:<br><code>daScript.exe -aot test.das test.das.cpp</code><br>или на уровне <a href="https://github.com/GaijinEntertainment/daScript/blob/master/examples/tutorial/CMakeLists.txt#L36" target="_blank" rel="noopener">cmake сборки</a>, настройки AoT кастомизируется на уровне отдельных модулей, функций и типов.<br><a href="/blog/1160489034/" title="daScript in imaginery world">daScript in imaginery world</a> - немного про прирост скорости от AoT-прекомпиляции. В отличие от jit, этим можно воспользоваться на всех платформах.</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script></div></article><div class="pagination"><a class="pagination__link pagination__next" href="/blog/3121981810/">Раньше</a></div></main><footer class="footer metadata"><p class="footer__text">© 2022 spiiin</p><p class="footer__text">Powered by <a class="footer__text__link" href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a class="footer__text__link" href="https://pages.github.com/" target="_blank">Github Page</a></p></footer></div></body></html>