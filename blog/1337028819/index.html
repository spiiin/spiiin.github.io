<!DOCTYPE html><html lang="ru"><head><meta charset="UTF-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Spiiin's blog | Немного о проектировании</title><meta name="description" content="&lt;p&gt;Дамп мыслей про проектирование систем, как обычно, с уклоном в геймдев.&lt;br&gt;"><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=PT+Serif&amp;display=swap"><link rel="stylesheet" href="/css/highlights/darkula.css"><link rel="stylesheet" href="/css/main.css"><link rel="search" type="application/opensearchdescription+xml" href="http://spiiin.github.io/atom.xml" title="Spiiin's blog"><script>(function (i, s, o, g, r, a, m) {
  i['GoogleAnalyticsObject'] = r;
  i[r] = i[r] || function () {
    (i[r].q = i[r].q || []).push(arguments)
  }, i[r].l = 1 * new Date();
  a = s.createElement(o),
    m = s.getElementsByTagName(o)[0];
  a.async = 1;
  a.src = g;
  m.parentNode.insertBefore(a, m)
})(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');
ga('create', 'UA-00000000-0', 'auto');
ga('send', 'pageview');</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Spiiin's blog" type="application/atom+xml">
</head><body><div class="container"><header class="main-header"><h1 class="main-header__title uplize"><a class="main-header__title__link" href="/"><img class="header-image" src="/images/favicon.png" width="36" height="36">Spiiin's blog</a></h1><nav class="main-header__nav"><ul class="main-nav"><li class="main-nav__list"><a class="main-nav__list__link" href="/" target="_self">HOME</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/archives/" target="_self">ARCHIVE</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/tags/meta" target="_self">TAGS</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/blog/1" target="_self">ABOUT</a></li></ul></nav></header><main class="container__wrapper"><div class="pagination"><a class="pagination__link pagination__prev" href="/blog/1567638407/">Позже</a><a class="pagination__link pagination__next" href="/blog/3914071471/">Раньше</a></div><article class="article post"><h3 class="article__title">Немного о проектировании</h3><div class="article__date metadata"><div class="post-info">2023/02/19</div></div><div class="article__tags metadata">Tags:
<a class="article__tags__link metadata" href="/tags/dev-evolution/">dev_evolution</a><a class="article__tags__link metadata" href="/tags/dev-method/">dev_method</a></div><div class="article__body"><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Дамп мыслей про проектирование систем, как обычно, с уклоном в геймдев.<br><a id="more"></a></p>
<h2 id="Cohesion-and-Coupling"><a href="#Cohesion-and-Coupling" class="headerlink" title="Cohesion and Coupling"></a>Cohesion and Coupling</h2><p><a href="https://en.wikipedia.org/wiki/Cohesion_(computer_science%29" target="_blank" rel="noopener">Cohesion</a> — степень смысловой связи между сгруппированными элементами (функциями в классе или модуле).<br><a href="https://en.wikipedia.org/wiki/Coupling_(computer_programming%29" target="_blank" rel="noopener">Coupling</a> — степень запутанности связи между модулями.</p>
<p><img src="/blog/1337028819/coupling_small.png" alt=""><br>Хороший вариант дизайна — высокая cohesion и низкая coupling.</p>
<p>Примеры модулей, в которых скорее всего окажется <code>низкий cohesion</code>:</p>
<ul>
<li>Utils - сгруппировано все небольшие функции</li>
<li>GameObject - в котором при ООП дизайне рано или поздно собирается весь функционал, который может потребоваться потомкам (анти-паттерны GodObject/Blob)</li>
</ul>
<p>Примеры модулей, которые скорее всего могут быть связаны с другими (<code>высокий coupling</code>) - системы логгирования, профилирования.<br>Подсистемы также связываются на уровне реализации игровой логики — звук шагов задействует подсистемы анимации, звука, физики. Сильно лучше, если подсистемы связаны не между собой, а на отдельном слое связывания.</p>
<h2 id="Компоненты"><a href="#Компоненты" class="headerlink" title="Компоненты"></a>Компоненты</h2><p>Для подсистем с высокой cohesion и низкой coupling встречается название <strong><code>компоненты</code></strong>, за счет того, что они изолированы друг от друга и могут переиспользоваться.<br>Один из приемов проектирования — строить программу из компонентов.</p>
<p>Между слоем компонентов и логики приложения могут лежать и промежуточные слои библиотек:</p>
<p><img src="/blog/1337028819/components_levels_small.png" alt=""><br><em>(картинка из книги John Lacos - Large-Scale C++ )</em></p>
<p>Однако при этом часто на среднем уровне библиотека не оформлена в виде компонентов или даже компоненты на спроектированы так, чтобы использоваться вне библиотеки очень высокого уровня.</p>
<p>Примеры библиотек:<br>В которых сложно “оторвать компоненты” для использования вне библиотеки (в плане coupling, иногда заниматься отрыванием может мешать и лицензия библиотеки): <code>Qt</code><br>Средний уровень сложности: <code>boost</code> (зависит от конкретной библиотеки, некоторые отрываются неплохо, некоторые тянут за собой в зависимостях половину библиотеки), <code>entt</code> (для примера — оторвать basic_sparse_set/basic_storage можно, но требует усилий)<br>Легко отделить компоненты: <a href="https://github.com/tamasmeszaros/libnest2d" target="_blank" rel="noopener">libnest2d</a> - надстроена над <code>clipper/nlopt/boost.geometry</code>, вполне позволяет подменить любую из этих библиотек</p>
<h2 id="Зависимости-от-компонентов-и-свойства-API"><a href="#Зависимости-от-компонентов-и-свойства-API" class="headerlink" title="Зависимости от компонентов и свойства API"></a>Зависимости от компонентов и свойства API</h2><p>По субъективному опыту — для open-source библиотек можно найти качественные компоненты более “низкого” уровня (то, что можно забросить в 3rdPartyLibs), библиотеки среднего уровня чаще всего (если не считать движения свободного кода) — проприетарная собственность компаний (1stPartyLibs), так как требуют серьёзного уровня поддержки, который сложно поддерживать небольшой группе разработчиков, а также могут быть заточены под нужды конкретной компании. В Large-Scale C++ такие компоненты, накопленные компаниями, упоминаются, как <code>software capital</code>. Большие open-source библиотеки компонентов часто появляются как открытие накопленного корпорацией software capital (<code>abseil</code>, <code>folly</code>).</p>
<p>Еще одно интересное свойство компонент, которое влияет на простоту их использования — компактность их API. Так как библиотеки “среднего” уровня могут быть достаточно объёмными, Эрик Реймонд в книге “Искусство программирования для UNIX” вводит термин <code>полукомпактность</code> для систем, которые позволяет решать с их помощью большинство задач, используя только небольшую и наиболее используемую компактную часть их API. В качестве примеров полукомпактных систем он приводит <code>html</code> или язык <code>c</code> (не c++).</p>
<p><a href="https://www.youtube.com/watch?v=ZQ5_u8Lgvyk" target="_blank" rel="noopener">Designing and Evaluating Reusable Components - 2004</a> — доклад Casey Muratori (соавтор библиотек <a href="http://www.radgametools.com/granny.html" target="_blank" rel="noopener">Granny 3D</a>, которая изолирует нижний уровень компонет - “лист” на графе), про дизайн компонентов и виды зависимостей, которые они могут добавлять на уровне, который их использует. На скриншоте с графом уровней компонент выше рёбра — это абстрактное “использование” компонент, доклад разбирает виды и характеристики этих соединений.</p>
<p><img src="/blog/1337028819/reuse_small.png" alt=""></p>
<p>Свойства API:</p>
<p><code>Разделяемость (Granularity)</code><br>Возможность установить/изменить параметры за несколько вызовов — вставить действие между между ними.<br>Гибкость VS простота</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Orientation = GetOrientation(Object)</span><br><span class="line">Change = GetOrientationChange(Object)</span><br><span class="line">Change += <span class="number">3.14f</span>                <span class="comment">//</span></span><br><span class="line">RunSomeOtherUnrelatedTthing()  <span class="comment">// возможность поменять отложенно</span></span><br><span class="line">SetOrientation(Object, Orientation + Change)</span><br></pre></td></tr></table></figure>
<p><code>Избыточность (Redundancy)</code><br>Возможность выполнить действия несколькими способами<br>Удобство VS ортогональность</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//установка направления с помощью матрицы</span></span><br><span class="line">SetOrientation3x3(Object, Matrix)</span><br><span class="line"><span class="comment">//то же самое с помощью кватерниона</span></span><br><span class="line">SetOrientationQ(Object, Quat)</span><br><span class="line"><span class="comment">//то же самое с помощью заготовленных разработчиками методов/констант</span></span><br><span class="line">IdentityOrientation(Object)</span><br><span class="line">FaceForward(Object)</span><br></pre></td></tr></table></figure>
<p><code>Cвязанность (Coupling)</code><br>Зависимости между частями системы (почти всегда плохо, не часто неизбежно)<br>Несвязанность VS запутанность (<a href="https://www.youtube.com/watch?v=SxdOUGdseq4 -- более детально" target="_blank" rel="noopener">“Simple Made Easy” - Rich Hickey (2011)</a>)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//неразделяемый апдейт всего (к примеру, физики)</span></span><br><span class="line">UpdateEverything(World)</span><br><span class="line"></span><br><span class="line"><span class="comment">//нужно установить состояние, прежде чем сделать что-то,</span></span><br><span class="line"><span class="comment">//  возможно скрыто</span></span><br><span class="line">SetTime(GlobalTime) </span><br><span class="line">UpdateObject(Object)</span><br><span class="line"></span><br><span class="line"><span class="comment">//возможность настройки только внутри пары вызовов</span></span><br><span class="line"><span class="comment">// часто подразумевает "не должно быть вложенности"</span></span><br><span class="line">BeginObjectSpecification()</span><br><span class="line">SetObjectState(Param1, Value1)</span><br><span class="line">Object = EndObjectSpecification()</span><br><span class="line"></span><br><span class="line"><span class="comment">//Использование скрытого общего буфера</span></span><br><span class="line"><span class="comment">// на который могут указывать String1 и String2</span></span><br><span class="line">String1 = GetMungedName(Name1)</span><br><span class="line">String2 = GetMungedName(Name2)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Нельзя сказать "у меня уже есть выделенная память, на которой нужно построить объект"</span></span><br><span class="line"><span class="comment">// или "выдели объект, но я инициализирую его, у меня кастомные инициализаторы из архивов"</span></span><br><span class="line">Object = AllocateAndInitialize()</span><br><span class="line"></span><br><span class="line"><span class="comment">//нужно обязательно создавать кастомный тип, хотя клиент может иметь тип для представления</span></span><br><span class="line"><span class="comment">// пример - QString для апи QT</span></span><br><span class="line">Matrix = MakeMatrixFrom(FloatPointer)</span><br><span class="line">SetOrientation(Object, Matrix)</span><br><span class="line"></span><br><span class="line"><span class="comment">//связь с форматом файла, нельзя создать самому,</span></span><br><span class="line"><span class="comment">//  зависимость от формата и I/O функций</span></span><br><span class="line">Object = ReadObject(filename)</span><br></pre></td></tr></table></figure>
<p><code>Запоминание (Retention)</code><br>Сохранение переданной ранее информации<br>Ведет к дублирование описания мира “внутри” библиотеки и в пользовательском коде<br>Сложность синхронизации состояний (комбинаторный рост от количества параметров) VS автоматизация работы после настройки</p>
<p>Immediate mode API (<a href="https://github.com/ocornut/imgui" target="_blank" rel="noopener">imgui</a> как пример) — одна из идея отказа от запоминания</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Настройка значений, которые повлияют на последующие вычисления</span></span><br><span class="line">SetTime(GlobalTime)</span><br><span class="line">SetPi(<span class="number">3.14f</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//изменение положение потомка также зависит от родителя</span></span><br><span class="line">SetParent(ChildObject, ParentObject)</span><br><span class="line">UpdateOrientation(ChildObject)</span><br></pre></td></tr></table></figure>
<p>Возможно, к “запоминанию” состояния можно отнести также некоторые идеи, которые предлагаются паттернами и парадигмами программирования:</p>
<ul>
<li>Асинхронное программирование с запоминанием точек продолжения программы (async/await)</li>
<li>Реактивное программирование, с запоминаем настроенных потоков данных</li>
<li>Декларативное программирование, с выполнением кода на какой-либо настроенной или заполненной ранее модели/системе</li>
</ul>
<p><code>Порядок вызовов (Flow Control)</code><br>Вызывает ли библиотека колбеки приложения или приложение функции библиотеки (и зовут ли функции библиотеки колбеки из приложения). Чем чаще необходимо осуществлять передачу управления, тем сложнее отслеживать это пользователю библиотеки.<br>Контроль на стороне приложения (почти всегда лучше) VS на стороне библиотеки</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Для открытия файла будет вызван колбек Open</span></span><br><span class="line">SetFileCallbacks(Open, Read, Close)</span><br><span class="line">File = OpenFile(Filemame)</span><br><span class="line"></span><br><span class="line"><span class="comment">//То же самое, но спрятано за ООП,</span></span><br><span class="line"><span class="comment">// где-то скрыто сохранён указатель на функцию открытия</span></span><br><span class="line">class MyHandler: <span class="keyword">public</span> LibraryHandler &#123;</span><br><span class="line">  <span class="keyword">virtual</span> <span class="keyword">void</span> Open(<span class="keyword">char</span>* Filename)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Ещё про свойства библиотек — <a href="/blog/1152347544/" title="Хорошие библиотеки">Хорошие библиотеки</a></p>
<h2 id="Копирование-лучших"><a href="#Копирование-лучших" class="headerlink" title="Копирование лучших"></a>Копирование лучших</h2><p>Вместо написания чего-то с нуля нужно использовать или копировать лучших (смысл не пользоваться накоплненным software capital?).</p>
<ul>
<li>Черновая реализация на несколько оптимизаций отстает от оптимальной</li>
<li>Часто оптимальная может так сильно отличаться от наивной, что переделать станет сложно/невозможно</li>
<li>Для понимания оптимальной версии может потребоваться больше времени, и знаний для сравнения, чем для написания наивной</li>
</ul>
<p>Кроме оптимизаций, готовый код содержит фиксы множества ошибок, найденные за время его использования. Джоэл Спольски в эссе <a href="https://www.joelonsoftware.com/2000/04/06/things-you-should-never-do-part-i/" target="_blank" rel="noopener">Things You Should Never Do</a> расписывает печально известную проектировщикам истину — простой код, написанный с чистого листа, сильно отстаёт от давно написанного сложного, но отлаженного.</p>
<p>При этом копирование плохо работает в чём-то, отличном от кода. <a href="https://vadzimv.dev/2020/03/07/childs-illusions.html" target="_blank" rel="noopener">Книжки не заменяют опыта</a>, но обещают успех в случае повторения внешних признаков (чтобы понять границы применимости общих техник, необходимо колоссальное количество опыта).</p>
<h2 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h2><p><strong><code>Data oriented</code></strong></p>
<ul>
<li>сначала кажется непривычным</li>
<li>так как (в случае, если мы думаем о локальности данных в памяти) подстраивается под данные, иногда требует дублирования кода под новые данные<br>(редко встречается достаточно генерик код, который может работать с кастомными структурами)</li>
<li>когда подстроишься под то, чтобы думать о расположении данных в памяти, становится сильно проще</li>
</ul>
<p>В геймдеве часто производительность имеет значение:</p>
<ul>
<li>там где ограниченные ресурсы - <a href="http://ru.esotericsoftware.com/" target="_blank" rel="noopener">Spine</a>-анимации для мобильных игр начинают тормозить уже на тех телефонах, но которых запускается Fortnite, при этом разработчиков не особо волнует эта проблема. <a href="https://youtu.be/rX0ItVEVjHc?t=4645" target="_blank" rel="noopener">Ответ</a> Mike Acton на позицию “We want not care about this stuff” - “из-за вас я должен ждать 2 минуты, пока открывается word”.</li>
<li>там где конкуренция, кто может выдать круче результат (точнее рассчёт физики, освещения, анимаций, ии)</li>
<li>там где платишь за сервера. <a href="https://youtu.be/KxQpDIKwGUw?t=2399" target="_blank" rel="noopener">Ответ</a> Максима Барышникова про то, зачем WoT сохраняется поддержка распределенных между серверами арен — на одном сервере помещается 3 арены, но за счёт того, что движок поддерживает разбиение, можно разместить 7 арен на 2х серверах (по 3.5 на сервер), а не на 3х, плюс можно динамически балансировать рассчёты, если все 4 арены одновременно становятся максимально нагруженными.</li>
</ul>
<p><strong><code>Performance if a feature</code></strong></p>
<ul>
<li>там где количество может переходить в качество, давать новые фичи. Например, без оптимизаций можем сделать RTS, в которых у игрока будет только 100 юнитов, а оптимизациями - как 100, так и 10000 - геймдизайнеры могут сделать фичей огромные армии, или более быстрая обработка позволяет “запихнуть” в освободившееся время ещё что-нибудь интересное.</li>
</ul>
<p>Кроме производительности конечной программы, немаловажно <strong><code>время сборки/пересборки и производительность дебажного билда</code></strong> (отлаживать не небажный билд добровольно — не очень весело).</p>
<p><a href="https://aras-p.info/blog/2018/12/28/Modern-C-Lamentations/" target="_blank" rel="noopener">“Modern” C++ Lamentations</a> — важная и большая статья о состоянии этого в современном C++ с большим количеством ссылок и сравнениями (<em>серьёзно, тот случай, когда стоит изучить каждую ссылку из статьи</em>). Кто-то пишет на ограниченном С++ (<code>Orthodox C++</code>), переучивая коллег и новичков, кто-то выбирает и создаёт альтернативные библиотеки (<code>EASTL</code>), кто-то переходит на другие языки (<code>Rust, Jai, Burst C#, daScript</code>).</p>
<ul>
<li><a href="/blog/1728194429/" title="С++ в геймдеве">С++ в геймдеве</a> — мой обзор применения C++ для разработки игр</li>
</ul>
<p><a href="https://www.youtube.com/watch?v=NAVbI1HIzCE" target="_blank" rel="noopener">Practical Optimizations</a> — доклад Jason Booth c измерениями производительности DoD кода. Важный тезис — <strong><code>optimization is a DESIGN time problem</code></strong>. Если не организовать данные в памяти сразу, переделать будет сложно. В докладе есть нестандартные примеры оптимизаций.</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script></div></article><div class="pagination"><a class="pagination__link pagination__prev" href="/blog/1567638407/">Позже</a><a class="pagination__link pagination__next" href="/blog/3914071471/">Раньше</a></div></main><footer class="footer metadata"><p class="footer__text">© 2023 spiiin</p><p class="footer__text">Powered by <a class="footer__text__link" href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a class="footer__text__link" href="https://pages.github.com/" target="_blank">Github Page</a></p></footer></div></body></html>