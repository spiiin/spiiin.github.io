<!DOCTYPE html><html lang="ru"><head><meta charset="UTF-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Spiiin's blog | С++ в геймдеве</title><meta name="description" content="&lt;p&gt;Немного о том, почему в геймдеве используется C++, как именно он используется, и всё ли с этим правильно.&lt;br&gt;"><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=PT+Serif&amp;display=swap"><link rel="stylesheet" href="/css/highlights/darkula.css"><link rel="stylesheet" href="/css/main.css"><link rel="search" type="application/opensearchdescription+xml" href="http://spiiin.github.io/atom.xml" title="Spiiin's blog"><script>(function (i, s, o, g, r, a, m) {
  i['GoogleAnalyticsObject'] = r;
  i[r] = i[r] || function () {
    (i[r].q = i[r].q || []).push(arguments)
  }, i[r].l = 1 * new Date();
  a = s.createElement(o),
    m = s.getElementsByTagName(o)[0];
  a.async = 1;
  a.src = g;
  m.parentNode.insertBefore(a, m)
})(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');
ga('create', 'UA-00000000-0', 'auto');
ga('send', 'pageview');</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Spiiin's blog" type="application/atom+xml">
</head><body><div class="container"><header class="main-header"><h1 class="main-header__title uplize"><a class="main-header__title__link" href="/"><img class="header-image" src="/images/favicon.png" width="36" height="36">Spiiin's blog</a></h1><nav class="main-header__nav"><ul class="main-nav"><li class="main-nav__list"><a class="main-nav__list__link" href="/" target="_self">HOME</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/archives/" target="_self">ARCHIVE</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/tags/meta" target="_self">TAGS</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/blog/1" target="_self">ABOUT</a></li></ul></nav></header><main class="container__wrapper"><div class="pagination"><a class="pagination__link pagination__prev" href="/blog/1547564887/">Позже</a><a class="pagination__link pagination__next" href="/blog/37481721/">Раньше</a></div><article class="article post"><h3 class="article__title">С++ в геймдеве</h3><div class="article__date metadata"><div class="post-info">2022/01/30</div></div><div class="article__tags metadata">Tags:
<a class="article__tags__link metadata" href="/tags/cpp/">cpp</a><a class="article__tags__link metadata" href="/tags/dev-method/">dev_method</a><a class="article__tags__link metadata" href="/tags/gamedev/">gamedev</a><a class="article__tags__link metadata" href="/tags/dascript/">dascript</a><a class="article__tags__link metadata" href="/tags/longread/">longread</a></div><div class="article__body"><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Немного о том, почему в геймдеве используется C++, как именно он используется, и всё ли с этим правильно.<br><a id="more"></a></p>
<h1 id="Почему"><a href="#Почему" class="headerlink" title="Почему"></a>Почему</h1><p>Тут всё просто — потому что:</p>
<ul>
<li>Вендоры платформ предлагают некоторый готовый API на уже выбранном языке, использовать что-то альтернативное — дополнительные затраты</li>
<li>Игры часто портируют на различные платформы, C (или подмножество C++) - это подмножество, которое можно использовать, чтобы переписывать минимальное количество кода</li>
<li>Компиляторы C оптимизировались годами, на нём можно писать быстрый код, и использовать его как подмножество С++, там где нужна скорость</li>
</ul>
<h1 id="Как-используется"><a href="#Как-используется" class="headerlink" title="Как используется"></a>Как используется</h1><p>Я бы выделил в типичной игре, написанной на C++, три “стиля” кода - низкоуровневый, стандартный, и высокоуровневый.</p>
<p>(Тим Суини в презентации <a href="https://www.st.cs.uni-saarland.de/edu/seminare/2005/advanced-fp/docs/sweeny.pdf" target="_blank" rel="noopener">The Next Mainstream Programming Language</a> в презентации 2010 года, выделяет в отдельную группу так же код шейдеров на HLSL/GLSL, но это уже не C++).</p>
<h2 id="Низкоуровневый-C"><a href="#Низкоуровневый-C" class="headerlink" title="Низкоуровневый C++"></a>Низкоуровневый C++</h2><p>Используется там, где нужны какие-либо быстрые Numeric Computation - вычисления с большими объёмами данных. Примеры задач:</p>
<ul>
<li>Обход графа сцены</li>
<li>Симуляция физики, определений столкновений</li>
<li>Легковесная система задач для получения выгоды от использования нескольких процессоров</li>
<li>Системы анимации 3D персонажей</li>
<li>Куллинг, отправка данных на отрисовку</li>
<li>Системы частиц</li>
<li>Использование особенностей железа - повышение cache locality, пакинг данных в структуры</li>
<li>Тяжёлые алгоритмы рендеринга (частично решаются не на C++)</li>
</ul>
<p>Часто (но не всегда) является “инлайнингом си”, неотделимым от обычного кода. Это бывает как удобным (практически тот же синтаксис), так и не очень — сложнее не допустить в такой код низкоквалифицированного программиста, и почти невозможно запретить использование отдельных синтаксических возможностей языка.</p>
<p>Суини на примере <code>Gear of War</code> приводит такое разделение:<br><code>LoC</code> - 50%/50% - половина кода на “обычном c++” (стандартный + высокоуровневый по моему разделению), половина на низкоуровневом. Для менее требовательных к ресурсам игр (типа мобильных казуалок), я бы привёл цифру в 10-20% на низкоуровевый код.<br><code>Использование CPU</code> - 10% времени процессор выполняет код написанный на обычном уровне (игровая логика + скрипты), 90% - на требовательные к скорости рассчёты.<br><code>Производительность кода</code> - низкоуровневый код в среднем в 10 раз быстрее стандартного.</p>
<p>Код на C неидеален, но удобен в том плане, что не нужно переключаться на другой синтаксис или явно инлайнить его какой-либо директивой. Поэтому другие языки, которые стремятся стать “лучшим С”, иногда поддерживают транспиляцию в C — сгенерированный C код может быть быстрее, чем средний код, написанный человеком (так же, как компилятор может сгенерировать более быстрый машинный код, чем средний программист написать на ассемблере), и можно получить переносимость на все платформы, для которых есть компилятор C.</p>
<p>Минусы других языков в том, что они 1) не “инлайнятся” в C++-код 2) требуют особой обработки для фич, недоступных в C++, чтобы взаимодействовать с ним (что-то вроде отметок unsafe для такого кода). Ну и не имеют столь тесной интеграции с C++, низкоуровневый код — это не обязательно исключительно код на C, можно сочетать “С с элементами C++”/“С++ с элементами С” в любых пропорциях. Быстрый низкоуровневый код получается в случаях, когда программист более-менее представляет, во что он скомпилируется.</p>
<p>Вообщем, C++ - не столько быстрый язык, сколько язык с возможностью хорошо контроллировать производительность получаемого кода там, где это требуется.</p>
<h2 id="Стандартный-C"><a href="#Стандартный-C" class="headerlink" title="Стандартный C++"></a>Стандартный C++</h2><p>Это код, написанный “по заветам классиков”. Задачи, решаемые на “стандартном” уровне:</p>
<ul>
<li>“Связка” используемых библиотек и языков: ~10-20 middleware библиотек, связка с хост-языком операционной системы (Java с JNI, Objective C++ с “инлайном С++” для мобилок), вызовы скриптовых языков, для которых хостом является игра</li>
<li>Высокоуровневая архитектура приложения (Object Oriented Design, Data Oriented Design, паттерны проектирования)</li>
<li>Написание кода, устойчивого к ошибкам (утечки памяти, использование освобожденной памяти, разыменование кривых указателей, неинициализированные переменные, выходы за границы массивов и прочее прелести)</li>
<li>Описание игровой логики</li>
<li>Вызов кода API библиотек, предоставляющих интерфейс на этом языке<br>Иногда открывающих доступ к большей части скрытой производительности железа:<br><a href="https://sean-parent.stlab.cc/presentations/2013-03-05-language-delay/language-delay.pdf" target="_blank" rel="noopener">Language Delay</a> - чистый C++ позволяет использовать 0.25% производительности компьютера (объяснение, где скрыты остальные 99.75% на <a href="https://youtu.be/zULU6Hhp42w?t=938" target="_blank" rel="noopener">видео</a>).<br><img src="/blog/1728194429/desktop_power.png" alt="desktop-power"></li>
</ul>
<p><code>Описание игровой логики</code></p>
<p>На этом уровне Суини выделяет такой момент:<br><blockquote><p>Мы с радостью пожертвуем 10% продуктивности ради того, чтобы получить 10% дополнительной производительности”</p>
</blockquote></p>
<p>(т.е. фактически, чтобы защититься от стандартных ошибок, которые позволяет совершить язык).</p>
<p>Распространённый вариант такого обмена — это использование каких-либо других языков, т.е. отказ от C++ в пользу чего-то более медленного, но устойчивого к ошибкам.</p>
<p>Традиционный для геймдева вариант — Lua. Во многом, идея такой привязки навеяна использованием <a href="https://www.osp.ru/os/1998/03/179470" target="_blank" rel="noopener">языков сценариев</a>. Минусы — производительность снижается далеко не на 10% (что компенсируется ростом производительности железа), и то, что некоторые программисты страдают от искусственного упрощения языка в целях “защиты от дурака”. По опыту, код на Lua, переписанный на C++, ускоряется раз в 5-10. Другие традиционно используемые для скриптования языки, не особо отличаются от Lua ни в плане производительности, ни в плане предоставляемых возможностей.</p>
<p>Ещё один минус — необходимость создания привязок C++ объектов для возможности использования их в скриптовом языке. Это задача требует использования “высокоуровневого” C++, и её особенности будут описаны в следующем разделе.</p>
<p>Плюсы — доступ к программированию непрограммистов (хотя их код в плане производительности теряет ещё больше, количество <a href="https://i.imgur.com/J1svNp7.jpg" target="_blank" rel="noopener">WTF в единицу времени</a> в коде гейм-дизайнера зашкаливает).</p>
<p>Но главный плюс, ради которого часто можно пожертвовать производительностью, это возможность изменить скрипт без перезапуска программы. Это не получается автоматом, а требует некоторой настройки работы с языком, зато в некоторых случаях позволяет повысить производительность программиста не на 10%, а на порядок (в 10 раз). Компиляция, перезапуск игры и прохождение до нужного места с воспроизведением ситуации займёт около минуты, перезагрузка скрипта может выполниться за несколько секунд.</p>
<p>Иногда, конечно, программист может предусмотреть необходимые читы, позволяющие подтюнить код без перезапуска, в случае использования определённых паттернов проектирования типа <a href="/blog/1488389622/" title="ECS">ECS</a> существенно, разница между таким подходом и использованием скриптов только в уровне радикальности возможных изменений без перезапуска игры.</p>
<p>Серьёзный шаг вперёд в направлении использования скриптовых языков сделала Unity, предоставляя программисту в качестве языка для скриптов C# — со статической типизацией (также пробовали Boo и JavaScript, но забили), выразительнее минималистичных “подрезанных” соперников, потенциально быстрый, с возможностью рефлексии, компилируемый в C++ с помощью ill2cpp, и с богатой стандартной библиотекой.</p>
<p>Небольшую проблему представляет запрет на использование виртуальных машин на платформах типа Apple, что обходится “нативизацией” скриптов в C++ код (AoT-компиляция). Таким образом, на устройстве игрока будет присутствовать только нативный код, а на машинах разработчиков — текстовый.</p>
<p><em>(Честно говоря, не очень понимаю смысл этого запрета, многие современные игры позволяют изменять поведение игры за счёт использования данных, полученных с серверов разработчика — вполне допускается загрузка, к примеру, нового главного меню с кнопкой, которая вызывает код, недоступный для проверки вендору. В одной китайской стратегии я находил использование чата на JavaScript - в котором разработчики теоретически могут хоть запустить игру в игре).</em></p>
<p><code>Визуальный скриптинг</code><br>Кроме текстовых языков применяется визуальный скриптинг, который ещё больше снижает когнитивную нагрузку при написании кода, и делает более сложным написание тормознутого или неработающего кода для непрограммистов. Как примеры <a href="https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/Blueprints/UserGuide/Types/ClassBlueprint/" target="_blank" rel="noopener">Blueprint classes</a> в Unreal, или <a href="https://habr.com/ru/company/playrix/blog/595385/" target="_blank" rel="noopener">VSO</a> от Playrix.</p>
<p>Из плюсов — такой язык почти не требует изучения и почти не подвержен ошибкам, по сути, позволяет создавать различные языки для решения различных задач, кроме описания игровой логики.<br>В Unreal с помощью визуального программирования можно описывать:</p>
<ul>
<li>Макросы конструирования объектов в редакторе (в том числе параметризированные), вообще не попадающие в игру</li>
<li>Материалы</li>
<li>Конечные автоматы поведения персонажей</li>
<li>Системы анимации</li>
</ul>
<p>Подготовка игрового контента чаще всего рассматривается как отдельная задача, не связанная с игрой, однако в некоторых случаях бывает полезна генерация С++ кода для работы с этими данными — задачу генерации такого кода можно отнести к области использования “высокоуровневого” C++.</p>
<p><code>Вызов кода API библиотек, предоставляющих интерфейс на этом языке</code><br>Часто какой-нибудь SDK представляет только C/C++ интерфейс для работы с ним (в качестве примера, можно взять OpenGL). Несмотря на то, что для многих библиотек существуют биндинги к популярным скриптовым языкам, особого преимущества при работе с ними не будет, если только биндинг каким-либо образом не добавляет библиотеке выразительности — какая разница, из какого языка вызывать сишные функции, по сути, по порядку? Возможно, определенные преимущества можно получить в языках, позволяющих менять семантику самого языка макросами, типа лиспа, но в рамках доступных для геймдева скриптовых языков особенных преимуществ не заметно.</p>
<p><code>Хардкорные C++-программисты</code><br>Отдельного упоминания заслуживают С++ программисты, которые противятся использованию скриптовых языков для описания игровой логики. Это труднообъяснимое явление, корни которого до конца я не понимаю, поэтому только приведу только те аргументы, которые от них слышал.</p>
<ul>
<li><del>С++ быстрый язык, а скрипты — медленные</del><br>С++ быстрый, если писать на низкоуровневом C++, в остальных случаях скрипт после AoT-компиляции может сконвертироваться в средний по качеству/скорости C++ код.</li>
<li><del>С++ выразительный язык, а скрипты — бейсикоподобные</del><br>Отчасти верно, но зависит от объектной модели, прокинутой в скрипты. Большинство кода в игровой логике на C++, наоборот, используют примитивы слишком низкого уровня там, где отлично было бы обойтись только высокоуровневыми абстракциями. Ну и, какая к чёрту разница, есть или нет какие-то фичи в скриптовом языке, если он позволяет достичь результата раз в 5 быстрее?</li>
<li><del>Я хочу учить C++, чтобы развиваться только как C++ программист</del><br>Один из самых трудных случаев. Человек верит в миф о самом лучшем языке, вдобавок подкрепив эту веру собственными усилиями, потраченными на изучения премудростей языка. Хз, если не помогают объяснения о том, что выгоднее развиваться не только в одном языке, то возможно, человеку лучше работать над компиляторами, а не в разработке игр.</li>
</ul>
<h2 id="Высокоуровневый-C"><a href="#Высокоуровневый-C" class="headerlink" title="Высокоуровневый C++"></a>Высокоуровневый C++</h2><p>Высокоуровневые задачи, с которыми сталкивается типичная игра:</p>
<ul>
<li>RTTI и рефлексия — сериализация данных, читы, статистика</li>
<li>Кодогенерация — введение удобного синтаксиса в язык, генерация типового кода</li>
<li>Compile/build-time вычисления</li>
</ul>
<p>Один из существенных минусов C++ - отсутствие рефлексии, из-за чего её постоянно переизобретают. Часто потому, что к готовой схеме рефлексии сложно “привязаться”, чтобы использовать её для других целей. Например, разметив код один раз, необходимо воспользоваться этой разметкой, чтобы сгенерировать код сериализации или генерации биндингов к скриптовому языку.</p>
<p>Другая задача, которая решается различными способами — генерация типов и кода десериализации по схеме данных. Если решать её средствами C++ — макросами и шаблонами, то достаточно нетривиально скрестить её со схемой аннотации типов и генерации биндингов.</p>
<p>Подходы, которые применяются для кодогенерации RTTI-информации:</p>
<ul>
<li>Использование схемы данных на отдельном языке (<a href="https://google.github.io/flatbuffers/" target="_blank" rel="noopener">flatbuffers</a>/protobuffers), с генерацией кода внешним компилятором</li>
<li>Использование языка, генерирующего данные и код работы с этими данными (<a href="https://youtu.be/oSmqbnhHp1c?t=1950" target="_blank" rel="noopener">DataCompiler</a> на Racket от Naughty Dogs)</li>
<li>Встраивание команд языка в описание данных (<a href="https://beautifulracket.com/jsonic-3/intro.html" target="_blank" rel="noopener">jsonic</a>)</li>
<li>Встраивание тегов в исходный язык, парсящихся языком, генерирующим данные по тегам (<a href="https://doc.qt.io/archives/qt-4.8/moc.html" target="_blank" rel="noopener">MOC</a>, <a href="https://habr.com/ru/company/playrix/blog/467827/" target="_blank" rel="noopener">CppHeaderParser</a>, парсинг с помощью libclang - половина либ <a href="https://github.com/fffaraz/awesome-cpp#reflection" target="_blank" rel="noopener">отсюда</a>)</li>
<li>Явное описание с помощью шаблонов C++ (<a href="https://github.com/rttrorg/rttr" target="_blank" rel="noopener">rttr</a>)</li>
</ul>
<p>Непосредственно генерация кода часто выполняется в текстовом виде, либо с помощью генерации текста по множеству условий в коде генератора (пример - <a href="https://github.com/GaijinEntertainment/daScript/blob/master/daslib/cpp_gen.das#L587" target="_blank" rel="noopener">dascript</a>), либо с помощью генерации текста с подстановкой по шаблону (чаще всего движки шаблонов изначально задумывались для генерации html-страниц, <a href="https://docs.racket-lang.org/fulmar-doc/index.html" target="_blank" rel="noopener">fulmar</a> — зачаточный генератор С++ на Racket, с удовольствием нашёл бы что-то лучше).</p>
<p>По идее, не особо сложно генерировать — сериализиацию, биндинги, rtti, типовой C++ код вроде клонирования (сначала всегда хочется пытаться решить эту задачу просто с помощью наследования от “правильного” базового класса :) ).</p>
<p>Сложнее в C++ с тем, чтобы генерировать синтаксис по уже существующему синтаксису, язык не особо приспособлен для этого. Примеры задач:</p>
<ul>
<li>Подсказка компилятору аллоцировать блок данных для структуры в линейном блоке памяти без явного написания кода работы с указателями в самой структуре, формулировка проблемы из <a href="https://youtu.be/TH9VCN6UkyQ?t=4047" target="_blank" rel="noopener">Jai</a></li>
<li>Смена AoS/SoA выравнивания в памяти</li>
<li>Регистрация функций в ECS (<a href="https://youtu.be/inGb9R1NowY" target="_blank" rel="noopener">атрибут EC для функций</a> с авто-выведением аргументов)</li>
</ul>
<p>Произвольные compile-time вычисления — чаще проще сделать на внешнем языке (экспериментальные попытки завести такое в C++ - <a href="https://youtu.be/NNU6cbG96M4?t=1065" target="_blank" rel="noopener">Circle</a>), и просто выстроить результат, чем пытаться выполнить что-то сложное компилятор.</p>
<p>Сейчас меня очень интересует в качестве скриптового языка <a href="https://youtu.be/IvHGczF6Go0" target="_blank" rel="noopener">DaScript</a>, доклад Антона Юдинцева сильно корреллирует с моим представлением о том, зачем нужны скриптовые языки на “стандартном” уровне, и замахивается на то, чтобы решать “высокоуровневые” задачи, для которых не всегда есть стандартные решения в самом C++. Пока не успел поиграться с языком, но мне очень нравятся начальные идеи, с которыми подходили к разработке, и заявленные результаты. Я достаточно знаком с использованием скриптовых языков в Gaijin в прошлом, чтобы примерно представлять уровень и объём кода, написанного ими на языке в продакшене и в тулзах, чтобы предварительно положительно отнестись к заявленному, но и без этого выглядит довольно круто. В докладе и стриме почти не освещаются возможности языка по написанию макросов, упоминаемые в <a href="https://dascript.org/doc/reference/language/macros.html" target="_blank" rel="noopener">документации</a>, а также в коде <a href="https://github.com/GaijinEntertainment/daScript/blob/master/daslib/decs_boost.das" target="_blank" rel="noopener">модулей</a> и <a href="https://github.com/borisbat/dasBGFX/blob/a1e10ab439e5996a0a4d8722689e2b0fab4e72d9/examples/01_hello_triangle.das#L12" target="_blank" rel="noopener">привязок</a> либ для реализации “высокоуровневых” фичи.</p>
<p>Интересно было бы прикинуть оценки пропорции использования C++ на каждом из уровней в различных играх.</p>
<h2 id="Ссылки"><a href="#Ссылки" class="headerlink" title="Ссылки"></a>Ссылки</h2><p><a href="/blog/1808122922/" title="Nim in imaginary world">Nim in imaginary world</a> — критерии выбора языка<br><a href="/blog/2297379949/" title="Заметки о языках программирования">Заметки о языках программирования</a> — сборник материалов по языкам<br><code>Джесси Шелл - Искусство Геймдизайна</code> — “Итерации делают игру лучше”. Совет использовать для прототипирования языки с возможностью быстрой проверки изменений - Smalltalk, Python, Scheme, JavaScript<br><code>Джейсон Грегори - Архитектура игрового движка</code> — 16.9.4 - Архитектуры для скриптования. Обзор возможных точек привязки скриптов к игре. 16.9.5 - Возможности игровых скриптов на этапе выполнения. Пример подхватывания изменённых данных игрой без перезапуска. 12.10.3 - Параметры состояния и дерева слияния - примеры анимационного клипа, описанного на языке Data Compiler, и Animation Blueprint для Unreal.<br><a href="https://youtu.be/UTqZNujQOlA" target="_blank" rel="noopener">Demo: Base language, compile-time execution</a> - пример запуска игры во время компиляции.<br><a href="https://fungos.github.io/cr-simple-c-hot-reload/" target="_blank" rel="noopener">cr.h: A Simple C Hot Reload Header-only Library</a> - трудности реализации hot code reload в C++. <a href="https://github.com/RuntimeCompiledCPlusPlus/RuntimeCompiledCPlusPlus/wiki/Alternatives" target="_blank" rel="noopener">Больше</a> статей и материалов.</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script></div></article><div class="pagination"><a class="pagination__link pagination__prev" href="/blog/1547564887/">Позже</a><a class="pagination__link pagination__next" href="/blog/37481721/">Раньше</a></div></main><footer class="footer metadata"><p class="footer__text">© 2024 spiiin</p><p class="footer__text">Powered by <a class="footer__text__link" href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a class="footer__text__link" href="https://pages.github.com/" target="_blank">Github Page</a></p></footer></div></body></html>