<!DOCTYPE html><html lang="ru"><head><meta charset="UTF-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Spiiin's blog | Файберы, диспетчеры, асинки</title><meta name="description" content="&lt;a href=&quot;/blog/2550823652/&quot; title=&quot;Итераторы, колстеки, корутины&quot;&gt;Итераторы, колстеки, корутины&lt;/a&gt; -- первая часть статьи про итераторы и асинхронное программирование. В ней были перечислены особенности абстракций обхода коллекций в нескольких языках, а также описана связь между ними и возобновляемыми функциями. В конце статьи рассмотрено представление возобновляемых функций в различных языках и различная терминология для их обозначений. Дальше можно постепенно перейти к способам управления этими функциями."><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=PT+Serif&amp;display=swap"><link rel="stylesheet" href="/css/highlights/darkula.css"><link rel="stylesheet" href="/css/main.css"><link rel="search" type="application/opensearchdescription+xml" href="http://spiiin.github.io/atom.xml" title="Spiiin's blog"><script>(function (i, s, o, g, r, a, m) {
  i['GoogleAnalyticsObject'] = r;
  i[r] = i[r] || function () {
    (i[r].q = i[r].q || []).push(arguments)
  }, i[r].l = 1 * new Date();
  a = s.createElement(o),
    m = s.getElementsByTagName(o)[0];
  a.async = 1;
  a.src = g;
  m.parentNode.insertBefore(a, m)
})(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');
ga('create', 'UA-00000000-0', 'auto');
ga('send', 'pageview');</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Spiiin's blog" type="application/atom+xml">
</head><body><div class="container"><header class="main-header"><h1 class="main-header__title uplize"><a class="main-header__title__link" href="/"><img class="header-image" src="/images/favicon.png" width="36" height="36">Spiiin's blog</a></h1><nav class="main-header__nav"><ul class="main-nav"><li class="main-nav__list"><a class="main-nav__list__link" href="/" target="_self">HOME</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/archives/" target="_self">ARCHIVE</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/tags/meta" target="_self">TAGS</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/blog/1" target="_self">ABOUT</a></li></ul></nav></header><main class="container__wrapper"><div class="pagination"><a class="pagination__link pagination__next" href="/blog/3309518526/">Раньше</a></div><article class="article post"><h3 class="article__title">Файберы, диспетчеры, асинки</h3><div class="article__date metadata"><div class="post-info">2022/09/04</div></div><div class="article__tags metadata">Tags:
<a class="article__tags__link metadata" href="/tags/dev/">dev</a><a class="article__tags__link metadata" href="/tags/link/">link</a><a class="article__tags__link metadata" href="/tags/dascript/">dascript</a><a class="article__tags__link metadata" href="/tags/cpp/">cpp</a></div><div class="article__body"><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><a href="/blog/2550823652/" title="Итераторы, колстеки, корутины">Итераторы, колстеки, корутины</a> -- первая часть статьи про итераторы и асинхронное программирование. В ней были перечислены особенности абстракций обхода коллекций в нескольких языках, а также описана связь между ними и возобновляемыми функциями. В конце статьи рассмотрено представление возобновляемых функций в различных языках и различная терминология для их обозначений. Дальше можно постепенно перейти к способам управления этими функциями.

<a id="more"></a>
<h2 id="Ссылки"><a href="#Ссылки" class="headerlink" title="Ссылки"></a>Ссылки</h2><p>(также см. ссылки из первой статьи)<br>[1] Иван Чукич - Функциональное программирование на C++ — глава 7 Диапазоны<br>[2] Alex Davies - Async in C# 5.0<br>[3] <a href="https://www.researchgate.net/publication/220802950_The_F_Asynchronous_Programming_Model" target="_blank" rel="noopener">Don Syme - F Asynchronous Programming Model</a><br>[4] <a href="http://www.kegel.com/c10k.html" target="_blank" rel="noopener">The C10K problem</a><br>[5] <a href="https://www.youtube.com/watch?v=i0RB7UqxERE" target="_blank" rel="noopener">Async await in Nim A demonstration of the flexibility metaprogramming can bring to a language</a>. Еще несколько ссылок про async в Nim - <a href="https://nim-lang.org/blog/2014/04/21/version-094-released.html" target="_blank" rel="noopener">1</a>, <a href="https://nim-lang.org/docs/asyncdispatch.html" target="_blank" rel="noopener">2</a>, <a href="https://peterme.net/asynchronous-programming-in-nim.html" target="_blank" rel="noopener">3</a><br>[6] <a href="https://cpratt.co/async-tips-tricks/" target="_blank" rel="noopener">C# async tips and tricks</a> -  sequence tasks vs parallel. Tasks return “hot”<br>[7] <a href="https://docs.python.org/3/library/asyncio-task.html" target="_blank" rel="noopener">Python asyncio-task</a><br>[8] <a href="https://www.youtube.com/watch?v=OE45F3iKtv4" target="_blank" rel="noopener">Павел Новиков — Учимся готовить C++ корутины на практике</a><br>[9] <a href="https://developer.apple.com/videos/play/wwdc2021/10132/" target="_blank" rel="noopener">Meet async/await in Swift</a><br>[10] <a href="https://marek-g.github.io/posts/projects/archive/nemerle_async_await/" target="_blank" rel="noopener">Nemerle macro async/await</a>, еще одна реализация через <a href="https://habr.com/ru/post/108184/" target="_blank" rel="noopener">монады</a><br>[11] <a href="https://www.youtube.com/watch?v=yJxFPoxqzWE" target="_blank" rel="noopener">“Clojure core.async” by Rich Hickey (2013)</a><br>[12] <a href="http://hueypetersen.com/posts/2013/08/02/the-state-machines-of-core-async/" target="_blank" rel="noopener">The State Machines of core.async</a><br>[13] <a href="https://www.youtube.com/watch?v=R3PZMIwXN_g" target="_blank" rel="noopener">Core Async Go Macro Internals - Part I</a> - реализация goroutine-макроса в closure<br>[14] <a href="https://github.com/scylladb/seastar/blob/master/doc/tutorial.md" target="_blank" rel="noopener">Scylla DB Tutorial</a> - туториал по библиотеке c++, интенсивно использующий корутины. Еще больше статей - <a href="https://www.scylladb.com/2020/03/26/avi-kivity-at-core-c-2019/" target="_blank" rel="noopener">1</a>, <a href="https://www.scylladb.com/2020/05/05/how-io_uring-and-ebpf-will-revolutionize-programming-in-linux/" target="_blank" rel="noopener">2</a></p>
<h2 id="Асинхронность"><a href="#Асинхронность" class="headerlink" title="Асинхронность"></a>Асинхронность</h2><p>Если рассматривать итераторы как абстракцию способов обхода коллекции, то в первую очередь они напоминают “умный” индекс в коллекции, который может пропускать какие-либо элементы, менять направление, или даже управляться элементами самой коллекции (например, можно описать вектором цепь Маркова, и сделать итератор, который реализует переключение состояний в этой цепи).</p>
<p>Есть ещё одно важное свойство отделения итерации от вызывающего её кода — на момент запроса следующего элемента коллекции сама коллекция не обязана существовать целиком. Процесс создания следующих элементов коллекции может быть описан в виде функции — коллекция всех натуральных чисел, передача запроса на получение элемента из файла/от внешнего устройства/по сети (само чтение данных может происходит в других потоках, которые каким-либо образом вернут данные итератору).</p>
<h2 id="Описание-коллекции-в-виде-функции"><a href="#Описание-коллекции-в-виде-функции" class="headerlink" title="Описание коллекции в виде функции"></a>Описание коллекции в виде функции</h2><p>Простейший пример на <code>daScript</code> — бесконечная коллекция натуральных чисел, заданная в виде генератора:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var natural &lt;- generator&lt;<span class="keyword">int</span>&gt;() &lt;| $()</span><br><span class="line">  var i = <span class="number">1</span></span><br><span class="line">  <span class="keyword">while</span> <span class="literal">true</span></span><br><span class="line">    yield i</span><br><span class="line">    i++</span><br></pre></td></tr></table></figure></p>
<p>Мы не можем использовать её в цикле foreach напрямую, потому что этот цикл пытается пройти по всем элементам коллекции. Но можно сделать другой генератор, который возьмёт несколько элементов из бесконечной коллекции и остановится.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">take</span><span class="params">(var src:iterator&lt;<span class="keyword">auto</span>(TT)&gt;; count:<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">  unsafe</span></span><br><span class="line">    var gen &lt;- generator&lt;TT&gt;() &lt;| $()</span><br><span class="line">      var aValue : TT-&amp;</span><br><span class="line">      <span class="function"><span class="keyword">for</span> i in <span class="title">range</span><span class="params">(count)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">if</span> <span class="title">next</span><span class="params">(src, aValue)</span></span></span><br><span class="line"><span class="function">          yield aValue</span></span><br><span class="line"><span class="function">        <span class="keyword">else</span></span></span><br><span class="line"><span class="function">          <span class="keyword">return</span> <span class="literal">false</span></span></span><br><span class="line"><span class="function">      <span class="keyword">return</span> <span class="literal">false</span></span></span><br><span class="line">    return &lt;-gen</span><br><span class="line"><span class="keyword">for</span> num in natural |&gt; take(<span class="number">3</span>)</span><br><span class="line">  print(<span class="string">"&#123;num&#125; "</span>)</span><br><span class="line"><span class="comment">//Output: "1 2 3"</span></span><br></pre></td></tr></table></figure>
<h2 id="Композиция-функций-и-ленивые-вычисления"><a href="#Композиция-функций-и-ленивые-вычисления" class="headerlink" title="Композиция функций и ленивые вычисления"></a>Композиция функций и ленивые вычисления</h2><p>Попробуем “просеять” натуральные числа, оставив только простые. Пример реализации функции <a href="https://github.com/spiiin/dascript_macro_tutorial/blob/master/primes/primes_mix_compile_runtime.das" target="_blank" rel="noopener">prime</a> (самая быстрая реализация, без учёта потребляемой памяти — просто посчитать первые n чисел заранее в compile-time :) ).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> num in natural |&gt; filter(@@is_prime) |&gt; take(<span class="number">10</span>)</span><br><span class="line">  print(<span class="string">"&#123;num&#125; "</span>)</span><br><span class="line"><span class="comment">//Output: 2, 3, 5, 7, 11, 13, 17, 19, 23, 29</span></span><br></pre></td></tr></table></figure>
<p>Можно заметить, что не существует вычисленной промежуточной коллекции <code>natural |&gt; filter(@@is_prime)</code>, которая представляла бы собой бесконечный список всех простых чисел). Вычисление следующего элемента коллекции, описанного композицией этих функций, вычисляется только по запросу этого элемента или <strong>лениво</strong> (lazy) — <code>take</code> запрашивает следующий элемент из <code>filter</code>, которая может запросить и вычислить один или несколько элементов из коллекции <code>natural</code>.</p>
<p>Если попробовать реализовать такую композицию на C++ с помощью итераторов и алгоритмов STL, окажется, что они не годятся для этого, функция <a href="https://en.cppreference.com/w/cpp/algorithm/copy" target="_blank" rel="noopener">std::copy_if</a>, с помощью которой можно было бы провести фильтр элементов, ожидает на вход итераторы <strong>существующей</strong> коллекции, что требует создания временной копии и её заполнения элементами. Но вместо итераторов можно воспользоваться библиотекой <code>ranges</code> - <a href="https://en.cppreference.com/w/cpp/algorithm/ranges/copy" target="_blank" rel="noopener">стандарт C++20</a>, <a href="https://github.com/ericniebler/range-v3" target="_blank" rel="noopener">range-v3</a>, она позволяет строить ленивые итераторы (<code>std::views</code>) или инплейсно изменять коллекции (<code>std::actions</code>).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::views;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : iota(<span class="number">1</span>) | filter(is_prime) | take(<span class="number">10</span>)) &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2 3 5 7 11 13 17 19 23 29</span></span><br></pre></td></tr></table></figure>
<h2 id="Коллекция-как-данные-из-внешнего-источника"><a href="#Коллекция-как-данные-из-внешнего-источника" class="headerlink" title="Коллекция как данные из внешнего источника"></a>Коллекция как данные из внешнего источника</h2><p>В отличие от всех предыдущих случаев, при получении данных от внешнего источника мы не всегда знаем когда именно данные будут получены, что приводит к следующей проблеме — что делать, если все данные готовые данные обработаны, а новых ещё нет? Как и с итераторами, возможны два основных подхода — либо вызывающий код регулярно опрашивает источник данных, есть ли новые данные для обработки, либо же источнику данных передаётся колбек, который будет вызван, когда появятся новые данные для обработки.</p>
<h2 id="Опрос-источника-данных"><a href="#Опрос-источника-данных" class="headerlink" title="Опрос источника данных"></a>Опрос источника данных</h2><p>Игрушечная симуляция длительно выполняющейся задачи — счётчик до 100, который позволяет информировать внешний код о прогрессе каждые 10 итераций<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> </span><br><span class="line">  ValueOrReady = variant&lt;value:<span class="keyword">int</span>; ready:<span class="keyword">bool</span>&gt;</span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line"><span class="function">def <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  <span class="comment">//создаём генератор, который может возвращать значение или флаг "значение не готово"</span></span></span><br><span class="line">  var gen &lt;- generator&lt;ValueOrReady&gt;() &lt;| $()</span><br><span class="line">    var i = <span class="number">1</span></span><br><span class="line">    var answer: ValueOrReady</span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="number">100</span></span><br><span class="line">      unsafe</span><br><span class="line">        <span class="comment">//каждый 10 шагов выдаём значение</span></span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">10</span> == <span class="number">0</span></span><br><span class="line">          answer = [[ValueOrReady value = i]]</span><br><span class="line">        <span class="comment">//иначе выдаём флаг "работа в процессе", данных пока нет</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          answer = [[ValueOrReady ready = <span class="literal">false</span>]]</span><br><span class="line">      yield answer</span><br><span class="line">      i++</span><br><span class="line">    <span class="comment">//задача выполнена</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> num in gen</span><br><span class="line">    unsafe</span><br><span class="line">      <span class="keyword">if</span> num is value</span><br><span class="line">        print(<span class="string">"&#123;num.value&#125; "</span>)</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        print(<span class="string">"x "</span>)</span><br><span class="line">  print(<span class="string">"\ndone"</span>)</span><br><span class="line"><span class="comment">//Output: x x x x x x x x x 10 x x x x x x x x x 20 x x x x x x x x x 30 x x x x x x x x x 40 x x x x x x x x x 50 x x x x x x x x x 60 x x x x x x x x x 70 x x x x x x x x x 80 x x x x x x x x x 90 x x x x x x x x x</span></span><br><span class="line"><span class="comment">//done</span></span><br></pre></td></tr></table></figure></p>
<p>Видно, что опрос генератор требует двух специальных флагов — выполнена ли задача полностью, и готовы ли данные. Для возврата признака, готовы ли данные, использован тип <code>variant&lt;value:int; ready:bool&gt;</code> (задача возвращает либо данные, либо флаг неготовности, но не их одновременно).</p>
<p>Вместо такой искусственной задержки генератор может совершать реальную работу — например опрос сокетов операционной системы, и предоставлять не результат, а интерфейс для чтения данных, когда они будут готовы (один из подходов к решению проблемы 10000 соединений к серверу [2])</p>
<p>Такое примитивное описание асинхронной выполняемой задачи оставляет сразу серию вопросов и возможных улучшений:</p>
<ul>
<li>пока что наш “опрос” источника внешних данных заключался в том, чтобы проверить какой-то флаг, выставляемый этим источником, в основном потоке. Реальное получение данных после того, как был получен сигнал о готовности, требует синхронизации при чтении данных из источника, что можно выразить в виде паттерна с использованием примитивов синхронизации.</li>
<li>в программе может существовать несколько выполняемых задач, ожидающих данных. Где-то может существовать диспетчер, опрашивающий все ожидающие задачи, чтобы не писать цикл их опроса вручную. Диспетчер может даже раскидывать выполнение задач на несколько потоков выполнения.</li>
<li>различные ожидающие задачи могут требовать результатов других ожидающих задач. Какие-то результаты могут потребоваться раньше, какие-то позже. Есть различные способы выражения того, что в конкретном месте выполнения программа должна дождаться данных от одной или нескольких подзадач.</li>
<li>если задача полностью зависит от внешнего источника, недоступного для управления из программы, логично предусмотреть возможность её завершения не дожидаясь окончания</li>
</ul>
<h2 id="Ожидание-колбеков"><a href="#Ожидание-колбеков" class="headerlink" title="Ожидание колбеков"></a>Ожидание колбеков</h2><p>Можно переписать задачу вычисления чисел так, чтобы она информировала вызывающий код о прогрессе сама (аналог внутреннего итератора):<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">makeLongCalculation</span><span class="params">(blk)</span></span></span><br><span class="line"><span class="function">  var i </span>= <span class="number">1</span></span><br><span class="line">  <span class="keyword">while</span> i &lt; <span class="number">100</span></span><br><span class="line">    unsafe</span><br><span class="line">      <span class="keyword">if</span> i % <span class="number">10</span> == <span class="number">0</span></span><br><span class="line">        invoke(blk, [[ValueOrReady value = i]], <span class="literal">false</span>)</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        invoke(blk, [[ValueOrReady ready = <span class="literal">false</span>]], <span class="literal">false</span>)</span><br><span class="line">    i++</span><br><span class="line">  invoke(blk, [[ValueOrReady ready = <span class="literal">false</span>]], <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//использование функции</span></span><br><span class="line">makeLongCalculation &lt;| $(num: ValueOrReady; done: <span class="keyword">bool</span>)</span><br><span class="line">  <span class="keyword">if</span> !done</span><br><span class="line">    unsafe</span><br><span class="line">      <span class="keyword">if</span> num is value</span><br><span class="line">        print(<span class="string">"&#123;num.value&#125; "</span>)</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        print(<span class="string">"x "</span>)</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    print(<span class="string">"\ndone"</span>)</span><br><span class="line"><span class="comment">//Output: x x x x x x x x x 10 x x x x x x x x x 20 x x x x x x x x x 30 x x x x x x x x x 40 x x x x x x x x x 50 x x x x x x x x x 60 x x x x x x x x x 70 x x x x x x x x x 80 x x x x x x x x x 90 x x x x x x x x x</span></span><br><span class="line"><span class="comment">//done</span></span><br></pre></td></tr></table></figure></p>
<p>Таким способом часто выглядят функции запроса данных по сети — в колбек приходит информация о массиве частично-скачанных данных, и флаги — ожидать ли ещё данных, и были ли ошибки.</p>
<p>Рассмотрим эволюцию паттернов работы с колбеками на примере .Net, в дань тому, что в F# и затем в C# впервые ушли от них к более свежим подходам. Microsoft в C# называет паттерны асинхронного вызова с использованием колбеков умными аббревиатурами <code>EAP</code> и <code>APM</code>. Примеры кода:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//.NET 1, APM (Asynchronous Programming Model)</span></span><br><span class="line">file.BeginCall(buffer, <span class="number">0</span>, maxLength, asyncResult =&gt; &#123;</span><br><span class="line">  <span class="comment">//вызовется через какое-то время</span></span><br><span class="line">  <span class="keyword">int</span> numBytesRead = file.EndRead(asyncResult);</span><br><span class="line">&#125;, <span class="literal">null</span>)</span><br></pre></td></tr></table></figure>
<p>В некоторых вызовах неочевидно, в каком контексте будет вызван колбек (из какого потока, нужно ли синхронизироваться и передавать результат обратно в поток, в котором будет обработан результат)<br>Если же нужно из колбека вызвать еще несколько вложенных операций, получается колбек-хелл, с жутким синтаксисом и смутным представлением контекста выполнения каждого из колбеков.</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//.NET 2, APM (Asynchronous Programming Model)</span></span><br><span class="line">webClient.DownloadStringCompleted += (sender, args) =&gt; &#123;</span><br><span class="line">  <span class="keyword">string</span> html = args.Result;</span><br><span class="line">&#125;</span><br><span class="line">webClient.DownloadStringAsync(<span class="keyword">new</span> Uri(<span class="string">"http://example.com"</span>));</span><br></pre></td></tr></table></figure>
<p>Примерно то же самое, но с необходимостью явно оторвать колбек от вызова (и возможностью навесить несколько обработчиков) — чуть меньше “лесенок” в коде</p>
<h2 id="Future-async-await"><a href="#Future-async-await" class="headerlink" title="Future, async/await"></a>Future, async/await</h2><p>Future (или Task в C#) — обёртка для результата, которая запускает задачу, и возвращает управление вызывающему коду. Код сам может решить что ему делать с объектом задачи, когда остановиться, чтобы дождаться результата, или как скомбинировать полученный объект с другими задачами.</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//.NET 4</span></span><br><span class="line">Task&lt;<span class="keyword">string</span>&gt; htmlTask = webClient.DownloadStringTaskAsync(url);</span><br><span class="line"><span class="comment">//тот можно выполнить код, которому не требуется результат hmtlTask</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">string</span> html = htmlTask.Result; <span class="comment">//тут блокировка до ожидания результата</span></span><br><span class="line"><span class="comment">//или прикрепить к задаче продолжение</span></span><br><span class="line">htmlTask.ContinueWith(task=&gt; &#123;</span><br><span class="line">  <span class="keyword">string</span> html = task.Result;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>Следующий шаг, сделанный в F# и перенятый в других языках — продвинутый синтаксический сахар, который позволяет записать <code>ContinueWith</code> не в виде лямбда-функции, а кодом, который выглядит, ка<br><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//.NET 5</span></span><br><span class="line">Task&lt;<span class="keyword">string</span>&gt; htmlTask = webClient.DownloadStringTaskAsync(url);</span><br><span class="line"><span class="keyword">string</span> html = <span class="keyword">await</span> htmlTask; <span class="comment">//то же что и в прошлом примере с ContinueWith</span></span><br><span class="line">doSomething(html)             <span class="comment">//строки ниже await также "переписываются" внутрь ContinueWith</span></span><br></pre></td></tr></table></figure></p>
<p>Другие языки с async/await в похожем виде адаптируют эти идеи из C#</p>
<ul>
<li>[5] - вкручивание их в Nim синтаксическими макросами.</li>
<li>[8] приводится пример разбора устройства Task в стандарте C++</li>
<li>[9] Swift. Достаточно подробное объяснение, тайминги<br>22:14 — трансформация кода на колбеках в async код<br>22:53 — про “цвета” функций<br>30:38 — continuation pattern cc/resume<br>32:19 — сохранение continuation %)</li>
<li>[10] Nemerle</li>
<li>[11] Closure, [12]<br> 8:24 C# async, linear code -&gt; callbacks + state machine, обзор подходов async и channel</li>
</ul>
<p>Проще говоря, <code>co_await</code> в C++ позволяет записать:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">task&lt;&gt; <span class="title">tcp_echo_server</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> data[<span class="number">1024</span>];</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> n = <span class="keyword">co_await</span> socket.async_read_some(buffer(data));</span><br><span class="line">    <span class="function"><span class="keyword">co_await</span> <span class="title">async_write</span><span class="params">(socket, buffer(data, n))</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"resended\n"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>вместо чего-то типа:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">socket.async_read_some(buffer(data)).continueWith([&amp;](<span class="keyword">auto</span> task)&#123;</span><br><span class="line">  n = task.result();</span><br><span class="line">  async_write(socket, buffer(data, n)).continueWith([&amp;](<span class="keyword">auto</span> task)&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"resended\n"</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>(специально не хочу вникать в особенности именно С++ реализации переписывания из-за её вырвиглазности, при желании можно покопаться в этом в [8]).</p>
<p>Можно рассматривать оператор <code>co_await</code> как возможность приостановить выполнение и “подписаться” на уведомление о завершении или приостановке выражения-аргумента.</p>
<p>Разбор некоторых проблем сочетания синхронных функций с асинхронными в статье <a href="http://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/" target="_blank" rel="noopener">What Color is Your Function?</a>. Библиотечные функции для синхронной и асинхронной работы “разных цветов”, и необходимо иметь 2 версии функций для того, чтобы вызывающий код мог выбирать из них (к примеру, синхронный <a href="https://github.com/redis/redis-py" target="_blank" rel="noopener">redispy</a> и его асихронный двойник <a href="https://github.com/aio-libs/aioredis-py" target="_blank" rel="noopener">aioredis</a>, или асинхронная копия <a href="https://pypi.org/project/asynctkinter/" target="_blank" rel="noopener">tkinter</a>, <a href="https://github.com/aio-libs" target="_blank" rel="noopener">десятки их</a>). Язык <code>Zig</code> кажется, один из немногих, в котором реализована поддержка универсальных бесцветных функций, которые могут работать синхронно или асинхронно, решение переносится на вызывающий кода (см ссылки [26], [27] в первой части статьи).</p>
<p>Интересно, насколько просто добавляются подобные операторы в языки с поддержкой синтаксических макросов. Например, модуль <a href="https://github.com/GaijinEntertainment/daScript/blob/138f625c7f95943341a5e96cca114ae7d0772ba6/daslib/coroutines.das" target="_blank" rel="noopener">coroutine</a> в <code>daScript</code>, реализующий макрос <code>co_await</code>, и примеры его использования <a href="https://github.com/GaijinEntertainment/daScript/blob/138f625c7f95943341a5e96cca114ae7d0772ba6/examples/test/misc/coroutines_example_2.das" target="_blank" rel="noopener">1</a> и <a href="https://github.com/GaijinEntertainment/daScript/blob/110bb4313fa479d7b837413700ed7f6c68601e24/examples/test/misc/coroutines_example.das" target="_blank" rel="noopener">2</a>.</p>
<p>Первый пример — последовательная передача управления между двумя функциями:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[coroutine]</span><br><span class="line"><span class="function">def <span class="title">subcr</span><span class="params">(name:<span class="built_in">string</span>)</span></span></span><br><span class="line"><span class="function">  <span class="title">print</span><span class="params">(<span class="string">"&#123;name&#125; sub 1\n"</span>)</span></span></span><br><span class="line"><span class="function">  <span class="title">co_continue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  <span class="title">print</span><span class="params">(<span class="string">"&#123;name&#125; sub 2\n"</span>)</span></span></span><br><span class="line"><span class="function">  <span class="title">co_continue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  <span class="title">print</span><span class="params">(<span class="string">"&#123;name&#125; sub 3\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">[coroutine]</span><br><span class="line"><span class="function">def <span class="title">coroutine_example</span><span class="params">(name:<span class="built_in">string</span>;count:<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">  <span class="title">print</span><span class="params">(<span class="string">"&#123;name&#125; step 1\n"</span>)</span></span></span><br><span class="line"><span class="function">  <span class="title">co_continue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  <span class="title">print</span><span class="params">(<span class="string">"&#123;name&#125; step 2\n"</span>)</span></span></span><br><span class="line"><span class="function">  <span class="title">co_continue</span><span class="params">()</span></span></span><br><span class="line">  co_await &lt;| subcr(name)</span><br><span class="line">  co_continue()</span><br><span class="line">  print(<span class="string">"&#123;name&#125; step 3\n"</span>)</span><br><span class="line">  co_continue()</span><br><span class="line">  <span class="function"><span class="keyword">for</span> i in <span class="title">range</span><span class="params">(<span class="number">4</span>,<span class="number">4</span>+count)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;name&#125; step &#123;i&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">co_continue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">[export]</span><br><span class="line">def main</span><br><span class="line">    var crs &lt;- [&#123;<span class="keyword">auto</span></span><br><span class="line">        coroutine_example(<span class="string">"co1"</span>,<span class="number">1</span>);</span><br><span class="line">        coroutine_example(<span class="string">"co2"</span>,<span class="number">2</span>)</span><br><span class="line">    &#125;]</span><br><span class="line">    cr_run_all(crs)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Output:</span></span><br><span class="line"><span class="comment">//co2 step 1</span></span><br><span class="line"><span class="comment">//co1 step 1</span></span><br><span class="line"><span class="comment">//co2 step 2</span></span><br><span class="line"><span class="comment">//co1 step 2</span></span><br><span class="line"><span class="comment">//co2 sub 1</span></span><br><span class="line"><span class="comment">//co1 sub 1</span></span><br><span class="line"><span class="comment">//co2 sub 2</span></span><br><span class="line"><span class="comment">//co1 sub 2</span></span><br><span class="line"><span class="comment">//co2 sub 3</span></span><br><span class="line"><span class="comment">//co1 sub 3</span></span><br><span class="line"><span class="comment">//co2 step 3</span></span><br><span class="line"><span class="comment">//co1 step 3</span></span><br><span class="line"><span class="comment">//co2 step 4</span></span><br><span class="line"><span class="comment">//co1 step 4</span></span><br><span class="line"><span class="comment">//co2 step 5</span></span><br></pre></td></tr></table></figure></p>
<p>Второй пример — это внутренний итератор по дереву из первой части статьи (раздел <strong><code>Файберы</code></strong>), оформленный в виде корутины:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[coroutine]</span><br><span class="line"><span class="function">def <span class="title">each_async</span><span class="params">(tree : Tree?)</span> : <span class="keyword">int</span></span></span><br><span class="line">  if tree.left != null</span><br><span class="line">    <span class="keyword">co_await</span> &lt;| each_async(tree.left)</span><br><span class="line">  yield tree.data</span><br><span class="line">  <span class="keyword">if</span> tree.right != null</span><br><span class="line">    <span class="keyword">co_await</span> &lt;| each_async(tree.right)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> t in each_async(tree)</span><br><span class="line">  print(<span class="string">"&#123;t&#125;\n"</span>)</span><br></pre></td></tr></table></figure></p>
<p>Макрос corountine превращает функцию в генератор, который может быть приостановлен и возобновлён. Как показывает пример, асинхронные значения могут возвращаться в том числе и из рекурсивной функции. Теперь можно как в <code>ruby</code>, возвращать управление из вложенных функций!</p>
<h2 id="Каналы"><a href="#Каналы" class="headerlink" title="Каналы"></a>Каналы</h2><p>Отойдём ненадолго от асинхронных функций, и посмотрим на работу с потоками. В <code>daScript</code> функции для работы с ними собраны в модуле <a href="https://github.com/GaijinEntertainment/daScript/blob/d60f0a310086458d28bf4726e93aa0e6c1e06abe/daslib/jobque_boost.das" target="_blank" rel="noopener">jobque_boost</a>. Примеры использования - <a href="https://github.com/GaijinEntertainment/daScript/blob/fdc48d4d4cfc46f08f0ca2fd8938a05896b973a6/examples/test/unit_tests/test_job_que.das" target="_blank" rel="noopener">test_job_que</a> и <a href="https://github.com/GaijinEntertainment/daScript/blob/master/examples/test/misc/producer-consumer.das" target="_blank" rel="noopener">produser-consumer</a>.</p>
<p>Новый поток создаётся функцией <code>new_thread</code>, а передача данных осуществляется через каналы (<code>channel</code>), которые объединяют примитив синхронизации (мьютекс) и результат, который может быть отправлен в канал из одного потока и принят из другого.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Answer</span></span></span><br><span class="line"><span class="class">    <span class="title">text</span>:</span><span class="built_in">string</span></span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">work_in_thread</span><span class="params">(var channel)</span></span></span><br><span class="line"><span class="function"><span class="comment">//создаём потока (в реальном коде нужно обернуть в job, чтобы иметь возможность дождаться завершения)</span></span></span><br><span class="line">new_thread &lt;| @</span><br><span class="line">    print(<span class="string">"in thread\n"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">for</span> i in <span class="title">range</span><span class="params">(<span class="number">3</span>)</span></span></span><br><span class="line">      channel |&gt; push_clone([[Answer text="work in progress &#123;i&#125;"]])  //передаём данные в канал</span><br><span class="line">      sleep(<span class="number">1000u</span>)</span><br><span class="line">    channel |&gt; notify_and_release                                    <span class="comment">//закрываем канал</span></span><br><span class="line">    <span class="comment">//completion |&gt; notify_and_release</span></span><br><span class="line">    print(<span class="string">"done thread\n"</span>)</span><br><span class="line">  print(<span class="string">"work_in_thread done\n"</span>)</span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main</span><br><span class="line">  with_channel(<span class="number">1</span>) &lt;| $(channel)</span><br><span class="line">    work_in_thread(channel)</span><br><span class="line">    print(<span class="string">"thread created\n"</span>)</span><br><span class="line">    for_each(channel) &lt;| $(ans:Answer#)              <span class="comment">//принимаем данные из канала</span></span><br><span class="line">        print(<span class="string">"result from thread: &#123;ans.text&#125;\n"</span>)</span><br><span class="line">    print(<span class="string">"done"</span>)</span><br><span class="line"><span class="comment">//Output</span></span><br><span class="line"><span class="comment">//work_in_thread done</span></span><br><span class="line"><span class="comment">//thread created</span></span><br><span class="line"><span class="comment">//in thread</span></span><br><span class="line"><span class="comment">//result from thread: work in progress 0</span></span><br><span class="line"><span class="comment">//result from thread: work in progress 1</span></span><br><span class="line"><span class="comment">//result from thread: work in progress 2</span></span><br><span class="line"><span class="comment">//done thread</span></span><br><span class="line"><span class="comment">//done</span></span><br></pre></td></tr></table></figure>
<p>Каналы по интерфейсу похожи на итераторы, однако в <code>dascript</code> не встроены в язык, поэтому работают не с встроенной функцией <code>for</code>, а с функцией из модуля joque_boost <code>for_each</code>, которая на очередной итерации достаёт из канала очередное значение или блокирует поток до тех пор, пока канал пуст. Итерация заканчивается после того, как канал будет закрыт (<code>release/notify_and_release</code>).</p>
<p>Но можно попробовать переписать код так, чтобы работа выполнялась в потоке, но была спрятана внутри асинхронной функции-корутине, которая предоставляет интерфейс в виде стандартного итератора. Используем предыдущий игрушечный пример с асинхронным счётчиком.<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> </span><br><span class="line">    ValueOrReady = variant&lt;value:<span class="keyword">int</span>; ready:<span class="keyword">bool</span>&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Answer</span></span></span><br><span class="line"><span class="class">    <span class="title">value</span>:</span><span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//поток</span></span><br><span class="line"><span class="function">def <span class="title">work_in_thread</span><span class="params">(var channel: Channel?)</span></span></span><br><span class="line">    new_thread &lt;| @</span><br><span class="line">        <span class="comment">//print("in thread\n")</span></span><br><span class="line">        <span class="function"><span class="keyword">for</span> i in <span class="title">range</span><span class="params">(<span class="number">100</span>)</span></span></span><br><span class="line">            if i % 10 == 0</span><br><span class="line">                channel |&gt; push_clone([[Answer value=i]])</span><br><span class="line">            sleep(<span class="number">100u</span>)</span><br><span class="line">        channel |&gt; notify_and_release</span><br><span class="line">        <span class="comment">//completion |&gt; notify_and_release</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//корутина, создающая поток и представляющая его результат</span></span><br><span class="line">[coroutine]</span><br><span class="line"><span class="function">def <span class="title">makeLongCalculationInThread</span><span class="params">(work)</span> : ValueOrReady</span></span><br><span class="line"><span class="function">    var channel </span>= unsafe_channel_create()</span><br><span class="line">    invoke(work, channel)</span><br><span class="line">    <span class="keyword">while</span> channel.size &gt;= <span class="number">0</span></span><br><span class="line">        var answer: ValueOrReady</span><br><span class="line">        <span class="keyword">if</span> !channel.isEmpty</span><br><span class="line">            let void_data = _builtin_channel_pop(channel)</span><br><span class="line">            unsafe</span><br><span class="line">                let typed_data = reinterpret&lt;Answer?#&gt; void_data</span><br><span class="line">                answer = [[ValueOrReady value = typed_data.value]]</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            answer = [[ValueOrReady ready = <span class="literal">false</span>]]</span><br><span class="line">        yield answer</span><br><span class="line">    unsafe_channel_free(channel)</span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main</span><br><span class="line">    <span class="comment">//опрос корутины, готова ли порция данных</span></span><br><span class="line">    <span class="keyword">for</span> num in makeLongCalculationInThread(@@work_in_thread)</span><br><span class="line">        unsafe</span><br><span class="line">            <span class="keyword">if</span> num is value</span><br><span class="line">                print(<span class="string">"&#123;num.value&#125; "</span>)</span><br><span class="line">    print(<span class="string">"\ndone"</span>)</span><br><span class="line"><span class="comment">//Output:</span></span><br><span class="line"><span class="comment">//0 10 20 30 40 50 60 70 80 90</span></span><br></pre></td></tr></table></figure></p>
<p><em>unsafe_channel_create и unsafe_channel_free тут - хак, добавленные в библиотеку работы с каналами функции, потому что стандартное api каналов daScript предоставляет доступ к созданному каналу только внутри блока, а из блока нельзя возвращать значение с помощью yield</em></p>
<p>Теперь внешний интерфейс — это асинхронная функция,  которая запускает вычисление в потоке и возвращает управление, но сохранит результат вычислений из потока в канале, как только он будет готов. Основной поток при этом не блокируется и может продолжать выполнение, до тех пор пока этот результат не потребуется. Когда результат потребуется — функция main либо приостановится, чтобы его дождаться, либо сразу прочитает его из канала, если он уже готов.</p>
<h2 id="Communicating-sequential-processes"><a href="#Communicating-sequential-processes" class="headerlink" title="Communicating sequential processes"></a>Communicating sequential processes</h2><p>Каналы повсеместно используются в <code>Go</code>, примитивы и паттерны работы с ними рассмотрены в [22] и [23] по ссылкам в первой части статьи (теорию по работе с каналами можно гуглить по аббревиатуре <a href="https://en.wikipedia.org/wiki/Communicating_sequential_processes" target="_blank" rel="noopener">CSP</a>). Поиграться с примерами в браузере в можно <a href="https://go.dev/tour/concurrency/1" target="_blank" rel="noopener">тут</a>. Go позволяет создавать буферизированные и небуферизированные каналы. Отличие в том, что при попытке отправить второе сообщение в канал, пока не прочитано первое, тред блокируется до тех пор, пока сообщение не будет прочитано. Каналы в <code>daScript</code> буферизированы, так что можно отправить сразу несколько сообщений без блокировки отправителя, даже если читатель ещё не принял эти сообщения.</p>
<p>В <code>Go</code> есть удобные примитивы для соединения выходов нескольких каналов:<br><img src="/blog/2826376146/dataflow.png" alt=""><br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Funnel_receiveOrTimeout</span><span class="params">(c &lt;- <span class="keyword">chan</span> <span class="keyword">int</span>, duration time.Duration)</span> <span class="params">(data <span class="keyword">int</span>, more, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> data, more = &lt;- c :       <span class="comment">//канал с данными</span></span><br><span class="line">      <span class="keyword">return</span> data, more, <span class="literal">true</span></span><br><span class="line">    <span class="keyword">case</span> &lt;- time.After(duration):  <span class="comment">//канал таймаута, выдаёт сообщение после указанного времени</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>, <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fanout</span><span class="params">(in &lt;- <span class="keyword">chan</span> <span class="keyword">int</span>, out1, out2 <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> data := <span class="keyword">range</span> in &#123; <span class="comment">//получает новые данные</span></span><br><span class="line">    <span class="keyword">select</span> &#123;             <span class="comment">//отправляет в первый попавшийся незаблокированный канал</span></span><br><span class="line">      <span class="keyword">case</span> out1 &lt;- data</span><br><span class="line">      <span class="keyword">case</span> out2 &lt;- data</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>select</code> в первом случае позволяет либо получить сообщение с данными из канала, либо сообщение из канала таймаута, если данных не поступило в течение определенного времени. Во втором — отправить данные в первый свободный канал из списка.</p>
<p><code>Go</code> также отличается тем, что имеет встроенный диспетчер горутин, который распределяет выполнений по нескольким потокам. Таким образом горутины в го — это корутины, которые могут быть выполнены или перенесены в другой поток. Выполнение горутины приостанавливается при ожидании при ожиданнии данных из канала.</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script></div></article><div class="pagination"><a class="pagination__link pagination__next" href="/blog/3309518526/">Раньше</a></div></main><footer class="footer metadata"><p class="footer__text">© 2022 spiiin</p><p class="footer__text">Powered by <a class="footer__text__link" href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a class="footer__text__link" href="https://pages.github.com/" target="_blank">Github Page</a></p></footer></div></body></html>