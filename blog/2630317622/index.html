<!DOCTYPE html><html lang="ru"><head><meta charset="UTF-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Spiiin's blog | daScript - перевод интервью с создателем языка</title><meta name="description" content="&lt;p&gt;Свободный перевод части &lt;a href=&quot;https://80.lv/articles/a-look-at-the-current-state-of-independent-gamedev-software-production/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;статьи&lt;/a&gt; &lt;code&gt;A Look At The Current State of Independent Gamedev Software Production&lt;/code&gt;, интервью с автором языка daScript Борисом Баткиным. Курсивом — мои вставки. Иногда осознанно немного перефразирую или уточняю ответы.&lt;br&gt;"><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=PT+Serif&amp;display=swap"><link rel="stylesheet" href="/css/highlights/darkula.css"><link rel="stylesheet" href="/css/main.css"><link rel="search" type="application/opensearchdescription+xml" href="http://spiiin.github.io/atom.xml" title="Spiiin's blog"><script>(function (i, s, o, g, r, a, m) {
  i['GoogleAnalyticsObject'] = r;
  i[r] = i[r] || function () {
    (i[r].q = i[r].q || []).push(arguments)
  }, i[r].l = 1 * new Date();
  a = s.createElement(o),
    m = s.getElementsByTagName(o)[0];
  a.async = 1;
  a.src = g;
  m.parentNode.insertBefore(a, m)
})(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');
ga('create', 'UA-00000000-0', 'auto');
ga('send', 'pageview');</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Spiiin's blog" type="application/atom+xml">
</head><body><div class="container"><header class="main-header"><h1 class="main-header__title uplize"><a class="main-header__title__link" href="/"><img class="header-image" src="/images/favicon.png" width="36" height="36">Spiiin's blog</a></h1><nav class="main-header__nav"><ul class="main-nav"><li class="main-nav__list"><a class="main-nav__list__link" href="/" target="_self">HOME</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/archives/" target="_self">ARCHIVE</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/tags/meta" target="_self">TAGS</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/blog/1" target="_self">ABOUT</a></li></ul></nav></header><main class="container__wrapper"><article class="article post"><h3 class="article__title">daScript - перевод интервью с создателем языка</h3><div class="article__date metadata"><div class="post-info">2022/06/12</div></div><div class="article__tags metadata">Tags:
<a class="article__tags__link metadata" href="/tags/dascript/">dascript</a></div><div class="article__body"><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Свободный перевод части <a href="https://80.lv/articles/a-look-at-the-current-state-of-independent-gamedev-software-production/" target="_blank" rel="noopener">статьи</a> <code>A Look At The Current State of Independent Gamedev Software Production</code>, интервью с автором языка daScript Борисом Баткиным. Курсивом — мои вставки. Иногда осознанно немного перефразирую или уточняю ответы.<br><a id="more"></a></p>
<p>Пост посвящен храбрым разработчикам и небольшим инди-командам, создающим собственные технологические решения для разработки игр.</p>
<p>Сегодня у нас есть множество мощных движков, доступных бесплатно: <code>Unreal, Unity, Lumberyard, CryEngine</code> и другие решения. Они содержат полный набор инструментов, позволяющий разработчикам экономить время на разработке собственных тулзов.</p>
<p><em>хм, ну не то, чтобы прямо совсем бесплатно доступны…</em></p>
<p>…</p>
<p>Но всё же некоторые разработчики продолжают находить причины, чтобы разрабатывать собственные движки. И мы говорим не только о гигантах вроде <code>Guirilla Games</code> или <code>Rockstar</code>. Одиночки или небольшие инди-команды предлагают свои решения, которые призваны справиться с недостатками существующих решений. Не слишком ли сложно это для маленькой команды? Мы связались с авторами нескольких таких технологий, чтобы узнать у них об их мотивах, проблемах, временных затратах и другом.</p>
<p><em>если говорить о daScript, то “Гайдзины” — не то, чтобы маленькая команда, и имеет свои наработки в области скриптовых языков, а также использования их в продакшене, где-то лет так 15 как минимум</em></p>
<p>…</p>
<h2 id="Разработка-daScript"><a href="#Разработка-daScript" class="headerlink" title="Разработка daScript"></a>Разработка daScript</h2><p>Мы связались с Борисом Баткиным, разработчиком <code>daScript</code>. Это высокоуровневый скриптовый язык с сильной статической типизацией. Цель разработки — создать быстрый язык для встраивания в качестве скриптового языка в C++ для критичных по производительности приложений, таких как игры. Посмотрим внимательнее на <code>daScript</code> и на то, как он может помочь улучшить производительность.</p>
<p><strong>Расскажи пожалуйста о daScript. Почему и когда ты начал над ним работать?</strong></p>
<p>С самого начала моей карьеры как программиста я хотел создать собственный язык. Фактически, первое, чем я занимался, работая в игровой индустрии в 2000х, было написание кросс-компилятора из <code>UnrealScript</code> в <code>C++</code>. С тех пор я думал о создании своего языка.</p>
<p>В 2005 я создал несколько черновиков и прототипов, когда я работал на <code>Naughty Dogs</code> и они экспериментировали со своим лиспо-подобным языком <code>Goal</code>, от которого им пришлось отказаться при переходе от PlayStation2 к PlayStation3. Тогда у нас было много продуктивных дискуссий, который натолкнули меня на некоторые идеи.</p>
<p><em>позволю себе втыкнуть сюда собственные размышления о языках программирования, применительно к геймдеву и не только</em><br><em><a href="/blog/3652741154/" title="10 лет в геймдеве">10 лет в геймдеве</a> — раздел языки программирования, про опыт использования разных языков<br><a href="/blog/1808122922/" title="Nim in imaginary world">Nim in imaginary world</a> — мои критерии выбора языка для хобби- и профессиональной разработки<br><a href="/blog/2297379949/" title="Заметки о языках программирования">Заметки о языках программирования</a> — сборник заметок про языки разного уровня и целей<br><a href="/blog/1728194429/" title="С++ в геймдеве">С++ в геймдеве</a> — почему C++ и всё ли с этим правильно</em></p>
<p>Уже тогда было до боли очевидно, что язык должен быть встраиваемым (<em>в С++</em>). Большинство компаний используют для создания игр подмножество <code>C++</code> (каждая — своё). Какой бы скриптовый язык мы ни придумали, он должен хорошо совмещаться с существующей кодовой базой. Можно думать о <code>C++</code> как платформе, тогда специализированный язык для игр должен работать на этой платформе. Подобные вещи происходили с другими платформами. <code>Java</code> получила <code>Scala</code>, а позже <code>Kotlin</code>, браузер в определенный момент стал платформой, и получил несколько языков, транслируемых в <code>JavaScript</code>, у <code>.Net</code> сначала был только <code>C#</code>, но позже получил жизнеспособный <code>F#</code>. <code>daScript</code> является чем-то подобным для <code>C++</code>.</p>
<p>Игровая индустрия давно нуждается в более практичном решении. C++ нельзя назвать идеальным языком программирования, если не сказать ещё хуже. Он многословен, он имеет очень крутую кривую обучения. Мультиплатформенное программирование на C++ напоминает обход минного поля. Вcё может внезапно взорваться. Но при этом, он позволяет создать надёжный код, поэтому мы его используем. Но желание иметь простое решение для быстрых итераций разработки — очень привлекательно.</p>
<p>Встроенные языки, которые обычно используются в индустрии игр, динамически типизируемые, с дорогостоящей передачей управления между C++ и скриптовым языком. <code>Lua (с LuaJIT), Squirrel, DukTape/QuickJS</code> - вот только некоторые из примеров. В большинстве из них лучшая производительность достигается за счёт just-in-time (JIT), но такая возможность вообще не доступна на большинстве закрытых платформ, таких как консоли или iOS. Маршаллинг данных между нативным и скриптовым кодом быстро становится серьёзной проблемой, даже при включенном JIT. Как правило, такая производительность приемлема только для event-driven приложений с отправкой сообщений, и на этом точка. Но такой подход не масштабируется для приложений типа игр. В результате большая часть “тяжёлого” кода либо сразу пишется на C++, либо же сначала пишется прототип на скриптовом языке, который затем переписывается на C++.</p>
<p><em>Антон Юдинцев в своём <a href="https://youtu.be/IvHGczF6Go0?t=1301" target="_blank" rel="noopener">докладе</a> про daScript ссылается в качестве примера на <a href="https://youtu.be/KHWquMYtji0" target="_blank" rel="noopener">доклады</a> про оптимизацию Fortnite на мобильные платформы — большая часть оптимизаций заключается в том, чтобы переписать код с блюпринтов на C++. Мой опыт использования Squirrel в продакшене для мобильных телефонов — ~20% работы состоит в переписывании со скриптов обратно на C++</em>.</p>
<p>Есть примеры статически типизированных скриптовых языков в геймдеве, <code>UnrealScript</code> — один из первых заметных успешных. Однако он показал проблемы с масштабируемостью. Рано или поздно наступает момент, когда “переписать медленную часть на C++” становится типичным решением проблем с производительностью в проекте. В конце концов, <code>Unreal</code> перешёл к <code>BluePrint</code>, у которого есть собственные минусы.</p>
<p>ООП в стиле C++ (<em>данные разбросаны на хипе</em>) - серьёзное препятствие для написания быстрого кода. Большинство языков предназначены в основном для поддержки той или иной модели программирования. Однако в разработке игр в наши дни часто необходим более ориентированный на данные подход (<em>data oriented design</em>). Многие переходят на ECS-фреймворки, которые сопровождаются какой-либо дополнительной инфраструктурой. <code>Unity</code> создала компилятор <code>Burst</code>, использующий подмножество C# для решения проблемы связи фреймворка с языком. Джонатан Блоу разрабатывает язык <code>Jai</code> для решения той же проблемы. Языки, которые изначально спроектированы с учётом возможности использования с data-oriented фреймворками, могут сделать взаимодействие с ними проше, и <code>daScript</code> делает шаг в этом направлении.</p>
<p>Когда в 2018 году Антон Юдинцев из <code>Gaijin Entertaiment</code> обратился ко мне с предложением создать собственный язык для их ECS-фреймворка, я “купился”. Запрос был достаточно конкретным, чтобы заинтересовать меня — язык общего назначения с “большой идеей” это не просто академическое упражнение, его очень трудно создать и еще труднее адаптировать к продакшену.</p>
<p><strong>Какие преимущества использования daScript? Как его можно использовать для разработки игр? Как это повлияет на производительность?</strong></p>
<p><code>daScript</code> работает быстро. Передача управления между C++ и daScript очень дешёвая. У него очень быстрый интерпретатор. Он выполняется с той же скоростью, что и нативный C++, если использует ahead-of-time компиляцию. По сути, вам никогда не придётся ничего переписывать с daScript на C++.</p>
<p><strong><em><code>(!) Это серьёзная заявка на киллер-фичу языка. Одну из. Вторая -- при небольшой настройке должно быть можно получить hot code reload, время перекомпиляции+перезапуска игры на мобилках, да и на ПК, критично</code></em></strong></p>
<p>daScript — безопасный, статически типизированный язык с сильной типизацией, с параноидальным уровней проверки ошибок. Однако у него очень надёжный механизм вывода типов, поэтому большая часть времени вам не нужно декорировать свой код информацией о типах. Безопасный код на языке обычно и выглядит просто, а небезопасный — должен быть явно помечен как таковой.</p>
<p>daScript — встраиваемый язык. Он хорошо сочетается с вашей кодовой базой на C++. Он сам компилируется тем же компилятором на тех же платформах. Нет проблемы с тем, что платформа не поддерживает JIT, потому что вы можете просто пред-компилировать все скрипты в C++ (aheod-of-time компиляция). При этом, вы можете “патчить” скопмилированные в C++-скрипты с помощью обновлённой интерпретируемой версии в реальном времени.</p>
<p><em>(Либо обновляя скрипты на девайсе на лету, либо присылая их “динамиками” с сервера)</em></p>
<p>Язык предоставляет очень глубокие механизмы интеграции, которые выходят далеко за рамки простого связывания методов, чтобы такие вещи, как ECS-фреймворк, могли получить всю необходимую им дополнительную информацию, как используются данные. Мы можем контроллировать, как именно интерпретируется daScript, и какой именно C++ код будет сгенерирован.</p>
<p><em>(Тут я чё-то не допонимаю, о чём именно говорит автор, не видел в репозитории примеров, возможно речь о <a href="/blog/1547564887/" title="синтаксических макросах">синтаксических макросах</a>)</em></p>
<p>daScript — язык для повышения продуктивности программистов. У него очень быстрое время компиляции. Он поддерживает горячую перезагрузку. Обычно изменения в коде отображаются в программе, как только они слетели с кончиков ваших пальцев. При правильной настройке вы можете запустить приложение и затем реализовать совершенно новую фичу, даже не перезапуская его.</p>
<p><strong><em><code>(!) а это -- заявка на киллер-фичу #2</code></em></strong></p>
<p><strong>Разработка собственного решения может показаться слишком сложной для большинства разработчиков, что же заставляет кого-то создавать что-то новое и сложное?</strong></p>
<p>Некоторые говорят, что необходимость — это мать изобретений. В какой-то момент становится совершенно очевидно, что никакие эволюционные улучшения не позволят сделать следующий шаг в качестве разработки. Наличие хорошего инструмента является признаком хорошего инженерного мышления. В случае с daScript было очевидно, что информацию, необходимую для среды ECS, очень сложно извлечь из кода на C++. Что программисту необходимо будет искуственно размечать код определенным образом, и этот процесс будет постоянно подвержен ошибкам в ходе написания и поддержки, и это просто чтобы предоставить информацию для эффективной работы фреймворка. Добавьте к сравнению разницу в скорости — даже прототип daScript был в 10-35 раз быстрее, чем LuaJit, и вдруг создание новый языка уже покажется очень хорошим вложением.</p>
<p><code>LuaJit</code> бьл хорошим источником вдохновения. Удивительно, как много можно сделать для языка, который не был спроектирован для достижения максимальной производительности. Если же сделать что-то подобное для языка, который изначально затачивался, чтобы быть производительным, должно быть возможно достичь поразительных результатов. При этом превзойти LuaJit — это непростой челлендж, он задаёт высокую планку, ни один интерпретируемый язык не может даже близко приблизиться к нему.</p>
<p>Когда дело доходит до фич самого языка, то идеи брались из самых различных источников: <code>Kotlin, Python, Ruby, Lisp, F#, HLSL</code> (!!!) — всего лишь некоторые из них. Одной из ключевых идея было “сделать что-то похожее, только работающее с сумасшедшей скоростью”.</p>
<p>Другая идея: “писать меньше лишнего”. Наличие в языке простых, но сильных генериков было обязательным с самого начала. Статически типизируемые языки без обобщений и вывода типов, как правило, очень многословны. С другой стороны, декларативное обобщенное программирование очень контр-интуитивно, поэтому мы пошли путём возможности проверки условий во время компиляции и при этом возможностью явно указать…, ну, вообще всё.</p>
<p><em>(? в оригинале: and explicit… well, explicit everything.)</em></p>
<p>Сосредоточение внимания на функциональном программировании и data-oriented design подходе, а не на классическом ООП, было еще одним сознательным решением. Язык должен был быть быстрым, а классическое ООП просто не позволило бы сделать его таким.</p>
<p><strong>Расскажи пожалуйста, о затратах времени. Сколько времени ушло на то, чтобы создать ядро языка? Какие дальнейшие планы?</strong></p>
<p>Потребовалось 3 месяца, чтобы создать прототип. С тех пор прошло около года, и язык сильно повзрослел. Теперь он работает у нас на клиенте и на сервере, и объём кода только растёт. Роадмап развития языка:</p>
<ul>
<li>Доработать язык до спецификации. Сейчас в нём не хватает нескольких важных задуманных вещей.<br>— Variant types.<br>— Мощный pattern-matching.<br>— Нативная поддержка генераторов (yield).<br>— Нативная поддержка регулярных выражений.</li>
<li>Переписать компилятор daScript и всё остальное (кроме рантайма) на нём самом.<br>— Это даст возможность представлять AST языка для чтения и записи на нём самом. Сейчас, сложные макросы и аннотации функция необходимо писать на нём самом.<br><em>(доступ к ast из daScript есть на момент перевода статьи, как и часть фич выше)</em></li>
<li>GPU бекэнд. Сейчас aot-компиляция доступна только в C++, но нет никакой фундаментальной причины для этого ограничения.</li>
<li>Стандартная библиотека и дополнительные модули.<br>— В стандартной библиотеке не хватает многих вещей, особенно для функционального программирования. Как только будут доделаны генераторы, следом нужно будет реализовать стандартные функции высшего порядка.<br><em>(вроде тоже есть уже)</em><br>— Существует несколько де-факто стандартных библиотек, для которых стоит сделать привязку “из коробки”. PugiXml, RapidJson, UriParser и другие.</li>
<li>Оптимизации, множество и множество оптимизаций.<br>— daScript уже оптимизирующий компилято с большими возможностями, которые будут только расти.<br>— daScript уже экстремально быстрый интерпретатор. И это лишь хорошая причина для того, чтобы сделать его еще быстрее.<br>— daScript при AoT-компиляции генерирует вполне читабельный C++-код. Однако мы хотели бы сделать, чтобы результирующий код на C++ был более надёжным.</li>
</ul>
<p>Несмотря на то, что еще слишком рано для standalone компилятора daScript, уже очевидно, что LLVM-бекэнд позволил бы генерировать значительно лучший код, чем AoT-бекэнд. Компилятор daScript знает некоторые факт о том, как используется код, такие как выравнивание, aliasing, зависимости и т.д., которые очень сложно передать компилятору C++. Так что в какой-то момент, вероятно, появится LLVM-бекэнд и возможность использовать daScript для полного цикла разработки, но я не думаю, что это произойдёт скоро.</p>
<p><a href="https://github.com/borisbat" target="_blank" rel="noopener">Борис Баткин</a>, разработчик языка <a href="https://dascript.org/" target="_blank" rel="noopener">daScript</a></p>
<p><em>От себя добавлю немного</em>:</p>
<ul>
<li>Скорость итераций разработки, который можно добиться с помощью скриптов — ключевой путь к качеству и выживанию игры-сервиса (а такие — почти все игры сейчас)</li>
<li>Скорость кода — важный параметр, чтобы у вас телефон с 4х-ядерным процессором, и вообщем-то неплохим GPU и кол-вом RAM не считался “тостером” (у конкурентов-то игра на нём отлично работать будет)</li>
<li>Отсутствие необходимости переписывать код с одного языка на другой ради ускорения просто экономит время, за которое можно сделать что-нибудь новое</li>
<li>До продакшена долетают типичные ошибки C++ (а это у всех бывает, в тексте ссылка на доклад Антона Юдинцева о статистике ошибок в Warthunder) — если станет меньше C++-кода (и меньше доступа к этому коду у неквалифицированных программистов) - станет и меньше таких ошибок</li>
<li>Высокая скорость разработки фич (hot-code reload об этом) — один из необходимых моментов для перехода к созданию более масштабных в плане количества кода игр (эх, ещё бы стоимость создания арта для более масштабных проектов как-нибудь сократить)</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script></div></article><section class="comments"><div id="disqus_thread"></div><script>var disqus_shortname = 'spiiin-github-io';
(function () {
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//#{theme.disqus}.disqus.com/count.js" async></script></section><div class="pagination"><a class="pagination__link pagination__prev" href="/blog/2786387393/">Next</a><a class="pagination__link pagination__next" href="/blog/500729544/">Back</a></div></main><footer class="footer metadata"><p class="footer__text">© 2022 spiiin</p><p class="footer__text">Powered by <a class="footer__text__link" href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a class="footer__text__link" href="https://pages.github.com/" target="_blank">Github Page</a></p></footer></div></body></html>