<!DOCTYPE html><html lang="ru"><head><meta charset="UTF-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Spiiin's blog | daScript. Brainfuck и оптимизации</title><meta name="description" content="&lt;p&gt;Попробовал портировать с &lt;code&gt;nim&lt;/code&gt; на &lt;code&gt;daScript&lt;/code&gt; &lt;a href=&quot;https://howistart.org/posts/nim/1/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;интерпретатор&lt;/a&gt; &lt;code&gt;brainfuck&lt;/code&gt; кода. Брейфак предельно простой язык, и базовая реализация интерпретатора занимает полчаса, но на нём можно потренироваться в ускорении кода и продемонстрировать возможности daScript в оптимизации.&lt;/p&gt;"><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=PT+Serif&amp;display=swap"><link rel="stylesheet" href="/css/highlights/darkula.css"><link rel="stylesheet" href="/css/main.css"><link rel="search" type="application/opensearchdescription+xml" href="http://spiiin.github.io/atom.xml" title="Spiiin's blog"><script>(function (i, s, o, g, r, a, m) {
  i['GoogleAnalyticsObject'] = r;
  i[r] = i[r] || function () {
    (i[r].q = i[r].q || []).push(arguments)
  }, i[r].l = 1 * new Date();
  a = s.createElement(o),
    m = s.getElementsByTagName(o)[0];
  a.async = 1;
  a.src = g;
  m.parentNode.insertBefore(a, m)
})(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');
ga('create', 'UA-00000000-0', 'auto');
ga('send', 'pageview');</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Spiiin's blog" type="application/atom+xml">
</head><body><div class="container"><header class="main-header"><h1 class="main-header__title uplize"><a class="main-header__title__link" href="/"><img class="header-image" src="/images/favicon.png" width="36" height="36">Spiiin's blog</a></h1><nav class="main-header__nav"><ul class="main-nav"><li class="main-nav__list"><a class="main-nav__list__link" href="/" target="_self">HOME</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/archives/" target="_self">ARCHIVE</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/tags/meta" target="_self">TAGS</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/blog/1" target="_self">ABOUT</a></li></ul></nav></header><main class="container__wrapper"><div class="pagination"><a class="pagination__link pagination__prev" href="/blog/1976052536/">Позже</a><a class="pagination__link pagination__next" href="/blog/1601029690/">Раньше</a></div><article class="article post"><h3 class="article__title">daScript. Brainfuck и оптимизации</h3><div class="article__date metadata"><div class="post-info">2022/11/11</div></div><div class="article__tags metadata">Tags:
<a class="article__tags__link metadata" href="/tags/longread/">longread</a><a class="article__tags__link metadata" href="/tags/llvm/">llvm</a><a class="article__tags__link metadata" href="/tags/dascript/">dascript</a></div><div class="article__body"><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Попробовал портировать с <code>nim</code> на <code>daScript</code> <a href="https://howistart.org/posts/nim/1/" target="_blank" rel="noopener">интерпретатор</a> <code>brainfuck</code> кода. Брейфак предельно простой язык, и базовая реализация интерпретатора занимает полчаса, но на нём можно потренироваться в ускорении кода и продемонстрировать возможности daScript в оптимизации.</p>
<a id="more"></a>
<p>Самая первая, максимально наивная, построчно скопированная реализация:</p>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">require strings</span><br><span class="line">require fio</span><br><span class="line"></span><br><span class="line">def run(code: string; var tape: array&lt;uint8&gt;; var codePos, tapePos: int&amp;; skip: bool): bool</span><br><span class="line">	<span class="keyword">while</span> tapePos &gt;= <span class="number">0</span> &amp;&amp; codePos &lt; length(code)</span><br><span class="line">		<span class="keyword">if</span> tapePos &gt;= length(tape) &#123; tape |&gt; push(uint8(<span class="number">0</span>)); &#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">let</span> sym1  = code |&gt; character_at(codePos)</span><br><span class="line">		<span class="keyword">if</span> sym1 == '['</span><br><span class="line">			++codePos</span><br><span class="line">			<span class="keyword">let</span> oldPos = codePos</span><br><span class="line">			<span class="keyword">while</span> run(code, tape, codePos, tapePos, tape[tapePos] == uint8(<span class="number">0</span>))</span><br><span class="line">				codePos = oldPos</span><br><span class="line">		<span class="keyword">elif</span> sym1 == ']'</span><br><span class="line">			<span class="keyword">return</span> tape[tapePos] != uint8(<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">elif</span> !skip</span><br><span class="line">			<span class="keyword">let</span> sym  = code |&gt; character_at(codePos)</span><br><span class="line">			<span class="keyword">if</span> sym == '+' &#123; tape[tapePos] = uint8(int(tape[tapePos]) + <span class="number">1</span>); &#125;</span><br><span class="line">			<span class="keyword">elif</span> sym == '-' &#123; tape[tapePos] = uint8(int(tape[tapePos]) - <span class="number">1</span>); &#125;</span><br><span class="line">			<span class="keyword">elif</span> sym == '&gt;' &#123; ++tapePos; &#125;</span><br><span class="line">			<span class="keyword">elif</span> sym == '&lt;' &#123; --tapePos; &#125;</span><br><span class="line">			<span class="keyword">elif</span> sym == '.' &#123; print(<span class="string">"&#123;int(tape[tapePos]) |&gt; to_char&#125;"</span>); &#125;</span><br><span class="line">			<span class="keyword">elif</span> sym == ',' &#123; tape[tapePos] = uint8(getchar()); &#125;</span><br><span class="line">			<span class="keyword">else</span> &#123; &#125;</span><br><span class="line">		++codePos</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span></span><br><span class="line"></span><br><span class="line">def interpret(code: string)</span><br><span class="line">	<span class="keyword">let</span> totalTime = ref_time_ticks()</span><br><span class="line">	var tape: array&lt;uint8&gt;</span><br><span class="line">	var codePos, tapePos : int</span><br><span class="line">	run(code, tape, codePos, tapePos, <span class="keyword">false</span>)</span><br><span class="line">	<span class="keyword">let</span> totalDt = double(get_time_usec(totalTime)) /<span class="number">1000000.0</span>lf</span><br><span class="line">	to_log(LOG_INFO, <span class="string">"total &#123;totalDt&#125; sec\n"</span>)</span><br></pre></td></tr></table></figure>
<p>Если попытаться протестировать его на генераторе <a href="https://github.com/def-/nim-brainfuck/blob/master/examples/mandelbrot.b" target="_blank" rel="noopener">множества Мандельброта</a>, можно заметить серьёзные проблемы со скоростью, вычисления занимают около 5 часов. Стоит попробовать его разогнать!</p>
<h2><span id="otklyuchenie-proverok-granic-i-ukazateley">Отключение проверок границ и указателей</span><a href="#otklyuchenie-proverok-granic-i-ukazateley" class="header-anchor">#</a></h2><p>Код на brainfuck - это простая числодробилка, ускорить которую можно, отключив все дополнительные проверки обращений к памяти.</p>
<p><em>Как отключать проверки, мне рассказал <a href="https://github.com/borisbat" target="_blank" rel="noopener">Борис Баткин</a> (так как интерпретатор nim делал один основных контрибьютеров языка, то его подсказки не отменяют честности сравнения — авторы находятся в одной “весовой категории” знания своего языка).</em></p>
<p>В первую очередь, можно заменить функцию <code>charcter_at</code>, которая <a href="https://github.com/GaijinEntertainment/daScript/blob/e9f4c486848a8985e4126e0fc2d04afbc6abd883/src/builtin/module_builtin_string.cpp#L26" target="_blank" rel="noopener">проверяет</a>,что индекс меньше длины строки, на <code>character_uat</code>, которая не делает этой проверки.</p>
<p>Также отключается проверка ссылок на null макросом <code>[unsafe_deref]</code>.</p>
<p>Наконец, обращение к массиву можно выполнять не через разыменование ссылки, а через обращение по указателю:</p>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">tape: array&lt;uint8&gt;</span><br><span class="line">tape[index] <span class="comment">// tape[check_range(index)] //медленно</span></span><br><span class="line"></span><br><span class="line">var ptape: uint8? = addr(tape[<span class="number">0</span>])</span><br><span class="line">ptape[index] <span class="comment">//check_not_null(ptape)[index] //быстрее, обращение без проверок</span></span><br><span class="line"></span><br><span class="line">[unsafe_deref]</span><br><span class="line">ptape[index] <span class="comment">//ptape[index] //еще быстрее, обращение без перепроверок указателя на nullptr</span></span><br></pre></td></tr></table></figure>
<p>Переписанная версия кода:</p>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">[unsafe_deref]</span><br><span class="line">def run(code: uint8?; lengthOfCode:int; var tape: uint8?; var codePos, tapePos: int&amp;; skip: bool): bool</span><br><span class="line">	unsafe</span><br><span class="line">		<span class="keyword">while</span> tapePos &gt;= <span class="number">0</span> &amp;&amp; codePos &lt; lengthOfCode</span><br><span class="line">			<span class="keyword">let</span> sym1  = int(code[codePos])</span><br><span class="line">			<span class="keyword">if</span> sym1 == '['</span><br><span class="line">				++codePos</span><br><span class="line">				<span class="keyword">let</span> oldPos = codePos</span><br><span class="line">				<span class="keyword">while</span> run(code, lengthOfCode, tape, codePos, tapePos, tape[tapePos] == uint8(<span class="number">0</span>))</span><br><span class="line">					codePos = oldPos</span><br><span class="line">			<span class="keyword">elif</span> sym1 == ']'</span><br><span class="line">				<span class="keyword">return</span> tape[tapePos] != uint8(<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">elif</span> !skip</span><br><span class="line">				<span class="keyword">let</span> sym  = int(code[codePos])</span><br><span class="line">				<span class="keyword">if</span> sym == '+' &#123; tape[tapePos] = uint8(int(tape[tapePos]) + <span class="number">1</span>); &#125;</span><br><span class="line">				<span class="keyword">elif</span> sym == '-' &#123; tape[tapePos] = uint8(int(tape[tapePos]) - <span class="number">1</span>); &#125;</span><br><span class="line">				<span class="keyword">elif</span> sym == '&gt;' &#123; ++tapePos; &#125;</span><br><span class="line">				<span class="keyword">elif</span> sym == '&lt;' &#123; --tapePos; &#125;</span><br><span class="line">				<span class="keyword">elif</span> sym == '.' &#123; print(int(tape[tapePos]) |&gt; to_char); &#125;</span><br><span class="line">				<span class="keyword">elif</span> sym == ',' &#123; tape[tapePos] = uint8(getchar()); &#125;</span><br><span class="line">				<span class="keyword">else</span> &#123; &#125;</span><br><span class="line">			++codePos</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span></span><br><span class="line"></span><br><span class="line">def interpret(code: string)</span><br><span class="line">	<span class="keyword">let</span> totalTime = ref_time_ticks()</span><br><span class="line">	var tape: array&lt;uint8&gt;</span><br><span class="line">	var codePos, tapePos : int</span><br><span class="line">	tape |&gt; resize(<span class="number">1000000</span>)</span><br><span class="line">	unsafe</span><br><span class="line">		run(reinterpret&lt;uint8?&gt; code, length(code), addr(tape[<span class="number">0</span>]), codePos, tapePos, <span class="keyword">false</span>)</span><br><span class="line">	<span class="keyword">let</span> totalDt = double(get_time_usec(totalTime)) /<span class="number">1000000.0</span>lf</span><br><span class="line">	to_log(LOG_INFO, <span class="string">"total &#123;totalDt&#125; sec\n"</span>)</span><br></pre></td></tr></table></figure>
<p>Такая версия интерпретатора всё ещё тормозная, но уже позволяет дождаться завершения выполнения кода:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">e:\src\daScript\bin\Release&gt;daScript.exe brainfuck_00.das</span><br><span class="line">AAAAAAAAAAAAAAAABBBBBBBBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDEGFFEEEEDDDDDDCCCCCCCCCBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB</span><br><span class="line">AAAAAAAAAAAAAAABBBBBBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDEEEFGIIGFFEEEDDDDDDDDCCCCCCCCCBBBBBBBBBBBBBBBBBBBBBBBBBB</span><br><span class="line">AAAAAAAAAAAAABBBBBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDEEEEFFFI KHGGGHGEDDDDDDDDDCCCCCCCCCBBBBBBBBBBBBBBBBBBBBBBB</span><br><span class="line">AAAAAAAAAAAABBBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDEEEEEFFGHIMTKLZOGFEEDDDDDDDDDCCCCCCCCCBBBBBBBBBBBBBBBBBBBBB</span><br><span class="line">AAAAAAAAAAABBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDEEEEEEFGGHHIKPPKIHGFFEEEDDDDDDDDDCCCCCCCCCCBBBBBBBBBBBBBBBBBB</span><br><span class="line">AAAAAAAAAABBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDEEEEEEFFGHIJKS  X KHHGFEEEEEDDDDDDDDDCCCCCCCCCCBBBBBBBBBBBBBBBB</span><br><span class="line">AAAAAAAAABBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDEEEEEEFFGQPUVOTY   ZQL[MHFEEEEEEEDDDDDDDCCCCCCCCCCCBBBBBBBBBBBBBB</span><br><span class="line">AAAAAAAABBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDEEEEEFFFFFGGHJLZ         UKHGFFEEEEEEEEDDDDDCCCCCCCCCCCCBBBBBBBBBBBB</span><br><span class="line">AAAAAAABBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDEEEEFFFFFFGGGGHIKP           KHHGGFFFFEEEEEEDDDDDCCCCCCCCCCCBBBBBBBBBBB</span><br><span class="line">AAAAAAABBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDEEEEEFGGHIIHHHHHIIIJKMR        VMKJIHHHGFFFFFFGSGEDDDDCCCCCCCCCCCCBBBBBBBBB</span><br><span class="line">AAAAAABBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDEEEEEEFFGHK   MKJIJO  N R  X      YUSR PLV LHHHGGHIOJGFEDDDCCCCCCCCCCCCBBBBBBBB</span><br><span class="line">AAAAABBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDEEEEEEEEEFFFFGH O    TN S                       NKJKR LLQMNHEEDDDCCCCCCCCCCCCBBBBBBB</span><br><span class="line">AAAAABBCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDEEEEEEEEEEEEFFFFFGHHIN                                 Q     UMWGEEEDDDCCCCCCCCCCCCBBBBBB</span><br><span class="line">AAAABBCCCCCCCCCCCCCCCCCCCCCCCCCDDDDEEEEEEEEEEEEEEEFFFFFFGHIJKLOT                                     [JGFFEEEDDCCCCCCCCCCCCCBBBBB</span><br><span class="line">AAAABCCCCCCCCCCCCCCCCCCCCCCDDDDEEEEEEEEEEEEEEEEFFFFFFGGHYV RQU                                     QMJHGGFEEEDDDCCCCCCCCCCCCCBBBB</span><br><span class="line">AAABCCCCCCCCCCCCCCCCCDDDDDDDEEFJIHFFFFFFFFFFFFFFGGGGGGHIJN                                            JHHGFEEDDDDCCCCCCCCCCCCCBBB</span><br><span class="line">AAABCCCCCCCCCCCDDDDDDDDDDEEEEFFHLKHHGGGGHHMJHGGGGGGHHHIKRR                                           UQ L HFEDDDDCCCCCCCCCCCCCCBB</span><br><span class="line">AABCCCCCCCCDDDDDDDDDDDEEEEEEFFFHKQMRKNJIJLVS JJKIIIIIIJLR                                               YNHFEDDDDDCCCCCCCCCCCCCBB</span><br><span class="line">AABCCCCCDDDDDDDDDDDDEEEEEEEFFGGHIJKOU  O O   PR LLJJJKL                                                OIHFFEDDDDDCCCCCCCCCCCCCCB</span><br><span class="line">AACCCDDDDDDDDDDDDDEEEEEEEEEFGGGHIJMR              RMLMN                                                 NTFEEDDDDDDCCCCCCCCCCCCCB</span><br><span class="line">AACCDDDDDDDDDDDDEEEEEEEEEFGGGHHKONSZ                QPR                                                NJGFEEDDDDDDCCCCCCCCCCCCCC</span><br><span class="line">ABCDDDDDDDDDDDEEEEEFFFFFGIPJIIJKMQ                   VX                                                 HFFEEDDDDDDCCCCCCCCCCCCCC</span><br><span class="line">ACDDDDDDDDDDEFFFFFFFGGGGHIKZOOPPS                                                                      HGFEEEDDDDDDCCCCCCCCCCCCCC</span><br><span class="line">ADEEEEFFFGHIGGGGGGHHHHIJJLNY                                                                        TJHGFFEEEDDDDDDDCCCCCCCCCCCCC</span><br><span class="line">A                                                                                                 PLJHGGFFEEEDDDDDDDCCCCCCCCCCCCC</span><br><span class="line">ADEEEEFFFGHIGGGGGGHHHHIJJLNY                                                                        TJHGFFEEEDDDDDDDCCCCCCCCCCCCC</span><br><span class="line">ACDDDDDDDDDDEFFFFFFFGGGGHIKZOOPPS                                                                      HGFEEEDDDDDDCCCCCCCCCCCCCC</span><br><span class="line">ABCDDDDDDDDDDDEEEEEFFFFFGIPJIIJKMQ                   VX                                                 HFFEEDDDDDDCCCCCCCCCCCCCC</span><br><span class="line">AACCDDDDDDDDDDDDEEEEEEEEEFGGGHHKONSZ                QPR                                                NJGFEEDDDDDDCCCCCCCCCCCCCC</span><br><span class="line">AACCCDDDDDDDDDDDDDEEEEEEEEEFGGGHIJMR              RMLMN                                                 NTFEEDDDDDDCCCCCCCCCCCCCB</span><br><span class="line">AABCCCCCDDDDDDDDDDDDEEEEEEEFFGGHIJKOU  O O   PR LLJJJKL                                                OIHFFEDDDDDCCCCCCCCCCCCCCB</span><br><span class="line">AABCCCCCCCCDDDDDDDDDDDEEEEEEFFFHKQMRKNJIJLVS JJKIIIIIIJLR                                               YNHFEDDDDDCCCCCCCCCCCCCBB</span><br><span class="line">AAABCCCCCCCCCCCDDDDDDDDDDEEEEFFHLKHHGGGGHHMJHGGGGGGHHHIKRR                                           UQ L HFEDDDDCCCCCCCCCCCCCCBB</span><br><span class="line">AAABCCCCCCCCCCCCCCCCCDDDDDDDEEFJIHFFFFFFFFFFFFFFGGGGGGHIJN                                            JHHGFEEDDDDCCCCCCCCCCCCCBBB</span><br><span class="line">AAAABCCCCCCCCCCCCCCCCCCCCCCDDDDEEEEEEEEEEEEEEEEFFFFFFGGHYV RQU                                     QMJHGGFEEEDDDCCCCCCCCCCCCCBBBB</span><br><span class="line">AAAABBCCCCCCCCCCCCCCCCCCCCCCCCCDDDDEEEEEEEEEEEEEEEFFFFFFGHIJKLOT                                     [JGFFEEEDDCCCCCCCCCCCCCBBBBB</span><br><span class="line">AAAAABBCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDEEEEEEEEEEEEFFFFFGHHIN                                 Q     UMWGEEEDDDCCCCCCCCCCCCBBBBBB</span><br><span class="line">AAAAABBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDEEEEEEEEEFFFFGH O    TN S                       NKJKR LLQMNHEEDDDCCCCCCCCCCCCBBBBBBB</span><br><span class="line">AAAAAABBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDEEEEEEFFGHK   MKJIJO  N R  X      YUSR PLV LHHHGGHIOJGFEDDDCCCCCCCCCCCCBBBBBBBB</span><br><span class="line">AAAAAAABBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDEEEEEFGGHIIHHHHHIIIJKMR        VMKJIHHHGFFFFFFGSGEDDDDCCCCCCCCCCCCBBBBBBBBB</span><br><span class="line">AAAAAAABBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDEEEEFFFFFFGGGGHIKP           KHHGGFFFFEEEEEEDDDDDCCCCCCCCCCCBBBBBBBBBBB</span><br><span class="line">AAAAAAAABBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDEEEEEFFFFFGGHJLZ         UKHGFFEEEEEEEEDDDDDCCCCCCCCCCCCBBBBBBBBBBBB</span><br><span class="line">AAAAAAAAABBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDEEEEEEFFGQPUVOTY   ZQL[MHFEEEEEEEDDDDDDDCCCCCCCCCCCBBBBBBBBBBBBBB</span><br><span class="line">AAAAAAAAAABBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDEEEEEEFFGHIJKS  X KHHGFEEEEEDDDDDDDDDCCCCCCCCCCBBBBBBBBBBBBBBBB</span><br><span class="line">AAAAAAAAAAABBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDEEEEEEFGGHHIKPPKIHGFFEEEDDDDDDDDDCCCCCCCCCCBBBBBBBBBBBBBBBBBB</span><br><span class="line">AAAAAAAAAAAABBBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDEEEEEFFGHIMTKLZOGFEEDDDDDDDDDCCCCCCCCCBBBBBBBBBBBBBBBBBBBBB</span><br><span class="line">AAAAAAAAAAAAABBBBBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDEEEEFFFI KHGGGHGEDDDDDDDDDCCCCCCCCCBBBBBBBBBBBBBBBBBBBBBBB</span><br><span class="line">AAAAAAAAAAAAAAABBBBBBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDEEEFGIIGFFEEEDDDDDDDDCCCCCCCCCBBBBBBBBBBBBBBBBBBBBBBBBBB</span><br><span class="line">[I] total 564.99929999999994834 sec</span><br></pre></td></tr></table></figure>
<p>564 секунды — в 30 раз быстрее первой версии, но всё ещё сильно медленнее интерпретатора на <code>nim</code>, который в релизной версии выполняется за 40 секунд.</p>
<h2><span id="ahead-of-time">Ahead-of-Time</span><a href="#ahead-of-time" class="header-anchor">#</a></h2><p>daScript умеет транспилироваться в C++ код, для сравнения с nim попробуем скомпилировать интерпретатор, без внесения каких-либо изменений в код.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">daScript.exe -aot brainfuck.das brainfuck.das.cpp</span><br></pre></td></tr></table></figure>
<p>Полученный C++-файл проще всего подсунуть в пример <a href="https://github.com/GaijinEntertainment/daScript/blob/master/examples/tutorial/tutorial02aot.cpp" target="_blank" rel="noopener">tutorial02aot</a>, который настроен на использование AoT варианта кода. Скомпилированный файл можно запустить:</p>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">e:\src\daScript\bin\Release&gt;tutorial02aot.exe</span><br><span class="line">[I] total <span class="number">34.27342399999999856</span> sec</span><br></pre></td></tr></table></figure>
<p>34 секунды — уже быстрее, чем nim, который сам по себе достаточно быстрый!</p>
<h2><span id="just-in-time">Just-in-Time</span><a href="#just-in-time" class="header-anchor">#</a></h2><p>Можно попробовать двигаться дальше, подключив экспериментальный модуль <a href="https://github.com/borisbat/dasLLVM" target="_blank" rel="noopener">dasLLVM</a>. Чтобы собрать его, необходимо:</p>
<ul>
<li>включить сборку модуля в cmake:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">option(DAS_LLVM_DISABLED &quot;Disable dasLLVM (llvm bindings)&quot; OFF)</span><br></pre></td></tr></table></figure>
<ul>
<li>собрать проект llvm, или скачать собранный (например, от <a href="https://download.qt.io/development_releases/prebuilt/libclang/" target="_blank" rel="noopener">qt</a>) и положить на уровень выше корневой директории проекта daScript, напрммер:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:&#x2F;dascript</span><br><span class="line">C:&#x2F;libclang</span><br></pre></td></tr></table></figure>
<ul>
<li>сгенерировать решение и пересобрать dascript:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">generate_msvc_2019.bat</span><br></pre></td></tr></table></figure>
<p>Теперь можно воспользоваться аннотацией <code>[jit]</code>, чтобы код функциии интерпретатора без AoT-компиляции перед первым выполнением компилировался с помощью <code>llvm-c</code>.</p>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">[jit,unsafe_deref]</span><br><span class="line">def run(code: uint8?; lengthOfCode:int; var tape: uint8?; var codePos, tapePos: int&amp;; skip: bool): bool</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">e:\src\daScript_my\bin\Release&gt;daScript.exe brainfuck_2_jit.das</span><br><span class="line">[I] total 22.66654300000000077 sec</span><br></pre></td></tr></table></figure>
<p>22.6 секунды, еще лучше! Генерация daScript-кода в llvm-ассемблер быстрее, чем в C++ — генератор передаёт больше полезной для оптимизации о кода, а также, возможно, задействуется сила оптимизаций LLVM.</p>
<h2><span id="metaprogrammirovanie">Метапрограммирование</span><a href="#metaprogrammirovanie" class="header-anchor">#</a></h2><p>Можно двигаться дальше. Вместо того, чтобы писать функцию, которая интерпретирует любой код на brainfuck, можно написать макрос, который сгенерирует код конкретной функции в compile-time, и измерить время выполнения этой функции.</p>
<p>Можно использовать <a href="https://dascript.org/doc/reference/language/macros.html#astreadermacro" target="_blank" rel="noopener">AstReaderMacro</a> — тип макроса, который обрабатывает отдельные символы. Синтаксис вызова такого макроса:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">% READER_MACRO_NAME ~ character_sequence %% &#x2F;&#x2F;character_sequence будет передана на вход макросу</span><br></pre></td></tr></table></figure>
<p>Шаблоны таких макросов можно посмотреть в модулях <code>json_boost</code> и <code>regex_boost</code></p>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> brainfuck_macro shared <span class="keyword">public</span></span><br><span class="line"></span><br><span class="line">def generateFunction(uniqueName, code)</span><br><span class="line">    <span class="keyword">let</span> seqStr = string(code)</span><br><span class="line"></span><br><span class="line">    var blkArr : array&lt;array&lt;ExpressionPtr&gt;&gt;; defer_delete(blkArr)</span><br><span class="line"></span><br><span class="line">    var blk : array&lt;ExpressionPtr&gt;; defer_delete(blk)</span><br><span class="line">    blkArr |&gt; emplace(blk)</span><br><span class="line"></span><br><span class="line">    blkArr[<span class="number">0</span>] |&gt; emplace_new &lt;| qmacro_expr( $&#123; var tape: array&lt;uint8&gt;; &#125;)</span><br><span class="line">    blkArr[<span class="number">0</span>] |&gt; emplace_new &lt;| qmacro_expr( $&#123; var tapePos : int; &#125;)</span><br><span class="line">    blkArr[<span class="number">0</span>] |&gt; emplace_new &lt;| qmacro_expr( $&#123; tape |&gt; resize(<span class="number">1000000</span>); &#125;)</span><br><span class="line">    blkArr[<span class="number">0</span>] |&gt; emplace_new &lt;| qmacro_expr( $&#123; var ptape = addr(tape[<span class="number">0</span>]); &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> sym <span class="keyword">in</span> seqStr</span><br><span class="line">        <span class="keyword">if</span> sym == '+'   &#123; back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( $&#123; ptape[tapePos] = uint8(int(ptape[tapePos]) + <span class="number">1</span>); &#125;); &#125;</span><br><span class="line">        <span class="keyword">elif</span> sym == '-' &#123; back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( $&#123; ptape[tapePos] = uint8(int(ptape[tapePos]) - <span class="number">1</span>); &#125;); &#125;</span><br><span class="line">        <span class="keyword">elif</span> sym == '&gt;' &#123; back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( $&#123; ++tapePos; &#125;); &#125; </span><br><span class="line">        <span class="keyword">elif</span> sym == '&lt;' &#123; back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( $&#123; --tapePos; &#125;); &#125;</span><br><span class="line">        <span class="keyword">elif</span> sym == '.' &#123; back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( $&#123; print(int(ptape[tapePos]) |&gt; to_char); &#125;); &#125;</span><br><span class="line">        <span class="keyword">elif</span> sym == ',' &#123; back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( $&#123; ptape[tapePos] = uint8(getchar()); &#125;); &#125;</span><br><span class="line">        <span class="keyword">elif</span> sym == '['</span><br><span class="line">            var blk1 : array&lt;ExpressionPtr&gt;; defer_delete(blk1)</span><br><span class="line">            blkArr |&gt; emplace(blk1)</span><br><span class="line">        <span class="keyword">elif</span> sym == ']'</span><br><span class="line">            var last &lt;- back(blkArr)</span><br><span class="line">            blkArr |&gt; pop()</span><br><span class="line">            var whileExpr &lt;- qmacro_expr &lt;|</span><br><span class="line">                <span class="keyword">while</span> ptape[tapePos] != uint8(<span class="number">0</span>)</span><br><span class="line">                    $b(last)</span><br><span class="line">            back(blkArr) |&gt; emplace_new &lt;| whileExpr</span><br><span class="line">        <span class="keyword">else</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    var fnArguments : array&lt;VariablePtr&gt;;</span><br><span class="line">    var fn &lt;- qmacro_function(uniqueName) &lt;| $ ($a(fnArguments))</span><br><span class="line">        unsafe</span><br><span class="line">            $b(blkArr[<span class="number">0</span>])</span><br><span class="line">    defer_delete(fn)</span><br><span class="line"></span><br><span class="line">    var args:array&lt; tuple&lt;argname:string;argvalue:RttiValue&gt; &gt;</span><br><span class="line">    fn |&gt; append_annotation(<span class="string">"$"</span>, <span class="string">"unsafe_deref"</span>, args)</span><br><span class="line">    <span class="comment">//print(describe(fn))</span></span><br><span class="line">    compiling_module() |&gt; add_function(fn)</span><br><span class="line"></span><br><span class="line">[reader_macro(name=<span class="string">"bf"</span>)]</span><br><span class="line"><span class="keyword">class</span> <span class="keyword">private</span> BrainfuckReader : AstReaderMacro</span><br><span class="line">    def <span class="keyword">override</span> accept( prog:ProgramPtr; mod:Module?; var expr:ExprReader?; ch:int; info:LineInfo) : bool</span><br><span class="line">        append(expr.sequence, ch)</span><br><span class="line">        <span class="keyword">if</span> ends_with(expr.sequence,<span class="string">"%%"</span>)</span><br><span class="line">            <span class="keyword">let</span> len = length(expr.sequence)</span><br><span class="line">            resize(expr.sequence,len<span class="number">-2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span></span><br><span class="line">    def <span class="keyword">override</span> visit( prog:ProgramPtr; mod:Module?; expr:smart_ptr&lt;ExprReader&gt;) : ExpressionPtr</span><br><span class="line">        <span class="keyword">let</span> str &lt;- make_unique_private_name(<span class="string">"bf`exec"</span>, expr.at)</span><br><span class="line">        generateFunction(str, expr.sequence)</span><br><span class="line"></span><br><span class="line">        var ftype &lt;- <span class="keyword">new</span> [[TypeDecl() at=expr.at, baseType=Type tFunction ]]</span><br><span class="line">        ftype.firstType &lt;- <span class="keyword">new</span> [[TypeDecl() at=expr.at, baseType=Type tVoid]]</span><br><span class="line">        var funcPtr &lt;- <span class="keyword">new</span> [[ExprAddr() at=expr.at, target:=str, funcType &lt;- ftype]]</span><br><span class="line">        <span class="keyword">return</span> funcPtr</span><br></pre></td></tr></table></figure>
<p>Тогда вызвать такой макрос можно так:</p>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">require brainfuck_macro</span><br><span class="line"><span class="comment">//генерируем функцию</span></span><br><span class="line"><span class="keyword">let</span> func = %bf~++++++++[&gt;++++[&gt;++&gt;+++&gt;+++&gt;+&lt;&lt;&lt;&lt;-]&gt;+&gt;+&gt;-&gt;&gt;+<span class="meta">[&lt;]&lt;-]&gt;&gt;.&gt;---.+++++++..+++.&gt;&gt;.&lt;-.&lt;.+++.------.--------.&gt;&gt;+.&gt;++.%%</span></span><br><span class="line"><span class="meta">//вызываем сгенерированную функцию</span></span><br><span class="line"><span class="meta">invoke(func)</span></span><br></pre></td></tr></table></figure>
<p>Если раскомментировать строчку <code>print(describe(fn))</code> можно посмотреть на сгенерированное тело функции.</p>
<p>Например:</p>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> func = %bf~[-&gt;+&lt;]%%</span><br><span class="line"><span class="comment">//сгенерированный код</span></span><br><span class="line"></span><br><span class="line">[unsafe_deref]</span><br><span class="line">def <span class="keyword">public</span> bf`exec_0xd_0xc</span><br><span class="line">    unsafe</span><br><span class="line">        var tape:array&lt;uint8&gt; -const                          <span class="comment">//declare variables</span></span><br><span class="line">        var tapePos:int -const</span><br><span class="line">        resize(tape,<span class="number">1000000</span>)</span><br><span class="line">        var ptape:auto -const = addr(tape[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ptape[tapePos] != uint8(<span class="number">0</span>)                      <span class="comment">//[</span></span><br><span class="line">            ptape[tapePos] = uint8(int(ptape[tapePos]) - <span class="number">1</span>)   <span class="comment">//-</span></span><br><span class="line">            ++tapePos                                         <span class="comment">//&gt;</span></span><br><span class="line">            ptape[tapePos] = uint8(int(ptape[tapePos]) + <span class="number">1</span>)   <span class="comment">//+</span></span><br><span class="line">            --tapePos                                         <span class="comment">//&lt;]</span></span><br><span class="line"><span class="keyword">let</span> func = @@bf`exec_0xd_0xc <span class="comment">//указатель на функцию</span></span><br></pre></td></tr></table></figure>
<p>Для каждой функции генерируется уникальное имя, чтобы можно было создать несколько отдельных интерпретатов, и своя “лента” памяти. В дальнейшем, каждый отдельный символ brainfuck компилируется в одну или несколько ast-нод daScript, который затем могут быть просимулированы.</p>
<p>(Раздел <code>daScript</code> про симуляцию и устройство виртуальной машины daScript)<br><a href="/blog/2115627465/" title="Устройство интерпретаторов lua-jit и daScript">Устройство интерпретаторов lua-jit и daScript</a> </p>
<p>(Генерация кода с помощью <a href="https://dascript.org/doc/reference/language/reification.html" target="_blank" rel="noopener">реификации выражений</a>)<br><a href="/blog/4046309382/" title="daScript macro - 2">daScript macro - 2</a></p>
<p>Если говорить о терминологии, то brainfuck можно рассматривать как <code>предметно-ориентированный язык (DSL)</code>. Переменные состояния tape и tapePos вместе составляют <code>семантическую модель</code> этого языка, которая настраивается с помощью DSL, а затем транслируется в синтаксическое дерево на <code>daScript</code> (в терминах Мартина Фаулера из книги “Предметно-ориентированные языки программирования”).</p>
<p>Время выполнения такой скомпилированной функции <strong>в режиме интерпретации</strong>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">e:\src\daScript_my\bin\Release&gt;daScript.exe brainfuck.das</span><br><span class="line">[I] total 29.28014399999999995 sec</span><br></pre></td></tr></table></figure>
<p>Это немного медленнее скомпилированной JiT-версии, но уже быстрее AoT версии интерпретатора.</p>
<h2><span id="macro-jit">Macro + JiT</span><a href="#macro-jit" class="header-anchor">#</a></h2><p>Дальше будет интереснее. Наша скомпилированная версия функции представляет собой по сути развёрнутую трассированную версию исполнения кода (и занимающую больше памяти). Попробуем применить к ней макрос [jit]:</p>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">fn |&gt; append_annotation(<span class="string">"$"</span>, <span class="string">"unsafe_deref"</span>, args)</span><br><span class="line">fn |&gt; append_annotation(<span class="string">"$"</span>, <span class="string">"jit"</span>, args)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">e:\src\daScript_my\bin\Release&gt;daScript.exe brainfuck.das</span><br><span class="line">[I] total 0.85775599999999996 sec</span><br></pre></td></tr></table></figure>
<p>0.85 секунды! (плюс около секунды на само время компиляции функции). llvm jit умеет сворачивать идущие подряд повторяющиеся операторы инкремента и декремента, за счёт чего получилось ускорение в 30 раз (и соотвествующее уменьшение размера функции).</p>
<p>Для сравнения — compile-time версия на nim работает ~3 секунды и тратит ~20 секунд на компиляцию (nim работает медленно в compile-time режиме).</p>
<h2><span id="optimizacii-brainfuck-gt-dascript-ast">Оптимизации Brainfuck -&gt; daScript AST</span><a href="#optimizacii-brainfuck-gt-dascript-ast" class="header-anchor">#</a></h2><p>Получается интересная цепочка преобразования кода:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bf --&gt; (bf macro) --&gt; dascript ast --&gt; (dascript simulate - unsafe deref macro + optimizations) --&gt; dascript ast optimized --&gt; (llvm macro) --&gt; llvm native optimized code --&gt; (execute)</span><br></pre></td></tr></table></figure>
<p>На каждом из шагов происходят серьёзные трансформации кода, которые могут включать оптимизации. Можно рассмотреть оптимизации в обратном порядке:</p>
<ul>
<li>llvm — бекэнд генерации кода оптимизирует байт-код, на этом этапе заметен эффект от сворачивания идущих подряд операций</li>
<li>dascript simulate — при симуляции ast-дерева выбираются оптимизированные частные версии нод, мелкие ноды могут “сплавляться” в более крупные, применяются кастомные макросы, трансформирующие дерево по различным правилам</li>
<li>bf macro — на данном уровне производится трансляция команд brainfuck в ноды dascript, пока без оптимизаций</li>
</ul>
<p>Оптимизации на стадиях трансформаций llvm были сделаны библиотекой из “комплекта” языка, на стадиях преобразования daScript — как встроенными в язык оптимизациями, так и добавленными для своего кода вручную. Можно теперь попробовать добавить пару оптимизаций на “стороне DSL”, т.е. в макрос трансформации <code>brainfuck-&gt;daScript</code>.</p>
<p>На данном этапе первую тупую и наивную реализацию уже получилось разогнать где-то в 20000 раз, и это отличный повод разогнать ещё немного :)</p>
<p>Можно выбрать несколько простых паттернов brainfuck кода и попробовать распознавать их и генерить более оптимальный код для этих частных случаев:</p>
<ul>
<li>цепочка повторяющихся операций. Например, “+++++” можно интерпретировать не как 5 отдельных инкрементов, а как одну операцию увеличения на 5. Эту свёртку делает llvm для версии <code>Macro+JiT</code>, но если сделать её в своём макросе, то она также ускорит и обычный режим интерпретации</li>
<li>паттерн [-] можно интерпретировать как очистку ячейки памяти одной операцией</li>
<li>[-&gt;+&lt;] - чуть более сложный паттерн, который часто встречается в примерах на brainfuck, “сложение двух ячеек с очисткой исходной”, может быть интерпретирован как 2 команды вместо цикла</li>
<li>можно продолжать обнаруживать и добавлять всё более сложные паттерны</li>
</ul>
<p>(Приём с отслеживанием паттернов подходит, естественно, не только для brainfuck-кода, но и для любых DSL)</p>
<p>“Продвинутая” версия макроса, отслеживающая перечисленные паттерны</p>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">def seachRepeats(symIt; var sym:int&amp;; symbolToCheck)</span><br><span class="line">    var count = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> next(symIt, sym)</span><br><span class="line">        <span class="keyword">if</span> sym == symbolToCheck</span><br><span class="line">            ++count</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> count</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line">def match_reset(data: array&lt;int&gt;)</span><br><span class="line">    <span class="keyword">return</span> length(data) == <span class="number">3</span> &amp;&amp; data[<span class="number">0</span>] == '[' &amp;&amp; data[<span class="number">1</span>] == '-' &amp;&amp; data[<span class="number">2</span>] == ']'</span><br><span class="line"></span><br><span class="line">def match_add_right_reset(data: array&lt;int&gt;)</span><br><span class="line">    <span class="keyword">return</span> length(data) == <span class="number">6</span> &amp;&amp; data[<span class="number">0</span>] == '[' &amp;&amp; data[<span class="number">1</span>] == '-' &amp;&amp; data[<span class="number">2</span>] == '&gt;' &amp;&amp; data[<span class="number">3</span>] == '+' &amp;&amp; data[<span class="number">4</span>] == '&lt;' &amp;&amp; data[<span class="number">5</span>] == ']'</span><br><span class="line"></span><br><span class="line">def generateFunction(uniqueName, code)</span><br><span class="line">    <span class="keyword">let</span> seqStr = string(code)</span><br><span class="line"></span><br><span class="line">    var blkArr : array&lt;array&lt;ExpressionPtr&gt;&gt;; defer_delete(blkArr)</span><br><span class="line"></span><br><span class="line">    var blk : array&lt;ExpressionPtr&gt;; defer_delete(blk)</span><br><span class="line">    blkArr |&gt; emplace(blk)</span><br><span class="line"></span><br><span class="line">    var cyclePatternChecker:array&lt;int&gt;</span><br><span class="line"></span><br><span class="line">    var initBlock &lt;- quote() &lt;|</span><br><span class="line">        var tape: array&lt;uint8&gt;</span><br><span class="line">        var tapePos : int</span><br><span class="line">        tape |&gt; resize(<span class="number">1000000</span>)</span><br><span class="line">        var ptape = addr(tape[<span class="number">0</span>])</span><br><span class="line">    <span class="comment">//blkArr[0] |&gt; emplace_new &lt;| initBlock</span></span><br><span class="line">    unsafe</span><br><span class="line">        var _block &lt;- reinterpret&lt;smart_ptr&lt;ExprBlock&gt;&gt;(reinterpret&lt;smart_ptr&lt;ExprMakeBlock&gt;&gt; initBlock)._block</span><br><span class="line">        <span class="keyword">for</span> blockItem <span class="keyword">in</span> _block.list</span><br><span class="line">            blkArr[<span class="number">0</span>] |&gt; emplace_new &lt;| blockItem</span><br><span class="line">    var symIt &lt;- unsafe(each(seqStr))</span><br><span class="line">    var sym : int</span><br><span class="line">    var repeat = <span class="keyword">false</span></span><br><span class="line">    var count : int = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> repeat || next(symIt, sym)</span><br><span class="line">        repeat = <span class="keyword">false</span></span><br><span class="line">        <span class="keyword">if</span> sym == '+'</span><br><span class="line">            cyclePatternChecker |&gt; push(sym)</span><br><span class="line">            repeat = <span class="keyword">true</span></span><br><span class="line">            count = seachRepeats(symIt, sym, '+')</span><br><span class="line">            back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( $&#123; ptape[tapePos] = uint8(int(ptape[tapePos]) + $v(count)); &#125;)</span><br><span class="line">        <span class="keyword">elif</span> sym == '-'</span><br><span class="line">            cyclePatternChecker |&gt; push(sym)</span><br><span class="line">            repeat = <span class="keyword">true</span></span><br><span class="line">            count = seachRepeats(symIt, sym, '-')</span><br><span class="line">            back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( $&#123; ptape[tapePos] = uint8(int(ptape[tapePos]) - $v(count)); &#125;)</span><br><span class="line">        <span class="keyword">elif</span> sym == '&gt;'</span><br><span class="line">            cyclePatternChecker |&gt; push(sym)</span><br><span class="line">            repeat = <span class="keyword">true</span></span><br><span class="line">            count = seachRepeats(symIt, sym, '&gt;')</span><br><span class="line">            back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( $&#123; tapePos +=  $v(count); &#125;)</span><br><span class="line">        <span class="keyword">elif</span> sym == '&lt;'</span><br><span class="line">            cyclePatternChecker |&gt; push(sym)</span><br><span class="line">            repeat = <span class="keyword">true</span></span><br><span class="line">            count = seachRepeats(symIt, sym, '&lt;')</span><br><span class="line">            back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( $&#123; tapePos -= $v(count); &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> sym == '.' &#123; back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( $&#123; print(int(ptape[tapePos]) |&gt; to_char); &#125;); &#125;</span><br><span class="line">        <span class="keyword">elif</span> sym == ',' &#123; back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( $&#123; ptape[tapePos] = uint8(getchar()); &#125;); &#125;</span><br><span class="line">        <span class="keyword">elif</span> sym == '['</span><br><span class="line">            cyclePatternChecker |&gt; clear</span><br><span class="line">            cyclePatternChecker |&gt; push(sym)</span><br><span class="line">            var blk1 : array&lt;ExpressionPtr&gt;; defer_delete(blk1)</span><br><span class="line">            blkArr |&gt; emplace(blk1)</span><br><span class="line">        <span class="keyword">elif</span> sym == ']'</span><br><span class="line">            cyclePatternChecker |&gt; push(sym)</span><br><span class="line">            <span class="keyword">if</span> match_reset(cyclePatternChecker)</span><br><span class="line">                <span class="comment">//match [-]</span></span><br><span class="line">                blkArr |&gt; pop()</span><br><span class="line">                back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( $&#123; ptape[tapePos] = uint8(<span class="number">0</span>); &#125;)</span><br><span class="line">            <span class="keyword">elif</span> match_add_right_reset(cyclePatternChecker)</span><br><span class="line">                <span class="comment">//match [-&gt;+&lt;]</span></span><br><span class="line">                blkArr |&gt; pop()</span><br><span class="line">                back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( $&#123; ptape[tapePos+$v(count)] = uint8(int(ptape[tapePos+$v(count)]) + int(ptape[tapePos])); &#125;)</span><br><span class="line">                back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( $&#123; ptape[tapePos] = uint8(<span class="number">0</span>); &#125;)</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">//usual cycle</span></span><br><span class="line">                var last &lt;- back(blkArr)</span><br><span class="line">                blkArr |&gt; pop()</span><br><span class="line">                var whileExpr &lt;- qmacro_expr &lt;|</span><br><span class="line">                    <span class="keyword">while</span> ptape[tapePos] != uint8(<span class="number">0</span>)</span><br><span class="line">                        $b(last)</span><br><span class="line">                back(blkArr) |&gt; emplace_new &lt;| whileExpr</span><br><span class="line"></span><br><span class="line">            cyclePatternChecker |&gt; clear</span><br><span class="line">        <span class="keyword">else</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    var fnArguments : array&lt;VariablePtr&gt;;</span><br><span class="line">    var fn &lt;- qmacro_function(uniqueName) &lt;| $ ($a(fnArguments))</span><br><span class="line">        unsafe</span><br><span class="line">            $b(blkArr[<span class="number">0</span>])</span><br><span class="line">    defer_delete(fn)</span><br><span class="line"></span><br><span class="line">    var args:array&lt; tuple&lt;argname:string;argvalue:RttiValue&gt; &gt;</span><br><span class="line">    fn |&gt; append_annotation(<span class="string">"$"</span>, <span class="string">"jit"</span>, args)</span><br><span class="line">    fn |&gt; append_annotation(<span class="string">"$"</span>, <span class="string">"unsafe_deref"</span>, args)</span><br><span class="line">    <span class="comment">//print(describe(fn))</span></span><br><span class="line">    compiling_module() |&gt; add_function(fn)</span><br></pre></td></tr></table></figure>
<p>Результат:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">e:\src\daScript_my\bin\Release&gt;daScript.exe brainfuck.das</span><br><span class="line">[I] total 0.70142899999999999 sec</span><br></pre></td></tr></table></figure>
<p>Еще на 17% быстрее<br><em>Из замеров явно стоило бы еще вынести print</em></p>
<h2><span id="nemnogo-vyvodov">Немного выводов</span><a href="#nemnogo-vyvodov" class="header-anchor">#</a></h2><ul>
<li>Основа оптимизации — написание грамотного кода на основном языке.</li>
<li>Техники JiT-компиляции (особенно в сочетании с кодогенерацией или замерами hot участков) могут давать крутые результаты, в том числе превосходящие статическую компиляцию</li>
<li>Организация цепочки преобразований кода в одной среде НАМНОГО удобнее, чем в разных (какой-нибудь вариант “кодоген на python” + макросы/шаблоны + код на C++” - мрак с отладкой). Особенно для более длинных цепочек.</li>
<li>Нормальные макросы = нормальная отладка и скорость компиляции DSL.</li>
</ul>
<p><a href="https://github.com/spiiin/dascript_brainfuck" target="_blank" rel="noopener">Код примеров</a></p>
<p><em>update от 14.01.2023</em><br><em><a href="https://tratt.net/laurie/blog/2023/compiled_and_interpreted_languages_two_ways_of_saying_tomato.html" target="_blank" rel="noopener">Compiled and Interpreted Languages: Two Ways of Saying Tomato</a> - похожие замеры на rust</em></p>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"Ov23liG1mZbiQOIdi91X","clientSecret":"e05812685eb741a752982b89dcf6f5b58dc10251","repo":"https://github.com/spiiin/spiiin.github.io","owner":"spiiin","admin":["spiiin"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script></div></article><div class="pagination"><a class="pagination__link pagination__prev" href="/blog/1976052536/">Позже</a><a class="pagination__link pagination__next" href="/blog/1601029690/">Раньше</a></div></main><footer class="footer metadata"><p class="footer__text">© 2024 spiiin</p><p class="footer__text">Powered by <a class="footer__text__link" href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a class="footer__text__link" href="https://pages.github.com/" target="_blank">Github Page</a></p></footer></div></body></html>