<!DOCTYPE html><html lang="ru"><head><meta charset="UTF-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Spiiin's blog | daScript. Brainfuck и оптимизации</title><meta name="description" content="&lt;p&gt;Попробовал портировать с &lt;code&gt;nim&lt;/code&gt; на &lt;code&gt;daScript&lt;/code&gt; &lt;a href=&quot;https://howistart.org/posts/nim/1/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;интерпретатор&lt;/a&gt; &lt;code&gt;brainfuck&lt;/code&gt; кода. Брейфак предельно простой язык, и базовая реализация интерпретатора занимает полчаса, но на нём можно потренироваться в ускорении кода и продемонстрировать возможности daScript в оптимизации.&lt;/p&gt;"><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=PT+Serif&amp;display=swap"><link rel="stylesheet" href="/css/highlights/darkula.css"><link rel="stylesheet" href="/css/main.css"><link rel="search" type="application/opensearchdescription+xml" href="http://spiiin.github.io/atom.xml" title="Spiiin's blog"><script>(function (i, s, o, g, r, a, m) {
  i['GoogleAnalyticsObject'] = r;
  i[r] = i[r] || function () {
    (i[r].q = i[r].q || []).push(arguments)
  }, i[r].l = 1 * new Date();
  a = s.createElement(o),
    m = s.getElementsByTagName(o)[0];
  a.async = 1;
  a.src = g;
  m.parentNode.insertBefore(a, m)
})(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');
ga('create', 'UA-00000000-0', 'auto');
ga('send', 'pageview');</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Spiiin's blog" type="application/atom+xml">
</head><body><div class="container"><header class="main-header"><h1 class="main-header__title uplize"><a class="main-header__title__link" href="/"><img class="header-image" src="/images/favicon.png" width="36" height="36">Spiiin's blog</a></h1><nav class="main-header__nav"><ul class="main-nav"><li class="main-nav__list"><a class="main-nav__list__link" href="/" target="_self">HOME</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/archives/" target="_self">ARCHIVE</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/tags/meta" target="_self">TAGS</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/blog/1" target="_self">ABOUT</a></li></ul></nav></header><main class="container__wrapper"><div class="pagination"><a class="pagination__link pagination__prev" href="/blog/1976052536/">Позже</a><a class="pagination__link pagination__next" href="/blog/1601029690/">Раньше</a></div><article class="article post"><h3 class="article__title">daScript. Brainfuck и оптимизации</h3><div class="article__date metadata"><div class="post-info">2022/11/11</div></div><div class="article__tags metadata">Tags:
<a class="article__tags__link metadata" href="/tags/dascript/">dascript</a><a class="article__tags__link metadata" href="/tags/llvm/">llvm</a></div><div class="article__body"><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Попробовал портировать с <code>nim</code> на <code>daScript</code> <a href="https://howistart.org/posts/nim/1/" target="_blank" rel="noopener">интерпретатор</a> <code>brainfuck</code> кода. Брейфак предельно простой язык, и базовая реализация интерпретатора занимает полчаса, но на нём можно потренироваться в ускорении кода и продемонстрировать возможности daScript в оптимизации.</p>
<a id="more"></a>
<p>Самая первая, максимально наивная, построчно скопированная реализация:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">require strings</span><br><span class="line">require fio</span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">run</span><span class="params">(code: <span class="built_in">string</span>; var tape: <span class="built_in">array</span>&lt;uint8&gt;; var codePos, tapePos: <span class="keyword">int</span>&amp;; skip: <span class="keyword">bool</span>)</span>: <span class="keyword">bool</span></span></span><br><span class="line"><span class="function">	<span class="keyword">while</span> tapePos &gt;</span>= <span class="number">0</span> &amp;&amp; codePos &lt; length(code)</span><br><span class="line">		<span class="keyword">if</span> tapePos &gt;= length(tape) &#123; tape |&gt; push(uint8(<span class="number">0</span>)); &#125;</span><br><span class="line"></span><br><span class="line">		let sym1  = code |&gt; character_at(codePos)</span><br><span class="line">		<span class="keyword">if</span> sym1 == <span class="string">'['</span></span><br><span class="line">			++codePos</span><br><span class="line">			let oldPos = codePos</span><br><span class="line">			<span class="keyword">while</span> run(code, tape, codePos, tapePos, tape[tapePos] == uint8(<span class="number">0</span>))</span><br><span class="line">				codePos = oldPos</span><br><span class="line">		elif sym1 == <span class="string">']'</span></span><br><span class="line">			<span class="keyword">return</span> tape[tapePos] != uint8(<span class="number">0</span>)</span><br><span class="line">		elif !skip</span><br><span class="line">			let sym  = code |&gt; character_at(codePos)</span><br><span class="line">			<span class="keyword">if</span> sym == <span class="string">'+'</span> &#123; tape[tapePos] = uint8(<span class="keyword">int</span>(tape[tapePos]) + <span class="number">1</span>); &#125;</span><br><span class="line">			elif sym == <span class="string">'-'</span> &#123; tape[tapePos] = uint8(<span class="keyword">int</span>(tape[tapePos]) - <span class="number">1</span>); &#125;</span><br><span class="line">			elif sym == <span class="string">'&gt;'</span> &#123; ++tapePos; &#125;</span><br><span class="line">			elif sym == <span class="string">'&lt;'</span> &#123; --tapePos; &#125;</span><br><span class="line">			elif sym == <span class="string">'.'</span> &#123; print(<span class="string">"&#123;int(tape[tapePos]) |&gt; to_char&#125;"</span>); &#125;</span><br><span class="line">			elif sym == <span class="string">','</span> &#123; tape[tapePos] = uint8(getchar()); &#125;</span><br><span class="line">			<span class="keyword">else</span> &#123; &#125;</span><br><span class="line">		++codePos</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">def interpret(code: <span class="built_in">string</span>)</span><br><span class="line">	let totalTime = ref_time_ticks()</span><br><span class="line">	var tape: <span class="built_in">array</span>&lt;uint8&gt;</span><br><span class="line">	var codePos, tapePos : <span class="keyword">int</span></span><br><span class="line">	run(code, tape, codePos, tapePos, <span class="literal">false</span>)</span><br><span class="line">	let totalDt = <span class="keyword">double</span>(get_time_usec(totalTime)) /<span class="number">1000000.0l</span>f</span><br><span class="line">	to_log(LOG_INFO, <span class="string">"total &#123;totalDt&#125; sec\n"</span>)</span><br></pre></td></tr></table></figure>
<p>Если попытаться протестировать его на генераторе <a href="https://github.com/def-/nim-brainfuck/blob/master/examples/mandelbrot.b" target="_blank" rel="noopener">множества Мандельброта</a>, можно заметить серьёзные проблемы со скоростью, вычисления занимают около 5 часов. Стоит попробовать его разогнать!</p>
<h2 id="Отключение-проверок-границ-и-указателей"><a href="#Отключение-проверок-границ-и-указателей" class="headerlink" title="Отключение проверок границ и указателей"></a>Отключение проверок границ и указателей</h2><p>Код на brainfuck - это простая числодробилка, ускорить которую можно, отключив все дополнительные проверки обращений к памяти.</p>
<p><em>Как отключать проверки, мне рассказал <a href="https://github.com/borisbat" target="_blank" rel="noopener">Борис Баткин</a> (так как интерпретатор nim делал один основных контрибьютеров языка, то его подсказки не отменяют честности сравнения — авторы находятся в одной “весовой категории” знания своего языка).</em></p>
<p>В первую очередь, можно заменить функцию <code>charcter_at</code>, которая <a href="https://github.com/GaijinEntertainment/daScript/blob/e9f4c486848a8985e4126e0fc2d04afbc6abd883/src/builtin/module_builtin_string.cpp#L26" target="_blank" rel="noopener">проверяет</a>,что индекс меньше длины строки, на <code>character_uat</code>, которая не делает этой проверки.</p>
<p>Также отключается проверка ссылок на null макросом <code>[unsafe_deref]</code>.</p>
<p>Наконец, обращение к массиву можно выполнять не через разыменование ссылки, а через обращение по указателю:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">tape: <span class="built_in">array</span>&lt;uint8&gt;</span><br><span class="line">tape[index] <span class="comment">// tape[check_range(index)] //медленно</span></span><br><span class="line"></span><br><span class="line">var ptape: uint8? = addr(tape[<span class="number">0</span>])</span><br><span class="line">ptape[index] <span class="comment">//check_not_null(ptape)[index] //быстрее, обращение без проверок</span></span><br><span class="line"></span><br><span class="line">[unsafe_deref]</span><br><span class="line">ptape[index] <span class="comment">//ptape[index] //еще быстрее, обращение без перепроверок указателя на nullptr</span></span><br></pre></td></tr></table></figure>
<p>Переписанная версия кода:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[unsafe_deref]</span><br><span class="line"><span class="function">def <span class="title">run</span><span class="params">(code: uint8?; lengthOfCode:<span class="keyword">int</span>; var tape: uint8?; var codePos, tapePos: <span class="keyword">int</span>&amp;; skip: <span class="keyword">bool</span>)</span>: <span class="keyword">bool</span></span></span><br><span class="line"><span class="function">	unsafe</span></span><br><span class="line"><span class="function">		<span class="keyword">while</span> tapePos &gt;</span>= <span class="number">0</span> &amp;&amp; codePos &lt; lengthOfCode</span><br><span class="line">			let sym1  = <span class="keyword">int</span>(code[codePos])</span><br><span class="line">			<span class="keyword">if</span> sym1 == <span class="string">'['</span></span><br><span class="line">				++codePos</span><br><span class="line">				let oldPos = codePos</span><br><span class="line">				<span class="keyword">while</span> run(code, lengthOfCode, tape, codePos, tapePos, tape[tapePos] == uint8(<span class="number">0</span>))</span><br><span class="line">					codePos = oldPos</span><br><span class="line">			elif sym1 == <span class="string">']'</span></span><br><span class="line">				<span class="keyword">return</span> tape[tapePos] != uint8(<span class="number">0</span>)</span><br><span class="line">			elif !skip</span><br><span class="line">				let sym  = <span class="keyword">int</span>(code[codePos])</span><br><span class="line">				<span class="keyword">if</span> sym == <span class="string">'+'</span> &#123; tape[tapePos] = uint8(<span class="keyword">int</span>(tape[tapePos]) + <span class="number">1</span>); &#125;</span><br><span class="line">				elif sym == <span class="string">'-'</span> &#123; tape[tapePos] = uint8(<span class="keyword">int</span>(tape[tapePos]) - <span class="number">1</span>); &#125;</span><br><span class="line">				elif sym == <span class="string">'&gt;'</span> &#123; ++tapePos; &#125;</span><br><span class="line">				elif sym == <span class="string">'&lt;'</span> &#123; --tapePos; &#125;</span><br><span class="line">				elif sym == <span class="string">'.'</span> &#123; print(<span class="keyword">int</span>(tape[tapePos]) |&gt; to_char); &#125;</span><br><span class="line">				elif sym == <span class="string">','</span> &#123; tape[tapePos] = uint8(getchar()); &#125;</span><br><span class="line">				<span class="keyword">else</span> &#123; &#125;</span><br><span class="line">			++codePos</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">def interpret(code: <span class="built_in">string</span>)</span><br><span class="line">	let totalTime = ref_time_ticks()</span><br><span class="line">	var tape: <span class="built_in">array</span>&lt;uint8&gt;</span><br><span class="line">	var codePos, tapePos : <span class="keyword">int</span></span><br><span class="line">	tape |&gt; resize(<span class="number">1000000</span>)</span><br><span class="line">	unsafe</span><br><span class="line">		run(reinterpret&lt;uint8?&gt; code, length(code), addr(tape[<span class="number">0</span>]), codePos, tapePos, <span class="literal">false</span>)</span><br><span class="line">	let totalDt = <span class="keyword">double</span>(get_time_usec(totalTime)) /<span class="number">1000000.0l</span>f</span><br><span class="line">	to_log(LOG_INFO, <span class="string">"total &#123;totalDt&#125; sec\n"</span>)</span><br></pre></td></tr></table></figure>
<p>Такая версия интерпретатора всё ещё тормозная, но уже позволяет дождаться завершения выполнения кода:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">e:\src\daScript\bin\Release&gt;daScript.exe brainfuck_00.das</span><br><span class="line">AAAAAAAAAAAAAAAABBBBBBBBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDEGFFEEEEDDDDDDCCCCCCCCCBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB</span><br><span class="line">AAAAAAAAAAAAAAABBBBBBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDEEEFGIIGFFEEEDDDDDDDDCCCCCCCCCBBBBBBBBBBBBBBBBBBBBBBBBBB</span><br><span class="line">AAAAAAAAAAAAABBBBBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDEEEEFFFI KHGGGHGEDDDDDDDDDCCCCCCCCCBBBBBBBBBBBBBBBBBBBBBBB</span><br><span class="line">AAAAAAAAAAAABBBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDEEEEEFFGHIMTKLZOGFEEDDDDDDDDDCCCCCCCCCBBBBBBBBBBBBBBBBBBBBB</span><br><span class="line">AAAAAAAAAAABBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDEEEEEEFGGHHIKPPKIHGFFEEEDDDDDDDDDCCCCCCCCCCBBBBBBBBBBBBBBBBBB</span><br><span class="line">AAAAAAAAAABBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDEEEEEEFFGHIJKS  X KHHGFEEEEEDDDDDDDDDCCCCCCCCCCBBBBBBBBBBBBBBBB</span><br><span class="line">AAAAAAAAABBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDEEEEEEFFGQPUVOTY   ZQL[MHFEEEEEEEDDDDDDDCCCCCCCCCCCBBBBBBBBBBBBBB</span><br><span class="line">AAAAAAAABBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDEEEEEFFFFFGGHJLZ         UKHGFFEEEEEEEEDDDDDCCCCCCCCCCCCBBBBBBBBBBBB</span><br><span class="line">AAAAAAABBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDEEEEFFFFFFGGGGHIKP           KHHGGFFFFEEEEEEDDDDDCCCCCCCCCCCBBBBBBBBBBB</span><br><span class="line">AAAAAAABBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDEEEEEFGGHIIHHHHHIIIJKMR        VMKJIHHHGFFFFFFGSGEDDDDCCCCCCCCCCCCBBBBBBBBB</span><br><span class="line">AAAAAABBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDEEEEEEFFGHK   MKJIJO  N R  X      YUSR PLV LHHHGGHIOJGFEDDDCCCCCCCCCCCCBBBBBBBB</span><br><span class="line">AAAAABBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDEEEEEEEEEFFFFGH O    TN S                       NKJKR LLQMNHEEDDDCCCCCCCCCCCCBBBBBBB</span><br><span class="line">AAAAABBCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDEEEEEEEEEEEEFFFFFGHHIN                                 Q     UMWGEEEDDDCCCCCCCCCCCCBBBBBB</span><br><span class="line">AAAABBCCCCCCCCCCCCCCCCCCCCCCCCCDDDDEEEEEEEEEEEEEEEFFFFFFGHIJKLOT                                     [JGFFEEEDDCCCCCCCCCCCCCBBBBB</span><br><span class="line">AAAABCCCCCCCCCCCCCCCCCCCCCCDDDDEEEEEEEEEEEEEEEEFFFFFFGGHYV RQU                                     QMJHGGFEEEDDDCCCCCCCCCCCCCBBBB</span><br><span class="line">AAABCCCCCCCCCCCCCCCCCDDDDDDDEEFJIHFFFFFFFFFFFFFFGGGGGGHIJN                                            JHHGFEEDDDDCCCCCCCCCCCCCBBB</span><br><span class="line">AAABCCCCCCCCCCCDDDDDDDDDDEEEEFFHLKHHGGGGHHMJHGGGGGGHHHIKRR                                           UQ L HFEDDDDCCCCCCCCCCCCCCBB</span><br><span class="line">AABCCCCCCCCDDDDDDDDDDDEEEEEEFFFHKQMRKNJIJLVS JJKIIIIIIJLR                                               YNHFEDDDDDCCCCCCCCCCCCCBB</span><br><span class="line">AABCCCCCDDDDDDDDDDDDEEEEEEEFFGGHIJKOU  O O   PR LLJJJKL                                                OIHFFEDDDDDCCCCCCCCCCCCCCB</span><br><span class="line">AACCCDDDDDDDDDDDDDEEEEEEEEEFGGGHIJMR              RMLMN                                                 NTFEEDDDDDDCCCCCCCCCCCCCB</span><br><span class="line">AACCDDDDDDDDDDDDEEEEEEEEEFGGGHHKONSZ                QPR                                                NJGFEEDDDDDDCCCCCCCCCCCCCC</span><br><span class="line">ABCDDDDDDDDDDDEEEEEFFFFFGIPJIIJKMQ                   VX                                                 HFFEEDDDDDDCCCCCCCCCCCCCC</span><br><span class="line">ACDDDDDDDDDDEFFFFFFFGGGGHIKZOOPPS                                                                      HGFEEEDDDDDDCCCCCCCCCCCCCC</span><br><span class="line">ADEEEEFFFGHIGGGGGGHHHHIJJLNY                                                                        TJHGFFEEEDDDDDDDCCCCCCCCCCCCC</span><br><span class="line">A                                                                                                 PLJHGGFFEEEDDDDDDDCCCCCCCCCCCCC</span><br><span class="line">ADEEEEFFFGHIGGGGGGHHHHIJJLNY                                                                        TJHGFFEEEDDDDDDDCCCCCCCCCCCCC</span><br><span class="line">ACDDDDDDDDDDEFFFFFFFGGGGHIKZOOPPS                                                                      HGFEEEDDDDDDCCCCCCCCCCCCCC</span><br><span class="line">ABCDDDDDDDDDDDEEEEEFFFFFGIPJIIJKMQ                   VX                                                 HFFEEDDDDDDCCCCCCCCCCCCCC</span><br><span class="line">AACCDDDDDDDDDDDDEEEEEEEEEFGGGHHKONSZ                QPR                                                NJGFEEDDDDDDCCCCCCCCCCCCCC</span><br><span class="line">AACCCDDDDDDDDDDDDDEEEEEEEEEFGGGHIJMR              RMLMN                                                 NTFEEDDDDDDCCCCCCCCCCCCCB</span><br><span class="line">AABCCCCCDDDDDDDDDDDDEEEEEEEFFGGHIJKOU  O O   PR LLJJJKL                                                OIHFFEDDDDDCCCCCCCCCCCCCCB</span><br><span class="line">AABCCCCCCCCDDDDDDDDDDDEEEEEEFFFHKQMRKNJIJLVS JJKIIIIIIJLR                                               YNHFEDDDDDCCCCCCCCCCCCCBB</span><br><span class="line">AAABCCCCCCCCCCCDDDDDDDDDDEEEEFFHLKHHGGGGHHMJHGGGGGGHHHIKRR                                           UQ L HFEDDDDCCCCCCCCCCCCCCBB</span><br><span class="line">AAABCCCCCCCCCCCCCCCCCDDDDDDDEEFJIHFFFFFFFFFFFFFFGGGGGGHIJN                                            JHHGFEEDDDDCCCCCCCCCCCCCBBB</span><br><span class="line">AAAABCCCCCCCCCCCCCCCCCCCCCCDDDDEEEEEEEEEEEEEEEEFFFFFFGGHYV RQU                                     QMJHGGFEEEDDDCCCCCCCCCCCCCBBBB</span><br><span class="line">AAAABBCCCCCCCCCCCCCCCCCCCCCCCCCDDDDEEEEEEEEEEEEEEEFFFFFFGHIJKLOT                                     [JGFFEEEDDCCCCCCCCCCCCCBBBBB</span><br><span class="line">AAAAABBCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDEEEEEEEEEEEEFFFFFGHHIN                                 Q     UMWGEEEDDDCCCCCCCCCCCCBBBBBB</span><br><span class="line">AAAAABBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDEEEEEEEEEFFFFGH O    TN S                       NKJKR LLQMNHEEDDDCCCCCCCCCCCCBBBBBBB</span><br><span class="line">AAAAAABBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDEEEEEEFFGHK   MKJIJO  N R  X      YUSR PLV LHHHGGHIOJGFEDDDCCCCCCCCCCCCBBBBBBBB</span><br><span class="line">AAAAAAABBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDEEEEEFGGHIIHHHHHIIIJKMR        VMKJIHHHGFFFFFFGSGEDDDDCCCCCCCCCCCCBBBBBBBBB</span><br><span class="line">AAAAAAABBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDEEEEFFFFFFGGGGHIKP           KHHGGFFFFEEEEEEDDDDDCCCCCCCCCCCBBBBBBBBBBB</span><br><span class="line">AAAAAAAABBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDEEEEEFFFFFGGHJLZ         UKHGFFEEEEEEEEDDDDDCCCCCCCCCCCCBBBBBBBBBBBB</span><br><span class="line">AAAAAAAAABBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDEEEEEEFFGQPUVOTY   ZQL[MHFEEEEEEEDDDDDDDCCCCCCCCCCCBBBBBBBBBBBBBB</span><br><span class="line">AAAAAAAAAABBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDEEEEEEFFGHIJKS  X KHHGFEEEEEDDDDDDDDDCCCCCCCCCCBBBBBBBBBBBBBBBB</span><br><span class="line">AAAAAAAAAAABBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDEEEEEEFGGHHIKPPKIHGFFEEEDDDDDDDDDCCCCCCCCCCBBBBBBBBBBBBBBBBBB</span><br><span class="line">AAAAAAAAAAAABBBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDEEEEEFFGHIMTKLZOGFEEDDDDDDDDDCCCCCCCCCBBBBBBBBBBBBBBBBBBBBB</span><br><span class="line">AAAAAAAAAAAAABBBBBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDEEEEFFFI KHGGGHGEDDDDDDDDDCCCCCCCCCBBBBBBBBBBBBBBBBBBBBBBB</span><br><span class="line">AAAAAAAAAAAAAAABBBBBBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDEEEFGIIGFFEEEDDDDDDDDCCCCCCCCCBBBBBBBBBBBBBBBBBBBBBBBBBB</span><br><span class="line">[I] total 564.99929999999994834 sec</span><br></pre></td></tr></table></figure>
<p>564 секунды — в 30 раз быстрее первой версии, но всё ещё сильно медленнее интерпретатора на <code>nim</code>, который в релизной версии выполняется за 40 секунд.</p>
<h2 id="Ahead-of-Time"><a href="#Ahead-of-Time" class="headerlink" title="Ahead-of-Time"></a>Ahead-of-Time</h2><p>daScript умеет транспилироваться в C++ код, для сравнения с nim попробуем скомпилировать интерпретатор, без внесения каких-либо изменений в код.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">daScript.exe -aot brainfuck.das brainfuck.das.cpp</span><br></pre></td></tr></table></figure>
<p>Полученный C++-файл проще всего подсунуть в пример <a href="https://github.com/GaijinEntertainment/daScript/blob/master/examples/tutorial/tutorial02aot.cpp" target="_blank" rel="noopener">tutorial02aot</a>, который настроен на использование AoT варианта кода. Скомпилированный файл можно запустить:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">e:\src\daScript\bin\Release&gt;tutorial02aot.exe</span><br><span class="line">[I] total <span class="number">34.27342399999999856</span> sec</span><br></pre></td></tr></table></figure>
<p>34 секунды — уже быстрее, чем nim, который сам по себе достаточно быстрый!</p>
<h2 id="Just-in-Time"><a href="#Just-in-Time" class="headerlink" title="Just-in-Time"></a>Just-in-Time</h2><p>Можно попробовать двигаться дальше, подключив экспериментальный модуль <a href="https://github.com/borisbat/dasLLVM" target="_blank" rel="noopener">dasLLVM</a>. Чтобы собрать его, необходимо:</p>
<ul>
<li>включить сборку модуля в cmake:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">option(DAS_LLVM_DISABLED &quot;Disable dasLLVM (llvm bindings)&quot; OFF)</span><br></pre></td></tr></table></figure>
<ul>
<li>собрать проект llvm, или скачать собранный (например, от <a href="https://download.qt.io/development_releases/prebuilt/libclang/" target="_blank" rel="noopener">qt</a>) и положить на уровень выше корневой директории проекта daScript, напрммер:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:&#x2F;dascript</span><br><span class="line">C:&#x2F;libclang</span><br></pre></td></tr></table></figure>
<ul>
<li>сгенерировать решение и пересобрать dascript:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">generate_msvc_2019.bat</span><br></pre></td></tr></table></figure>
<p>Теперь можно воспользоваться аннотацией <code>[jit]</code>, чтобы код функциии интерпретатора без AoT-компиляции перед первым выполнением компилировался с помощью <code>llvm-c</code>.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[jit,unsafe_deref]</span><br><span class="line"><span class="function">def <span class="title">run</span><span class="params">(code: uint8?; lengthOfCode:<span class="keyword">int</span>; var tape: uint8?; var codePos, tapePos: <span class="keyword">int</span>&amp;; skip: <span class="keyword">bool</span>)</span>: <span class="keyword">bool</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">e:\src\daScript_my\bin\Release&gt;daScript.exe brainfuck_2_jit.das</span><br><span class="line">[I] total 22.66654300000000077 sec</span><br></pre></td></tr></table></figure>
<p>22.6 секунды, еще лучше! Генерация daScript-кода в llvm-ассемблер быстрее, чем в C++ — генератор передаёт больше полезной для оптимизации о кода, а также, возможно, задействуется сила оптимизаций LLVM.</p>
<h2 id="Метапрограммирование"><a href="#Метапрограммирование" class="headerlink" title="Метапрограммирование"></a>Метапрограммирование</h2><p>Можно двигаться дальше. Вместо того, чтобы писать функцию, которая интерпретирует любой код на brainfuck, можно написать макрос, который сгенерирует код конкретной функции в compile-time, и измерить время выполнения этой функции.</p>
<p>Можно использовать <a href="https://dascript.org/doc/reference/language/macros.html#astreadermacro" target="_blank" rel="noopener">AstReaderMacro</a> — тип макроса, который обрабатывает отдельные символы. Синтаксис вызова такого макроса:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">% READER_MACRO_NAME ~ character_sequence %% &#x2F;&#x2F;character_sequence будет передана на вход макросу</span><br></pre></td></tr></table></figure>
<p>Шаблоны таких макросов можно посмотреть в модулях <code>json_boost</code> и <code>regex_boost</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> brainfuck_macro shared <span class="keyword">public</span></span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">generateFunction</span><span class="params">(uniqueName, code)</span></span></span><br><span class="line"><span class="function">    let seqStr </span>= <span class="built_in">string</span>(code)</span><br><span class="line"></span><br><span class="line">    var blkArr : <span class="built_in">array</span>&lt;<span class="built_in">array</span>&lt;ExpressionPtr&gt;&gt;; defer_delete(blkArr)</span><br><span class="line"></span><br><span class="line">    var blk : <span class="built_in">array</span>&lt;ExpressionPtr&gt;; defer_delete(blk)</span><br><span class="line">    blkArr |&gt; emplace(blk)</span><br><span class="line"></span><br><span class="line">    blkArr[<span class="number">0</span>] |&gt; emplace_new &lt;| qmacro_expr( $&#123; var tape: <span class="built_in">array</span>&lt;uint8&gt;; &#125;)</span><br><span class="line">    blkArr[<span class="number">0</span>] |&gt; emplace_new &lt;| qmacro_expr( $&#123; var tapePos : <span class="keyword">int</span>; &#125;)</span><br><span class="line">    blkArr[<span class="number">0</span>] |&gt; emplace_new &lt;| qmacro_expr( $&#123; tape |&gt; resize(<span class="number">1000000</span>); &#125;)</span><br><span class="line">    blkArr[<span class="number">0</span>] |&gt; emplace_new &lt;| qmacro_expr( $&#123; var ptape = addr(tape[<span class="number">0</span>]); &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> sym in seqStr</span><br><span class="line">        <span class="keyword">if</span> sym == <span class="string">'+'</span>   &#123; back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( $&#123; ptape[tapePos] = uint8(<span class="keyword">int</span>(ptape[tapePos]) + <span class="number">1</span>); &#125;); &#125;</span><br><span class="line">        elif sym == <span class="string">'-'</span> &#123; back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( $&#123; ptape[tapePos] = uint8(<span class="keyword">int</span>(ptape[tapePos]) - <span class="number">1</span>); &#125;); &#125;</span><br><span class="line">        elif sym == <span class="string">'&gt;'</span> &#123; back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( $&#123; ++tapePos; &#125;); &#125; </span><br><span class="line">        elif sym == <span class="string">'&lt;'</span> &#123; back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( $&#123; --tapePos; &#125;); &#125;</span><br><span class="line">        elif sym == <span class="string">'.'</span> &#123; back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( $&#123; print(<span class="keyword">int</span>(ptape[tapePos]) |&gt; to_char); &#125;); &#125;</span><br><span class="line">        elif sym == <span class="string">','</span> &#123; back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( $&#123; ptape[tapePos] = uint8(getchar()); &#125;); &#125;</span><br><span class="line">        elif sym == <span class="string">'['</span></span><br><span class="line">            var blk1 : <span class="built_in">array</span>&lt;ExpressionPtr&gt;; defer_delete(blk1)</span><br><span class="line">            blkArr |&gt; emplace(blk1)</span><br><span class="line">        elif sym == <span class="string">']'</span></span><br><span class="line">            var last &lt;- back(blkArr)</span><br><span class="line">            blkArr |&gt; pop()</span><br><span class="line">            var whileExpr &lt;- qmacro_expr &lt;|</span><br><span class="line">                <span class="keyword">while</span> ptape[tapePos] != uint8(<span class="number">0</span>)</span><br><span class="line">                    $b(last)</span><br><span class="line">            back(blkArr) |&gt; emplace_new &lt;| whileExpr</span><br><span class="line">        <span class="keyword">else</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    var fnArguments : <span class="built_in">array</span>&lt;VariablePtr&gt;;</span><br><span class="line">    var fn &lt;- qmacro_function(uniqueName) &lt;| $ ($a(fnArguments))</span><br><span class="line">        unsafe</span><br><span class="line">            $b(blkArr[<span class="number">0</span>])</span><br><span class="line">    defer_delete(fn)</span><br><span class="line"></span><br><span class="line">    var args:<span class="built_in">array</span>&lt; tuple&lt;argname:<span class="built_in">string</span>;argvalue:RttiValue&gt; &gt;</span><br><span class="line">    fn |&gt; append_annotation(<span class="string">"$"</span>, <span class="string">"unsafe_deref"</span>, args)</span><br><span class="line">    <span class="comment">//print(describe(fn))</span></span><br><span class="line">    compiling_module() |&gt; add_function(fn)</span><br><span class="line"></span><br><span class="line">[reader_macro(name=<span class="string">"bf"</span>)]</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">private</span> <span class="title">BrainfuckReader</span> :</span> AstReaderMacro</span><br><span class="line">    <span class="function">def <span class="keyword">override</span> <span class="title">accept</span><span class="params">( prog:ProgramPtr; mod:Module?; var expr:ExprReader?; ch:<span class="keyword">int</span>; info:LineInfo)</span> : <span class="keyword">bool</span></span></span><br><span class="line"><span class="function">        <span class="title">append</span><span class="params">(expr.sequence, ch)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">if</span> <span class="title">ends_with</span><span class="params">(expr.sequence,<span class="string">"%%"</span>)</span></span></span><br><span class="line"><span class="function">            let len </span>= length(expr.sequence)</span><br><span class="line">            resize(expr.sequence,len<span class="number">-2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    def <span class="keyword">override</span> visit( prog:ProgramPtr; mod:Module?; expr:smart_ptr&lt;ExprReader&gt;) : ExpressionPtr</span><br><span class="line">        let str &lt;- make_unique_private_name(<span class="string">"bf`exec"</span>, expr.at)</span><br><span class="line">        generateFunction(str, expr.sequence)</span><br><span class="line"></span><br><span class="line">        var ftype &lt;- <span class="keyword">new</span> [[TypeDecl() at=expr.at, baseType=Type tFunction ]]</span><br><span class="line">        ftype.firstType &lt;- <span class="keyword">new</span> [[TypeDecl() at=expr.at, baseType=Type tVoid]]</span><br><span class="line">        var funcPtr &lt;- <span class="keyword">new</span> [[ExprAddr() at=expr.at, target:=str, funcType &lt;- ftype]]</span><br><span class="line">        <span class="keyword">return</span> funcPtr</span><br></pre></td></tr></table></figure>
<p>Тогда вызвать такой макрос можно так:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">require brainfuck_macro</span><br><span class="line"><span class="comment">//генерируем функцию</span></span><br><span class="line">let func = %bf~++++++++[&gt;++++[&gt;++&gt;+++&gt;+++&gt;+&lt;&lt;&lt;&lt;-]&gt;+&gt;+&gt;-&gt;&gt;+[&lt;]&lt;-]&gt;&gt;.&gt;---.+++++++..+++.&gt;&gt;.&lt;-.&lt;.+++.------.--------.&gt;&gt;+.&gt;++.%%</span><br><span class="line"><span class="comment">//вызываем сгенерированную функцию</span></span><br><span class="line">invoke(func)</span><br></pre></td></tr></table></figure>
<p>Если раскомментировать строчку <code>print(describe(fn))</code> можно посмотреть на сгенерированное тело функции.</p>
<p>Например:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">let func = %bf~[-&gt;+&lt;]%%</span><br><span class="line"><span class="comment">//сгенерированный код</span></span><br><span class="line"></span><br><span class="line">[unsafe_deref]</span><br><span class="line">def <span class="keyword">public</span> bf`exec_0xd_0xc</span><br><span class="line">    unsafe</span><br><span class="line">        var tape:<span class="built_in">array</span>&lt;uint8&gt; -<span class="keyword">const</span>                          <span class="comment">//declare variables</span></span><br><span class="line">        var tapePos:<span class="keyword">int</span> -<span class="keyword">const</span></span><br><span class="line">        resize(tape,<span class="number">1000000</span>)</span><br><span class="line">        var ptape:<span class="keyword">auto</span> -<span class="keyword">const</span> = addr(tape[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ptape[tapePos] != uint8(<span class="number">0</span>)                      <span class="comment">//[</span></span><br><span class="line">            ptape[tapePos] = uint8(<span class="keyword">int</span>(ptape[tapePos]) - <span class="number">1</span>)   <span class="comment">//-</span></span><br><span class="line">            ++tapePos                                         <span class="comment">//&gt;</span></span><br><span class="line">            ptape[tapePos] = uint8(<span class="keyword">int</span>(ptape[tapePos]) + <span class="number">1</span>)   <span class="comment">//+</span></span><br><span class="line">            --tapePos                                         <span class="comment">//&lt;]</span></span><br><span class="line">let func = @@bf`exec_0xd_0xc <span class="comment">//указатель на функцию</span></span><br></pre></td></tr></table></figure>
<p>Для каждой функции генерируется уникальное имя, чтобы можно было создать несколько отдельных интерпретатов, и своя “лента” памяти. В дальнейшем, каждый отдельный символ brainfuck компилируется в одну или несколько ast-нод daScript, который затем могут быть просимулированы.</p>
<p>(Раздел <code>daScript</code> про симуляцию и устройство виртуальной машины daScript)<br><a href="/blog/2115627465/" title="Устройство интерпретаторов lua-jit и daScript">Устройство интерпретаторов lua-jit и daScript</a> </p>
<p>(Генерация кода с помощью <a href="https://dascript.org/doc/reference/language/reification.html" target="_blank" rel="noopener">реификации выражений</a>)<br><a href="/blog/4046309382/" title="daScript macro - 2">daScript macro - 2</a></p>
<p>Если говорить о терминологии, то brainfuck можно рассматривать как <code>предметно-ориентированный язык (DSL)</code>. Переменные состояния tape и tapePos вместе составляют <code>семантическую модель</code> этого языка, которая настраивается с помощью DSL, а затем транслируется в синтаксическое дерево на <code>daScript</code> (в терминах Мартина Фаулера из книги “Предметно-ориентированные языки программирования”).</p>
<p>Время выполнения такой скомпилированной функции <strong>в режиме интерпретации</strong>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">e:\src\daScript_my\bin\Release&gt;daScript.exe brainfuck.das</span><br><span class="line">[I] total 29.28014399999999995 sec</span><br></pre></td></tr></table></figure>
<p>Это немного медленнее скомпилированной JiT-версии, но уже быстрее AoT версии интерпретатора.</p>
<h2 id="Macro-JiT"><a href="#Macro-JiT" class="headerlink" title="Macro + JiT"></a>Macro + JiT</h2><p>Дальше будет интереснее. Наша скомпилированная версия функции представляет собой по сути развёрнутую трассированную версию исполнения кода (и занимающую больше памяти). Попробуем применить к ней макрос [jit]:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">fn |&gt; append_annotation(<span class="string">"$"</span>, <span class="string">"unsafe_deref"</span>, args)</span><br><span class="line">fn |&gt; append_annotation(<span class="string">"$"</span>, <span class="string">"jit"</span>, args)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">e:\src\daScript_my\bin\Release&gt;daScript.exe brainfuck.das</span><br><span class="line">[I] total 0.85775599999999996 sec</span><br></pre></td></tr></table></figure>
<p>0.85 секунды! (плюс около секунды на само время компиляции функции). llvm jit умеет сворачивать идущие подряд повторяющиеся операторы инкремента и декремента, за счёт чего получилось ускорение в 30 раз (и соотвествующее уменьшение размера функции).</p>
<p>Для сравнения — compile-time версия на nim работает ~3 секунды и тратит ~20 секунд на компиляцию (nim работает медленно в compile-time режиме).</p>
<h2 id="Оптимизации-Brainfuck-gt-daScript-AST"><a href="#Оптимизации-Brainfuck-gt-daScript-AST" class="headerlink" title="Оптимизации Brainfuck -&gt; daScript AST"></a>Оптимизации Brainfuck -&gt; daScript AST</h2><p>Получается интересная цепочка преобразования кода:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bf --&gt; (bf macro) --&gt; dascript ast --&gt; (dascript simulate - unsafe deref macro + optimizations) --&gt; dascript ast optimized --&gt; (llvm macro) --&gt; llvm native optimized code --&gt; (execute)</span><br></pre></td></tr></table></figure>
<p>На каждом из шагов происходят серьёзные трансформации кода, которые могут включать оптимизации. Можно рассмотреть оптимизации в обратном порядке:</p>
<ul>
<li>llvm — бекэнд генерации кода оптимизирует байт-код, на этом этапе заметен эффект от сворачивания идущих подряд операций</li>
<li>dascript simulate — при симуляции ast-дерева выбираются оптимизированные частные версии нод, мелкие ноды могут “сплавляться” в более крупные, применяются кастомные макросы, трансформирующие дерево по различным правилам</li>
<li>bf macro — на данном уровне производится трансляция команд brainfuck в ноды dascript, пока без оптимизаций</li>
</ul>
<p>Оптимизации на стадиях трансформаций llvm были сделаны библиотекой из “комплекта” языка, на стадиях преобразования daScript — как встроенными в язык оптимизациями, так и добавленными для своего кода вручную. Можно теперь попробовать добавить пару оптимизаций на “стороне DSL”, т.е. в макрос трансформации <code>brainfuck-&gt;daScript</code>.</p>
<p>На данном этапе первую тупую и наивную реализацию уже получилось разогнать где-то в 20000 раз, и это отличный повод разогнать ещё немного :)</p>
<p>Можно выбрать несколько простых паттернов brainfuck кода и попробовать распознавать их и генерить более оптимальный код для этих частных случаев:</p>
<ul>
<li>цепочка повторяющихся операций. Например, “+++++” можно интерпретировать не как 5 отдельных инкрементов, а как одну операцию увеличения на 5. Эту свёртку делает llvm для версии <code>Macro+JiT</code>, но если сделать её в своём макросе, то она также ускорит и обычный режим интерпретации</li>
<li>паттерн [-] можно интерпретировать как очистку ячейки памяти одной операцией</li>
<li>[-&gt;+&lt;] - чуть более сложный паттерн, который часто встречается в примерах на brainfuck, “сложение двух ячеек с очисткой исходной”, может быть интерпретирован как 2 команды вместо цикла</li>
<li>можно продолжать обнаруживать и добавлять всё более сложные паттерны</li>
</ul>
<p>(Приём с отслеживанием паттернов подходит, естественно, не только для brainfuck-кода, но и для любых DSL)</p>
<p>“Продвинутая” версия макроса, отслеживающая перечисленные паттерны</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">seachRepeats</span><span class="params">(symIt; var sym:<span class="keyword">int</span>&amp;; symbolToCheck)</span></span></span><br><span class="line"><span class="function">    var count </span>= <span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">while</span> <span class="title">next</span><span class="params">(symIt, sym)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">if</span> sym </span>== symbolToCheck</span><br><span class="line">            ++count</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> count</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line">def match_reset(data: <span class="built_in">array</span>&lt;<span class="keyword">int</span>&gt;)</span><br><span class="line">    <span class="keyword">return</span> length(data) == <span class="number">3</span> &amp;&amp; data[<span class="number">0</span>] == <span class="string">'['</span> &amp;&amp; data[<span class="number">1</span>] == <span class="string">'-'</span> &amp;&amp; data[<span class="number">2</span>] == <span class="string">']'</span></span><br><span class="line"></span><br><span class="line">def match_add_right_reset(data: <span class="built_in">array</span>&lt;<span class="keyword">int</span>&gt;)</span><br><span class="line">    <span class="keyword">return</span> length(data) == <span class="number">6</span> &amp;&amp; data[<span class="number">0</span>] == <span class="string">'['</span> &amp;&amp; data[<span class="number">1</span>] == <span class="string">'-'</span> &amp;&amp; data[<span class="number">2</span>] == <span class="string">'&gt;'</span> &amp;&amp; data[<span class="number">3</span>] == <span class="string">'+'</span> &amp;&amp; data[<span class="number">4</span>] == <span class="string">'&lt;'</span> &amp;&amp; data[<span class="number">5</span>] == <span class="string">']'</span></span><br><span class="line"></span><br><span class="line">def generateFunction(uniqueName, code)</span><br><span class="line">    let seqStr = <span class="built_in">string</span>(code)</span><br><span class="line"></span><br><span class="line">    var blkArr : <span class="built_in">array</span>&lt;<span class="built_in">array</span>&lt;ExpressionPtr&gt;&gt;; defer_delete(blkArr)</span><br><span class="line"></span><br><span class="line">    var blk : <span class="built_in">array</span>&lt;ExpressionPtr&gt;; defer_delete(blk)</span><br><span class="line">    blkArr |&gt; emplace(blk)</span><br><span class="line"></span><br><span class="line">    var cyclePatternChecker:<span class="built_in">array</span>&lt;<span class="keyword">int</span>&gt;</span><br><span class="line"></span><br><span class="line">    var initBlock &lt;- quote() &lt;|</span><br><span class="line">        var tape: <span class="built_in">array</span>&lt;uint8&gt;</span><br><span class="line">        var tapePos : <span class="keyword">int</span></span><br><span class="line">        tape |&gt; resize(<span class="number">1000000</span>)</span><br><span class="line">        var ptape = addr(tape[<span class="number">0</span>])</span><br><span class="line">    <span class="comment">//blkArr[0] |&gt; emplace_new &lt;| initBlock</span></span><br><span class="line">    unsafe</span><br><span class="line">        var _block &lt;- reinterpret&lt;smart_ptr&lt;ExprBlock&gt;&gt;(reinterpret&lt;smart_ptr&lt;ExprMakeBlock&gt;&gt; initBlock)._block</span><br><span class="line">        <span class="keyword">for</span> blockItem in _block.<span class="built_in">list</span></span><br><span class="line">            blkArr[<span class="number">0</span>] |&gt; emplace_new &lt;| blockItem</span><br><span class="line">    var symIt &lt;- unsafe(each(seqStr))</span><br><span class="line">    var sym : <span class="keyword">int</span></span><br><span class="line">    var repeat = <span class="literal">false</span></span><br><span class="line">    var count : <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> repeat || next(symIt, sym)</span><br><span class="line">        repeat = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">if</span> sym == <span class="string">'+'</span></span><br><span class="line">            cyclePatternChecker |&gt; push(sym)</span><br><span class="line">            repeat = <span class="literal">true</span></span><br><span class="line">            count = seachRepeats(symIt, sym, <span class="string">'+'</span>)</span><br><span class="line">            back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( $&#123; ptape[tapePos] = uint8(<span class="keyword">int</span>(ptape[tapePos]) + $v(count)); &#125;)</span><br><span class="line">        elif sym == <span class="string">'-'</span></span><br><span class="line">            cyclePatternChecker |&gt; push(sym)</span><br><span class="line">            repeat = <span class="literal">true</span></span><br><span class="line">            count = seachRepeats(symIt, sym, <span class="string">'-'</span>)</span><br><span class="line">            back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( $&#123; ptape[tapePos] = uint8(<span class="keyword">int</span>(ptape[tapePos]) - $v(count)); &#125;)</span><br><span class="line">        elif sym == <span class="string">'&gt;'</span></span><br><span class="line">            cyclePatternChecker |&gt; push(sym)</span><br><span class="line">            repeat = <span class="literal">true</span></span><br><span class="line">            count = seachRepeats(symIt, sym, <span class="string">'&gt;'</span>)</span><br><span class="line">            back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( $&#123; tapePos +=  $v(count); &#125;)</span><br><span class="line">        elif sym == <span class="string">'&lt;'</span></span><br><span class="line">            cyclePatternChecker |&gt; push(sym)</span><br><span class="line">            repeat = <span class="literal">true</span></span><br><span class="line">            count = seachRepeats(symIt, sym, <span class="string">'&lt;'</span>)</span><br><span class="line">            back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( $&#123; tapePos -= $v(count); &#125;)</span><br><span class="line"></span><br><span class="line">        elif sym == <span class="string">'.'</span> &#123; back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( $&#123; print(<span class="keyword">int</span>(ptape[tapePos]) |&gt; to_char); &#125;); &#125;</span><br><span class="line">        elif sym == <span class="string">','</span> &#123; back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( $&#123; ptape[tapePos] = uint8(getchar()); &#125;); &#125;</span><br><span class="line">        elif sym == <span class="string">'['</span></span><br><span class="line">            cyclePatternChecker |&gt; clear</span><br><span class="line">            cyclePatternChecker |&gt; push(sym)</span><br><span class="line">            var blk1 : <span class="built_in">array</span>&lt;ExpressionPtr&gt;; defer_delete(blk1)</span><br><span class="line">            blkArr |&gt; emplace(blk1)</span><br><span class="line">        elif sym == <span class="string">']'</span></span><br><span class="line">            cyclePatternChecker |&gt; push(sym)</span><br><span class="line">            <span class="keyword">if</span> match_reset(cyclePatternChecker)</span><br><span class="line">                <span class="comment">//match [-]</span></span><br><span class="line">                blkArr |&gt; pop()</span><br><span class="line">                back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( $&#123; ptape[tapePos] = uint8(<span class="number">0</span>); &#125;)</span><br><span class="line">            elif match_add_right_reset(cyclePatternChecker)</span><br><span class="line">                <span class="comment">//match [-&gt;+&lt;]</span></span><br><span class="line">                blkArr |&gt; pop()</span><br><span class="line">                back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( $&#123; ptape[tapePos+$v(count)] = uint8(<span class="keyword">int</span>(ptape[tapePos+$v(count)]) + <span class="keyword">int</span>(ptape[tapePos])); &#125;)</span><br><span class="line">                back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( $&#123; ptape[tapePos] = uint8(<span class="number">0</span>); &#125;)</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">//usual cycle</span></span><br><span class="line">                var last &lt;- back(blkArr)</span><br><span class="line">                blkArr |&gt; pop()</span><br><span class="line">                var whileExpr &lt;- qmacro_expr &lt;|</span><br><span class="line">                    <span class="keyword">while</span> ptape[tapePos] != uint8(<span class="number">0</span>)</span><br><span class="line">                        $b(last)</span><br><span class="line">                back(blkArr) |&gt; emplace_new &lt;| whileExpr</span><br><span class="line"></span><br><span class="line">            cyclePatternChecker |&gt; clear</span><br><span class="line">        <span class="keyword">else</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    var fnArguments : <span class="built_in">array</span>&lt;VariablePtr&gt;;</span><br><span class="line">    var fn &lt;- qmacro_function(uniqueName) &lt;| $ ($a(fnArguments))</span><br><span class="line">        unsafe</span><br><span class="line">            $b(blkArr[<span class="number">0</span>])</span><br><span class="line">    defer_delete(fn)</span><br><span class="line"></span><br><span class="line">    var args:<span class="built_in">array</span>&lt; tuple&lt;argname:<span class="built_in">string</span>;argvalue:RttiValue&gt; &gt;</span><br><span class="line">    fn |&gt; append_annotation(<span class="string">"$"</span>, <span class="string">"jit"</span>, args)</span><br><span class="line">    fn |&gt; append_annotation(<span class="string">"$"</span>, <span class="string">"unsafe_deref"</span>, args)</span><br><span class="line">    <span class="comment">//print(describe(fn))</span></span><br><span class="line">    compiling_module() |&gt; add_function(fn)</span><br></pre></td></tr></table></figure>
<p>Результат:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">e:\src\daScript_my\bin\Release&gt;daScript.exe brainfuck.das</span><br><span class="line">[I] total 0.70142899999999999 sec</span><br></pre></td></tr></table></figure>
<p>Еще на 17% быстрее<br><em>Из замеров явно стоило бы еще вынести print</em></p>
<h2 id="Немного-выводов"><a href="#Немного-выводов" class="headerlink" title="Немного выводов"></a>Немного выводов</h2><ul>
<li>Основа оптимизации — написание грамотного кода на основном языке.</li>
<li>Техники JiT-компиляции (особенно в сочетании с кодогенерацией или замерами hot участков) могут давать крутые результаты, в том числе превосходящие статическую компиляцию</li>
<li>Организация цепочки преобразований кода в одной среде НАМНОГО удобнее, чем в разных (какой-нибудь вариант “кодоген на python” + макросы/шаблоны + код на C++” - мрак с отладкой). Особенно для более длинных цепочек.</li>
<li>Нормальные макросы = нормальная отладка и скорость компиляции DSL.</li>
</ul>
<p><a href="https://github.com/spiiin/dascript_brainfuck" target="_blank" rel="noopener">Код примеров</a></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script></div></article><div class="pagination"><a class="pagination__link pagination__prev" href="/blog/1976052536/">Позже</a><a class="pagination__link pagination__next" href="/blog/1601029690/">Раньше</a></div></main><footer class="footer metadata"><p class="footer__text">© 2023 spiiin</p><p class="footer__text">Powered by <a class="footer__text__link" href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a class="footer__text__link" href="https://pages.github.com/" target="_blank">Github Page</a></p></footer></div></body></html>