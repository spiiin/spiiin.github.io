<!DOCTYPE html><html lang="ru"><head><meta charset="UTF-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Spiiin's blog | daScript. Brainfuck и оптимизации</title><meta name="description" content="&lt;p&gt;Попробовал портировать с &lt;code&gt;nim&lt;/code&gt; на &lt;code&gt;daScript&lt;/code&gt; &lt;a href=&quot;https://howistart.org/posts/nim/1/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;интерпретатор&lt;/a&gt; &lt;code&gt;brainfuck&lt;/code&gt; кода. Брейфак предельно простой язык, и базовая реализация интерпретатора занимает полчаса, но на нём можно потренироваться в ускорении кода и продемонстрировать возможности daScript в оптимизации.&lt;/p&gt;"><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=PT+Serif&amp;display=swap"><link rel="stylesheet" href="/css/highlights/darkula.css"><link rel="stylesheet" href="/css/main.css"><link rel="search" type="application/opensearchdescription+xml" href="http://spiiin.github.io/atom.xml" title="Spiiin's blog"><script>(function (i, s, o, g, r, a, m) {
  i['GoogleAnalyticsObject'] = r;
  i[r] = i[r] || function () {
    (i[r].q = i[r].q || []).push(arguments)
  }, i[r].l = 1 * new Date();
  a = s.createElement(o),
    m = s.getElementsByTagName(o)[0];
  a.async = 1;
  a.src = g;
  m.parentNode.insertBefore(a, m)
})(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');
ga('create', 'UA-00000000-0', 'auto');
ga('send', 'pageview');</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Spiiin's blog" type="application/atom+xml">
</head><body><div class="container"><header class="main-header"><h1 class="main-header__title uplize"><a class="main-header__title__link" href="/"><img class="header-image" src="/images/favicon.png" width="36" height="36">Spiiin's blog</a></h1><nav class="main-header__nav"><ul class="main-nav"><li class="main-nav__list"><a class="main-nav__list__link" href="/" target="_self">HOME</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/archives/" target="_self">ARCHIVE</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/tags/meta" target="_self">TAGS</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/blog/1" target="_self">ABOUT</a></li></ul></nav></header><main class="container__wrapper"><div class="pagination"><a class="pagination__link pagination__prev" href="/blog/1976052536/">Позже</a><a class="pagination__link pagination__next" href="/blog/1601029690/">Раньше</a></div><article class="article post"><h3 class="article__title">daScript. Brainfuck и оптимизации</h3><div class="article__date metadata"><div class="post-info">2022/11/11</div></div><div class="article__tags metadata">Tags:
<a class="article__tags__link metadata" href="/tags/llvm/">llvm</a><a class="article__tags__link metadata" href="/tags/dascript/">dascript</a></div><div class="article__body"><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Попробовал портировать с <code>nim</code> на <code>daScript</code> <a href="https://howistart.org/posts/nim/1/" target="_blank" rel="noopener">интерпретатор</a> <code>brainfuck</code> кода. Брейфак предельно простой язык, и базовая реализация интерпретатора занимает полчаса, но на нём можно потренироваться в ускорении кода и продемонстрировать возможности daScript в оптимизации.</p>
<a id="more"></a>
<p>Самая первая, максимально наивная, построчно скопированная реализация:</p>
<div style="color: #d4d4d4;background-color: #1e1e1e;font-family: Consolas, 'Courier New', monospace;font-weight: normal;font-size: 14px;line-height: 19px;white-space: pre;"><div><span style="color: #c586c0;">require</span><span style="color: #d4d4d4;"> strings</span></div><div><span style="color: #c586c0;">require</span><span style="color: #d4d4d4;"> fio</span></div><br><div><span style="color: #569cd6;">def</span><span style="color: #d4d4d4;"> </span><span style="color: #dcdcaa;">run</span><span style="color: #d4d4d4;">(</span><span style="color: #9cdcfe;">code</span><span style="color: #d4d4d4;">: </span><span style="color: #4ec9b0;">string</span><span style="color: #d4d4d4;">; </span><span style="color: #569cd6;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">tape</span><span style="color: #d4d4d4;">: </span><span style="color: #c586c0;">array</span><span style="color: #d4d4d4;">&lt;</span><span style="color: #4ec9b0;">uint8</span><span style="color: #d4d4d4;">&gt;; </span><span style="color: #569cd6;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">codePos, tapePos</span><span style="color: #d4d4d4;">: </span><span style="color: #4ec9b0;">int</span><span style="color: #d4d4d4;">&amp;; </span><span style="color: #9cdcfe;">skip</span><span style="color: #d4d4d4;">: </span><span style="color: #4ec9b0;">bool</span><span style="color: #d4d4d4;">): </span><span style="color: #4ec9b0;">bool</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">while</span><span style="color: #d4d4d4;"> tapePos &gt;= </span><span style="color: #b5cea8;">0</span><span style="color: #d4d4d4;"> &amp;&amp; codePos &lt; </span><span style="color: #dcdcaa;">length</span><span style="color: #d4d4d4;">(code)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">if</span><span style="color: #d4d4d4;"> tapePos &gt;= </span><span style="color: #dcdcaa;">length</span><span style="color: #d4d4d4;">(tape) { tape |&gt; </span><span style="color: #dcdcaa;">push</span><span style="color: #d4d4d4;">(uint8(</span><span style="color: #b5cea8;">0</span><span style="color: #d4d4d4;">)); }</span></div><br><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">let</span><span style="color: #d4d4d4;"> sym1 &#160;= code |&gt; character_at(codePos)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">if</span><span style="color: #d4d4d4;"> sym1 == </span><span style="color: #ce9178;">'['</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; ++codePos</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">let</span><span style="color: #d4d4d4;"> oldPos = codePos</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">while</span><span style="color: #d4d4d4;"> run(code, tape, codePos, tapePos, tape[</span><span style="color: #569cd6;">tapePos</span><span style="color: #d4d4d4;">] == uint8(</span><span style="color: #b5cea8;">0</span><span style="color: #d4d4d4;">))</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; codePos = oldPos</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">elif</span><span style="color: #d4d4d4;"> sym1 == </span><span style="color: #ce9178;">']'</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">return</span><span style="color: #d4d4d4;"> tape[</span><span style="color: #569cd6;">tapePos</span><span style="color: #d4d4d4;">] != uint8(</span><span style="color: #b5cea8;">0</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">elif</span><span style="color: #d4d4d4;"> !skip</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">let</span><span style="color: #d4d4d4;"> sym &#160;= code |&gt; character_at(codePos)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">if</span><span style="color: #d4d4d4;"> sym == </span><span style="color: #ce9178;">'+'</span><span style="color: #d4d4d4;"> { tape[</span><span style="color: #569cd6;">tapePos</span><span style="color: #d4d4d4;">] = uint8(int(tape[</span><span style="color: #569cd6;">tapePos</span><span style="color: #d4d4d4;">]) + </span><span style="color: #b5cea8;">1</span><span style="color: #d4d4d4;">); }</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">elif</span><span style="color: #d4d4d4;"> sym == </span><span style="color: #ce9178;">'-'</span><span style="color: #d4d4d4;"> { tape[</span><span style="color: #569cd6;">tapePos</span><span style="color: #d4d4d4;">] = uint8(int(tape[</span><span style="color: #569cd6;">tapePos</span><span style="color: #d4d4d4;">]) - </span><span style="color: #b5cea8;">1</span><span style="color: #d4d4d4;">); }</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">elif</span><span style="color: #d4d4d4;"> sym == </span><span style="color: #ce9178;">'&gt;'</span><span style="color: #d4d4d4;"> { ++tapePos; }</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">elif</span><span style="color: #d4d4d4;"> sym == </span><span style="color: #ce9178;">'&lt;'</span><span style="color: #d4d4d4;"> { --tapePos; }</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">elif</span><span style="color: #d4d4d4;"> sym == </span><span style="color: #ce9178;">'.'</span><span style="color: #d4d4d4;"> { </span><span style="color: #dcdcaa;">print</span><span style="color: #d4d4d4;">(</span><span style="color: #ce9178;">"{int(tape[</span><span style="color: #569cd6;">tapePos</span><span style="color: #ce9178;">]) </span><span style="color: #d4d4d4;">|&gt;</span><span style="color: #ce9178;"> </span><span style="color: #9cdcfe;">to_char</span><span style="color: #ce9178;">}"</span><span style="color: #d4d4d4;">); }</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">elif</span><span style="color: #d4d4d4;"> sym == </span><span style="color: #ce9178;">','</span><span style="color: #d4d4d4;"> { tape[</span><span style="color: #569cd6;">tapePos</span><span style="color: #d4d4d4;">] = uint8(getchar()); }</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">else</span><span style="color: #d4d4d4;"> { }</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; ++codePos</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">return</span><span style="color: #d4d4d4;"> </span><span style="color: #c586c0;">false</span></div><br><div><span style="color: #569cd6;">def</span><span style="color: #d4d4d4;"> </span><span style="color: #dcdcaa;">interpret</span><span style="color: #d4d4d4;">(</span><span style="color: #9cdcfe;">code</span><span style="color: #d4d4d4;">: </span><span style="color: #4ec9b0;">string</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">let</span><span style="color: #d4d4d4;"> totalTime = ref_time_ticks()</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> tape: </span><span style="color: #c586c0;">array</span><span style="color: #d4d4d4;">&lt;</span><span style="color: #4ec9b0;">uint8</span><span style="color: #d4d4d4;">&gt;</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> codePos, tapePos : </span><span style="color: #4ec9b0;">int</span></div><div><span style="color: #d4d4d4;">&#160; &#160; run(code, tape, codePos, tapePos, </span><span style="color: #c586c0;">false</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">let</span><span style="color: #d4d4d4;"> totalDt = double(get_time_usec(totalTime)) /</span><span style="color: #b5cea8;">1000000.0l</span><span style="color: #d4d4d4;">f</span></div><div><span style="color: #d4d4d4;">&#160; &#160; to_log(LOG_INFO, </span><span style="color: #ce9178;">"total {</span><span style="color: #9cdcfe;">totalDt</span><span style="color: #ce9178;">} sec</span><span style="color: #d7ba7d;">\n</span><span style="color: #ce9178;">"</span><span style="color: #d4d4d4;">)</span></div></div>
<p>Если попытаться протестировать его на генераторе <a href="https://github.com/def-/nim-brainfuck/blob/master/examples/mandelbrot.b" target="_blank" rel="noopener">множества Мандельброта</a>, можно заметить серьёзные проблемы со скоростью, вычисления занимают около 5 часов. Стоит попробовать его разогнать!</p>
<h2 id="Отключение-проверок-границ-и-указателей"><a href="#Отключение-проверок-границ-и-указателей" class="headerlink" title="Отключение проверок границ и указателей"></a>Отключение проверок границ и указателей</h2><p>Код на brainfuck - это простая числодробилка, ускорить которую можно, отключив все дополнительные проверки обращений к памяти.</p>
<p><em>Как отключать проверки, мне рассказал <a href="https://github.com/borisbat" target="_blank" rel="noopener">Борис Баткин</a> (так как интерпретатор nim делал один основных контрибьютеров языка, то его подсказки не отменяют честности сравнения — авторы находятся в одной “весовой категории” знания своего языка).</em></p>
<p>В первую очередь, можно заменить функцию <code>charcter_at</code>, которая <a href="https://github.com/GaijinEntertainment/daScript/blob/e9f4c486848a8985e4126e0fc2d04afbc6abd883/src/builtin/module_builtin_string.cpp#L26" target="_blank" rel="noopener">проверяет</a>,что индекс меньше длины строки, на <code>character_uat</code>, которая не делает этой проверки.</p>
<p>Также отключается проверка ссылок на null макросом <code>[unsafe_deref]</code>.</p>
<p>Наконец, обращение к массиву можно выполнять не через разыменование ссылки, а через обращение по указателю:</p>
<div style="color: #d4d4d4;background-color: #1e1e1e;font-family: Consolas, 'Courier New', monospace;font-weight: normal;font-size: 14px;line-height: 19px;white-space: pre;"><div><span style="color: #d4d4d4;">tape: </span><span style="color: #c586c0;">array</span><span style="color: #d4d4d4;">&lt;</span><span style="color: #4ec9b0;">uint8</span><span style="color: #d4d4d4;">&gt;</span></div><div><span style="color: #d4d4d4;">tape[</span><span style="color: #569cd6;">index</span><span style="color: #d4d4d4;">] </span><span style="color: #6a9955;">// tape[check_range(index)] //медленно</span></div><br><div><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> ptape: </span><span style="color: #4ec9b0;">uint8</span><span style="color: #d4d4d4;">? = </span><span style="color: #c586c0;">addr</span><span style="color: #d4d4d4;">(tape[</span><span style="color: #569cd6;">0</span><span style="color: #d4d4d4;">])</span></div><div><span style="color: #d4d4d4;">ptape[</span><span style="color: #569cd6;">index</span><span style="color: #d4d4d4;">] </span><span style="color: #6a9955;">//check_not_null(ptape)[index] //быстрее, обращение без проверок</span></div><br><div><span style="color: #d4d4d4;">[</span><span style="color: #569cd6;">unsafe_deref</span><span style="color: #d4d4d4;">]</span></div><div><span style="color: #d4d4d4;">ptape[</span><span style="color: #569cd6;">index</span><span style="color: #d4d4d4;">] </span><span style="color: #6a9955;">//ptape[index] //еще быстрее, обращение без перепроверок указателя на nullptr</span></div></div>
<p>Переписанная версия кода:</p>
<div style="color: #d4d4d4;background-color: #1e1e1e;font-family: Consolas, 'Courier New', monospace;font-weight: normal;font-size: 14px;line-height: 19px;white-space: pre;"><div><span style="color: #d4d4d4;">[</span><span style="color: #569cd6;">unsafe_deref</span><span style="color: #d4d4d4;">]</span></div><div><span style="color: #569cd6;">def</span><span style="color: #d4d4d4;"> </span><span style="color: #dcdcaa;">run</span><span style="color: #d4d4d4;">(</span><span style="color: #9cdcfe;">code</span><span style="color: #d4d4d4;">: </span><span style="color: #4ec9b0;">uint8</span><span style="color: #d4d4d4;">?; </span><span style="color: #9cdcfe;">lengthOfCode</span><span style="color: #d4d4d4;">:</span><span style="color: #4ec9b0;">int</span><span style="color: #d4d4d4;">; </span><span style="color: #569cd6;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">tape</span><span style="color: #d4d4d4;">: </span><span style="color: #4ec9b0;">uint8</span><span style="color: #d4d4d4;">?; </span><span style="color: #569cd6;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">codePos, tapePos</span><span style="color: #d4d4d4;">: </span><span style="color: #4ec9b0;">int</span><span style="color: #d4d4d4;">&amp;; </span><span style="color: #9cdcfe;">skip</span><span style="color: #d4d4d4;">: </span><span style="color: #4ec9b0;">bool</span><span style="color: #d4d4d4;">): </span><span style="color: #4ec9b0;">bool</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">unsafe</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">while</span><span style="color: #d4d4d4;"> tapePos &gt;= </span><span style="color: #b5cea8;">0</span><span style="color: #d4d4d4;"> &amp;&amp; codePos &lt; lengthOfCode</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">let</span><span style="color: #d4d4d4;"> sym1 &#160;= int(code[</span><span style="color: #569cd6;">codePos</span><span style="color: #d4d4d4;">])</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">if</span><span style="color: #d4d4d4;"> sym1 == </span><span style="color: #ce9178;">'['</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; ++codePos</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">let</span><span style="color: #d4d4d4;"> oldPos = codePos</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">while</span><span style="color: #d4d4d4;"> run(code, lengthOfCode, tape, codePos, tapePos, tape[</span><span style="color: #569cd6;">tapePos</span><span style="color: #d4d4d4;">] == uint8(</span><span style="color: #b5cea8;">0</span><span style="color: #d4d4d4;">))</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; codePos = oldPos</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">elif</span><span style="color: #d4d4d4;"> sym1 == </span><span style="color: #ce9178;">']'</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">return</span><span style="color: #d4d4d4;"> tape[</span><span style="color: #569cd6;">tapePos</span><span style="color: #d4d4d4;">] != uint8(</span><span style="color: #b5cea8;">0</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">elif</span><span style="color: #d4d4d4;"> !skip</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">let</span><span style="color: #d4d4d4;"> sym &#160;= int(code[</span><span style="color: #569cd6;">codePos</span><span style="color: #d4d4d4;">])</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">if</span><span style="color: #d4d4d4;"> sym == </span><span style="color: #ce9178;">'+'</span><span style="color: #d4d4d4;"> { tape[</span><span style="color: #569cd6;">tapePos</span><span style="color: #d4d4d4;">] = uint8(int(tape[</span><span style="color: #569cd6;">tapePos</span><span style="color: #d4d4d4;">]) + </span><span style="color: #b5cea8;">1</span><span style="color: #d4d4d4;">); }</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">elif</span><span style="color: #d4d4d4;"> sym == </span><span style="color: #ce9178;">'-'</span><span style="color: #d4d4d4;"> { tape[</span><span style="color: #569cd6;">tapePos</span><span style="color: #d4d4d4;">] = uint8(int(tape[</span><span style="color: #569cd6;">tapePos</span><span style="color: #d4d4d4;">]) - </span><span style="color: #b5cea8;">1</span><span style="color: #d4d4d4;">); }</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">elif</span><span style="color: #d4d4d4;"> sym == </span><span style="color: #ce9178;">'&gt;'</span><span style="color: #d4d4d4;"> { ++tapePos; }</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">elif</span><span style="color: #d4d4d4;"> sym == </span><span style="color: #ce9178;">'&lt;'</span><span style="color: #d4d4d4;"> { --tapePos; }</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">elif</span><span style="color: #d4d4d4;"> sym == </span><span style="color: #ce9178;">'.'</span><span style="color: #d4d4d4;"> { </span><span style="color: #dcdcaa;">print</span><span style="color: #d4d4d4;">(int(tape[</span><span style="color: #569cd6;">tapePos</span><span style="color: #d4d4d4;">]) |&gt; to_char); }</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">elif</span><span style="color: #d4d4d4;"> sym == </span><span style="color: #ce9178;">','</span><span style="color: #d4d4d4;"> { tape[</span><span style="color: #569cd6;">tapePos</span><span style="color: #d4d4d4;">] = uint8(getchar()); }</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">else</span><span style="color: #d4d4d4;"> { }</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; ++codePos</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">return</span><span style="color: #d4d4d4;"> </span><span style="color: #c586c0;">false</span></div><br><div><span style="color: #569cd6;">def</span><span style="color: #d4d4d4;"> </span><span style="color: #dcdcaa;">interpret</span><span style="color: #d4d4d4;">(</span><span style="color: #9cdcfe;">code</span><span style="color: #d4d4d4;">: </span><span style="color: #4ec9b0;">string</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">let</span><span style="color: #d4d4d4;"> totalTime = ref_time_ticks()</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> tape: </span><span style="color: #c586c0;">array</span><span style="color: #d4d4d4;">&lt;</span><span style="color: #4ec9b0;">uint8</span><span style="color: #d4d4d4;">&gt;</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> codePos, tapePos : </span><span style="color: #4ec9b0;">int</span></div><div><span style="color: #d4d4d4;">&#160; &#160; tape |&gt; </span><span style="color: #dcdcaa;">resize</span><span style="color: #d4d4d4;">(</span><span style="color: #b5cea8;">1000000</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">unsafe</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; run(</span><span style="color: #c586c0;">reinterpret</span><span style="color: #d4d4d4;">&lt;</span><span style="color: #4ec9b0;">uint8</span><span style="color: #d4d4d4;">?&gt; code, </span><span style="color: #dcdcaa;">length</span><span style="color: #d4d4d4;">(code), </span><span style="color: #c586c0;">addr</span><span style="color: #d4d4d4;">(tape[</span><span style="color: #569cd6;">0</span><span style="color: #d4d4d4;">]), codePos, tapePos, </span><span style="color: #c586c0;">false</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">let</span><span style="color: #d4d4d4;"> totalDt = double(get_time_usec(totalTime)) /</span><span style="color: #b5cea8;">1000000.0l</span><span style="color: #d4d4d4;">f</span></div><div><span style="color: #d4d4d4;">&#160; &#160; to_log(LOG_INFO, </span><span style="color: #ce9178;">"total {</span><span style="color: #9cdcfe;">totalDt</span><span style="color: #ce9178;">} sec</span><span style="color: #d7ba7d;">\n</span><span style="color: #ce9178;">"</span><span style="color: #d4d4d4;">)</span></div></div>
<p>Такая версия интерпретатора всё ещё тормозная, но уже позволяет дождаться завершения выполнения кода:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">e:\src\daScript\bin\Release&gt;daScript.exe brainfuck_00.das</span><br><span class="line">AAAAAAAAAAAAAAAABBBBBBBBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDEGFFEEEEDDDDDDCCCCCCCCCBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB</span><br><span class="line">AAAAAAAAAAAAAAABBBBBBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDEEEFGIIGFFEEEDDDDDDDDCCCCCCCCCBBBBBBBBBBBBBBBBBBBBBBBBBB</span><br><span class="line">AAAAAAAAAAAAABBBBBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDEEEEFFFI KHGGGHGEDDDDDDDDDCCCCCCCCCBBBBBBBBBBBBBBBBBBBBBBB</span><br><span class="line">AAAAAAAAAAAABBBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDEEEEEFFGHIMTKLZOGFEEDDDDDDDDDCCCCCCCCCBBBBBBBBBBBBBBBBBBBBB</span><br><span class="line">AAAAAAAAAAABBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDEEEEEEFGGHHIKPPKIHGFFEEEDDDDDDDDDCCCCCCCCCCBBBBBBBBBBBBBBBBBB</span><br><span class="line">AAAAAAAAAABBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDEEEEEEFFGHIJKS  X KHHGFEEEEEDDDDDDDDDCCCCCCCCCCBBBBBBBBBBBBBBBB</span><br><span class="line">AAAAAAAAABBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDEEEEEEFFGQPUVOTY   ZQL[MHFEEEEEEEDDDDDDDCCCCCCCCCCCBBBBBBBBBBBBBB</span><br><span class="line">AAAAAAAABBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDEEEEEFFFFFGGHJLZ         UKHGFFEEEEEEEEDDDDDCCCCCCCCCCCCBBBBBBBBBBBB</span><br><span class="line">AAAAAAABBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDEEEEFFFFFFGGGGHIKP           KHHGGFFFFEEEEEEDDDDDCCCCCCCCCCCBBBBBBBBBBB</span><br><span class="line">AAAAAAABBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDEEEEEFGGHIIHHHHHIIIJKMR        VMKJIHHHGFFFFFFGSGEDDDDCCCCCCCCCCCCBBBBBBBBB</span><br><span class="line">AAAAAABBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDEEEEEEFFGHK   MKJIJO  N R  X      YUSR PLV LHHHGGHIOJGFEDDDCCCCCCCCCCCCBBBBBBBB</span><br><span class="line">AAAAABBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDEEEEEEEEEFFFFGH O    TN S                       NKJKR LLQMNHEEDDDCCCCCCCCCCCCBBBBBBB</span><br><span class="line">AAAAABBCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDEEEEEEEEEEEEFFFFFGHHIN                                 Q     UMWGEEEDDDCCCCCCCCCCCCBBBBBB</span><br><span class="line">AAAABBCCCCCCCCCCCCCCCCCCCCCCCCCDDDDEEEEEEEEEEEEEEEFFFFFFGHIJKLOT                                     [JGFFEEEDDCCCCCCCCCCCCCBBBBB</span><br><span class="line">AAAABCCCCCCCCCCCCCCCCCCCCCCDDDDEEEEEEEEEEEEEEEEFFFFFFGGHYV RQU                                     QMJHGGFEEEDDDCCCCCCCCCCCCCBBBB</span><br><span class="line">AAABCCCCCCCCCCCCCCCCCDDDDDDDEEFJIHFFFFFFFFFFFFFFGGGGGGHIJN                                            JHHGFEEDDDDCCCCCCCCCCCCCBBB</span><br><span class="line">AAABCCCCCCCCCCCDDDDDDDDDDEEEEFFHLKHHGGGGHHMJHGGGGGGHHHIKRR                                           UQ L HFEDDDDCCCCCCCCCCCCCCBB</span><br><span class="line">AABCCCCCCCCDDDDDDDDDDDEEEEEEFFFHKQMRKNJIJLVS JJKIIIIIIJLR                                               YNHFEDDDDDCCCCCCCCCCCCCBB</span><br><span class="line">AABCCCCCDDDDDDDDDDDDEEEEEEEFFGGHIJKOU  O O   PR LLJJJKL                                                OIHFFEDDDDDCCCCCCCCCCCCCCB</span><br><span class="line">AACCCDDDDDDDDDDDDDEEEEEEEEEFGGGHIJMR              RMLMN                                                 NTFEEDDDDDDCCCCCCCCCCCCCB</span><br><span class="line">AACCDDDDDDDDDDDDEEEEEEEEEFGGGHHKONSZ                QPR                                                NJGFEEDDDDDDCCCCCCCCCCCCCC</span><br><span class="line">ABCDDDDDDDDDDDEEEEEFFFFFGIPJIIJKMQ                   VX                                                 HFFEEDDDDDDCCCCCCCCCCCCCC</span><br><span class="line">ACDDDDDDDDDDEFFFFFFFGGGGHIKZOOPPS                                                                      HGFEEEDDDDDDCCCCCCCCCCCCCC</span><br><span class="line">ADEEEEFFFGHIGGGGGGHHHHIJJLNY                                                                        TJHGFFEEEDDDDDDDCCCCCCCCCCCCC</span><br><span class="line">A                                                                                                 PLJHGGFFEEEDDDDDDDCCCCCCCCCCCCC</span><br><span class="line">ADEEEEFFFGHIGGGGGGHHHHIJJLNY                                                                        TJHGFFEEEDDDDDDDCCCCCCCCCCCCC</span><br><span class="line">ACDDDDDDDDDDEFFFFFFFGGGGHIKZOOPPS                                                                      HGFEEEDDDDDDCCCCCCCCCCCCCC</span><br><span class="line">ABCDDDDDDDDDDDEEEEEFFFFFGIPJIIJKMQ                   VX                                                 HFFEEDDDDDDCCCCCCCCCCCCCC</span><br><span class="line">AACCDDDDDDDDDDDDEEEEEEEEEFGGGHHKONSZ                QPR                                                NJGFEEDDDDDDCCCCCCCCCCCCCC</span><br><span class="line">AACCCDDDDDDDDDDDDDEEEEEEEEEFGGGHIJMR              RMLMN                                                 NTFEEDDDDDDCCCCCCCCCCCCCB</span><br><span class="line">AABCCCCCDDDDDDDDDDDDEEEEEEEFFGGHIJKOU  O O   PR LLJJJKL                                                OIHFFEDDDDDCCCCCCCCCCCCCCB</span><br><span class="line">AABCCCCCCCCDDDDDDDDDDDEEEEEEFFFHKQMRKNJIJLVS JJKIIIIIIJLR                                               YNHFEDDDDDCCCCCCCCCCCCCBB</span><br><span class="line">AAABCCCCCCCCCCCDDDDDDDDDDEEEEFFHLKHHGGGGHHMJHGGGGGGHHHIKRR                                           UQ L HFEDDDDCCCCCCCCCCCCCCBB</span><br><span class="line">AAABCCCCCCCCCCCCCCCCCDDDDDDDEEFJIHFFFFFFFFFFFFFFGGGGGGHIJN                                            JHHGFEEDDDDCCCCCCCCCCCCCBBB</span><br><span class="line">AAAABCCCCCCCCCCCCCCCCCCCCCCDDDDEEEEEEEEEEEEEEEEFFFFFFGGHYV RQU                                     QMJHGGFEEEDDDCCCCCCCCCCCCCBBBB</span><br><span class="line">AAAABBCCCCCCCCCCCCCCCCCCCCCCCCCDDDDEEEEEEEEEEEEEEEFFFFFFGHIJKLOT                                     [JGFFEEEDDCCCCCCCCCCCCCBBBBB</span><br><span class="line">AAAAABBCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDEEEEEEEEEEEEFFFFFGHHIN                                 Q     UMWGEEEDDDCCCCCCCCCCCCBBBBBB</span><br><span class="line">AAAAABBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDEEEEEEEEEFFFFGH O    TN S                       NKJKR LLQMNHEEDDDCCCCCCCCCCCCBBBBBBB</span><br><span class="line">AAAAAABBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDEEEEEEFFGHK   MKJIJO  N R  X      YUSR PLV LHHHGGHIOJGFEDDDCCCCCCCCCCCCBBBBBBBB</span><br><span class="line">AAAAAAABBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDEEEEEFGGHIIHHHHHIIIJKMR        VMKJIHHHGFFFFFFGSGEDDDDCCCCCCCCCCCCBBBBBBBBB</span><br><span class="line">AAAAAAABBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDEEEEFFFFFFGGGGHIKP           KHHGGFFFFEEEEEEDDDDDCCCCCCCCCCCBBBBBBBBBBB</span><br><span class="line">AAAAAAAABBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDEEEEEFFFFFGGHJLZ         UKHGFFEEEEEEEEDDDDDCCCCCCCCCCCCBBBBBBBBBBBB</span><br><span class="line">AAAAAAAAABBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDEEEEEEFFGQPUVOTY   ZQL[MHFEEEEEEEDDDDDDDCCCCCCCCCCCBBBBBBBBBBBBBB</span><br><span class="line">AAAAAAAAAABBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDEEEEEEFFGHIJKS  X KHHGFEEEEEDDDDDDDDDCCCCCCCCCCBBBBBBBBBBBBBBBB</span><br><span class="line">AAAAAAAAAAABBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDEEEEEEFGGHHIKPPKIHGFFEEEDDDDDDDDDCCCCCCCCCCBBBBBBBBBBBBBBBBBB</span><br><span class="line">AAAAAAAAAAAABBBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDEEEEEFFGHIMTKLZOGFEEDDDDDDDDDCCCCCCCCCBBBBBBBBBBBBBBBBBBBBB</span><br><span class="line">AAAAAAAAAAAAABBBBBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDEEEEFFFI KHGGGHGEDDDDDDDDDCCCCCCCCCBBBBBBBBBBBBBBBBBBBBBBB</span><br><span class="line">AAAAAAAAAAAAAAABBBBBBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDEEEFGIIGFFEEEDDDDDDDDCCCCCCCCCBBBBBBBBBBBBBBBBBBBBBBBBBB</span><br><span class="line">[I] total 564.99929999999994834 sec</span><br></pre></td></tr></table></figure>
<p>564 секунды — в 30 раз быстрее первой версии, но всё ещё сильно медленнее интерпретатора на <code>nim</code>, который в релизной версии выполняется за 40 секунд.</p>
<h2 id="Ahead-of-Time"><a href="#Ahead-of-Time" class="headerlink" title="Ahead-of-Time"></a>Ahead-of-Time</h2><p>daScript умеет транспилироваться в C++ код, для сравнения с nim попробуем скомпилировать интерпретатор, без внесения каких-либо изменений в код.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">daScript.exe -aot brainfuck.das brainfuck.das.cpp</span><br></pre></td></tr></table></figure>
<p>Полученный C++-файл проще всего подсунуть в пример <a href="https://github.com/GaijinEntertainment/daScript/blob/master/examples/tutorial/tutorial02aot.cpp" target="_blank" rel="noopener">tutorial02aot</a>, который настроен на использование AoT варианта кода. Скомпилированный файл можно запустить:</p>
<div style="color: #d4d4d4;background-color: #1e1e1e;font-family: Consolas, 'Courier New', monospace;font-weight: normal;font-size: 14px;line-height: 19px;white-space: pre;"><div><span style="color: #d4d4d4;">e:\src\daScript\bin\Release&gt;tutorial02aot.exe</span></div><div><span style="color: #d4d4d4;">[</span><span style="color: #569cd6;">I</span><span style="color: #d4d4d4;">] total </span><span style="color: #b5cea8;">34.27342399999999856</span><span style="color: #d4d4d4;"> sec</span></div></div>
<p>34 секунды — уже быстрее, чем nim, который сам по себе достаточно быстрый!</p>
<h2 id="Just-in-Time"><a href="#Just-in-Time" class="headerlink" title="Just-in-Time"></a>Just-in-Time</h2><p>Можно попробовать двигаться дальше, подключив экспериментальный модуль <a href="https://github.com/borisbat/dasLLVM" target="_blank" rel="noopener">dasLLVM</a>. Чтобы собрать его, необходимо:</p>
<ul>
<li>включить сборку модуля в cmake:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">option(DAS_LLVM_DISABLED &quot;Disable dasLLVM (llvm bindings)&quot; OFF)</span><br></pre></td></tr></table></figure>
<ul>
<li>собрать проект llvm, или скачать собранный (например, от <a href="https://download.qt.io/development_releases/prebuilt/libclang/" target="_blank" rel="noopener">qt</a>) и положить на уровень выше корневой директории проекта daScript, напрммер:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:&#x2F;dascript</span><br><span class="line">C:&#x2F;libclang</span><br></pre></td></tr></table></figure>
<ul>
<li>сгенерировать решение и пересобрать dascript:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">generate_msvc_2019.bat</span><br></pre></td></tr></table></figure>
<p>Теперь можно воспользоваться аннотацией <code>[jit]</code>, чтобы код функциии интерпретатора без AoT-компиляции перед первым выполнением компилировался с помощью <code>llvm-c</code>.</p>
<div style="color: #d4d4d4;background-color: #1e1e1e;font-family: Consolas, 'Courier New', monospace;font-weight: normal;font-size: 14px;line-height: 19px;white-space: pre;"><div><span style="color: #d4d4d4;">[</span><span style="color: #569cd6;">jit,unsafe_deref</span><span style="color: #d4d4d4;">]</span></div><div><span style="color: #569cd6;">def</span><span style="color: #d4d4d4;"> </span><span style="color: #dcdcaa;">run</span><span style="color: #d4d4d4;">(</span><span style="color: #9cdcfe;">code</span><span style="color: #d4d4d4;">: </span><span style="color: #4ec9b0;">uint8</span><span style="color: #d4d4d4;">?; </span><span style="color: #9cdcfe;">lengthOfCode</span><span style="color: #d4d4d4;">:</span><span style="color: #4ec9b0;">int</span><span style="color: #d4d4d4;">; </span><span style="color: #569cd6;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">tape</span><span style="color: #d4d4d4;">: </span><span style="color: #4ec9b0;">uint8</span><span style="color: #d4d4d4;">?; </span><span style="color: #569cd6;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">codePos, tapePos</span><span style="color: #d4d4d4;">: </span><span style="color: #4ec9b0;">int</span><span style="color: #d4d4d4;">&amp;; </span><span style="color: #9cdcfe;">skip</span><span style="color: #d4d4d4;">: </span><span style="color: #4ec9b0;">bool</span><span style="color: #d4d4d4;">): </span><span style="color: #4ec9b0;">bool</span></div></div>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">e:\src\daScript_my\bin\Release&gt;daScript.exe brainfuck_2_jit.das</span><br><span class="line">[I] total 22.66654300000000077 sec</span><br></pre></td></tr></table></figure>
<p>22.6 секунды, еще лучше! Генерация daScript-кода в llvm-ассемблер быстрее, чем в C++ — генератор передаёт больше полезной для оптимизации о кода, а также, возможно, задействуется сила оптимизаций LLVM.</p>
<h2 id="Метапрограммирование"><a href="#Метапрограммирование" class="headerlink" title="Метапрограммирование"></a>Метапрограммирование</h2><p>Можно двигаться дальше. Вместо того, чтобы писать функцию, которая интерпретирует любой код на brainfuck, можно написать макрос, который сгенерирует код конкретной функции в compile-time, и измерить время выполнения этой функции.</p>
<p>Можно использовать <a href="https://dascript.org/doc/reference/language/macros.html#astreadermacro" target="_blank" rel="noopener">AstReaderMacro</a> — тип макроса, который обрабатывает отдельные символы. Синтаксис вызова такого макроса:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">% READER_MACRO_NAME ~ character_sequence %% &#x2F;&#x2F;character_sequence будет передана на вход макросу</span><br></pre></td></tr></table></figure>
<p>Шаблоны таких макросов можно посмотреть в модулях <code>json_boost</code> и <code>regex_boost</code></p>
<div style="color: #d4d4d4;background-color: #1e1e1e;font-family: Consolas, 'Courier New', monospace;font-weight: normal;font-size: 14px;line-height: 19px;white-space: pre;"><div><span style="color: #c586c0;">module</span><span style="color: #d4d4d4;"> brainfuck_macro </span><span style="color: #c586c0;">shared</span><span style="color: #d4d4d4;"> </span><span style="color: #c586c0;">public</span></div><br><div><span style="color: #569cd6;">def</span><span style="color: #d4d4d4;"> </span><span style="color: #dcdcaa;">generateFunction</span><span style="color: #d4d4d4;">(uniqueName, </span><span style="color: #9cdcfe;">code</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">let</span><span style="color: #d4d4d4;"> seqStr = string(code)</span></div><br><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> blkArr : </span><span style="color: #c586c0;">array</span><span style="color: #d4d4d4;">&lt;</span><span style="color: #c586c0;">array</span><span style="color: #d4d4d4;">&lt;ExpressionPtr&gt;&gt;; defer_delete(blkArr)</span></div><br><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> blk : </span><span style="color: #c586c0;">array</span><span style="color: #d4d4d4;">&lt;ExpressionPtr&gt;; defer_delete(blk)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; blkArr |&gt; </span><span style="color: #dcdcaa;">emplace</span><span style="color: #d4d4d4;">(blk)</span></div><br><div><span style="color: #d4d4d4;">&#160; &#160; blkArr[</span><span style="color: #569cd6;">0</span><span style="color: #d4d4d4;">] |&gt; emplace_new &lt;| qmacro_expr( ${ </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> tape: </span><span style="color: #c586c0;">array</span><span style="color: #d4d4d4;">&lt;</span><span style="color: #4ec9b0;">uint8</span><span style="color: #d4d4d4;">&gt;; })</span></div><div><span style="color: #d4d4d4;">&#160; &#160; blkArr[</span><span style="color: #569cd6;">0</span><span style="color: #d4d4d4;">] |&gt; emplace_new &lt;| qmacro_expr( ${ </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> tapePos : </span><span style="color: #4ec9b0;">int</span><span style="color: #d4d4d4;">; })</span></div><div><span style="color: #d4d4d4;">&#160; &#160; blkArr[</span><span style="color: #569cd6;">0</span><span style="color: #d4d4d4;">] |&gt; emplace_new &lt;| qmacro_expr( ${ tape |&gt; </span><span style="color: #dcdcaa;">resize</span><span style="color: #d4d4d4;">(</span><span style="color: #b5cea8;">1000000</span><span style="color: #d4d4d4;">); })</span></div><div><span style="color: #d4d4d4;">&#160; &#160; blkArr[</span><span style="color: #569cd6;">0</span><span style="color: #d4d4d4;">] |&gt; emplace_new &lt;| qmacro_expr( ${ </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">ptape</span><span style="color: #d4d4d4;"> = </span><span style="color: #c586c0;">addr</span><span style="color: #d4d4d4;">(tape[</span><span style="color: #569cd6;">0</span><span style="color: #d4d4d4;">]); })</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">for</span><span style="color: #d4d4d4;"> sym </span><span style="color: #c586c0;">in</span><span style="color: #d4d4d4;"> seqStr</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">if</span><span style="color: #d4d4d4;"> sym == </span><span style="color: #ce9178;">'+'</span><span style="color: #d4d4d4;"> &#160; { back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( ${ ptape[</span><span style="color: #569cd6;">tapePos</span><span style="color: #d4d4d4;">] = uint8(int(ptape[</span><span style="color: #569cd6;">tapePos</span><span style="color: #d4d4d4;">]) + </span><span style="color: #b5cea8;">1</span><span style="color: #d4d4d4;">); }); }</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">elif</span><span style="color: #d4d4d4;"> sym == </span><span style="color: #ce9178;">'-'</span><span style="color: #d4d4d4;"> { back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( ${ ptape[</span><span style="color: #569cd6;">tapePos</span><span style="color: #d4d4d4;">] = uint8(int(ptape[</span><span style="color: #569cd6;">tapePos</span><span style="color: #d4d4d4;">]) - </span><span style="color: #b5cea8;">1</span><span style="color: #d4d4d4;">); }); }</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">elif</span><span style="color: #d4d4d4;"> sym == </span><span style="color: #ce9178;">'&gt;'</span><span style="color: #d4d4d4;"> { back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( ${ ++tapePos; }); } </span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">elif</span><span style="color: #d4d4d4;"> sym == </span><span style="color: #ce9178;">'&lt;'</span><span style="color: #d4d4d4;"> { back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( ${ --tapePos; }); }</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">elif</span><span style="color: #d4d4d4;"> sym == </span><span style="color: #ce9178;">'.'</span><span style="color: #d4d4d4;"> { back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( ${ </span><span style="color: #dcdcaa;">print</span><span style="color: #d4d4d4;">(int(ptape[</span><span style="color: #569cd6;">tapePos</span><span style="color: #d4d4d4;">]) |&gt; to_char); }); }</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">elif</span><span style="color: #d4d4d4;"> sym == </span><span style="color: #ce9178;">','</span><span style="color: #d4d4d4;"> { back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( ${ ptape[</span><span style="color: #569cd6;">tapePos</span><span style="color: #d4d4d4;">] = uint8(getchar()); }); }</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">elif</span><span style="color: #d4d4d4;"> sym == </span><span style="color: #ce9178;">'['</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> blk1 : </span><span style="color: #c586c0;">array</span><span style="color: #d4d4d4;">&lt;ExpressionPtr&gt;; defer_delete(blk1)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; blkArr |&gt; </span><span style="color: #dcdcaa;">emplace</span><span style="color: #d4d4d4;">(blk1)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">elif</span><span style="color: #d4d4d4;"> sym == </span><span style="color: #ce9178;">']'</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> last &lt;- back(blkArr)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; blkArr |&gt; pop()</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> whileExpr &lt;- qmacro_expr &lt;|</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">while</span><span style="color: #d4d4d4;"> ptape[</span><span style="color: #569cd6;">tapePos</span><span style="color: #d4d4d4;">] != uint8(</span><span style="color: #b5cea8;">0</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; $b(last)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; back(blkArr) |&gt; emplace_new &lt;| whileExpr</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">else</span><span style="color: #d4d4d4;"> { }</span></div><br><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> fnArguments : </span><span style="color: #c586c0;">array</span><span style="color: #d4d4d4;">&lt;VariablePtr&gt;;</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> fn &lt;- qmacro_function(uniqueName) &lt;| </span><span style="color: #569cd6;">$</span><span style="color: #d4d4d4;"> ($a(fnArguments))</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">unsafe</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; $b(blkArr[</span><span style="color: #569cd6;">0</span><span style="color: #d4d4d4;">])</span></div><div><span style="color: #d4d4d4;">&#160; &#160; defer_delete(fn)</span></div><br><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> args:</span><span style="color: #c586c0;">array</span><span style="color: #d4d4d4;">&lt; </span><span style="color: #4ec9b0;">tuple</span><span style="color: #d4d4d4;">&lt;argname:</span><span style="color: #4ec9b0;">string</span><span style="color: #d4d4d4;">;argvalue:RttiValue&gt; &gt;</span></div><div><span style="color: #d4d4d4;">&#160; &#160; fn |&gt; append_annotation(</span><span style="color: #ce9178;">"$"</span><span style="color: #d4d4d4;">, </span><span style="color: #ce9178;">"unsafe_deref"</span><span style="color: #d4d4d4;">, args)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #6a9955;">//print(describe(fn))</span></div><div><span style="color: #d4d4d4;">&#160; &#160; compiling_module() |&gt; add_function(fn)</span></div><br><div><span style="color: #d4d4d4;">[</span><span style="color: #569cd6;">reader_macro</span><span style="color: #d4d4d4;">(name=</span><span style="color: #ce9178;">"bf"</span><span style="color: #d4d4d4;">)]</span></div><div><span style="color: #569cd6;">class</span><span style="color: #d4d4d4;"> private </span><span style="color: #4ec9b0;">BrainfuckReader</span><span style="color: #d4d4d4;"> : </span><span style="color: #4ec9b0;">AstReaderMacro</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #569cd6;">def override</span><span style="color: #d4d4d4;"> </span><span style="color: #dcdcaa;">accept</span><span style="color: #d4d4d4;">( </span><span style="color: #9cdcfe;">prog</span><span style="color: #d4d4d4;">:ProgramPtr; </span><span style="color: #9cdcfe;">mod</span><span style="color: #d4d4d4;">:Module?; </span><span style="color: #569cd6;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">expr</span><span style="color: #d4d4d4;">:ExprReader?; </span><span style="color: #9cdcfe;">ch</span><span style="color: #d4d4d4;">:</span><span style="color: #4ec9b0;">int</span><span style="color: #d4d4d4;">; </span><span style="color: #9cdcfe;">info</span><span style="color: #d4d4d4;">:LineInfo) : </span><span style="color: #4ec9b0;">bool</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; append(expr.sequence, ch)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">if</span><span style="color: #d4d4d4;"> ends_with(expr.sequence,</span><span style="color: #ce9178;">"%%"</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">let</span><span style="color: #d4d4d4;"> len = </span><span style="color: #dcdcaa;">length</span><span style="color: #d4d4d4;">(expr.sequence)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; </span><span style="color: #dcdcaa;">resize</span><span style="color: #d4d4d4;">(expr.sequence,len-</span><span style="color: #b5cea8;">2</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">return</span><span style="color: #d4d4d4;"> </span><span style="color: #c586c0;">false</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">else</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">return</span><span style="color: #d4d4d4;"> </span><span style="color: #c586c0;">true</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #569cd6;">def override</span><span style="color: #d4d4d4;"> </span><span style="color: #dcdcaa;">visit</span><span style="color: #d4d4d4;">( </span><span style="color: #9cdcfe;">prog</span><span style="color: #d4d4d4;">:ProgramPtr; </span><span style="color: #9cdcfe;">mod</span><span style="color: #d4d4d4;">:Module?; </span><span style="color: #9cdcfe;">expr</span><span style="color: #d4d4d4;">:</span><span style="color: #c586c0;">smart_ptr</span><span style="color: #d4d4d4;">&lt;ExprReader&gt;) : ExpressionPtr</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">let</span><span style="color: #d4d4d4;"> str &lt;- make_unique_private_name(</span><span style="color: #ce9178;">"bf`exec"</span><span style="color: #d4d4d4;">, expr.at)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; generateFunction(str, expr.sequence)</span></div><br><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> ftype &lt;- </span><span style="color: #c586c0;">new</span><span style="color: #d4d4d4;"> [[TypeDecl() at=expr.at, baseType=Type tFunction ]]</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; ftype.firstType &lt;- </span><span style="color: #c586c0;">new</span><span style="color: #d4d4d4;"> [[TypeDecl() at=expr.at, baseType=Type tVoid]]</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> funcPtr &lt;- </span><span style="color: #c586c0;">new</span><span style="color: #d4d4d4;"> [[ExprAddr() at=expr.at, target:=str, funcType &lt;- ftype]]</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">return</span><span style="color: #d4d4d4;"> funcPtr</span></div></div>
<p>Тогда вызвать такой макрос можно так:</p>
<div style="color: #d4d4d4;background-color: #1e1e1e;font-family: Consolas, 'Courier New', monospace;font-weight: normal;font-size: 14px;line-height: 19px;white-space: pre;"><div><span style="color: #c586c0;">require</span><span style="color: #d4d4d4;"> brainfuck_macro</span></div><div><span style="color: #6a9955;">//генерируем функцию</span></div><div><span style="color: #c586c0;">let</span><span style="color: #d4d4d4;"> func = %bf~++++++++[</span><span style="color: #569cd6;">&gt;++++[&gt;++&gt;+++&gt;+++&gt;+&lt;&lt;&lt;&lt;-</span><span style="color: #d4d4d4;">]&gt;+&gt;+&gt;-&gt;&gt;+[</span><span style="color: #569cd6;">&lt;</span><span style="color: #d4d4d4;">]&lt;-]&gt;&gt;.&gt;---.+++++++..+++.&gt;&gt;.&lt;-.&lt;.+++.------.--------.&gt;&gt;+.&gt;++.%%</span></div><div><span style="color: #6a9955;">//вызываем сгенерированную функцию</span></div><div><span style="color: #dcdcaa;">invoke</span><span style="color: #d4d4d4;">(func)</span></div></div>
<p>Если раскомментировать строчку <code>print(describe(fn))</code> можно посмотреть на сгенерированное тело функции.</p>
<p>Например:</p>
<div style="color: #d4d4d4;background-color: #1e1e1e;font-family: Consolas, 'Courier New', monospace;font-weight: normal;font-size: 14px;line-height: 19px;white-space: pre;"><div><span style="color: #c586c0;">let</span><span style="color: #d4d4d4;"> func = %bf~[</span><span style="color: #569cd6;">-&gt;+&lt;</span><span style="color: #d4d4d4;">]%%</span></div><div><span style="color: #6a9955;">//сгенерированный код</span></div><br><div><span style="color: #d4d4d4;">[</span><span style="color: #569cd6;">unsafe_deref</span><span style="color: #d4d4d4;">]</span></div><div><span style="color: #c586c0;">def</span><span style="color: #d4d4d4;"> </span><span style="color: #c586c0;">public</span><span style="color: #d4d4d4;"> bf`exec_0xd_0xc</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">unsafe</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> tape:</span><span style="color: #c586c0;">array</span><span style="color: #d4d4d4;">&lt;</span><span style="color: #4ec9b0;">uint8</span><span style="color: #d4d4d4;">&gt; -</span><span style="color: #c586c0;">const</span><span style="color: #d4d4d4;"> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;</span><span style="color: #6a9955;">//declare variables</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> tapePos:</span><span style="color: #4ec9b0;">int</span><span style="color: #d4d4d4;"> -</span><span style="color: #c586c0;">const</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #dcdcaa;">resize</span><span style="color: #d4d4d4;">(tape,</span><span style="color: #b5cea8;">1000000</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> ptape:</span><span style="color: #4ec9b0;">auto</span><span style="color: #d4d4d4;"> -</span><span style="color: #c586c0;">const</span><span style="color: #d4d4d4;"> = </span><span style="color: #c586c0;">addr</span><span style="color: #d4d4d4;">(tape[</span><span style="color: #569cd6;">0</span><span style="color: #d4d4d4;">])</span></div><br><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">while</span><span style="color: #d4d4d4;"> ptape[</span><span style="color: #569cd6;">tapePos</span><span style="color: #d4d4d4;">] != uint8(</span><span style="color: #b5cea8;">0</span><span style="color: #d4d4d4;">) &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;</span><span style="color: #6a9955;">//[</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; ptape[</span><span style="color: #569cd6;">tapePos</span><span style="color: #d4d4d4;">] = uint8(int(ptape[</span><span style="color: #569cd6;">tapePos</span><span style="color: #d4d4d4;">]) - </span><span style="color: #b5cea8;">1</span><span style="color: #d4d4d4;">) &#160; </span><span style="color: #6a9955;">//-</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; ++tapePos &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; </span><span style="color: #6a9955;">//&gt;</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; ptape[</span><span style="color: #569cd6;">tapePos</span><span style="color: #d4d4d4;">] = uint8(int(ptape[</span><span style="color: #569cd6;">tapePos</span><span style="color: #d4d4d4;">]) + </span><span style="color: #b5cea8;">1</span><span style="color: #d4d4d4;">) &#160; </span><span style="color: #6a9955;">//+</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; --tapePos &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; </span><span style="color: #6a9955;">//&lt;]</span></div><div><span style="color: #c586c0;">let</span><span style="color: #d4d4d4;"> func = @@bf`exec_0xd_0xc </span><span style="color: #6a9955;">//указатель на функцию</span></div></div>
<p>Для каждой функции генерируется уникальное имя, чтобы можно было создать несколько отдельных интерпретатов, и своя “лента” памяти. В дальнейшем, каждый отдельный символ brainfuck компилируется в одну или несколько ast-нод daScript, который затем могут быть просимулированы.</p>
<p>(Раздел <code>daScript</code> про симуляцию и устройство виртуальной машины daScript)<br><a href="/blog/2115627465/" title="Устройство интерпретаторов lua-jit и daScript">Устройство интерпретаторов lua-jit и daScript</a> </p>
<p>(Генерация кода с помощью <a href="https://dascript.org/doc/reference/language/reification.html" target="_blank" rel="noopener">реификации выражений</a>)<br><a href="/blog/4046309382/" title="daScript macro - 2">daScript macro - 2</a></p>
<p>Если говорить о терминологии, то brainfuck можно рассматривать как <code>предметно-ориентированный язык (DSL)</code>. Переменные состояния tape и tapePos вместе составляют <code>семантическую модель</code> этого языка, которая настраивается с помощью DSL, а затем транслируется в синтаксическое дерево на <code>daScript</code> (в терминах Мартина Фаулера из книги “Предметно-ориентированные языки программирования”).</p>
<p>Время выполнения такой скомпилированной функции <strong>в режиме интерпретации</strong>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">e:\src\daScript_my\bin\Release&gt;daScript.exe brainfuck.das</span><br><span class="line">[I] total 29.28014399999999995 sec</span><br></pre></td></tr></table></figure>
<p>Это немного медленнее скомпилированной JiT-версии, но уже быстрее AoT версии интерпретатора.</p>
<h2 id="Macro-JiT"><a href="#Macro-JiT" class="headerlink" title="Macro + JiT"></a>Macro + JiT</h2><p>Дальше будет интереснее. Наша скомпилированная версия функции представляет собой по сути развёрнутую трассированную версию исполнения кода (и занимающую больше памяти). Попробуем применить к ней макрос [jit]:</p>
<div style="color: #d4d4d4;background-color: #1e1e1e;font-family: Consolas, 'Courier New', monospace;font-weight: normal;font-size: 14px;line-height: 19px;white-space: pre;"><div><span style="color: #d4d4d4;">fn |&gt; append_annotation(</span><span style="color: #ce9178;">"$"</span><span style="color: #d4d4d4;">, </span><span style="color: #ce9178;">"unsafe_deref"</span><span style="color: #d4d4d4;">, args)</span></div><div><span style="color: #d4d4d4;">fn |&gt; append_annotation(</span><span style="color: #ce9178;">"$"</span><span style="color: #d4d4d4;">, </span><span style="color: #ce9178;">"jit"</span><span style="color: #d4d4d4;">, args)</span></div></div>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">e:\src\daScript_my\bin\Release&gt;daScript.exe brainfuck.das</span><br><span class="line">[I] total 0.85775599999999996 sec</span><br></pre></td></tr></table></figure>
<p>0.85 секунды! (плюс около секунды на само время компиляции функции). llvm jit умеет сворачивать идущие подряд повторяющиеся операторы инкремента и декремента, за счёт чего получилось ускорение в 30 раз (и соотвествующее уменьшение размера функции).</p>
<p>Для сравнения — compile-time версия на nim работает ~3 секунды и тратит ~20 секунд на компиляцию (nim работает медленно в compile-time режиме).</p>
<h2 id="Оптимизации-Brainfuck-gt-daScript-AST"><a href="#Оптимизации-Brainfuck-gt-daScript-AST" class="headerlink" title="Оптимизации Brainfuck -&gt; daScript AST"></a>Оптимизации Brainfuck -&gt; daScript AST</h2><p>Получается интересная цепочка преобразования кода:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bf --&gt; (bf macro) --&gt; dascript ast --&gt; (dascript simulate - unsafe deref macro + optimizations) --&gt; dascript ast optimized --&gt; (llvm macro) --&gt; llvm native optimized code --&gt; (execute)</span><br></pre></td></tr></table></figure>
<p>На каждом из шагов происходят серьёзные трансформации кода, которые могут включать оптимизации. Можно рассмотреть оптимизации в обратном порядке:</p>
<ul>
<li>llvm — бекэнд генерации кода оптимизирует байт-код, на этом этапе заметен эффект от сворачивания идущих подряд операций</li>
<li>dascript simulate — при симуляции ast-дерева выбираются оптимизированные частные версии нод, мелкие ноды могут “сплавляться” в более крупные, применяются кастомные макросы, трансформирующие дерево по различным правилам</li>
<li>bf macro — на данном уровне производится трансляция команд brainfuck в ноды dascript, пока без оптимизаций</li>
</ul>
<p>Оптимизации на стадиях трансформаций llvm были сделаны библиотекой из “комплекта” языка, на стадиях преобразования daScript — как встроенными в язык оптимизациями, так и добавленными для своего кода вручную. Можно теперь попробовать добавить пару оптимизаций на “стороне DSL”, т.е. в макрос трансформации <code>brainfuck-&gt;daScript</code>.</p>
<p>На данном этапе первую тупую и наивную реализацию уже получилось разогнать где-то в 20000 раз, и это отличный повод разогнать ещё немного :)</p>
<p>Можно выбрать несколько простых паттернов brainfuck кода и попробовать распознавать их и генерить более оптимальный код для этих частных случаев:</p>
<ul>
<li>цепочка повторяющихся операций. Например, “+++++” можно интерпретировать не как 5 отдельных инкрементов, а как одну операцию увеличения на 5. Эту свёртку делает llvm для версии <code>Macro+JiT</code>, но если сделать её в своём макросе, то она также ускорит и обычный режим интерпретации</li>
<li>паттерн [-] можно интерпретировать как очистку ячейки памяти одной операцией</li>
<li>[-&gt;+&lt;] - чуть более сложный паттерн, который часто встречается в примерах на brainfuck, “сложение двух ячеек с очисткой исходной”, может быть интерпретирован как 2 команды вместо цикла</li>
<li>можно продолжать обнаруживать и добавлять всё более сложные паттерны</li>
</ul>
<p>(Приём с отслеживанием паттернов подходит, естественно, не только для brainfuck-кода, но и для любых DSL)</p>
<p>“Продвинутая” версия макроса, отслеживающая перечисленные паттерны</p>
<div style="color: #d4d4d4;background-color: #1e1e1e;font-family: Consolas, 'Courier New', monospace;font-weight: normal;font-size: 14px;line-height: 19px;white-space: pre;"><div><span style="color: #569cd6;">def</span><span style="color: #d4d4d4;"> </span><span style="color: #dcdcaa;">seachRepeats</span><span style="color: #d4d4d4;">(</span><span style="color: #9cdcfe;">symIt</span><span style="color: #d4d4d4;">; </span><span style="color: #569cd6;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">sym</span><span style="color: #d4d4d4;">:</span><span style="color: #4ec9b0;">int</span><span style="color: #d4d4d4;">&amp;; </span><span style="color: #9cdcfe;">symbolToCheck</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> count = </span><span style="color: #b5cea8;">1</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">while</span><span style="color: #d4d4d4;"> next(symIt, sym)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">if</span><span style="color: #d4d4d4;"> sym == symbolToCheck</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; ++count</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">else</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">return</span><span style="color: #d4d4d4;"> count</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">return</span><span style="color: #d4d4d4;"> count</span></div><br><div><span style="color: #569cd6;">def</span><span style="color: #d4d4d4;"> </span><span style="color: #dcdcaa;">match_reset</span><span style="color: #d4d4d4;">(</span><span style="color: #9cdcfe;">data</span><span style="color: #d4d4d4;">: </span><span style="color: #c586c0;">array</span><span style="color: #d4d4d4;">&lt;</span><span style="color: #4ec9b0;">int</span><span style="color: #d4d4d4;">&gt;)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">return</span><span style="color: #d4d4d4;"> </span><span style="color: #dcdcaa;">length</span><span style="color: #d4d4d4;">(data) == </span><span style="color: #b5cea8;">3</span><span style="color: #d4d4d4;"> &amp;&amp; data[</span><span style="color: #569cd6;">0</span><span style="color: #d4d4d4;">] == </span><span style="color: #ce9178;">'['</span><span style="color: #d4d4d4;"> &amp;&amp; data[</span><span style="color: #569cd6;">1</span><span style="color: #d4d4d4;">] == </span><span style="color: #ce9178;">'-'</span><span style="color: #d4d4d4;"> &amp;&amp; data[</span><span style="color: #569cd6;">2</span><span style="color: #d4d4d4;">] == </span><span style="color: #ce9178;">']'</span></div><br><div><span style="color: #569cd6;">def</span><span style="color: #d4d4d4;"> </span><span style="color: #dcdcaa;">match_add_right_reset</span><span style="color: #d4d4d4;">(</span><span style="color: #9cdcfe;">data</span><span style="color: #d4d4d4;">: </span><span style="color: #c586c0;">array</span><span style="color: #d4d4d4;">&lt;</span><span style="color: #4ec9b0;">int</span><span style="color: #d4d4d4;">&gt;)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">return</span><span style="color: #d4d4d4;"> </span><span style="color: #dcdcaa;">length</span><span style="color: #d4d4d4;">(data) == </span><span style="color: #b5cea8;">6</span><span style="color: #d4d4d4;"> &amp;&amp; data[</span><span style="color: #569cd6;">0</span><span style="color: #d4d4d4;">] == </span><span style="color: #ce9178;">'['</span><span style="color: #d4d4d4;"> &amp;&amp; data[</span><span style="color: #569cd6;">1</span><span style="color: #d4d4d4;">] == </span><span style="color: #ce9178;">'-'</span><span style="color: #d4d4d4;"> &amp;&amp; data[</span><span style="color: #569cd6;">2</span><span style="color: #d4d4d4;">] == </span><span style="color: #ce9178;">'&gt;'</span><span style="color: #d4d4d4;"> &amp;&amp; data[</span><span style="color: #569cd6;">3</span><span style="color: #d4d4d4;">] == </span><span style="color: #ce9178;">'+'</span><span style="color: #d4d4d4;"> &amp;&amp; data[</span><span style="color: #569cd6;">4</span><span style="color: #d4d4d4;">] == </span><span style="color: #ce9178;">'&lt;'</span><span style="color: #d4d4d4;"> &amp;&amp; data[</span><span style="color: #569cd6;">5</span><span style="color: #d4d4d4;">] == </span><span style="color: #ce9178;">']'</span></div><br><div><span style="color: #569cd6;">def</span><span style="color: #d4d4d4;"> </span><span style="color: #dcdcaa;">generateFunction</span><span style="color: #d4d4d4;">(uniqueName, </span><span style="color: #9cdcfe;">code</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">let</span><span style="color: #d4d4d4;"> seqStr = string(code)</span></div><br><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> blkArr : </span><span style="color: #c586c0;">array</span><span style="color: #d4d4d4;">&lt;</span><span style="color: #c586c0;">array</span><span style="color: #d4d4d4;">&lt;ExpressionPtr&gt;&gt;; defer_delete(blkArr)</span></div><br><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> blk : </span><span style="color: #c586c0;">array</span><span style="color: #d4d4d4;">&lt;ExpressionPtr&gt;; defer_delete(blk)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; blkArr |&gt; </span><span style="color: #dcdcaa;">emplace</span><span style="color: #d4d4d4;">(blk)</span></div><br><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> cyclePatternChecker:</span><span style="color: #c586c0;">array</span><span style="color: #d4d4d4;">&lt;</span><span style="color: #4ec9b0;">int</span><span style="color: #d4d4d4;">&gt;</span></div><br><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> initBlock &lt;- quote() &lt;|</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> tape: </span><span style="color: #c586c0;">array</span><span style="color: #d4d4d4;">&lt;</span><span style="color: #4ec9b0;">uint8</span><span style="color: #d4d4d4;">&gt;</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> tapePos : </span><span style="color: #4ec9b0;">int</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; tape |&gt; </span><span style="color: #dcdcaa;">resize</span><span style="color: #d4d4d4;">(</span><span style="color: #b5cea8;">1000000</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> ptape = </span><span style="color: #c586c0;">addr</span><span style="color: #d4d4d4;">(tape[</span><span style="color: #569cd6;">0</span><span style="color: #d4d4d4;">])</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #6a9955;">//blkArr[0] |&gt; emplace_new &lt;| initBlock</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">unsafe</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> _block &lt;- </span><span style="color: #c586c0;">reinterpret</span><span style="color: #d4d4d4;">&lt;</span><span style="color: #c586c0;">smart_ptr</span><span style="color: #d4d4d4;">&lt;ExprBlock&gt;&gt;(</span><span style="color: #c586c0;">reinterpret</span><span style="color: #d4d4d4;">&lt;</span><span style="color: #c586c0;">smart_ptr</span><span style="color: #d4d4d4;">&lt;ExprMakeBlock&gt;&gt; initBlock)._block</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">for</span><span style="color: #d4d4d4;"> blockItem </span><span style="color: #c586c0;">in</span><span style="color: #d4d4d4;"> _block.list</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; blkArr[</span><span style="color: #569cd6;">0</span><span style="color: #d4d4d4;">] |&gt; emplace_new &lt;| blockItem</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> symIt &lt;- </span><span style="color: #c586c0;">unsafe</span><span style="color: #d4d4d4;">(each(seqStr))</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> sym : </span><span style="color: #4ec9b0;">int</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> repeat = </span><span style="color: #c586c0;">false</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> count : </span><span style="color: #4ec9b0;">int</span><span style="color: #d4d4d4;"> = </span><span style="color: #b5cea8;">1</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">while</span><span style="color: #d4d4d4;"> repeat || next(symIt, sym)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; repeat = </span><span style="color: #c586c0;">false</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">if</span><span style="color: #d4d4d4;"> sym == </span><span style="color: #ce9178;">'+'</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; cyclePatternChecker |&gt; </span><span style="color: #dcdcaa;">push</span><span style="color: #d4d4d4;">(sym)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; repeat = </span><span style="color: #c586c0;">true</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; count = seachRepeats(symIt, sym, </span><span style="color: #ce9178;">'+'</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( ${ ptape[</span><span style="color: #569cd6;">tapePos</span><span style="color: #d4d4d4;">] = uint8(int(ptape[</span><span style="color: #569cd6;">tapePos</span><span style="color: #d4d4d4;">]) + $v(count)); })</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">elif</span><span style="color: #d4d4d4;"> sym == </span><span style="color: #ce9178;">'-'</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; cyclePatternChecker |&gt; </span><span style="color: #dcdcaa;">push</span><span style="color: #d4d4d4;">(sym)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; repeat = </span><span style="color: #c586c0;">true</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; count = seachRepeats(symIt, sym, </span><span style="color: #ce9178;">'-'</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( ${ ptape[</span><span style="color: #569cd6;">tapePos</span><span style="color: #d4d4d4;">] = uint8(int(ptape[</span><span style="color: #569cd6;">tapePos</span><span style="color: #d4d4d4;">]) - $v(count)); })</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">elif</span><span style="color: #d4d4d4;"> sym == </span><span style="color: #ce9178;">'&gt;'</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; cyclePatternChecker |&gt; </span><span style="color: #dcdcaa;">push</span><span style="color: #d4d4d4;">(sym)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; repeat = </span><span style="color: #c586c0;">true</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; count = seachRepeats(symIt, sym, </span><span style="color: #ce9178;">'&gt;'</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( ${ tapePos += &#160;$v(count); })</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">elif</span><span style="color: #d4d4d4;"> sym == </span><span style="color: #ce9178;">'&lt;'</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; cyclePatternChecker |&gt; </span><span style="color: #dcdcaa;">push</span><span style="color: #d4d4d4;">(sym)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; repeat = </span><span style="color: #c586c0;">true</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; count = seachRepeats(symIt, sym, </span><span style="color: #ce9178;">'&lt;'</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( ${ tapePos -= $v(count); })</span></div><br><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">elif</span><span style="color: #d4d4d4;"> sym == </span><span style="color: #ce9178;">'.'</span><span style="color: #d4d4d4;"> { back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( ${ </span><span style="color: #dcdcaa;">print</span><span style="color: #d4d4d4;">(int(ptape[</span><span style="color: #569cd6;">tapePos</span><span style="color: #d4d4d4;">]) |&gt; to_char); }); }</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">elif</span><span style="color: #d4d4d4;"> sym == </span><span style="color: #ce9178;">','</span><span style="color: #d4d4d4;"> { back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( ${ ptape[</span><span style="color: #569cd6;">tapePos</span><span style="color: #d4d4d4;">] = uint8(getchar()); }); }</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">elif</span><span style="color: #d4d4d4;"> sym == </span><span style="color: #ce9178;">'['</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; cyclePatternChecker |&gt; </span><span style="color: #dcdcaa;">clear</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; cyclePatternChecker |&gt; </span><span style="color: #dcdcaa;">push</span><span style="color: #d4d4d4;">(sym)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> blk1 : </span><span style="color: #c586c0;">array</span><span style="color: #d4d4d4;">&lt;ExpressionPtr&gt;; defer_delete(blk1)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; blkArr |&gt; </span><span style="color: #dcdcaa;">emplace</span><span style="color: #d4d4d4;">(blk1)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">elif</span><span style="color: #d4d4d4;"> sym == </span><span style="color: #ce9178;">']'</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; cyclePatternChecker |&gt; </span><span style="color: #dcdcaa;">push</span><span style="color: #d4d4d4;">(sym)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">if</span><span style="color: #d4d4d4;"> match_reset(cyclePatternChecker)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; </span><span style="color: #6a9955;">//match [-]</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; blkArr |&gt; pop()</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( ${ ptape[</span><span style="color: #569cd6;">tapePos</span><span style="color: #d4d4d4;">] = uint8(</span><span style="color: #b5cea8;">0</span><span style="color: #d4d4d4;">); })</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">elif</span><span style="color: #d4d4d4;"> match_add_right_reset(cyclePatternChecker)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; </span><span style="color: #6a9955;">//match [-&gt;+&lt;]</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; blkArr |&gt; pop()</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( ${ ptape[</span><span style="color: #569cd6;">tapePos+$v</span><span style="color: #d4d4d4;">(count)] = uint8(int(ptape[</span><span style="color: #569cd6;">tapePos+$v</span><span style="color: #d4d4d4;">(count)]) + int(ptape[</span><span style="color: #569cd6;">tapePos</span><span style="color: #d4d4d4;">])); })</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( ${ ptape[</span><span style="color: #569cd6;">tapePos</span><span style="color: #d4d4d4;">] = uint8(</span><span style="color: #b5cea8;">0</span><span style="color: #d4d4d4;">); })</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">else</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; </span><span style="color: #6a9955;">//usual cycle</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> last &lt;- back(blkArr)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; blkArr |&gt; pop()</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> whileExpr &lt;- qmacro_expr &lt;|</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">while</span><span style="color: #d4d4d4;"> ptape[</span><span style="color: #569cd6;">tapePos</span><span style="color: #d4d4d4;">] != uint8(</span><span style="color: #b5cea8;">0</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; $b(last)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; back(blkArr) |&gt; emplace_new &lt;| whileExpr</span></div><br><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; cyclePatternChecker |&gt; </span><span style="color: #dcdcaa;">clear</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">else</span><span style="color: #d4d4d4;"> { }</span></div><br><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> fnArguments : </span><span style="color: #c586c0;">array</span><span style="color: #d4d4d4;">&lt;VariablePtr&gt;;</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> fn &lt;- qmacro_function(uniqueName) &lt;| </span><span style="color: #569cd6;">$</span><span style="color: #d4d4d4;"> ($a(fnArguments))</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">unsafe</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; $b(blkArr[</span><span style="color: #569cd6;">0</span><span style="color: #d4d4d4;">])</span></div><div><span style="color: #d4d4d4;">&#160; &#160; defer_delete(fn)</span></div><br><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> args:</span><span style="color: #c586c0;">array</span><span style="color: #d4d4d4;">&lt; </span><span style="color: #4ec9b0;">tuple</span><span style="color: #d4d4d4;">&lt;argname:</span><span style="color: #4ec9b0;">string</span><span style="color: #d4d4d4;">;argvalue:RttiValue&gt; &gt;</span></div><div><span style="color: #d4d4d4;">&#160; &#160; fn |&gt; append_annotation(</span><span style="color: #ce9178;">"$"</span><span style="color: #d4d4d4;">, </span><span style="color: #ce9178;">"jit"</span><span style="color: #d4d4d4;">, args)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; fn |&gt; append_annotation(</span><span style="color: #ce9178;">"$"</span><span style="color: #d4d4d4;">, </span><span style="color: #ce9178;">"unsafe_deref"</span><span style="color: #d4d4d4;">, args)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #6a9955;">//print(describe(fn))</span></div><div><span style="color: #d4d4d4;">&#160; &#160; compiling_module() |&gt; add_function(fn)</span></div></div>
<p>Результат:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">e:\src\daScript_my\bin\Release&gt;daScript.exe brainfuck.das</span><br><span class="line">[I] total 0.70142899999999999 sec</span><br></pre></td></tr></table></figure>
<p>Еще на 17% быстрее<br><em>Из замеров явно стоило бы еще вынести print</em></p>
<h2 id="Немного-выводов"><a href="#Немного-выводов" class="headerlink" title="Немного выводов"></a>Немного выводов</h2><ul>
<li>Основа оптимизации — написание грамотного кода на основном языке.</li>
<li>Техники JiT-компиляции (особенно в сочетании с кодогенерацией или замерами hot участков) могут давать крутые результаты, в том числе превосходящие статическую компиляцию</li>
<li>Организация цепочки преобразований кода в одной среде НАМНОГО удобнее, чем в разных (какой-нибудь вариант “кодоген на python” + макросы/шаблоны + код на C++” - мрак с отладкой). Особенно для более длинных цепочек.</li>
<li>Нормальные макросы = нормальная отладка и скорость компиляции DSL.</li>
</ul>
<p><a href="https://github.com/spiiin/dascript_brainfuck" target="_blank" rel="noopener">Код примеров</a></p>
<p><em>update от 14.01.2023</em><br><em><a href="https://tratt.net/laurie/blog/2023/compiled_and_interpreted_languages_two_ways_of_saying_tomato.html" target="_blank" rel="noopener">Compiled and Interpreted Languages: Two Ways of Saying Tomato</a> - похожие замеры на rust</em></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script></div></article><div class="pagination"><a class="pagination__link pagination__prev" href="/blog/1976052536/">Позже</a><a class="pagination__link pagination__next" href="/blog/1601029690/">Раньше</a></div></main><footer class="footer metadata"><p class="footer__text">© 2024 spiiin</p><p class="footer__text">Powered by <a class="footer__text__link" href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a class="footer__text__link" href="https://pages.github.com/" target="_blank">Github Page</a></p></footer></div></body></html>