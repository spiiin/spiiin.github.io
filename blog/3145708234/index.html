<!DOCTYPE html><html lang="ru"><head><meta charset="UTF-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Spiiin's blog | Push/Pull/Event model, Reactive GUI</title><meta name="description" content=""><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=PT+Serif&amp;display=swap"><link rel="stylesheet" href="/css/highlights/darkula.css"><link rel="stylesheet" href="/css/main.css"><link rel="search" type="application/opensearchdescription+xml" href="http://spiiin.github.io/atom.xml" title="Spiiin's blog"><script>(function (i, s, o, g, r, a, m) {
  i['GoogleAnalyticsObject'] = r;
  i[r] = i[r] || function () {
    (i[r].q = i[r].q || []).push(arguments)
  }, i[r].l = 1 * new Date();
  a = s.createElement(o),
    m = s.getElementsByTagName(o)[0];
  a.async = 1;
  a.src = g;
  m.parentNode.insertBefore(a, m)
})(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');
ga('create', 'UA-00000000-0', 'auto');
ga('send', 'pageview');</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Spiiin's blog" type="application/atom+xml">
</head><body><div class="container"><header class="main-header"><h1 class="main-header__title uplize"><a class="main-header__title__link" href="/"><img class="header-image" src="/images/favicon.png" width="36" height="36">Spiiin's blog</a></h1><nav class="main-header__nav"><ul class="main-nav"><li class="main-nav__list"><a class="main-nav__list__link" href="/" target="_self">HOME</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/archives/" target="_self">ARCHIVE</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/tags/meta" target="_self">TAGS</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/blog/1" target="_self">ABOUT</a></li></ul></nav></header><main class="container__wrapper"><div class="pagination"><a class="pagination__link pagination__next" href="/blog/1364570417/">Раньше</a></div><article class="article post"><h3 class="article__title">Push/Pull/Event model, Reactive GUI</h3><div class="article__date metadata"><div class="post-info">2024/03/23</div></div><div class="article__tags metadata">Tags:
<a class="article__tags__link metadata" href="/tags/cpp/">cpp</a><a class="article__tags__link metadata" href="/tags/dev-method/">dev_method</a><a class="article__tags__link metadata" href="/tags/gamedev/">gamedev</a><a class="article__tags__link metadata" href="/tags/dev/">dev</a></div><div class="article__body"><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><h1 id="Push-Pull-Events-модели"><a href="#Push-Pull-Events-модели" class="headerlink" title="Push/Pull/Events модели"></a>Push/Pull/Events модели</h1><p>Регулярно повторяющаяся задача проектирования — выбор способа взаимодействия вызывающего и вызываемого кода.</p>
<p><strong><code>Pull-модель</code></strong> — “вам надо, вы и мучаетесь”. Часто реализовывается проще. Вызывающий код в том месте, в котором удобно, запрашивает данные.</p>
<p>Примеры<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">считывание настроек в стиле &#96;game::get_setting&lt;string&gt;(&quot;blabla&quot;)&#96;</span><br><span class="line">считывание 3D модели через render::load3dmodel(&quot;balbalb.xxx&quot;)</span><br><span class="line">опрос сервера клиентом для получения новых сообщений или обновлений</span><br><span class="line">игровой цикл, где игровой движок &quot;запрашивает&quot; состояние игрока или ввод данных в начале каждого кадра</span><br></pre></td></tr></table></figure><br>Все загрузки, всё определение конфигурации и т.п. - размазано по коду и делается ad hoc.  </p>
<p><strong><code>Push-модель</code></strong> — “то же самое, но вывернутое наизнанку”. Вам приходит callback/event/change propagation “blabla setting changed old-&gt;new”. В системе жёстко вшито, когда именно происходит событие, и имеется возможность добавить свою реакцию на него.</p>
<p>Примеры<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">системы реального времени, где сенсоры отправляют данные на сервер или обработчик событий немедленно, как только они доступны</span><br><span class="line">системы уведомлений, где сервер пушит уведомления на устройства клиентов без необходимости запроса со стороны клиента</span><br></pre></td></tr></table></figure></p>
<p>Все загрузки, конфигурации, управление ресурсами - вынесено наружу, делается более-менее централизованно. Вы регистрируетесь где попало и реагируете на обновления. Зато система без вас знает, когда, как и что делать.</p>
<p>Место определения колбека отделено от момента его вызова, вызывающий код должен понимать контекст, в котором будет вызван колбек — необходимо ли проверять на существование необходимые колбеку ресурсы, доступны ли они или заняты, безопасно ли создавать или удалять какие-либо типы объектов. Один из самых примитивных примеров — инвалидация итератора stl-контейнера в цикле в c++.</p>
<p><strong><code>Events-модель</code></strong></p>
<p>В push-моделях можно встретить элементы pull-модели:</p>
<ul>
<li>если объём данных для push большой и может быть не нужен клиентам полностью или сразу, система может только уведомить об изменившихся данных (послать сообщение) и предоставить pull-интерфейс для запроса этих данных, когда будет удобно клиенту</li>
<li>если удобно отложить обработку данных, коллбек может вместо выполнения работы положить сообщение в очередь. Дальше на клиента ложиться задача спуллить сообщения из очереди и обработать их. Удобно, если необходимо обработать все сообщения вместе. </li>
</ul>
<p>Примеры<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">отложенная обработка сгенерированных команд для подсистемы рендера</span><br><span class="line">отложенная обработка сообщений о столкновениях, чтобы проверить, что суммарные силы воздействии на физический объект не разрушат его</span><br></pre></td></tr></table></figure></p>
<p><a href="http://www.kegel.com/c10k.html" target="_blank" rel="noopener">The C10K problem</a> — взаимодействие большого количества сообщений в ОС.<br><a href="https://bitsquid.blogspot.com/2011/02/managing-decoupling-part-2-polling.html" target="_blank" rel="noopener">Managing Coupling Part 2 — Polling, Callbacks and Events</a> — о push/pull/events модели от дизайнеров движка Stingray</p>
<h2 id="Паттерны-идиомы-узоры"><a href="#Паттерны-идиомы-узоры" class="headerlink" title="Паттерны/идиомы/узоры"></a>Паттерны/идиомы/узоры</h2><p>В различных языках или библиотеках идеи и модели могут быть:<br><strong><code>прозрачные для пользователя</code></strong> — доступны в виде примитивов языка<br><strong><code>выражаемые формально</code></strong> — для использования можно переопределить функцию для своего типа/отнаследоваться от языка/написать синтаксический макрос/воспользоваться принятым в языке способом<br><strong><code>выражаемые неформально</code></strong> — для использования необходимо каждый раз повторно реализовывать функционал</p>
<p>Когда-то паттернами считались процедуры (1957, <a href="https://www.norvig.com/design-patterns/design-patterns.pdf" target="_blank" rel="noopener">Design Patterns in Dynamic Programming</a>) и классы (1972, <a href="https://blog.plover.com/prog/design-patterns.html" target="_blank" rel="noopener">Design patterns of 1972</a>). Прозрачные для пользователя  практически не обсуждаются (или даже не называются!), формально выраженные также часто принимаются как правило хорошего программирования. Разве что когда кому-нибудь не нравится производительность или ограничения в интерфейсе. В этом случае даже прозрачные идиомы могут быть реифицированны и переделаны. Пример — <a href="/blog/1552834708/" title="Runtime-полиморфизм в C++">Runtime-полиморфизм в C++</a>, альтернативный полиморфизм.</p>
<p>Может показаться, что называть что-то очень простое и примитивное паттерном слишком сёрьзно, но это всего лишь ярлыки.</p>
<p><a href="https://probablydance.com/2015/06/16/ideas-for-a-programming-language-part-4-reactive-programming/" target="_blank" rel="noopener">Ideas for a Programming Language Part 4: Reactive Programming</a> — про поиск синтаксиса для того, чтобы ввернуть асинхронное программирование в язык прозрачно для пользователя</p>
<h2 id="Итераторы-колстеки-корутины-файберы-диспетчеры-асинки-—-revisited"><a href="#Итераторы-колстеки-корутины-файберы-диспетчеры-асинки-—-revisited" class="headerlink" title="Итераторы, колстеки, корутины, файберы, диспетчеры, асинки — revisited"></a>Итераторы, колстеки, корутины, файберы, диспетчеры, асинки — revisited</h2><ul>
<li><a href="/blog/2550823652/" title="Итераторы, колстеки, корутины">Итераторы, колстеки, корутины</a></li>
<li><a href="/blog/2826376146/" title="Файберы, диспетчеры, асинки">Файберы, диспетчеры, асинки</a>
</li>
</ul>
<p>Две большие статьи выше посвящены, по большому счёту, паттернам работы с коллекциями в различных языках (где-то эти “паттерны” уже вшиты в примитивы языка, где-то их нет и в стандартной библиотеке и приходилось писать самому).</p>
<p>Всё описанное в статьях можно классифицировать по 4 группам:<br><strong><code>операции с pull-итераторами в синхронных коллекциях</code></strong><br><strong><code>операции с push-итераторами в синхронных коллекциях</code></strong><br><strong><code>операции с pull-итераторами в асинхронных коллекциях</code></strong><br><strong><code>операции с push-итераторами в асинхронных коллекциях</code></strong></p>
<p>pull-итераторы — c++ stl-итераторы, <a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.ienumerator-1?view=net-8.0" target="_blank" rel="noopener">IEnumerator<T></a> C#<br>push-итераторы — колбеки<br>синхронные коллекции — контейнеры<br>асинхронные коллекции — генераторы (могут описывать как space-distributed коллекции, так и time-distributed)</p>
<p>Как и в общем для pull-моделей, pull-итераторы проще для использования/комбинирования — результаты, возвращаемый pull-итератором — стандартные типы языка, с которым учатся работать с самого начала знакомства с языком.</p>
<p>Push-итератор не возвращает ничего, и является отложенным вычислением (замыкания/указатели на функции/функциональные объекты). Отложенные вычисленя тоже можно комбинировать, но вместо привычных прикладному программисту на императивных языках способов требуются привычные математикам.</p>
<p><a href="https://aras-p.info/blog/2018/12/28/Modern-C-Lamentations/" target="_blank" rel="noopener">“Modern” C++ Lamentations</a> — про разницу в синтаксисе и времени компиляции между C++ и C# при работе с лямбдами.<br><a href="https://www.youtube.com/watch?v=6mTbuzafcII" target="_blank" rel="noopener">“Transducers” by Rich Hickey</a> — типичные проблемы комбинирования колбеков, как оторвать комбинирование вычислений от коллекций.</p>
<p>Даже просто запись цепочки выполняющихся друг за другом после окончания предыдущего колбеков превращается в анти-паттерн <code>callback hell</code> (синтаксический сахар async/await - количество скобок уменьшается)</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//.NET 4</span></span><br><span class="line">Task&lt;<span class="keyword">string</span>&gt; htmlTask = webClient.DownloadStringTaskAsync(url);</span><br><span class="line"><span class="comment">//тот можно выполнить код, которому не требуется результат hmtlTask</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">string</span> html = htmlTask.Result; <span class="comment">//тут блокировка до ожидания результата</span></span><br><span class="line"><span class="comment">//или прикрепить к задаче продолжение</span></span><br><span class="line">htmlTask.ContinueWith(task=&gt; &#123;</span><br><span class="line">  <span class="keyword">string</span> html = task.Result;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//.NET 5</span></span><br><span class="line">Task&lt;<span class="keyword">string</span>&gt; htmlTask = webClient.DownloadStringTaskAsync(url);</span><br><span class="line"><span class="keyword">string</span> html = <span class="keyword">await</span> htmlTask; <span class="comment">//то же что и в прошлом примере с ContinueWith</span></span><br><span class="line">doSomething(html)             <span class="comment">//строки ниже await также "переписываются" внутрь ContinueWith</span></span><br></pre></td></tr></table></figure>
<p>Паттерн <code>Task</code> (где-то встречается название <code>Future</code>) является обёрткой для асинхронной работы над примитивом. В статьях не хватает разбора способов асинхронной работы с коллекциями (синхронными и асинхронными).</p>
<h2 id="Обобщения-паттерна-Task-в-C"><a href="#Обобщения-паттерна-Task-в-C" class="headerlink" title="Обобщения паттерна Task в C"></a>Обобщения паттерна Task в C</h2><p><strong><code>pull-based работа синхронными коллекциями</code></strong> — если просто заменить <code>Task&lt;int&gt;</code> на <code>Task&lt;IEnumerable&lt;int&gt;&gt;</code>, то можно использовать <code>await</code> для коллекции, но при этом все элементы коллекции будут собираться синхронно за один вызов, в чём собственно нет особого смысла<br><strong><code>pull-based работа с асинхронными коллекциями</code></strong> — <a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.iasyncenumerable-1?view=net-8.0" target="_blank" rel="noopener"><code>IAsyncEnumerable&lt;T&gt;</code></a> и <code>await foreach</code> позволяет получать элементы коллекции асинхронно<br><strong><code>push-based работа с асинхронными коллекциями</code></strong> — push-вариант работы с асинхронными коллекциями — паттерн <code>Observer</code> (<a href="https://learn.microsoft.com/en-us/dotnet/api/system.iobserver-1?view=net-8.0" target="_blank" rel="noopener"><code>IObserver&lt;T&gt;</code></a> в C#). Если <code>Task</code> представляет собой одно асинхронное событие, то <code>Observable</code> — это асинхронная коллекция (источник) событий, на которые могут подписываться <code>Observer</code>-ы.</p>
<h2 id="Observable-Observer"><a href="#Observable-Observer" class="headerlink" title="Observable/Observer"></a>Observable/Observer</h2><p><code>Observer</code> — давно известный паттерн, популяризованный в GoF, и активно используемый в smalltalk-версии паттерна <code>MVC</code>.<br><a href="https://stlab.cc/tips/about-mvc.html" target="_blank" rel="noopener">How did MVC get so F’ed up?</a> — деградация MVC в языках с не-observable примитивами в качестве модели, мешает композиции.</p>
<p><code>Observable</code> в C# зовёт 3 метода <code>Observer</code> (<em>продолжение/окончание/ошибка</em>):<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OnCompleted() - последовательность закончилась</span><br><span class="line">OnError(exception) - при генерации данных произошла ошибка</span><br><span class="line">OnNext(value) - было сгенерированно следующее значение</span><br></pre></td></tr></table></figure></p>
<p><code>Observable</code> можно представить как обобщение примитивного обхода коллекции (синхронной или асинхронной). При этом, как и для примитивного foreach, так и любых более сложных реализаций, должно соблюдаться простое правило: OnCompleted/OnError — это последний колбек, после которого Observable не будет присылать других.</p>
<p>Паттерн сам по себе не защищен от возможностей кривой композиции, так что периодически появляются теоретические попытки сделать что-то более чистое (но не всегда более простое).<br><a href="https://core.ac.uk/download/pdf/147982753.pdf" target="_blank" rel="noopener">Deprecating the Observer Pattern with Scala.React</a> от Мартина Одерски, умершая либа. Вместо неё сейчас и сам Одерски <a href="https://stackoverflow.com/questions/21546456/what-happened-to-scala-react" target="_blank" rel="noopener">предлагает</a> JavaRx, надстроенную над observer-ами.</p>
<p><strong><code>Reactive-подход</code></strong><br>Observer имеет те же особенности композиции, что и push-итераторы — близкие математикам или функциональным программистам примитивы, в C# местами завёрнутые в linq-синтаксис.</p>
<p><a href="https://reactivex.io/" target="_blank" rel="noopener">ReactiveX</a> — библиотека реактивного программирования, набор примитивов для композиции и конвертеров между различными типами итераторов.<br><a href="https://kirkshoop.github.io/introductionToRxcpp" target="_blank" rel="noopener">Introduction to ReactiveX in C++ (rxcpp)</a> — презентация по С++ версии библиотеки, heavy templates-based.<br><a href="https://introtorx.com/chapters/foreword" target="_blank" rel="noopener">Introduction to RX.Net</a> — книга по C# версии.</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//kotlin example</span></span><br><span class="line">getDataFromNetwork()</span><br><span class="line">  .skip(<span class="number">10</span>)</span><br><span class="line">  .take(<span class="number">5</span>)</span><br><span class="line">  .map(&#123; s -&gt; <span class="keyword">return</span> s + <span class="string">" transformed"</span> &#125;)</span><br><span class="line">  .subscribe(&#123; println <span class="string">"onNext =&gt; "</span> + it &#125;)</span><br></pre></td></tr></table></figure>
<h1 id="GUI"><a href="#GUI" class="headerlink" title="GUI"></a>GUI</h1><p>Можно разделить GUI-библиотеки на <code>imperative/declarative</code> и <code>retained/immediate/reactive</code>.</p>
<h2 id="Imperative-Declarative"><a href="#Imperative-Declarative" class="headerlink" title="Imperative/Declarative"></a>Imperative/Declarative</h2><p><strong><code>Imperative</code></strong> — установка состояние контролов описывается в коде<br><strong><code>Declarative</code></strong> — установка состояния вынесена куда-нибудь в JSON/XML/HTML или в динамический язык (lua/squirrel — бестиповые таблицы + лямбды удобны для описания представления и кода) и загружается с помощью <code>control-&gt;loadFromFile</code>. Из преимуществ — gui можно менять без перекомпиляции, программиста и с помощью тулзы, которая позволяет менять состояние мышкой.</p>
<p><a href="https://habr.com/ru/articles/719908/" target="_blank" rel="noopener">WPF: контролы лишенные внешнего вида и неразрешимая задача выбора конфигурации темплейта</a> — более развернуто про то, что даёт декларативный подход<br><blockquote><p>Разработчики хотят, чтобы библиотека «угадала» их представление о том, как должен выглядеть и как должен работать тот или иной элемент визуального интерфейса. Соответственно, разработчики, как пользователи библиотеки, оказываются не готовы, что вместо того, чтобы искать готовые компоненты, надо научиться создавать их самому в парадигме того инструментария и тех концепций, которые реализованы в библиотеке.</p>
</blockquote></p>
<h2 id="Retained"><a href="#Retained" class="headerlink" title="Retained"></a>Retained</h2><p><strong><code>Retained</code></strong> — клиентский код не занимается рендером сам, а заполняет и обновляет модель. Push-модель, очень распространённая в GUI-библиотеках.</p>
<p>Пример, как может выглядеть код:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">&#125; state;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> window = GUI::createRootWindow();</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> label = GUI::createLabel(<span class="string">"Click counter %d"</span>, state.value);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> button = GUI::createButton();</span><br><span class="line">button-&gt;setText(<span class="string">"Increase counter"</span>);</span><br><span class="line">button-&gt;setClickCallback([]()&#123;</span><br><span class="line">    state.value++;</span><br><span class="line">    <span class="comment">//нужно не забыть руками обновить внутреннее состояние контрола, отображающего значение</span></span><br><span class="line">    label-&gt;updateText(<span class="string">"Click counter %d"</span>, state.value);</span><br><span class="line">&#125;);</span><br><span class="line">window-&gt;addChild(button);</span><br><span class="line"></span><br><span class="line"><span class="comment">//somewhere</span></span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">exit</span>) &#123;</span><br><span class="line">    GUI::updateRootWindow();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Минусы — код обновления состояния модели (всего, что вне GUI), нужно синхронизировать с состоянием GUI.</p>
<p>Примеры либ - <a href="https://github.com/cegui/cegui" target="_blank" rel="noopener">cegui</a></p>
<h2 id="Immediate"><a href="#Immediate" class="headerlink" title="Immediate"></a>Immediate</h2><p><strong><code>Immediate</code></strong> — Pull-подход (“вам надо, вы и рисуйте”), <a href="https://caseymuratori.com/blog_0001" target="_blank" rel="noopener">родившийся</a> в головах гейм-девелоперов. Если “вывернуть” наизнанку логику, и отдать обязанность рисования контролов клиенту, то логика местами станет проще (вместо угадывания потребностей клиента сложность переезжает в клиентский код, и отпадает необходимость синхронизации состояния). Функции рисования не имеют своего состояния, а принимают указатели на данные, которые они могут изменить.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> value;</span><br><span class="line">&#125; state;</span><br><span class="line"></span><br><span class="line">Gui::Begin(<span class="string">"My window"</span>);</span><br><span class="line">Gui::Text(<span class="string">"Counter %d"</span>, state.value);</span><br><span class="line"><span class="keyword">if</span> (Gui::Button(<span class="string">"Increate counter"</span>)) <span class="comment">//without explicit callback function</span></span><br><span class="line">    state.value++;</span><br><span class="line">Gui::End();</span><br></pre></td></tr></table></figure>
<p>Примеры либ — <code>Unity Imgui, Dear Imgui, Nuklear</code>.</p>
<h2 id="Reactive"><a href="#Reactive" class="headerlink" title="Reactive"></a>Reactive</h2><p>Если под рукой есть язык или библиотека, который может описать зависимости между данными, то можно было бы устранить недостаток retained gui без перехода к immediate.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    GUI::MagicObservable&lt;<span class="keyword">int</span>&gt; value; <span class="comment">//при изменении уведомлять всех наблюдателей</span></span><br><span class="line">&#125; state;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> window = GUI::createRootWindow();</span><br><span class="line"><span class="keyword">auto</span> label = GUI::createLabel(<span class="string">"Click counter %d"</span>, state.value);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> button = GUI::createButton();</span><br><span class="line">button-&gt;setText(<span class="string">"Increase counter"</span>);</span><br><span class="line">button-&gt;setClickCallback([]()&#123;</span><br><span class="line">    <span class="comment">//обновляем значение, observer уведомит об изменении все контролы. Прямого обновления label в коде больше нет</span></span><br><span class="line">    GUI::updateObservable(state.value); </span><br><span class="line">&#125;);</span><br><span class="line">window-&gt;addChild(button);</span><br></pre></td></tr></table></figure>
<p>Примеры либ — <code>knockout.js, rivets</code> для js, <a href="https://www.reactiveui.net/" target="_blank" rel="noopener">ReactiveUI</a> для C#,  <a href="https://github.com/tetsurom/rxqt" target="_blank" rel="noopener">rxqt</a> для C++.<br><a href="https://www.youtube.com/watch?v=_d65qS0GzWM" target="_blank" rel="noopener">MIX11 Knockout JS Helping you build dynamic JavaScript UIs with MVVM and ASP NET</a> — knockout.js demo<br><a href="https://knockoutjs.com/documentation/computed-dependency-tracking.html" target="_blank" rel="noopener">How dependency tracking works</a> — knockout.js how it works</p>
<p>Knockout.js использует тривиальный динамический метод ослеживания зависимостей.</p>
<ul>
<li>Когда объявляется observable, вычисляется его initial-значение.</li>
<li>В ходе вычисления, устанавливается подписка на любые другие observables (включая computed observables), значения которых читаются (язык должен поддерживать хук на чтение значений). Подписка означает, что будет вызвано вычисление этого observable (шаг 1), при этом любые старые подписки удаляются.</li>
<li>После завершения вычисления, вызываются все подписки о том, что новое значение этого observable доступно.<br>Так что зависимости не вычисляются при первом запуске и их не нужно объявлять, они просто перерасчитываются каждый раз при обновлении, и могут изменяться динамически. Если эвалуатор observable не читает ни одного другого observable, от которого он зависит, то повторное вычисление никогда не произойдёт, и сам эвалуатор может быть заменён на вычисленное значение.</li>
<li>Декларативные биндинги данных к состоянию контролов — это просто computed observables.</li>
</ul>
<p><a href="https://habr.com/ru/articles/303650/" target="_blank" rel="noopener">Введение в ReactiveUI: прокачиваем свойства во ViewModel</a> — В C# -&gt; WPF + XAML бекэнд + RX.Net для описания зависимостей + ReactiveUI.Fody для генерации</p>
<h2 id="Reactive-Gui-на-C-и-геймдеве"><a href="#Reactive-Gui-на-C-и-геймдеве" class="headerlink" title="Reactive Gui на C++ и геймдеве"></a>Reactive Gui на C++ и геймдеве</h2><p>Систему реактивного GUI можно разделить на 4 части:</p>
<ul>
<li>язык реализации (и, возможно, расширения) системы (C++)</li>
<li>язык для декларативного описания gui и байндингов контролов к данным</li>
<li>язык для описания скриптового поведения контролов (если хотим декларативно описывать поведение — в C++ сложно с рефлексией и интерпретацией кода)</li>
<li>тулза для визуального изменения декларативного описания</li>
</ul>
<p><a href="https://ru.wikipedia.org/wiki/Model-View-ViewModel" target="_blank" rel="noopener">Model-View-ViewModel</a><br><a href="https://guide.elm-lang.org/architecture/" target="_blank" rel="noopener">The Elm Architecture</a></p>
<p>Примеры Reactive GUI для геймдева встречаются не очень часто, но встречаются.</p>
<p><strong><code>imvue</code></strong><br><a href="https://github.com/Unix4ever/imvue/" target="_blank" rel="noopener">imvue</a> — минималистичный проект-пример</p>
<ul>
<li>sdl/glew/imgui в качестве бекэнда для рендера gui, плюс кодоген ооп-обёртки вокруг imgui</li>
<li>lua в качестве скриптового языка и reactive-системы</li>
<li>libcss — html/css декларативное описание, в стиле шаблонов vue.js</li>
<li>без визуального редактора, так как игрушечная либа</li>
</ul>
<p><strong><code>xui</code></strong><br><a href="https://github.com/JayDT/XUI" target="_blank" rel="noopener">XUI</a> — еще один демо-пример</p>
<ul>
<li>irrlicht в качестве бекэнда</li>
<li>C++ clang-based парсер для рефлексии, rxcpp и cpplinq для реактивности</li>
<li>xaml для декларативного описания, порт OmniXaml на C++</li>
</ul>
<p><strong><code>noesisengine</code></strong><br><a href="https://www.noesisengine.com/" target="_blank" rel="noopener">noesisengine</a> — коммерческий проект</p>
<ul>
<li>свой рендер-бекэнд, рефлексия, редактор (+ экспорт из microsoft blend)</li>
<li>xaml в качестве декларативного описания</li>
</ul>
<p><strong><code>daRg</code></strong><br><a href="https://github.com/GaijinEntertainment/DagorEngine/tree/d3499602af19410703e6248439916778231f3878/prog/gameLibs/daRg" target="_blank" rel="noopener">Dagor Reactive GUI</a> — гайдзиновский reactive gui</p>
<ul>
<li>своей рендер-бекэнд</li>
<li>quirrel (свой порт squirrel) в качестве декларативного описания, рефлексии и скриптового языка</li>
<li>свой визуальный редактор Dargbox</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script></div></article><div class="pagination"><a class="pagination__link pagination__next" href="/blog/1364570417/">Раньше</a></div></main><footer class="footer metadata"><p class="footer__text">© 2024 spiiin</p><p class="footer__text">Powered by <a class="footer__text__link" href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a class="footer__text__link" href="https://pages.github.com/" target="_blank">Github Page</a></p></footer></div></body></html>