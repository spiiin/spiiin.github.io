<!DOCTYPE html><html lang="ru"><head><meta charset="UTF-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Spiiin's blog | daScript - binding tricks 2</title><meta name="description" content=""><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=PT+Serif&amp;display=swap"><link rel="stylesheet" href="/css/highlights/darkula.css"><link rel="stylesheet" href="/css/main.css"><link rel="search" type="application/opensearchdescription+xml" href="http://spiiin.github.io/atom.xml" title="Spiiin's blog"><script>(function (i, s, o, g, r, a, m) {
  i['GoogleAnalyticsObject'] = r;
  i[r] = i[r] || function () {
    (i[r].q = i[r].q || []).push(arguments)
  }, i[r].l = 1 * new Date();
  a = s.createElement(o),
    m = s.getElementsByTagName(o)[0];
  a.async = 1;
  a.src = g;
  m.parentNode.insertBefore(a, m)
})(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');
ga('create', 'UA-00000000-0', 'auto');
ga('send', 'pageview');</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Spiiin's blog" type="application/atom+xml">
</head><body><div class="container"><header class="main-header"><h1 class="main-header__title uplize"><a class="main-header__title__link" href="/"><img class="header-image" src="/images/favicon.png" width="36" height="36">Spiiin's blog</a></h1><nav class="main-header__nav"><ul class="main-nav"><li class="main-nav__list"><a class="main-nav__list__link" href="/" target="_self">HOME</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/archives/" target="_self">ARCHIVE</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/tags/meta" target="_self">TAGS</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/blog/1" target="_self">ABOUT</a></li></ul></nav></header><main class="container__wrapper"><div class="pagination"><a class="pagination__link pagination__prev" href="/blog/1465137776/">Позже</a><a class="pagination__link pagination__next" href="/blog/4109146319/">Раньше</a></div><article class="article post"><h3 class="article__title">daScript - binding tricks 2</h3><div class="article__date metadata"><div class="post-info">2024/04/03</div></div><div class="article__tags metadata">Tags:
<a class="article__tags__link metadata" href="/tags/dascript/">dascript</a></div><div class="article__body"><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><ul>
<li><a href="/blog/1908536621/" title="daScript - binding tricks">daScript - binding tricks</a>
</li>
</ul>
<p>Ещё несколько примеров байндингов типов из <code>C++</code> и <code>daScript</code>.</p>
<h2><span id="standart-layout-struktury">Standart-layout структуры</span><a href="#standart-layout-struktury" class="header-anchor">#</a></h2><p>Пустой базовый класс C++:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> hidden;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMyClass</span><span class="params">(<span class="keyword">const</span> MyClass&amp; a)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a.hidden &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>(переменная hidden — просто для проверок, что класс инициализирован)</p>
<p>Привязка его к daScript:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyClassAnnotation</span> <span class="title">final</span> :</span> ManagedStructureAnnotation&lt;MyClass&gt; &#123;</span><br><span class="line">    MyClassAnnotation(ModuleLibrary&amp; ml) : ManagedStructureAnnotation(<span class="string">"MyClass"</span>, ml) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">MAKE_TYPE_FACTORY(MyClass, MyClass);</span><br></pre></td></tr></table></figure>
<p>..и добавление в модуль</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Module_Tutorial</span> :</span> <span class="keyword">public</span> Module &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Module_Tutorial() : Module(<span class="string">"tutorial"</span>) &#123;   <span class="comment">// module name, when used from das file</span></span><br><span class="line">        <span class="function">ModuleLibrary <span class="title">lib</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">        lib.addBuiltInModule();</span><br><span class="line"></span><br><span class="line">        addAnnotation(make_smart&lt;MyClassAnnotation&gt;(lib));</span><br><span class="line">        addCtorAndUsing&lt;MyClass&gt;(*<span class="keyword">this</span>, lib, <span class="string">"MyClass"</span>, <span class="string">"MyClass"</span>);</span><br><span class="line">        addExtern&lt;DAS_BIND_FUN(printMyClass)&gt;(*<span class="keyword">this</span>, lib, <span class="string">"printMyClass"</span>, SideEffects::worstDefault, <span class="string">"printMyClass"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">REGISTER_MODULE(Module_Tutorial);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">//где-то в регистрации модулей</span></span><br><span class="line">NEED_MODULE(Module_Tutorial);</span><br></pre></td></tr></table></figure>
<p>определение <code>ManagedStructureAnnotation</code> выглядит как:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> OT,</span><br><span class="line">    <span class="keyword">bool</span> canNew = is_default_constructible&lt;OT&gt;::value,</span><br><span class="line">    <span class="keyword">bool</span> canDelete = canNew &amp;&amp; is_destructible&lt;OT&gt;::value</span><br><span class="line">&gt; struct ManagedStructureAnnotation ;</span><br></pre></td></tr></table></figure>
<p>Это структура разбирает данные о типе <code>OT</code> с помощью <code>std::type_traits</code> и устанавливает его свойства, на основе которых daScript знает, что можно/нельзя делать с типом.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">hasNonTrivialCtor</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !is_trivially_constructible&lt;OT&gt;::value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">hasNonTrivialDtor</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !is_trivially_destructible&lt;OT&gt;::value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">hasNonTrivialCopy</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span>  !is_trivially_copyable&lt;OT&gt;::value</span><br><span class="line">        ||  !is_trivially_copy_constructible&lt;OT&gt;::value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">isPod</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> is_standard_layout&lt;OT&gt;::value &amp;&amp; is_trivial&lt;OT&gt;::value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">canMove</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !hasNonTrivialCopy();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">canCopy</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !hasNonTrivialCopy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Пока всё тривиально, <code>MyClass</code> — standart layout структура, не требующая дополнительной инициализации.<br><figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//объявления на стеке</span></span><br><span class="line">var c1 = [[MyClass]] </span><br><span class="line">var c2 = MyClass()</span><br><span class="line">var c3 : MyClass</span><br><span class="line">printMyClass(c1) <span class="comment">//0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//или на хипе</span></span><br><span class="line">var c4 = <span class="keyword">new</span> MyClass()</span><br><span class="line">printMyClass<span class="comment">(*c4) //0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//или создание временного объекта с помощью идиомы using:</span></span><br><span class="line"><span class="comment">using() &lt;| $ ( var c5: MyClass# )</span></span><br><span class="line"><span class="comment">    printMyClass(c5) //0</span></span><br></pre></td></tr></table></figure></p>
<h2><span id="non-standart-layout-klassy">Non standart layout классы</span><a href="#non-standart-layout-klassy" class="header-anchor">#</a></h2><p>Попробуем добавить в класс что-нибудь, что потребует его инициализации:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> hidden = <span class="number">42</span>; <span class="comment">//инициализация члена</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> str; <span class="comment">//non-stardary layout член</span></span><br><span class="line">    MyClass(<span class="keyword">const</span> MyClass&amp; other) : str(other.str) &#123;&#125; <span class="comment">//copy-ctor</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">virtualFunction</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;&#125; <span class="comment">//virtual function</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    MyClass(<span class="keyword">const</span> <span class="keyword">char</span>* data): str(data) &#123;&#125;</span><br><span class="line">    MyClass() = <span class="keyword">default</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">//привязки</span></span><br><span class="line">addCtorAndUsing&lt;MyClass, <span class="keyword">const</span> <span class="keyword">char</span>*&gt;(*<span class="keyword">this</span>, lib, <span class="string">"MyClass"</span>, <span class="string">"MyClass"</span>)-&gt;args(&#123; <span class="string">"str"</span> &#125;);</span><br><span class="line">addCtorAndUsing&lt;MyClass, <span class="keyword">const</span> MyClass&amp;&gt;(*<span class="keyword">this</span>, lib, <span class="string">"MyClass"</span>, <span class="string">"MyClass"</span>)-&gt;args(&#123; <span class="string">"other"</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> _method_100 = das::das_call_member&lt; <span class="keyword">void</span>(MyClass::*)() <span class="keyword">const</span>, &amp;MyClass::virtualFunction &gt;;</span><br><span class="line">makeExtern&lt;DAS_CALL_METHOD(_method_100), SimNode_ExtFuncCall&gt;(lib, <span class="string">"virtualFunction"</span>, <span class="string">"das::das_call_member&lt; void(MyClass::*)(), &amp;MyClass::virtualFunction &gt;::invoke"</span>)</span><br><span class="line">    -&gt;addToModule(*<span class="keyword">this</span>, SideEffects::worstDefault);</span><br></pre></td></tr></table></figure>
<p>Байндинг класса при перекомпиляции “увидит”, что теперь класс нетривиальный, и правильно переопределит его свойства. Теперь класс не может быть локальным, не может быть скопирован или перемещён:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canCopy</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canMove</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLocal</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br></pre></td></tr></table></figure></p>
<p>Соотвественно, тот же код на daScript выдаст ошибки компиляции, при попытке создать класс без инициализации:<br><figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//можно создать класс на хипе:</span></span><br><span class="line">var a &lt;- <span class="keyword">new</span> MyClass(<span class="string">"hello heap"</span>)</span><br><span class="line">printMyClass( *a ) <span class="comment">//42</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//можно создать временный объект с помощью using:</span></span><br><span class="line">using(<span class="string">"hello temp"</span>) &lt;| $(var c5: MyClass explicit)</span><br><span class="line">    printMyClass(c5) <span class="comment">//42</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//можно создать временный объект на стеке и передать его в качестве параметра</span></span><br><span class="line"><span class="comment">//(конструктор класса ничем не отличается от обычной функции)</span></span><br><span class="line">printMyClass(MyClass(<span class="string">"hello temp"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//нельзя создать объект, требующий перемещения (массив из одного элемента)</span></span><br><span class="line">printMyClass([[MyClass()]])</span><br><span class="line"><span class="comment">//нельзя переместить объект</span></span><br><span class="line">var c1 &lt;- MyClass()</span><br><span class="line"></span><br><span class="line"><span class="comment">//нельзя скопировать объект</span></span><br><span class="line">var c1 = MyClass()</span><br></pre></td></tr></table></figure></p>
<p><code>daScript</code> достаточно консервативно определяет, что объект нельзя копировать/перемещать, вообще говоря, если у класса есть конструктор копирования, то его можно разрешить копировать, если просто явно переопределить функцию canCopy в аннотации-обёртке класса</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> isCopyConstructable = <span class="built_in">std</span>::is_copy_constructible&lt;MyClass&gt;::value;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canCopy</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> isCopyConstructable; &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canClone</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> isCopyConstructable; &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canMove</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> isCopyConstructable; &#125;</span><br><span class="line"><span class="comment">//но нельзя создавать локальный переменные, так как они позволяет не инициализировать класс</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLocal</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br></pre></td></tr></table></figure>
<p><em>Если можно построить объект из другого объекта, то можно и copy/clone/move?</em></p>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//теперь можно copy/clone/move</span></span><br><span class="line">var a &lt;- <span class="keyword">new</span> MyClass(<span class="string">"hello heap"</span>)</span><br><span class="line">var b = <span class="keyword">new</span> MyClass()</span><br><span class="line">*b = *a</span><br><span class="line">*b := *a</span><br><span class="line">*b &lt;- *a</span><br></pre></td></tr></table></figure>
<p>Также в unsafe блоке теперь можно делать небезопасные, но интересные штуки:<br><figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> Params</span><br><span class="line">    a: MyClass</span><br><span class="line">unsafe</span><br><span class="line">    <span class="comment">//создаём локальную переменную на стеке</span></span><br><span class="line">    var m = MyClass(<span class="string">"hello_local"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//создаём контейнер неинициализированных объектов</span></span><br><span class="line">    <span class="comment">//  которые можно построить позже в этой памяти</span></span><br><span class="line">    <span class="comment">//  (аналог placement new в c++)</span></span><br><span class="line">    var n = [[MyClass(m)]]</span><br><span class="line"></span><br><span class="line">    <span class="comment">//создаём структуру из неинициализированных объектов</span></span><br><span class="line">    <span class="comment">//( аналог stackframe)</span></span><br><span class="line">    var s : Params</span><br><span class="line">    printMyClass(s.a)</span><br><span class="line">    <span class="comment">//s.a |&gt; virtualFunction() //пока нельзя обращаться к объекту</span></span><br><span class="line">    s.a &lt;- MyClass(<span class="string">"hello_local"</span>)</span><br><span class="line">    s.a |&gt; virtualFunction() <span class="comment">//vtable инициализирована</span></span><br><span class="line">    printMyClass(s.a) <span class="comment">//42</span></span><br></pre></td></tr></table></figure></p>
<h2><span id="argumenty-i-rezultaty">Аргументы и результаты</span><a href="#argumenty-i-rezultaty" class="header-anchor">#</a></h2><p>Если попытаться привязать такую функцию:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">functionWithClassArgument</span><span class="params">(MyClass a)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><br>компилятор начнёт ругаться на то, что не определён шаблон <code>cast_arg&lt;MyClass&gt;::to</code>. daScript-функции представляют свои аргументы и результаты в виде 128-битного типа <code>vec4f</code>, так что для кастомных типов необходимо описать способ преобразования с помощью частичной специализации этого шаблона.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">cast_arg</span>&lt;MyClass&gt; &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> __forceinline <span class="keyword">const</span> MyClass&amp; <span class="title">to</span><span class="params">(Context&amp; ctx, SimNode* node)</span> </span>&#123;</span><br><span class="line">        vec4f res = node-&gt;eval(ctx);</span><br><span class="line">        <span class="keyword">return</span> *cast&lt;MyClass*&gt;::to(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Другие примеры возможных способов определения преобразования:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//если тип standart-layout и меньше 128 байт -- можно просто скопировать память</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">cast_arg</span>&lt;const ImVec2 &amp;&gt; &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> __forceinline ImVec2 <span class="title">to</span> <span class="params">( Context &amp; ctx, SimNode * node )</span> </span>&#123;</span><br><span class="line">        vec4f res = node-&gt;eval(ctx);</span><br><span class="line">        ImVec2 v2;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;v2,&amp;res,<span class="keyword">sizeof</span>(ImVec2));</span><br><span class="line">        <span class="keyword">return</span> v2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//для типов-хэндлеров можно указать способ приведения хэндлера к какому-нибудь базовому типу</span></span><br><span class="line"><span class="comment">//  (каст указателей можно рассматривать как частный случай хэндлеров, уже определенных явно)</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">cast_arg</span>&lt;ax::NodeEditor::NodeId&gt; &#123;</span></span><br><span class="line">    <span class="keyword">static</span> __forceinline ax::<span class="function">NodeEditor::NodeId <span class="title">to</span> <span class="params">( Context &amp; ctx, SimNode * node )</span> </span>&#123;</span><br><span class="line">        vec4f res = node-&gt;eval(ctx);</span><br><span class="line">        <span class="keyword">return</span> ax::NodeEditor::NodeId(cast&lt;<span class="keyword">int32_t</span>&gt;::to(res));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">cast_res</span>&lt;ax::NodeEditor::NodeId&gt; &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> __forceinline vec4f <span class="title">from</span> <span class="params">( ax::NodeEditor::NodeId node, Context * )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cast&lt;<span class="keyword">int32_t</span>&gt;::from(<span class="keyword">int32_t</span>(node.Get()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//для типов-прокси можно определить способ построения прокси из базового типа/извлечения базового типа</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">cast_arg</span>&lt;const sf::String &amp;&gt; &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> __forceinline sf::String <span class="title">to</span> <span class="params">( Context &amp; ctx, SimNode * node )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> * pstr = node-&gt;evalPtr(ctx);</span><br><span class="line">        <span class="keyword">return</span> sf::String(pstr ? pstr : <span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">cast_res</span>&lt;sf::String&gt; &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> __forceinline vec4f <span class="title">from</span> <span class="params">( <span class="keyword">const</span> sf::String &amp; str, Context * context )</span> </span>&#123;</span><br><span class="line">		<span class="keyword">auto</span> text = context-&gt;stringHeap-&gt;allocateString(str);</span><br><span class="line">        <span class="keyword">return</span> cast&lt;<span class="keyword">char</span> *&gt;::from(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Из пары примеров выше видно, что для привязки функций, возвращающих тип в качестве результата, необходимо определить специализацию шаблона <code>cast_res</code> с функцией <code>from</code>. Это верно для standard layout структур, но для сложного класса (с созданием временного объекта на хипе, по аналогии с sf::String) daScript бросает assert:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">addExtern(getMyClass_ExtFuncCall)::failed</span><br><span class="line">  this function should be bound with addExtern&lt;DAS_BIND_FUNC(getMyClass_ExtFuncCall), SimNode_ExtFuncCallAndCopyOrMove&gt;</span><br><span class="line">  likely cast&lt;&gt; is implemented for the return type, and it should not</span><br></pre></td></tr></table></figure>
<p>говорит этот ассерт о том, что вместо того, чтобы создавать временный объект, что тормознуто, лучше использовать специальную ноду языка, которая возвращает уже созданный объект. Такое себе принуждение к оптимизации.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">    <span class="function">MyClass <span class="title">getMyClass</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> _method_2 = das::das_call_member&lt; MyClass(MyClass::*)() <span class="keyword">const</span>, &amp;MyClass::getMyClass &gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//makeExtern&lt;DAS_CALL_METHOD(_method_2), SimNode_ExtFuncCall &gt;(lib, "getMyClass_ExtFuncCall", "das::das_call_member&lt; MyClass(MyClass::*)() const, &amp;MyClass::getMyClass &gt;::invoke")</span></span><br><span class="line"><span class="comment">//    -&gt;addToModule(*this, SideEffects::worstDefault); //work with pod type, but not if type has something not trivial</span></span><br><span class="line"></span><br><span class="line">makeExtern&lt;DAS_CALL_METHOD(_method_2), SimNode_ExtFuncCallAndCopyOrMove &gt;(lib, <span class="string">"getMyClass_ExtFuncCallAndCopyOrMove"</span>, <span class="string">"das::das_call_member&lt; MyClass(MyClass::*)() const, &amp;MyClass::getMyClass &gt;::invoke"</span>)</span><br><span class="line">    -&gt;addToModule(*<span class="keyword">this</span>, SideEffects::worstDefault);</span><br></pre></td></tr></table></figure>
<p>Теперь в daScript можно использовать эти функции:</p>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">functionWithClassArgument(MyClass(<span class="string">"hello arg"</span>))</span><br><span class="line">MyClass(<span class="string">"hello res"</span>)|&gt; getMyClass_ExtFuncCallAndCopyOrMove()</span><br></pre></td></tr></table></figure>
<h2><span id="reflection-over-c">Reflection over C++</span><a href="#reflection-over-c" class="header-anchor">#</a></h2><p>Вся эта шаблонная магия привязок генерится не руками, а генератором привязок <a href="https://github.com/GaijinEntertainment/daScript/tree/master/modules/dasClangBind/bind" target="_blank" rel="noopener">dasClangBind</a>. Распознавание инфы о типах сделано на уровне самого кода daScript, а не генератора, чтобы сам код генератора и сгенерированный код был более простым и однообразным. Но все примеры обёрток, сделанные <code>dasClingBind</code>, сделаны для библиотек с C-интерфейсом, которые почти не требуют ручного вмешательства. Но как только дело доходит до реального C++ кода, вылезает всё и сразу. Описанные в статье приёмы позволяют побороть большую часть сложности, и нагенерировать что-нибудь серьёзное, типа привязок классов <code>Unreal Engine</code> (с небольшими доработками напильником).</p>
<p>Примеры привязок либ с c-интерфейсом через <code>dasClangBind</code>:</p>
<ul>
<li><a href="/blog/4090909622/" title="daScript: C++ auto-bindings, msgpack">daScript: C++ auto-bindings, msgpack</a></li>
<li><a href="/blog/500729544/" title="daScript: C++ auto-bindings, assimp">daScript: C++ auto-bindings, assimp</a>
</li>
</ul>
<p>Другие подходы:<br><a href="https://floooh.github.io/2020/08/23/sokol-bindgen.html" target="_blank" rel="noopener">Automatic Language Bindings</a> — размышления о способах генерации привязок к языкам от автора sokol gfx (тоже c-style, с помощью clang json)<br><a href="https://medium.com/@eddo2626/lets-learn-zig-4-using-c-libraries-in-zig-5fcc3206f0dc" target="_blank" rel="noopener">Using C Libraries in Zig</a> — прозрачный импорт C из zig. с Си (не С++) вообще все достаточно просто<br><a href="https://scripter.co/binding-nim-to-c-plus-plus-std-list/" target="_blank" rel="noopener">Binding Nim to C++ std::list</a> — читерский подход в nim, без интерпретации и с транспиляцией в C++ можно просто встраивать и использовать куски плюсового кода.<br><a href="https://github.com/seanbaxter/circle" target="_blank" rel="noopener">Circle</a> — “бэтменский” альтернативный компилятор с встроенными compile-time фичами, включая рефлексию. Автор публикует прогресс в <a href="https://twitter.com/seanbax" target="_blank" rel="noopener">твиттере</a><br><a href="https://cppyy.readthedocs.io/en/latest/" target="_blank" rel="noopener">cppyy: Automatic Python-C++ bindings</a> — хардкор с использованием интерактивного компилятора C++ cling, прозрачный парсинг, компиляция и генерация привязок на лету</p>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"Ov23liG1mZbiQOIdi91X","clientSecret":"e05812685eb741a752982b89dcf6f5b58dc10251","repo":"spiiin.github.io","owner":"spiiin","admin":["spiiin"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script></div></article><div class="pagination"><a class="pagination__link pagination__prev" href="/blog/1465137776/">Позже</a><a class="pagination__link pagination__next" href="/blog/4109146319/">Раньше</a></div></main><footer class="footer metadata"><p class="footer__text">© 2024 spiiin</p><p class="footer__text">Powered by <a class="footer__text__link" href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a class="footer__text__link" href="https://pages.github.com/" target="_blank">Github Page</a></p></footer></div></body></html>