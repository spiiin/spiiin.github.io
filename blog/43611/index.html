<!DOCTYPE html><html lang="ru"><head><meta charset="UTF-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Spiiin's blog | Objictive С tips</title><meta name="description" content=""><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=PT+Serif&amp;display=swap"><link rel="stylesheet" href="/css/highlights/darkula.css"><link rel="stylesheet" href="/css/main.css"><link rel="search" type="application/opensearchdescription+xml" href="http://spiiin.github.io/atom.xml" title="Spiiin's blog"><script>(function (i, s, o, g, r, a, m) {
  i['GoogleAnalyticsObject'] = r;
  i[r] = i[r] || function () {
    (i[r].q = i[r].q || []).push(arguments)
  }, i[r].l = 1 * new Date();
  a = s.createElement(o),
    m = s.getElementsByTagName(o)[0];
  a.async = 1;
  a.src = g;
  m.parentNode.insertBefore(a, m)
})(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');
ga('create', 'UA-00000000-0', 'auto');
ga('send', 'pageview');</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-shiki-plugin@latest/lib/codeblock.css">
<style>:root{--hl-color:#abb2bf;--hl-bg:#282c34;--hltools-bg:#21252b;--hltools-color:#bbbbbc;--hlnumber-bg:#282c34;--hlnumber-color:#495162;--hlscrollbar-bg:#373c47;--hlexpand-bg:linear-gradient(180deg,rgba(40,44,52,0.1),rgba(40,44,52,0.9))}</style><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Spiiin's blog" type="application/atom+xml">
</head><body><div class="container"><header class="main-header"><h1 class="main-header__title uplize"><a class="main-header__title__link" href="/"><img class="header-image" src="/images/favicon.png" width="36" height="36">Spiiin's blog</a></h1><nav class="main-header__nav"><ul class="main-nav"><li class="main-nav__list"><a class="main-nav__list__link" href="/" target="_self">HOME</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/archives/" target="_self">ARCHIVE</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/tags/meta" target="_self">TAGS</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/blog/1" target="_self">ABOUT</a></li></ul></nav></header><main class="container__wrapper"><div class="pagination"><a class="pagination__link pagination__prev" href="/blog/51338/">Позже</a><a class="pagination__link pagination__next" href="/blog/37438/">Раньше</a></div><article class="article post"><h3 class="article__title">Objictive С tips</h3><div class="article__date metadata"><div class="post-info">2011/07/11</div></div><div class="article__tags metadata">Tags:
<a class="article__tags__link metadata" href="/tags/iphone/">iphone</a><a class="article__tags__link metadata" href="/tags/objc/">objc</a></div><div class="article__body"><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p><strong>1. Смешивание языков.</strong> </p>
<p>Objective-C код совместим с сишным кодом, но не всегда совместим с С++.</p>
<p>Также существует язык Objective-C++, который позволяет более-менее свободно смешивать C++/Objective-C код. Компилятор gcc по умолчанию считает файлы с расширением .m содержащими код на Objective-C, а файлы с расширением .mm - код на языка Objictive-C++, но ему можно явно указать язык с помощью ключа -x В универсальных заголовочных файлах определить, в какой язык включается файл, можно, проверяя наличие макросимволов __OBJC__ или __cplusplus. </p>
<p>Чтобы вызывать Objective-C код из языка С++, удобнее всего сделать обычный С++-класс-обертку, содержащий членом указатель на класс Objective-C, так как наследование от него невозможно. </p>
<p>Если возможности создать класс нет (Objective-C, в отличие от Objective-C++, не дает возможности создавать C++-классы), то проще всего заворачивать вызовы в глобальные функции, и звать их из С++. При этом такие функции, как и обычные сишные, в С++ коде надо объявлять в блоке extern “C”, так как компилятор манглит их имена по правилам языка си. Проще это всё показать примером:  </p>
<figure class="shiki objc"><div class="codeblock"><div class="code"><pre class="shiki slack-dark"><code><span class="line"><span style="color: #6A9955">//h-файл (общий заголовок)</span></span>
<span class="line"><span style="color: #E6E6E6"> class ObjClassWrapper</span></span>
<span class="line"><span style="color: #E6E6E6"> {</span></span>
<span class="line"><span style="color: #E6E6E6">   ObjClass </span><span style="color: #D4D4D4">*</span><span style="color: #E6E6E6"> objClass1;</span></span>
<span class="line"><span style="color: #E6E6E6">   </span><span style="color: #DCDCAA">ObjClassWrapper</span><span style="color: #E6E6E6">(); { [[objClass1 </span><span style="color: #DCDCAA">alloc</span><span style="color: #E6E6E6">] </span><span style="color: #DCDCAA">init</span><span style="color: #E6E6E6">]; }</span></span>
<span class="line"><span style="color: #E6E6E6">   </span><span style="color: #D4D4D4">~</span><span style="color: #DCDCAA">ObjClassWrapper</span><span style="color: #E6E6E6">(); { [objClass1 </span><span style="color: #DCDCAA">dealloc</span><span style="color: #E6E6E6">]; }</span></span>
<span class="line"><span style="color: #E6E6E6">   </span><span style="color: #569CD6">void</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">method1</span><span style="color: #E6E6E6">(); { [objClass1 </span><span style="color: #DCDCAA">method1</span><span style="color: #E6E6E6">]; }</span></span>
<span class="line"><span style="color: #E6E6E6"> };</span></span>
<span class="line"><span style="color: #E6E6E6"> </span></span>
<span class="line"><span style="color: #E6E6E6"> </span><span style="color: #6A9955">//mm-файл (язык Objective-C++)</span></span>
<span class="line"><span style="color: #E6E6E6"> </span><span style="color: #569CD6">@interface</span><span style="color: #E6E6E6"> </span><span style="color: #4EC9B0">ObjClass</span></span>
<span class="line"><span style="color: #E6E6E6"> </span><span style="color: #569CD6">@end</span></span>
<span class="line"><span style="color: #E6E6E6"> </span></span>
<span class="line"><span style="color: #E6E6E6"> </span><span style="color: #569CD6">@implementation</span><span style="color: #E6E6E6"> </span><span style="color: #4EC9B0">ObjClass</span></span>
<span class="line"><span style="color: #E6E6E6"> </span><span style="color: #D4D4D4">-</span><span style="color: #E6E6E6">(</span><span style="color: #569CD6">void</span><span style="color: #E6E6E6">) method1</span></span>
<span class="line"><span style="color: #E6E6E6"> {</span></span>
<span class="line"><span style="color: #E6E6E6">   </span><span style="color: #DCDCAA">NSLog</span><span style="color: #E6E6E6">(</span><span style="color: #CE9178">&quot;Method1&quot;</span><span style="color: #E6E6E6">);</span></span>
<span class="line"><span style="color: #E6E6E6"> }</span></span>
<span class="line"><span style="color: #E6E6E6"> </span><span style="color: #569CD6">@end</span></span>
<span class="line"><span style="color: #E6E6E6"> </span></span>
<span class="line"><span style="color: #E6E6E6"> ObjClassWrapper::</span><span style="color: #DCDCAA">ObjClassWrapper</span><span style="color: #E6E6E6">() { [[objClass1 </span><span style="color: #DCDCAA">alloc</span><span style="color: #E6E6E6">] </span><span style="color: #DCDCAA">init</span><span style="color: #E6E6E6">]; }</span></span>
<span class="line"><span style="color: #E6E6E6"> ObjClassWrapper::</span><span style="color: #D4D4D4">~</span><span style="color: #DCDCAA">ObjClassWrapper</span><span style="color: #E6E6E6">() { [objClass1 </span><span style="color: #DCDCAA">dealloc</span><span style="color: #E6E6E6">]; }</span></span>
<span class="line"><span style="color: #E6E6E6"> </span><span style="color: #569CD6">void</span><span style="color: #E6E6E6"> ObjClassWrapper::</span><span style="color: #DCDCAA">method1</span><span style="color: #E6E6E6">(); { [objClass1 </span><span style="color: #DCDCAA">method1</span><span style="color: #E6E6E6">]; }</span></span>
<span class="line"><span style="color: #E6E6E6"> </span></span>
<span class="line"><span style="color: #E6E6E6"> </span><span style="color: #6A9955">//m-файл (язык Objective-C)</span></span>
<span class="line"><span style="color: #E6E6E6"> </span><span style="color: #569CD6">@implementation</span><span style="color: #E6E6E6"> </span><span style="color: #4EC9B0">StaticObjClass</span></span>
<span class="line"><span style="color: #E6E6E6"> </span><span style="color: #D4D4D4">+</span><span style="color: #E6E6E6">(</span><span style="color: #569CD6">void</span><span style="color: #E6E6E6">) method2</span></span>
<span class="line"><span style="color: #E6E6E6"> {</span></span>
<span class="line"><span style="color: #E6E6E6">   </span><span style="color: #DCDCAA">NSLog</span><span style="color: #E6E6E6">(</span><span style="color: #CE9178">&quot;Method2&quot;</span><span style="color: #E6E6E6">);</span></span>
<span class="line"><span style="color: #E6E6E6"> }</span></span>
<span class="line"><span style="color: #E6E6E6"> </span><span style="color: #569CD6">@end</span></span>
<span class="line"><span style="color: #E6E6E6"> </span></span>
<span class="line"><span style="color: #E6E6E6"> </span><span style="color: #569CD6">void</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">method2</span><span style="color: #E6E6E6">() { [StaticObjClassObjClass </span><span style="color: #DCDCAA">method2</span><span style="color: #E6E6E6">]; }</span></span>
<span class="line"><span style="color: #E6E6E6"> </span></span>
<span class="line"><span style="color: #E6E6E6"> </span><span style="color: #6A9955">//c++-файл</span></span>
<span class="line"><span style="color: #569CD6"> </span><span style="color: #C586C0">#include</span><span style="color: #569CD6"> </span><span style="color: #CE9178">&lt;universalHeader.h&gt;</span><span style="color: #569CD6">   </span><span style="color: #6A9955">//объявляем класс-обертку</span></span>
<span class="line"><span style="color: #E6E6E6"> </span><span style="color: #569CD6">extern</span><span style="color: #E6E6E6"> </span><span style="color: #CE9178">&quot;C&quot;</span><span style="color: #E6E6E6"> { </span><span style="color: #569CD6">void</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">method2</span><span style="color: #E6E6E6">(); } </span><span style="color: #6A9955">//объявляем метод-обертку</span></span>
<span class="line"><span style="color: #E6E6E6"> </span></span>
<span class="line"><span style="color: #E6E6E6"> ObjClassWrapper w; w.</span><span style="color: #DCDCAA">method1</span><span style="color: #E6E6E6">();  </span><span style="color: #6A9955">//зовем код на Objective-C</span></span>
<span class="line"><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">method2</span><span style="color: #E6E6E6">();</span></span>
<span class="line"><span style="color: #E6E6E6"> ```</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E6E6E6">Про смешивание языков и вызов кода на С</span><span style="color: #D4D4D4">++</span><span style="color: #E6E6E6"> из языка Objective</span><span style="color: #D4D4D4">-</span><span style="color: #E6E6E6">C есть статья </span><span style="color: #D4D4D4">&lt;</span><span style="color: #E6E6E6">http:</span><span style="color: #6A9955">//touchdev.ru/documents/963&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #D4D4D4">**</span><span style="color: #B5CEA8">2.</span><span style="color: #E6E6E6"> True</span><span style="color: #D4D4D4">/</span><span style="color: #E6E6E6">Yes</span><span style="color: #D4D4D4">**</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E6E6E6">Всегда интересно ([раз](http:</span><span style="color: #6A9955">//stackoverflow.com/questions/615702/is-there-a-difference-between-yes-no-true-false-and-true-false-in-objective-c) [два](http://stackoverflow.com/questions/541289/objective-c-bool-vs-boo) [три](http://stackoverflow.com/questions/6420987/why-does-objective-c-use-yes-no-macro-convention-instead-of-true-false)), нафига разные ключевые слова?</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E6E6E6">[Главное, чтобы </span><span style="color: #DCDCAA">помещалось</span><span style="color: #E6E6E6">](http:</span><span style="color: #6A9955">//wasm.ru/article.php?article=1022005)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #D4D4D4">**</span><span style="color: #B5CEA8">3.</span><span style="color: #E6E6E6"> Динамический Objective</span><span style="color: #D4D4D4">-</span><span style="color: #E6E6E6">C</span><span style="color: #D4D4D4">**</span></span>
<span class="line"></span>
<span class="line"><span style="color: #D4D4D4">**</span><span style="color: #B5CEA8">3.1</span><span style="color: #D4D4D4">**</span></span>
<span class="line"><span style="color: #E6E6E6">Так как Objective</span><span style="color: #D4D4D4">-</span><span style="color: #E6E6E6">C является динамической веткой развития языка С</span><span style="color: #D4D4D4">++</span><span style="color: #E6E6E6">, то проверка наличия методов у экземляров выполняется только во время запуска приложения.</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E6E6E6">Методы среды выполнения, позволяющие динамически оперировать классами и методами классов, находятся в библиотеке `libobjc.A.dylib`, которая подключается к любой программе.</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E6E6E6">С помощью них можно, например, сделать подмену одного класса другим во всех местах, в которых будет обращения к оригинальному классу:</span></span></code></pre></div></div></figure>
<p>[[MyBundle class] poseAsClass:[NSBundle class]]; //заменяем класс бандла своим, переопределяя его стандартное поведение.<br><figure class="shiki"><div class="codeblock"><div class="code"><pre class="shiki slack-dark"><code><span class="line"><span style="color: #E6E6E6"></span></span>
<span class="line"><span style="color: #E6E6E6">**3.2**</span></span>
<span class="line"><span style="color: #E6E6E6">Однако такой метод уже признан apple устаревшим и вместо него можно подменять отдельные методы класса при помощи `class_getInstanceMethod` и свойства `method_imp` у селекторов класса. </span></span>
<span class="line"><span style="color: #E6E6E6"></span></span>
<span class="line"><span style="color: #E6E6E6">Описание интересного трика с подменой метода :</span></span>
<span class="line"><span style="color: #E6E6E6">&lt;http://www.cocoadev.com/index.pl?MethodSwizzling&gt;</span></span>
<span class="line"><span style="color: #E6E6E6"></span></span>
<span class="line"><span style="color: #E6E6E6">**3.3**</span></span>
<span class="line"><span style="color: #E6E6E6">Помимо этого в самих классах также можно перегрузить служебные методы, используемые средой выполнения, например, присвоив новый класс свойству isa, проверяющему, какому классу принадлежит объект. Члены класса таким способом поменять нельзя, зато можно полностью сменить интерфейс.</span></span></code></pre></div></div></figure><br>obj-&gt;isa = [MyClass class];<br>```</p>
<p><strong>3.4</strong><br>Или можно перегрузить методы <code>forwardInvocation:</code> и <code>methodSignatureForSelector:</code> проверяющие само наличие метода у объекта<br><a target="_blank" rel="noopener" href="http://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class/Reference/Reference.html#//apple_ref/occ/instm/NSObject/forwardInvocation:">ссылка</a></p>
<p><strong>3.5</strong><br>Ну и в самом языке есть возможность расширения существующих классов, вплоть до базового <code>NSObject</code>‘а, используя категории<br><a target="_blank" rel="noopener" href="http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/ObjectiveC/Chapters/ocCategories.html#//apple_ref/doc/uid/TP30001163-CH20-SW1">ссылка</a></p>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"Ov23liG1mZbiQOIdi91X","clientSecret":"e05812685eb741a752982b89dcf6f5b58dc10251","repo":"spiiin.github.io","owner":"spiiin","admin":["spiiin"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script></div></article><div class="pagination"><a class="pagination__link pagination__prev" href="/blog/51338/">Позже</a><a class="pagination__link pagination__next" href="/blog/37438/">Раньше</a></div></main><footer class="footer metadata"><p class="footer__text">© 2024 spiiin</p><p class="footer__text">Powered by <a class="footer__text__link" href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a class="footer__text__link" href="https://pages.github.com/" target="_blank">Github Page</a></p></footer></div><!-- hexo injector body_end start -->
  <script>
  const CODE_CONFIG = {
    beautify: undefined,
    highlightCopy: undefined,
    highlightLang: undefined,
    highlightHeightLimit: undefined,
    isHighlightShrink: undefined,
    copy: {
      success: 'undefined',
      error: 'undefined',
      noSupport: 'undefined',
    }
  };
  console.log(
    `%c hexo-shiki-plugin %c v1.0.27 %c https://github.com/nova1751/hexo-shiki-plugin`,
    "color: #fff; background: #5f5f5f",
    "color: #fff; background: #80c8f8",
    ""
  );
  </script>
  <!-- hexo injector body_end end --></body></html>