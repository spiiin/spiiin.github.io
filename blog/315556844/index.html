<!DOCTYPE html><html lang="ru"><head><meta charset="UTF-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Spiiin's blog | LLVM - обзор</title><meta name="description" content="&lt;p&gt;Попытка очень бегло пройтись по тому, что можно найти в LLVM.&lt;br&gt;"><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=PT+Serif&amp;display=swap"><link rel="stylesheet" href="/css/highlights/darkula.css"><link rel="stylesheet" href="/css/main.css"><link rel="search" type="application/opensearchdescription+xml" href="http://spiiin.github.io/atom.xml" title="Spiiin's blog"><script>(function (i, s, o, g, r, a, m) {
  i['GoogleAnalyticsObject'] = r;
  i[r] = i[r] || function () {
    (i[r].q = i[r].q || []).push(arguments)
  }, i[r].l = 1 * new Date();
  a = s.createElement(o),
    m = s.getElementsByTagName(o)[0];
  a.async = 1;
  a.src = g;
  m.parentNode.insertBefore(a, m)
})(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');
ga('create', 'UA-00000000-0', 'auto');
ga('send', 'pageview');</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Spiiin's blog" type="application/atom+xml">
</head><body><div class="container"><header class="main-header"><h1 class="main-header__title uplize"><a class="main-header__title__link" href="/"><img class="header-image" src="/images/favicon.png" width="36" height="36">Spiiin's blog</a></h1><nav class="main-header__nav"><ul class="main-nav"><li class="main-nav__list"><a class="main-nav__list__link" href="/" target="_self">HOME</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/archives/" target="_self">ARCHIVE</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/tags/meta" target="_self">TAGS</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/blog/1" target="_self">ABOUT</a></li></ul></nav></header><main class="container__wrapper"><div class="pagination"><a class="pagination__link pagination__prev" href="/blog/3121981810/">Позже</a><a class="pagination__link pagination__next" href="/blog/1186660544/">Раньше</a></div><article class="article post"><h3 class="article__title">LLVM - обзор</h3><div class="article__date metadata"><div class="post-info">2022/10/09</div></div><div class="article__tags metadata">Tags:
<a class="article__tags__link metadata" href="/tags/dev/">dev</a><a class="article__tags__link metadata" href="/tags/dascript/">dascript</a><a class="article__tags__link metadata" href="/tags/cpp/">cpp</a></div><div class="article__body"><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Попытка очень бегло пройтись по тому, что можно найти в LLVM.<br><a id="more"></a></p>
<h2 id="Инфраструктура-для-авторов-языков-программирования"><a href="#Инфраструктура-для-авторов-языков-программирования" class="headerlink" title="Инфраструктура для авторов языков программирования"></a>Инфраструктура для авторов языков программирования</h2><p>LLVM - это огромный проект. Чаще всего, когда говорят о нём - имеют ввиду возможность написать только фронтэнд для какого-нибудь языка - из языка в биткод llvm. Дальше автоматом можно получить следующие стадии трансформации: из <code>ir llvm -&gt; оптимизации различные -&gt;mir под конкретные платформы -&gt; бинарный код под платформы</code>.</p>
<p>Биткод может быть представлен в 3х формах: текстовый псевдоассемблер, бинарный формат, и in-memory api, с помощью которого можно нагенерить всё с помощью кода, в том числе сделать jit-компилятор.</p>
<p>В теории, jit быстрее статической компиляции, потому что:</p>
<ul>
<li>может задействовать динамические данные о том, какой код “горячее” (статическому компилятору тоже можно передать эту инфу, полученную уже после запуска приложения, при повторной компиляции/линковке)</li>
<li>может инлайнить больше, чем статический - например, библиотечные функции, которые иначе нельзя</li>
<li>может подстроиться под особенностью архитектуры или ос</li>
</ul>
<p>Java vm, .net или js-двики чаще всего jit так или иначе делают, быстрые версии интерпретаторов тоже. Jit-компиляция большая отдельная тема.<br><a href="https://github.com/borisbat/dasLLVM" target="_blank" rel="noopener">dasLLVM</a> — пример jit-компиляции из <a href="https://spiiin.github.io/tags/dascript/">daScript</a> на LLVM, пока на начальной стадии.</p>
<p>Если хочется погрузиться в теорию компиляции, можно читать что-нибудь типа:</p>
<ul>
<li>Learn LLVM 12</li>
<li>Классическую “Компиляторы: принципы, технологии и инструменты”</li>
<li><a href="http://craftinginterpreters.com/" target="_blank" rel="noopener">Crafting Interpreters</a></li>
</ul>
<p>Последняя интересна тем, что нацелена на практику, от автора <code>Game Programming Patterns</code>, а также нескольких скриптовых языков: <a href="https://wren.io/" target="_blank" rel="noopener">wren</a>, <a href="https://magpie-lang.org/" target="_blank" rel="noopener">magpie</a>. В его блоге также много <a href="https://journal.stuffwithstuff.com/category/language/" target="_blank" rel="noopener">статей</a> об устройстве языков программирования. В третьей части много продвинутого материала об оптимизации вызовов функций, замыканий и методам ускорения интерпретатора байт кода.</p>
<p>Несколько нестандартных применений:</p>
<ul>
<li><a href="https://andrewkelley.me/post/jamulator.html" target="_blank" rel="noopener">Statically Recompiling NES Games into Native Executables with LLVM and Go</a> - попытка перекомпилировать байт-код для NES в LLVM-биткод, без эмуляции от автора языка <code>Zig</code>, не очень успешная, так как в NES ассемблере очень много трюков, которые требуют реальной эмуляции особенностей железа (синхронизация с процессором, прыжки в середину инструкции, самомодифицирующийся код).</li>
<li>“Компиляция данных” — создание микроязыков для того, чтобы добавить возможность “положить” в игровые ресурсы код.</li>
</ul>
<p><a href="https://www.youtube.com/watch?v=3QQuhL-dSys" target="_blank" rel="noopener">2019 LLVM Developers’ Meeting: J. Paquette &amp; F. Hahn “Getting Started With LLVM: Basics”</a> — доклад про IR LLVM<br><a href="https://llvm.org/docs/WritingAnLLVMPass.html" target="_blank" rel="noopener">Writing an LLVM Pass</a> — как написать свой проход LLVM</p>
<h2 id="Clang-фронтэнд-компилятор-C"><a href="#Clang-фронтэнд-компилятор-C" class="headerlink" title="Clang - фронтэнд компилятор C++"></a>Clang - фронтэнд компилятор C++</h2><p>Отдельный проект — фронтэнд для С++ (а также С и  Objective C/C++) - <code>clang</code>. Собственно, у него есть несколько ключей, чтобы получать промежуточные представления кода, но это тоже прикладным разработчикам не особо надо чаще всего. Один из вариантов его использования - написание своих проходов при компиляции. Cобирается плагин в dll/dylib/a и компилятору clang ключом передаётся, чтобы он дёргал функции-колбека из этого плагина при каждой компиляции кода.</p>
<p>Apple в xcode clang не совсем из стандартной репы собирала, поэтому он у них с такими плагинами не работает, но в принципе пересобрав самому из исходников можно и им под ios код генерить. Вот <a href="https://railsware.com/blog/creation-and-using-clang-plugin-with-xcode/" target="_blank" rel="noopener">“hello world”</a> с плагинами. Таким способом можно решать что-то типа “хочу, чтобы если в лямбду кто-то захватил this неявно, то компиляция крешилась с сообщением, потому что в половине случаев автор забыл проверить время жизни this и упадёт в рантайме” (или другие правила, обычно написанные кровью в code convention проекта, которые невозможно выразить семантикой C++).</p>
<p>Так редко кто делает, но вот примеры проектов с набором плагинов, дополнительно проверяющих код:<br><a href="https://github.com/LibreOffice/core/tree/master/compilerplugins/clang" target="_blank" rel="noopener">libreoffice</a><br><a href="https://chromium.googlesource.com/chromium/src.git/+/master/docs/clang.md#using-plugins" target="_blank" rel="noopener">chrome</a> + <a href="https://ehsanakhgari.org/blog/2015-12-07/c-static-analysis-using-clang/" target="_blank" rel="noopener">Статья</a><br><a href="https://hg.mozilla.org/mozilla-central/file/tip/build/clang-plugin/" target="_blank" rel="noopener">firefox</a></p>
<p>Более основательный туториал про то, как писать плагины, и что с их помощью можно делать<br><a href="https://github.com/banach-space/llvm-tutor" target="_blank" rel="noopener">https://github.com/banach-space/llvm-tutor</a></p>
<h2 id="API-для-работы-с-Clang"><a href="#API-для-работы-с-Clang" class="headerlink" title="API для работы с Clang"></a>API для работы с Clang</h2><p>Особенность компилятора Clang — он предоставляет несколько API для того, чтобы можно было получать информацию о коде программы.</p>
<p>К примеру, можно пропарсить заголовочный файлы и автоматом нагенерить привязок к другим языкам. Из особенностей - не очень быстро работает (поэтому некоторые предпочитают велосипедить свои парсеры, передавая мета-информацию комментариями), и не очень хорошо работает с сложным шаблонным кодом. Но в целом можно целиком какую-нибудь либу привязать им к другому языку с небольшим количеством ручной работы.</p>
<p>Один из интерфейсов - <code>libclang</code>, библиотека на C++, к которой есть привязки на других языках.</p>
<p>Примеры использования <strong><code>генерации привязок</code></strong>:<br><a href="/blog/4090909622/" title="daScript: C++ auto-bindings, msgpack">daScript: C++ auto-bindings, msgpack</a> — генерация из daScript привязок к <code>msgpack</code><br><a href="/blog/500729544/" title="daScript: C++ auto-bindings, assimp">daScript: C++ auto-bindings, assimp</a> — генерация из daScript привязок к <code>assimp</code>, без написания кода (почти)<br>(с помощью <a href="https://github.com/GaijinEntertainment/daScript/tree/master/modules/dasClangBind" target="_blank" rel="noopener">dasClangBind</a>)<br><a href="https://floooh.github.io/2020/08/23/sokol-bindgen.html" target="_blank" rel="noopener">Automatic Language Bindings</a> — генерация из Python привязок к <code>solol</code> для различных языков (zig/nim/odin)</p>
<p><strong><code>Интерактивное получение данных из кода</code></strong><br><a href="https://root.cern/cling/" target="_blank" rel="noopener">Cling</a> - интерактивная комплиляция С++ кода, для использования с инструментами типа <code>Jupyter</code><br><a href="https://cppyy.readthedocs.io/en/latest/examples.html" target="_blank" rel="noopener">cppyy</a> - привязка cling к python, работает в том числе и под windows</p>
<p><strong><code>Написание тулзов для IDE</code></strong><br><a href="https://github.com/def-/ycmd" target="_blank" rel="noopener">ycmd</a> - сервер автодополнения кода для различных IDE<br><a href="https://marketplace.visualstudio.com/items?itemName=RamonViladomat.StructLayout" target="_blank" rel="noopener">StructLayout</a> - расширение для VS code, которое может показать то, как компилятор будет размещать структуру в памяти (надо помнить, что libclang, который использует это расширение, должен быть той же версии, что и сам компилятор, который будет генерировать код).</p>
<p>Можно также решать всякие задачи вроде “отсортировать функции по количеству байт и напечатать 10 самых больших”.</p>
<p><strong><code>Туториалы, как научиться пользоваться</code></strong><br><a href="https://jonasdevlieghere.com/understanding-the-clang-ast/" target="_blank" rel="noopener">Understanding the Clang AST</a> - 3 API для работы с AST в clang<br><a href="https://clang.llvm.org/docs/IntroductionToTheClangAST.html" target="_blank" rel="noopener">Introduction to the Clang AST</a> - ссылки на диаграммы классов AST, во что трансформируется код на C++<br><a href="https://clang.llvm.org/docs/RAVFrontendAction.html" target="_blank" rel="noopener">How to write RecursiveASTVisitor based ASTFrontendActions</a> - пример того, как сделать свой визитор для AST<br><a href="https://clang.llvm.org/docs/LibASTMatchersTutorial.html" target="_blank" rel="noopener">Tutorial for building tools using LibTooling and LibASTMatchers</a> - использование других интерфейсов для написания визиторов<br><a href="https://www.youtube.com/watch?v=VqCkCDFLSsc" target="_blank" rel="noopener">The Clang AST - a Tutorial</a> - доклад всё про то же<br><a href="http://www.goldsborough.me/c++/clang/llvm/tools/2017/02/24/00-00-06-emitting_diagnostics_and_fixithints_in_clang_tools/" target="_blank" rel="noopener">Emitting Diagnostics in Clang</a> — вывод своих сообщений об ошибках</p>
<p>В каком-то смысле, интерфейс для того, чтобы иметь доступ к AST языка, необходим из-за того, что этого не умеет сам C++ - шаблоны умеют заставить компилятор произвести эффекты, но не имеют доступа к самому коду. В языках вроде <code>daScript</code> аналогичную плагинам компилятора работы могут выполнять макросы.<br><a href="https://github.com/GaijinEntertainment/daScript/blob/master/daslib/jobque_boost.das#L142" target="_blank" rel="noopener">Пример</a> макроса в daScript, применяемого к замыканию и выполняющего дополнительную работу, если в замыкание передаются примитивы синхронизации <code>Channel</code> или <code>Job</code>.<br><a href="/blog/1547564887/" title="daScript macro">daScript macro</a> — пример генерации AST daScript из кода<br><a href="/blog/4046309382/" title="daScript macro - 2">daScript macro - 2</a> — пример работы с DSL, упрощающим написание AST</p>
<p>Также, для Clang, чтобы упростить работу с C++ AST, существует DSL для составления запросов - <strong><code>clang query</code></strong><br><a href="https://www.youtube.com/watch?v=yqi8U8Q0h2g" target="_blank" rel="noopener">2019 EuroLLVM Developers’ Meeting: S. Kelly “The Future of AST Matcher-based Refactoring</a> - использование запросов clang query для визуальной работы с кодом, расширение godbolt + интерфейс к qt контролам<br><a href="https://www.youtube.com/watch?v=38tYYrnfNrs" target="_blank" rel="noopener">Extending clang-tidy in the Present and in the Future - Stephen Kelly</a> - и для модификации кода/рефакторинга</p>
<p>Ещё один способ использования — глубже изучить, как устроена какая-либо абстракция в языке<br><a href="https://www.youtube.com/watch?v=8C8NnE1Dg4A" target="_blank" rel="noopener">CppCon 2016: Gor Nishanov “C++ Coroutines: Under the covers”</a> — реализация корутин в новом стандарте C++<br><a href="https://llvm.org/docs/LangRef.html" target="_blank" rel="noopener">LLVM Language Reference Manual</a> - справка по псевдо-ассемблеру LLVM</p>
<h2 id="Исходный-код-и-архитектура-LLVM"><a href="#Исходный-код-и-архитектура-LLVM" class="headerlink" title="Исходный код и архитектура LLVM"></a>Исходный код и архитектура LLVM</h2><p><a href="http://rus-linux.net/MyLDP/BOOKS/Architecture-Open-Source-Applications/Vol-1/llvm.html" target="_blank" rel="noopener">Глава в книге “Архитектура приложений с открытым исходным кодом”</a><br><a href="https://blog.regehr.org/archives/1453" target="_blank" rel="noopener">A Tourist’s Guide to the LLVM Source Code</a> - обзор исходников<br><a href="https://llvm.org/docs/ProgrammersManual.html" target="_blank" rel="noopener">Обзор используемых структур данных</a> + <a href="https://llvm.org/devmtg/2014-04/PDFs/LightningTalks/data_structure_llvm.pdf" target="_blank" rel="noopener">Ещё один</a></p>
<h2 id="LLDB"><a href="#LLDB" class="headerlink" title="LLDB"></a>LLDB</h2><p>Отладчик, также использующий инфраструктуру llvm. Одна из интересных возможностей — наличие <a href="https://lldb.llvm.org/python_reference/" target="_blank" rel="noopener">python api</a>.</p>
<p>Пример использования API:<br><a href="/blog/1170009669/" title="Расположение объектов C++ в памяти. Часть 2">Расположение объектов C++ в памяти. Часть 2</a> — рекурсивный обход структур, для запроса из отладчика выравнивания их в памяти, с отображением “дырок”</p>
<h2 id="Общие-ссылки"><a href="#Общие-ссылки" class="headerlink" title="Общие ссылки"></a>Общие ссылки</h2><p><a href="https://llvm.org/devmtg/" target="_blank" rel="noopener">https://llvm.org/devmtg/</a> + <a href="https://www.youtube.com/c/LLVMPROJ/playlists" target="_blank" rel="noopener">https://www.youtube.com/c/LLVMPROJ/playlists</a><br><a href="https://blog.llvm.org/" target="_blank" rel="noopener">https://blog.llvm.org/</a></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script></div></article><div class="pagination"><a class="pagination__link pagination__prev" href="/blog/3121981810/">Позже</a><a class="pagination__link pagination__next" href="/blog/1186660544/">Раньше</a></div></main><footer class="footer metadata"><p class="footer__text">© 2022 spiiin</p><p class="footer__text">Powered by <a class="footer__text__link" href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a class="footer__text__link" href="https://pages.github.com/" target="_blank">Github Page</a></p></footer></div></body></html>