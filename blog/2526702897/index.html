<!DOCTYPE html><html lang="ru"><head><meta charset="UTF-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Spiiin's blog | Flamegraph. Windows/iOS/Android</title><meta name="description" content="&lt;p&gt;В прошлой заметке я писал, что флеймграфы можно генерировать из данных различных профайлеров, сейчас решил проверить, насколько это удобно на практике.&lt;br&gt;&lt;a href=&quot;/blog/2779627234/&quot; title=&quot;Flamegraphs&quot;&gt;Flamegraphs&lt;/a&gt;&lt;/p&gt;"><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=PT+Serif&amp;display=swap"><link rel="stylesheet" href="/css/highlights/darkula.css"><link rel="stylesheet" href="/css/main.css"><link rel="search" type="application/opensearchdescription+xml" href="http://spiiin.github.io/atom.xml" title="Spiiin's blog"><script>(function (i, s, o, g, r, a, m) {
  i['GoogleAnalyticsObject'] = r;
  i[r] = i[r] || function () {
    (i[r].q = i[r].q || []).push(arguments)
  }, i[r].l = 1 * new Date();
  a = s.createElement(o),
    m = s.getElementsByTagName(o)[0];
  a.async = 1;
  a.src = g;
  m.parentNode.insertBefore(a, m)
})(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');
ga('create', 'UA-00000000-0', 'auto');
ga('send', 'pageview');</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Spiiin's blog" type="application/atom+xml">
</head><body><div class="container"><header class="main-header"><h1 class="main-header__title uplize"><a class="main-header__title__link" href="/"><img class="header-image" src="/images/favicon.png" width="36" height="36">Spiiin's blog</a></h1><nav class="main-header__nav"><ul class="main-nav"><li class="main-nav__list"><a class="main-nav__list__link" href="/" target="_self">HOME</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/archives/" target="_self">ARCHIVE</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/tags/meta" target="_self">TAGS</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/blog/1" target="_self">ABOUT</a></li></ul></nav></header><main class="container__wrapper"><div class="pagination"><a class="pagination__link pagination__prev" href="/blog/1366632532/">Позже</a><a class="pagination__link pagination__next" href="/blog/2779627234/">Раньше</a></div><article class="article post"><h3 class="article__title">Flamegraph. Windows/iOS/Android</h3><div class="article__date metadata"><div class="post-info">2021/07/18</div></div><div class="article__tags metadata">Tags:
<a class="article__tags__link metadata" href="/tags/dev-method/">dev_method</a></div><div class="article__body"><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>В прошлой заметке я писал, что флеймграфы можно генерировать из данных различных профайлеров, сейчас решил проверить, насколько это удобно на практике.<br><a href="/blog/2779627234/" title="Flamegraphs">Flamegraphs</a></p>
<a id="more"></a>
<p><code>Флеймграфы</code> позволяют детально изучить какие функции занимают время процессора (не только пару самых тяжёлых, но и относительное время выполнения любых функций в любой части программы).</p>
<p>С их помощью можно измерить время выполнения(точнее, количество сэмплов), <code>частей &quot;ядра&quot; приложения</code> (библиотеки, фреймворки, STL, системный вызовы ОС), <code>увидеть стоимость абстракций</code> (rtti/dynamic_cast, malloc/new), <code>исследовать горячие места программы</code> (не только самые тяжёлые места, с которыми иногда ничего нельзя сделать, но и “локальные” горячие точки), измерить, <code>на какие именно части программы влияет оптимизация</code> (как собственные, так и компилятора).</p>
<p>Также возможно сохранение отчётов для последующего изучения и дифференциальное сравнение (чтобы увидеть регрессию/оптимизацию при развитии программы).</p>
<h2><span id="windows">Windows</span><a href="#windows" class="header-anchor">#</a></h2><p>Сходу оказалось, что экспорт данных в csv формате, необходимый для анализа, из встроенного в студию профайлера в версии 2019 <a href="https://developercommunity.visualstudio.com/t/vs2019-profiling-report-is-missing-export-report-d/714378" target="_blank" rel="noopener">выбросили</a>, потому что “никому не нужно”.</p>
<p>Что ж, на офф-сайте Flamegraph упоминается, что можно экспортировать данные из отчёта, собираемого другим профайлером для Windows <code>XPerf</code>. Однако <a href="https://randomascii.wordpress.com/2013/03/26/summarizing-xperf-cpu-usage-with-flame-graphs/" target="_blank" rel="noopener">скрипт</a> для конвертации данных писался сторонним разработчиком и спустя 8 лет уже не работает, так что я забил на поиски и решил, что быстрее будет написать конвертер самому, чем искать и править чужие решения.</p>
<p>В качестве сборщика данных можно взять не сам <code>XPerf</code>, а open-source профайлер, использующий тот же API Event Tracing for Windows - <a href="https://github.com/Donpedro13/etwprof" target="_blank" rel="noopener">etfprof</a>. Он позволяет сразу отфильтровать события профилируемого приложения от других процессов, за счёт чего экономится размер собираемых данных.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;-t - id процесса или имя запущенного приложения</span><br><span class="line">etwprof profile -t&#x3D;418996 --output profile_result -m</span><br></pre></td></tr></table></figure>
<p>Профайлер создаёт файл <code>ИМЯ_ПРОЦЕССА_дата.etl</code>. Его можно открыть в программе <a href="https://www.microsoft.com/en-us/p/windows-performance-analyzer/9n0w1b2bxgnz#activetab=pivot:overviewtab" target="_blank" rel="noopener">Windows Performance Analyzer</a>, которая может <a href="https://randomascii.wordpress.com/2016/09/05/etw-flame-graphs-made-easy/" target="_blank" rel="noopener">отобразить результаты</a> в виде флеймграфа.</p>
<p>Но мне захотелось пойти дальше и экспортировать данные в текстовом виде для преобразования их оригинальными скриптами. Во первых, чтобы проверить понимание работы этих скриптов, имея референсную картинку от <code>Windows Performance Analyzer</code>, во-вторых, чтобы иметь возможность отфильтровать вывод и воспользоваться другими преимуществами оригинальных скриптов, например, построением диференциальных графов по результатам двух измерений.</p>
<p>Для этого нужно сконвертировать данные из бинарного etl формата в текстовый утилитой <code>xperf</code> (ставится вместе с <code>Windows Performance Analyzer</code>):</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xperf -i &quot;profile.etl&quot; -o perf.csv -target machine -symbols</span><br></pre></td></tr></table></figure>
<p>На выходе получается файл с записью о сэмплах, сделанных профайлером, примерно в таком виде:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SampledProfile,     508414, MyProc.exe (425204),     404904, 0xffff8563393bcd20,   0, MyProc.exe!$$Thunk@00002a54,   win32kbase.sys!ValidateHwnd,     1, Unbatched</span><br><span class="line">                  Stack,     508414,     404904, win32kbase.sys!ValidateHwnd, win32kfull.sys!xxxRealInternalGetMessage, win32kfull.sys!NtUserPeekMessage, ntoskrnl.exe!KiSystemServiceCopyEnd</span><br><span class="line">                  Stack,     508414,     404904, wow64win.dll!ZwUserPeekMessage, wow64win.dll!whNtUserPeekMessage, wow64.dll!Wow64SystemServiceEx, wow64cpu.dll!ServiceNoTurbo, wow64cpu.dll!BTCpuSimulate, wow64.dll!RunCpuSimulation, wow64.dll!Wow64LdrpInitialize, ntdll.dll!LdrpInitializeProcess, ntdll.dll!_LdrpInitialize, ntdll.dll!LdrpInitialize, ntdll.dll!LdrInitializeThunk, win32u.dll!NtUserPeekMessage, user32.dll!_PeekMessage, user32.dll!PeekMessageW, MyProc.exe!update, MyProc.exe!processEvents, MyProc.exe!loop, MyProc.exe!WinMain, MyProc.exe!invoke_main, MyProc.exe!__scrt_common_main_seh, MyProc.exe!__scrt_common_main, MyProc.exe!WinMainCRTStartup, kernel32.dll!BaseThreadInitThunk, ntdll.dll!__RtlUserThreadStart, ntdll.dll!_RtlUserThreadStart</span><br></pre></td></tr></table></figure></p>
<p>Этот файл необходимо распарсить и преобразовать в формат <code>folded stacks</code>, который выглядит так:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">win32kbase.sys!ValidateHwnd;win32kfull.sys!xxxRealInternalGetMessage;win32kfull.sys!NtUserPeekMessage;ntoskrnl.exe!KiSystemServiceCopyEnd 42</span><br></pre></td></tr></table></figure></p>
<p>То есть:</p>
<ul>
<li>“Разворачиваем” порядок вызова функций в стеке, и заменяем разделитель на “;”</li>
<li>Небольшая хитрость - нужно сосчитать все повторяющиеся стеки и в конце строки записать их количество</li>
<li>Манглинг имён - некоторые спецсимфолы нужно заэкранировать, чтобы на следующем этапе скрипты flamegraph не сломались</li>
</ul>
<p>Результат:<br><a href="https://github.com/spiiin/converters_to_flamegraph/blob/master/xperf_csv_to_collapsed_stacks.py" target="_blank" rel="noopener">https://github.com/spiiin/converters_to_flamegraph/blob/master/xperf_csv_to_collapsed_stacks.py</a></p>
<p>Дальше ставим <a href="https://strawberryperl.com/" target="_blank" rel="noopener">perl</a> и выполняем скрипт <a href="https://github.com/brendangregg/FlameGraph/blob/master/flamegraph.pl" target="_blank" rel="noopener">flamegraph.pl</a>, чтобы сконвертировать файл со свёрнутыми стеками, которые сгенерировал питоновский скрипт, в svg-файл для изучения.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flamegraph.pl perf.folded &gt; perf.svg</span><br></pre></td></tr></table></figure>
<p>На выходе получается файл svg (содержащий xml-данные и js-код), который можно открыть в любом браузере и изучить.<br><img src="/blog/2526702897/perf_win32_small.png" alt="perf_win32_smal"></p>
<h2><span id="macos-ios">macOS/iOS</span><a href="#macos-ios" class="header-anchor">#</a></h2><p>В Apple тоже решили, что экспорт в CSV никому не нужен и убрали его, потому тут тоже приходится искать обходные пути.</p>
<p>Самый простой найденный мной - собрать данные с помощью <code>Instruments -&gt; Time profile</code> и скопировать их в виде текста самому.<br>Также что порядок действий такой:<br><img src="/blog/2526702897/xcode-config_small.png" alt="xcode_config"></p>
<p><strong><code>1. Выделить промежуток времени, данные для которого хочется изучить</code></strong><br><strong><code>2. Настроить отображение колонок для экспорта</code></strong><br>Нужно отключить все, кроме количества сэмплов (символ “#”) и имён функций (<code>Symbol Name</code>). Не забыть выключить также отображение иконок функций (они создают дополнительный символ табуляции и пробела при экспорте).<br><strong><code>3. Выделить корневой (ТОЛЬКО корневой!) элемент для экспорта мышкой и в меню XCode выбрать пункт Edit-&gt;Deep Copy</code></strong></p>
<p>Дальше скопированные данные нужно вставить в текстовый файл и сохранить (под именем <code>sample.txt</code>, как ожидает скрипт конвертации).<br>Пример экспортированных данных<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Samples	Symbol Name</span><br><span class="line">34532	MyApp (637)</span><br><span class="line">28052	 Main Thread  0x12daf</span><br><span class="line">28048	  start</span><br><span class="line">28048	   UIApplicationMain</span><br><span class="line">28048	    GSEventRunModal</span><br><span class="line">28048	     CFRunLoopRunSpecific</span><br><span class="line">28048	      __CFRunLoopRun</span><br><span class="line">27796	       __CFRunLoopDoSource1</span><br><span class="line">27789	        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__</span><br><span class="line">27789	         __CFMachPortPerform</span><br><span class="line">27787	          IODispatchCalloutFromCFMessage</span><br><span class="line">27766	           CA::Display::DisplayLink::dispatch_items(unsigned long long, unsigned long long, unsigned long long)</span><br><span class="line">27741	            -[AppController doCaller:]</span><br></pre></td></tr></table></figure></p>
<p>Здесь чуть хитрее, чем в Windows версии, так как данные о глубине стека сохранены в виде количества пробелов относительно предыдущей строки. Зато уже подсчитано количество сэмплов.</p>
<p>Готовые скрипты типа <a href="https://github.com/brendangregg/FlameGraph/blob/master/stackcollapse-instruments.pl" target="_blank" rel="noopener">этого</a>, конечно, больше не работают- видимо формат экспорта данных немного сменился с обновлениями. Так что, как и для win-версии пришлось сделать свой на питоне:<br><a href="https://github.com/spiiin/converters_to_flamegraph/blob/master/instruments_to_collapsed_stacks.py" target="_blank" rel="noopener">https://github.com/spiiin/converters_to_flamegraph/blob/master/instruments_to_collapsed_stacks.py</a></p>
<p>Он не такой короткий, как оригинальный на перле (<a href="https://xkcd.ru/208/" target="_blank" rel="noopener">расступитесь, я знаю регулярные выражения!</a>), зато его проще понять и подправить, если формат экспорта снова изменится. </p>
<p>Последний шаг - конвертация:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flamegraph.pl perf.folded &gt; perf.svg</span><br></pre></td></tr></table></figure></p>
<p>И уииии, у меня есть флеймграф выполнения программы:<br><img src="/blog/2526702897/perf_ios_small.png" alt="perf_ios_smal"></p>
<h2><span id="android">Android</span><a href="#android" class="header-anchor">#</a></h2><p>Здесь я не стал возиться с экспортом данных, потому что штатный профайлер Android Studio <a href="https://youtu.be/O5V9ZSL0BsM?t=86" target="_blank" rel="noopener">умеет</a> отображать флеймграфы. Данные можно экспортировать в виде .track-файла и загружать его для изучения в Android Studio.<br>Тем не менее, вроде бы, при большом желании, используя <a href="https://android.googlesource.com/platform/prebuilts/simpleperf/+/67b5f82a399fba110faf781a8be55aaaa0f21084/README.md#show-flamegraph" target="_blank" rel="noopener">simpleperf</a> из командной строки можно заставить сгенерировать данные в виде сжатых графов.</p>
<h2><span id="zamechaniya">Замечания</span><a href="#zamechaniya" class="header-anchor">#</a></h2><p>Исследуя фреймграфы, стоит помнить о стандартных штуках при профилировании приложений и игр:</p>
<ul>
<li>Статистические профайлеры отмечают, в каком месте выполнения находится процессор, “”включаясь” с определенной заданной частотой, им нужно некоторое время (несколько секунд), чтобы собрать данные. Они не очень подходят для отображения пиков-фризов в определенном кадре.</li>
<li>Для регрессионного профилирования нужно подумать о хорошо воспроизводимых тестовых сценариях.</li>
<li>Флеймграфы показывают не абсолютное время работы конкретных функций, а сгруппированное количество сэмплов в ходе профилирования - этого достаточно, чтобы понять, чем “обычно” занят процессор в ходе выполнения программы.</li>
<li>Изредка слетает отображение имён символов. Нужно изучать документацию к конкретному профайлеру. Часто помогает просто провести повторное измерение.</li>
<li>Данные, относящиеся к вызовам графического API, показывают работу CPU по отправке команд на GPU - отрисовка этих данных начинает выполняться позже и выполняется параллельно с последующей работой CPU. То же самое касается работы со звуковым чипом. Профилирование сети и обращений к диску возможно и обычными профайлерами (Off-CPU profiling).</li>
<li>Придётся научиться читать и понимать STL-код, и расшифровывать замангленные имена функций компилятора (например, лямбда-функции).</li>
</ul>
<h2><span id="repozitoriy-so-skriptami">Репозиторий со скриптами</span><a href="#repozitoriy-so-skriptami" class="header-anchor">#</a></h2><p><a href="https://github.com/spiiin/converters_to_flamegraph" target="_blank" rel="noopener">https://github.com/spiiin/converters_to_flamegraph</a></p>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"Ov23liG1mZbiQOIdi91X","clientSecret":"e05812685eb741a752982b89dcf6f5b58dc10251","repo":"https://github.com/spiiin/spiiin.github.io","owner":"spiiin","admin":["spiiin"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script></div></article><div class="pagination"><a class="pagination__link pagination__prev" href="/blog/1366632532/">Позже</a><a class="pagination__link pagination__next" href="/blog/2779627234/">Раньше</a></div></main><footer class="footer metadata"><p class="footer__text">© 2024 spiiin</p><p class="footer__text">Powered by <a class="footer__text__link" href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a class="footer__text__link" href="https://pages.github.com/" target="_blank">Github Page</a></p></footer></div></body></html>