<!DOCTYPE html><html lang="ru"><head><meta charset="UTF-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Spiiin's blog | daScript in imaginery world</title><meta name="description" content="&lt;p&gt;Мой собственный способ измерить выразительность и скорость языка — решить на нём “задачу Джеймса Бонда младшего”, выдуманную головоломку из игры на NES &lt;code&gt;James Bond Jr&lt;/code&gt; (&lt;a href=&quot;https://youtu.be/Kzu_cGHFqM8?t=1290&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;видео&lt;/a&gt;). Несмотря на игрушечность задачи, кажется, это неплохой тест нового языка. Это веселее, чем реализовывать абстрактный поиск в ширину/глубину. Задачу решаю с небольшими алгоритмическими оптимизациями, но без оптимизаций по мелочам (скорее, наоборот, массив чисел специально копируется, как решена первая версия задачи на питоне, чтобы решения были сравнивыми, чтобы симулировать “код новичка” на языка и посмотреть, как язык справляется с этим копированием).&lt;/p&gt;
&lt;p&gt;Сразу выводы про &lt;code&gt;daScript&lt;/code&gt; для тех, кому не особенно интересны подробности реализации:&lt;/p&gt;
&lt;p&gt;— Выразительность языка ОЧЕНЬ похожа на &lt;code&gt;Python&lt;/code&gt;. Более того, я фактически просто переписал своё решение на &lt;code&gt;Python&lt;/code&gt; 13-летней давности построчно, с парой изменений.&lt;br&gt;— &lt;code&gt;daScript&lt;/code&gt; по скорости &lt;strong&gt;в режиме интерпретации&lt;/strong&gt; находится в одной лиге с компилируемыми языками (!!!). Код по скорости сопоставим с версией на &lt;code&gt;Nim&lt;/code&gt; (чуть быстрее “наивной” &lt;strong&gt;скомпилированной&lt;/strong&gt; версии, и раза в 1.5-2 медленнее оптимизированной).&lt;br&gt;— В режиме &lt;code&gt;Ahead-of-Time&lt;/code&gt; компиляции &lt;code&gt;daScript&lt;/code&gt; обгоняет &lt;code&gt;nim&lt;/code&gt; (который вообще показывает достаточно хорошие результаты в нормальных бенчмарках с другими языками).&lt;/p&gt;"><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=PT+Serif&amp;display=swap"><link rel="stylesheet" href="/css/highlights/darkula.css"><link rel="stylesheet" href="/css/main.css"><link rel="search" type="application/opensearchdescription+xml" href="http://spiiin.github.io/atom.xml" title="Spiiin's blog"><script>(function (i, s, o, g, r, a, m) {
  i['GoogleAnalyticsObject'] = r;
  i[r] = i[r] || function () {
    (i[r].q = i[r].q || []).push(arguments)
  }, i[r].l = 1 * new Date();
  a = s.createElement(o),
    m = s.getElementsByTagName(o)[0];
  a.async = 1;
  a.src = g;
  m.parentNode.insertBefore(a, m)
})(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');
ga('create', 'UA-00000000-0', 'auto');
ga('send', 'pageview');</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Spiiin's blog" type="application/atom+xml">
</head><body><div class="container"><header class="main-header"><h1 class="main-header__title uplize"><a class="main-header__title__link" href="/"><img class="header-image" src="/images/favicon.png" width="36" height="36">Spiiin's blog</a></h1><nav class="main-header__nav"><ul class="main-nav"><li class="main-nav__list"><a class="main-nav__list__link" href="/" target="_self">HOME</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/archives/" target="_self">ARCHIVE</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/tags/meta" target="_self">TAGS</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/blog/1" target="_self">ABOUT</a></li></ul></nav></header><main class="container__wrapper"><div class="pagination"><a class="pagination__link pagination__prev" href="/blog/2301621444/">Позже</a><a class="pagination__link pagination__next" href="/blog/3006126295/">Раньше</a></div><article class="article post"><h3 class="article__title">daScript in imaginery world</h3><div class="article__date metadata"><div class="post-info">2022/06/19</div></div><div class="article__tags metadata">Tags:
<a class="article__tags__link metadata" href="/tags/dascript/">dascript</a></div><div class="article__body"><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Мой собственный способ измерить выразительность и скорость языка — решить на нём “задачу Джеймса Бонда младшего”, выдуманную головоломку из игры на NES <code>James Bond Jr</code> (<a href="https://youtu.be/Kzu_cGHFqM8?t=1290" target="_blank" rel="noopener">видео</a>). Несмотря на игрушечность задачи, кажется, это неплохой тест нового языка. Это веселее, чем реализовывать абстрактный поиск в ширину/глубину. Задачу решаю с небольшими алгоритмическими оптимизациями, но без оптимизаций по мелочам (скорее, наоборот, массив чисел специально копируется, как решена первая версия задачи на питоне, чтобы решения были сравнивыми, чтобы симулировать “код новичка” на языка и посмотреть, как язык справляется с этим копированием).</p>
<p>Сразу выводы про <code>daScript</code> для тех, кому не особенно интересны подробности реализации:</p>
<p>— Выразительность языка ОЧЕНЬ похожа на <code>Python</code>. Более того, я фактически просто переписал своё решение на <code>Python</code> 13-летней давности построчно, с парой изменений.<br>— <code>daScript</code> по скорости <strong>в режиме интерпретации</strong> находится в одной лиге с компилируемыми языками (!!!). Код по скорости сопоставим с версией на <code>Nim</code> (чуть быстрее “наивной” <strong>скомпилированной</strong> версии, и раза в 1.5-2 медленнее оптимизированной).<br>— В режиме <code>Ahead-of-Time</code> компиляции <code>daScript</code> обгоняет <code>nim</code> (который вообще показывает достаточно хорошие результаты в нормальных бенчмарках с другими языками).</p>
<a id="more"></a>
<p>Заметки<br>1 - <a href="/blog/28461/" title="(2009) Python in imaginary world">(2009) Python in imaginary world</a><br>2 - <a href="/blog/3351183716/" title="(2015) Scala in imaginary world">(2015) Scala in imaginary world</a><br>3 - <a href="/blog/1808122922/" title="(2021) Nim in imaginary world">(2021) Nim in imaginary world</a><br>Исходники<br><a href="https://github.com/spiiin/james_bond_jr_problem" target="_blank" rel="noopener">https://github.com/spiiin/james_bond_jr_problem</a></p>
<h2 id="Подготовка"><a href="#Подготовка" class="headerlink" title="Подготовка"></a>Подготовка</h2><p>Сборка автономного интерпретатора - проект <code>daScript</code> (можно в cmake поотключать дополнительные библиотеки типа <code>glfw</code>, ненужные для интерпретатора)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">option(DAS_XXX_MODULE_DISABLED &quot;Disable any unneeded modules&quot; OFF)</span><br></pre></td></tr></table></figure><br>Также не забывать собрать Release-версию. Теперь можно запускать скрипты из командной строки:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">daScript.exe james_bond_jr.das</span><br></pre></td></tr></table></figure></p>
<h2 id="Решение"><a href="#Решение" class="headerlink" title="Решение"></a>Решение</h2><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        gist
    </div>
    <div class='spoiler-content'>
        <script src="//gist.github.com/3bd63cd5271b277f5bc87f670b0ab967.js?file=james_bond_jr_dascript.das"></script>
    </div>
</div>
<p>Отличия в синтаксис от <code>Python</code>:</p>
<p><strong><code>- Отсутствует присваивание кортежей</code></strong><br>Из-за чего нельзя написать сдвиг в массиве как в <code>python</code>:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n[0+plus],n[1+plus],n[2+plus],n[3+plus] &#x3D; n[3+plus],n[0+plus],n[1+plus],n[2+plus]</span><br></pre></td></tr></table></figure><br>и приходится писать отдельную функцию сдвига</p>
<p><strong><code>- Нельзя сравнить два массива с помощью оператора проверки равенства</code></strong><br>Что логично из-за неопределенности поведения такого оператора (сравнивать ли содержимое или указатели). Из-за этого используется самописная функция <code>same</code>:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">same</span><span class="params">(var a,b: int[<span class="number">16</span>])</span></span></span><br><span class="line">    for ai, bi in a, b</span><br><span class="line">        <span class="keyword">if</span> ai != bi</span><br><span class="line">            <span class="keyword">return</span> false</span><br><span class="line">    <span class="keyword">return</span> true</span><br></pre></td></tr></table></figure></p>
<p><strong><code>- Поддержка именованных именованных кортежей без необходимости использовать отдельный класс</code></strong><br><code>Python</code> позволяет использовать <a href="https://docs.python.org/3.6/library/collections.html?highlight=namedtuple#collections.namedtuple" target="_blank" rel="noopener">именованные кортежи</a> вместо обычных там, где не хочется заводить структуру. В <code>daScript</code> возможность именовать поля кортежа встроена в язык:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">typedef FieldPathInfo = tuple&lt;field:int[<span class="number">16</span>]; fieldFrom:int[<span class="number">16</span>];  rate:int&gt;</span><br><span class="line">var a = [[FieldPathInfo val, vert, rate(val)]]</span><br></pre></td></tr></table></figure></p>
<p><strong><code>- Ошибки вывода типа в генериках иногда напоминают вывод ошибок в шаблонов C++</code></strong><br><a href="https://github.com/GaijinEntertainment/daScript/issues/309" target="_blank" rel="noopener">https://github.com/GaijinEntertainment/daScript/issues/309</a></p>
<p><strong><code>- Нет встроенного аналога list из Python и DoubleLinkedList из Nim</code></strong><br>Вместо этого кортежи хранятся в классе <code>array</code>, представляющем собой динамический массив. Для того, чтобы избежать лишнего копирования данных при сортировке, память под кортежи выделяется на стеке:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">//медленный вариант</span><br><span class="line">var open: array&lt;FieldPathInfo&gt;</span><br><span class="line">open |&gt; push &lt;| [[FieldPathInfo source, rate(source), zeros]] //хранение в массиве объектов</span><br><span class="line">//более быстрый вариант</span><br><span class="line">var open: array&lt;FieldPathInfo?&gt;</span><br><span class="line">open |&gt; push &lt;| new [[FieldPathInfo source, zeros, rate(source)]] //хранение в массиве ссылок на объекта на хипе</span><br></pre></td></tr></table></figure></p>
<p>Также можно отметить, что объекты на хипе выделяются в соседних областях памяти, аллокатор контекста по умолчанию выделяет память из предвыделенного линейного блока:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">16</span>)</span><br><span class="line">    var xxx = new [[FieldPathInfo val, vert, rate(val)]]</span><br><span class="line">    unsafe</span><br><span class="line">        print(<span class="string">"addr=&#123;reinterpret&lt;void?&gt; xxx&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line">//output:</span><br><span class="line">addr=<span class="number">0x28b1bb582f0</span></span><br><span class="line">addr=<span class="number">0x28b1bb58380</span></span><br><span class="line">addr=<span class="number">0x28b1bb58410</span></span><br><span class="line">addr=<span class="number">0x28b1bb584a0</span></span><br><span class="line">addr=<span class="number">0x28b1bb58530</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>Так что, в теории, разница в скорости в выделении объектов на стеке и в куче для <code>daScript</code> должна быть небольшой, и хранение узлов в массиве должно дать даже небольшой прирост скорости из-за локальности хранения узлов в памяти, по отношению к способу хранения в списке.</p>
<p>За исключением перечисленных отличий, код “переведён” построчно с Python версии (с “бонусной” проверкой ошибок типизации интерпретатором). В такой форме при интерпретации он уже работает лишь чуть медленнее скомпилированной версии на <code>Nim</code>.</p>
<h2 id="Ahead-of-Time-компиляция"><a href="#Ahead-of-Time-компиляция" class="headerlink" title="Ahead-of-Time компиляция"></a>Ahead-of-Time компиляция</h2><p><code>daScript</code> можно настроить, чтобы вместо интерпретации он генерировал C++-код, выполняющий те же действия. В репозитория проекта есть <a href="https://github.com/GaijinEntertainment/daScript/blob/master/examples/tutorial/CMakeLists.txt#L36" target="_blank" rel="noopener">пример</a> настройки <code>cmake</code> для автоматической генерации AoT-версии кода.<br>Можно проделать этот этап вручную:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">daScript.exe -aot james_bond_jr.das james_bond_jr.das.cpp</span><br></pre></td></tr></table></figure></p>
<p>Полученный C++ файл можно скомпилировать (можно просто добавить его в один из туториалов), и теперь при выполнении скрипта <code>james_bond_jr.das</code>, вместо интерпретации, будут выполнены скомпилированные версии функций. В таком режиме скрипт обгоняет разогнанную <code>nim</code> версию решения. Выводы в начале.</p>
<p><img src="/blog/1160489034/jbjr.gif" alt="jbjr"></p>
<h2 id="Ещё-быстрее"><a href="#Ещё-быстрее" class="headerlink" title="Ещё быстрее!"></a>Ещё быстрее!</h2><p>Пара оптимизаций, чтобы сделать программу ешё быстрее.</p>
<p><strong><code>[[unsafe_deref]]</code></strong><br>аннотация для функций, которая “инлайнит” обращения по указателям.<br>Код из <a href="https://github.com/GaijinEntertainment/daScript/blob/a0fcdfdbf134d3dfb8055c9218c6e57ff4ae925b/src/ast/ast_simulate.cpp#L1023" target="_blank" rel="noopener">ast_simulate</a>:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">SimNode * <span class="title">ExprPtr2Ref::simulate</span> <span class="params">(Context &amp; context)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( unsafeDeref ) &#123;</span><br><span class="line">        <span class="comment">//симуляция выполнения ноды</span></span><br><span class="line">        <span class="keyword">return</span> subexpr-&gt;simulate(context);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//создание ноды для более поздней симуляции</span></span><br><span class="line">        <span class="keyword">return</span> context.code-&gt;makeNode&lt;SimNode_Ptr2Ref&gt;(at,subexpr-&gt;simulate(context));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong><code>Векторизация!</code></strong><br>В daScript есть встроенные векторные типы int4 и float4, и описание поля логичнее переделать на их использование:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;typedef Field &#x3D; int[16]</span><br><span class="line">typedef Field &#x3D; int4[4]</span><br></pre></td></tr></table></figure><br>Тогда горизонтальные сдвиги можно описать так:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def right(var v:Field; line: int)</span><br><span class="line">    var ans &#x3D; v</span><br><span class="line">    ans[line] &#x3D; ans[line].yzwx</span><br><span class="line">    return &lt;- ans</span><br><span class="line"></span><br><span class="line">def left(var v:Field; line: int)</span><br><span class="line">    var ans &#x3D; v</span><br><span class="line">    ans[line] &#x3D; ans[line].wxyz</span><br><span class="line">    return &lt;- ans</span><br></pre></td></tr></table></figure></p>
<p>Что 1) короче 2) очень быстро</p>
<p>Можно измерить скорость выполнения обычной и оптимизированной версии встроенным профайлером:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">profile(20, &quot;JamesBondUsual&quot;) &lt;|</span><br><span class="line">        for i in range(100)</span><br><span class="line">            var dif &lt;- extract(search())</span><br></pre></td></tr></table></figure></p>
<p>Получился прирост скорости ещё на 25% ( 0.4 -&gt; 0.3 миллисекунд за 100 запусков).<br>Код быстрой версии:</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        gist
    </div>
    <div class='spoiler-content'>
        <script src="//gist.github.com/5aba216fdf4aa70984c112cd4c6496df.js?file=james_bond_jr_fast.das"></script>
    </div>
</div>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script></div></article><div class="pagination"><a class="pagination__link pagination__prev" href="/blog/2301621444/">Позже</a><a class="pagination__link pagination__next" href="/blog/3006126295/">Раньше</a></div></main><footer class="footer metadata"><p class="footer__text">© 2022 spiiin</p><p class="footer__text">Powered by <a class="footer__text__link" href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a class="footer__text__link" href="https://pages.github.com/" target="_blank">Github Page</a></p></footer></div></body></html>