<!DOCTYPE html><html lang="ru"><head><meta charset="UTF-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Spiiin's blog | Game Engines - Rendering Abstraction Layer</title><meta name="description" content=""><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=PT+Serif&amp;display=swap"><link rel="stylesheet" href="/css/highlights/darkula.css"><link rel="stylesheet" href="/css/main.css"><link rel="search" type="application/opensearchdescription+xml" href="http://spiiin.github.io/atom.xml" title="Spiiin's blog"><script>(function (i, s, o, g, r, a, m) {
  i['GoogleAnalyticsObject'] = r;
  i[r] = i[r] || function () {
    (i[r].q = i[r].q || []).push(arguments)
  }, i[r].l = 1 * new Date();
  a = s.createElement(o),
    m = s.getElementsByTagName(o)[0];
  a.async = 1;
  a.src = g;
  m.parentNode.insertBefore(a, m)
})(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');
ga('create', 'UA-00000000-0', 'auto');
ga('send', 'pageview');</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-shiki-plugin@latest/lib/codeblock.css">
<style>:root{--hl-color:#abb2bf;--hl-bg:#282c34;--hltools-bg:#21252b;--hltools-color:#bbbbbc;--hlnumber-bg:#282c34;--hlnumber-color:#495162;--hlscrollbar-bg:#373c47;--hlexpand-bg:linear-gradient(180deg,rgba(40,44,52,0.1),rgba(40,44,52,0.9))}</style><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Spiiin's blog" type="application/atom+xml">
</head><body><div class="container"><header class="main-header"><h1 class="main-header__title uplize"><a class="main-header__title__link" href="/"><img class="header-image" src="/images/favicon.png" width="36" height="36">Spiiin's blog</a></h1><nav class="main-header__nav"><ul class="main-nav"><li class="main-nav__list"><a class="main-nav__list__link" href="/" target="_self">HOME</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/archives/" target="_self">ARCHIVE</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/tags/meta" target="_self">TAGS</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/blog/1" target="_self">ABOUT</a></li></ul></nav></header><main class="container__wrapper"><div class="pagination"><a class="pagination__link pagination__prev" href="/blog/3145708234/">Позже</a><a class="pagination__link pagination__next" href="/blog/770184585/">Раньше</a></div><article class="article post"><h3 class="article__title">Game Engines - Rendering Abstraction Layer</h3><div class="article__date metadata"><div class="post-info">2024/03/10</div></div><div class="article__tags metadata">Tags:
<a class="article__tags__link metadata" href="/tags/dev-method/">dev_method</a><a class="article__tags__link metadata" href="/tags/dev-evolution/">dev_evolution</a><a class="article__tags__link metadata" href="/tags/3d/">3d</a><a class="article__tags__link metadata" href="/tags/unreal/">unreal</a></div><div class="article__body"><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><ul>
<li><a href="/blog/2721099263/" title="Ещё о проектировании (движки и история)">Ещё о проектировании (движки и история)</a> — заметка о GameObject в движках</li>
</ul>
<h2><span id="scenegraph-false-start">SceneGraph (False start)</span><a href="#scenegraph-false-start" class="header-anchor">#</a></h2><p>GameObject-ы на сцене часто собраны в иерархию, которую нужно как-то отрисовывать на экране. Наивная идея — отрисовка дерева GameObject-ов в порядке обхода.</p>
<figure class="shiki cpp"><div class="codeblock"><div class="code"><pre class="shiki dracula"><code><span class="line"><span style="color: #FF79C6">class</span><span style="color: #F8F8F2"> </span><span style="color: #8BE9FD">GameObject</span><span style="color: #F8F8F2"> {</span></span>
<span class="line"><span style="color: #F8F8F2">    </span><span style="color: #FF79C6">void</span><span style="color: #F8F8F2"> </span><span style="color: #50FA7B">preRender</span><span style="color: #F8F8F2">();</span></span>
<span class="line"><span style="color: #F8F8F2">    </span><span style="color: #FF79C6">void</span><span style="color: #F8F8F2"> </span><span style="color: #50FA7B">render</span><span style="color: #F8F8F2">();</span></span>
<span class="line"><span style="color: #F8F8F2">    </span><span style="color: #FF79C6">void</span><span style="color: #F8F8F2"> </span><span style="color: #50FA7B">postRender</span><span style="color: #F8F8F2">();</span></span>
<span class="line"><span style="color: #F8F8F2">    TArray</span><span style="color: #FF79C6">&lt;</span><span style="color: #F8F8F2">GameObject</span><span style="color: #FF79C6">*&gt;</span><span style="color: #F8F8F2"> children;</span></span>
<span class="line"><span style="color: #F8F8F2">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F8F8F2">GameObject</span><span style="color: #FF79C6">::</span><span style="color: #50FA7B">preRender</span><span style="color: #F8F8F2">() {</span></span>
<span class="line"><span style="color: #6272A4">    //set render state</span></span>
<span class="line"><span style="color: #F8F8F2">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F8F8F2">GameObject</span><span style="color: #FF79C6">::</span><span style="color: #50FA7B">render</span><span style="color: #F8F8F2">() {</span></span>
<span class="line"><span style="color: #6272A4">    //render self</span></span>
<span class="line"><span style="color: #F8F8F2">    ...</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6272A4">    //render children</span></span>
<span class="line"><span style="color: #F8F8F2">    </span><span style="color: #FF79C6">for</span><span style="color: #F8F8F2"> (</span><span style="color: #FF79C6">auto</span><span style="color: #F8F8F2"> child : children) {</span></span>
<span class="line"><span style="color: #F8F8F2">        child</span><span style="color: #FF79C6">-&gt;</span><span style="color: #50FA7B">preRender</span><span style="color: #F8F8F2">();</span></span>
<span class="line"><span style="color: #F8F8F2">        child</span><span style="color: #FF79C6">-&gt;</span><span style="color: #50FA7B">render</span><span style="color: #F8F8F2">();</span></span>
<span class="line"><span style="color: #F8F8F2">        child</span><span style="color: #FF79C6">-&gt;</span><span style="color: #50FA7B">postRender</span><span style="color: #F8F8F2">();</span></span>
<span class="line"><span style="color: #F8F8F2">    }</span></span>
<span class="line"><span style="color: #F8F8F2">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F8F8F2">GameObject</span><span style="color: #FF79C6">::</span><span style="color: #50FA7B">postRender</span><span style="color: #F8F8F2">() {</span></span>
<span class="line"><span style="color: #6272A4">    //restore render state</span></span>
<span class="line"><span style="color: #F8F8F2">}</span></span></code></pre></div></div></figure>
<p>Имеет множество проблем в реализации даже для старых render api — различные алгоритмы требуют различных способов обхода сцены, не укладывающихся в единый граф (как для 2D сцен, так и для 3D). Возникают альтернативные Visitor-ы, списки, флаги управления порядком. Примеры задач:</p>
<ul>
<li>для оптимизации выполнения команд рендера данные могут не отправляться на отрисовку сразу, а группироваться (batching) — добавляются хранимые списки данных для рендера и условия синхронизации этих списков с основным обходом объектов</li>
<li>опция рендера в текстуру - ещё один проход или альтернативное состояние рендера</li>
<li>трики с блендингом, для которых необходимо изменить порядок вывода на обратный (<a href="/blog/887709799/" title="daScript. SFML, dasBox и спайны">daScript. SFML, dasBox и спайны</a>)</li>
<li>другие методы отрисовки, требующие изменения порядка — полупрозрачные объекты (до OIT), тени, зеркала</li>
<li>композиция нескольких из этих приёмов. НЕ решается тем, чтобы ввести наследника GameObject, который бы переопределил preRender/postRender и втыкать его в нужные места графа. Если и решается, то прикручиваением колоссального количества хаков проверки и хранения текущего состояния.</li>
</ul>
<p>Тем не менее, подход был достаточно живучий (и оживший на какое-то время с приходом ранних OpenGL ES и WebGL), судя по количеству обсуждений его вредности:<br><a target="_blank" rel="noopener" href="https://tomforsyth1000.github.io/blog.wiki.html#%5B%5BScene%20Graphs%20-%20just%20say%20no%5D%5D">Scene Graphs - just say no</a><br><a target="_blank" rel="noopener" href="http://diaryofagraphicsprogrammer.blogspot.com/2009/01/handling-scene-geometry.html">Handling Scene Geometry</a><br><a target="_blank" rel="noopener" href="https://www.stevestreeting.com/2009/01/05/spatialgraph-scenetree-renderqueue-sound-familiar/">SpatialGraph, SceneTree, RenderQueue - sound familiar?</a><br><a target="_blank" rel="noopener" href="https://solid-angle.blogspot.com/2009/01/animation-and-physics-sitting-in-tree.html">The world is not a SceneTree</a>, <a target="_blank" rel="noopener" href="https://solid-angle.blogspot.com/2009/01/world-is-not-scenetree.html">The world is not a SceneTree</a>, <a target="_blank" rel="noopener" href="https://solid-angle.blogspot.com/2009/01/characters-are-special-sort-of-tree-but.html">Characters are a special sort of tree but not a SceneTree</a>, <a target="_blank" rel="noopener" href="https://solid-angle.blogspot.com/2009/01/world-is-world.html">The world is… the world</a></p>
<h2><span id="spiski-komand-otrisovki">Списки команд отрисовки</span><a href="#spiski-komand-otrisovki" class="header-anchor">#</a></h2><p>Дизайн способа передачи данных отрисовки от игровых объектов к API видеокарты эволюционировал вместе с дизайном самих API отрисовки. Вместо отдельных команд переключения состояний и создания графических ресурсов постепенно появлялись буферы с данными (вершины, индексы, команды отрисовки) и команды отрисовки использующие эти буферы (“вот указатель на блоб данных, вот описание раскладки этих данных, выведи их”). </p>
<p>Соответственно, со стороны игрового движка так или иначе возникало формирование списка команд на отрисовку. Чаще отдельным слоем над графическим API (с названиями вроде Rendering Hardware Interface). Причины, по которым удобнее иметь отдельный уровень команд:</p>
<ul>
<li><strong>возможность отсортировать команды оптимальным образом перед передачей в графический API</strong> (или же в Data-Oriented style — заранее иметь фиксированный набор списков, в которые можно добавить объекты):<br>  <a target="_blank" rel="noopener" href="https://realtimecollisiondetection.net/blog/?p=86">Order your graphics draw calls around!</a> — пример обоих вариантов<br>  <a target="_blank" rel="noopener" href="https://bitsquid.blogspot.com/2017/02/stingray-renderer-walkthrough-4-sorting.html">Stingray Renderer Walkthrough #4: Sorting</a></li>
<li><strong>кеширование</strong><br>  <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=UJ6f1pm_sdU">Refactoring the Mesh Drawing Pipeline</a> — пайплайн в Unreal, добавляется ещё один этап кеширования команд отрисовки, статические меши могут не создавать команды каждый кадр повторно, чтобы не тратить время не повторное формирование команд<br>  <img src="/blog/1364570417/journey_of_draw.png" alt></li>
<li><strong>многопоточность</strong> — передачу состояния можно вынести в отдельный поток (а если потоков много, то ещё и отделить процесс декодирования из RHI-команд в списки команд графического API)<br>  <a target="_blank" rel="noopener" href="https://bitsquid.blogspot.com/2016/09/state-reflection.html">State reflection</a> — 2 класса, состояние и прокси для его передачи<br>  <a target="_blank" rel="noopener" href="https://github.com/donaldwuid/unreal_source_explained/blob/master/main/rendering.md">Unreal Source Explained, Rendering</a> — то же в Unreal, <code>UPrimitiveComponent-&gt;FPrimitiveSceneProxy-&gt;FPrimitiveSceneInfo</code> и другие</li>
<li><strong>разные стратегии на разных платформах</strong> — для различных платформ можно эмпирически настроить поведение, например, эмулировать устравшие immediate api,  подобрать оптимальный размер данных в очереди команд перед передачей на отрисовку (flush несколько раз за кадр), или настроить размер конвейера в зависимости от количества потоков (iOS - great single core/Android - many cores)<br>  <a target="_blank" rel="noopener" href="https://github.com/donaldwuid/unreal_source_explained/blob/master/main/rendering_parallel.md">Unreal Source Explained, Parallel Rendering</a> — настройки параллельного рендера в Unreal</li>
</ul>
<p>Получается API вроде такого:</p>
<figure class="shiki cpp"><div class="codeblock"><div class="code"><pre class="shiki dracula"><code><span class="line"><span style="color: #FF79C6">class</span><span style="color: #F8F8F2"> </span><span style="color: #8BE9FD">GameObject</span><span style="color: #F8F8F2"> {</span></span>
<span class="line"><span style="color: #F8F8F2">    ResourceHandler resHandler;</span></span>
<span class="line"><span style="color: #F8F8F2">    </span><span style="color: #FF79C6">void</span><span style="color: #F8F8F2"> </span><span style="color: #50FA7B">initResources</span><span style="color: #F8F8F2">(</span><span style="color: #8BE9FD; font-style: italic">RenderCommandList</span><span style="color: #F8F8F2"> </span><span style="color: #FFB86C; font-style: italic">cmdList</span><span style="color: #F8F8F2">) { resHandler </span><span style="color: #FF79C6">=</span><span style="color: #F8F8F2"> cmdList.</span><span style="color: #50FA7B">addCommand</span><span style="color: #F8F8F2">(CreateSomeResource{Parameters}); }</span></span>
<span class="line"><span style="color: #F8F8F2">    </span><span style="color: #FF79C6">void</span><span style="color: #F8F8F2"> </span><span style="color: #50FA7B">freeResourses</span><span style="color: #F8F8F2">(</span><span style="color: #8BE9FD; font-style: italic">RenderCommandList</span><span style="color: #F8F8F2"> </span><span style="color: #FFB86C; font-style: italic">cmdList</span><span style="color: #F8F8F2">) { cmdList.</span><span style="color: #50FA7B">addCommand</span><span style="color: #F8F8F2">(FreeResourceAsync{ resHandler }); }</span></span>
<span class="line"><span style="color: #F8F8F2">    </span><span style="color: #FF79C6">void</span><span style="color: #F8F8F2"> </span><span style="color: #50FA7B">render</span><span style="color: #F8F8F2">(</span><span style="color: #8BE9FD; font-style: italic">RenderCommandList</span><span style="color: #F8F8F2"> </span><span style="color: #FFB86C; font-style: italic">cmdList</span><span style="color: #F8F8F2">) { cmdList.</span><span style="color: #50FA7B">addCommand</span><span style="color: #F8F8F2">(DrawSomeResourceCommand { resHandler }); }</span></span>
<span class="line"><span style="color: #F8F8F2">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF79C6">class</span><span style="color: #F8F8F2"> </span><span style="color: #8BE9FD">RenderCommandList</span><span style="color: #F8F8F2"> {</span></span>
<span class="line"><span style="color: #6272A4">    //threading, commands optimization, and batching things</span></span>
<span class="line"><span style="color: #F8F8F2">    DelayedCommandListMT delayedCommands;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F8F8F2">    </span><span style="color: #FF79C6">void</span><span style="color: #F8F8F2"> </span><span style="color: #50FA7B">addCommand</span><span style="color: #F8F8F2">(</span><span style="color: #8BE9FD; font-style: italic">Command</span><span style="color: #F8F8F2"> </span><span style="color: #FFB86C; font-style: italic">cmd</span><span style="color: #F8F8F2">) {</span></span>
<span class="line"><span style="color: #F8F8F2">        </span><span style="color: #FF79C6">if</span><span style="color: #F8F8F2"> (</span><span style="color: #50FA7B">inRenderThread</span><span style="color: #F8F8F2">() </span><span style="color: #FF79C6">&amp;&amp;</span><span style="color: #F8F8F2"> </span><span style="color: #50FA7B">allowImmediate</span><span style="color: #F8F8F2">()) {</span></span>
<span class="line"><span style="color: #F8F8F2">            </span><span style="color: #50FA7B">translateCommandToRenderDevice</span><span style="color: #F8F8F2">(cmd);</span></span>
<span class="line"><span style="color: #F8F8F2">        }</span></span>
<span class="line"><span style="color: #F8F8F2">        </span><span style="color: #FF79C6">else</span><span style="color: #F8F8F2"> {</span></span>
<span class="line"><span style="color: #6272A4">            //maybe not just add, but also pre-process</span></span>
<span class="line"><span style="color: #F8F8F2">            delayedCommands.</span><span style="color: #50FA7B">addNew</span><span style="color: #F8F8F2">(</span><span style="color: #50FA7B">MOVE</span><span style="color: #F8F8F2">(cmd))</span></span>
<span class="line"><span style="color: #F8F8F2">        }</span></span>
<span class="line"><span style="color: #F8F8F2">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F8F8F2">    </span><span style="color: #FF79C6">void</span><span style="color: #F8F8F2"> </span><span style="color: #50FA7B">processDelayedCommands</span><span style="color: #F8F8F2">(){</span></span>
<span class="line"><span style="color: #F8F8F2">        </span><span style="color: #50FA7B">ENSURE_IN_RENDER_THREAD</span><span style="color: #F8F8F2">();</span></span>
<span class="line"><span style="color: #F8F8F2">        delayedCommands.</span><span style="color: #50FA7B">preprocessCommands</span><span style="color: #F8F8F2">();</span><span style="color: #6272A4"> //sort/optimize/fuse/batch</span></span>
<span class="line"><span style="color: #F8F8F2">        </span><span style="color: #FF79C6">for</span><span style="color: #F8F8F2"> (</span><span style="color: #FF79C6">auto</span><span style="color: #F8F8F2"> cmd: delayedCommands) {</span></span>
<span class="line"><span style="color: #F8F8F2">            </span><span style="color: #50FA7B">translateCommandToRenderDevice</span><span style="color: #F8F8F2">(cmd);</span></span>
<span class="line"><span style="color: #F8F8F2">        }</span></span>
<span class="line"><span style="color: #F8F8F2">    }</span></span>
<span class="line"><span style="color: #F8F8F2">}</span></span></code></pre></div></div></figure>
<p><a target="_blank" rel="noopener" href="https://medium.com/realities-io/creating-a-custom-mesh-component-in-ue4-part-1-an-in-depth-explanation-of-vertex-factories-4a6fd9fd58f2">Creating a Custom Mesh Component in UE4</a> — серия из 4х статей, про добавление в пайплайн своего компонента, и структур для его обработки.<br><a target="_blank" rel="noopener" href="https://medium.com/@lordned">Unreal Engine 4 Rendering</a> — ещё одна серия, небольшой обзор структур рендера.</p>
<h2><span id="intermediate-3d-api">Intermediate 3D API</span><a href="#intermediate-3d-api" class="header-anchor">#</a></h2><p>Так как графических API много и они разные, а движки часто хотят быть мультиплатформенными, то возникают попытки выделения нижнего уровня абстракции RHI в отдельные библиотеки-прослойки между DirectX 11/12/Vulkan/Metal/Opengl desktop/web/mobile. На этом уровне библиотека на заботится ни о чём, кроме быстрого формирования картинки из команд, не вникая в то, что представляют из себя эти команды (чем-то похоже на видеоплейеры).</p>
<p><a target="_blank" rel="noopener" href="https://alain.xyz/blog/comparison-of-modern-graphics-apis">A Comparison of Modern Graphics APIs</a><br><a target="_blank" rel="noopener" href="https://alextardif.com/RenderingAbstractionLayers.html">An Opinionated Post on Modern Rendering Abstraction Layers</a><br><a target="_blank" rel="noopener" href="http://www.gijskaerts.com/wordpress/?p=98">Musings on cross-platform graphics engine architectures</a> + <a target="_blank" rel="noopener" href="https://www.gijskaerts.com/wordpress/?p=112">Multi-threaded command recording and submission</a><br><a target="_blank" rel="noopener" href="https://www.gamedeveloper.com/programming/designing-a-modern-cross-platform-low-level-graphics-library">Designing a Modern Cross-Platform Low-Level Graphics Library</a><br><a target="_blank" rel="noopener" href="https://bitsquid.blogspot.com/2017/02/stingray-renderer-walkthrough.html">Stingray Renderer Walkthrough #5: RenderDevice</a></p>
<p><a target="_blank" rel="noopener" href="https://dev.to/funatsufumiya/comparison-of-c-low-level-graphics-cross-platform-frameworks-and-libraries-58e5#llgl-low-level-graphics-library">Comparison of C++ Low-Level Graphics, Cross-Platform Frameworks and Libraries</a> — обзор нескольких библиотек.</p>
<p><code>sokol</code><br><a target="_blank" rel="noopener" href="https://github.com/floooh/sokol">sokol-gfx</a> — thin-решение на C. Графическая обёртка отделена от всего, что только можно. Часто связанные с обёрткой решения выделены в отдельные библиотеки — <a target="_blank" rel="noopener" href="https://github.com/floooh/sokol-tools/">sokol-shdc</a> для кросс-платформенных шейдеров, транспилируемых в нативные языки (annotated GLSL -&gt; platform shaders + c header) и <a target="_blank" rel="noopener" href="https://github.com/floooh/oryol">oryol</a> для обёртки над окнами и IO.</p>
<p><code>bgfx</code><br><a target="_blank" rel="noopener" href="https://github.com/bkaradzic/bgfx">bgfx</a> — кроме составления списка команд, умеет их <a target="_blank" rel="noopener" href="https://bkaradzic.github.io/bgfx/internals.html">сортировать</a>, а также заполнять из нескольких потоков. Shaderc — компилятор шейдеров, надстройка на GLSL-like языком, транспилируемым в нативные языки.<br>Настраивается на использование с различными оконными обёртками (glfw/sdl/native os), имеет отдельные base-library <a target="_blank" rel="noopener" href="https://github.com/bkaradzic/bx/">bx</a> (обёртки над io/threads primitives/math/memory/hash) и <a target="_blank" rel="noopener" href="https://github.com/bkaradzic/bnet">bnet</a> (tcp protocol wrapper).</p>
<p><code>llgl</code><br><a target="_blank" rel="noopener" href="https://github.com/LukasBanana/LLGL">llgl</a> — еще одна thin-прослойка для большинства платформ, без window- и shader- слоёв (из-за чего в примерах 100500 вариантов шейдеров на всех языках). Многопоточный command buffer поддерживается только для OpenGL-wrapper (<a target="_blank" rel="noopener" href="https://github.com/LukasBanana/LLGL/blob/master/docu/GettingStarted/Getting%20Started%20with%20LLGL.pdf">не поддерживается</a> для DX12 и Vulkan). Имеет c-api для генерации привязок к языками (как и sokol/bgfx).</p>
<p><code>Diligent Engine</code><br><a target="_blank" rel="noopener" href="https://github.com/DiligentGraphics/DiligentCore">Diligent Engine Core</a> — декларирует полную поддержку новых API, и ограниченную поддержку старых. Поддерживает генерацию команд из нескольких потоков, и вшитую на низком уровне систему <a target="_blank" rel="noopener" href="http://diligentgraphics.com/diligent-engine/architecture/cross-platform/reference-counting/">Reference Counting</a>. Имеет C API для привязок к языкам (C++/C#). <a target="_blank" rel="noopener" href="https://github.com/DiligentGraphics/DiligentFX">DiligentFX</a> - high-level слой поверх Core. <a target="_blank" rel="noopener" href="http://diligentgraphics.com/">Блог</a> с обновлениями и описанием дизайна.</p>
<p><code>The Forge</code><br><a target="_blank" rel="noopener" href="https://github.com/ConfettiFX/The-Forge">The Forge</a> — open-source прослойка, industry-level качества, разработчики предлагают услуги по помощи в интеграции в существующие движки (примеры — Forza Motorspirt и Starfield). Больше оптимизаций, высокий порог для старта, постепенное обрастание необходимыми для движка системами, не связанными с прослойкой для рендера (скорее всего, связанное с потребностями компаний, интегрирующих библиотеку).</p>
<h2><span id="shader-abstraction">Shader abstraction</span><a href="#shader-abstraction" class="header-anchor">#</a></h2><p>Так как языки для описания шейдеров похожие, но чуть отличающиеся, и требуют описания соотвествующих им структур и кода на C++, то библиотеки используют мета-языки — надстройки над одним из базовых языков (GLSL/HLSL + транспиляция в другие базовые языки) и/или DSL/схемы данных, по которым генерируется код привязки параметров к шейдеру.</p>
<p>Также, шейдеры требуют оптимизаций, поэтому опциональные фичи рендера, которые могут присутствовать или отсутствовать в материале, генерируют различные варианты шейдеров (с включенным и выключенным вариантом фичи). Поскольку каждая новая опция вдвое увеличивает количество вариантов шейдеров, необходимо предусмотреть возможности заданий ограничений вариантов в тех частях движка, которые взаимодействуют с системой материалов (скомпилировать заранее все варианты быстро становится невозможным).<br><a target="_blank" rel="noopener" href="https://aras-p.info/blog/2017/02/05/Every-Possible-Scalability-Limit-Will-Be-Reached/">Every Possible Scalability Limit Will Be Reached</a> - эволюция системы материалов в Unity, от 5 вариантов шейдеров, до 100 миллиардов.</p>
<p>Идиомы систем материалов:</p>
<ul>
<li>code reuse (include-based)</li>
<li>uber-shader (substractive)</li>
<li>additive (nodes-based)</li>
<li>templates (material domain в unreal, surface shader в unity)</li>
</ul>
<p><img src="/blog/1364570417/destiny_shaders_small.png" alt><br><a target="_blank" rel="noopener" href="https://www.gdcvault.com/play/1024231/-Destiny-Shader">Destiny’ Shader Pipeline</a></p>
<p><a target="_blank" rel="noopener" href="https://aras-p.info/blog/2014/05/05/shader-compilation-in-unity-4-dot-5/">Shader compilation in Unity 4.5</a><br>GPU Pro 6 - Semantic-BasedShaderGenerationUsingShaderShaker</p>
<h2><span id="frame-graph">Frame Graph</span><a href="#frame-graph" class="header-anchor">#</a></h2><p>Отрисовка кадра игры состоит из большого количества этапов.</p>
<p>Примеры реверс-инжинирига пайплайна отрисовки кадра из различных игр:<br><a target="_blank" rel="noopener" href="http://www.adriancourreges.com/blog/2016/09/09/doom-2016-graphics-study/">DOOM (2016) - Graphics Study</a><br><a target="_blank" rel="noopener" href="https://80.lv/articles/world-of-tanks-graphical-update-technical-overview/">World of Tanks: Graphical Update Technical Overview</a><br><a target="_blank" rel="noopener" href="https://astralcode.blogspot.com/2018/11/reverse-engineering-rendering-of.html">Reverse engineering the rendering of The Witcher 3</a><br><a target="_blank" rel="noopener" href="https://godotengine.org/article/godot-3-renderer-design-explained">Godot 3’s Renderer Design Explained</a><br><a target="_blank" rel="noopener" href="http://www.adriancourreges.com/blog/2015/11/02/gta-v-graphics-study/">GTA V - Graphics Study</a><br><a target="_blank" rel="noopener" href="https://interplayoflight.wordpress.com/2017/10/25/how-unreal-renders-a-frame/amp/">How Unreal Renders a Frame</a><br><a target="_blank" rel="noopener" href="https://c0de517e.blogspot.com/2020/12/hallucinations-re-rendering-of.html">Hallucinations re: the rendering of Cyberpunk 2077</a><br><a target="_blank" rel="noopener" href="https://mamoniem.com/behind-the-pretty-frames-god-of-war/">Behind the Pretty Frames: God of War</a><br><a target="_blank" rel="noopener" href="https://gamedev.ru/community/gamedev_lecture/articles/?id=718">Oblivion</a><br><a target="_blank" rel="noopener" href="https://gamedev.ru/community/gamedev_lecture/articles/r_e_n_de_r">Stalker</a><br><a target="_blank" rel="noopener" href="https://www.elopezr.com/">https://www.elopezr.com/</a> — Mafia, Nanite, Jurassic World, Rise of Tomb Raider, Shadow of Mordor, Castlevania<br><a target="_blank" rel="noopener" href="https://users.livejournal.com/--vortex--/">https://users.livejournal.com/--vortex--/</a> — старенькое: Diablo 3, Starcraft 2, Jericho, Dirt, Company Of Heroes, Warhammer 40K: Dawn of War, Gothic 3, NFS Carbon, Painkiller, Flatout 2</p>
<p><a target="_blank" rel="noopener" href="https://github.com/GaijinEntertainment/DagorEngine/blob/main/samples/skiesSample/prog/test_app.cpp">skySample</a> - тестовый пример из DagorEngine, описание рендера кадра на ~2к строк.<br><a target="_blank" rel="noopener" href="https://github.com/ConfettiFX/The-Forge/blob/master/Examples_3/Aura/src/Aura.cpp">Aura</a> - аналогично из The-Forge, ~2к строк<br><a target="_blank" rel="noopener" href="https://www.gdcvault.com/play/1024612/FrameGraph-Extensible-Rendering-Architecture-in">FrameGraph: Extensible Rendering Architecture in Frostbite</a> - список проходов Battlefield 4<br><img src="/blog/1364570417/frame_graph_1_small.png" alt></p>
<p>В универсальных движках возможны также настраиваемые этапы или различные пайплайны для различных платформ, а также дополнительный отладочный вывод, что делает описание еще более сложным.</p>
<p><a target="_blank" rel="noopener" href="https://logins.github.io/graphics/2021/05/31/RenderGraphs.html">Why Talking About Render Graphs</a> — граф для описания этапов, и compile-time/runtime вычисления зависимостей используемых ресурсов меджу этапами.</p>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"Ov23liG1mZbiQOIdi91X","clientSecret":"e05812685eb741a752982b89dcf6f5b58dc10251","repo":"spiiin.github.io","owner":"spiiin","admin":["spiiin"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script></div></article><div class="pagination"><a class="pagination__link pagination__prev" href="/blog/3145708234/">Позже</a><a class="pagination__link pagination__next" href="/blog/770184585/">Раньше</a></div></main><footer class="footer metadata"><p class="footer__text">© 2024 spiiin</p><p class="footer__text">Powered by <a class="footer__text__link" href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a class="footer__text__link" href="https://pages.github.com/" target="_blank">Github Page</a></p></footer></div><!-- hexo injector body_end start -->
  <script>
  const CODE_CONFIG = {
    beautify: undefined,
    highlightCopy: undefined,
    highlightLang: undefined,
    highlightHeightLimit: undefined,
    isHighlightShrink: undefined,
    copy: {
      success: 'undefined',
      error: 'undefined',
      noSupport: 'undefined',
    }
  };
  console.log(
    `%c hexo-shiki-plugin %c v1.0.27 %c https://github.com/nova1751/hexo-shiki-plugin`,
    "color: #fff; background: #5f5f5f",
    "color: #fff; background: #80c8f8",
    ""
  );
  </script>
  <!-- hexo injector body_end end --></body></html>