<!DOCTYPE html><html lang="ru"><head><meta charset="UTF-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Spiiin's blog | daScript: обобщенное программирование</title><meta name="description" content=""><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=PT+Serif&amp;display=swap"><link rel="stylesheet" href="/css/highlights/darkula.css"><link rel="stylesheet" href="/css/main.css"><link rel="search" type="application/opensearchdescription+xml" href="http://spiiin.github.io/atom.xml" title="Spiiin's blog"><script>(function (i, s, o, g, r, a, m) {
  i['GoogleAnalyticsObject'] = r;
  i[r] = i[r] || function () {
    (i[r].q = i[r].q || []).push(arguments)
  }, i[r].l = 1 * new Date();
  a = s.createElement(o),
    m = s.getElementsByTagName(o)[0];
  a.async = 1;
  a.src = g;
  m.parentNode.insertBefore(a, m)
})(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');
ga('create', 'UA-00000000-0', 'auto');
ga('send', 'pageview');</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Spiiin's blog" type="application/atom+xml">
</head><body><div class="container"><header class="main-header"><h1 class="main-header__title uplize"><a class="main-header__title__link" href="/"><img class="header-image" src="/images/favicon.png" width="36" height="36">Spiiin's blog</a></h1><nav class="main-header__nav"><ul class="main-nav"><li class="main-nav__list"><a class="main-nav__list__link" href="/" target="_self">HOME</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/archives/" target="_self">ARCHIVE</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/tags/meta" target="_self">TAGS</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/blog/1" target="_self">ABOUT</a></li></ul></nav></header><main class="container__wrapper"><div class="pagination"><a class="pagination__link pagination__prev" href="/blog/3914071471/">Позже</a><a class="pagination__link pagination__next" href="/blog/1023396573/">Раньше</a></div><article class="article post"><h3 class="article__title">daScript: обобщенное программирование</h3><div class="article__date metadata"><div class="post-info">2023/01/21</div></div><div class="article__tags metadata">Tags:
<a class="article__tags__link metadata" href="/tags/dascript/">dascript</a></div><div class="article__body"><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Обобщенное программирование — одна из серых, но важных и интересных сторон daScript. “Серость” темы связана с тем, что, во-первых, система типов не очень детально описана в документации, во-вторых — в рассуждениях о типизации можно от практики быстро уйти в дебри академических терминов, в-третьих, тема плохо укладывается в голову C++-программисту.</p>
<p>Поддержка обобщенного программирования в языке, если “на пальцах” — совокупность способов вызывать одну функцию для разных типов.</p>
<h2 id="Перегрузка-функций"><a href="#Перегрузка-функций" class="headerlink" title="Перегрузка функций"></a>Перегрузка функций</h2><p>Перегруженные функции (ad-hoc полиморфизм) — простейший способ определить функцию для двух различных типов</p>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">def func(a : int)</span><br><span class="line">    print(<span class="string">"&#123;a&#125;\n"</span>)</span><br><span class="line">def func(a : float)</span><br><span class="line">    print(<span class="string">"&#123;a&#125;\n"</span>)</span><br><span class="line">[export]</span><br><span class="line">def main</span><br><span class="line">    func(<span class="number">1</span>)</span><br><span class="line">    func(<span class="number">1.0</span>f)</span><br></pre></td></tr></table></figure>
<p><strong><code>Константность</code></strong></p>
<p>Напечатаем тип параметра-аргумента:<br><figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">def func(a : int)</span><br><span class="line">    print(<span class="string">"&#123;typeinfo(typename a)&#125;\n"</span>)</span><br><span class="line"><span class="comment">//Output:</span></span><br><span class="line">int const</span><br></pre></td></tr></table></figure></p>
<p>По умолчанию к типу был добавлен спецификатор <code>const</code>, который не позволяет поменять значение аргумента. Его можно убрать, добавив ключевое слово <code>var</code>:<br><figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">def func(var a: int)</span><br><span class="line">    print(<span class="string">"&#123;typeinfo(typename a)&#125;\n"</span>)</span><br><span class="line"><span class="comment">//Output</span></span><br><span class="line">int</span><br></pre></td></tr></table></figure></p>
<p>При выборе перегрузки, константная и неконстантная версия, в отличие от C++, не имеют приоритета друг перед другом и при нахождении двух вариантов функции <code>daScript</code> выдаст ошибку (<a href="https://dascript.org/doc/reference/language/functions.html#function-overloading" target="_blank" rel="noopener">Правила выбора функции</a>).<br><figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">var a: int</span><br><span class="line">func(a)</span><br><span class="line"><span class="comment">//Output</span></span><br><span class="line"><span class="number">30304</span>: too many matching functions <span class="keyword">or</span> generics func</span><br><span class="line">candidates:</span><br><span class="line">        func ( a : int const ) : <span class="keyword">void</span> at generics.das:<span class="number">3</span>:<span class="number">4</span> <span class="comment">//принимает int и int const</span></span><br><span class="line">        func ( a : int -const ) : <span class="keyword">void</span> at generics.das:<span class="number">9</span>:<span class="number">4</span> <span class="comment">//-const читается как "удалить у типа спецификатор const"</span></span><br></pre></td></tr></table></figure></p>
<p>Для того, чтобы daScript различил функции, можно добавить <a href="https://dascript.org/doc/reference/language/generic_programming.html#type-contracts-and-type-operations" target="_blank" rel="noopener">спецификатор типа</a> <code>== const</code> (“константность аргумента должна совпадать).<br><figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">def func(a : int ==const)</span><br><span class="line">    print(<span class="string">"&#123;typeinfo(typename a)&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line">def func(var a : int ==const)</span><br><span class="line">    print(<span class="string">"&#123;typeinfo(typename a)&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line">[export]</span><br><span class="line">def main</span><br><span class="line">    var a: int</span><br><span class="line">    func(a)</span><br><span class="line">    func(<span class="number">1</span>)</span><br><span class="line"><span class="comment">//Output:</span></span><br><span class="line">int ==const</span><br><span class="line">int const ==const</span><br></pre></td></tr></table></figure></p>
<p><strong><code>Ссылки</code></strong></p>
<p>В предыдущем примере аргумент передавался по значению, поэтому даже <code>var int</code> не позволяет изменить переданную переменную (меняется <strong>значение аргумента</strong>, а не оригинальная переменная). Возможно передать аргумент по ссылке:<br><figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">def func(var a : int&amp;)</span><br><span class="line">    a = <span class="number">42</span></span><br><span class="line"></span><br><span class="line">[export]</span><br><span class="line">def main</span><br><span class="line">    var a: int</span><br><span class="line">    func(a)</span><br><span class="line">    print(<span class="string">"&#123;a&#125;\n"</span>)</span><br><span class="line"><span class="comment">//Output: 42</span></span><br></pre></td></tr></table></figure></p>
<p><strong> Все непримитивные типы передаются по ссылке, независимо от того, был ли описан аргумент со спецификатором <code>&amp;</code> или без него. </strong></p>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> A</span><br><span class="line">    a : int</span><br><span class="line"></span><br><span class="line">def func(var arg : A)</span><br><span class="line">    arg.a = <span class="number">42</span></span><br><span class="line">    print(<span class="string">"&#123;typeinfo(typename arg)&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line">[export]</span><br><span class="line">def main</span><br><span class="line">    var a : A</span><br><span class="line">    func(a)</span><br><span class="line">    print(<span class="string">"&#123;a&#125;\n"</span>)</span><br><span class="line"><span class="comment">//Output</span></span><br><span class="line">A</span><br><span class="line">[[ <span class="number">42</span>]]</span><br></pre></td></tr></table></figure>
<p><em>(причём можно описать 2 перегруженные функции с аргуметами типа A и A&amp;, несмотря на то, что для структур семантически это будет идентичная запись)</em></p>
<p>При этом, как и с константностью, компилятор не различает приоритета перегрузки функций с аргументом-ссылкой и значением, и выдаёт ошибку неоднозначности разрешения перегрузки.</p>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">def func(var a: int)</span><br><span class="line">    pass</span><br><span class="line">def func(var a : int&amp;)</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">[export]</span><br><span class="line">def main</span><br><span class="line">    func(<span class="number">1</span>) <span class="comment">//ok</span></span><br><span class="line">    var a: int</span><br><span class="line">    func(a) <span class="comment">//30304: too many matching functions or generics func</span></span><br><span class="line">            <span class="comment">//candidates:</span></span><br><span class="line">            <span class="comment">//func ( a : int -const ) : void at generics.das:1:4</span></span><br><span class="line">            <span class="comment">//func ( a : int&amp; -const ) : void at generics.das:3:4</span></span><br></pre></td></tr></table></figure>
<p><strong><code>Контракты</code></strong></p>
<p>Макросы работают раньше разрешения перегрузки, что позволяет реализовать паттерн <a href="https://github.com/GaijinEntertainment/daScript/blob/e7992b384dad13c1a201f9eee1c6a6ae1e0cf8b8/daslib/contracts.das" target="_blank" rel="noopener">contracts</a> — произвольную функцию, которая предварительно проверяет тип аргументов:</p>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">require daslib/contracts</span><br><span class="line"></span><br><span class="line">[!expect_ref(arg)]</span><br><span class="line">def func(var arg : int)</span><br><span class="line">    print(<span class="string">"&#123;typeinfo(typename arg)&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line">[expect_ref(arg)]</span><br><span class="line">def func(var arg : int&amp;)</span><br><span class="line">    print(<span class="string">"&#123;typeinfo(typename arg)&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line">[export]</span><br><span class="line">def main</span><br><span class="line">    var a: int</span><br><span class="line">    func(a)</span><br><span class="line">    func(<span class="number">1</span>)</span><br><span class="line"><span class="comment">//Output:</span></span><br><span class="line">int <span class="comment">//must be int&amp;</span></span><br><span class="line">int</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/GaijinEntertainment/daScript/blob/master/examples/test/misc/contracts_example.das" target="_blank" rel="noopener">https://github.com/GaijinEntertainment/daScript/blob/master/examples/test/misc/contracts_example.das</a><br><em>вывод typeinfo, кажется, содержит <a href="https://github.com/GaijinEntertainment/daScript/issues/393" target="_blank" rel="noopener">баг</a></em></p>
<p><strong><code>Временные ссылки</code></strong></p>
<p>Кроме обычных ссылок в daScript есть временные ссылки, которые позволяют работать с объектами из C++-кода внутри блоков. Временная ссылка доступна только внутри блока, и не может быть сохранена вне его (но может быть передана в другую функцию, принимающую временные объекты).</p>
<p>Рассмотрим для примера C++ тип <code>Color</code> из <a href="https://github.com/GaijinEntertainment/daScript/blob/master/examples/tutorial/tutorial03.cpp#L15" target="_blank" rel="noopener">туториала к daScript</a>. Для него создаётся daScript-обёртка, в которую можно добавить декларацию конструктора и инициализатора с помощью паттерна <code>using</code> — в этом случае можно создать временную ссылку на тип, которая будет доступна только внутри блока: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//cpp</span></span><br><span class="line">Module_Tutorial03() : Module(<span class="string">"tutorial_03"</span>) &#123;   <span class="comment">// module name, when used from das file</span></span><br><span class="line">    ModuleLibrary lib;</span><br><span class="line">    ...</span><br><span class="line">    addCtorAndUsing&lt;Color&gt;(*<span class="keyword">this</span>, lib, <span class="string">"Color"</span>, <span class="string">"Color"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//das</span></span><br><span class="line"></span><br><span class="line">require tutorial_03</span><br><span class="line"></span><br><span class="line">def printColor(c : Color) <span class="comment">//same as Color&amp; as c is struct</span></span><br><span class="line">    print(<span class="string">"&#123;typeinfo(typename c)&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line">def printColor(c : Color#)</span><br><span class="line">    print(<span class="string">"&#123;typeinfo(typename c)&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line">[export]</span><br><span class="line">def test</span><br><span class="line">    <span class="keyword">let</span> c = [[Color]]</span><br><span class="line">    printColor(c)</span><br><span class="line">    using() &lt;| $(var c_temp : Color#)</span><br><span class="line">        printColor(c_temp)</span><br><span class="line"><span class="comment">//Output</span></span><br><span class="line">tutorial_03::Color const</span><br><span class="line">tutorial_03::Color const#</span><br></pre></td></tr></table></figure>
<p><strong>Если тип нельзя <a href="https://github.com/GaijinEntertainment/daScript/commit/9521fdba38c4f5ea422450c6b4979cc2808f58ef" target="_blank" rel="noopener">скопировать или переместить</a>, то <code>using</code> не будет не будет создавать временный тип — аргумент и так не сможет покинуть блок</strong></p>
<p>Чаще всего нет необходимости в раздельной обработке обычных и временных ссылок, в этом случае можно добавить к типу аргумента спецификатор <code>implicit</code>:</p>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">def printColor(c:Color implicit)</span><br><span class="line">    print(<span class="string">"&#123;typeinfo(typename c)&#125;\n"</span>)</span><br><span class="line"><span class="comment">//Output</span></span><br><span class="line">tutorial_03::Color const implicit</span><br><span class="line">tutorial_03::Color const implicit</span><br></pre></td></tr></table></figure>
<p>Небольшое отличие в том, как будет трактоваться аргумент:<br><figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">def printColor(c:Color implicit)    <span class="comment">// accepts Color and Color#, a will be treated as Color</span></span><br><span class="line">def printColor(c:Color# implicit)   <span class="comment">// accepts Color and Color#, a will be treated as Color#</span></span><br></pre></td></tr></table></figure></p>
<p><strong><code>Указатели</code></strong></p>
<p>Как и в C++, указатели — это ссылки, которые могут указывать на <code>null</code>, также имеют чуть другую семантику, что позволяет уже без шаманства иметь перегрузки для значения и указателя.</p>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">require daslib/safe_addr</span><br><span class="line"></span><br><span class="line">def func(var a: int)</span><br><span class="line">    print(<span class="string">"&#123;typeinfo(typename a)&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line">def func(var a: int?)</span><br><span class="line">    print(<span class="string">"&#123;typeinfo(typename a)&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line">[export]</span><br><span class="line">def main</span><br><span class="line">    var a: int</span><br><span class="line">    var a_ptr: int? = safe_addr(a)</span><br><span class="line">    func(a)</span><br><span class="line">    func(a_ptr)</span><br><span class="line"><span class="comment">//Output</span></span><br><span class="line">int</span><br><span class="line">int?</span><br></pre></td></tr></table></figure>
<p><strong><code>Приведение базовых типов</code></strong></p>
<p>Базовые типы не приводятся друг другу неявно, требуется явный вызов конструктора типа (<em>Explicit is better than implicit</em>).</p>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">def func(a : int) &#123;&#125;</span><br><span class="line">def func(a : float) &#123;&#125;</span><br><span class="line">def func(a : int4) &#123;&#125;</span><br><span class="line">def func(a : bool) &#123;&#125;</span><br><span class="line">def func(a : uint) &#123;&#125;</span><br><span class="line">def func(a : int64) &#123;&#125;</span><br><span class="line"></span><br><span class="line">[export]</span><br><span class="line">def main</span><br><span class="line">    func(<span class="number">1</span>) <span class="comment">//int</span></span><br><span class="line">    func(float(<span class="number">1</span>)); func(<span class="number">1.0</span>f) <span class="comment">//float</span></span><br><span class="line">    func(int4(<span class="number">1</span>)) <span class="comment">//int4</span></span><br><span class="line">    func(<span class="keyword">true</span>) <span class="comment">//bool</span></span><br><span class="line">    func(uint(<span class="number">1</span>)); func(<span class="number">1</span>u); func(<span class="number">0x1</span>) <span class="comment">//uint</span></span><br><span class="line">    func(int64(<span class="number">1</span>)); func(<span class="number">1</span>l) <span class="comment">//int64</span></span><br></pre></td></tr></table></figure>
<p><strong><code>Приведение классов/структур</code></strong></p>
<p>Для типов, поддерживающих наследование, неявно выполняется приведение указателей и ссылок от дочернего к родительскомму типу (<a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle" target="_blank" rel="noopener">LSP</a>).</p>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> A </span><br><span class="line">    a : int</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> B : A</span><br><span class="line">    b : int</span><br><span class="line"></span><br><span class="line">def func(a : A)</span><br><span class="line">    print(<span class="string">"&#123;typeinfo(typename a)&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line">[export]</span><br><span class="line">def main</span><br><span class="line">    var a : A</span><br><span class="line">    var b : B</span><br><span class="line">    func(a)</span><br><span class="line">    func(b)</span><br><span class="line"><span class="comment">//Output:</span></span><br><span class="line">A const</span><br><span class="line">A const</span><br></pre></td></tr></table></figure>
<p>Приведение типов структур (<code>cast/upcast/reinterpret</code>):<br><figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">var a : A</span><br><span class="line">var b : B</span><br><span class="line"></span><br><span class="line">var refA : A&amp; = a</span><br><span class="line">var refB : B&amp; = b</span><br><span class="line"></span><br><span class="line"><span class="comment">//downcast, safe</span></span><br><span class="line">refA = cast&lt;A&amp;&gt; refB </span><br><span class="line"><span class="comment">//upcase, unsafe</span></span><br><span class="line">unsafe</span><br><span class="line">    refB = <span class="keyword">upcast</span>&lt;B&amp;&gt; refA</span><br><span class="line"><span class="comment">//reinterpret cast, VERY unsafe, can cast any</span></span><br><span class="line">unsafe</span><br><span class="line">    refA = reinterpret&lt;A&amp;&gt;(<span class="number">1</span>) <span class="comment">//will crash</span></span><br></pre></td></tr></table></figure></p>
<p><strong>При выборе перегрузки функции выбирается та, для которой нужно выполнить наименьшее количество преобразований (при равном количестве daScript выдаст ошибку неоднозначности выбора)</strong></p>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> A </span><br><span class="line">    a : int</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> B : A</span><br><span class="line">    b: int</span><br><span class="line"></span><br><span class="line">def func(var a : A?)</span><br><span class="line">    print(<span class="string">"a: &#123;typeinfo(typename a)&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line">def func(var b : B?)</span><br><span class="line">    print(<span class="string">"b: &#123;typeinfo(typename b)&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line">def func4(var a,b,c,d: A?)</span><br><span class="line">    print(<span class="string">"AAAA\n"</span>)</span><br><span class="line"></span><br><span class="line">def func4(var a,b,c: A?; var d: B?)</span><br><span class="line">    print(<span class="string">"AAAB\n"</span>)</span><br><span class="line"></span><br><span class="line">def func4(var a,b : A?; var c: B?; var d: A?)</span><br><span class="line">    print(<span class="string">"AABA\n"</span>)</span><br><span class="line"></span><br><span class="line">def func4(var a,b,c,d: B?)</span><br><span class="line">    print(<span class="string">"BBBB\n"</span>)</span><br><span class="line"></span><br><span class="line">[export]</span><br><span class="line">def main</span><br><span class="line">    <span class="comment">//simple cases</span></span><br><span class="line">    var refA = <span class="keyword">new</span> A()</span><br><span class="line">    func(refA) <span class="comment">//a: A?</span></span><br><span class="line">    var refB = <span class="keyword">new</span> B()</span><br><span class="line">    func(refB) <span class="comment">//b: B?</span></span><br><span class="line">    var refAB = cast&lt;A?&gt; <span class="keyword">new</span> B()</span><br><span class="line">    func(refAB) <span class="comment">//a: A?</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//advanced cases</span></span><br><span class="line">    func4(refA, refA, refA, refA) <span class="comment">//shortest LSP to AAAA = 0</span></span><br><span class="line">    func4(refA, refA, refA, refB) <span class="comment">//shortest LSP to AAAB = 0</span></span><br><span class="line">    <span class="comment">//func4(refA, refA, refB, refB) //shortest LSP to AAAB/AABA = 1, conflict error</span></span><br><span class="line">    func4(refA, refB, refB, refA) <span class="comment">//shortest LSP to AABA = 1</span></span><br><span class="line">    func4(refB, refB, refB, refB) <span class="comment">//shortest LSP to BBBB = 0</span></span><br></pre></td></tr></table></figure>
<p><strong><code>explicit</code></strong></p>
<p>Для того, чтобы отключить LSP приведение типа аргумента, можно добавить ключевое слово <code>explicit</code>. Так </p>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> A </span><br><span class="line">    a : int</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> B : A</span><br><span class="line">    b : int</span><br><span class="line"></span><br><span class="line">def func(var a : A explicit)</span><br><span class="line">    print(<span class="string">"&#123;typeinfo(typename a)&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line">[export]</span><br><span class="line">def main</span><br><span class="line">    var a : A</span><br><span class="line">    var b : B</span><br><span class="line">    func(a)   <span class="comment">//A</span></span><br><span class="line">    <span class="comment">//func(b) //invalid argument a (0). expecting A explicit -const, passing B&amp; -const</span></span><br></pre></td></tr></table></figure>
<p><strong><code>Приведение generic-типов</code></strong></p>
<p>В документации не описана работа с generic-типами (и не дано общее определение для них, также пока отсутствует возможность создания своих типов), но поиском по коду находятся такие встроенные типы (исключая те, которые связаны с оператором typeinfo и кастами):</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Функциональные объекты:</span><br><span class="line">block</span><br><span class="line">function</span><br><span class="line">lambda</span><br><span class="line"></span><br><span class="line">Коллекции:</span><br><span class="line">array</span><br><span class="line">table&lt;key&gt;</span><br><span class="line">table&lt;key, value&gt;</span><br><span class="line"></span><br><span class="line">iterator</span><br><span class="line">generator</span><br><span class="line">smart_ptr</span><br><span class="line">tuple</span><br><span class="line">variant</span><br></pre></td></tr></table></figure>
<p>Для таких типов, возможно явное LSP-приведение для типов их аргументов (<code>ковариантность</code>). Пример для функций:</p>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> A </span><br><span class="line">    a : int</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> B : A</span><br><span class="line">    b : int</span><br><span class="line"></span><br><span class="line">def func1(var a : A)</span><br><span class="line">    print(<span class="string">"a\n"</span>)</span><br><span class="line"></span><br><span class="line">def func2(var b : B)</span><br><span class="line">    print(<span class="string">"b\n"</span>)</span><br><span class="line"></span><br><span class="line">def highOrder(func: <span class="keyword">function</span>&lt;(var a:A):<span class="keyword">void</span>&gt;)</span><br><span class="line">    invoke(func, [[B]])</span><br><span class="line"></span><br><span class="line">[export]</span><br><span class="line">def main</span><br><span class="line">    highOrder(@@func1)</span><br><span class="line">    highOrder(cast&lt;<span class="keyword">function</span>&lt;(var a:A):<span class="keyword">void</span>&gt;&gt; @@func2) <span class="comment">//возможно привести тип function&lt;(var b:B):void&gt; к function&lt;(var a:A):void&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="Generic-функции"><a href="#Generic-функции" class="headerlink" title="Generic-функции"></a>Generic-функции</h2><p>Вернёмся к самому первому примеру — если мы хотим написать функцию, семантически одинаково обрабатывающую различные типы (например, выводящую значение типа с помощью функции <code>print</code>) для типов. Чтобы не реализовывать её для каждого нового типа, в языках программирования используется понятие generic-функций, которые могут производить конкретные функции для новых типов автоматически.</p>
<p><a href="https://habr.com/ru/company/piter/blog/656377/" target="_blank" rel="noopener">Обзор реализаций в языках</a>.</p>
<p>Шаблонные функции в C++ производят код конкретных функций на уровне текста, который отдаётся компилятору (если не ошибаюсь, компилятор visual studio в этом плане действительно генерирует полные копии, не остлеживаю возможных повторов, чтобы иметь больше простора для частных оптимизаций функции под конкретные типы, а clang чуть раньше начинает отслеживать потенциально идентичные реализации для экономии памяти).</p>
<p>Другой возможный вариант реализации в Java — “изображать” generic на высоком уровне для контроля типов, но оставлять одну реализацию (все объекты передаются по ссылке, добавляется overhead при работе с value-типами по боксингу/анбоксингу в обёртку).</p>
<p>Третий путь из C# — добавить поддержку generic-функций в виртуальную машину, в этом случае возможна комбинированная реализация — value-типы получают свои сгенерированные копии функций, а reference-типы — общую функцию. Также возможно инстанцировать новые версии функций в runtime. daScript близок к такому типу реализации generic-функций.</p>
<p><strong><code>Автоматический вывод типов</code></strong></p>
<p>Если не указан тип аргумента функции, daScript выводит его автоматически, пример функции id принимающей аргумент любого типа и возвращающий его:</p>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">options log=<span class="keyword">true</span>, optimize=<span class="keyword">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> S1</span><br><span class="line">    a: int</span><br><span class="line"><span class="keyword">struct</span> S2</span><br><span class="line">    a: int</span><br><span class="line"></span><br><span class="line">def id(T)</span><br><span class="line">    <span class="keyword">return</span> T</span><br><span class="line"></span><br><span class="line">[export]</span><br><span class="line">def main</span><br><span class="line">    <span class="keyword">let</span> a = id(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">let</span> b = id(<span class="number">1.0</span>f)</span><br><span class="line">    <span class="keyword">let</span> c = id([[S1]])</span><br><span class="line">    <span class="keyword">let</span> d = id([[S2]])</span><br><span class="line"><span class="comment">//Output</span></span><br><span class="line"></span><br><span class="line">def `id ( T:int const explicit ) : int const</span><br><span class="line">        <span class="keyword">return</span> T</span><br><span class="line"></span><br><span class="line">def `id ( T:float const explicit ) : float const</span><br><span class="line">        <span class="keyword">return</span> T</span><br><span class="line"></span><br><span class="line">def `id ( T:S1 const explicit ) : S1 const</span><br><span class="line">        <span class="keyword">return</span> T</span><br><span class="line"></span><br><span class="line">def `id ( T:S2 const explicit ) : S2 const</span><br><span class="line">        <span class="keyword">return</span> T</span><br><span class="line"></span><br><span class="line">def <span class="keyword">public</span> main</span><br><span class="line">        <span class="keyword">let</span> a:int const = __::`id(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">let</span> b:float const = __::`id(<span class="number">1</span>f)</span><br><span class="line">        <span class="keyword">let</span> c:S1 const = __::`id([[S1 ]])</span><br><span class="line">        <span class="keyword">let</span> d:S2 const = __::`id([[S2 ]])</span><br></pre></td></tr></table></figure>
<p>По выводу текста сгенерированной программы понятна реализация. Символы подчёркивания перед именем функции <code>__::id</code> означают “взять реализацию функции только из текущего модуля” (<a href="https://dascript.org/doc/reference/language/modules.html#module-function-visibility" target="_blank" rel="noopener">линк</a>), идея будет рассмотрена далее.</p>
<p>Большая часть фич, связанных с generic-функциями, связана с тем, чтобы так или иначе задать или использовать информацию о типах.</p>
<p><strong><code>auto</code></strong></p>
<p>Определение для id более развернуто выглядит так:<br><figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">def id(a:auto): auto</span><br><span class="line">    <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure></p>
<p>Такая форма синтаксиса позволяет задать для каждого из выводимых типов псевдоним, который можно использовать для сравнения типа или получения rtti информации. Несколько примеров:</p>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//print typename</span></span><br><span class="line">def func(a : auto(T))</span><br><span class="line">    print(<span class="string">"&#123;typeinfo(typename type&lt;T&gt;)&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//generic sum, a and b must be same type</span></span><br><span class="line">def sum(a, b : auto(T))</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br></pre></td></tr></table></figure>
<p><strong><code>Использование типа в качестве аргумента</code></strong></p>
<p>Можно передать информацию о типе в качестве аргумента шаблона, как обычный <code>auto</code> аргумент.</p>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//generic linear interpolation between int types via cast to float type</span></span><br><span class="line">def lerpi(a, b : auto(IntType); part : float; tempCastType : auto(CastType))</span><br><span class="line">    <span class="keyword">return</span> IntType(CastType(a) + CastType(b - a) * part)</span><br><span class="line">print(<span class="string">"&#123;lerpi(int2(0, 0), int2(4, 4), 0.5f, type&lt;float2&gt;)&#125;\n"</span>) <span class="comment">// (2,2)</span></span><br><span class="line">print(<span class="string">"&#123;lerpi(int3(1, 2, 3), int3(2, 4, 7), 0.5f, type&lt;float3&gt;)&#125;\n"</span>) <span class="comment">// (1,3,5)</span></span><br></pre></td></tr></table></figure>
<p>Для того, чтобы тип не передавался в runtime, существует макрос <a href="https://github.com/GaijinEntertainment/daScript/blob/master/daslib/templates.das#L41" target="_blank" rel="noopener">template</a>, который в compile-time убирает такие аргументы.</p>
<p><strong><code>Шаблоны для auto</code></strong></p>
<p>Различные формы <a href="https://dascript.org/doc/reference/language/generic_programming.html#type-contracts-and-type-operations" target="_blank" rel="noopener">ограчений</a> для типов аргументов auto. Примеры из доки</p>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">def foo( a : auto&amp;)           <span class="comment">// accepts any type, passed by reference</span></span><br><span class="line">def foo( a : auto[])          <span class="comment">// accepts static array of any type of any size</span></span><br><span class="line">def foo( a : array&lt;auto -const&gt;)  <span class="comment">// matches any array, with non-const elements</span></span><br><span class="line"><span class="comment">//some tests</span></span><br><span class="line">def foo(a: tuple&lt;auto; auto; auto&gt;) <span class="comment">//tuple of 3 elements, any type</span></span><br><span class="line">def foo(a: <span class="keyword">function</span>&lt;(a : auto) : auto&gt;) <span class="comment">//any function with 1 argument</span></span><br><span class="line">def foo(a: table&lt;int; auto&gt;) <span class="comment">//any tables with int keys</span></span><br></pre></td></tr></table></figure>
<p>Еще раз приведу <a href="https://dascript.org/doc/reference/language/functions.html#function-overloading" target="_blank" rel="noopener">ссылку</a> на правила выбора функций при наличии нескольких специализаций и перегрузок.</p>
<p><strong><code>Контракты</code></strong></p>
<p>Так же, как и к аргументам обычным функциям, к аргументам generic-функциям могут быть применены контракты, позволяющие в более общем виде описать ограничения для типа аргумента. Именно c generic-функциями видна вся мощь контрактов.</p>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">require daslib/contracts</span><br><span class="line"></span><br><span class="line"><span class="comment">//accept any functions</span></span><br><span class="line">[expect_any_function(a)]</span><br><span class="line">def foo(a: auto(T))</span><br><span class="line">    print(<span class="string">"&#123;typeinfo(typename type&lt;T&gt;)&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//accept any tuples</span></span><br><span class="line">[expect_any_tuple(a)]</span><br><span class="line">def bar(a:auto(T))</span><br><span class="line">    print(<span class="string">"&#123;typeinfo(typename type&lt;T&gt;)&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line">[export]</span><br><span class="line">def main</span><br><span class="line">    foo(@@(a : int) =&gt; a)                       <span class="comment">//function&lt;(a:int const):int const&gt; const</span></span><br><span class="line">    foo(@@(a : int; b: float) =&gt; <span class="string">"hello world"</span>) <span class="comment">//function&lt;(a:int const;b:float const):string const&gt; const</span></span><br><span class="line">    bar([[auto <span class="number">1</span> ,<span class="number">2.0</span>f, <span class="string">"test"</span>]])               <span class="comment">//tuple&lt;int;float;string&gt; const</span></span><br><span class="line">    bar([[auto <span class="number">1</span>, <span class="number">1</span>]])                          <span class="comment">//tuple&lt;int;int&gt; const</span></span><br></pre></td></tr></table></figure>
<p>Контракты для одного аргумента могут комбинироваться с помощью операторов !, &amp;&amp;, || и ^^</p>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">require daslib/contracts</span><br><span class="line"></span><br><span class="line">[expect_any_function(arg) || expect_any_tuple(arg)]</span><br><span class="line">def func_or_tuple(var arg : auto)</span><br><span class="line">    print(<span class="string">"&#123;typeinfo(typename arg)&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//expect_any_array разрешает любые массивы, expect_dim - статические массивы</span></span><br><span class="line">[expect_any_array(arg) &amp;&amp; !expect_dim(arg)]</span><br><span class="line">def array_and_notdim(var arg : auto)</span><br><span class="line">    print(<span class="string">"&#123;typeinfo(typename arg)&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line">[export]</span><br><span class="line">def main</span><br><span class="line">    func_or_tuple(@@(a : int) =&gt; a)</span><br><span class="line">    func_or_tuple([[auto <span class="number">1</span>, <span class="number">2.0</span>, <span class="string">"3"</span>]])</span><br><span class="line"></span><br><span class="line">    array_and_notdim([&#123; int[] <span class="number">1</span>;<span class="number">2</span>;<span class="number">3</span> &#125;]) <span class="comment">//array&lt;int&gt; allowed</span></span><br><span class="line">    <span class="comment">//array_and_notdim([[ int[] 1;2;3 ]]) //int4[2] not allowed</span></span><br></pre></td></tr></table></figure>
<p><strong><code>Сумма типов</code></strong></p>
<p>Еще один способ задать ограничения для типа — перечислить разрешенные типы через символ <code>|</code> (<a href="https://dascript.org/doc/reference/language/generic_programming.html#options" target="_blank" rel="noopener">options</a> в доках):</p>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">def foo(var a : int | float | string) <span class="comment">//accept int or float or string</span></span><br><span class="line">def foo(var a : array&lt;int | float&gt;) <span class="comment">//array of int of array of float</span></span><br><span class="line">def foo(a : <span class="keyword">function</span>&lt;(a : auto) : auto&gt; | <span class="keyword">function</span>&lt;(a, b : auto) : auto&gt;) <span class="comment">//accept any function with 1 or 2 arguments</span></span><br><span class="line">def foo (a : Bar explicit | Foo)   <span class="comment">// accept exactly Bar or anything inherited from Foo</span></span><br><span class="line">def foo (a : Foo | #) <span class="comment">//accept Foo and Foo#, looks like this short syntax only works with #</span></span><br></pre></td></tr></table></figure>
<p>Порядок проверки соответствия опций — слева направо:</p>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">def foo(var a : auto | int&amp;) &#123; a = <span class="number">84</span>; &#125;</span><br><span class="line">def bar(var a : int&amp; | auto) &#123; a = <span class="number">42</span>; &#125;</span><br><span class="line"></span><br><span class="line">[export]</span><br><span class="line">def main</span><br><span class="line">    var a: int</span><br><span class="line">    foo(a) <span class="comment">// match foo(auto)</span></span><br><span class="line">    print(<span class="string">"&#123;a&#125;\n"</span>) <span class="comment">// a == 0</span></span><br><span class="line">    bar(a) <span class="comment">// match bar(int&amp;)</span></span><br><span class="line">    print(<span class="string">"&#123;a&#125;\n"</span>) <span class="comment">// a == 42</span></span><br></pre></td></tr></table></figure>
<p><strong><code>static_if</code></strong></p>
<p>Проверка наличия методов или полей структуры выполняется в момент инстанцирования generic-функции</p>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> S</span><br><span class="line">    a : int</span><br><span class="line"></span><br><span class="line">def foo(var s)</span><br><span class="line">    s.a = <span class="number">42</span> <span class="comment">//not check if s has field</span></span><br><span class="line"></span><br><span class="line">[export]</span><br><span class="line">def main</span><br><span class="line">    var s : S</span><br><span class="line">    foo(s) <span class="comment">//ok</span></span><br></pre></td></tr></table></figure>
<p>Ошибка возникнет только в момент инстанциирования <code>foo</code> со структурой, не имеющей поля <code>a</code>. Проверить наличие полей или другую информацию о типе в время компиляции можно с помощью оператора <code>static_if</code>:</p>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> S</span><br><span class="line">    a : int</span><br><span class="line"><span class="keyword">struct</span> T</span><br><span class="line">    a : float4</span><br><span class="line"></span><br><span class="line">def foo(var s)</span><br><span class="line">    static_if typeinfo(has_field&lt;a&gt; s) &amp;&amp; (typeinfo(typename s.a) == typeinfo(typename <span class="class"><span class="keyword">type</span>&lt;int -const&gt;))</span></span><br><span class="line">        s.a = <span class="number">42</span></span><br><span class="line"></span><br><span class="line">var s : S</span><br><span class="line">foo(s) <span class="comment">//ok</span></span><br><span class="line">var t: T</span><br><span class="line">foo(t) <span class="comment">//also ok, but do nothing</span></span><br></pre></td></tr></table></figure>
<p><strong><code>Вызываемые макросы</code></strong></p>
<p>Более сложные конструкции вроде “вызвать конструктор того же типа, что и поле структуры <code>s.a</code> можно выразить с помощью макросов</p>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//generics macro</span></span><br><span class="line"><span class="keyword">module</span> generics_macro shared <span class="keyword">private</span></span><br><span class="line"></span><br><span class="line">[call_macro(name=<span class="string">"convert_to"</span>)]  <span class="comment">// convert_to(convertType, arg)</span></span><br><span class="line"><span class="keyword">class</span> ApplyMacro : AstCallMacro</span><br><span class="line">    <span class="comment">//! convert_to("float4", 42) -&gt; float4(42)</span></span><br><span class="line">    def <span class="keyword">override</span> visit ( prog:ProgramPtr; mod:Module?; var expr:smart_ptr&lt;ExprCallMacro&gt; ) : ExpressionPtr</span><br><span class="line">        var exprConstStr &lt;- unsafe(reinterpret&lt; smart_ptr&lt;ast::ExprConstString&gt;&amp;&gt; expr.arguments[<span class="number">0</span>])</span><br><span class="line">        var call &lt;- <span class="keyword">new</span> [[ExprCall() name:=exprConstStr.value, at=expr.at]]</span><br><span class="line">        emplace_new(call.arguments, clone_expression(expr.arguments[<span class="number">1</span>]))</span><br><span class="line">        <span class="keyword">return</span> &lt;- call</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">require generics_macro</span><br><span class="line"></span><br><span class="line">def foo(var s)</span><br><span class="line">    static_if typeinfo(has_field&lt;a&gt; s)</span><br><span class="line">        static_if typeinfo(has_field&lt;a&gt; s)</span><br><span class="line">            static_if typeinfo(typename s.a) == typeinfo(typename <span class="class"><span class="keyword">type</span>&lt;int -const&gt;)</span></span><br><span class="line">                s.a = <span class="number">42</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                s.a = convert_to(typeinfo(typename s.a), <span class="number">42</span>) <span class="comment">// --&gt; s.a = float4(42)</span></span><br><span class="line"></span><br><span class="line">var t : T</span><br><span class="line">foo(t)</span><br><span class="line">print(<span class="string">"&#123;t&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Output:</span></span><br><span class="line">[[ <span class="number">42</span>,<span class="number">42</span>,<span class="number">42</span>,<span class="number">42</span>]]</span><br></pre></td></tr></table></figure>
<p><strong><code>[generic]</code></strong></p>
<p>daScript распознаёт обычные или generic-функции по синтаксису, но можно также явно обозначить функцию как generic:</p>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">options log=<span class="keyword">true</span></span><br><span class="line"></span><br><span class="line">[generic]</span><br><span class="line">def func()</span><br><span class="line">    print(<span class="string">"hello"</span>)</span><br><span class="line"></span><br><span class="line">[export]</span><br><span class="line">def main</span><br><span class="line">    func()</span><br><span class="line"></span><br><span class="line"><span class="comment">//Output:</span></span><br><span class="line"></span><br><span class="line">def <span class="keyword">private</span> `func</span><br><span class="line">        print(<span class="string">"hello"</span>,__context__)</span><br><span class="line"></span><br><span class="line"><span class="comment">// [modify_external]</span></span><br><span class="line">[export]</span><br><span class="line">def <span class="keyword">public</span> main</span><br><span class="line">        __::`func()</span><br></pre></td></tr></table></figure>
<p>В таком случае вызов <code>func</code> будет преобразован в <code>__::</code>func` - вызов версии функции только из текущего модуля. Это используется в <a href="https://github.com/GaijinEntertainment/daScript/blob/87ab585fc3704896bff3eea71ab87e29f772be94/src/builtin/fio.das#L10" target="_blank" rel="noopener">некоторых функциях</a> стандартной библиотеки daslib, потому что если компилятор знает, что функция находится в том же модуле, что и вызывающий код, то может её оптимизировать — при AoT-компиляции генериуется не полноценный вызов через ABI (который может вести в другой не-AoT daScript модуль), а прямой вызов, что быстрее.</p>
<p><strong><code>[instance_function]</code></strong></p>
<p>С помощью макроса <code>[instance_function]</code> можно попросить явно специализировать generic-функцию с определенными типами:</p>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">require daslib/instance_function</span><br><span class="line"></span><br><span class="line">def func(a : auto(TT))</span><br><span class="line">    print(<span class="string">"&#123;typeinfo(typename a )&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line">[instance_function(func, TT = <span class="string">"int const"</span>)]</span><br><span class="line">def print_int(a) &#123;&#125;</span><br><span class="line"></span><br><span class="line">[export]</span><br><span class="line">def main</span><br><span class="line">    print_int(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p><strong><code>Видимость модулей</code></strong></p>
<p>Для generic функций, которые подразумевают переопределение для новых кастомных типов в других модулях, необходимо добавлять префикс <code>_::</code> или <code>__::</code>, чтобы обозначить, что функций должна искаться в том модуле, который её вызывает.</p>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//module1.das</span></span><br><span class="line">[export]</span><br><span class="line">def call_func(a)</span><br><span class="line">    _::func(a) <span class="comment">//func will be declared somewhere later</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//main.das</span></span><br><span class="line">require module1</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> S</span><br><span class="line">    a: int</span><br><span class="line"></span><br><span class="line">def func(s: S)</span><br><span class="line">    print(<span class="string">"&#123;s&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line">call_func(s) <span class="comment">//module1::call_func will see and call main::func()</span></span><br></pre></td></tr></table></figure>
<p><code>__::</code> — подразумевает возможность определения функции только в том же модуле, что и вызывающий код (main)<br><code>_::</code> — допускает определение как в том же модуле, что и вызывающий код, так и в других модулях (main, module1 или другие модули)</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script></div></article><div class="pagination"><a class="pagination__link pagination__prev" href="/blog/3914071471/">Позже</a><a class="pagination__link pagination__next" href="/blog/1023396573/">Раньше</a></div></main><footer class="footer metadata"><p class="footer__text">© 2023 spiiin</p><p class="footer__text">Powered by <a class="footer__text__link" href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a class="footer__text__link" href="https://pages.github.com/" target="_blank">Github Page</a></p></footer></div></body></html>