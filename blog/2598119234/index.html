<!DOCTYPE html><html lang="ru"><head><meta charset="UTF-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Spiiin's blog | Самый лучший способ поиска форматов блоков для NES-игр.</title><meta name="description" content=""><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=PT+Serif&amp;display=swap"><link rel="stylesheet" href="/css/highlights/darkula.css"><link rel="stylesheet" href="/css/main.css"><link rel="search" type="application/opensearchdescription+xml" href="http://spiiin.github.io/atom.xml" title="Spiiin's blog"><script>(function (i, s, o, g, r, a, m) {
  i['GoogleAnalyticsObject'] = r;
  i[r] = i[r] || function () {
    (i[r].q = i[r].q || []).push(arguments)
  }, i[r].l = 1 * new Date();
  a = s.createElement(o),
    m = s.getElementsByTagName(o)[0];
  a.async = 1;
  a.src = g;
  m.parentNode.insertBefore(a, m)
})(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');
ga('create', 'UA-00000000-0', 'auto');
ga('send', 'pageview');</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Spiiin's blog" type="application/atom+xml">
</head><body><div class="container"><header class="main-header"><h1 class="main-header__title uplize"><a class="main-header__title__link" href="/"><img class="header-image" src="/images/favicon.png" width="36" height="36">Spiiin's blog</a></h1><nav class="main-header__nav"><ul class="main-nav"><li class="main-nav__list"><a class="main-nav__list__link" href="/" target="_self">HOME</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/archives/" target="_self">ARCHIVE</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/tags/meta" target="_self">TAGS</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/blog/1" target="_self">ABOUT</a></li></ul></nav></header><main class="container__wrapper"><div class="pagination"><a class="pagination__link pagination__prev" href="/blog/3359911754/">Позже</a><a class="pagination__link pagination__next" href="/blog/1654464955/">Раньше</a></div><article class="article post"><h3 class="article__title">Самый лучший способ поиска форматов блоков для NES-игр.</h3><div class="article__date metadata"><div class="post-info">2016/08/03</div></div><div class="article__tags metadata">Tags:
<a class="article__tags__link metadata" href="/tags/nes/">nes</a><a class="article__tags__link metadata" href="/tags/hack/">hack</a></div><div class="article__body"><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Изобрёл ещё один способ реверса формата уровней NES-игр.</p>
<p>Способ во многом лучше предыдущего (<a href="http://spiiin.livejournal.com/73202.html" target="_blank" rel="noopener">автокорраптера</a>) и работает практически в любой игре:</p>
<p>не надо ловить момент старта уровня, достаточно сделать дамп памяти PPU в любой момент.</p>
<p>не надо использовать графику вообще, метод работает напрямую с данными от PPU консоли.</p>
<p>намного меньше усилий со стороны пользователя. </p>
<p>способ сочетается с предыдущим (можно использовать оба метода для достижения лучшего результата). </p>
<p>работает быстрее - перебирает все возможные варианты размещения блоков в ROM за 15-20 секунд. </p>
<p>универсальнее (сработал в 48 из 50 проверенных игр, будет время – прогоню более полные тесты). </p>
<p><strong>Теория</strong><br>Фон, который отображается на экране, задаётся массивом индексов тайлов видеопамяти по фиксированному адресу PPU – для NES существует 4 экранные страницы, которые в зависимости от настроек PPU могут разными способами выводится на экран. </p>
<p>Нам тут даже не важно, что именно будет на экране, достаточно просто захватить какую-нибудь загруженную страницу для анализа. <a href="http://dendy.migera.ru/nes/g02.html" target="_blank" rel="noopener">Подробнее о страницах и адресах</a>. </p>
<p>Первая экранная страница расположена по адресам PPU <strong>$2000-$23BF</strong>. Её содержимое можно в эмуляторе FCEUX можно посмотреть в окне <strong><em>Debug -&gt; Name Table Viewer</em></strong>: </p>
<p><img src="http://ic.pics.livejournal.com/spiiin/20318251/45978/45978_300.png" alt> </p>
<p>А также в виде байт в окне <strong><em>Debug -&gt; Hex Editor, View -&gt; PPU Memory</em></strong> (перейти по адресу <strong>$2000</strong>). </p>
<p>Здесь же можно сделать дамп всей видеопамяти, который пригодится нам для анализа (<strong><em>File-&gt;Dump to File-&gt;PPU Memory</em></strong>). </p>
<p><strong>Идея метода</strong> </p>
<p>Мы знаем (путём <a href="http://spiiin.livejournal.com/90540.html" target="_blank" rel="noopener">реверса</a> нескольких десятков игр), что в большинстве игр на NES для сохранения места в ROM уровни описываются не с помощью тайлов, а путём более крупных структур – блоков. </p>
<p>Таким образом, если мы предположим некоторый размер блока (для начала попробуем самый стандартный – 2x2 тайла), то мы можем разбить данные из Name Table на участки 2x2 тайла, в каждом из которых окажется описание одного блока. <a href="https://gist.github.com/spiiin/dfabd3cd7554c1bc0bdb1c0133e723b4" target="_blank" rel="noopener">https://gist.github.com/spiiin/dfabd3cd7554c1bc0bdb1c0133e723b4</a> </p>
<p>Так мы получаем список из всех блоков, которые присутствуют на экране. Причём у нас “чистые” описания блоков, без информации от спрайтов (спрайты рисуются другим способом), и независимый от анимации (анимации фона практически всегда делаются с помощью изменений палитры либо самой видеопамяти, номера тайлов в Name Table остаются неизменными).</p>
<p> <a href="http://ic.pics.livejournal.com/spiiin/20318251/46404/46404_original.png" target="_blank" rel="noopener"><img src="http://ic.pics.livejournal.com/spiiin/20318251/46404/46404_300.png" alt></a> </p>
<p> На скриншоте выделены первые 4 блока размером 2x2 тайла, для лучшей видимосте перекрашенные выделяющимися по цвету тайлами.</p>
<p> У нас есть описание блоков на экране, но мы не знаем их порядок хранения в ROM. Тем не менее, мы можем с некоторой вероятностью (как покажет практика, вероятность очень высокая) предположить, где именно расположено описание блоков. Алгоритм для этого такой: </p>
<ol>
<li><p>Проходим по всему ROM и размечаем все адреса, по которым обнаруживается какой-нибудь блок, при этом сохраняем его номер (настоящий номер может быть другой, нам важно отметить только отличия блоков друг от друга).</p>
</li>
<li><p>Находим область в ROM, в которой обнаружено наибольшее количество РАЗНЫХ блоков.</p>
<p>С наибольшей вероятностью именно это и есть описание блоков.<br><a href="https://gist.github.com/spiiin/500262e8d9da86f10a093bbb41833360" target="_blank" rel="noopener">https://gist.github.com/spiiin/500262e8d9da86f10a093bbb41833360</a></p>
<p>Таким образом, мы можем найти блоки размером 2x2 в играх, в которых они хранятся последовательно. Это уже неплохо, но есть способ кардинально улучшить результаты работы алгоритма.</p>
<p>Дело в том, что существует ограниченное количество основных размеров блоков и способов их хранения в ROM, и мы можем перебрать их все. Основные размеры блоков - 2x2, 4x2, 2x4 и 4x4, других не попадалось, но в случае необходимости легко добавить и их, нужно просто параметризировать итератор выбора индексов размером блока и скармливать ему другие индексы блоков (также меняя и порядок - блоки описываются как построчно, так и постолбцово).</p>
<p>Со способом хранения их в ROM немного хитрее, блоки могут храниться в ROM как линейно, так и разбитыми на части массивами (<a href="https://en.wikipedia.org/wiki/AOS_and_SOA" target="_blank" rel="noopener">Structure of Arrays</a>, сокращенно SoA ), т.е. сначала в ROM хранится массив только первых частей блоков, за ним - массивы со следующими частями.</p>
<p>Чаще всего такие массивы хранятся друг за другом, при этом промежуток между началами массивов равен количеству блоков. Чтобы найти в ROM такие SoA-массивы, мы должны узнать их длину, что можно сделать перебором всех вариантов (частенько в играх используется по 256 блоков, так что начинать проверку стоит с этого числа и постепенно его уменьшать). Я для такого поиска шарахнул регулярное выражение вида:</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def buildReWithStride(blockStr, stride): strideStr &#x3D; r&quot;.&#123;%d&#125;&quot;%stride #пропускаем stride символов</span><br><span class="line">  e &#x3D; re.escape</span><br><span class="line">  return e(blockStr[0]) + strideStr + e(blockStr[1]) + strideStr + e(blockStr[2]) + strideStr + e(blockStr[3])</span><br></pre></td></tr></table></figure>
<p> что, конечно, не самое лучшее решение, зато укладывается в пару строк кода. С такими методами поиска я приступил к охоте на блоки в играх.</p>
<p><strong>Результаты находок разных типов</strong> </p>
<p>Блоки 2x2, линейные: <a href="http://ic.pics.livejournal.com/spiiin/20318251/46819/46819_original.png" target="_blank" rel="noopener"><img src="http://ic.pics.livejournal.com/spiiin/20318251/46819/46819_300.png" alt></a></p>
<p>Блоки 2x2, SoA: <a href="http://ic.pics.livejournal.com/spiiin/20318251/46982/46982_original.png" target="_blank" rel="noopener"><img src="http://ic.pics.livejournal.com/spiiin/20318251/46982/46982_300.png" alt></a> </p>
<p>Блоки 4x4, линейные: <a href="http://ic.pics.livejournal.com/spiiin/20318251/47105/47105_original.png" target="_blank" rel="noopener"><img src="http://ic.pics.livejournal.com/spiiin/20318251/47105/47105_300.png" alt></a></p>
<p>Блоки 4x2, линейные: <a href="http://ic.pics.livejournal.com/spiiin/20318251/47557/47557_original.png" target="_blank" rel="noopener"><img src="http://ic.pics.livejournal.com/spiiin/20318251/47557/47557_300.png" alt></a></p>
<p>Необычные типы блоков Описание всего уровня блоками 2x2: <a href="http://ic.pics.livejournal.com/spiiin/20318251/47821/47821_original.png" target="_blank" rel="noopener"><img src="http://ic.pics.livejournal.com/spiiin/20318251/47821/47821_300.png" alt></a></p>
<p>Автоблоки из видеопамяти построчно: MegaMan, Banana Prince (достаточно открыть банк видеопамяти, чтобы увидеть блоки)</p>
<p>Несколько раздельных наборов блоков: <a href="http://spiiin.livejournal.com/82993.html" target="_blank" rel="noopener">Jungle Book</a> (перебором обнаруживаются обе части).</p>
<p><strong>Возможные улучшения</strong></p>
<p>Самое банальное – перебирать как можно больше разных размеров блоков, что не очень нужно, так как другие размеры практически не встречаются.</p>
<p>Расширить метод для других платформ. Name Table есть ещё много где, и описание блоков хранится в ROM в несжатом виде (блоки по определению уникальны, следовательно, практически не сжимаются). </p>
<p>Необходимо работать не только с байтами, но и другими размерами слова.</p>
<p>После того, как найден точный адрес описания блоков в ROM, можно сделать ремаппинг индексов блоков в Name Table на правильные. После этого мы получим массив из индексов не тайлов, а блоков, и сможем в нём искать в ROM описание следующей единицы построения уровня – макроблоков (для игр, в которых это актуально). Здесь уже требуется больше ручной работы и понимания процесса (кроме того, часто макроблоки не используются).</p>
<p>Пример такого поиска для Чёрного Плаща: <a href="https://gist.github.com/spiiin/3635525e6846d4eaf33d7eafb5a6673f" target="_blank" rel="noopener">https://gist.github.com/spiiin/3635525e6846d4eaf33d7eafb5a6673f</a></p>
<p><strong>Ссылки</strong><br><a href="https://github.com/spiiin/NesBlockFinder" target="_blank" rel="noopener">Исходники</a><br><a href="https://dl.dropboxusercontent.com/u/852723/cad_editor/NesBlockFinder1.0.zip" target="_blank" rel="noopener">Скомпилированный бинарник</a><br><a href="http://ic.pics.livejournal.com/spiiin/20318251/48323/48323_original.jpg" target="_blank" rel="noopener"><img src="http://ic.pics.livejournal.com/spiiin/20318251/48323/48323_300.jpg" alt></a></p>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"Ov23liG1mZbiQOIdi91X","clientSecret":"e05812685eb741a752982b89dcf6f5b58dc10251","repo":"spiiin.github.io","owner":"spiiin","admin":["spiiin"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script></div></article><div class="pagination"><a class="pagination__link pagination__prev" href="/blog/3359911754/">Позже</a><a class="pagination__link pagination__next" href="/blog/1654464955/">Раньше</a></div></main><footer class="footer metadata"><p class="footer__text">© 2024 spiiin</p><p class="footer__text">Powered by <a class="footer__text__link" href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a class="footer__text__link" href="https://pages.github.com/" target="_blank">Github Page</a></p></footer></div></body></html>