<!DOCTYPE html><html lang="ru"><head><meta charset="UTF-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Spiiin's blog | Расположение объектов C++ в памяти</title><meta name="description" content="&lt;p&gt;Обычно на вопрос о расположении объекта в памяти программисты C++ отвечают “это зависит от реализации”, а как именно зависит - не особо понимают. Это действительно практически не нужно знать для написания корректных программ, но может пригодиться для написания быстрых.&lt;/p&gt;
&lt;p&gt;После просмотра доклада об оптимизации &lt;code&gt;Witcher 3&lt;/code&gt; для Switch (&lt;a href=&quot;https://www.gdcvault.com/play/1026635/-Witcher-3-on-the&quot;&gt;видео&lt;/a&gt; на 14:28), я решил проверить, возможно ли получить информацию об расположении объектов в памяти таким же или похожим способом для телефонов.&lt;br&gt;"><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=PT+Serif&amp;display=swap"><link rel="stylesheet" href="/css/highlights/darkula.css"><link rel="stylesheet" href="/css/main.css"><link rel="search" type="application/opensearchdescription+xml" href="http://spiiin.github.io/atom.xml" title="Spiiin's blog"><script>(function (i, s, o, g, r, a, m) {
  i['GoogleAnalyticsObject'] = r;
  i[r] = i[r] || function () {
    (i[r].q = i[r].q || []).push(arguments)
  }, i[r].l = 1 * new Date();
  a = s.createElement(o),
    m = s.getElementsByTagName(o)[0];
  a.async = 1;
  a.src = g;
  m.parentNode.insertBefore(a, m)
})(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');
ga('create', 'UA-00000000-0', 'auto');
ga('send', 'pageview');</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-shiki-plugin@latest/lib/codeblock.css">
<style>:root{--hl-color:#abb2bf;--hl-bg:#282c34;--hltools-bg:#21252b;--hltools-color:#bbbbbc;--hlnumber-bg:#282c34;--hlnumber-color:#495162;--hlscrollbar-bg:#373c47;--hlexpand-bg:linear-gradient(180deg,rgba(40,44,52,0.1),rgba(40,44,52,0.9))}</style><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Spiiin's blog" type="application/atom+xml">
</head><body><div class="container"><header class="main-header"><h1 class="main-header__title uplize"><a class="main-header__title__link" href="/"><img class="header-image" src="/images/favicon.png" width="36" height="36">Spiiin's blog</a></h1><nav class="main-header__nav"><ul class="main-nav"><li class="main-nav__list"><a class="main-nav__list__link" href="/" target="_self">HOME</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/archives/" target="_self">ARCHIVE</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/tags/meta" target="_self">TAGS</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/blog/1" target="_self">ABOUT</a></li></ul></nav></header><main class="container__wrapper"><div class="pagination"><a class="pagination__link pagination__prev" href="/blog/1170009669/">Позже</a><a class="pagination__link pagination__next" href="/blog/1552834708/">Раньше</a></div><article class="article post"><h3 class="article__title">Расположение объектов C++ в памяти</h3><div class="article__date metadata"><div class="post-info">2021/06/09</div></div><div class="article__tags metadata">Tags:
<a class="article__tags__link metadata" href="/tags/cpp/">cpp</a><a class="article__tags__link metadata" href="/tags/longread/">longread</a></div><div class="article__body"><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Обычно на вопрос о расположении объекта в памяти программисты C++ отвечают “это зависит от реализации”, а как именно зависит - не особо понимают. Это действительно практически не нужно знать для написания корректных программ, но может пригодиться для написания быстрых.</p>
<p>После просмотра доклада об оптимизации <code>Witcher 3</code> для Switch (<a target="_blank" rel="noopener" href="https://www.gdcvault.com/play/1026635/-Witcher-3-on-the">видео</a> на 14:28), я решил проверить, возможно ли получить информацию об расположении объектов в памяти таким же или похожим способом для телефонов.<br><span id="more"></span></p>
<p><strong><code>Зачем это нужно в контексте разработки мобильных игр (и не только):</code></strong></p>
<ul>
<li>Пробраться “вглубь” языка, лучше понять его фичи</li>
<li>Улучшить понимание работы компиляторов и отличия в реализациях</li>
<li>Получить возможность оценить размер базовых объектов используемых библиотек</li>
<li>Научиться data-oriented design (если начинать проектировать от данных, хорошо бы понять, как они вообще выглядят)</li>
<li><strong>Оптимизировать наиболее часто используемые структуры - уменьшить системные требования игры</strong></li>
</ul>
<p>Заметки про <code>data-oriented design</code> и <code>entity-component-system</code> подход - <a href="/blog/381238762/" title="ECS. Ссылки">ECS. Ссылки</a>,  <a href="/blog/1488389622/" title="ECS для казуальных игр">ECS для казуальных игр</a></p>
<p><strong><code>Когда можно браться за подобные исследования</code></strong></p>
<ul>
<li>Если у вас есть много времени</li>
<li>Если игра не влезает в память и тормозит, а нужно её запихать и разогнать</li>
<li>Если хотите “достичь невозможного” (Do the impossible! ;) )</li>
</ul>
<p><strong><code>Когда не стоит</code></strong><br>Если просто нужно сделать фичу или окошко для игры - то лучше сделать поскорее, закрыть задачу, выпустить апдейт/релиз, выпить шампанского (или коньяка, в зависимости от масштабов запуска). Потом выехать погулять на природу и тогда, возможно, задуматься о расположении объектов в памяти.</p>
<h2><span id="kak-umenshenie-razmera-struktur-uvelichivaet-proizvoditelnost">Как уменьшение размера структур увеличивает производительность</span><a href="#kak-umenshenie-razmera-struktur-uvelichivaet-proizvoditelnost" class="header-anchor">#</a></h2><p>Кроме очевидного <strong><code>уменьшения времени на копирование</code></strong> байт, необходимого для создания объекта, более важным является то, что объекты лучше <strong><code>помещаются в кеш</code></strong>.</p>
<p>Т.е. во-первых, уменьшается количество страниц оперативной памяти, которые будут выгружена на диск (<a target="_blank" rel="noopener" href="https://ru.wikipedia.org/wiki/%D0%92%D0%B8%D1%80%D1%82%D1%83%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F_%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D1%8C">Виртуальная память</a>).</p>
<p>Во-вторых, процессор имеет свой <a target="_blank" rel="noopener" href="https://ru.wikipedia.org/wiki/%D0%9A%D1%8D%D1%88_%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BE%D1%80%D0%B0">кеш памяти</a> нескольких уровней. При запросе данных из памяти он загружает не только запрошенную ячейки, но ещё и соседние ячейки. Количество таких ячеек называется <em>кеш-линией</em>. В случае обращения к соседним ячейкам данные будут получены не из оперативной памяти, а из кеша, что <strong>сильно</strong> быстрее.</p>
<blockquote><p>Разница между получением данных из кеша 1 уровня и основной памяти достигает 2х порядков <strong>(~100 раз быстрее)</strong>, конкретные числа зависят от железа.</p>
</blockquote>
<p><img src="/blog/854775037/cache.gif" alt="cache"><br>(источник - <a target="_blank" rel="noopener" href="https://technology.riotgames.com/news/profiling-measurement-and-analysis">https://technology.riotgames.com/news/profiling-measurement-and-analysis</a>)</p>
<p>Примеры и бенчмарки:<br><a target="_blank" rel="noopener" href="https://gameprogrammingpatterns.com/data-locality.html">Data Locality</a> - глава из книги <strong><code>Game Programming Patterns</code></strong>.<br><a target="_blank" rel="noopener" href="https://colin-scott.github.io/personal_website/research/interactive_latency.html">Latency Numbers Every Programmer Should Know</a> - визуализация задержек доступа к разным типам памяти.<br><a target="_blank" rel="noopener" href="http://overbyte.com.au/misc/Pitfalls2009.pdf">Pitfalls of Object Oriented Programming</a> - слайды с бенчмарками на PS3 с закрытого доклада Тони Альбрехта.<br><a target="_blank" rel="noopener" href="https://youtu.be/VAT9E-M-PoE">Pitfalls of Object Oriented Programming, Revisited - Tony Albrecht (TGC 2017)</a> - публичный доклад 2017 года Тони Альбрехта, бенчмарки для PC и PS4.<br><a target="_blank" rel="noopener" href="https://solid-angle.blogspot.com/2010/02/musings-on-data-oriented-design.html">Musings on Data-Oriented Design</a> - статья про то, что компиляторы преобразуют код, но не трогают данные.<br><a target="_blank" rel="noopener" href="https://gamesfromwithin.com/data-oriented-design">Data-Oriented Design (Or Why You Might Be Shooting Yourself in The Foot With OOP)</a> - одна из первых статей о дизайне, ориентированном на данные, применительно к геймдеву</p>
<h2><span id="ponyatiya">Понятия</span><a href="#ponyatiya" class="header-anchor">#</a></h2><p><strong><code>Размер объекта</code></strong> (<code>size</code>) - количество байт в памяти, которое занимает (на стеке или в куче) созданный экземпляр класса объекта. Размер объекта можно получить с помощью оператора <code>sizeof</code>. Если объект умеет выделять динамическую память в конструкторе (или любой другой функцией), естественно, компилятор не учитают это в размере самого объекта - подобные действия выполняются уже во время работы программы.</p>
<p><strong><code>Выравнивание</code></strong> (<code>alignment</code>) - способ размещения данных в памяти так, чтобы к ним можно было быстро обращаться (на некоторых процессорах к невыровненным данным вообще невозможно обратиться).<br>Процессор загружает данные из памяти не по одному байту, а по размеру <em>машинного слова</em>.</p>
<p>Например, на машине с 64-битной адресацией, если нужно загрузить адрес из памяти, то он должен быть выровнен в памяти по границе 8 байт (может находиться в памяти только по адресам, заканчивающимся на <code>0x0</code> или <code>0x8</code>). Если адрес <code>0x1122334455667788</code>, например, сохранён начиная с ячейки памяти <code>0x00000003</code> (в big-endian формате):</p>
<figure class="shiki"><div class="codeblock"><div class="code"><pre class="shiki slack-dark"><code><span class="line"><span style="color: #E6E6E6">0x00000000: 00 00 00 00 00 11 22 33</span></span>
<span class="line"><span style="color: #E6E6E6">0x00000008: 44 55 66 77 88 00 00 00</span></span></code></pre></div></div></figure>
<p>Процессор может загрузить только слова по адресам <code>0x00000000</code> или <code>0x00000008</code>. Таким образом, чтобы “собрать” нужный адрес, ему потребовалось по загрузить 2 слова <code>0x000000112233</code> и <code>0x4455667788000000</code> и произвести операции сдвига и совмещения адресов, что сильно дольше одной команды загрузки.</p>
<p>Получить выравнивание структуры с помощью оператора <code>alignof</code>.</p>
<p><strong><code>Padding</code></strong> (иногда переводят тоже как <code>выравнивание</code>, что может создать путаницу, так что если пусть называется <code>паддинг</code>) - добавление неиспользуемых байт после окончания описания какого-либо объекта в памяти так, чтобы следующий за ним объект оставался выровненным. Оператора, который бы позволил добраться до этих неиспользуемых байт, нет, но прочитать или записать их можно (лучше так никогда не делать).</p>
<p>В совсем тривиальных случаях <code>размер, выравнивание и паддинг</code> легко рассчитать, глядя на код, но при малейшем усложнении это резко становится сложным. Собственно, цель заметки - исследовать различные способы получения этой информации для компиляторов C++, используемых мной в работе, т.е. для ОС <strong><code>Windows/iOS/Android</code></strong> (<code>Visual C++</code> и <code>Clang</code>).</p>
<h2><span id="otladka-programmy">Отладка программы</span><a href="#otladka-programmy" class="header-anchor">#</a></h2><p>Более продвинутый способ, чем ручной подсчёт - использование средств отладки программы (сюда я включаю сразу как точки остановки, так и просто диагностический вывод или использование подсказок ide компилятора). Для начала подойдёт простой вывод полученных чисел в консоль:<br><a target="_blank" rel="noopener" href="https://gcc.godbolt.org/z/8fKa74j9n">https://gcc.godbolt.org/z/8fKa74j9n</a><br><figure class="shiki cpp"><div class="codeblock"><div class="code"><pre class="shiki slack-dark"><code><span class="line"><span style="color: #569CD6">struct</span><span style="color: #E6E6E6"> </span><span style="color: #4EC9B0">A</span><span style="color: #E6E6E6"> {</span></span>
<span class="line"><span style="color: #E6E6E6">  </span><span style="color: #569CD6">bool</span><span style="color: #E6E6E6"> b1;</span></span>
<span class="line"><span style="color: #E6E6E6">  </span><span style="color: #569CD6">bool</span><span style="color: #E6E6E6"> b2;</span></span>
<span class="line"><span style="color: #E6E6E6">  </span><span style="color: #569CD6">int</span><span style="color: #E6E6E6"> i;</span></span>
<span class="line"><span style="color: #E6E6E6">};</span></span>
<span class="line"></span>
<span class="line"><span style="color: #569CD6">struct</span><span style="color: #E6E6E6"> </span><span style="color: #4EC9B0">B</span><span style="color: #E6E6E6"> {</span></span>
<span class="line"><span style="color: #E6E6E6">  </span><span style="color: #569CD6">bool</span><span style="color: #E6E6E6"> b1;</span></span>
<span class="line"><span style="color: #E6E6E6">  </span><span style="color: #569CD6">int</span><span style="color: #E6E6E6"> i;</span></span>
<span class="line"><span style="color: #E6E6E6">  </span><span style="color: #569CD6">bool</span><span style="color: #E6E6E6"> b2;</span></span>
<span class="line"><span style="color: #E6E6E6">};</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E6E6E6">std::cout </span><span style="color: #D4D4D4">&lt;&lt;</span><span style="color: #E6E6E6"> </span><span style="color: #CE9178">&quot;sizeof(A):&quot;</span><span style="color: #E6E6E6"> </span><span style="color: #D4D4D4">&lt;&lt;</span><span style="color: #E6E6E6"> </span><span style="color: #569CD6">sizeof</span><span style="color: #E6E6E6">(A) </span><span style="color: #D4D4D4">&lt;&lt;</span><span style="color: #E6E6E6">  std::endl;</span></span>
<span class="line"><span style="color: #E6E6E6">std::cout </span><span style="color: #D4D4D4">&lt;&lt;</span><span style="color: #E6E6E6"> </span><span style="color: #CE9178">&quot;sizeof(B):&quot;</span><span style="color: #E6E6E6"> </span><span style="color: #D4D4D4">&lt;&lt;</span><span style="color: #E6E6E6"> </span><span style="color: #569CD6">sizeof</span><span style="color: #E6E6E6">(B) </span><span style="color: #D4D4D4">&lt;&lt;</span><span style="color: #E6E6E6">  std::endl;</span></span>
<span class="line"><span style="color: #6A9955">//output:</span></span>
<span class="line"><span style="color: #6A9955">//  sizeof(A):8</span></span>
<span class="line"><span style="color: #6A9955">//  sizeof(B):12</span></span></code></pre></div></div></figure></p>
<p>Посмотреть, где именно находится дополнительная “дырка” в структуре <code>B</code> можно с помощью макроса <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/types/offsetof">offsetof</a>, хотя здесь проще перейти к способу с отладчиком.<br>Для идентификации данных в памяти можно “пометить” их при инициализации:</p>
<figure class="shiki cpp"><div class="codeblock"><div class="code"><pre class="shiki slack-dark"><code><span class="line"><span style="color: #569CD6">struct</span><span style="color: #E6E6E6"> </span><span style="color: #4EC9B0">A</span><span style="color: #E6E6E6"> {</span></span>
<span class="line"><span style="color: #E6E6E6">  </span><span style="color: #569CD6">bool</span><span style="color: #E6E6E6"> b1 </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #B5CEA8">0x1</span><span style="color: #E6E6E6">;</span></span>
<span class="line"><span style="color: #E6E6E6">  </span><span style="color: #569CD6">bool</span><span style="color: #E6E6E6"> b2 </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #B5CEA8">0x1</span><span style="color: #E6E6E6">;</span></span>
<span class="line"><span style="color: #E6E6E6">  </span><span style="color: #569CD6">int</span><span style="color: #E6E6E6"> i </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #B5CEA8">0xAAAAAAAA</span><span style="color: #E6E6E6">;</span></span>
<span class="line"><span style="color: #E6E6E6">};</span></span>
<span class="line"></span>
<span class="line"><span style="color: #569CD6">struct</span><span style="color: #E6E6E6"> </span><span style="color: #4EC9B0">B</span><span style="color: #E6E6E6"> {</span></span>
<span class="line"><span style="color: #E6E6E6">  </span><span style="color: #569CD6">bool</span><span style="color: #E6E6E6"> b1 </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #B5CEA8">0x1</span><span style="color: #E6E6E6">;</span></span>
<span class="line"><span style="color: #E6E6E6">  </span><span style="color: #569CD6">int</span><span style="color: #E6E6E6"> i </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #B5CEA8">0xBBBBBBBB</span><span style="color: #E6E6E6">;</span></span>
<span class="line"><span style="color: #E6E6E6">  </span><span style="color: #569CD6">bool</span><span style="color: #E6E6E6"> b2 </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #B5CEA8">0x1</span><span style="color: #E6E6E6">;</span></span>
<span class="line"><span style="color: #E6E6E6">};</span></span></code></pre></div></div></figure>
<p>При использовании <code>Visual Studio</code> можно вызвать посмотреть адрес переменной в окне <code>Locals</code>, и затем изучить содержимое памяти с помощью окна <a target="_blank" rel="noopener" href="https://docs.microsoft.com/ru-ru/visualstudio/debugger/memory-windows?view=vs-2019">Memory</a>.<br><img src="/blog/854775037/vs_memory_small.png" alt="vs-memory"><br><figure class="shiki"><div class="codeblock"><div class="code"><pre class="shiki slack-dark"><code><span class="line"><span style="color: #E6E6E6">0x002EB138  01 01 00 00  &lt;---  A.b1, A.b2, padding[2]</span></span>
<span class="line"><span style="color: #E6E6E6">0x002EB13C  aa aa aa aa  &lt;---  A.i</span></span>
<span class="line"><span style="color: #E6E6E6">0x002EB140  01 00 00 00  &lt;---  B.b1, padding[3]</span></span>
<span class="line"><span style="color: #E6E6E6">0x002EB144  bb bb bb bb  &lt;---  B.i</span></span>
<span class="line"><span style="color: #E6E6E6">0x002EB148  01 00 00 00  &lt;---  B.b2, padding[3]</span></span></code></pre></div></div></figure></p>
<p>В <code>XCode</code> для просмотра памяти можно воспользоваться командой отладчика:</p>
<figure class="shiki"><div class="codeblock"><div class="code"><pre class="shiki slack-dark"><code><span class="line"><span style="color: #E6E6E6">gdb /12xb 0x002EB138</span></span>
<span class="line"><span style="color: #E6E6E6">//вывести 12 байт в hex-формате, начиная с адреса 0x002EB138</span></span></code></pre></div></div></figure>
<p>Небольшую хитрость при таком способе представляет лишь просмотр пространства в конце структуры, так как его сложнее пометить, но здесь можно воспользоваться наследованием (данные структуры наследника будут располагаться сразу за предком), массивом из нескольких структур, или просто скопировать все данные в непрерывный массив данных с помощью <code>memcpy</code>:</p>
<figure class="shiki cpp"><div class="codeblock"><div class="code"><pre class="shiki slack-dark"><code><span class="line"><span style="color: #569CD6">char</span><span style="color: #E6E6E6"> </span><span style="color: #9CDCFE">values</span><span style="color: #E6E6E6">[</span><span style="color: #B5CEA8">1000</span><span style="color: #E6E6E6">];</span></span>
<span class="line"><span style="color: #DCDCAA">memcpy</span><span style="color: #E6E6E6">(values, d1, </span><span style="color: #569CD6">sizeof</span><span style="color: #E6E6E6">(A));</span></span>
<span class="line"><span style="color: #6A9955">//можем изучать в отладчике содержимое values</span></span></code></pre></div></div></figure>
<p>Собственно, если говорить о <a target="_blank" rel="noopener" href="https://www.cplusplus.com/reference/type_traits/is_trivial/">тривиальных типах данных</a> (без виртуальных функций или множественного/виртуального наследования), то на этом можно было бы и остановиться.</p>
<p>Таким способом можно изучать и сложные классы, некоторые так и делают, например, <a target="_blank" rel="noopener" href="https://shaharmike.com/cpp/vtable-part1/">статьи</a> Shakar Mike по исследованиям содержимого и формата таблиц виртуальной памяти. Однако при этом достаточно сложно на глаз определить работу в случаях, которые находятся за рамками тривиальных разобранных в статьях примерах. Так что лучше сразу читать спецификацию, которую использует <code>Clang</code> в том числе и для <code>iOS/Android</code> - <a target="_blank" rel="noopener" href="https://itanium-cxx-abi.github.io/cxx-abi/abi.html#layout">Itanium C++ ABI</a>.</p>
<p><em>не уверен, что это на 100% верно, но скрипты, которые анализируют размеры и расположение в памяти, использующие другие способы, показывают, что используется эти спецификация</em>.</p>
<p>Главное отличие в поведении компилятора <code>Visual C++</code> - он кладёт указатель на виртуальный базовый класс в сам объект, а не добавляет его в виртуальную таблицу класса.</p>
<p>Если <em>совсем кратко</em> и на пальцах объяснять виртуальное и множественное наследование - все невиртуальные предки располагаются перед собственными членами класса (в порядке объявления слева направо, но первый класс с таблицей виртуальных функций “всплывает” наверх), а все виртуальные предки - сразу за собственными членами.</p>
<p>Спецификация объясняет все особенности множественного и виртуального наследования, но всё равно, использовать отладчик на классах из реальных проектов сложно, потому что:</p>
<ul>
<li>В случае сложных иерархий можно просто запутаться в обычных и виртуальных наследниках</li>
<li>Тяжело изучать классы из std или чужих библиотек</li>
<li>Легко пропустить “дырки” в каких-нибудь классах</li>
<li>Сложно представить, какие данные в какую кеш-линию попадут</li>
</ul>
<p>Таким образом, вместо изучения программы методом запуска её с отладчиком и написанием диагностического кода хочется воспользоваться более продвинутыми способами.</p>
<h2><span id="izuchenie-sposobov-dostat-informaciyu-o-tipah">Изучение способов достать информацию о типах</span><a href="#izuchenie-sposobov-dostat-informaciyu-o-tipah" class="header-anchor">#</a></h2><p>К сожалению, в C++ нет интроспекции, но <code>отладчик ведь как-то получает эту информацию</code>?</p>
<p>Собственно, об этом способе рассказывается в докладе о Ведьмаке.</p>
<p>Компилятор пишет её в отладочную секцию исполнимого файла в бинарном виде, откуда её могут прочитать какие-либо тулзы.</p>
<blockquote><p>Из этой информации кстати можно сделать полезный вывод о том, как работает сборка в режиме Release with Debug info - она не замедляет код, а просто добавляет в испонимый файл эту дебажную информацию, которую потом можно просто отрезать не пересобирая исполнимый файл.</p>
</blockquote>
<p>Автор доклада взял браузер отладочного формата (<a target="_blank" rel="noopener" href="http://msinilo.pl/blog2/post/p425/">статья</a>, сейчас <a target="_blank" rel="noopener" href="https://issues.unrealengine.com/issue/UE-96827">используется</a> где-то в <code>Unreal Engine</code>), который использует <code>Visual Studio</code>, и <a target="_blank" rel="noopener" href="https://github.com/rdev0/PadAnalyzer/commits">зафигачил</a> туда поддержку форматов PDB (отладочная база данных <code>Visual Studio</code> для x86/x64/XboxOne), и чтение отладочной информации в формате <code>Dwarf</code> из <code>Elf</code>-файлов (Switch, PS4).</p>
<p>В этом месте я очень обрадовался, так как Elf-файлы и отладочные секции в <a target="_blank" rel="noopener" href="http://dwarfstd.org/">формате Dwarf</a> - стандартные для <code>Unix</code>, а значит, был шанс, что получится загрузить в утилиту и бинарники для <code>iOS</code> и <code>Android</code>. С некоторыми усилиями я собрал тулзу и запустил её, но понял, что радоваться рановато - <code>iOS/macOS</code> бинарники не загружались, так как отличались от стандартного формата, но <code>Android</code> so-файл удалось загрузить! Но даже с ним возникли проблемы, оказалось, что тулза неправильно показывает расположение объектов с виртуальным наследованием - в Ведьмаке 3, видимо, не было сложных схем наследования, так что автор порта просто не обратил внимание на этот баг, но в моём проекте это широко использовалось.<br><img src="/blog/854775037/pad_analyzer_small.png" alt="pad_analyzer"></p>
<p>Было грустно, что <code>Pad Analyzer</code> <em>как будто</em> должен был подойти для изучения мобильных платформ, но не помог. Однако им можно было воспользоваться как референсом для других скриптов, так что я решил попробовать разобраться с Dwarf-форматом чуть детальнее.</p>
<p>С загрузкой <code>iOS/macOS</code> оказалось относительно просто - в Apple решили не писать в финальный бинарник отладочную секцию, а сохранить в нём просто айдишник, по которому может быть найден <strong><code>dsym</code></strong>-файл со ссылками на реальную отладочную информацию, находящуюся в <strong><code>*.o-файлах</code></strong>.</p>
<p>Ссылки с детальными объяснениями:<br><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/10044697/where-how-does-apples-gcc-store-dwarf-inside-an-executable/12827463#12827463">Ответ на stackoverflow</a> от программера из Apple.<br><a target="_blank" rel="noopener" href="http://wiki.dwarfstd.org/index.php?title=Apple%27s_%22Lazy%22_DWARF_Scheme">Apple’s “Lazy” DWARF Scheme</a> - “Ленивые дворфы от Эпл”<br><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/24961746/what-the-structure-of-dsym-file">Описание структуры dsym-файла</a> - со ссылкой на тулзу на Python, которая может загружать Mach-O файлы.</p>
<blockquote><p>Здесь тоже есть полезное знание о том, из-за чего XCode после перегенерации проекта вынуждена перекомпилировать все файлы - она не может расшарить отладочную информацию из предыдущих сборок.</p>
</blockquote>
<p>Pad Analyzer не умеет загружать <em>.o файлы, но можно было либо разобраться, как добавлять их, либо попробовать собрать пустой Elf-файл, и “пересадить” в него отладочную секцию из </em>.o файла. Звучит безумно, но задача выполнима:<br><a target="_blank" rel="noopener" href="https://dzone.com/articles/converting-a-raw-binary-file-into-an-elfdwarf-file">Converting a Raw Binary File Into an ELF/Dwarf File</a><br><a target="_blank" rel="noopener" href="https://habr.com/ru/company/inforion/blog/460247/">Рецепты для ELF-ов</a></p>
<p>Но, к счастью, по одной из ссылок я натолкнулся на библиотеку <a target="_blank" rel="noopener" href="https://github.com/eliben/pyelftools">pyelftools</a> и визуализатор dwarf-формата <a target="_blank" rel="noopener" href="https://github.com/sevaa/dwex">dwex</a>. Это был шаг вперёд, потому что он умел открывать 32- и 64-битные <code>.o-файлы для MacOSx</code>, собранные 32- и 64-бинарники для <code>.so бинарники для Android</code>, и 32-битные <code>.o бинарники для Android</code>. Оставалась проблема с тем, что <a target="_blank" rel="noopener" href="https://github.com/eliben/pyelftools/issues/317">не работали</a> 64-битные *.o-файлы для Android. </p>
<p>Сам <code>Dwarf Explorer</code> не предназначен для показа полной информации об объекте, но, раз у него есть дерево со ссылками на предков, можно написать свой алгоритм, который соберёт все данные.</p>
<h2><span id="staticheskoe-izuchenie-otladochnoy-informacii">Статическое изучение отладочной информации</span><a href="#staticheskoe-izuchenie-otladochnoy-informacii" class="header-anchor">#</a></h2><p>Я набросал примерно <a target="_blank" rel="noopener" href="https://gist.github.com/spiiin/d9edf2c32f555b530b1413d632c14888">такой скрипт</a> в <code>Jupyter</code> с использованием библиотеки <code>Dwex/pyelftools</code>, чтобы проверить результаты. После нескольких исправлений он работает <em>почти правильно</em> (не ходит рекурсивно по всем членам, из-за чего не может узнать их выравнивание, так что предполагает выравнивание в 8 байт (зачастую оказывается прав из-за того, что классы содержат указатели :), и сравнивает полученные рассчётами размер с тем, что записан в dwarf - так что можно узнать, корректно ли он отработал. Тем не менее, скрипт точно показывает <strong><code>относительное смещение</code></strong> каждого члена структуры и знает <strong><code>размер каждого члена</code></strong>, а значит, и <strong><code>паддинг</code></strong>, т.е. его в большинстве случаев можно использовать для того, чтобы найти “дыры” внутри структур.<br><img src="/blog/854775037/dwarf_pad_analyze_small.png" alt="dwarf-pad"></p>
<p>Пример вывода скрипта:<br><figure class="shiki"><div class="codeblock"><div class="code"><pre class="shiki slack-dark"><code><span class="line"><span style="color: #E6E6E6">b&#39;alphaModeChanged&#39;      | 720 |&lt; 32&gt; | b&#39;function&lt;void (int)&gt;&#39;</span></span>
<span class="line"><span style="color: #E6E6E6">b&#39;texture&#39;               | 752 |&lt; 16&gt; | b&#39;sharedResource&lt;tex&gt;&#39;</span></span>
<span class="line"><span style="color: #E6E6E6">b&#39;maskTexture&#39;           | 768 |&lt; 16&gt; | b&#39;sharedResource&lt;tex&gt;&#39;</span></span>
<span class="line"><span style="color: #E6E6E6">b&#39;maskRender&#39;            | 784 |&lt;  8&gt; | b&#39;ptr render&#39;</span></span>
<span class="line"><span style="color: #E6E6E6">b&#39;alphaModeCoefficient&#39;  | 792 |&lt;  4&gt; | b&#39;float&#39;  </span></span>
<span class="line"><span style="color: #E6E6E6">b&#39;batching&#39;              | 796 |&lt;  1&gt; | b&#39;bool&#39;   </span></span>
<span class="line"><span style="color: #E6E6E6">b&#39;drawOnlyAdditive&#39;      | 797 |&lt;  1&gt; | b&#39;bool&#39;   </span></span>
<span class="line"><span style="color: #E6E6E6">b&#39;mode&#39;                  | 798 |&lt;  1&gt; | b&#39;blendMode&#39;</span></span>
<span class="line"><span style="color: #E6E6E6">b&#39;flipX&#39;                 | 799 |&lt;  1&gt; | b&#39;bool&#39;   </span></span>
<span class="line"><span style="color: #E6E6E6">b&#39;flipY&#39;                 | 800 |&lt;  1&gt; | b&#39;bool&#39;   </span></span>
<span class="line"><span style="color: #E6E6E6">b&#39;logged&#39;                | 801 |&lt;  1&gt; | b&#39;bool&#39;   </span></span>
<span class="line"><span style="color: #E6E6E6">---padding---            | 802 |&lt;  6&gt; | ---unused---</span></span>
<span class="line"><span style="color: #E6E6E6">b&#39;texturePart&#39;           | 808 |&lt;  8&gt; | b&#39;ptr texPart&#39;</span></span>
<span class="line"><span style="color: #E6E6E6">b&#39;part&#39;                  | 816 |&lt; 24&gt; | b&#39;basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt;&#39;</span></span>
<span class="line"><span style="color: #E6E6E6">b&#39;maskImageSize&#39;         | 840 |&lt;  8&gt; | b&#39;pair&lt;float, float&gt;&#39;</span></span>
<span class="line"><span style="color: #E6E6E6">b&#39;needHitTest&#39;           | 848 |&lt;  1&gt; | b&#39;bool&#39;   </span></span>
<span class="line"><span style="color: #E6E6E6">           padded offset: 848</span></span>
<span class="line"><span style="color: #E6E6E6">^^^------- sprite--------^^^</span></span></code></pre></div></div></figure></p>
<p>Для Linux есть утилита <a target="_blank" rel="noopener" href="https://lwn.net/Articles/335942/">pahole</a> и скрипт <del><a target="_blank" rel="noopener" href="https://github.com/arvidn/struct_layout">struct_layout</a> (он использует linux утилиту dwarfdump)</del> (сырая и не работает), которые также умеют показывать пустоты внутри структур, но мне не удалось завести их <code>Android/iOS</code>.</p>
<h2><span id="poluchenie-dannyh-ot-clang-vo-vremya-kompilyacii">Получение данных от Clang во время компиляции</span><a href="#poluchenie-dannyh-ot-clang-vo-vremya-kompilyacii" class="header-anchor">#</a></h2><p>Другой интересный подход - <code>Clang</code> с ключом <strong><code>-Xclang  -fdump-record-layouts</code></strong> (<a target="_blank" rel="noopener" href="https://eli.thegreenplace.net/2012/12/17/dumping-a-c-objects-memory-layout-with-clang/">статья</a>) выводит прямо в stdout данные о расположении структур в памяти (аналогично, для <code>Visual C++</code> - <strong><code>/d1reportAllClassLayout</code></strong>.</p>
<p>Это удобно для небольших типов, пример: <a target="_blank" rel="noopener" href="https://gcc.godbolt.org/z/3fev6fc5d">https://gcc.godbolt.org/z/3fev6fc5d</a>, но на реальных проекта выдаёт несколько десятков мегабайт текста на каждый файл (так что приходится не добавлять ключ в <code>XCode/Android Studio</code>, а просто скопировать командную строку из среды разработки и вызывать её из консоли для одного файла, иначе есть риск получить десятки гигабайт текста).</p>
<p>Тогда можно набросать <a target="_blank" rel="noopener" href="https://gist.github.com/spiiin/9b19c549d1367fb00ad301896423a82b">скрипт</a>, который парсит текстовый вывод и отображает его в виде дерева:<br><img src="/blog/854775037/string_ndk_small.png" alt="string-ndk"><br><em>(если анализировать не stl, а свои типы, то всё выглядит понятнее)</em></p>
<p>Этот подход показывает корректные <strong><code>выравнивания</code></strong> всех структур, но Clang не показывает <strong><code>размеры</code></strong> вложенных членов (на скриншоте размеры, полученные другим способом), а значит, в таком выводе не видны <strong><code>паддинги</code></strong>.</p>
<p>Cкорее всего можно получить все нужные данные от Clang, если не охотится за его выводом в текстовом виде, а использовать его <a target="_blank" rel="noopener" href="https://clang.llvm.org/docs/Tooling.html">API</a>, однако его компиляция - отдельное приключение =\ Кажется, <a target="_blank" rel="noopener" href="https://github.com/def-/ycmd/commit/2a7124bcb5730f301e3e73a4af81316bbff81926">что-то подобное</a> - обращение к libclang за размером типы и выравниванием).</p>
<h2><span id="vyvody">Выводы</span><a href="#vyvody" class="header-anchor">#</a></h2><p>Если немного заморочиться с написанием вспомогательных скриптов (каждый из них пока не доделан до конца, когда-нибудь я их закончу), то можно заглянуть сквозь тему внутрь объектов. Только осторожно, есть шансы наткнуться там на упырей, питающихся памятью, с которыми потом придётся начинать бороться!<br><img src="/blog/854775037/shadows_small.png" alt="shadows-small"></p>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"Ov23liG1mZbiQOIdi91X","clientSecret":"e05812685eb741a752982b89dcf6f5b58dc10251","repo":"spiiin.github.io","owner":"spiiin","admin":["spiiin"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script></div></article><div class="pagination"><a class="pagination__link pagination__prev" href="/blog/1170009669/">Позже</a><a class="pagination__link pagination__next" href="/blog/1552834708/">Раньше</a></div></main><footer class="footer metadata"><p class="footer__text">© 2024 spiiin</p><p class="footer__text">Powered by <a class="footer__text__link" href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a class="footer__text__link" href="https://pages.github.com/" target="_blank">Github Page</a></p></footer></div><!-- hexo injector body_end start -->
  <script>
  const CODE_CONFIG = {
    beautify: undefined,
    highlightCopy: undefined,
    highlightLang: undefined,
    highlightHeightLimit: undefined,
    isHighlightShrink: undefined,
    copy: {
      success: 'undefined',
      error: 'undefined',
      noSupport: 'undefined',
    }
  };
  console.log(
    `%c hexo-shiki-plugin %c v1.0.27 %c https://github.com/nova1751/hexo-shiki-plugin`,
    "color: #fff; background: #5f5f5f",
    "color: #fff; background: #80c8f8",
    ""
  );
  </script>
  <!-- hexo injector body_end end --></body></html>