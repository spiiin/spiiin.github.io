<!DOCTYPE html><html lang="ru"><head><meta charset="UTF-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Spiiin's blog | daScript. SFML, dasBox и semi-transparent render target</title><meta name="description" content=""><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=PT+Serif&amp;display=swap"><link rel="stylesheet" href="/css/highlights/darkula.css"><link rel="stylesheet" href="/css/main.css"><link rel="search" type="application/opensearchdescription+xml" href="http://spiiin.github.io/atom.xml" title="Spiiin's blog"><script>(function (i, s, o, g, r, a, m) {
  i['GoogleAnalyticsObject'] = r;
  i[r] = i[r] || function () {
    (i[r].q = i[r].q || []).push(arguments)
  }, i[r].l = 1 * new Date();
  a = s.createElement(o),
    m = s.getElementsByTagName(o)[0];
  a.async = 1;
  a.src = g;
  m.parentNode.insertBefore(a, m)
})(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');
ga('create', 'UA-00000000-0', 'auto');
ga('send', 'pageview');</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Spiiin's blog" type="application/atom+xml">
</head><body><div class="container"><header class="main-header"><h1 class="main-header__title uplize"><a class="main-header__title__link" href="/"><img class="header-image" src="/images/favicon.png" width="36" height="36">Spiiin's blog</a></h1><nav class="main-header__nav"><ul class="main-nav"><li class="main-nav__list"><a class="main-nav__list__link" href="/" target="_self">HOME</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/archives/" target="_self">ARCHIVE</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/tags/meta" target="_self">TAGS</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/blog/1" target="_self">ABOUT</a></li></ul></nav></header><main class="container__wrapper"><div class="pagination"><a class="pagination__link pagination__prev" href="/blog/887709799/">Позже</a><a class="pagination__link pagination__next" href="/blog/2385889062/">Раньше</a></div><article class="article post"><h3 class="article__title">daScript. SFML, dasBox и semi-transparent render target</h3><div class="article__date metadata"><div class="post-info">2022/10/22</div></div><div class="article__tags metadata">Tags:
<a class="article__tags__link metadata" href="/tags/opengl/">opengl</a><a class="article__tags__link metadata" href="/tags/dascript/">dascript</a></div><div class="article__body"><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Пример работы с SFML в dasBox — рендер полупрозрачных объектов в рендер-таргет. Тривиальная задача для графического программиста, но почему-то многие разработчики игр не знают, как это корректно сделать.</p>
<h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>Изначальная задумка поста — собрать небольшой пример, показывающий алгоритм рендеринга полупрозрачных объектов в текстуру, с последующим корректным отображением этой текстуры, как если бы объекты рендерились на экран напрямую, без использования этой текстуры. Но попутно оказалось, что можно запилить фреймворк для таких демок, с возможноостью в live-режиме поиграться с параметрами и посмотреть результат.</p>
<h2 id="dasSFML"><a href="#dasSFML" class="headerlink" title="dasSFML"></a>dasSFML</h2><p>Примеры на <code>Opengl+GLFW</code>:<br><a href="/blog/4232971949/" title="daScript OpenGL">daScript OpenGL</a><br><a href="/blog/3006126295/" title="daScript - live-режим">daScript - live-режим</a></p>
<p>В отличие от GLFW, <code>SFML</code> представляет простые объекты-обёртки над функциями OpenGL для работы с текстурами, шейдерами, рендер-таргетами, и прочими примитивами библиотеки рендера, в то же время представляя для кастомизации практически все параметры рендера (во всяком случае необходимые для задуманного примера), для того, чтобы можно было писать небольшие примеры алгоритмов рендера на OpenGL.</p>
<p>Для начала, можно “завести” простейший <a href="https://github.com/borisbat/dasSFML/blob/main/examples/graphics.das" target="_blank" rel="noopener">пример</a> из комплекта привязки <code>SFML</code> к <code>daScript</code>.</p>
<p>Для его сборки выкачиваем сабмодули <code>daScript</code>:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git submodule update --init --recursive</span><br></pre></td></tr></table></figure></p>
<p>Затем включаем сборку этого модуля в CmakeLists.txt и добавляем линковку статической библиотеки с модулем libDasSFML и самих библиотек SFML:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">option(DAS_SFML_DISABLED &quot;Disable dasSFML (SFML multimedia library)&quot; OFF)</span><br><span class="line">...</span><br><span class="line">target_link_libraries(sfmlApp</span><br><span class="line">  libDasModuleSFML</span><br><span class="line">  sfml-graphics</span><br><span class="line">  sfml-network</span><br><span class="line">  sfml-system</span><br><span class="line">  sfml-window</span><br><span class="line">  #для windows также:</span><br><span class="line">  legacy_stdio_definitions</span><br><span class="line">  winmm</span><br><span class="line">  Opengl32</span><br><span class="line">  sfml-main</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>и перегененируем проект<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;generate_msvc_2019.bat</span><br></pre></td></tr></table></figure></p>
<p>Затем в хост-приложении на C++:<br><div style="color: #d4d4d4;background-color: #1e1e1e;font-family: Consolas, 'Courier New', monospace;font-weight: normal;font-size: 14px;line-height: 19px;white-space: pre;"><div><span style="color: #6a9955;">//подключение заголовка с определением модуля</span></div><div><span style="color: #d4d4d4;">#include &lt;dasSFML/src/dasSFML.h&gt;</span></div><div><span style="color: #d4d4d4;">...</span></div><div><span style="color: #d4d4d4;">&#160; </span><span style="color: #4ec9b0;">int</span><span style="color: #d4d4d4;"> main( </span><span style="color: #4ec9b0;">int</span><span style="color: #d4d4d4;">, char * [] ) {</span></div><div><span style="color: #d4d4d4;">&#160; &#160; NEED_ALL_DEFAULT_MODULES;</span></div><div><span style="color: #d4d4d4;">&#160; &#160; NEED_MODULE(Module_dasSFML); </span><span style="color: #6a9955;">//&lt;---создаём модуль sfml</span></div><div><span style="color: #d4d4d4;">&#160; &#160; Module::Initialize();</span></div><div><span style="color: #d4d4d4;">&#160; &#160; run_script();</span></div><div><span style="color: #d4d4d4;">&#160; &#160; Module::Shutdown();</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">return</span><span style="color: #d4d4d4;"> </span><span style="color: #b5cea8;">0</span><span style="color: #d4d4d4;">;</span></div><div><span style="color: #d4d4d4;">}</span></div></div></p>
<p><code>run_script</code> вызывает метод <code>main</code> из примера, который создаёт SFML-окно и запускает цикл обработки сообщений в нём.</p>
<div style="color: #d4d4d4;background-color: #1e1e1e;font-family: Consolas, 'Courier New', monospace;font-weight: normal;font-size: 14px;line-height: 19px;white-space: pre;"><div><span style="color: #d4d4d4;">[</span><span style="color: #569cd6;">export</span><span style="color: #d4d4d4;">]</span></div><div><span style="color: #c586c0;">def</span><span style="color: #d4d4d4;"> main</span></div><div><span style="color: #d4d4d4;">&#160; &#160; using(VideoMode(</span><span style="color: #b5cea8;">64</span><span style="color: #d4d4d4;">0u,</span><span style="color: #b5cea8;">48</span><span style="color: #d4d4d4;">0u), </span><span style="color: #ce9178;">"SFML window"</span><span style="color: #d4d4d4;">, uint(WindowStyle Default), ContextSettings()) &lt;| </span><span style="color: #569cd6;">$</span><span style="color: #d4d4d4;"> ( </span><span style="color: #569cd6;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">window </span><span style="color: #d4d4d4;">: RenderWindow# )</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">while</span><span style="color: #d4d4d4;"> window |&gt; isOpen()</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> event : Event</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">while</span><span style="color: #d4d4d4;"> window |&gt; pollEvent(event)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">if</span><span style="color: #d4d4d4;"> event._type == EventType Closed</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; window |&gt; close()</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; interface(window) &lt;| </span><span style="color: #569cd6;">$</span><span style="color: #d4d4d4;"> ( </span><span style="color: #569cd6;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">rt </span><span style="color: #d4d4d4;">: RenderTarget )</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; rt |&gt; </span><span style="color: #dcdcaa;">clear</span><span style="color: #d4d4d4;">( Color(</span><span style="color: #b5cea8;">6</span><span style="color: #d4d4d4;">4u,</span><span style="color: #b5cea8;">0</span><span style="color: #d4d4d4;">u,</span><span style="color: #b5cea8;">0</span><span style="color: #d4d4d4;">u,</span><span style="color: #b5cea8;">25</span><span style="color: #d4d4d4;">5u) )</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; using(</span><span style="color: #b5cea8;">50.0f</span><span style="color: #d4d4d4;">,</span><span style="color: #b5cea8;">0x1e</span><span style="color: #d4d4d4;">ul) &lt;| </span><span style="color: #569cd6;">$</span><span style="color: #d4d4d4;"> ( </span><span style="color: #569cd6;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">shape </span><span style="color: #d4d4d4;">: CircleShape# )</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; interface(shape) &lt;| </span><span style="color: #569cd6;">$</span><span style="color: #d4d4d4;"> ( </span><span style="color: #569cd6;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">tr </span><span style="color: #d4d4d4;">: Transformable )</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; tr |&gt; move(</span><span style="color: #b5cea8;">20.</span><span style="color: #d4d4d4;">,</span><span style="color: #b5cea8;">30.</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; shape |&gt; setFillColor(Color(</span><span style="color: #b5cea8;">15</span><span style="color: #d4d4d4;">0u,</span><span style="color: #b5cea8;">5</span><span style="color: #d4d4d4;">0u,</span><span style="color: #b5cea8;">25</span><span style="color: #d4d4d4;">0u,</span><span style="color: #b5cea8;">25</span><span style="color: #d4d4d4;">5u))</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; shape |&gt; setOutlineThickness(</span><span style="color: #b5cea8;">10.f</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; shape |&gt; setOutlineColor(Color(</span><span style="color: #b5cea8;">25</span><span style="color: #d4d4d4;">0u,</span><span style="color: #b5cea8;">15</span><span style="color: #d4d4d4;">0u,</span><span style="color: #b5cea8;">10</span><span style="color: #d4d4d4;">0u,</span><span style="color: #b5cea8;">25</span><span style="color: #d4d4d4;">5u))</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; rt |&gt; draw(shape, RenderStates_Default())</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; window |&gt; display()</span></div></div>
<p>В качестве фреймворка для создания окна используется имеющийся в SFML класс <code>Window</code>. Однако проще воспользоваться другим фреймворком, в который уже внедрены возможности daScript-а по перезагрузке кода.</p>
<h2 id="dasbox"><a href="#dasbox" class="headerlink" title="dasbox"></a>dasbox</h2><p><a href="https://github.com/imp5imp5/dasbox" target="_blank" rel="noopener">dasbox</a> — примитивный движок для 2d-игр, который Gaijin-ы использовали для проведения конкурса <a href="https://gaijinjam.net/ru" target="_blank" rel="noopener">Gaijin Jam</a> (<a href="https://github.com/AlexLemminG/TheFarmers" target="_blank" rel="noopener">игра-победитель</a>). Движок имеет простую <a href="https://github.com/imp5imp5/dasbox/blob/main/doc/api.txt" target="_blank" rel="noopener">апишку</a>, на которой можно потренироваться использованию языка на уровне “как будто типизированная lua”, а также настроен для подключения отладчика языка, веб-инспектора для отображения состояния ecs-модуля и горячей перезагрузке кода.</p>
<p>Но для меня интереснее другое — <code>dasbox</code> использует в качестве бекэнда <code>SFML</code>. И хотя это осознанно скрыто от пользователей для того, чтобы можно было сменить бекэнд, можно немного “поломать инкапсуляцию”, для того, чтобы воспользоваться в нём модулем <code>dasSFML</code>, и получить доступ к более богатому API, получив от самого dasbox-а фичи и инструменты по работе с кодом.</p>
<p><a href="https://github.com/spiiin/dasbox_sfml" target="_blank" rel="noopener">dasbox_sfml</a> — порт дасбокса с включенным модулем dasSFML.</p>
<p>Базовый пример на нём выглядит так:<br><div style="color: #d4d4d4;background-color: #1e1e1e;font-family: Consolas, 'Courier New', monospace;font-weight: normal;font-size: 14px;line-height: 19px;white-space: pre;"><div><span style="color: #c586c0;">require</span><span style="color: #d4d4d4;"> daslib/media</span></div><div><span style="color: #c586c0;">require</span><span style="color: #d4d4d4;"> sfml</span></div><div><span style="color: #c586c0;">require</span><span style="color: #d4d4d4;"> dasbox_sfml</span></div><br><div><span style="color: #d4d4d4;">[</span><span style="color: #569cd6;">export</span><span style="color: #d4d4d4;">]</span></div><div><span style="color: #c586c0;">def</span><span style="color: #d4d4d4;"> initialize</span></div><div><span style="color: #d4d4d4;">&#160; &#160; set_window_title(</span><span style="color: #ce9178;">"sfml"</span><span style="color: #d4d4d4;">)</span></div><br><div><span style="color: #d4d4d4;">[</span><span style="color: #569cd6;">export</span><span style="color: #d4d4d4;">]</span></div><div><span style="color: #569cd6;">def</span><span style="color: #d4d4d4;"> </span><span style="color: #dcdcaa;">act</span><span style="color: #d4d4d4;">(</span><span style="color: #9cdcfe;">dt</span><span style="color: #d4d4d4;">: </span><span style="color: #4ec9b0;">float</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">if</span><span style="color: #d4d4d4;"> get_key(VK_ESCAPE)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; schedule_quit_game()</span></div><br><div><span style="color: #d4d4d4;">[</span><span style="color: #569cd6;">export</span><span style="color: #d4d4d4;">]</span></div><div><span style="color: #c586c0;">def</span><span style="color: #d4d4d4;"> draw</span></div><div><span style="color: #d4d4d4;">&#160; &#160; withRenderTarget &lt;| </span><span style="color: #569cd6;">$</span><span style="color: #d4d4d4;">(</span><span style="color: #569cd6;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">rt</span><span style="color: #d4d4d4;">: RenderTarget&amp;)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; rt |&gt; </span><span style="color: #dcdcaa;">clear</span><span style="color: #d4d4d4;">(Color(</span><span style="color: #b5cea8;">0</span><span style="color: #d4d4d4;">u,</span><span style="color: #b5cea8;">25</span><span style="color: #d4d4d4;">5u,</span><span style="color: #b5cea8;">0</span><span style="color: #d4d4d4;">u,</span><span style="color: #b5cea8;">25</span><span style="color: #d4d4d4;">5u))</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; using(</span><span style="color: #b5cea8;">50.0f</span><span style="color: #d4d4d4;">,</span><span style="color: #b5cea8;">0x1e</span><span style="color: #d4d4d4;">ul) &lt;| </span><span style="color: #569cd6;">$</span><span style="color: #d4d4d4;">(</span><span style="color: #569cd6;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">shape</span><span style="color: #d4d4d4;">: CircleShape#)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; interface(shape) &lt;| </span><span style="color: #569cd6;">$</span><span style="color: #d4d4d4;">(</span><span style="color: #569cd6;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">tr</span><span style="color: #d4d4d4;">: Transformable)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; tr |&gt; move(</span><span style="color: #b5cea8;">20.</span><span style="color: #d4d4d4;">,</span><span style="color: #b5cea8;">30.</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; shape |&gt; setFillColor(Color(</span><span style="color: #b5cea8;">15</span><span style="color: #d4d4d4;">0u,</span><span style="color: #b5cea8;">5</span><span style="color: #d4d4d4;">0u,</span><span style="color: #b5cea8;">25</span><span style="color: #d4d4d4;">0u,</span><span style="color: #b5cea8;">25</span><span style="color: #d4d4d4;">5u))</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; shape |&gt; setOutlineThickness(</span><span style="color: #b5cea8;">10.f</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; shape |&gt; setOutlineColor(Color(</span><span style="color: #b5cea8;">25</span><span style="color: #d4d4d4;">0u,</span><span style="color: #b5cea8;">15</span><span style="color: #d4d4d4;">0u,</span><span style="color: #b5cea8;">10</span><span style="color: #d4d4d4;">0u,</span><span style="color: #b5cea8;">25</span><span style="color: #d4d4d4;">5u))</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; rt |&gt; draw(shape, RenderStates_Default())</span></div></div><br><img src="/blog/4060902549/screen1_small.png" alt=""></p>
<p><code>dasBox_sfml</code> подхватывает изменения в файле с кодом, а также отображает в своей консоли ошибки в этом файле.</p>
<p>Идиомы <code>daScript</code> в примере:</p>
<ul>
<li><code>using()</code> - создание переменной <a href="https://dascript.org/doc/reference/language/temporary.html" target="_blank" rel="noopener">временного типа</a>, который существует только в пределах блока using</li>
</ul>
<div style="color: #d4d4d4;background-color: #1e1e1e;font-family: Consolas, 'Courier New', monospace;font-weight: normal;font-size: 14px;line-height: 19px;white-space: pre;"><div><span style="color: #d4d4d4;">using() &lt;| </span><span style="color: #569cd6;">$</span><span style="color: #d4d4d4;">(</span><span style="color: #569cd6;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">fs</span><span style="color: #d4d4d4;">: das_string#)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; fs := </span><span style="color: #ce9178;">"hello world"</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #6a9955;">//тут можно использовать переменную, в том числе передавать в другие функции</span></div><div><span style="color: #d4d4d4;">&#160; &#160; some_func(fs)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #6a9955;">//но нельзя как-либо сохранить указатель на эту переменную</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #6a9955;">//var s = fs //ошибка, нельзя копировать временный тип</span></div></div>
<ul>
<li><code>interface</code> - приведение к базовому типу</li>
</ul>
<p>Генератор привязок на C++ позволяет передать отношение наследования двух C++ типов в daScript так:<br><div style="color: #d4d4d4;background-color: #1e1e1e;font-family: Consolas, 'Courier New', monospace;font-weight: normal;font-size: 14px;line-height: 19px;white-space: pre;"><div><span style="color: #d4d4d4;">addExtern&lt; decltype(&amp;with_interface&lt;sf::Sprite,sf::Transformable&gt;), with_interface&lt;sf::Sprite,sf::Transformable&gt; &gt;(*this,lib,</span><span style="color: #ce9178;">"interface"</span><span style="color: #d4d4d4;">,SideEffects::</span><span style="color: #dcdcaa;">invoke</span><span style="color: #d4d4d4;">,</span><span style="color: #ce9178;">"with_interface&lt;sf::Sprite,sf::Transformable&gt;"</span><span style="color: #d4d4d4;">);</span></div></div></p>
<p><code>daScript</code> заставляет думать о типах и их времени жизни немного больше, чем C++, но и позволяет выразить больше таких утверждений, которые сможет проверить компилятор, чтобы уберечься от ошибок.</p>
<h2 id="RenderTarget"><a href="#RenderTarget" class="headerlink" title="RenderTarget"></a>RenderTarget</h2><p>Следующий пример — рендер в текстуру и отображение её на экране. В SFML для этого можно использовать класс <a href="https://www.sfml-dev.org/documentation/2.5.1/classsf_1_1RenderTexture.php" target="_blank" rel="noopener">RenderTexture</a></p>
<div style="color: #d4d4d4;background-color: #1e1e1e;font-family: Consolas, 'Courier New', monospace;font-weight: normal;font-size: 14px;line-height: 19px;white-space: pre;"><div><span style="color: #c586c0;">def</span><span style="color: #d4d4d4;"> draw</span></div><div><span style="color: #d4d4d4;">&#160; &#160; withRenderTarget &lt;| </span><span style="color: #569cd6;">$</span><span style="color: #d4d4d4;">(</span><span style="color: #569cd6;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">rt</span><span style="color: #d4d4d4;">: RenderTarget&amp;)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #dcdcaa;">clear</span><span style="color: #d4d4d4;">(rt, Color(</span><span style="color: #b5cea8;">0</span><span style="color: #d4d4d4;">u,</span><span style="color: #b5cea8;">25</span><span style="color: #d4d4d4;">5u,</span><span style="color: #b5cea8;">0</span><span style="color: #d4d4d4;">u,</span><span style="color: #b5cea8;">25</span><span style="color: #d4d4d4;">5u))</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; using() &lt;| </span><span style="color: #569cd6;">$</span><span style="color: #d4d4d4;">(</span><span style="color: #569cd6;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">rtTex</span><span style="color: #d4d4d4;">: RenderTexture#)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; rtTex |&gt; create(</span><span style="color: #b5cea8;">30</span><span style="color: #d4d4d4;">0u, </span><span style="color: #b5cea8;">30</span><span style="color: #d4d4d4;">0u, </span><span style="color: #c586c0;">false</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; using(</span><span style="color: #b5cea8;">50.0f</span><span style="color: #d4d4d4;">,</span><span style="color: #b5cea8;">0x1e</span><span style="color: #d4d4d4;">ul) &lt;| </span><span style="color: #569cd6;">$</span><span style="color: #d4d4d4;">(</span><span style="color: #569cd6;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">shape</span><span style="color: #d4d4d4;">: CircleShape#)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; interface(shape) &lt;| </span><span style="color: #569cd6;">$</span><span style="color: #d4d4d4;">(</span><span style="color: #569cd6;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">tr</span><span style="color: #d4d4d4;">: Transformable)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; tr |&gt; move(</span><span style="color: #b5cea8;">20.</span><span style="color: #d4d4d4;">,</span><span style="color: #b5cea8;">30.</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; shape |&gt; setFillColor(Color(</span><span style="color: #b5cea8;">15</span><span style="color: #d4d4d4;">0u,</span><span style="color: #b5cea8;">5</span><span style="color: #d4d4d4;">0u,</span><span style="color: #b5cea8;">25</span><span style="color: #d4d4d4;">0u,</span><span style="color: #b5cea8;">25</span><span style="color: #d4d4d4;">5u))</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; shape |&gt; setOutlineThickness(</span><span style="color: #b5cea8;">10.f</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; shape |&gt; setOutlineColor(Color(</span><span style="color: #b5cea8;">25</span><span style="color: #d4d4d4;">0u,</span><span style="color: #b5cea8;">15</span><span style="color: #d4d4d4;">0u,</span><span style="color: #b5cea8;">10</span><span style="color: #d4d4d4;">0u,</span><span style="color: #b5cea8;">25</span><span style="color: #d4d4d4;">5u))</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; rtTex |&gt; draw(shape, RenderStates_Default())</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; using(rtTex |&gt; getTexture()) &lt;| </span><span style="color: #569cd6;">$</span><span style="color: #d4d4d4;">(</span><span style="color: #569cd6;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">sprite</span><span style="color: #d4d4d4;">: Sprite#)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; rt |&gt; draw(sprite, RenderStates_Default())</span></div></div>
<p>Пока всё хорошо, и круг отрендеренный в текстуру выглядит также, как если бы был выведен на экран напрямую</p>
<h2 id="Полупрозрачные-объекты-в-RenderTarget"><a href="#Полупрозрачные-объекты-в-RenderTarget" class="headerlink" title="Полупрозрачные объекты в RenderTarget"></a>Полупрозрачные объекты в RenderTarget</h2><div style="color: #d4d4d4;background-color: #1e1e1e;font-family: Consolas, 'Courier New', monospace;font-weight: normal;font-size: 14px;line-height: 19px;white-space: pre;"><div><span style="color: #6a9955;">//рендер двух полупрозрачных кругов</span></div><div><span style="color: #569cd6;">def</span><span style="color: #d4d4d4;"> </span><span style="color: #dcdcaa;">drawCircles</span><span style="color: #d4d4d4;">(</span><span style="color: #569cd6;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">rt</span><span style="color: #d4d4d4;">: RenderTarget&amp;)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; using(</span><span style="color: #b5cea8;">125.0f</span><span style="color: #d4d4d4;">, </span><span style="color: #b5cea8;">12</span><span style="color: #d4d4d4;">8ul) &lt;| </span><span style="color: #569cd6;">$</span><span style="color: #d4d4d4;">(</span><span style="color: #569cd6;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">shape</span><span style="color: #d4d4d4;">: CircleShape#)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; shape |&gt; setFillColor(Color(</span><span style="color: #b5cea8;">0</span><span style="color: #d4d4d4;">u,</span><span style="color: #b5cea8;">25</span><span style="color: #d4d4d4;">5u,</span><span style="color: #b5cea8;">0</span><span style="color: #d4d4d4;">u,</span><span style="color: #b5cea8;">12</span><span style="color: #d4d4d4;">8u))</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; rt |&gt; draw(shape, RenderStates_Default())</span></div><div><span style="color: #d4d4d4;">&#160; &#160; using(</span><span style="color: #b5cea8;">125.0f</span><span style="color: #d4d4d4;">, </span><span style="color: #b5cea8;">12</span><span style="color: #d4d4d4;">8ul) &lt;| </span><span style="color: #569cd6;">$</span><span style="color: #d4d4d4;">(</span><span style="color: #569cd6;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">shape</span><span style="color: #d4d4d4;">: CircleShape#)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; interface(shape) &lt;| </span><span style="color: #569cd6;">$</span><span style="color: #d4d4d4;">(</span><span style="color: #569cd6;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">tr</span><span style="color: #d4d4d4;">: Transformable) { tr |&gt; move(</span><span style="color: #b5cea8;">125.0f</span><span style="color: #d4d4d4;">, </span><span style="color: #b5cea8;">0.0f</span><span style="color: #d4d4d4;">); }</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; shape |&gt; setFillColor(Color(</span><span style="color: #b5cea8;">25</span><span style="color: #d4d4d4;">5u,</span><span style="color: #b5cea8;">05u</span><span style="color: #d4d4d4;">,</span><span style="color: #b5cea8;">0</span><span style="color: #d4d4d4;">u,</span><span style="color: #b5cea8;">12</span><span style="color: #d4d4d4;">8u))</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; rt |&gt; draw(shape, RenderStates_Default())</span></div><br><div><span style="color: #d4d4d4;">[</span><span style="color: #569cd6;">export</span><span style="color: #d4d4d4;">]</span></div><div><span style="color: #c586c0;">def</span><span style="color: #d4d4d4;"> draw</span></div><div><span style="color: #d4d4d4;">&#160; &#160; withRenderTarget &lt;| </span><span style="color: #569cd6;">$</span><span style="color: #d4d4d4;">(</span><span style="color: #569cd6;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">rt</span><span style="color: #d4d4d4;">: RenderTarget&amp;)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; rt |&gt; </span><span style="color: #dcdcaa;">clear</span><span style="color: #d4d4d4;">(Color(</span><span style="color: #b5cea8;">25</span><span style="color: #d4d4d4;">5u,</span><span style="color: #b5cea8;">25</span><span style="color: #d4d4d4;">5u,</span><span style="color: #b5cea8;">25</span><span style="color: #d4d4d4;">5u,</span><span style="color: #b5cea8;">25</span><span style="color: #d4d4d4;">5u))</span></div><br><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #6a9955;">//простой рендер</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; text_out(</span><span style="color: #b5cea8;">0</span><span style="color: #d4d4d4;">, </span><span style="color: #b5cea8;">0</span><span style="color: #d4d4d4;">, </span><span style="color: #ce9178;">"Simple"</span><span style="color: #d4d4d4;">, </span><span style="color: #b5cea8;">0xFF000000</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; drawCircles(rt)</span></div><br><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #6a9955;">//рендер в текстуру</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; text_out(</span><span style="color: #b5cea8;">0</span><span style="color: #d4d4d4;">, </span><span style="color: #b5cea8;">300</span><span style="color: #d4d4d4;">, </span><span style="color: #ce9178;">"Texture"</span><span style="color: #d4d4d4;">, </span><span style="color: #b5cea8;">0xFF000000</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; using() &lt;| </span><span style="color: #569cd6;">$</span><span style="color: #d4d4d4;">(</span><span style="color: #569cd6;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">rtTex</span><span style="color: #d4d4d4;">: RenderTexture#)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; rtTex |&gt; create(</span><span style="color: #b5cea8;">25</span><span style="color: #d4d4d4;">0u + </span><span style="color: #b5cea8;">12</span><span style="color: #d4d4d4;">5u, </span><span style="color: #b5cea8;">25</span><span style="color: #d4d4d4;">0u, </span><span style="color: #c586c0;">false</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; rtTex |&gt; </span><span style="color: #dcdcaa;">clear</span><span style="color: #d4d4d4;">(Color(</span><span style="color: #b5cea8;">0</span><span style="color: #d4d4d4;">u, </span><span style="color: #b5cea8;">0</span><span style="color: #d4d4d4;">u, </span><span style="color: #b5cea8;">0</span><span style="color: #d4d4d4;">u, </span><span style="color: #b5cea8;">0</span><span style="color: #d4d4d4;">u))</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; drawCircles(rtTex)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; using(rtTex |&gt; getTexture()) &lt;| </span><span style="color: #569cd6;">$</span><span style="color: #d4d4d4;">(</span><span style="color: #569cd6;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">sprite</span><span style="color: #d4d4d4;">: Sprite#)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; interface(sprite) &lt;| </span><span style="color: #569cd6;">$</span><span style="color: #d4d4d4;">(</span><span style="color: #569cd6;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">tr</span><span style="color: #d4d4d4;">: Transformable)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; tr |&gt; move(</span><span style="color: #b5cea8;">0.0f</span><span style="color: #d4d4d4;">, </span><span style="color: #b5cea8;">300.0f</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; rt |&gt; draw(sprite, RenderStates_Default())</span></div></div>
<p><img src="/blog/4060902549/screen2_small.png" alt=""></p>
<p>Полупрозрачные круги, отрендеренные в текстуру, выглядят темнее, чем отрисованные на экране напрямую. С реальными текстурами (или отрендеренными в текстуру шрифтами), проблема обычно выглядит как темная рамка на краях объекта (там где края ради сглаживания плавно “уходят” в прозрачность).</p>
<p>Из-за чего это возникает?</p>
<p>Цвет пиксела отрисованного объекта смешивается в пикселем, уже находящимся в буфере цвете по настраиваемым формулам. При прямой отрисовке порядок рендера получается таким:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">рисуется пиксел красного круга -&gt; смешивается с цветом dst1 фона (белое изображение) &#x3D; получаем цвет dst2</span><br><span class="line">рисуется пиксел зеленого круга -&gt; смешивается с цветом dst2 (фон + красный круг)</span><br></pre></td></tr></table></figure></p>
<p>Тогда как в случае рендера в текстуру происходит:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">рисуется пиксел красного круга -&gt; смешивается с фоновым цветом рендер таргет текстуры dst_rt1 (&quot;пустой&quot; rgba цвет, rgb каналы по умолчанию чёрные) &#x3D; получаем dst_rt2</span><br><span class="line">рисуется пиксел зелёного круга -&gt; смешивается с цветом dst_rt2 (пустой цвет текстуры + красный круг)</span><br><span class="line">текстура выводится на экран -&gt; смешивается цвет фона dst1 с цветом рендер таргет текстуры (пустой цвет текстуры + красный круг + зелёный круг)</span><br></pre></td></tr></table></figure></p>
<p>Видно, что в итоговом цвете на экрана присутствует влияние цвета render-target текстуры — прозрачного по альфа каналу, но в итоговой формуле кроме альфа канала влияение оказывают также и RGB каналы цвета (чёрного или любого другого — неважно, но избавиться от влияния этого фонового цвета без изменения формулы смешивания невозможно, “невидимый” цвет начинает быть видимым).</p>
<h2 id="Настройка-режимов-смешивания"><a href="#Настройка-режимов-смешивания" class="headerlink" title="Настройка режимов смешивания"></a>Настройка режимов смешивания</h2><p><code>OpenGL</code> (и <code>SFML</code> над ней) дают возможность переключать формулы режимов смешивания. Важно отойти от представления “определенная формула магическим образом включает полупрозрачность” к тому, что графический API просто даёт возможность изменить уравнение смешивание, а вывод конкретных формул ложится на плечи программиста.</p>
<p>Стандартное уравнение смешивания для полупрозрачности смешивает цвета в пропорции:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); </span><br><span class="line">GL_SRC_ALPHA - коэффициент смешивания рисуемого цвета - чем прозрачнее рисуемая фигура, тем меньше видно её цвет</span><br><span class="line">GL_ONE_MINUS_SRC_ALPHA - коэффициент смешивания фонового цвета - обратный, чем прозрачнее рисуемая фигура, тем больше видно цвет за ней</span><br><span class="line"></span><br><span class="line">r1 - цвет фона</span><br><span class="line">r2 - цвет 1-го круга</span><br><span class="line">r3 - цвет 2-го круга</span><br><span class="line">после отрисовки фона m1 &#x3D; (a1 * r1)</span><br><span class="line">смешанный цвет после отрисовки первого круга m2 &#x3D; (a2 * r2 + (1.0 - a2) * a1 * r1)</span><br><span class="line">смешанный цвет после отрисовки второго круга m3 &#x3D; (a3 * r3 + (1.0 - a3) * (a2 * r2 + (1.0 - a2) * a1 * r1)) &#x3D; </span><br><span class="line"> &#x3D; (a3 * r3 + (1.0 - a3) * a2 * r2 + (1.0 - a3) * (1.0 - a2) * a1 * r1)</span><br></pre></td></tr></table></figure></p>
<p>При рендере в текстуру по умолчанию используется другая формула, которая разделяет рассчёты для RGB-каналов цвета и для A-канала.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ONE_MINUS_SRC_ALPHA);</span><br><span class="line">для RGB-каналов - аналогично предыдущей формуле</span><br><span class="line">для A-канала:</span><br><span class="line">  Asrc + Adst * (1-Asrc) - альфа значение рисуемого цвета берётся &quot;как есть&quot; и складывается с уменьшенным фоновым значением </span><br><span class="line"></span><br><span class="line">Цвет и альфа для рендер-таргет текстуры - glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ONE_MINUS_SRC_ALPHA);</span><br><span class="line">цвет в рендер-таргет текстуре rt1 &#x3D; r1 * a1 (берём черный прозрачный цвет r1&#x3D;(0,0,0), a1&#x3D;0 - четвёртый компонент важен)</span><br><span class="line">цвет после добавления круга rt2 &#x3D; (a2 * r2 + (1.0 - a2) * a1 * r1) &#x3D; a2 * r2     &#x2F;&#x2F;premultiply alpha</span><br><span class="line">альфа после добавления круга rta2 &#x3D; a2 + a1 * (1-a2) &#x3D; a2</span><br><span class="line">цвет после добавления второго круга rt3 &#x3D; (a3 * r3 + (1.0 - a3) * a2 * r2)</span><br><span class="line">альфа после добавления второго круга rta3 &#x3D; a3 + a2 * (1 - a3)</span><br></pre></td></tr></table></figure>
<p>Эта формула годится только для рендера полностью непрозрачных объектов. Если какие-то части объекта прозрачные, необходимо использовать другую пару формул (для рендера в текстуру + для рендера полученной текстуры на экране). Для рендера в текстуру при этом можно даже получать “неправильные” цвета, которые можно потом смешать с изображением на экране так, чтобы смешанный итоговый цвет стал корректным.</p>
<p>Хороший разбор проблемы на <a href="https://stackoverflow.com/questions/24346585/opengl-render-to-texture-with-partial-transparancy-translucency-and-then-rende" target="_blank" rel="noopener">stackoverflow</a><br>Формулы смешивания также разжеваны в статье <a href="https://habr.com/ru/post/468067/" target="_blank" rel="noopener">Как работает альфа-композитинг</a></p>
<h2 id="Source-Over"><a href="#Source-Over" class="headerlink" title="Source-Over"></a>Source-Over</h2><p>Одно из возможных решений — смешать цвет полученной render target текстуры в режиме <code>Source-Over</code> (термин из статьи выше, из списка операторов смешивания Портера-Даффа):<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA)</span><br><span class="line">итоговый цвет m3 &#x3D; rt3 + m1 * (1.0 - rta3)</span><br><span class="line"></span><br><span class="line">подставим сюда значения значения из предудыщей формулы для рендерт-таргет цвета и текстуры:</span><br><span class="line">m3 &#x3D; (a3 * r3 + (1.0 - a3) * a2 * r2) + (a1 * r1) * (1.0 - a3 - a2 * (1 - a3))</span><br><span class="line"></span><br><span class="line">Теперь можно сравнить полученные значения итогового цвета m3 из формулы прямого рендера и этой формулы:</span><br><span class="line">m3_direct &#x3D;&#x3D; m3_sourceover</span><br><span class="line">(a3 * r3 + (1.0 - a3) * a2 * r2 + (1.0 - a3) * (1.0 - a2) * a1 * r1) &#x3D;&#x3D; (a3 * r3 + (1.0 - a3) * a2 * r2) + (a1 * r1) * (1.0 - a3 - a2 * (1 - a3))</span><br><span class="line">(1.0 - a3) * (1.0 - a2) &#x3D;&#x3D; (1.0 - a3 - a2 * (1 - a3)</span><br><span class="line">1.0 - a3 - a2 + a2*a3 &#x3D;&#x3D; 1.0 - a3 - a2 + a2*a3</span><br><span class="line"></span><br><span class="line">Тада! убедились в равенстве</span><br></pre></td></tr></table></figure></p>
<p>Код смешивания в режиме <code>Source-Over</code>, правильный результат:<br><div style="color: #d4d4d4;background-color: #1e1e1e;font-family: Consolas, 'Courier New', monospace;font-weight: normal;font-size: 14px;line-height: 19px;white-space: pre;"><div><span style="color: #c586c0;">def</span><span style="color: #d4d4d4;"> draw</span></div><div><span style="color: #d4d4d4;">&#160; &#160; withRenderTarget &lt;| </span><span style="color: #569cd6;">$</span><span style="color: #d4d4d4;">(</span><span style="color: #569cd6;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">rt</span><span style="color: #d4d4d4;">: RenderTarget&amp;)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; rt |&gt; </span><span style="color: #dcdcaa;">clear</span><span style="color: #d4d4d4;">(Color(</span><span style="color: #b5cea8;">25</span><span style="color: #d4d4d4;">5u,</span><span style="color: #b5cea8;">25</span><span style="color: #d4d4d4;">5u,</span><span style="color: #b5cea8;">25</span><span style="color: #d4d4d4;">5u,</span><span style="color: #b5cea8;">25</span><span style="color: #d4d4d4;">5u))</span></div><br><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #6a9955;">//simple draw</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; text_out(</span><span style="color: #b5cea8;">0</span><span style="color: #d4d4d4;">, </span><span style="color: #b5cea8;">0</span><span style="color: #d4d4d4;">, </span><span style="color: #ce9178;">"Simple"</span><span style="color: #d4d4d4;">, </span><span style="color: #b5cea8;">0xFF000000</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; drawCircles(rt)</span></div><br><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #6a9955;">//render texture draw</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; text_out(</span><span style="color: #b5cea8;">0</span><span style="color: #d4d4d4;">, </span><span style="color: #b5cea8;">300</span><span style="color: #d4d4d4;">, </span><span style="color: #ce9178;">"Texture: Satsub"</span><span style="color: #d4d4d4;">, </span><span style="color: #b5cea8;">0xFF000000</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; using() &lt;| </span><span style="color: #569cd6;">$</span><span style="color: #d4d4d4;">(</span><span style="color: #569cd6;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">rtTex</span><span style="color: #d4d4d4;">: RenderTexture#)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; rtTex |&gt; create(</span><span style="color: #b5cea8;">25</span><span style="color: #d4d4d4;">0u + </span><span style="color: #b5cea8;">12</span><span style="color: #d4d4d4;">5u, </span><span style="color: #b5cea8;">25</span><span style="color: #d4d4d4;">0u, </span><span style="color: #c586c0;">false</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; rtTex |&gt; </span><span style="color: #dcdcaa;">clear</span><span style="color: #d4d4d4;">(Color(</span><span style="color: #b5cea8;">0</span><span style="color: #d4d4d4;">u, </span><span style="color: #b5cea8;">0</span><span style="color: #d4d4d4;">u, </span><span style="color: #b5cea8;">0</span><span style="color: #d4d4d4;">u, </span><span style="color: #b5cea8;">0</span><span style="color: #d4d4d4;">u))</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; drawCircles(rtTex)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; using(rtTex |&gt; getTexture()) &lt;| </span><span style="color: #569cd6;">$</span><span style="color: #d4d4d4;">(</span><span style="color: #569cd6;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">sprite</span><span style="color: #d4d4d4;">: Sprite#)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; interface(sprite) &lt;| </span><span style="color: #569cd6;">$</span><span style="color: #d4d4d4;">(</span><span style="color: #569cd6;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">tr</span><span style="color: #d4d4d4;">: Transformable)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; tr |&gt; move(</span><span style="color: #b5cea8;">0.0f</span><span style="color: #d4d4d4;">, </span><span style="color: #b5cea8;">300.0f</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; using(Factor One, Factor OneMinusSrcAlpha, Equation Add) &lt;| </span><span style="color: #569cd6;">$</span><span style="color: #d4d4d4;">(</span><span style="color: #569cd6;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">blendMode</span><span style="color: #d4d4d4;">: BlendMode#)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; using(blendMode) &lt;| </span><span style="color: #569cd6;">$</span><span style="color: #d4d4d4;">(</span><span style="color: #569cd6;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">renderState</span><span style="color: #d4d4d4;">: RenderStates#)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; rt |&gt; draw(sprite, renderState)</span></div></div><br><img src="/blog/4060902549/screen3_small.png" alt=""></p>
<h2 id="Premultiply-alpha"><a href="#Premultiply-alpha" class="headerlink" title="Premultiply alpha"></a>Premultiply alpha</h2><p>Если посмотреть на коэффициенты смешивания в “неправильном” блендинге, и в <code>Sourse-Over</code>, можно прийти к более правильному интуитивному пониманию лишнего влияния цвета в неправильной версии. В неё не “вмешан” лишний чёрный цвет, а добавлено лишнее умножение цвета на альфа канал, которое “гасит” этот цвет больше, чем необходимо при корректном смешивании.</p>
<p>Можно пойти другим путём — убрать умножение цвета на альфу при смешивании совсем, но производить его 1 раз в шейдере — тогда не нужно переключать режим прозрачности, но нужно переключать шейдер, с которым отрисован объект. Преимуществом такого способами может быть то, что исходное изображение часто можно домножить на альфа-канал еще до запуска приложения (в демо-примере изображение генерится динамически, поэтому умножение сделано в шейдере).</p>
<div style="color: #d4d4d4;background-color: #1e1e1e;font-family: Consolas, 'Courier New', monospace;font-weight: normal;font-size: 14px;line-height: 19px;white-space: pre;"><div><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> fragmentShaderTex = (</span></div><div><span style="color: #ce9178;">"uniform sampler2D texture;</span></div><div><span style="color: #ce9178;">void main()</span></div><div><span style="color: #d7ba7d;">\{</span></div><div><span style="color: #ce9178;">&#160; &#160; gl_FragColor = texture2D(texture, gl_TexCoord[0].st);</span></div><div><span style="color: #d7ba7d;">\}</span><span style="color: #ce9178;">"</span><span style="color: #d4d4d4;">)</span></div><br><div><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> fragmentShaderPremultiply = (</span></div><div><span style="color: #ce9178;">"void main()</span></div><div><span style="color: #d7ba7d;">\{</span></div><div><span style="color: #ce9178;">&#160; &#160; //gl_FragColor = gl_Color; &#160;//for testing no premultiply</span></div><div><span style="color: #ce9178;">&#160; &#160; gl_FragColor = vec4(gl_Color.rgb * gl_Color.a, gl_Color.a);</span></div><div><span style="color: #d7ba7d;">\}</span><span style="color: #ce9178;">"</span><span style="color: #d4d4d4;">)</span></div><br><div><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> rsPremultiplySatSub, rsSatSub : RenderStates?</span></div><br><div><span style="color: #d4d4d4;">[</span><span style="color: #569cd6;">export</span><span style="color: #d4d4d4;">]</span></div><div><span style="color: #c586c0;">def</span><span style="color: #d4d4d4;"> initialize</span></div><div><span style="color: #d4d4d4;">&#160; &#160; set_window_title(</span><span style="color: #ce9178;">"sfml"</span><span style="color: #d4d4d4;">) </span></div><br><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> shaderPremult = </span><span style="color: #c586c0;">new</span><span style="color: #d4d4d4;"> Shader()</span></div><div><span style="color: #d4d4d4;">&#160; &#160; shaderPremult |&gt; load_fragment_shader_from_string(fragmentShaderPremultiply)</span></div><br><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> shaderTex = </span><span style="color: #c586c0;">new</span><span style="color: #d4d4d4;"> Shader()</span></div><div><span style="color: #d4d4d4;">&#160; &#160; shaderTex |&gt; load_fragment_shader_from_string(fragmentShaderTex) &#160; &#160;</span></div><div><span style="color: #d4d4d4;">&#160; &#160; shaderTex |&gt; bind_current_texture_to_uniform(</span><span style="color: #ce9178;">"texture"</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> blendModeSatSubSeparate = </span><span style="color: #c586c0;">new</span><span style="color: #d4d4d4;"> BlendMode(Factor One, Factor OneMinusSrcAlpha, Equation Add, Factor OneMinusDstAlpha, Factor One, Equation Add)</span></div><br><div><span style="color: #d4d4d4;">&#160; &#160; rsPremultiplySatSub = makeRenderTarget(shaderPremult, blendModeSatSubSeparate)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; rsSatSub = makeRenderTarget(shaderTex, blendModeSatSubSeparate)</span></div><br><div><span style="color: #569cd6;">def</span><span style="color: #d4d4d4;"> </span><span style="color: #dcdcaa;">drawCircles</span><span style="color: #d4d4d4;">(</span><span style="color: #569cd6;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">rt</span><span style="color: #d4d4d4;">: RenderTarget&amp;; </span><span style="color: #9cdcfe;">rs</span><span style="color: #d4d4d4;">: RenderStates&amp; </span><span style="color: #c586c0;">implicit</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; using(</span><span style="color: #b5cea8;">125.0f</span><span style="color: #d4d4d4;">, </span><span style="color: #b5cea8;">12</span><span style="color: #d4d4d4;">8ul) &lt;| </span><span style="color: #569cd6;">$</span><span style="color: #d4d4d4;">(</span><span style="color: #569cd6;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">shape</span><span style="color: #d4d4d4;">: CircleShape#)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; shape |&gt; setFillColor(Color(</span><span style="color: #b5cea8;">0</span><span style="color: #d4d4d4;">u,</span><span style="color: #b5cea8;">25</span><span style="color: #d4d4d4;">5u,</span><span style="color: #b5cea8;">0</span><span style="color: #d4d4d4;">u,</span><span style="color: #b5cea8;">12</span><span style="color: #d4d4d4;">8u))</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; rt |&gt; draw(shape, rs)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; using(</span><span style="color: #b5cea8;">125.0f</span><span style="color: #d4d4d4;">, </span><span style="color: #b5cea8;">12</span><span style="color: #d4d4d4;">8ul) &lt;| </span><span style="color: #569cd6;">$</span><span style="color: #d4d4d4;">(</span><span style="color: #569cd6;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">shape</span><span style="color: #d4d4d4;">: CircleShape#)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; interface(shape) &lt;| </span><span style="color: #569cd6;">$</span><span style="color: #d4d4d4;">(</span><span style="color: #569cd6;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">tr</span><span style="color: #d4d4d4;">: Transformable) { tr |&gt; move(</span><span style="color: #b5cea8;">125.0f</span><span style="color: #d4d4d4;">, </span><span style="color: #b5cea8;">0.0f</span><span style="color: #d4d4d4;">); }</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; shape |&gt; setFillColor(Color(</span><span style="color: #b5cea8;">25</span><span style="color: #d4d4d4;">5u,</span><span style="color: #b5cea8;">05u</span><span style="color: #d4d4d4;">,</span><span style="color: #b5cea8;">0</span><span style="color: #d4d4d4;">u,</span><span style="color: #b5cea8;">12</span><span style="color: #d4d4d4;">8u))</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; rt |&gt; draw(shape, rs)</span></div><br><div><span style="color: #569cd6;">def</span><span style="color: #d4d4d4;"> </span><span style="color: #dcdcaa;">render_with_blend_and_premultiply</span><span style="color: #d4d4d4;">(</span><span style="color: #569cd6;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">rt</span><span style="color: #d4d4d4;">: RenderTarget&amp;)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; drawCircles(rt, *rsPremultiplySatSub)</span></div><br><div><span style="color: #569cd6;">def</span><span style="color: #d4d4d4;"> </span><span style="color: #dcdcaa;">render_sprite_with_blend</span><span style="color: #d4d4d4;">(</span><span style="color: #569cd6;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">rt</span><span style="color: #d4d4d4;">: RenderTarget&amp;; </span><span style="color: #569cd6;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">sprite</span><span style="color: #d4d4d4;">: Sprite&amp; </span><span style="color: #c586c0;">implicit</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; rt |&gt; draw(sprite, *rsSatSub)</span></div><br><div><span style="color: #d4d4d4;">[</span><span style="color: #569cd6;">export</span><span style="color: #d4d4d4;">]</span></div><div><span style="color: #c586c0;">def</span><span style="color: #d4d4d4;"> draw</span></div><div><span style="color: #d4d4d4;">&#160; &#160; withRenderTarget &lt;| </span><span style="color: #569cd6;">$</span><span style="color: #d4d4d4;">(</span><span style="color: #569cd6;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">rt</span><span style="color: #d4d4d4;">: RenderTarget&amp;)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; rt |&gt; </span><span style="color: #dcdcaa;">clear</span><span style="color: #d4d4d4;">(Color(</span><span style="color: #b5cea8;">25</span><span style="color: #d4d4d4;">5u,</span><span style="color: #b5cea8;">25</span><span style="color: #d4d4d4;">5u,</span><span style="color: #b5cea8;">25</span><span style="color: #d4d4d4;">5u,</span><span style="color: #b5cea8;">25</span><span style="color: #d4d4d4;">5u))</span></div><br><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #6a9955;">//simple draw</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; text_out(</span><span style="color: #b5cea8;">0</span><span style="color: #d4d4d4;">, </span><span style="color: #b5cea8;">0</span><span style="color: #d4d4d4;">, </span><span style="color: #ce9178;">"Simple"</span><span style="color: #d4d4d4;">, </span><span style="color: #b5cea8;">0xFF000000</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; drawCircles(rt, RenderStates_Default())</span></div><br><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #6a9955;">//render texture draw</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; text_out(</span><span style="color: #b5cea8;">0</span><span style="color: #d4d4d4;">, </span><span style="color: #b5cea8;">300</span><span style="color: #d4d4d4;">, </span><span style="color: #ce9178;">"Texture: Premult"</span><span style="color: #d4d4d4;">, </span><span style="color: #b5cea8;">0xFF000000</span><span style="color: #d4d4d4;">)</span></div><br><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; using() &lt;| </span><span style="color: #569cd6;">$</span><span style="color: #d4d4d4;">(</span><span style="color: #569cd6;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">rtTex</span><span style="color: #d4d4d4;">: RenderTexture#)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; rtTex |&gt; create(</span><span style="color: #b5cea8;">25</span><span style="color: #d4d4d4;">0u + </span><span style="color: #b5cea8;">12</span><span style="color: #d4d4d4;">5u, </span><span style="color: #b5cea8;">25</span><span style="color: #d4d4d4;">0u, </span><span style="color: #c586c0;">false</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; rtTex |&gt; </span><span style="color: #dcdcaa;">clear</span><span style="color: #d4d4d4;">(Color(</span><span style="color: #b5cea8;">0</span><span style="color: #d4d4d4;">u, </span><span style="color: #b5cea8;">0</span><span style="color: #d4d4d4;">u, </span><span style="color: #b5cea8;">0</span><span style="color: #d4d4d4;">u, </span><span style="color: #b5cea8;">0</span><span style="color: #d4d4d4;">u))</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; render_with_blend_and_premultiply(rtTex)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; using(rtTex |&gt; getTexture()) &lt;| </span><span style="color: #569cd6;">$</span><span style="color: #d4d4d4;">(</span><span style="color: #569cd6;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">sprite</span><span style="color: #d4d4d4;">: Sprite#)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; interface(sprite) &lt;| </span><span style="color: #569cd6;">$</span><span style="color: #d4d4d4;">(</span><span style="color: #569cd6;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">tr</span><span style="color: #d4d4d4;">: Transformable)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; tr |&gt; move(</span><span style="color: #b5cea8;">0.0f</span><span style="color: #d4d4d4;">, </span><span style="color: #b5cea8;">300.0f</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; render_sprite_with_blend(rt, sprite)</span></div></div>
<p><img src="/blog/4060902549/screen4_small.png" alt=""></p>
<p>Универсальный режим смешивания для premultiply изображений:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">glBlendFuncSeparate(GL_ONE, GL_ONE_MINUS_SRC_ALPHA, GL_ONE_MINUS_DST_ALPHA, GL_ONE);</span><br><span class="line"></span><br><span class="line">Порядок рендера:</span><br><span class="line">1. Вывод в изображения в рендер-таргет текстуру с premultiply-шейдером (или же вывод подготовленного заранее изображения с обычным шейдером)</span><br><span class="line">2. Вывод рендер-таргет текстуры на экран с обычным шейдером (чтобы избежать лишнего умножения)</span><br><span class="line"></span><br><span class="line">математика (скопипащена с stackoverflow ответа):</span><br><span class="line">after layer 2: (a2 * r2, a2)</span><br><span class="line">after layer 3: (a3 * r3 + (1.0 - a3) * a2 * r2, (1.0 - a2) * a3 + a2)</span><br><span class="line"></span><br><span class="line">srcR &#x3D; a3 * r3 + (1.0 - a3) * a2 * r2</span><br><span class="line">srcA &#x3D; (1.0 - a2) * a3 + a2</span><br><span class="line">dstR &#x3D; a1 * r1</span><br><span class="line">ONE * srcR + ONE_MINUS_SRC_ALPHA * dstR</span><br><span class="line">    &#x3D; srcR + (1.0 - srcA) * dstR</span><br><span class="line">    &#x3D; a3 * r3 + (1.0 - a3) * a2 * r2 + (1.0 - ((1.0 - a2) * a3 + a2)) * a1 * r1</span><br><span class="line">    &#x3D; a3 * r3 + (1.0 - a3) * a2 * r2 + (1.0 - a3 + a2 * a3 - a2) * a1 * r1</span><br><span class="line">    &#x3D; a3 * r3 + (1.0 - a3) * a2 * r2 + (1.0 - a3) * (1.0 - a2) * a1 * r1</span><br></pre></td></tr></table></figure></p>
<p>Заметки по daScript:</p>
<ul>
<li>Вывод объекта с изменённым режимом блендинга и шейдером в <code>SFML</code> инкапуслирован в объекте <code>RenderStates</code></li>
<li>Вместо создания временных типов в этом примере используются “обычные” для <code>daScript</code> указатели:</li>
</ul>
<div style="color: #d4d4d4;background-color: #1e1e1e;font-family: Consolas, 'Courier New', monospace;font-weight: normal;font-size: 14px;line-height: 19px;white-space: pre;"><div><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> shaderPremult : Shader? = </span><span style="color: #c586c0;">new</span><span style="color: #d4d4d4;"> Shader()</span></div></div>
<p>Такие <a href="https://dascript.org/doc/reference/language/datatypes.html#pointers" target="_blank" rel="noopener">указатели</a> хранят объект в куче и владеют им, по семантике близко к <code>std::unique_ptr</code>. При желании можно освободить объект вручную, присвоив указателю <code>nullptr</code>.</p>
<ul>
<li>ключевое слово implicit после имени типа в аргументах функции позволяет функции работать с обычными типами, так и с временными.</li>
</ul>
<p>Код примеров - <a href="https://github.com/spiiin/dasbox_sfml/tree/main/samples/sfml_blending" target="_blank" rel="noopener">https://github.com/spiiin/dasbox_sfml/tree/main/samples/sfml_blending</a></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script></div></article><div class="pagination"><a class="pagination__link pagination__prev" href="/blog/887709799/">Позже</a><a class="pagination__link pagination__next" href="/blog/2385889062/">Раньше</a></div></main><footer class="footer metadata"><p class="footer__text">© 2023 spiiin</p><p class="footer__text">Powered by <a class="footer__text__link" href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a class="footer__text__link" href="https://pages.github.com/" target="_blank">Github Page</a></p></footer></div></body></html>