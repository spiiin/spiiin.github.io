<!DOCTYPE html><html lang="ru"><head><meta charset="UTF-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Spiiin's blog | daScript. SFML, dasBox и semi-transparent render target</title><meta name="description" content=""><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=PT+Serif&amp;display=swap"><link rel="stylesheet" href="/css/highlights/darkula.css"><link rel="stylesheet" href="/css/main.css"><link rel="search" type="application/opensearchdescription+xml" href="http://spiiin.github.io/atom.xml" title="Spiiin's blog"><script>(function (i, s, o, g, r, a, m) {
  i['GoogleAnalyticsObject'] = r;
  i[r] = i[r] || function () {
    (i[r].q = i[r].q || []).push(arguments)
  }, i[r].l = 1 * new Date();
  a = s.createElement(o),
    m = s.getElementsByTagName(o)[0];
  a.async = 1;
  a.src = g;
  m.parentNode.insertBefore(a, m)
})(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');
ga('create', 'UA-00000000-0', 'auto');
ga('send', 'pageview');</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Spiiin's blog" type="application/atom+xml">
</head><body><div class="container"><header class="main-header"><h1 class="main-header__title uplize"><a class="main-header__title__link" href="/"><img class="header-image" src="/images/favicon.png" width="36" height="36">Spiiin's blog</a></h1><nav class="main-header__nav"><ul class="main-nav"><li class="main-nav__list"><a class="main-nav__list__link" href="/" target="_self">HOME</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/archives/" target="_self">ARCHIVE</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/tags/meta" target="_self">TAGS</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/blog/1" target="_self">ABOUT</a></li></ul></nav></header><main class="container__wrapper"><div class="pagination"><a class="pagination__link pagination__next" href="/blog/2385889062/">Раньше</a></div><article class="article post"><h3 class="article__title">daScript. SFML, dasBox и semi-transparent render target</h3><div class="article__date metadata"><div class="post-info">2022/10/22</div></div><div class="article__tags metadata">Tags:
<a class="article__tags__link metadata" href="/tags/opengl/">opengl</a><a class="article__tags__link metadata" href="/tags/dascript/">dascript</a></div><div class="article__body"><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Пример работы с SFML в dasBox — рендер полупрозрачных объектов в рендер-таргет. Тривиальная задача для графического программиста, но почему-то многие разработчики игр не знают, как это корректно сделать.</p>
<h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>Изначальная задумка поста — собрать небольшой пример, показывающий алгоритм рендеринга полупрозрачных объектов в текстуру, с последующим корректным отображением этой текстуры, как если бы объекты рендерились на экран напрямую, без использования этой текстуры. Но попутно оказалось, что можно запилить фреймворк для таких демок, с возможноостью в live-режиме поиграться с параметрами и посмотреть результат.</p>
<h2 id="dasSFML"><a href="#dasSFML" class="headerlink" title="dasSFML"></a>dasSFML</h2><p>Примеры на <code>Opengl+GLFW</code>:<br><a href="/blog/4232971949/" title="daScript OpenGL">daScript OpenGL</a><br><a href="/blog/3006126295/" title="daScript - live-режим">daScript - live-режим</a></p>
<p>В отличие от GLFW, <code>SFML</code> представляет простые объекты-обёртки над функциями OpenGL для работы с текстурами, шейдерами, рендер-таргетами, и прочими примитивами библиотеки рендера, в то же время представляя для кастомизации практически все параметры рендера (во всяком случае необходимые для задуманного примера), для того, чтобы можно было писать небольшие примеры алгоритмов рендера на OpenGL.</p>
<p>Для начала, можно “завести” простейший <a href="https://github.com/borisbat/dasSFML/blob/main/examples/graphics.das" target="_blank" rel="noopener">пример</a> из комплекта привязки <code>SFML</code> к <code>daScript</code>.</p>
<p>Для его сборки выкачиваем сабмодули <code>daScript</code>:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git submodule update --init --recursive</span><br></pre></td></tr></table></figure></p>
<p>Затем включаем сборку этого модуля в CmakeLists.txt и добавляем линковку статической библиотеки с модулем libDasSFML и самих библиотек SFML:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">option(DAS_SFML_DISABLED &quot;Disable dasSFML (SFML multimedia library)&quot; OFF)</span><br><span class="line">...</span><br><span class="line">target_link_libraries(sfmlApp</span><br><span class="line">  libDasModuleSFML</span><br><span class="line">  sfml-graphics</span><br><span class="line">  sfml-network</span><br><span class="line">  sfml-system</span><br><span class="line">  sfml-window</span><br><span class="line">  #для windows также:</span><br><span class="line">  legacy_stdio_definitions</span><br><span class="line">  winmm</span><br><span class="line">  Opengl32</span><br><span class="line">  sfml-main</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>и перегененируем проект<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;generate_msvc_2019.bat</span><br></pre></td></tr></table></figure></p>
<p>Затем в хост-приложении на C++:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//подключение заголовка с определением модуля</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dasSFML/src/dasSFML.h&gt;</span></span></span><br><span class="line">...</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span>, <span class="keyword">char</span> * [] )</span> </span>&#123;</span><br><span class="line">    NEED_ALL_DEFAULT_MODULES;</span><br><span class="line">    NEED_MODULE(Module_dasSFML); <span class="comment">//&lt;---создаём модуль sfml</span></span><br><span class="line">    Module::Initialize();</span><br><span class="line">    run_script();</span><br><span class="line">    Module::Shutdown();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>run_script</code> вызывает метод <code>main</code> из примера, который создаёт SFML-окно и запускает цикл обработки сообщений в нём.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main</span><br><span class="line">    <span class="keyword">using</span>(VideoMode(<span class="number">640u</span>,<span class="number">480u</span>), <span class="string">"SFML window"</span>, uint(WindowStyle Default), ContextSettings()) &lt;| $ ( var window : RenderWindow# )</span><br><span class="line">        <span class="keyword">while</span> window |&gt; isOpen()</span><br><span class="line">            var event : Event</span><br><span class="line">            <span class="keyword">while</span> window |&gt; pollEvent(event)</span><br><span class="line">                <span class="keyword">if</span> event._type == EventType Closed</span><br><span class="line">                    window |&gt; close()</span><br><span class="line">            interface(window) &lt;| $ ( var rt : RenderTarget )</span><br><span class="line">                rt |&gt; clear( Color(<span class="number">64u</span>,<span class="number">0u</span>,<span class="number">0u</span>,<span class="number">255u</span>) )</span><br><span class="line">                <span class="keyword">using</span>(<span class="number">50.0f</span>,<span class="number">0x1e</span>ul) &lt;| $ ( var shape : CircleShape# )</span><br><span class="line">                    interface(shape) &lt;| $ ( var tr : Transformable )</span><br><span class="line">                        tr |&gt; move(<span class="number">20.</span>,<span class="number">30.</span>)</span><br><span class="line">                    shape |&gt; setFillColor(Color(<span class="number">150u</span>,<span class="number">50u</span>,<span class="number">250u</span>,<span class="number">255u</span>))</span><br><span class="line">                    shape |&gt; setOutlineThickness(<span class="number">10.f</span>)</span><br><span class="line">                    shape |&gt; setOutlineColor(Color(<span class="number">250u</span>,<span class="number">150u</span>,<span class="number">100u</span>,<span class="number">255u</span>))</span><br><span class="line">                    rt |&gt; draw(shape, RenderStates_Default())</span><br><span class="line">            window |&gt; display()</span><br></pre></td></tr></table></figure>
<p>В качестве фреймворка для создания окна используется имеющийся в SFML класс <code>Window</code>. Однако проще воспользоваться другим фреймворком, в который уже внедрены возможности daScript-а по перезагрузке кода.</p>
<h2 id="dasbox"><a href="#dasbox" class="headerlink" title="dasbox"></a>dasbox</h2><p><a href="https://github.com/imp5imp5/dasbox" target="_blank" rel="noopener">dasbox</a> — примитивный движок для 2d-игр, который Gaijin-ы использовали для проведения конкурса <a href="https://gaijinjam.net/ru" target="_blank" rel="noopener">Gaijin Jam</a> (<a href="https://github.com/AlexLemminG/TheFarmers" target="_blank" rel="noopener">игра-победитель</a>). Движок имеет простую <a href="https://github.com/imp5imp5/dasbox/blob/main/doc/api.txt" target="_blank" rel="noopener">апишку</a>, на которой можно потренироваться использованию языка на уровне “как будто типизированная lua”, а также настроен для подключения отладчика языка, веб-инспектора для отображения состояния ecs-модуля и горячей перезагрузке кода.</p>
<p>Но для меня интереснее другое — <code>dasbox</code> использует в качестве бекэнда <code>SFML</code>. И хотя это осознанно скрыто от пользователей для того, чтобы можно было сменить бекэнд, можно немного “поломать инкапсуляцию”, для того, чтобы воспользоваться в нём модулем <code>dasSFML</code>, и получить доступ к более богатому API, получив от самого dasbox-а фичи и инструменты по работе с кодом.</p>
<p><a href="https://github.com/spiiin/dasbox_sfml" target="_blank" rel="noopener">dasbox_sfml</a> — порт дасбокса с включенным модулем dasSFML.</p>
<p>Базовый пример на нём выглядит так:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">require daslib/media</span><br><span class="line">require sfml</span><br><span class="line">require dasbox_sfml</span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def initialize</span><br><span class="line">    set_window_title(<span class="string">"sfml"</span>)</span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line"><span class="function">def <span class="title">act</span><span class="params">(dt: <span class="keyword">float</span>)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">if</span> <span class="title">get_key</span><span class="params">(VK_ESCAPE)</span></span></span><br><span class="line"><span class="function">        <span class="title">schedule_quit_game</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">[export]</span><br><span class="line">def draw</span><br><span class="line">    withRenderTarget &lt;| $(var rt: RenderTarget&amp;)</span><br><span class="line">        rt |&gt; clear(Color(<span class="number">0u</span>,<span class="number">255u</span>,<span class="number">0u</span>,<span class="number">255u</span>))</span><br><span class="line">        <span class="keyword">using</span>(<span class="number">50.0f</span>,<span class="number">0x1e</span>ul) &lt;| $(var shape: CircleShape#)</span><br><span class="line">            interface(shape) &lt;| $(var tr: Transformable)</span><br><span class="line">                tr |&gt; move(<span class="number">20.</span>,<span class="number">30.</span>)</span><br><span class="line">            shape |&gt; setFillColor(Color(<span class="number">150u</span>,<span class="number">50u</span>,<span class="number">250u</span>,<span class="number">255u</span>))</span><br><span class="line">            shape |&gt; setOutlineThickness(<span class="number">10.f</span>)</span><br><span class="line">            shape |&gt; setOutlineColor(Color(<span class="number">250u</span>,<span class="number">150u</span>,<span class="number">100u</span>,<span class="number">255u</span>))</span><br><span class="line">            rt |&gt; draw(shape, RenderStates_Default())</span><br></pre></td></tr></table></figure><br><img src="/blog/4060902549/screen1_small.png" alt=""></p>
<p><code>dasBox_sfml</code> подхватывает изменения в файле с кодом, а также отображает в своей консоли ошибки в этом файле.</p>
<p>Идиомы <code>daScript</code> в примере:</p>
<ul>
<li><code>using()</code> - создание переменной <a href="https://dascript.org/doc/reference/language/temporary.html" target="_blank" rel="noopener">временного типа</a>, который существует только в пределах блока using</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span>() &lt;| $(var fs: das_string#)</span><br><span class="line">    fs := <span class="string">"hello world"</span></span><br><span class="line">    <span class="comment">//тут можно использовать переменную, в том числе передавать в другие функции</span></span><br><span class="line">    some_func(fs)</span><br><span class="line">    <span class="comment">//но нельзя как-либо сохранить указатель на эту переменную</span></span><br><span class="line">    <span class="comment">//var s = fs //ошибка, нельзя копировать временный тип</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>interface</code> - приведение к базовому типу</li>
</ul>
<p>Генератор привязок на C++ позволяет передать отношение наследования двух C++ типов в daScript так:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">addExtern&lt; <span class="keyword">decltype</span>(&amp;with_interface&lt;sf::Sprite,sf::Transformable&gt;), with_interface&lt;sf::Sprite,sf::Transformable&gt; &gt;(*<span class="keyword">this</span>,lib,<span class="string">"interface"</span>,SideEffects::invoke,<span class="string">"with_interface&lt;sf::Sprite,sf::Transformable&gt;"</span>);</span><br></pre></td></tr></table></figure></p>
<p><code>daScript</code> заставляет думать о типах и их времени жизни немного больше, чем C++, но и позволяет выразить больше таких утверждений, которые сможет проверить компилятор, чтобы уберечься от ошибок.</p>
<h2 id="RenderTarget"><a href="#RenderTarget" class="headerlink" title="RenderTarget"></a>RenderTarget</h2><p>Следующий пример — рендер в текстуру и отображение её на экране. В SFML для этого можно использовать класс <a href="https://www.sfml-dev.org/documentation/2.5.1/classsf_1_1RenderTexture.php" target="_blank" rel="noopener">RenderTexture</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">def draw</span><br><span class="line">    withRenderTarget &lt;| $(var rt: RenderTarget&amp;)</span><br><span class="line">        clear(rt, Color(<span class="number">0u</span>,<span class="number">255u</span>,<span class="number">0u</span>,<span class="number">255u</span>))</span><br><span class="line">        <span class="keyword">using</span>() &lt;| $(var rtTex: RenderTexture#)</span><br><span class="line">            rtTex |&gt; create(<span class="number">300u</span>, <span class="number">300u</span>, <span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">using</span>(<span class="number">50.0f</span>,<span class="number">0x1e</span>ul) &lt;| $(var shape: CircleShape#)</span><br><span class="line">                interface(shape) &lt;| $(var tr: Transformable)</span><br><span class="line">                    tr |&gt; move(<span class="number">20.</span>,<span class="number">30.</span>)</span><br><span class="line">                shape |&gt; setFillColor(Color(<span class="number">150u</span>,<span class="number">50u</span>,<span class="number">250u</span>,<span class="number">255u</span>))</span><br><span class="line">                shape |&gt; setOutlineThickness(<span class="number">10.f</span>)</span><br><span class="line">                shape |&gt; setOutlineColor(Color(<span class="number">250u</span>,<span class="number">150u</span>,<span class="number">100u</span>,<span class="number">255u</span>))</span><br><span class="line">                rtTex |&gt; draw(shape, RenderStates_Default())</span><br><span class="line">            <span class="keyword">using</span>(rtTex |&gt; getTexture()) &lt;| $(var sprite: Sprite#)</span><br><span class="line">                rt |&gt; draw(sprite, RenderStates_Default())</span><br></pre></td></tr></table></figure>
<p>Пока всё хорошо, и круг отрендеренный в текстуру выглядит также, как если бы был выведен на экран напрямую</p>
<h2 id="Полупрозрачные-объекты-в-RenderTarget"><a href="#Полупрозрачные-объекты-в-RenderTarget" class="headerlink" title="Полупрозрачные объекты в RenderTarget"></a>Полупрозрачные объекты в RenderTarget</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//рендер двух полупрозрачных кругов</span></span><br><span class="line"><span class="function">def <span class="title">drawCircles</span><span class="params">(var rt: RenderTarget&amp;)</span></span></span><br><span class="line">    using(125.0f, 128ul) &lt;| $(var shape: CircleShape#)</span><br><span class="line">        shape |&gt; setFillColor(Color(<span class="number">0u</span>,<span class="number">255u</span>,<span class="number">0u</span>,<span class="number">128u</span>))</span><br><span class="line">        rt |&gt; draw(shape, RenderStates_Default())</span><br><span class="line">    <span class="keyword">using</span>(<span class="number">125.0f</span>, <span class="number">128u</span>l) &lt;| $(var shape: CircleShape#)</span><br><span class="line">        interface(shape) &lt;| $(var tr: Transformable) &#123; tr |&gt; move(<span class="number">125.0f</span>, <span class="number">0.0f</span>); &#125;</span><br><span class="line">        shape |&gt; setFillColor(Color(<span class="number">255u</span>,<span class="number">05u</span>,<span class="number">0u</span>,<span class="number">128u</span>))</span><br><span class="line">        rt |&gt; draw(shape, RenderStates_Default())</span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def draw</span><br><span class="line">    withRenderTarget &lt;| $(var rt: RenderTarget&amp;)</span><br><span class="line">        rt |&gt; clear(Color(<span class="number">255u</span>,<span class="number">255u</span>,<span class="number">255u</span>,<span class="number">255u</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment">//простой рендер</span></span><br><span class="line">        text_out(<span class="number">0</span>, <span class="number">0</span>, <span class="string">"Simple"</span>, <span class="number">0xFF000000</span>)</span><br><span class="line">        drawCircles(rt)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//рендер в текстуру</span></span><br><span class="line">        text_out(<span class="number">0</span>, <span class="number">300</span>, <span class="string">"Texture"</span>, <span class="number">0xFF000000</span>)</span><br><span class="line">        <span class="keyword">using</span>() &lt;| $(var rtTex: RenderTexture#)</span><br><span class="line">            rtTex |&gt; create(<span class="number">250u</span> + <span class="number">125u</span>, <span class="number">250u</span>, <span class="literal">false</span>)</span><br><span class="line">            rtTex |&gt; clear(Color(<span class="number">0u</span>, <span class="number">0u</span>, <span class="number">0u</span>, <span class="number">0u</span>))</span><br><span class="line">            drawCircles(rtTex)</span><br><span class="line">            <span class="keyword">using</span>(rtTex |&gt; getTexture()) &lt;| $(var sprite: Sprite#)</span><br><span class="line">                interface(sprite) &lt;| $(var tr: Transformable)</span><br><span class="line">                    tr |&gt; move(<span class="number">0.0f</span>, <span class="number">300.0f</span>)</span><br><span class="line">                rt |&gt; draw(sprite, RenderStates_Default())</span><br></pre></td></tr></table></figure>
<p><img src="/blog/4060902549/screen2_small.png" alt=""></p>
<p>Полупрозрачные круги, отрендеренные в текстуру, выглядят темнее, чем отрисованные на экране напрямую. С реальными текстурами (или отрендеренными в текстуру шрифтами), проблема обычно выглядит как темная рамка на краях объекта (там где края ради сглаживания плавно “уходят” в прозрачность).</p>
<p>Из-за чего это возникает?</p>
<p>Цвет пиксела отрисованного объекта смешивается в пикселем, уже находящимся в буфере цвете по настраиваемым формулам. При прямой отрисовке порядок рендера получается таким:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">рисуется пиксел красного круга -&gt; смешивается с цветом dst1 фона (белое изображение) &#x3D; получаем цвет dst2</span><br><span class="line">рисуется пиксел зеленого круга -&gt; смешивается с цветом dst2 (фон + красный круг)</span><br></pre></td></tr></table></figure></p>
<p>Тогда как в случае рендера в текстуру происходит:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">рисуется пиксел красного круга -&gt; смешивается с фоновым цветом рендер таргет текстуры dst_rt1 (&quot;пустой&quot; rgba цвет, rgb каналы по умолчанию чёрные) &#x3D; получаем dst_rt2</span><br><span class="line">рисуется пиксел зелёного круга -&gt; смешивается с цветом dst_rt2 (пустой цвет текстуры + красный круг)</span><br><span class="line">текстура выводится на экран -&gt; смешивается цвет фона dst1 с цветом рендер таргет текстуры (пустой цвет текстуры + красный круг + зелёный круг)</span><br></pre></td></tr></table></figure></p>
<p>Видно, что в итоговом цвете на экрана присутствует влияние цвета render-target текстуры — прозрачного по альфа каналу, но в итоговой формуле кроме альфа канала влияение оказывают также и RGB каналы цвета (чёрного или любого другого — неважно, но избавиться от влияния этого фонового цвета без изменения формулы смешивания невозможно, “невидимый” цвет начинает быть видимым).</p>
<h2 id="Настройка-режимов-смешивания"><a href="#Настройка-режимов-смешивания" class="headerlink" title="Настройка режимов смешивания"></a>Настройка режимов смешивания</h2><p><code>OpenGL</code> (и <code>SFML</code> над ней) дают возможность переключать формулы режимов смешивания. Важно отойти от представления “определенная формула магическим образом включает полупрозрачность” к тому, что графический API просто даёт возможность изменить уравнение смешивание, а вывод конкретных формул ложится на плечи программиста.</p>
<p>Стандартное уравнение смешивания для полупрозрачности смешивает цвета в пропорции:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); </span><br><span class="line">GL_SRC_ALPHA - коэффициент смешивания рисуемого цвета - чем прозрачнее рисуемая фигура, тем меньше видно её цвет</span><br><span class="line">GL_ONE_MINUS_SRC_ALPHA - коэффициент смешивания фонового цвета - обратный, чем прозрачнее рисуемая фигура, тем больше видно цвет за ней</span><br><span class="line"></span><br><span class="line">r1 - цвет фона</span><br><span class="line">r2 - цвет 1-го круга</span><br><span class="line">r3 - цвет 2-го круга</span><br><span class="line">после отрисовки фона m1 &#x3D; (a1 * r1)</span><br><span class="line">смешанный цвет после отрисовки первого круга m2 &#x3D; (a2 * r2 + (1.0 - a2) * a1 * r1)</span><br><span class="line">смешанный цвет после отрисовки второго круга m3 &#x3D; (a3 * r3 + (1.0 - a3) * (a2 * r2 + (1.0 - a2) * a1 * r1)) &#x3D; </span><br><span class="line"> &#x3D; (a3 * r3 + (1.0 - a3) * a2 * r2 + (1.0 - a3) * (1.0 - a2) * a1 * r1)</span><br></pre></td></tr></table></figure></p>
<p>При рендере в текстуру по умолчанию используется другая формула, которая разделяет рассчёты для RGB-каналов цвета и для A-канала.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ONE_MINUS_SRC_ALPHA);</span><br><span class="line">для RGB-каналов - аналогично предыдущей формуле</span><br><span class="line">для A-канала:</span><br><span class="line">  Asrc + Adst * (1-Asrc) - альфа значение рисуемого цвета берётся &quot;как есть&quot; и складывается с уменьшенным фоновым значением </span><br><span class="line"></span><br><span class="line">Цвет и альфа для рендер-таргет текстуры - glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ONE_MINUS_SRC_ALPHA);</span><br><span class="line">цвет в рендер-таргет текстуре rt1 &#x3D; r1 * a1 (берём черный прозрачный цвет r1&#x3D;(0,0,0), a1&#x3D;0 - четвёртый компонент важен)</span><br><span class="line">цвет после добавления круга rt2 &#x3D; (a2 * r2 + (1.0 - a2) * a1 * r1) &#x3D; a2 * r2     &#x2F;&#x2F;premultiply alpha</span><br><span class="line">альфа после добавления круга rta2 &#x3D; a2 + a1 * (1-a2) &#x3D; a2</span><br><span class="line">цвет после добавления второго круга rt3 &#x3D; (a3 * r3 + (1.0 - a3) * a2 * r2)</span><br><span class="line">альфа после добавления второго круга rta3 &#x3D; a3 + a2 * (1 - a3)</span><br></pre></td></tr></table></figure>
<p>Эта формула годится только для рендера полностью непрозрачных объектов. Если какие-то части объекта прозрачные, необходимо использовать другую пару формул (для рендера в текстуру + для рендера полученной текстуры на экране). Для рендера в текстуру при этом можно даже получать “неправильные” цвета, которые можно потом смешать с изображением на экране так, чтобы смешанный итоговый цвет стал корректным.</p>
<p>Хороший разбор проблемы на <a href="https://stackoverflow.com/questions/24346585/opengl-render-to-texture-with-partial-transparancy-translucency-and-then-rende" target="_blank" rel="noopener">stackoverflow</a><br>Формулы смешивания также разжеваны в статье <a href="https://habr.com/ru/post/468067/" target="_blank" rel="noopener">Как работает альфа-композитинг</a></p>
<h2 id="Source-Over"><a href="#Source-Over" class="headerlink" title="Source-Over"></a>Source-Over</h2><p>Одно из возможных решений — смешать цвет полученной render target текстуры в режиме <code>Source-Over</code> (термин из статьи выше, из списка операторов смешивания Портера-Даффа):<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA)</span><br><span class="line">итоговый цвет m3 &#x3D; rt3 + m1 * (1.0 - rta3)</span><br><span class="line"></span><br><span class="line">подставим сюда значения значения из предудыщей формулы для рендерт-таргет цвета и текстуры:</span><br><span class="line">m3 &#x3D; (a3 * r3 + (1.0 - a3) * a2 * r2) + (a1 * r1) * (1.0 - a3 - a2 * (1 - a3))</span><br><span class="line"></span><br><span class="line">Теперь можно сравнить полученные значения итогового цвета m3 из формулы прямого рендера и этой формулы:</span><br><span class="line">m3_direct &#x3D;&#x3D; m3_sourceover</span><br><span class="line">(a3 * r3 + (1.0 - a3) * a2 * r2 + (1.0 - a3) * (1.0 - a2) * a1 * r1) &#x3D;&#x3D; (a3 * r3 + (1.0 - a3) * a2 * r2) + (a1 * r1) * (1.0 - a3 - a2 * (1 - a3))</span><br><span class="line">(1.0 - a3) * (1.0 - a2) &#x3D;&#x3D; (1.0 - a3 - a2 * (1 - a3)</span><br><span class="line">1.0 - a3 - a2 + a2*a3 &#x3D;&#x3D; 1.0 - a3 - a2 + a2*a3</span><br><span class="line"></span><br><span class="line">Тада! убедились в равенстве</span><br></pre></td></tr></table></figure></p>
<p>Код смешивания в режиме <code>Source-Over</code>, правильный результат:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">def draw</span><br><span class="line">    withRenderTarget &lt;| $(var rt: RenderTarget&amp;)</span><br><span class="line">        rt |&gt; clear(Color(<span class="number">255u</span>,<span class="number">255u</span>,<span class="number">255u</span>,<span class="number">255u</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment">//simple draw</span></span><br><span class="line">        text_out(<span class="number">0</span>, <span class="number">0</span>, <span class="string">"Simple"</span>, <span class="number">0xFF000000</span>)</span><br><span class="line">        drawCircles(rt)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//render texture draw</span></span><br><span class="line">        text_out(<span class="number">0</span>, <span class="number">300</span>, <span class="string">"Texture: Satsub"</span>, <span class="number">0xFF000000</span>)</span><br><span class="line">        <span class="keyword">using</span>() &lt;| $(var rtTex: RenderTexture#)</span><br><span class="line">            rtTex |&gt; create(<span class="number">250u</span> + <span class="number">125u</span>, <span class="number">250u</span>, <span class="literal">false</span>)</span><br><span class="line">            rtTex |&gt; clear(Color(<span class="number">0u</span>, <span class="number">0u</span>, <span class="number">0u</span>, <span class="number">0u</span>))</span><br><span class="line">            drawCircles(rtTex)</span><br><span class="line">            <span class="keyword">using</span>(rtTex |&gt; getTexture()) &lt;| $(var sprite: Sprite#)</span><br><span class="line">                interface(sprite) &lt;| $(var tr: Transformable)</span><br><span class="line">                    tr |&gt; move(<span class="number">0.0f</span>, <span class="number">300.0f</span>)</span><br><span class="line">                <span class="keyword">using</span>(Factor One, Factor OneMinusSrcAlpha, Equation Add) &lt;| $(var blendMode: BlendMode#)</span><br><span class="line">                    <span class="keyword">using</span>(blendMode) &lt;| $(var renderState: RenderStates#)</span><br><span class="line">                        rt |&gt; draw(sprite, renderState)</span><br></pre></td></tr></table></figure><br><img src="/blog/4060902549/screen3_small.png" alt=""></p>
<h2 id="Premultiply-alpha"><a href="#Premultiply-alpha" class="headerlink" title="Premultiply alpha"></a>Premultiply alpha</h2><p>Если посмотреть на коэффициенты смешивания в “неправильном” блендинге, и в <code>Sourse-Over</code>, можно прийти к более правильному интуитивному пониманию лишнего влияния цвета в неправильной версии. В неё не “вмешан” лишний чёрный цвет, а добавлено лишнее умножение цвета на альфа канал, которое “гасит” этот цвет больше, чем необходимо при корректном смешивании.</p>
<p>Можно пойти другим путём — убрать умножение цвета на альфу при смешивании совсем, но производить его 1 раз в шейдере — тогда не нужно переключать режим прозрачности, но нужно переключать шейдер, с которым отрисован объект. Преимуществом такого способами может быть то, что исходное изображение часто можно домножить на альфа-канал еще до запуска приложения (в демо-примере изображение генерится динамически, поэтому умножение сделано в шейдере).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var fragmentShaderTex = (</span><br><span class="line"><span class="string">"uniform sampler2D texture;</span></span><br><span class="line"><span class="string">void main()</span></span><br><span class="line"><span class="string">\&#123;</span></span><br><span class="line"><span class="string">    gl_FragColor = texture2D(texture, gl_TexCoord[0].st);</span></span><br><span class="line"><span class="string">\&#125;"</span>)</span><br><span class="line"></span><br><span class="line">var fragmentShaderPremultiply = (</span><br><span class="line"><span class="string">"void main()</span></span><br><span class="line"><span class="string">\&#123;</span></span><br><span class="line"><span class="string">    //gl_FragColor = gl_Color;  //for testing no premultiply</span></span><br><span class="line"><span class="string">    gl_FragColor = vec4(gl_Color.rgb * gl_Color.a, gl_Color.a);</span></span><br><span class="line"><span class="string">\&#125;"</span>)</span><br><span class="line"></span><br><span class="line">var rsPremultiplySatSub, rsSatSub : RenderStates?</span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def initialize</span><br><span class="line">    set_window_title(<span class="string">"sfml"</span>) </span><br><span class="line"></span><br><span class="line">    var shaderPremult = <span class="keyword">new</span> Shader()</span><br><span class="line">    shaderPremult |&gt; load_fragment_shader_from_string(fragmentShaderPremultiply)</span><br><span class="line"></span><br><span class="line">    var shaderTex = <span class="keyword">new</span> Shader()</span><br><span class="line">    shaderTex |&gt; load_fragment_shader_from_string(fragmentShaderTex)    </span><br><span class="line">    shaderTex |&gt; bind_current_texture_to_uniform(<span class="string">"texture"</span>)</span><br><span class="line">    </span><br><span class="line">    var blendModeSatSubSeparate = <span class="keyword">new</span> BlendMode(Factor One, Factor OneMinusSrcAlpha, Equation Add, Factor OneMinusDstAlpha, Factor One, Equation Add)</span><br><span class="line"></span><br><span class="line">    rsPremultiplySatSub = makeRenderTarget(shaderPremult, blendModeSatSubSeparate)</span><br><span class="line">    rsSatSub = makeRenderTarget(shaderTex, blendModeSatSubSeparate)</span><br><span class="line"></span><br><span class="line">def drawCircles(var rt: RenderTarget&amp;; rs: RenderStates&amp; implicit)</span><br><span class="line">    <span class="keyword">using</span>(<span class="number">125.0f</span>, <span class="number">128u</span>l) &lt;| $(var shape: CircleShape#)</span><br><span class="line">        shape |&gt; setFillColor(Color(<span class="number">0u</span>,<span class="number">255u</span>,<span class="number">0u</span>,<span class="number">128u</span>))</span><br><span class="line">        rt |&gt; draw(shape, rs)</span><br><span class="line">    <span class="keyword">using</span>(<span class="number">125.0f</span>, <span class="number">128u</span>l) &lt;| $(var shape: CircleShape#)</span><br><span class="line">        interface(shape) &lt;| $(var tr: Transformable) &#123; tr |&gt; move(<span class="number">125.0f</span>, <span class="number">0.0f</span>); &#125;</span><br><span class="line">        shape |&gt; setFillColor(Color(<span class="number">255u</span>,<span class="number">05u</span>,<span class="number">0u</span>,<span class="number">128u</span>))</span><br><span class="line">        rt |&gt; draw(shape, rs)</span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">render_with_blend_and_premultiply</span><span class="params">(var rt: RenderTarget&amp;)</span></span></span><br><span class="line"><span class="function">    <span class="title">drawCircles</span><span class="params">(rt, *rsPremultiplySatSub)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">def <span class="title">render_sprite_with_blend</span><span class="params">(var rt: RenderTarget&amp;; var sprite: Sprite&amp; implicit)</span></span></span><br><span class="line">    rt |&gt; draw(sprite, *rsSatSub)</span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def draw</span><br><span class="line">    withRenderTarget &lt;| $(var rt: RenderTarget&amp;)</span><br><span class="line">        rt |&gt; clear(Color(<span class="number">255u</span>,<span class="number">255u</span>,<span class="number">255u</span>,<span class="number">255u</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment">//simple draw</span></span><br><span class="line">        text_out(<span class="number">0</span>, <span class="number">0</span>, <span class="string">"Simple"</span>, <span class="number">0xFF000000</span>)</span><br><span class="line">        drawCircles(rt, RenderStates_Default())</span><br><span class="line"></span><br><span class="line">        <span class="comment">//render texture draw</span></span><br><span class="line">        text_out(<span class="number">0</span>, <span class="number">300</span>, <span class="string">"Texture: Premult"</span>, <span class="number">0xFF000000</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">using</span>() &lt;| $(var rtTex: RenderTexture#)</span><br><span class="line">            rtTex |&gt; create(<span class="number">250u</span> + <span class="number">125u</span>, <span class="number">250u</span>, <span class="literal">false</span>)</span><br><span class="line">            rtTex |&gt; clear(Color(<span class="number">0u</span>, <span class="number">0u</span>, <span class="number">0u</span>, <span class="number">0u</span>))</span><br><span class="line">            render_with_blend_and_premultiply(rtTex)</span><br><span class="line">            <span class="keyword">using</span>(rtTex |&gt; getTexture()) &lt;| $(var sprite: Sprite#)</span><br><span class="line">                interface(sprite) &lt;| $(var tr: Transformable)</span><br><span class="line">                    tr |&gt; move(<span class="number">0.0f</span>, <span class="number">300.0f</span>)</span><br><span class="line">                render_sprite_with_blend(rt, sprite)</span><br></pre></td></tr></table></figure>
<p><img src="/blog/4060902549/screen4_small.png" alt=""></p>
<p>Универсальный режим смешивания для premultiply изображений:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">glBlendFuncSeparate(GL_ONE, GL_ONE_MINUS_SRC_ALPHA, GL_ONE_MINUS_DST_ALPHA, GL_ONE);</span><br><span class="line"></span><br><span class="line">Порядок рендера:</span><br><span class="line">1. Вывод в изображения в рендер-таргет текстуру с premultiply-шейдером (или же вывод подготовленного заранее изображения с обычным шейдером)</span><br><span class="line">2. Вывод рендер-таргет текстуры на экран с обычным шейдером (чтобы избежать лишнего умножения)</span><br><span class="line"></span><br><span class="line">математика (скопипащена с stackoverflow ответа):</span><br><span class="line">after layer 2: (a2 * r2, a2)</span><br><span class="line">after layer 3: (a3 * r3 + (1.0 - a3) * a2 * r2, (1.0 - a2) * a3 + a2)</span><br><span class="line"></span><br><span class="line">srcR &#x3D; a3 * r3 + (1.0 - a3) * a2 * r2</span><br><span class="line">srcA &#x3D; (1.0 - a2) * a3 + a2</span><br><span class="line">dstR &#x3D; a1 * r1</span><br><span class="line">ONE * srcR + ONE_MINUS_SRC_ALPHA * dstR</span><br><span class="line">    &#x3D; srcR + (1.0 - srcA) * dstR</span><br><span class="line">    &#x3D; a3 * r3 + (1.0 - a3) * a2 * r2 + (1.0 - ((1.0 - a2) * a3 + a2)) * a1 * r1</span><br><span class="line">    &#x3D; a3 * r3 + (1.0 - a3) * a2 * r2 + (1.0 - a3 + a2 * a3 - a2) * a1 * r1</span><br><span class="line">    &#x3D; a3 * r3 + (1.0 - a3) * a2 * r2 + (1.0 - a3) * (1.0 - a2) * a1 * r1</span><br></pre></td></tr></table></figure></p>
<p>Заметки по daScript:</p>
<ul>
<li>Вывод объекта с изменённым режимом блендинга и шейдером в <code>SFML</code> инкапуслирован в объекте <code>RenderStates</code></li>
<li>Вместо создания временных типов в этом примере используются “обычные” для <code>daScript</code> указатели:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var shaderPremult : Shader? = <span class="keyword">new</span> Shader()</span><br></pre></td></tr></table></figure>
<p>Такие <a href="https://dascript.org/doc/reference/language/datatypes.html#pointers" target="_blank" rel="noopener">указатели</a> хранят объект в куче и владеют им, по семантике близко к <code>std::unique_ptr</code>. При желании можно освободить объект вручную, присвоив указателю <code>nullptr</code>.</p>
<ul>
<li>ключевое слово implicit после имени типа в аргументах функции позволяет функции работать с обычными типами, так и с временными.</li>
</ul>
<p>Код примеров - <a href="https://github.com/spiiin/dasbox_sfml/tree/main/samples/sfml_blending" target="_blank" rel="noopener">https://github.com/spiiin/dasbox_sfml/tree/main/samples/sfml_blending</a></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script></div></article><div class="pagination"><a class="pagination__link pagination__next" href="/blog/2385889062/">Раньше</a></div></main><footer class="footer metadata"><p class="footer__text">© 2022 spiiin</p><p class="footer__text">Powered by <a class="footer__text__link" href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a class="footer__text__link" href="https://pages.github.com/" target="_blank">Github Page</a></p></footer></div></body></html>