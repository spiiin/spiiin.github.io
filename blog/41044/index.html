<!DOCTYPE html><html lang="ru"><head><meta charset="UTF-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Spiiin's blog | Уровни Jungle Book [NES]. Часть 1.</title><meta name="description" content=""><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=PT+Serif&amp;display=swap"><link rel="stylesheet" href="/css/highlights/darkula.css"><link rel="stylesheet" href="/css/main.css"><link rel="search" type="application/opensearchdescription+xml" href="http://spiiin.github.io/atom.xml" title="Spiiin's blog"><script>(function (i, s, o, g, r, a, m) {
  i['GoogleAnalyticsObject'] = r;
  i[r] = i[r] || function () {
    (i[r].q = i[r].q || []).push(arguments)
  }, i[r].l = 1 * new Date();
  a = s.createElement(o),
    m = s.getElementsByTagName(o)[0];
  a.async = 1;
  a.src = g;
  m.parentNode.insertBefore(a, m)
})(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');
ga('create', 'UA-00000000-0', 'auto');
ga('send', 'pageview');</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Spiiin's blog" type="application/atom+xml">
</head><body><div class="container"><header class="main-header"><h1 class="main-header__title uplize"><a class="main-header__title__link" href="/"><img class="header-image" src="/images/favicon.png" width="36" height="36">Spiiin's blog</a></h1><nav class="main-header__nav"><ul class="main-nav"><li class="main-nav__list"><a class="main-nav__list__link" href="/" target="_self">HOME</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/archives/" target="_self">ARCHIVE</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/tags/meta" target="_self">TAGS</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/blog/1" target="_self">ABOUT</a></li></ul></nav></header><main class="container__wrapper"><div class="pagination"><a class="pagination__link pagination__prev" href="/blog/21742/">Позже</a><a class="pagination__link pagination__next" href="/blog/61505/">Раньше</a></div><article class="article post"><h3 class="article__title">Уровни Jungle Book [NES]. Часть 1.</h3><div class="article__date metadata"><div class="post-info">2011/10/19</div></div><div class="article__tags metadata">Tags:
<a class="article__tags__link metadata" href="/tags/nes/">nes</a><a class="article__tags__link metadata" href="/tags/hack/">hack</a></div><div class="article__body"><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p><em>//Лучший способ научиться программированию - взять дизассемблер и посмотреть, как это делают другие.</em>  </p>
<p><strong>Шаг 0xFF.</strong><br>Когда-то давно у меня было несколько выпусков журнала <a href="http://lurkmore.ru/%D0%92%D0%B5%D0%BB%D0%B8%D0%BA%D0%B8%D0%B9_D%D1%80%D0%B0%D0%BA%D0%BE%D0%BD" target="_blank" rel="noopener">“Великий Дракон”</a>, в которых были опубликованы карты уровней из “Утиных историй”. Но только там были швы на границах сшитых скриншотов и на каждом экране была копия Скруджа. Я вспомнил про эти карты и подумал, что было бы неплохо научиться вырывать из картриджа с игрой карты уровней в том формате, в котором они там и записаны. Технически это, конечно, немножко сложнее, чем слепливать скриншоты, но зато можно разобраться с методикой. В каждой игре используется свой способ хранения (разве что может у игр с одинаковым движком будет одинаковый формат), но можно выделить общие действия.  </p>
<p><strong>Шаг 0x00.</strong><br>Кроме обучения, можно использовать результат и в практических целях:  </p>
<ul>
<li>Планирование способов прохождения.  </li>
<li>Наглядная подсказка.  </li>
<li>Обнаружение неизвестных ранее секретных зон.  </li>
<li>Анализ дизайна уровней.  </li>
<li>Пиратское копирование уровней или графики в другую игру.  </li>
<li>Модификация уровня и/или создание редактора уровней.  </li>
<li>Распечатывание и развешивание на стены в качестве обоев.  </li>
</ul>
<p>Но карты для Duck Tales мне были не особо нужны, потому что они не особо запутанные и спустя годы я все равно помню все секретные проходы и оптимальные пути и сомневаюсь в наличии неизвестных ранее сокровищ и секретов, еще не открытых обычными геймерами. Поэтому интереснее выбрать игру с лабиринтами, в которых можно заблудиться и ограничено время, за которое необходимо найти выход. Из известных мне игр на NES сходу вспомнились Jungle Book и Alien 3. Маугли повезло больше, поэтому я стал рипать уровни из рома Jungle Book[E].nes.  </p>
<p>Под катом спрятано техническое описание процесса вырезания и сами карты.  </p>
<p><strong>Шаг 0x01.</strong><br>Необходимые инструменты - эмулятор NES со встроенным отладчиком и просмотром состояния памяти консоли (<a href="http://www.the-interweb.com/serendipity/index.php?/categories/9-FCEUXD-SP" target="_blank" rel="noopener">FCEUXSP</a>), дизассемблер, бумага и ручка. Также очень не помешает знание какого-нибудь языка программирования, чтобы автоматизировать рассчеты, так как считать и рисовать придется довольно много.  </p>
<p><strong>Шаг 0x02.</strong><br>Отрисовка графики фона на NES.<br>Консоль умеет рисовать бекграунд и до тридцати двух спрайтов. Чтобы вывести полноэкранный бекграунд, необходимо выключить вывод фона видеопроцессором, и записать в видеопамять по адресу $2000 960 байт. Каждый байт означает номер тайла размером 8х8 в знакогенераторе (в знакогенератор загружается 1 блок графики из картриджа размером в 4 килобайта, который содержит 256 инонок-тайлов, по 2 бита на пиксел). Так выкладывается 30 строк по 32 элемента.<br>Далее по адресам $23C0-$23FF в видеопамять записывается 64 байта атрибутов и каждому квадрату размером 2х2 тайла приписывается еще 2 бита цвета из атрибута. С помощью этого можно подкрасить двухбитовые пикселы тайлов до четырехбитовых. Эти 4 бита являются индексом в палитре, которая позволяет выбрать 16 цветов из 64 поддерживаемых видеопроцессором. Палитра расположена по адресу $3F00. Далее необходимо снова включить отрисовку фона и видеопроцессор обновит картинку на экране. Кроме того, через регистры процессора можно скроллить фоновую картинку по горизонтали и вертикали, поэтому чтобы передвинуть бекграунд вправо или влево, необязательно перерисовывать всю картинку целиком, достаточно включить аппаратный скроллинг и дорисовывать только новые столбы и строки.<br>Управление видеопроцессором осуществляется записью по определенным адресам CPU.<br>Подробнее про отрисовку можно почитать в <a href="http://dendy.migera.ru/" target="_blank" rel="noopener">доке Migera</a>.  </p>
<p><strong>Шаг 0x03.</strong><br>Эмулятор FCEUXSP умеет отображать содержимое знакогенератора и текущую палитру (Tools-&gt;PPU Viewer), содержимое экранной страницы (Tools-&gt;Name Table Viewer), либо просто просматривать видеопамять (Tools-&gt;Hex Editor, View-&gt;Ppu memory). Еще встроенный отладчик позволяет ставить точки остановки на запись в видеопамять, и можно начать процесса взлома с того, чтобы поставить точку остановки на запись в видеопамять в диапазоне $2000-$23BF (то есть любое обновление экрана). Точка остановки срабатывает от нажатия на кнопку старт в главном меню игры до запуска первого уровня несколько раз, поэтому включать её стоит, когда уровень уже начался, чтобы поймать только обновление экрана.<br>Остановка сработает в тот момент, когда экран сдвинется вправо или влево и отладчик покажет адрес выполнения $E38C (инструкция STA $2007). В этот момент следует сделать дамп памяти Tools-&gt;Hex View и загрузить его в дизассемблер. Как это делается, хорошо описано <a href="http://griever.magicteam.net/doc/?doc=NES_IDA" target="_blank" rel="noopener">здесь</a>.<br>Новые дампы памяти надо делать каждый раз, когда в отладчике обнаруживается, что данные в области ROM’а (от $8000 до $FFFF) отличаются от тех, что видны в дизассемблере. Это происходит потому, что на картридже могут иметься несколько банков памяти, которые подставляются в адресное пространство процессора (вроде бы плоское), добавляя ему второе измерение. Про переключение банков я знаю пока мало, для этого надо вчитываться в доки по мапперам, а некоторые из них еще нерасшифрованы полностью, поэтому отслеживаю соотвествие кода в дампе тому, что отображает просмотрщик памяти в эмуляторе.<br>Функция, на которой остановился отладчик - горизонтальный скроллинг экрана, дорисовка нового столбца слева или справа. Данные копируются из оперативной памяти по адресу $040D и дальше в видеопамять.  </p>
<p><strong>Шаг 0x04.</strong><br>Точка остановки переставляется на запись в адреса около $040D и срабатывает при очередном горизонтальном скроллинге, когда Маугли бежит вперед.<br>ROM:8462 LDA ($95),Y<br>ROM:8464 STA $40D,X<br>ROM:8467 LDA ($99),Y<br>ROM:8469 STA $40E,X<br>ROM:846C LDA ($71),Y<br>ROM:846E JMP loc_847D<br>ROM:8471 ; —————————————————————————————————————-<br>ROM:8471 LDA ($93),Y ; что-то типа записи в столбик, из которого будет перенос в видеопамять<br>ROM:8473 STA $40D,X<br>ROM:8476 LDA ($97),Y<br>ROM:8478 STA $40E,X<br>ROM:847B LDA ($6F),Y  </p>
<p>Столбик заполняется данными из адресов, записанных либо в ячейки 95-96 и 98-99, либо в ячейки 93-94 и 97-98. Такая адресация - злейший враг для хакера по двум причинам. Во-первых, чтобы проверить, какие адреса находятся в нулевой странице (по адресам $00-$FF, нужно каждый раз смотреть их в дизассемблере, что добавляет в код третье измерение и сильно усложняет восприятие, а во-вторых, брейкпоинты на чтение, поставленные на нулевую страницу, не работают, так как чтение значения из нее не производится, а происходит вычисление адреса относительно того, что записано в эти ячейки памяти.<br>Я проверяю, что за адреса лежат в этих ячейках памяти на каждом шаге в поисках закономерности - каждые 4 шага адреса повторяются, но это не позволяет разобраться, откуда они берутся.  </p>
<p><strong>Шаг 0x05.</strong><br>Дальше проверяю то, откуда берутся адреса в ячейках 93-98. Брейкнулся в кусок функции:<br>ROM:856B LDY $DD88,X<br>ROM:856E LDA 0,Y<br>ROM:8571 STA byte_83<br>ROM:8573 LDA 1,Y<br>ROM:8576 STA byte_84<br>ROM:8578 LDA 4,Y<br>ROM:857B STA byte_85<br>ROM:857D LDA 5,Y<br>ROM:8580 STA byte_86<br>ROM:8582 LDY $DD8C,X<br>ROM:8585 LDA 0,Y<br>ROM:8588 STA byte_87<br>ROM:858A LDA 1,Y<br>ROM:858D STA byte_88<br>ROM:858F LDA 4,Y<br>ROM:8592 STA byte_89<br>ROM:8594 LDA 5,Y<br>ROM:8597 STA byte_8A<br>ROM:8599 LDY $DD90,X<br>ROM:859C LDA 0,Y<br>ROM:859F STA byte_93<br>ROM:85A1 LDA 1,Y<br>ROM:85A4 STA byte_94<br>ROM:85A6 LDA 4,Y<br>ROM:85A9 STA byte_95<br>ROM:85AB LDA 5,Y<br>ROM:85AE STA byte_96<br>ROM:85B0 LDY $DD94,X<br>ROM:85B3 LDA 0,Y<br>ROM:85B6 STA byte_97<br>ROM:85B8 LDA 1,Y<br>ROM:85BB STA byte_98<br>ROM:85BD LDA 4,Y<br>ROM:85C0 STA byte_99<br>ROM:85C2 LDA 5,Y<br>ROM:85C5 STA byte_9A<br>ROM:85C7 RTS  </p>
<p>Отсюда видно, что в роме (область $DDxx - уже области памяти картриджа) есть массивы указателей, которыми индексируется какие-то ячейки оперативной памяти (какие именно показывает регистр Y), и данные из этих ячеек переносятся дальше. Тут непонятно, откуда берется X и Y, но вместо дальнейшего реверс-анализа я смотрю их изменение во времени при нескольких последовательных скроллингах. X меняется последовательно от 0 до 3, а Y не совсем понятно как, но адреса находятся примерно в диапазоне $60-$80. Много их там быть не может, потому что эта область - оперативная память и расходовать ее много нельзя ввиду ее небольшого размера. Поэтому лучше ставить точки остановки на как можно меньшее число адресов в этой зоне, так как иногда одна и та же ячейка может за один кадр использоваться в разных целях (например для рассчета позиций врагов). Так что в качестве следующей точки остановки выбрал ячейки $67-$68  </p>
<p><strong>Шаг 0x06.</strong><br>Следующая остановка показывает, что запись в эти ячейки производится 1 раз при старте уровня (сразу после затухания экрана LEVEL 1 GET READY) по адресу $F542 (STA 0047,Y). Сделав в отладчике step out , доходим до выхода из функции, засекаем ее начало и делаем дамп памяти, чтобы засунуть его в дизассемблер. Это - функция загрузки уровня. По адресу 35D хранится номер уровня, служащий индексом для таблицы смещений , где лежит набор адресов, копирующих в набор - диапазон 47-82.<br>ROM:F52F LDA byte_35D ; взять номер уровня<br>ROM:F532 ASL A ; (адрес занимает 2 байта)<br>ROM:F533 TAX<br>ROM:F534 LDA $F71A,X ; загрузить из F71A адрес начала таблицы смещений уровня<br>ROM:F537 STA byte_21<br>ROM:F539 LDA $F71B,X<br>ROM:F53C STA byte_22<br>ROM:F53E LDY #$3B ; ‘;’<br>ROM:F540 LDA ($21),Y ; копирование адреса в набор 47-82 для уровня<br>ROM:F542 STA $47,Y<br>ROM:F545 DEY<br>ROM:F546 BPL loc_F540 ; копирование адреса в набор 47-82 для уровня<br>ROM:F548 LDY #$46 ; ‘F’ ; дальше еще полкилобайта какого-то кода  </p>
<p>Чуть про философию реверса - выбор названий для переменных здесь намного важнее, чем в обычном программировании, потому что, разбираясь с кодом алгоритма, изначально есть только адреса, по сути анонимные переменные , по аналогии с анонимными функциями. А воспринимаемый набор действий над такими переменными без названия имеет только образ, без определения. Мысленно можно построить только граф выполнения, временную развертку команд над адресами. Распознавание в командах действий позволяет заменить граф последовательностью функций, а распознавание назначения адресов - разделить безымянное адресное пространство на области, имеющие определенное предназначение. Чтобы привести алгоритм к известному, надо подобрать такие названия областей, чтобы по ним было понятно их содержимое. Ну и необходимо помнить, что ввиду малого количества памяти эти области могут перекрываться и использоваться в различных целях, то есть в данном месте значения в ячейках 42-83 являются набором стартовых адресов при загрузке уровня, а по окончании уже могут быть например, количеством набранных за уровень очков или еще чем-нибудь.  </p>
<p><strong>Шаг 0x07.</strong><br>Начиная с обнаружения функции загрузки, можно не лезть дальше вглубь в сам ROM, а расшифровать ее, то есть понять назначение ячеек, в которые считываются данные. Здесь стоит подумать, что именно необходимо искать. Из предыдущего опыта разбора игровых данных в  <a href="http://spiiin.livejournal.com/38881.html" target="_blank" rel="noopener">Охотниках за привидениями</a> , я запомнил, что запись об уровне может иметь сложный формат, содержать вперемежку код логики игровых событий и данные. Так что, скорее всего, здесь тоже применяется какой-нибудь метод для сжатия игровых данных. Так что при анализе вверх от данных из рома к видеопамяти придется разобраться еще с функцией расшифровки данных и сэмулировать ему на каком-нибудь языке. Однако и возможность того, что данные лежат целым блоком, тоже есть. Так что стоит придумать способ отрисовки картинки уровня по какому-либо набору данных. Чтобы найти этот набор, можно взять любой адрес начала записи об уровне и попытаться разделить в нем код и данные. Правило визуального отделения данных и кодов - данные обладают когерентностью (соседние похожи между собой), коды - не обладают. Еще можно узнавать шаблоны кодов (зная коды команд, содержащих в операнде непосредственный адрес (jmp и lda с некоторыми типами адресаций) + код rts для конца функций, можно находить в коде адреса, и попробовать ассемблировать эти куски в дизассемблере). Вообщем, даже если начать рисовать смесью кодов и данных, то все равно можно найти какой-то осмысленный кусок и понять структуру. Так что дальше надо написать программу рисования и скормить ей все данные об уровне.<br>Как было сказано выше, для получения этих данных можно не лезть глубже, а начать вместо обратного просмотра прямой, отслеживая данные от момента считывания из РОМа в зону 47-82 ( набор ) до попадания прямо на экран.<br>Начинаем выныривать.<br>ROM:F71A .WORD $B6E3 ; адреса начала смещений уровней и бонусных зон (всего по 72, хотя под карту юзаются 59, дальше что-то еще).<br>ROM:F71C .WORD $B72B<br>ROM:F71E .WORD $B773<br>ROM:F720 .WORD $B7BB<br>ROM:F722 .WORD $B803<br>ROM:F724 .WORD $B84B<br>ROM:F726 .WORD $B893<br>ROM:F728 .WORD $B8DB<br>ROM:F72A .WORD $B923<br>ROM:F72C .WORD $B96B<br>ROM:F72E .WORD $BBAB<br>ROM:F730 .WORD $BB63<br>ROM:F732 .WORD $B9B3<br>ROM:F734 .WORD $B9FB<br>ROM:F736 .WORD $BA43<br>ROM:F738 .WORD $BA8B<br>ROM:F73A .WORD $BAD3<br>ROM:F73C .WORD $BB1B<br>ROM:F73E .WORD $BBAB  </p>
<p><strong>Шаг 0x08.</strong><br>Скрипт рисования. На питоне, для работы с изображениями нужна библиотека <a href="http://www.pythonware.com/products/pil/" target="_blank" rel="noopener">PIL</a>.  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Класс инкапсулирует данные об одном тайле и позволяет сравнить тайлы с учетом палитры.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PpuSprite</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, im)</span>:</span></span><br><span class="line">     self.image = im</span><br><span class="line">     self.imageData = im.getdata()</span><br><span class="line">     self.colorTable = im.getcolors()</span><br><span class="line">     self.colorTable.sort()</span><br><span class="line">     self.firstColorsPos = [] </span><br><span class="line">     self.calcFirstColorsPoses()</span><br><span class="line">     self.indexedData = []</span><br><span class="line">     self.prepareIndexedData()</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">calcFirstColorsPoses</span><span class="params">(self)</span>:</span>        </span><br><span class="line">     <span class="keyword">for</span> _,colorInPalette <span class="keyword">in</span> self.colorTable:</span><br><span class="line">       firstColorPos = <span class="number">-1</span></span><br><span class="line">       <span class="keyword">for</span> color <span class="keyword">in</span> self.imageData:</span><br><span class="line">         firstColorPos+=<span class="number">1</span></span><br><span class="line">         <span class="keyword">if</span> color == colorInPalette:</span><br><span class="line">           <span class="keyword">break</span></span><br><span class="line">       self.firstColorsPos.append((firstColorPos,colorInPalette))</span><br><span class="line">     self.firstColorsPos.sort()</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">prepareIndexedData</span><span class="params">(self)</span>:</span></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">calcColorHash</span><span class="params">(c)</span>:</span></span><br><span class="line">       <span class="keyword">return</span> c[<span class="number">0</span>]&lt;&lt;<span class="number">16</span> | c[<span class="number">1</span>]&lt;&lt;<span class="number">8</span> | c[<span class="number">2</span>]</span><br><span class="line">     colorHashes = map (<span class="keyword">lambda</span> colorRec : calcColorHash(colorRec[<span class="number">1</span>]), self.firstColorsPos)</span><br><span class="line">     <span class="keyword">for</span> pixel <span class="keyword">in</span> self.imageData:</span><br><span class="line">       pixelHash = calcColorHash(pixel)</span><br><span class="line">       colorIndex = <span class="number">-1</span></span><br><span class="line">       <span class="keyword">for</span> colorHash <span class="keyword">in</span> colorHashes:</span><br><span class="line">         colorIndex +=<span class="number">1</span></span><br><span class="line">         <span class="keyword">if</span> pixelHash == colorHash:</span><br><span class="line">           <span class="keyword">break</span></span><br><span class="line">       self.indexedData.append(colorIndex)</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">isEqual</span><span class="params">(self, otherPpuSprite)</span>:</span></span><br><span class="line">     <span class="keyword">if</span> len(self.firstColorsPos) != len(otherPpuSprite.firstColorsPos):</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">     <span class="keyword">for</span> fcp1, fcp2 <span class="keyword">in</span> zip(self.firstColorsPos, otherPpuSprite.firstColorsPos):</span><br><span class="line">       <span class="keyword">if</span>  fcp1[<span class="number">0</span>]!= fcp2[<span class="number">0</span>]:</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">     <span class="keyword">if</span> len(self.colorTable) != len(otherPpuSprite.colorTable):</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">     <span class="keyword">for</span> colorTableRec1, colorTableRec2 <span class="keyword">in</span> zip(self.colorTable, otherPpuSprite.colorTable):</span><br><span class="line">       <span class="keyword">if</span> colorTableRec1[<span class="number">0</span>] != colorTableRec2[<span class="number">0</span>]:</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">     <span class="keyword">for</span> pixel1, pixel2 <span class="keyword">in</span> zip(self.indexedData, otherPpuSprite.indexedData):</span><br><span class="line">       <span class="keyword">if</span> pixel1!=pixel2:</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">     <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>Дальше следует захватить из эмулятора блок с тайлами текущего уровня и распилить его на кусочки. FCEUXSP позволяет только посмотреть этот блок (View-&gt;Name Table View), но можно заскриншотить его и вырезать в любом графическом редакторе. Вот так выглядит блок для первого уровня:<br><img src="http://pics.livejournal.com/spiiin/pic/0001tbpp" alt=""><br>Только надо помнить, что эмулятор показывает блок увеличенным в 2 раза, поэтому надо в редакторе уменьшить его до размера 128x128, убедившись, что при уменьшении не используются никакие алгоритмы улучшения качества, так как нужно получить попиксельное совпадение. Дальше из этой картинки можно нарезать тайлы:  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">imNameTable = Image.open(os.path.expanduser(<span class="string">"~/desktop/jungleBook/jungleBookTable1.png"</span>))   <span class="comment">#сохраненная таблица тайлов.</span></span><br><span class="line">imLevelTable = Image.open(os.path.expanduser(<span class="string">"~/desktop/jungleBook/jungleBookLevel1.png"</span>))  <span class="comment">#любой скриншот уровня, загружается для теста</span></span><br><span class="line">nameSize = imNameTable.size</span><br><span class="line">levelSize = imLevelTable.size</span><br><span class="line">nameTable = [imNameTable.crop((x,y,x+<span class="number">8</span>,y+<span class="number">8</span>)) <span class="keyword">for</span> y,x <span class="keyword">in</span> itertools.product(xrange(<span class="number">0</span>,nameSize[<span class="number">1</span>],<span class="number">8</span>),xrange(<span class="number">0</span>,nameSize[<span class="number">0</span>],<span class="number">8</span>))]</span><br><span class="line">levelTable = [imLevelTable.crop((x,y,x+<span class="number">8</span>,y+<span class="number">8</span>)) <span class="keyword">for</span> y,x <span class="keyword">in</span> itertools.product(xrange(<span class="number">0</span>,levelSize[<span class="number">1</span>],<span class="number">8</span>),xrange(<span class="number">0</span>,levelSize[<span class="number">0</span>],<span class="number">8</span>))]</span><br><span class="line">ppuSpriteMemTable = map (<span class="keyword">lambda</span> im: PpuSprite(im),nameTable) </span><br><span class="line">ppuSpriteLvlTable = map (<span class="keyword">lambda</span> im: PpuSprite(im),levelTable)</span><br></pre></td></tr></table></figure>
<p>Функция отрисовки по массиву тайлов (принимает линейный массив данных, таблицу спрайтов, размер уровня и флажок, построчно или постолбцово рисовать, возврашает экземляр класс PIL Image):  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">drawLevelFromData</span><span class="params">(levelArray, ppuSpriteTable, size, vertical = False)</span>:</span></span><br><span class="line">  w,h = size</span><br><span class="line">  im = Image.new(<span class="string">"RGBA"</span>, (w*<span class="number">8</span>,h*<span class="number">8</span>))</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(levelArray)):</span><br><span class="line">    <span class="keyword">if</span> vertical:</span><br><span class="line">      x,y = i/h, i%h</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      x,y = i%w, i/w</span><br><span class="line">    ind = levelArray[i]</span><br><span class="line">    <span class="keyword">if</span> (ind!=<span class="number">-1</span>):</span><br><span class="line">      im.paste(ppuSpriteTable[ind].image, (x*<span class="number">8</span>,y*<span class="number">8</span>,x*<span class="number">8</span>+<span class="number">8</span>,y*<span class="number">8</span>+<span class="number">8</span>))</span><br><span class="line">  <span class="keyword">return</span> im</span><br></pre></td></tr></table></figure>
<p>Чтобы проверить программу рисования и корректность сравнения по индексированным цветам, превратим скриншот уровня в данные и отдадим этой функции.  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findFirstPicIndex</span><span class="params">(sprite, ppuSpriteTable)</span>:</span></span><br><span class="line">  index = <span class="number">-1</span></span><br><span class="line">  <span class="keyword">for</span> ppuSprite <span class="keyword">in</span> ppuSpriteTable:</span><br><span class="line">    index+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> ppuSprite.isEqual(sprite):</span><br><span class="line">      <span class="keyword">return</span> index</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">makeLevelMap</span><span class="params">(mem, lev)</span>:</span></span><br><span class="line">  levTable = []</span><br><span class="line">  <span class="keyword">for</span> l <span class="keyword">in</span> lev:</span><br><span class="line">    levTable.append(findFirstPicIndex(l, mem))</span><br><span class="line">  <span class="keyword">return</span> levTable</span><br><span class="line"> </span><br><span class="line">mapLevel = makeLevelMap(ppuSpriteMemTable, ppuSpriteLvlTable)</span><br><span class="line">drawLevelFromData(mapLevel, sprites,(WIDTH,HEIGHT),<span class="literal">True</span>).show()</span><br></pre></td></tr></table></figure>
<p>На выходе можно увидеть уровень, выглядящий примерно как рендер Матрицы на компьютере с недостаточной мощностью:<br><img src="http://pics.livejournal.com/spiiin/pic/0001w7zd" alt="">  </p>
<p><strong>Шаг 0x09.</strong><br>Дальше я попытался отрисовать данные уровня разными способами, ничего интересного не получил, и понял, что надо все-таки еще искать функцию-комбинатор, которые будет определять, как данные из набора попадают на экран . Набор смещений 47-82 для первого уровня по адресу $B6E3<br>A139 A739 DDC8 DDC8 DBF4<br>DC59 AA49 AAC0 DCBE DD23<br>AB37 ABAE D974 D9F4 A7C9<br>A849 DA74 DAF4 A8C9 A949<br>DB74 A9C9 BBF3 A825 A795<br>A765 A764 A766 A7F5 A7C5<br>Точка остановки на чтение этих значений. $8D62 в новом банке памяти (надо сделать еще один дамп), анализ кода там:<br>берем 4 бита шагов (2 горизонт, 2 вертикаль) и используем их как смещение от адреса DDA8<br>ROM:DDA8 .WORD $4F4F ; idle вторая часть (адреса из набора )<br>ROM:DDAA .WORD $5151<br>ROM:DDAC .WORD $4F4F<br>ROM:DDAE .WORD $5151<br>ROM:DDB0 .WORD $5757<br>ROM:DDB2 .WORD $5959<br>ROM:DDB4 .WORD $5757<br>ROM:DDB6 .WORD $5959<br>и переносим их в 8b-8e<br>потом повторно берем из DDB8 и переносим в 9b-9e:<br>ROM:DDB8 .WORD $615F ; idle вторая часть(адреса из набора )<br>ROM:DDBA .WORD $615F<br>ROM:DDBC .WORD $6967<br>ROM:DDBE .WORD $6967<br>ROM:DDC0 .WORD $615F<br>ROM:DDC2 .WORD $615F<br>ROM:DDC4 .WORD $6967<br>ROM:DDC6 .WORD $6967  </p>
<p>Это массив направлений , где хранится по 4 значения адресов из набора , которые будут скопированы по адресу предэкран (назовем так адреса 9B-9E и 8B-8E, потому что там лежат адреса массивов, из которых будут считаны номеры тайлов, попадающих в зону экрана $40E-$423).  </p>
<p><a href="http://spiiin.livejournal.com/43116.html" target="_blank" rel="noopener">Продолжение</a></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script></div></article><div class="pagination"><a class="pagination__link pagination__prev" href="/blog/21742/">Позже</a><a class="pagination__link pagination__next" href="/blog/61505/">Раньше</a></div></main><footer class="footer metadata"><p class="footer__text">© 2022 spiiin</p><p class="footer__text">Powered by <a class="footer__text__link" href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a class="footer__text__link" href="https://pages.github.com/" target="_blank">Github Page</a></p></footer></div></body></html>