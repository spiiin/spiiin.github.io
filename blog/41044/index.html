<!DOCTYPE html><html lang="ru"><head><meta charset="UTF-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Spiiin's blog | Уровни Jungle Book [NES]. Часть 1.</title><meta name="description" content=""><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=PT+Serif&amp;display=swap"><link rel="stylesheet" href="/css/highlights/darkula.css"><link rel="stylesheet" href="/css/main.css"><link rel="search" type="application/opensearchdescription+xml" href="http://spiiin.github.io/atom.xml" title="Spiiin's blog"><script>(function (i, s, o, g, r, a, m) {
  i['GoogleAnalyticsObject'] = r;
  i[r] = i[r] || function () {
    (i[r].q = i[r].q || []).push(arguments)
  }, i[r].l = 1 * new Date();
  a = s.createElement(o),
    m = s.getElementsByTagName(o)[0];
  a.async = 1;
  a.src = g;
  m.parentNode.insertBefore(a, m)
})(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');
ga('create', 'UA-00000000-0', 'auto');
ga('send', 'pageview');</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-shiki-plugin@latest/lib/codeblock.css">
<style>:root{--hl-color:#abb2bf;--hl-bg:#282c34;--hltools-bg:#21252b;--hltools-color:#bbbbbc;--hlnumber-bg:#282c34;--hlnumber-color:#495162;--hlscrollbar-bg:#373c47;--hlexpand-bg:linear-gradient(180deg,rgba(40,44,52,0.1),rgba(40,44,52,0.9))}</style><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Spiiin's blog" type="application/atom+xml">
</head><body><div class="container"><header class="main-header"><h1 class="main-header__title uplize"><a class="main-header__title__link" href="/"><img class="header-image" src="/images/favicon.png" width="36" height="36">Spiiin's blog</a></h1><nav class="main-header__nav"><ul class="main-nav"><li class="main-nav__list"><a class="main-nav__list__link" href="/" target="_self">HOME</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/archives/" target="_self">ARCHIVE</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/tags/meta" target="_self">TAGS</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/blog/1" target="_self">ABOUT</a></li></ul></nav></header><main class="container__wrapper"><div class="pagination"><a class="pagination__link pagination__prev" href="/blog/21742/">Позже</a><a class="pagination__link pagination__next" href="/blog/61505/">Раньше</a></div><article class="article post"><h3 class="article__title">Уровни Jungle Book [NES]. Часть 1.</h3><div class="article__date metadata"><div class="post-info">2011/10/20</div></div><div class="article__tags metadata">Tags:
<a class="article__tags__link metadata" href="/tags/nes/">nes</a><a class="article__tags__link metadata" href="/tags/hack/">hack</a></div><div class="article__body"><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p><em>//Лучший способ научиться программированию - взять дизассемблер и посмотреть, как это делают другие.</em>  </p>
<p><strong>Шаг 0xFF.</strong><br>Когда-то давно у меня было несколько выпусков журнала <a target="_blank" rel="noopener" href="http://lurkmore.ru/%D0%92%D0%B5%D0%BB%D0%B8%D0%BA%D0%B8%D0%B9_D%D1%80%D0%B0%D0%BA%D0%BE%D0%BD">“Великий Дракон”</a>, в которых были опубликованы карты уровней из “Утиных историй”. Но только там были швы на границах сшитых скриншотов и на каждом экране была копия Скруджа. Я вспомнил про эти карты и подумал, что было бы неплохо научиться вырывать из картриджа с игрой карты уровней в том формате, в котором они там и записаны. Технически это, конечно, немножко сложнее, чем слепливать скриншоты, но зато можно разобраться с методикой. В каждой игре используется свой способ хранения (разве что может у игр с одинаковым движком будет одинаковый формат), но можно выделить общие действия.  </p>
<p><strong>Шаг 0x00.</strong><br>Кроме обучения, можно использовать результат и в практических целях:  </p>
<ul>
<li>Планирование способов прохождения.  </li>
<li>Наглядная подсказка.  </li>
<li>Обнаружение неизвестных ранее секретных зон.  </li>
<li>Анализ дизайна уровней.  </li>
<li>Пиратское копирование уровней или графики в другую игру.  </li>
<li>Модификация уровня и/или создание редактора уровней.  </li>
<li>Распечатывание и развешивание на стены в качестве обоев.  </li>
</ul>
<p>Но карты для Duck Tales мне были не особо нужны, потому что они не особо запутанные и спустя годы я все равно помню все секретные проходы и оптимальные пути и сомневаюсь в наличии неизвестных ранее сокровищ и секретов, еще не открытых обычными геймерами. Поэтому интереснее выбрать игру с лабиринтами, в которых можно заблудиться и ограничено время, за которое необходимо найти выход. Из известных мне игр на NES сходу вспомнились Jungle Book и Alien 3. Маугли повезло больше, поэтому я стал рипать уровни из рома Jungle Book[E].nes.  </p>
<p>Под катом спрятано техническое описание процесса вырезания и сами карты.  </p>
<p><strong>Шаг 0x01.</strong><br>Необходимые инструменты - эмулятор NES со встроенным отладчиком и просмотром состояния памяти консоли (<a target="_blank" rel="noopener" href="http://www.the-interweb.com/serendipity/index.php?/categories/9-FCEUXD-SP">FCEUXSP</a>), дизассемблер, бумага и ручка. Также очень не помешает знание какого-нибудь языка программирования, чтобы автоматизировать рассчеты, так как считать и рисовать придется довольно много.  </p>
<p><strong>Шаг 0x02.</strong><br>Отрисовка графики фона на NES.<br>Консоль умеет рисовать бекграунд и до тридцати двух спрайтов. Чтобы вывести полноэкранный бекграунд, необходимо выключить вывод фона видеопроцессором, и записать в видеопамять по адресу $2000 960 байт. Каждый байт означает номер тайла размером 8х8 в знакогенераторе (в знакогенератор загружается 1 блок графики из картриджа размером в 4 килобайта, который содержит 256 инонок-тайлов, по 2 бита на пиксел). Так выкладывается 30 строк по 32 элемента.<br>Далее по адресам $23C0-$23FF в видеопамять записывается 64 байта атрибутов и каждому квадрату размером 2х2 тайла приписывается еще 2 бита цвета из атрибута. С помощью этого можно подкрасить двухбитовые пикселы тайлов до четырехбитовых. Эти 4 бита являются индексом в палитре, которая позволяет выбрать 16 цветов из 64 поддерживаемых видеопроцессором. Палитра расположена по адресу $3F00. Далее необходимо снова включить отрисовку фона и видеопроцессор обновит картинку на экране. Кроме того, через регистры процессора можно скроллить фоновую картинку по горизонтали и вертикали, поэтому чтобы передвинуть бекграунд вправо или влево, необязательно перерисовывать всю картинку целиком, достаточно включить аппаратный скроллинг и дорисовывать только новые столбы и строки.<br>Управление видеопроцессором осуществляется записью по определенным адресам CPU.<br>Подробнее про отрисовку можно почитать в <a target="_blank" rel="noopener" href="http://dendy.migera.ru/">доке Migera</a>.  </p>
<p><strong>Шаг 0x03.</strong><br>Эмулятор FCEUXSP умеет отображать содержимое знакогенератора и текущую палитру (Tools-&gt;PPU Viewer), содержимое экранной страницы (Tools-&gt;Name Table Viewer), либо просто просматривать видеопамять (Tools-&gt;Hex Editor, View-&gt;Ppu memory). Еще встроенный отладчик позволяет ставить точки остановки на запись в видеопамять, и можно начать процесса взлома с того, чтобы поставить точку остановки на запись в видеопамять в диапазоне $2000-$23BF (то есть любое обновление экрана). Точка остановки срабатывает от нажатия на кнопку старт в главном меню игры до запуска первого уровня несколько раз, поэтому включать её стоит, когда уровень уже начался, чтобы поймать только обновление экрана.<br>Остановка сработает в тот момент, когда экран сдвинется вправо или влево и отладчик покажет адрес выполнения $E38C (инструкция STA $2007). В этот момент следует сделать дамп памяти Tools-&gt;Hex View и загрузить его в дизассемблер. Как это делается, хорошо описано <a target="_blank" rel="noopener" href="http://griever.magicteam.net/doc/?doc=NES_IDA">здесь</a>.<br>Новые дампы памяти надо делать каждый раз, когда в отладчике обнаруживается, что данные в области ROM’а (от $8000 до $FFFF) отличаются от тех, что видны в дизассемблере. Это происходит потому, что на картридже могут иметься несколько банков памяти, которые подставляются в адресное пространство процессора (вроде бы плоское), добавляя ему второе измерение. Про переключение банков я знаю пока мало, для этого надо вчитываться в доки по мапперам, а некоторые из них еще нерасшифрованы полностью, поэтому отслеживаю соотвествие кода в дампе тому, что отображает просмотрщик памяти в эмуляторе.<br>Функция, на которой остановился отладчик - горизонтальный скроллинг экрана, дорисовка нового столбца слева или справа. Данные копируются из оперативной памяти по адресу $040D и дальше в видеопамять.  </p>
<p><strong>Шаг 0x04.</strong><br>Точка остановки переставляется на запись в адреса около $040D и срабатывает при очередном горизонтальном скроллинге, когда Маугли бежит вперед.<br>ROM:8462 LDA ($95),Y<br>ROM:8464 STA $40D,X<br>ROM:8467 LDA ($99),Y<br>ROM:8469 STA $40E,X<br>ROM:846C LDA ($71),Y<br>ROM:846E JMP loc_847D<br>ROM:8471 ; —————————————————————————————————————-<br>ROM:8471 LDA ($93),Y ; что-то типа записи в столбик, из которого будет перенос в видеопамять<br>ROM:8473 STA $40D,X<br>ROM:8476 LDA ($97),Y<br>ROM:8478 STA $40E,X<br>ROM:847B LDA ($6F),Y  </p>
<p>Столбик заполняется данными из адресов, записанных либо в ячейки 95-96 и 98-99, либо в ячейки 93-94 и 97-98. Такая адресация - злейший враг для хакера по двум причинам. Во-первых, чтобы проверить, какие адреса находятся в нулевой странице (по адресам $00-$FF, нужно каждый раз смотреть их в дизассемблере, что добавляет в код третье измерение и сильно усложняет восприятие, а во-вторых, брейкпоинты на чтение, поставленные на нулевую страницу, не работают, так как чтение значения из нее не производится, а происходит вычисление адреса относительно того, что записано в эти ячейки памяти.<br>Я проверяю, что за адреса лежат в этих ячейках памяти на каждом шаге в поисках закономерности - каждые 4 шага адреса повторяются, но это не позволяет разобраться, откуда они берутся.  </p>
<p><strong>Шаг 0x05.</strong><br>Дальше проверяю то, откуда берутся адреса в ячейках 93-98. Брейкнулся в кусок функции:<br>ROM:856B LDY $DD88,X<br>ROM:856E LDA 0,Y<br>ROM:8571 STA byte_83<br>ROM:8573 LDA 1,Y<br>ROM:8576 STA byte_84<br>ROM:8578 LDA 4,Y<br>ROM:857B STA byte_85<br>ROM:857D LDA 5,Y<br>ROM:8580 STA byte_86<br>ROM:8582 LDY $DD8C,X<br>ROM:8585 LDA 0,Y<br>ROM:8588 STA byte_87<br>ROM:858A LDA 1,Y<br>ROM:858D STA byte_88<br>ROM:858F LDA 4,Y<br>ROM:8592 STA byte_89<br>ROM:8594 LDA 5,Y<br>ROM:8597 STA byte_8A<br>ROM:8599 LDY $DD90,X<br>ROM:859C LDA 0,Y<br>ROM:859F STA byte_93<br>ROM:85A1 LDA 1,Y<br>ROM:85A4 STA byte_94<br>ROM:85A6 LDA 4,Y<br>ROM:85A9 STA byte_95<br>ROM:85AB LDA 5,Y<br>ROM:85AE STA byte_96<br>ROM:85B0 LDY $DD94,X<br>ROM:85B3 LDA 0,Y<br>ROM:85B6 STA byte_97<br>ROM:85B8 LDA 1,Y<br>ROM:85BB STA byte_98<br>ROM:85BD LDA 4,Y<br>ROM:85C0 STA byte_99<br>ROM:85C2 LDA 5,Y<br>ROM:85C5 STA byte_9A<br>ROM:85C7 RTS  </p>
<p>Отсюда видно, что в роме (область $DDxx - уже области памяти картриджа) есть массивы указателей, которыми индексируется какие-то ячейки оперативной памяти (какие именно показывает регистр Y), и данные из этих ячеек переносятся дальше. Тут непонятно, откуда берется X и Y, но вместо дальнейшего реверс-анализа я смотрю их изменение во времени при нескольких последовательных скроллингах. X меняется последовательно от 0 до 3, а Y не совсем понятно как, но адреса находятся примерно в диапазоне $60-$80. Много их там быть не может, потому что эта область - оперативная память и расходовать ее много нельзя ввиду ее небольшого размера. Поэтому лучше ставить точки остановки на как можно меньшее число адресов в этой зоне, так как иногда одна и та же ячейка может за один кадр использоваться в разных целях (например для рассчета позиций врагов). Так что в качестве следующей точки остановки выбрал ячейки $67-$68  </p>
<p><strong>Шаг 0x06.</strong><br>Следующая остановка показывает, что запись в эти ячейки производится 1 раз при старте уровня (сразу после затухания экрана LEVEL 1 GET READY) по адресу $F542 (STA 0047,Y). Сделав в отладчике step out , доходим до выхода из функции, засекаем ее начало и делаем дамп памяти, чтобы засунуть его в дизассемблер. Это - функция загрузки уровня. По адресу 35D хранится номер уровня, служащий индексом для таблицы смещений , где лежит набор адресов, копирующих в набор - диапазон 47-82.<br>ROM:F52F LDA byte_35D ; взять номер уровня<br>ROM:F532 ASL A ; (адрес занимает 2 байта)<br>ROM:F533 TAX<br>ROM:F534 LDA $F71A,X ; загрузить из F71A адрес начала таблицы смещений уровня<br>ROM:F537 STA byte_21<br>ROM:F539 LDA $F71B,X<br>ROM:F53C STA byte_22<br>ROM:F53E LDY #$3B ; ‘;’<br>ROM:F540 LDA ($21),Y ; копирование адреса в набор 47-82 для уровня<br>ROM:F542 STA $47,Y<br>ROM:F545 DEY<br>ROM:F546 BPL loc_F540 ; копирование адреса в набор 47-82 для уровня<br>ROM:F548 LDY #$46 ; ‘F’ ; дальше еще полкилобайта какого-то кода  </p>
<p>Чуть про философию реверса - выбор названий для переменных здесь намного важнее, чем в обычном программировании, потому что, разбираясь с кодом алгоритма, изначально есть только адреса, по сути анонимные переменные , по аналогии с анонимными функциями. А воспринимаемый набор действий над такими переменными без названия имеет только образ, без определения. Мысленно можно построить только граф выполнения, временную развертку команд над адресами. Распознавание в командах действий позволяет заменить граф последовательностью функций, а распознавание назначения адресов - разделить безымянное адресное пространство на области, имеющие определенное предназначение. Чтобы привести алгоритм к известному, надо подобрать такие названия областей, чтобы по ним было понятно их содержимое. Ну и необходимо помнить, что ввиду малого количества памяти эти области могут перекрываться и использоваться в различных целях, то есть в данном месте значения в ячейках 42-83 являются набором стартовых адресов при загрузке уровня, а по окончании уже могут быть например, количеством набранных за уровень очков или еще чем-нибудь.  </p>
<p><strong>Шаг 0x07.</strong><br>Начиная с обнаружения функции загрузки, можно не лезть дальше вглубь в сам ROM, а расшифровать ее, то есть понять назначение ячеек, в которые считываются данные. Здесь стоит подумать, что именно необходимо искать. Из предыдущего опыта разбора игровых данных в  <a href="/blog/37438/" title="New Ghostbusters Hard Mode Lua Script">Охотниках за привидениями</a>, я запомнил, что запись об уровне может иметь сложный формат, содержать вперемежку код логики игровых событий и данные. Так что, скорее всего, здесь тоже применяется какой-нибудь метод для сжатия игровых данных. Так что при анализе вверх от данных из рома к видеопамяти придется разобраться еще с функцией расшифровки данных и сэмулировать ему на каком-нибудь языке. Однако и возможность того, что данные лежат целым блоком, тоже есть. Так что стоит придумать способ отрисовки картинки уровня по какому-либо набору данных. Чтобы найти этот набор, можно взять любой адрес начала записи об уровне и попытаться разделить в нем код и данные. Правило визуального отделения данных и кодов - данные обладают когерентностью (соседние похожи между собой), коды - не обладают. Еще можно узнавать шаблоны кодов (зная коды команд, содержащих в операнде непосредственный адрес (jmp и lda с некоторыми типами адресаций) + код rts для конца функций, можно находить в коде адреса, и попробовать ассемблировать эти куски в дизассемблере). Вообщем, даже если начать рисовать смесью кодов и данных, то все равно можно найти какой-то осмысленный кусок и понять структуру. Так что дальше надо написать программу рисования и скормить ей все данные об уровне.<br>Как было сказано выше, для получения этих данных можно не лезть глубже, а начать вместо обратного просмотра прямой, отслеживая данные от момента считывания из РОМа в зону 47-82 ( набор ) до попадания прямо на экран.<br>Начинаем выныривать.<br>ROM:F71A .WORD $B6E3 ; адреса начала смещений уровней и бонусных зон (всего по 72, хотя под карту юзаются 59, дальше что-то еще).<br>ROM:F71C .WORD $B72B<br>ROM:F71E .WORD $B773<br>ROM:F720 .WORD $B7BB<br>ROM:F722 .WORD $B803<br>ROM:F724 .WORD $B84B<br>ROM:F726 .WORD $B893<br>ROM:F728 .WORD $B8DB<br>ROM:F72A .WORD $B923<br>ROM:F72C .WORD $B96B<br>ROM:F72E .WORD $BBAB<br>ROM:F730 .WORD $BB63<br>ROM:F732 .WORD $B9B3<br>ROM:F734 .WORD $B9FB<br>ROM:F736 .WORD $BA43<br>ROM:F738 .WORD $BA8B<br>ROM:F73A .WORD $BAD3<br>ROM:F73C .WORD $BB1B<br>ROM:F73E .WORD $BBAB  </p>
<p><strong>Шаг 0x08.</strong><br>Скрипт рисования. На питоне, для работы с изображениями нужна библиотека <a target="_blank" rel="noopener" href="http://www.pythonware.com/products/pil/">PIL</a>.  </p>
<figure class="shiki python"><div class="codeblock"><div class="code"><pre class="shiki dracula"><code><span class="line"><span style="color: #6272A4">#Класс инкапсулирует данные об одном тайле и позволяет сравнить тайлы с учетом палитры.</span></span>
<span class="line"><span style="color: #FF79C6">class</span><span style="color: #F8F8F2"> </span><span style="color: #8BE9FD">PpuSprite</span><span style="color: #F8F8F2">:</span></span>
<span class="line"><span style="color: #F8F8F2">   </span><span style="color: #FF79C6">def</span><span style="color: #F8F8F2"> </span><span style="color: #BD93F9">__init__</span><span style="color: #F8F8F2">(</span><span style="color: #BD93F9; font-style: italic">self</span><span style="color: #F8F8F2">, </span><span style="color: #FFB86C; font-style: italic">im</span><span style="color: #F8F8F2">):</span></span>
<span class="line"><span style="color: #F8F8F2">     </span><span style="color: #BD93F9; font-style: italic">self</span><span style="color: #F8F8F2">.image </span><span style="color: #FF79C6">=</span><span style="color: #F8F8F2"> im</span></span>
<span class="line"><span style="color: #F8F8F2">     </span><span style="color: #BD93F9; font-style: italic">self</span><span style="color: #F8F8F2">.imageData </span><span style="color: #FF79C6">=</span><span style="color: #F8F8F2"> im.getdata()</span></span>
<span class="line"><span style="color: #F8F8F2">     </span><span style="color: #BD93F9; font-style: italic">self</span><span style="color: #F8F8F2">.colorTable </span><span style="color: #FF79C6">=</span><span style="color: #F8F8F2"> im.getcolors()</span></span>
<span class="line"><span style="color: #F8F8F2">     </span><span style="color: #BD93F9; font-style: italic">self</span><span style="color: #F8F8F2">.colorTable.sort()</span></span>
<span class="line"><span style="color: #F8F8F2">     </span><span style="color: #BD93F9; font-style: italic">self</span><span style="color: #F8F8F2">.firstColorsPos </span><span style="color: #FF79C6">=</span><span style="color: #F8F8F2"> [] </span></span>
<span class="line"><span style="color: #F8F8F2">     </span><span style="color: #BD93F9; font-style: italic">self</span><span style="color: #F8F8F2">.calcFirstColorsPoses()</span></span>
<span class="line"><span style="color: #F8F8F2">     </span><span style="color: #BD93F9; font-style: italic">self</span><span style="color: #F8F8F2">.indexedData </span><span style="color: #FF79C6">=</span><span style="color: #F8F8F2"> []</span></span>
<span class="line"><span style="color: #F8F8F2">     </span><span style="color: #BD93F9; font-style: italic">self</span><span style="color: #F8F8F2">.prepareIndexedData()</span></span>
<span class="line"><span style="color: #F8F8F2"> </span></span>
<span class="line"><span style="color: #F8F8F2">   </span><span style="color: #FF79C6">def</span><span style="color: #F8F8F2"> </span><span style="color: #50FA7B">calcFirstColorsPoses</span><span style="color: #F8F8F2">(</span><span style="color: #BD93F9; font-style: italic">self</span><span style="color: #F8F8F2">):        </span></span>
<span class="line"><span style="color: #F8F8F2">     </span><span style="color: #FF79C6">for</span><span style="color: #F8F8F2"> _,colorInPalette </span><span style="color: #FF79C6">in</span><span style="color: #F8F8F2"> </span><span style="color: #BD93F9; font-style: italic">self</span><span style="color: #F8F8F2">.colorTable:</span></span>
<span class="line"><span style="color: #F8F8F2">       firstColorPos </span><span style="color: #FF79C6">=</span><span style="color: #F8F8F2"> </span><span style="color: #FF79C6">-</span><span style="color: #BD93F9">1</span></span>
<span class="line"><span style="color: #F8F8F2">       </span><span style="color: #FF79C6">for</span><span style="color: #F8F8F2"> color </span><span style="color: #FF79C6">in</span><span style="color: #F8F8F2"> </span><span style="color: #BD93F9; font-style: italic">self</span><span style="color: #F8F8F2">.imageData:</span></span>
<span class="line"><span style="color: #F8F8F2">         firstColorPos</span><span style="color: #FF79C6">+=</span><span style="color: #BD93F9">1</span></span>
<span class="line"><span style="color: #F8F8F2">         </span><span style="color: #FF79C6">if</span><span style="color: #F8F8F2"> color </span><span style="color: #FF79C6">==</span><span style="color: #F8F8F2"> colorInPalette:</span></span>
<span class="line"><span style="color: #F8F8F2">           </span><span style="color: #FF79C6">break</span></span>
<span class="line"><span style="color: #F8F8F2">       </span><span style="color: #BD93F9; font-style: italic">self</span><span style="color: #F8F8F2">.firstColorsPos.append((firstColorPos,colorInPalette))</span></span>
<span class="line"><span style="color: #F8F8F2">     </span><span style="color: #BD93F9; font-style: italic">self</span><span style="color: #F8F8F2">.firstColorsPos.sort()</span></span>
<span class="line"><span style="color: #F8F8F2"> </span></span>
<span class="line"><span style="color: #F8F8F2">   </span><span style="color: #FF79C6">def</span><span style="color: #F8F8F2"> </span><span style="color: #50FA7B">prepareIndexedData</span><span style="color: #F8F8F2">(</span><span style="color: #BD93F9; font-style: italic">self</span><span style="color: #F8F8F2">):</span></span>
<span class="line"><span style="color: #F8F8F2">     </span><span style="color: #FF79C6">def</span><span style="color: #F8F8F2"> </span><span style="color: #50FA7B">calcColorHash</span><span style="color: #F8F8F2">(</span><span style="color: #FFB86C; font-style: italic">c</span><span style="color: #F8F8F2">):</span></span>
<span class="line"><span style="color: #F8F8F2">       </span><span style="color: #FF79C6">return</span><span style="color: #F8F8F2"> c[</span><span style="color: #BD93F9">0</span><span style="color: #F8F8F2">]</span><span style="color: #FF79C6">&lt;&lt;</span><span style="color: #BD93F9">16</span><span style="color: #F8F8F2"> </span><span style="color: #FF79C6">|</span><span style="color: #F8F8F2"> c[</span><span style="color: #BD93F9">1</span><span style="color: #F8F8F2">]</span><span style="color: #FF79C6">&lt;&lt;</span><span style="color: #BD93F9">8</span><span style="color: #F8F8F2"> </span><span style="color: #FF79C6">|</span><span style="color: #F8F8F2"> c[</span><span style="color: #BD93F9">2</span><span style="color: #F8F8F2">]</span></span>
<span class="line"><span style="color: #F8F8F2">     colorHashes </span><span style="color: #FF79C6">=</span><span style="color: #F8F8F2"> </span><span style="color: #8BE9FD">map</span><span style="color: #F8F8F2"> (</span><span style="color: #FF79C6">lambda</span><span style="color: #F8F8F2"> </span><span style="color: #FFB86C; font-style: italic">colorRec</span><span style="color: #F8F8F2"> : calcColorHash(colorRec[</span><span style="color: #BD93F9">1</span><span style="color: #F8F8F2">]), </span><span style="color: #BD93F9; font-style: italic">self</span><span style="color: #F8F8F2">.firstColorsPos)</span></span>
<span class="line"><span style="color: #F8F8F2">     </span><span style="color: #FF79C6">for</span><span style="color: #F8F8F2"> pixel </span><span style="color: #FF79C6">in</span><span style="color: #F8F8F2"> </span><span style="color: #BD93F9; font-style: italic">self</span><span style="color: #F8F8F2">.imageData:</span></span>
<span class="line"><span style="color: #F8F8F2">       pixelHash </span><span style="color: #FF79C6">=</span><span style="color: #F8F8F2"> calcColorHash(pixel)</span></span>
<span class="line"><span style="color: #F8F8F2">       colorIndex </span><span style="color: #FF79C6">=</span><span style="color: #F8F8F2"> </span><span style="color: #FF79C6">-</span><span style="color: #BD93F9">1</span></span>
<span class="line"><span style="color: #F8F8F2">       </span><span style="color: #FF79C6">for</span><span style="color: #F8F8F2"> colorHash </span><span style="color: #FF79C6">in</span><span style="color: #F8F8F2"> colorHashes:</span></span>
<span class="line"><span style="color: #F8F8F2">         colorIndex </span><span style="color: #FF79C6">+=</span><span style="color: #BD93F9">1</span></span>
<span class="line"><span style="color: #F8F8F2">         </span><span style="color: #FF79C6">if</span><span style="color: #F8F8F2"> pixelHash </span><span style="color: #FF79C6">==</span><span style="color: #F8F8F2"> colorHash:</span></span>
<span class="line"><span style="color: #F8F8F2">           </span><span style="color: #FF79C6">break</span></span>
<span class="line"><span style="color: #F8F8F2">       </span><span style="color: #BD93F9; font-style: italic">self</span><span style="color: #F8F8F2">.indexedData.append(colorIndex)</span></span>
<span class="line"><span style="color: #F8F8F2"> </span></span>
<span class="line"><span style="color: #F8F8F2">   </span><span style="color: #FF79C6">def</span><span style="color: #F8F8F2"> </span><span style="color: #50FA7B">isEqual</span><span style="color: #F8F8F2">(</span><span style="color: #BD93F9; font-style: italic">self</span><span style="color: #F8F8F2">, </span><span style="color: #FFB86C; font-style: italic">otherPpuSprite</span><span style="color: #F8F8F2">):</span></span>
<span class="line"><span style="color: #F8F8F2">     </span><span style="color: #FF79C6">if</span><span style="color: #F8F8F2"> </span><span style="color: #8BE9FD">len</span><span style="color: #F8F8F2">(</span><span style="color: #BD93F9; font-style: italic">self</span><span style="color: #F8F8F2">.firstColorsPos) </span><span style="color: #FF79C6">!=</span><span style="color: #F8F8F2"> </span><span style="color: #8BE9FD">len</span><span style="color: #F8F8F2">(otherPpuSprite.firstColorsPos):</span></span>
<span class="line"><span style="color: #F8F8F2">       </span><span style="color: #FF79C6">return</span><span style="color: #F8F8F2"> </span><span style="color: #BD93F9">False</span></span>
<span class="line"><span style="color: #F8F8F2">     </span><span style="color: #FF79C6">for</span><span style="color: #F8F8F2"> fcp1, fcp2 </span><span style="color: #FF79C6">in</span><span style="color: #F8F8F2"> </span><span style="color: #8BE9FD">zip</span><span style="color: #F8F8F2">(</span><span style="color: #BD93F9; font-style: italic">self</span><span style="color: #F8F8F2">.firstColorsPos, otherPpuSprite.firstColorsPos):</span></span>
<span class="line"><span style="color: #F8F8F2">       </span><span style="color: #FF79C6">if</span><span style="color: #F8F8F2">  fcp1[</span><span style="color: #BD93F9">0</span><span style="color: #F8F8F2">]</span><span style="color: #FF79C6">!=</span><span style="color: #F8F8F2"> fcp2[</span><span style="color: #BD93F9">0</span><span style="color: #F8F8F2">]:</span></span>
<span class="line"><span style="color: #F8F8F2">         </span><span style="color: #FF79C6">return</span><span style="color: #F8F8F2"> </span><span style="color: #BD93F9">False</span></span>
<span class="line"><span style="color: #F8F8F2">     </span><span style="color: #FF79C6">if</span><span style="color: #F8F8F2"> </span><span style="color: #8BE9FD">len</span><span style="color: #F8F8F2">(</span><span style="color: #BD93F9; font-style: italic">self</span><span style="color: #F8F8F2">.colorTable) </span><span style="color: #FF79C6">!=</span><span style="color: #F8F8F2"> </span><span style="color: #8BE9FD">len</span><span style="color: #F8F8F2">(otherPpuSprite.colorTable):</span></span>
<span class="line"><span style="color: #F8F8F2">       </span><span style="color: #FF79C6">return</span><span style="color: #F8F8F2"> </span><span style="color: #BD93F9">False</span></span>
<span class="line"><span style="color: #F8F8F2">     </span><span style="color: #FF79C6">for</span><span style="color: #F8F8F2"> colorTableRec1, colorTableRec2 </span><span style="color: #FF79C6">in</span><span style="color: #F8F8F2"> </span><span style="color: #8BE9FD">zip</span><span style="color: #F8F8F2">(</span><span style="color: #BD93F9; font-style: italic">self</span><span style="color: #F8F8F2">.colorTable, otherPpuSprite.colorTable):</span></span>
<span class="line"><span style="color: #F8F8F2">       </span><span style="color: #FF79C6">if</span><span style="color: #F8F8F2"> colorTableRec1[</span><span style="color: #BD93F9">0</span><span style="color: #F8F8F2">] </span><span style="color: #FF79C6">!=</span><span style="color: #F8F8F2"> colorTableRec2[</span><span style="color: #BD93F9">0</span><span style="color: #F8F8F2">]:</span></span>
<span class="line"><span style="color: #F8F8F2">         </span><span style="color: #FF79C6">return</span><span style="color: #F8F8F2"> </span><span style="color: #BD93F9">False</span></span>
<span class="line"><span style="color: #F8F8F2">     </span><span style="color: #FF79C6">for</span><span style="color: #F8F8F2"> pixel1, pixel2 </span><span style="color: #FF79C6">in</span><span style="color: #F8F8F2"> </span><span style="color: #8BE9FD">zip</span><span style="color: #F8F8F2">(</span><span style="color: #BD93F9; font-style: italic">self</span><span style="color: #F8F8F2">.indexedData, otherPpuSprite.indexedData):</span></span>
<span class="line"><span style="color: #F8F8F2">       </span><span style="color: #FF79C6">if</span><span style="color: #F8F8F2"> pixel1</span><span style="color: #FF79C6">!=</span><span style="color: #F8F8F2">pixel2:</span></span>
<span class="line"><span style="color: #F8F8F2">         </span><span style="color: #FF79C6">return</span><span style="color: #F8F8F2"> </span><span style="color: #BD93F9">False</span></span>
<span class="line"><span style="color: #F8F8F2">     </span><span style="color: #FF79C6">return</span><span style="color: #F8F8F2"> </span><span style="color: #BD93F9">True</span></span></code></pre></div></div></figure>
<p>Дальше следует захватить из эмулятора блок с тайлами текущего уровня и распилить его на кусочки. FCEUXSP позволяет только посмотреть этот блок (View-&gt;Name Table View), но можно заскриншотить его и вырезать в любом графическом редакторе. Вот так выглядит блок для первого уровня:<br><img src="http://pics.livejournal.com/spiiin/pic/0001tbpp" alt><br>Только надо помнить, что эмулятор показывает блок увеличенным в 2 раза, поэтому надо в редакторе уменьшить его до размера 128x128, убедившись, что при уменьшении не используются никакие алгоритмы улучшения качества, так как нужно получить попиксельное совпадение. Дальше из этой картинки можно нарезать тайлы:  </p>
<figure class="shiki python"><div class="codeblock"><div class="code"><pre class="shiki dracula"><code><span class="line"><span style="color: #F8F8F2">imNameTable </span><span style="color: #FF79C6">=</span><span style="color: #F8F8F2"> Image.open(os.path.expanduser(</span><span style="color: #E9F284">&quot;</span><span style="color: #F1FA8C">~/desktop/jungleBook/jungleBookTable1.png</span><span style="color: #E9F284">&quot;</span><span style="color: #F8F8F2">))   </span><span style="color: #6272A4">#сохраненная таблица тайлов.</span></span>
<span class="line"><span style="color: #F8F8F2">imLevelTable </span><span style="color: #FF79C6">=</span><span style="color: #F8F8F2"> Image.open(os.path.expanduser(</span><span style="color: #E9F284">&quot;</span><span style="color: #F1FA8C">~/desktop/jungleBook/jungleBookLevel1.png</span><span style="color: #E9F284">&quot;</span><span style="color: #F8F8F2">))  </span><span style="color: #6272A4">#любой скриншот уровня, загружается для теста</span></span>
<span class="line"><span style="color: #F8F8F2">nameSize </span><span style="color: #FF79C6">=</span><span style="color: #F8F8F2"> imNameTable.size</span></span>
<span class="line"><span style="color: #F8F8F2">levelSize </span><span style="color: #FF79C6">=</span><span style="color: #F8F8F2"> imLevelTable.size</span></span>
<span class="line"><span style="color: #F8F8F2">nameTable </span><span style="color: #FF79C6">=</span><span style="color: #F8F8F2"> [imNameTable.crop((x,y,x</span><span style="color: #FF79C6">+</span><span style="color: #BD93F9">8</span><span style="color: #F8F8F2">,y</span><span style="color: #FF79C6">+</span><span style="color: #BD93F9">8</span><span style="color: #F8F8F2">)) </span><span style="color: #FF79C6">for</span><span style="color: #F8F8F2"> y,x </span><span style="color: #FF79C6">in</span><span style="color: #F8F8F2"> itertools.product(xrange(</span><span style="color: #BD93F9">0</span><span style="color: #F8F8F2">,nameSize[</span><span style="color: #BD93F9">1</span><span style="color: #F8F8F2">],</span><span style="color: #BD93F9">8</span><span style="color: #F8F8F2">),xrange(</span><span style="color: #BD93F9">0</span><span style="color: #F8F8F2">,nameSize[</span><span style="color: #BD93F9">0</span><span style="color: #F8F8F2">],</span><span style="color: #BD93F9">8</span><span style="color: #F8F8F2">))]</span></span>
<span class="line"><span style="color: #F8F8F2">levelTable </span><span style="color: #FF79C6">=</span><span style="color: #F8F8F2"> [imLevelTable.crop((x,y,x</span><span style="color: #FF79C6">+</span><span style="color: #BD93F9">8</span><span style="color: #F8F8F2">,y</span><span style="color: #FF79C6">+</span><span style="color: #BD93F9">8</span><span style="color: #F8F8F2">)) </span><span style="color: #FF79C6">for</span><span style="color: #F8F8F2"> y,x </span><span style="color: #FF79C6">in</span><span style="color: #F8F8F2"> itertools.product(xrange(</span><span style="color: #BD93F9">0</span><span style="color: #F8F8F2">,levelSize[</span><span style="color: #BD93F9">1</span><span style="color: #F8F8F2">],</span><span style="color: #BD93F9">8</span><span style="color: #F8F8F2">),xrange(</span><span style="color: #BD93F9">0</span><span style="color: #F8F8F2">,levelSize[</span><span style="color: #BD93F9">0</span><span style="color: #F8F8F2">],</span><span style="color: #BD93F9">8</span><span style="color: #F8F8F2">))]</span></span>
<span class="line"><span style="color: #F8F8F2">ppuSpriteMemTable </span><span style="color: #FF79C6">=</span><span style="color: #F8F8F2"> </span><span style="color: #8BE9FD">map</span><span style="color: #F8F8F2"> (</span><span style="color: #FF79C6">lambda</span><span style="color: #F8F8F2"> </span><span style="color: #FFB86C; font-style: italic">im</span><span style="color: #F8F8F2">: PpuSprite(im),nameTable) </span></span>
<span class="line"><span style="color: #F8F8F2">ppuSpriteLvlTable </span><span style="color: #FF79C6">=</span><span style="color: #F8F8F2"> </span><span style="color: #8BE9FD">map</span><span style="color: #F8F8F2"> (</span><span style="color: #FF79C6">lambda</span><span style="color: #F8F8F2"> </span><span style="color: #FFB86C; font-style: italic">im</span><span style="color: #F8F8F2">: PpuSprite(im),levelTable)</span></span></code></pre></div></div></figure>
<p>Функция отрисовки по массиву тайлов (принимает линейный массив данных, таблицу спрайтов, размер уровня и флажок, построчно или постолбцово рисовать, возврашает экземляр класс PIL Image):  </p>
<figure class="shiki python"><div class="codeblock"><div class="code"><pre class="shiki dracula"><code><span class="line"><span style="color: #FF79C6">def</span><span style="color: #F8F8F2"> </span><span style="color: #50FA7B">drawLevelFromData</span><span style="color: #F8F8F2">(</span><span style="color: #FFB86C; font-style: italic">levelArray</span><span style="color: #F8F8F2">, </span><span style="color: #FFB86C; font-style: italic">ppuSpriteTable</span><span style="color: #F8F8F2">, </span><span style="color: #FFB86C; font-style: italic">size</span><span style="color: #F8F8F2">, </span><span style="color: #FFB86C; font-style: italic">vertical</span><span style="color: #F8F8F2"> </span><span style="color: #FF79C6">=</span><span style="color: #F8F8F2"> </span><span style="color: #BD93F9">False</span><span style="color: #F8F8F2">):</span></span>
<span class="line"><span style="color: #F8F8F2">  w,h </span><span style="color: #FF79C6">=</span><span style="color: #F8F8F2"> size</span></span>
<span class="line"><span style="color: #F8F8F2">  im </span><span style="color: #FF79C6">=</span><span style="color: #F8F8F2"> Image.new(</span><span style="color: #E9F284">&quot;</span><span style="color: #F1FA8C">RGBA</span><span style="color: #E9F284">&quot;</span><span style="color: #F8F8F2">, (w</span><span style="color: #FF79C6">*</span><span style="color: #BD93F9">8</span><span style="color: #F8F8F2">,h</span><span style="color: #FF79C6">*</span><span style="color: #BD93F9">8</span><span style="color: #F8F8F2">))</span></span>
<span class="line"><span style="color: #F8F8F2">  </span><span style="color: #FF79C6">for</span><span style="color: #F8F8F2"> i </span><span style="color: #FF79C6">in</span><span style="color: #F8F8F2"> xrange(</span><span style="color: #8BE9FD">len</span><span style="color: #F8F8F2">(levelArray)):</span></span>
<span class="line"><span style="color: #F8F8F2">    </span><span style="color: #FF79C6">if</span><span style="color: #F8F8F2"> vertical:</span></span>
<span class="line"><span style="color: #F8F8F2">      x,y </span><span style="color: #FF79C6">=</span><span style="color: #F8F8F2"> i</span><span style="color: #FF79C6">/</span><span style="color: #F8F8F2">h, i</span><span style="color: #FF79C6">%</span><span style="color: #F8F8F2">h</span></span>
<span class="line"><span style="color: #F8F8F2">    </span><span style="color: #FF79C6">else</span><span style="color: #F8F8F2">:</span></span>
<span class="line"><span style="color: #F8F8F2">      x,y </span><span style="color: #FF79C6">=</span><span style="color: #F8F8F2"> i</span><span style="color: #FF79C6">%</span><span style="color: #F8F8F2">w, i</span><span style="color: #FF79C6">/</span><span style="color: #F8F8F2">w</span></span>
<span class="line"><span style="color: #F8F8F2">    ind </span><span style="color: #FF79C6">=</span><span style="color: #F8F8F2"> levelArray[i]</span></span>
<span class="line"><span style="color: #F8F8F2">    </span><span style="color: #FF79C6">if</span><span style="color: #F8F8F2"> (ind</span><span style="color: #FF79C6">!=-</span><span style="color: #BD93F9">1</span><span style="color: #F8F8F2">):</span></span>
<span class="line"><span style="color: #F8F8F2">      im.paste(ppuSpriteTable[ind].image, (x</span><span style="color: #FF79C6">*</span><span style="color: #BD93F9">8</span><span style="color: #F8F8F2">,y</span><span style="color: #FF79C6">*</span><span style="color: #BD93F9">8</span><span style="color: #F8F8F2">,x</span><span style="color: #FF79C6">*</span><span style="color: #BD93F9">8</span><span style="color: #FF79C6">+</span><span style="color: #BD93F9">8</span><span style="color: #F8F8F2">,y</span><span style="color: #FF79C6">*</span><span style="color: #BD93F9">8</span><span style="color: #FF79C6">+</span><span style="color: #BD93F9">8</span><span style="color: #F8F8F2">))</span></span>
<span class="line"><span style="color: #F8F8F2">  </span><span style="color: #FF79C6">return</span><span style="color: #F8F8F2"> im</span></span></code></pre></div></div></figure>
<p>Чтобы проверить программу рисования и корректность сравнения по индексированным цветам, превратим скриншот уровня в данные и отдадим этой функции.  </p>
<figure class="shiki python"><div class="codeblock"><div class="code"><pre class="shiki dracula"><code><span class="line"><span style="color: #FF79C6">def</span><span style="color: #F8F8F2"> </span><span style="color: #50FA7B">findFirstPicIndex</span><span style="color: #F8F8F2">(</span><span style="color: #FFB86C; font-style: italic">sprite</span><span style="color: #F8F8F2">, </span><span style="color: #FFB86C; font-style: italic">ppuSpriteTable</span><span style="color: #F8F8F2">):</span></span>
<span class="line"><span style="color: #F8F8F2">  index </span><span style="color: #FF79C6">=</span><span style="color: #F8F8F2"> </span><span style="color: #FF79C6">-</span><span style="color: #BD93F9">1</span></span>
<span class="line"><span style="color: #F8F8F2">  </span><span style="color: #FF79C6">for</span><span style="color: #F8F8F2"> ppuSprite </span><span style="color: #FF79C6">in</span><span style="color: #F8F8F2"> ppuSpriteTable:</span></span>
<span class="line"><span style="color: #F8F8F2">    index</span><span style="color: #FF79C6">+=</span><span style="color: #BD93F9">1</span></span>
<span class="line"><span style="color: #F8F8F2">    </span><span style="color: #FF79C6">if</span><span style="color: #F8F8F2"> ppuSprite.isEqual(sprite):</span></span>
<span class="line"><span style="color: #F8F8F2">      </span><span style="color: #FF79C6">return</span><span style="color: #F8F8F2"> index</span></span>
<span class="line"><span style="color: #F8F8F2">  </span><span style="color: #FF79C6">return</span><span style="color: #F8F8F2"> </span><span style="color: #FF79C6">-</span><span style="color: #BD93F9">1</span></span>
<span class="line"><span style="color: #F8F8F2"> </span></span>
<span class="line"><span style="color: #FF79C6">def</span><span style="color: #F8F8F2"> </span><span style="color: #50FA7B">makeLevelMap</span><span style="color: #F8F8F2">(</span><span style="color: #FFB86C; font-style: italic">mem</span><span style="color: #F8F8F2">, </span><span style="color: #FFB86C; font-style: italic">lev</span><span style="color: #F8F8F2">):</span></span>
<span class="line"><span style="color: #F8F8F2">  levTable </span><span style="color: #FF79C6">=</span><span style="color: #F8F8F2"> []</span></span>
<span class="line"><span style="color: #F8F8F2">  </span><span style="color: #FF79C6">for</span><span style="color: #F8F8F2"> l </span><span style="color: #FF79C6">in</span><span style="color: #F8F8F2"> lev:</span></span>
<span class="line"><span style="color: #F8F8F2">    levTable.append(findFirstPicIndex(l, mem))</span></span>
<span class="line"><span style="color: #F8F8F2">  </span><span style="color: #FF79C6">return</span><span style="color: #F8F8F2"> levTable</span></span>
<span class="line"><span style="color: #F8F8F2"> </span></span>
<span class="line"><span style="color: #F8F8F2">mapLevel </span><span style="color: #FF79C6">=</span><span style="color: #F8F8F2"> makeLevelMap(ppuSpriteMemTable, ppuSpriteLvlTable)</span></span>
<span class="line"><span style="color: #F8F8F2">drawLevelFromData(mapLevel, sprites,(</span><span style="color: #BD93F9">WIDTH</span><span style="color: #F8F8F2">,</span><span style="color: #BD93F9">HEIGHT</span><span style="color: #F8F8F2">),</span><span style="color: #BD93F9">True</span><span style="color: #F8F8F2">).show()</span></span></code></pre></div></div></figure>
<p>На выходе можно увидеть уровень, выглядящий примерно как рендер Матрицы на компьютере с недостаточной мощностью:<br><img src="http://pics.livejournal.com/spiiin/pic/0001w7zd" alt>  </p>
<p><strong>Шаг 0x09.</strong><br>Дальше я попытался отрисовать данные уровня разными способами, ничего интересного не получил, и понял, что надо все-таки еще искать функцию-комбинатор, которые будет определять, как данные из набора попадают на экран . Набор смещений 47-82 для первого уровня по адресу $B6E3<br>A139 A739 DDC8 DDC8 DBF4<br>DC59 AA49 AAC0 DCBE DD23<br>AB37 ABAE D974 D9F4 A7C9<br>A849 DA74 DAF4 A8C9 A949<br>DB74 A9C9 BBF3 A825 A795<br>A765 A764 A766 A7F5 A7C5<br>Точка остановки на чтение этих значений. $8D62 в новом банке памяти (надо сделать еще один дамп), анализ кода там:<br>берем 4 бита шагов (2 горизонт, 2 вертикаль) и используем их как смещение от адреса DDA8<br>ROM:DDA8 .WORD $4F4F ; idle вторая часть (адреса из набора )<br>ROM:DDAA .WORD $5151<br>ROM:DDAC .WORD $4F4F<br>ROM:DDAE .WORD $5151<br>ROM:DDB0 .WORD $5757<br>ROM:DDB2 .WORD $5959<br>ROM:DDB4 .WORD $5757<br>ROM:DDB6 .WORD $5959<br>и переносим их в 8b-8e<br>потом повторно берем из DDB8 и переносим в 9b-9e:<br>ROM:DDB8 .WORD $615F ; idle вторая часть(адреса из набора )<br>ROM:DDBA .WORD $615F<br>ROM:DDBC .WORD $6967<br>ROM:DDBE .WORD $6967<br>ROM:DDC0 .WORD $615F<br>ROM:DDC2 .WORD $615F<br>ROM:DDC4 .WORD $6967<br>ROM:DDC6 .WORD $6967  </p>
<p>Это массив направлений , где хранится по 4 значения адресов из набора , которые будут скопированы по адресу предэкран (назовем так адреса 9B-9E и 8B-8E, потому что там лежат адреса массивов, из которых будут считаны номеры тайлов, попадающих в зону экрана $40E-$423).  </p>
<a href="/blog/21742/" title="Уровни Jungle Book [NES]. Часть 2">Продолжение</a>
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"Ov23liG1mZbiQOIdi91X","clientSecret":"e05812685eb741a752982b89dcf6f5b58dc10251","repo":"spiiin.github.io","owner":"spiiin","admin":["spiiin"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script></div></article><div class="pagination"><a class="pagination__link pagination__prev" href="/blog/21742/">Позже</a><a class="pagination__link pagination__next" href="/blog/61505/">Раньше</a></div></main><footer class="footer metadata"><p class="footer__text">© 2024 spiiin</p><p class="footer__text">Powered by <a class="footer__text__link" href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a class="footer__text__link" href="https://pages.github.com/" target="_blank">Github Page</a></p></footer></div><!-- hexo injector body_end start -->
  <script>
  const CODE_CONFIG = {
    beautify: undefined,
    highlightCopy: undefined,
    highlightLang: undefined,
    highlightHeightLimit: undefined,
    isHighlightShrink: undefined,
    copy: {
      success: 'undefined',
      error: 'undefined',
      noSupport: 'undefined',
    }
  };
  console.log(
    `%c hexo-shiki-plugin %c v1.0.27 %c https://github.com/nova1751/hexo-shiki-plugin`,
    "color: #fff; background: #5f5f5f",
    "color: #fff; background: #80c8f8",
    ""
  );
  </script>
  <!-- hexo injector body_end end --></body></html>