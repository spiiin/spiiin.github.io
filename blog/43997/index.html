<!DOCTYPE html><html lang="ru"><head><meta charset="UTF-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Spiiin's blog | Squirrel tips - 3</title><meta name="description" content=""><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=PT+Serif&amp;display=swap"><link rel="stylesheet" href="/css/highlights/darkula.css"><link rel="stylesheet" href="/css/main.css"><link rel="search" type="application/opensearchdescription+xml" href="http://spiiin.github.io/atom.xml" title="Spiiin's blog"><script>(function (i, s, o, g, r, a, m) {
  i['GoogleAnalyticsObject'] = r;
  i[r] = i[r] || function () {
    (i[r].q = i[r].q || []).push(arguments)
  }, i[r].l = 1 * new Date();
  a = s.createElement(o),
    m = s.getElementsByTagName(o)[0];
  a.async = 1;
  a.src = g;
  m.parentNode.insertBefore(a, m)
})(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');
ga('create', 'UA-00000000-0', 'auto');
ga('send', 'pageview');</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Spiiin's blog" type="application/atom+xml">
</head><body><div class="container"><header class="main-header"><h1 class="main-header__title uplize"><a class="main-header__title__link" href="/"><img class="header-image" src="/images/favicon.png" width="36" height="36">Spiiin's blog</a></h1><nav class="main-header__nav"><ul class="main-nav"><li class="main-nav__list"><a class="main-nav__list__link" href="/" target="_self">HOME</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/archives/" target="_self">ARCHIVE</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/tags/meta" target="_self">TAGS</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/blog/1" target="_self">ABOUT</a></li></ul></nav></header><main class="container__wrapper"><div class="pagination"><a class="pagination__link pagination__prev" href="/blog/64916/">Позже</a><a class="pagination__link pagination__next" href="/blog/5060/">Раньше</a></div><article class="article post"><h3 class="article__title">Squirrel tips - 3</h3><div class="article__date metadata"><div class="post-info">2009/09/16</div></div><div class="article__tags metadata">Tags:
<a class="article__tags__link metadata" href="/tags/squirell/">squirell</a></div><div class="article__body"><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p><code>Squirrel</code> простой, как 5 копеек, язык. Но документации по нему очень мало. Официальный <a href="http://squirrel-lang.org/doc/squirrel2.html" target="_blank" rel="noopener">мануал</a>, и полупустые <a href="http://wiki.squirrel-lang.org/default.aspx/SquirrelWiki/SquirrelWiki.html" target="_blank" rel="noopener">вики</a> и <a href="http://squirrel-lang.org/forums/default.aspx" target="_blank" rel="noopener">форум</a> - все, что удалось найти (ну и исходный текст, если его считать за документацию). Поэтому я себе и пишу такие типсы о том, что не указано явно в доках.  </p>
<p>Есть вот в нем такой “спецэффект”, в принципе, логичный, но о котором следует помнить - если в классе имеется слот-значение, то инициализировать его можно прямо в теле класса, а не в конструкторе, все экземпляры получат копию этого слота. А если так сделать со слотом-ссылкой, то все экземпляры получат по копии этой ссылки, указывающей на один и тот же созданный объект. Поэтому слоты-ссылки стоит инициализировать в конструкторе. На примере:  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  val = <span class="string">"hello"</span>              <span class="comment">//числа, строковые константы и члены перечислений - значения</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">a1 &lt;- A()</span><br><span class="line">a2 &lt;- A()</span><br><span class="line">a2.val = <span class="string">" world!"</span>            <span class="comment">//a2.val изменилось, a1.val не изменилось</span></span><br><span class="line">print (a1.val + a2.val);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  wrong = &#123;val = <span class="string">"hello"</span>&#125;            <span class="comment">// ссылочный тип, если создать здесь экземпляр таблицы, она будет "шариться" всеми экземплярами</span></span><br><span class="line">  right = <span class="literal">null</span>                       <span class="comment">// не спешим создавать таблицу</span></span><br><span class="line">  <span class="keyword">constructor</span>()</span><br><span class="line">  &#123;</span><br><span class="line">    right = &#123;val = <span class="string">"hello"</span>&#125;          <span class="comment">// создаем свою копию таблицы для каждого экземпляра класса</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">b1 &lt;- B()</span><br><span class="line">b2 &lt;- B()</span><br><span class="line">print (b1.wrong == b2.wrong)         <span class="comment">//true,  ссылки указывают на одну и ту же таблицу</span></span><br><span class="line">print (b1.right == b2.right)         <span class="comment">//false, у каждого объекта своя таблица</span></span><br><span class="line"> </span><br><span class="line">b2.wrong.val = <span class="string">" world!"</span>             <span class="comment">//b1.wrong.val ссылается сюда же... </span></span><br><span class="line">b2.right.val = <span class="string">" world!"</span></span><br><span class="line">print (b1.wrong.val + b2.wrong.val)  <span class="comment">//не вышло :(</span></span><br><span class="line">print (b1.right.val + b2.right.val)  <span class="comment">//ура!</span></span><br></pre></td></tr></table></figure>
<p>Ну и еще штука, основанная на разнице между значениями и ссылками. Свободные переменные, переданные в функцию, вычисляются в момент определения функции. Т.е. если передать переменную-значение, то создастся ее копия и связи с исходной переменной не будет:  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">a &lt;- <span class="number">10</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span> (<span class="params"></span>) : (<span class="params">a</span>) </span>&#123; print(a) &#125; a = <span class="number">5</span> f(); <span class="comment">//выведет 10</span></span><br></pre></td></tr></table></figure>
<p>Если все же нужно передать значение в функцию, можно завернуть его в класс или таблицу и воспользоваться одним из двух способов связи - передать таблицу как свободную переменную (как было описано выше) или привязать ее как окружение для функции. Второй способ основан на том, что функция когда встречает неизвестное ей имя переменной, она ищет его в таблице this. Эту таблицу можно заменить на свою, используя функцию bindenv. Разница между двумя способами заключается в том, что в первом случае ссылка на таблицу копируется в скрытую переменную, а во втором используется слабая ссылка на таблицу. Это означает, что во втором случае когда исходная таблица будет удалена, функция перестанет работать! На примере:  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">t &lt;- &#123; a = <span class="string">"vaaar!"</span> &#125;                           <span class="comment">//кладем нужную переменную в таблицу</span></span><br><span class="line"> </span><br><span class="line">f1  &lt;- <span class="function"><span class="keyword">function</span> (<span class="params"></span>) : (<span class="params">t</span>)  </span>&#123; print (t.a) &#125;   </span><br><span class="line">f2  &lt;- <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; print(a) &#125;.bindenv(t)      <span class="comment">//эта строка эквивалентна такой записи : function f2 ()  &#123; print (a) &#125;</span></span><br><span class="line">                                                <span class="comment">//                                       f2 = f2.binenv(t)</span></span><br><span class="line"> </span><br><span class="line">f1()                                            <span class="comment">//vaaar!</span></span><br><span class="line">f2()                                            <span class="comment">//vaaar!</span></span><br><span class="line">t.a = <span class="string">"nyaaa!"</span>                                  <span class="comment">//теперь попробуем так</span></span><br><span class="line">f1()                                            <span class="comment">//nyaaa!</span></span><br><span class="line">f2()                                            <span class="comment">//nyaaa!</span></span><br><span class="line"><span class="keyword">delete</span> t                                        <span class="comment">//и вот так</span></span><br><span class="line">f1()                                            <span class="comment">//nyaaa!</span></span><br><span class="line">f2()                                            <span class="comment">//упс, сломалось, t больше не существует и f2 теперь ищет переменную a в глобальном пространстве имен</span></span><br></pre></td></tr></table></figure>
<p>В <code>Squirrel</code>‘е для таблицы можно указать родителя, в котором будут искаться слоты, если их нету в самой таблице. Такой родитель будет называется делегатом. За счет этого таблицы становятся похожи на классы. Отличия состоят только в том, что таблицы нельзя инстанциировать, в них нельзя не будут работать метаметоды (но в таблицах-делегатах будут) и для них можно сменить делегата-родителя в любой момент. Еще я сильно пытался сделать что-то похожее на множественное наследование, которого в языке нету.  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123; a = <span class="number">1</span> &#125;                             <span class="comment">//классический способ определения для классов</span></span><br><span class="line">a &lt;- &#123;a = <span class="number">1</span>&#125;                                  <span class="comment">//и таблиц</span></span><br><span class="line"> </span><br><span class="line">B &lt;- <span class="class"><span class="keyword">class</span> </span>&#123; b = <span class="number">2</span>&#125;                           <span class="comment">//синтаксический сахарок</span></span><br><span class="line">b &lt;- &#123; b = <span class="number">2</span> &#125;</span><br><span class="line"> </span><br><span class="line">C &lt;- <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">B</span> </span>&#123; c = <span class="number">3</span> &#125;                <span class="comment">//наследование</span></span><br><span class="line">с &lt;- delegate b : &#123; c = <span class="number">3</span> &#125;                   <span class="comment">//и делегирование</span></span><br><span class="line"> </span><br><span class="line">d &lt;- delegate a : delegate b :</span><br><span class="line">  delegate c : &#123;d = <span class="number">4</span>&#125;                        <span class="comment">//интерпретатор пропускает и такое, но настоящим делегатом будет только первый из списка, это видимо ошибка парсера</span></span><br><span class="line">E &lt;- <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">class</span> </span>&#123;e1 = <span class="number">10</span>&#125;  &#123;e2 = <span class="number">11</span>&#125; <span class="comment">//а вот подставить определение класса в том месте, где требуется его имя можно </span></span><br><span class="line">e &lt;- delegate delegate delegate </span><br><span class="line">     &#123;z = <span class="number">3</span> &#125; : a  : &#123;x = <span class="number">1</span>&#125;  : &#123;&#125;            <span class="comment">//и определить таблицу тоже - цепочки делегатов выглядят прикольно =(^_^)=</span></span><br></pre></td></tr></table></figure>
<p>Можно, собственно вообще вместо наследования просто перекидывать в класс нужные слоты от какого-нибудь объекта, в том числе и задаваемого на лету, “<a href="http://ru.wikipedia.org/wiki/Mixin" target="_blank" rel="noopener">подмешивая</a>“ его свойства:  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mixin</span> (<span class="params">clas, mix</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  foreach (slot,val <span class="keyword">in</span> mix)</span><br><span class="line">    clas[slot] &lt;- val</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line">mixin (A , &#123;f = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) <span class="title">print</span> (<span class="params"><span class="string">"hello"</span></span>) &#125; )</span></span><br><span class="line"><span class="function"><span class="title">A</span>.<span class="title">f</span>(<span class="params"></span>);   //<span class="title">print</span> "<span class="title">hello</span>"</span></span><br></pre></td></tr></table></figure>
<p>Если еще отслеживать список имен добавленных методов, можно даже “отмешать” свойства обратно, единственное ограничение - делать это можно только до первого создания экземпляра класса, зато таблицы можно модифицировать как душе угодно.</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script></div></article><div class="pagination"><a class="pagination__link pagination__prev" href="/blog/64916/">Позже</a><a class="pagination__link pagination__next" href="/blog/5060/">Раньше</a></div></main><footer class="footer metadata"><p class="footer__text">© 2023 spiiin</p><p class="footer__text">Powered by <a class="footer__text__link" href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a class="footer__text__link" href="https://pages.github.com/" target="_blank">Github Page</a></p></footer></div></body></html>