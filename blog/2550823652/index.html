<!DOCTYPE html><html lang="ru"><head><meta charset="UTF-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Spiiin's blog | Итераторы, колстеки, корутины</title><meta name="description" content=""><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=PT+Serif&amp;display=swap"><link rel="stylesheet" href="/css/highlights/darkula.css"><link rel="stylesheet" href="/css/main.css"><link rel="search" type="application/opensearchdescription+xml" href="http://spiiin.github.io/atom.xml" title="Spiiin's blog"><script>(function (i, s, o, g, r, a, m) {
  i['GoogleAnalyticsObject'] = r;
  i[r] = i[r] || function () {
    (i[r].q = i[r].q || []).push(arguments)
  }, i[r].l = 1 * new Date();
  a = s.createElement(o),
    m = s.getElementsByTagName(o)[0];
  a.async = 1;
  a.src = g;
  m.parentNode.insertBefore(a, m)
})(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');
ga('create', 'UA-00000000-0', 'auto');
ga('send', 'pageview');</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-shiki-plugin@latest/lib/codeblock.css">
<style>:root{--hl-color:#abb2bf;--hl-bg:#282c34;--hltools-bg:#21252b;--hltools-color:#bbbbbc;--hlnumber-bg:#282c34;--hlnumber-color:#495162;--hlscrollbar-bg:#373c47;--hlexpand-bg:linear-gradient(180deg,rgba(40,44,52,0.1),rgba(40,44,52,0.9))}</style><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Spiiin's blog" type="application/atom+xml">
</head><body><div class="container"><header class="main-header"><h1 class="main-header__title uplize"><a class="main-header__title__link" href="/"><img class="header-image" src="/images/favicon.png" width="36" height="36">Spiiin's blog</a></h1><nav class="main-header__nav"><ul class="main-nav"><li class="main-nav__list"><a class="main-nav__list__link" href="/" target="_self">HOME</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/archives/" target="_self">ARCHIVE</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/tags/meta" target="_self">TAGS</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/blog/1" target="_self">ABOUT</a></li></ul></nav></header><main class="container__wrapper"><div class="pagination"><a class="pagination__link pagination__prev" href="/blog/3774050611/">Позже</a><a class="pagination__link pagination__next" href="/blog/1067581840/">Раньше</a></div><article class="article post"><h3 class="article__title">Итераторы, колстеки, корутины</h3><div class="article__date metadata"><div class="post-info">2022/08/01</div></div><div class="article__tags metadata">Tags:
<a class="article__tags__link metadata" href="/tags/cpp/">cpp</a><a class="article__tags__link metadata" href="/tags/dev/">dev</a><a class="article__tags__link metadata" href="/tags/link/">link</a><a class="article__tags__link metadata" href="/tags/longread/">longread</a><a class="article__tags__link metadata" href="/tags/dascript/">dascript</a></div><div class="article__body"><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Малость нырнул в кучу статей про асинхронность и корутины в различных языках. Напишу небольшую выдержку (с переводами примеров на <code>daScript</code> там, где актуально), о том, что корутины можно начинать рассматривать как расширение возможностей итераторов и колбеков (функторов), а не с более часто встречающихся генерации последовательностей или реализации паттерна “продюсер-консюмер”.</p>
<p>Ссылки<br> [1] <a target="_blank" rel="noopener" href="http://journal.stuffwithstuff.com/2013/01/13/iteration-inside-and-out/">Iterators Inside and Out</a> - обзор итераторов в различных языках, для каких задач удобны<br> [2] <a target="_blank" rel="noopener" href="http://journal.stuffwithstuff.com/2013/02/24/iteration-inside-and-out-part-2/">Iterators Inside and Out. Part 2</a> - подводка к тому, что абстракция итераторов требует примитивов работы с параллельным кодом<br> [3] <a target="_blank" rel="noopener" href="http://journal.stuffwithstuff.com/2013/04/17/well-done/">Well Done: A Sentinel Value</a> - каналы<br> [4] <a target="_blank" rel="noopener" href="https://users.livejournal.com/-winnie/421941.html">Итератор: внутрь и наружу</a> - совсем краткий вывод из статей [1] и [2], и дополнения в комментариях<br> [5] <a target="_blank" rel="noopener" href="https://fprog.ru/lib/ferguson-dwight-call-cc-patterns/">Паттерны использования «call with current continuation»</a> - перевод статьи про паттерны использования call with continuations в Lisp, среди которых — реализация корутин<br> [6] Журнал “Практика функционального программирования”. Статья “Продолжения на практике” - пример “выворачивания” внутреннего итератора во внешний<br> [7] <a target="_blank" rel="noopener" href="https://yehudakatz.com/2010/02/07/the-building-blocks-of-ruby/">The building blocks of Ruby</a> - особенности блоков в Ruby, нелокальные возвраты из итераторов<br> [8] <a target="_blank" rel="noopener" href="https://okmij.org/ftp/Scheme/enumerators-callcc.html">General ways to traverse collections</a> - обзоры способов обхода коллекций, примеры на Scheme. Итератор с памятью (стейт-машина) в функциональном стиле<br> [9] <a target="_blank" rel="noopener" href="https://okmij.org/ftp/papers/LL3-collections-enumerators.txt">Towards the best collection API</a> - пример “выворачивания” итераторов на Scheme<br> [10] <a target="_blank" rel="noopener" href="https://legacy.cs.indiana.edu/~sabry/papers/yield.pdf">Yield: Mainstream Delimited Continuations</a> - yield в разных языках. <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Delimited_continuation">Delimited continuations</a><br> [11] <a target="_blank" rel="noopener" href="http://pllab.is.ocha.ac.jp/~asai/cw2011tutorial/main-e.pdf">Introduction to Programming with Shift and Reset</a> - операторы shift и reset<br> [12] <a target="_blank" rel="noopener" href="https://probablydance.com/2015/01/11/ideas-for-a-programming-language-part-2-a-more-liberal-call-stack/">Ideas for a Programming Language Part 2: A more liberal call stack</a> - про недостатки абстракции стека вызовов<br> [13] <a target="_blank" rel="noopener" href="https://www.chiark.greenend.org.uk/~sgtatham/coroutines.html">Coroutines in C</a> - классическая статья про проблемы реализации корутин в C. Трюк с реализацией корутин с помощью <a target="_blank" rel="noopener" href="https://ru.wikipedia.org/wiki/%D0%9C%D0%B5%D1%82%D0%BE%D0%B4_%D0%94%D0%B0%D1%84%D1%84%D0%B0">метода Даффа</a><br> [14] <a target="_blank" rel="noopener" href="https://probablydance.com/2021/10/31/c-coroutines-do-not-spark-joy">C++ Coroutines Do Not Spark Joy</a> - обзор реализации корутин в стандарте C++<br> [15] <a target="_blank" rel="noopener" href="https://www.scs.stanford.edu/~dm/blog/c++-coroutines.html#the-promise-object">My tutorial and take on C++20 coroutines</a> - ещё одна статья про корутины в C++ 20, трюк с хранением результата корутины на стеке через Promise Object<br> [16] <a target="_blank" rel="noopener" href="https://github.com/lewissbaker/cppcoro">CppCoro - A coroutine library for C++</a> - библиотека обёрток над корутинами из стандарта C++<br> [17] <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=8C8NnE1Dg4A">CppCon 2016: Gor Nishanov “C++ Coroutines: Under the covers”</a> - доклад про реализацию корутин в стандарте C++, особенности реализации генерируемого кода в LLVM, возможности по оптимизации кода на уровне LLVM. Хорошо для понимания того, когда возможна элиминация выделения памяти. <a target="_blank" rel="noopener" href="https://llvm.org/docs/Coroutines.html">LLVM coroutines</a> - интринсики для корутины в LLVM.<br> [18] <a target="_blank" rel="noopener" href="https://probablydance.com/2013/02/20/handmade-coroutines-for-windows/">Handmade Coroutines for Windows</a> - альтернативные реализации корутин для windows. Раз C++ не даёт прямого доступа к указателю на стек, можно подменить его на ассемблере<br> [19] <a target="_blank" rel="noopener" href="https://probablydance.com/2012/11/18/implementing-coroutines-with-ucontext/">Implementing coroutines with ucontext</a> - реализация корутин через posix ucontext<br> [20] <a target="_blank" rel="noopener" href="https://www.boost.org/doc/libs/1_79_0/libs/context/doc/html/index.html">Boost::Context</a> - реализации переключения контекста из boost. Используют обёртки над posix или платформенные заголовки для переключения контекста, или <a target="_blank" rel="noopener" href="https://gcc.gnu.org/wiki/SplitStacks">ассемблерный трюк</a> из gcc (<a target="_blank" rel="noopener" href="https://gcc.gnu.org/legacy-ml/gcc-help/2012-03/msg00395.html">особенности реализации</a>)<br> [21] <a target="_blank" rel="noopener" href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0534r3.pdf">call/cc (call-with-current-continuation): A low-level API for stackful context switching</a> - пропозал по добавлению в стандарт c++ функционала call/cc<br> [22] <a target="_blank" rel="noopener" href="https://go.dev/doc/effective_go#goroutines">Goroutines</a> - горутины из go, управляются рантаймом языка. <a target="_blank" rel="noopener" href="https://go.dev/tour/concurrency/1">Tour of Go. Goroutines</a>. Планировщик горутин кооперативный, но “ощущается”, как вытесняющий<br> [23] <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=YEKjSzIwAdA">Concurrency Patterns In Go</a> - каналы, оператор select выбора из нескольких каналов<br> [24] <a target="_blank" rel="noopener" href="https://www.raywenderlich.com/books/kotlin-coroutines-by-tutorials/v2.0/chapters/5-async-await">Kotlin coroutines. async/await</a> - многопоточные async/await в Kotlin. Идиомы future/promise, async/await/deferred<br> [25] <a target="_blank" rel="noopener" href="http://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/">What Color is Your Function?</a> - проблемы с комбинированием синхронных и асинхронных функций<br> [26] <a target="_blank" rel="noopener" href="https://kristoff.it/blog/zig-colorblind-async-await/">What is Zig’s “Colorblind” Async/Await?</a> - необычный подход Zig, трансформация синхронных функций в асинхронные и наоборот<br> [27] <a target="_blank" rel="noopener" href="https://ziglearn.org/chapter-5/">Zyg’s Async</a> - Async в Zig (<a target="_blank" rel="noopener" href="https://ziglang.org/documentation/master/#Async-Functions">документация</a>)</p>
<h2><span id="vneshnie-iteratory">Внешние итераторы</span><a href="#vneshnie-iteratory" class="header-anchor">#</a></h2><p>Внешний итератор — объект, реализующий некоторый интерфейс Iterator (<a target="_blank" rel="noopener" href="http://msdn.microsoft.com/en-us/library/system.collections.ienumerable.aspx">C#</a>, <a target="_blank" rel="noopener" href="https://docs.python.org/2/library/stdtypes.html#iterator-types">Python</a>), у которого есть методы получения первого элемента коллекции (метод у коллекции или свободная функция), перехода на следующий элемент, и проверки на то, есть ли ещё элементы. На шаблонах C++ — явного интерфейса нет, но есть протокол, декларирующий способы описания итератора для своих типов.</p>
<p>Рассматривается в книге Банды Четырёх. В [8] критикуется название за активный суффикс -or, хотя методы итератор зовёт внешний код, предлагается название iteratee. Итераторы в стиле C++ также называют курсорами.</p>
<p><a target="_blank" rel="noopener" href="https://dascript.org/doc/reference/language/iterators.html?highlight=iterator">Итераторы</a> в <code>daScript</code>:</p>
<figure class="shiki dascript"><div class="codeblock"><div class="code"><pre class="shiki slack-dark"><code><span class="line"><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> it </span><span style="color: #D4D4D4">&lt;-</span><span style="color: #E6E6E6"> each ([[</span><span style="color: #4EC9B0">int</span><span style="color: #E6E6E6"> </span><span style="color: #B5CEA8">1</span><span style="color: #E6E6E6">;</span><span style="color: #B5CEA8">2</span><span style="color: #E6E6E6">;</span><span style="color: #B5CEA8">3</span><span style="color: #E6E6E6">;</span><span style="color: #B5CEA8">4</span><span style="color: #E6E6E6">;</span><span style="color: #B5CEA8">5</span><span style="color: #E6E6E6">]]) </span><span style="color: #6A9955">//создание итератора</span></span>
<span class="line"><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> x : </span><span style="color: #4EC9B0">int</span></span>
<span class="line"><span style="color: #C586C0">while</span><span style="color: #E6E6E6"> next(it, x)      </span><span style="color: #6A9955">// получение следующего значения</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #DCDCAA">print</span><span style="color: #E6E6E6">(</span><span style="color: #CE9178">&quot;x = {</span><span style="color: #9CDCFE">x</span><span style="color: #CE9178">}</span><span style="color: #D7BA7D">\n</span><span style="color: #CE9178">&quot;</span><span style="color: #E6E6E6">)</span></span>
<span class="line"><span style="color: #DCDCAA">verify</span><span style="color: #E6E6E6">(empty(it))      </span><span style="color: #6A9955">// функция проверки проверки существования следующего значения</span></span></code></pre></div></div></figure>
<p>Часто в языках есть синтаксический сахар для того, чтобы записывать выражение выше как <code>for-each</code> цикл:<br><figure class="shiki dascript"><div class="codeblock"><div class="code"><pre class="shiki slack-dark"><code><span class="line"><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> it </span><span style="color: #D4D4D4">&lt;-</span><span style="color: #E6E6E6"> each ([[</span><span style="color: #4EC9B0">int</span><span style="color: #E6E6E6"> </span><span style="color: #B5CEA8">1</span><span style="color: #E6E6E6">;</span><span style="color: #B5CEA8">2</span><span style="color: #E6E6E6">;</span><span style="color: #B5CEA8">3</span><span style="color: #E6E6E6">;</span><span style="color: #B5CEA8">4</span><span style="color: #E6E6E6">;</span><span style="color: #B5CEA8">5</span><span style="color: #E6E6E6">]])</span></span>
<span class="line"><span style="color: #C586C0">for</span><span style="color: #E6E6E6"> x </span><span style="color: #C586C0">in</span><span style="color: #E6E6E6"> it</span></span>
<span class="line"><span style="color: #E6E6E6">  </span><span style="color: #DCDCAA">print</span><span style="color: #E6E6E6">(</span><span style="color: #CE9178">&quot;x = {</span><span style="color: #9CDCFE">x</span><span style="color: #CE9178">}</span><span style="color: #D7BA7D">\n</span><span style="color: #CE9178">&quot;</span><span style="color: #E6E6E6">)</span></span></code></pre></div></div></figure></p>
<p>Элегантно решаемая внешним итератором задача:</p>
<p><strong><code>Поиск элемента</code></strong></p>
<figure class="shiki dascript"><div class="codeblock"><div class="code"><pre class="shiki slack-dark"><code><span class="line"><span style="color: #6A9955">//TT - generic-тип, TT-&amp; - &quot;убрать из определения типа символ ссылки&quot;</span></span>
<span class="line"><span style="color: #569CD6">def</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">find</span><span style="color: #E6E6E6">(</span><span style="color: #9CDCFE">it</span><span style="color: #E6E6E6">: </span><span style="color: #C586C0">iterator</span><span style="color: #D4D4D4">&lt;</span><span style="color: #E6E6E6">auto(TT)</span><span style="color: #D4D4D4">&gt;</span><span style="color: #E6E6E6">; </span><span style="color: #9CDCFE">value</span><span style="color: #E6E6E6">:TT</span><span style="color: #D4D4D4">-&amp;</span><span style="color: #E6E6E6">)</span></span>
<span class="line"><span style="color: #E6E6E6">  </span><span style="color: #C586C0">for</span><span style="color: #E6E6E6"> x </span><span style="color: #C586C0">in</span><span style="color: #E6E6E6"> it</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">if</span><span style="color: #E6E6E6"> x </span><span style="color: #D4D4D4">==</span><span style="color: #E6E6E6"> value { </span><span style="color: #C586C0">return</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">true</span><span style="color: #E6E6E6">; }</span></span>
<span class="line"><span style="color: #E6E6E6">  </span><span style="color: #C586C0">return</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">false</span></span></code></pre></div></div></figure>
<p>Более неаккуратное решение</p>
<p><strong><code>Проверка двух коллекций на равенство</code></strong><br>(и эквивалентные задачи, требуюшие поочередного обращения к двум или более коллекциям — функция <code>zip</code>; итератор выдающий по очереди элементы каждой коллекции)</p>
<figure class="shiki dascript"><div class="codeblock"><div class="code"><pre class="shiki slack-dark"><code><span class="line"><span style="color: #569CD6">def</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">is_equal</span><span style="color: #E6E6E6">(</span><span style="color: #9CDCFE">it1, it2</span><span style="color: #E6E6E6">: </span><span style="color: #C586C0">iterator</span><span style="color: #D4D4D4">&lt;</span><span style="color: #E6E6E6">auto(TT)</span><span style="color: #D4D4D4">&gt;</span><span style="color: #E6E6E6">)</span></span>
<span class="line"><span style="color: #E6E6E6">  </span><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> i2: TT</span><span style="color: #D4D4D4">-&amp;</span></span>
<span class="line"><span style="color: #E6E6E6">  </span><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> it2Ended: </span><span style="color: #4EC9B0">bool</span></span>
<span class="line"><span style="color: #E6E6E6">  </span><span style="color: #C586C0">for</span><span style="color: #E6E6E6"> i1 </span><span style="color: #C586C0">in</span><span style="color: #E6E6E6"> it1               </span><span style="color: #6A9955">//обращение к первому итератору</span></span>
<span class="line"><span style="color: #E6E6E6">    it2Ended </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> next(it2, i2)  </span><span style="color: #6A9955">//обращение ко второму итератору</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">if</span><span style="color: #E6E6E6"> </span><span style="color: #D4D4D4">!</span><span style="color: #E6E6E6">it2Ended </span><span style="color: #D4D4D4">||</span><span style="color: #E6E6E6"> (i1 </span><span style="color: #D4D4D4">!=</span><span style="color: #E6E6E6"> i2)</span></span>
<span class="line"><span style="color: #E6E6E6">      </span><span style="color: #C586C0">return</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">false</span></span>
<span class="line"><span style="color: #E6E6E6">  </span><span style="color: #C586C0">return</span><span style="color: #E6E6E6"> </span><span style="color: #D4D4D4">!</span><span style="color: #E6E6E6">next(it2, i2)</span></span></code></pre></div></div></figure>
<p>Неэлегантный пример</p>
<p><strong><code>Итератор в дереве</code></strong></p>
<p>Рекурсивная функция печати дерева на экран занимает 4 строки<br><figure class="shiki dascript"><div class="codeblock"><div class="code"><pre class="shiki slack-dark"><code><span class="line"><span style="color: #C586C0">struct</span><span style="color: #E6E6E6"> Tree</span></span>
<span class="line"><span style="color: #E6E6E6">  data: </span><span style="color: #4EC9B0">int</span></span>
<span class="line"><span style="color: #E6E6E6">  left, right: Tree?</span></span>
<span class="line"></span>
<span class="line"><span style="color: #569CD6">def</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">printTree</span><span style="color: #E6E6E6">(</span><span style="color: #9CDCFE">a</span><span style="color: #E6E6E6">: Tree?)</span></span>
<span class="line"><span style="color: #E6E6E6">  </span><span style="color: #C586C0">if</span><span style="color: #E6E6E6"> a </span><span style="color: #D4D4D4">!=</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">null</span></span>
<span class="line"><span style="color: #E6E6E6">    printTree(a</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">left)</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #DCDCAA">print</span><span style="color: #E6E6E6">(</span><span style="color: #CE9178">&quot;{</span><span style="color: #9CDCFE">a</span><span style="color: #D4D4D4">.</span><span style="color: #9CDCFE">data</span><span style="color: #CE9178">}</span><span style="color: #D7BA7D">\n</span><span style="color: #CE9178">&quot;</span><span style="color: #E6E6E6">)</span></span>
<span class="line"><span style="color: #E6E6E6">    printTree(a</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">right)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #D4D4D4">...</span></span>
<span class="line"><span style="color: #C586C0">let</span><span style="color: #E6E6E6"> tree </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">new</span><span style="color: #E6E6E6"> [[ Tree </span></span>
<span class="line"><span style="color: #E6E6E6">    data </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #B5CEA8">5</span><span style="color: #E6E6E6">,</span></span>
<span class="line"><span style="color: #E6E6E6">    left </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">new</span><span style="color: #E6E6E6"> [[Tree </span></span>
<span class="line"><span style="color: #E6E6E6">      data </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #B5CEA8">1</span></span>
<span class="line"><span style="color: #E6E6E6">    ]],</span></span>
<span class="line"><span style="color: #E6E6E6">    right </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">new</span><span style="color: #E6E6E6"> [[Tree</span></span>
<span class="line"><span style="color: #E6E6E6">      data </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #B5CEA8">7</span><span style="color: #E6E6E6">,</span></span>
<span class="line"><span style="color: #E6E6E6">      right </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">new</span><span style="color: #E6E6E6"> [[Tree</span></span>
<span class="line"><span style="color: #E6E6E6">        data </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #B5CEA8">10</span></span>
<span class="line"><span style="color: #E6E6E6">      ]]</span></span>
<span class="line"><span style="color: #E6E6E6">    ]]</span></span>
<span class="line"><span style="color: #E6E6E6">  ]] </span></span>
<span class="line"><span style="color: #E6E6E6">printTree(tree)</span></span></code></pre></div></div></figure></p>
<p>Попробуем написать итератор для дерева. Строительным блоком для кастомных внешних итераторов в <code>daScript</code> служат <a target="_blank" rel="noopener" href="https://dascript.org/doc/reference/language/lambdas.html?highlight=lambda#iterators">лямбда-функции</a>.<br><figure class="shiki dascript"><div class="codeblock"><div class="code"><pre class="shiki slack-dark"><code><span class="line"><span style="color: #C586C0">struct</span><span style="color: #E6E6E6"> IterateState</span></span>
<span class="line"><span style="color: #E6E6E6">  tree: Tree?</span></span>
<span class="line"><span style="color: #E6E6E6">  step: </span><span style="color: #4EC9B0">int</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> stack: </span><span style="color: #C586C0">array</span><span style="color: #D4D4D4">&lt;</span><span style="color: #E6E6E6">IterateState?</span><span style="color: #D4D4D4">&gt;</span></span>
<span class="line"><span style="color: #E6E6E6">stack </span><span style="color: #D4D4D4">|&gt;</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">push</span><span style="color: #E6E6E6">(</span><span style="color: #C586C0">new</span><span style="color: #E6E6E6"> [[IterateState </span><span style="color: #9CDCFE">tree</span><span style="color: #E6E6E6"> </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> tree]])</span></span>
<span class="line"><span style="color: #C586C0">unsafe</span></span>
<span class="line"><span style="color: #E6E6E6">  </span><span style="color: #C586C0">let</span><span style="color: #E6E6E6"> treeIterator </span><span style="color: #D4D4D4">&lt;-</span><span style="color: #E6E6E6"> @ </span><span style="color: #D4D4D4">&lt;|</span><span style="color: #E6E6E6"> (</span><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> current: </span><span style="color: #4EC9B0">int</span><span style="color: #D4D4D4">&amp;</span><span style="color: #E6E6E6">) : </span><span style="color: #4EC9B0">bool</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> hasValue </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">false</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">while</span><span style="color: #E6E6E6"> </span><span style="color: #D4D4D4">!</span><span style="color: #E6E6E6">empty(stack) </span><span style="color: #D4D4D4">&amp;&amp;</span><span style="color: #E6E6E6"> </span><span style="color: #D4D4D4">!</span><span style="color: #E6E6E6">hasValue</span></span>
<span class="line"><span style="color: #E6E6E6">      </span><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> state </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> back(stack)</span></span>
<span class="line"><span style="color: #E6E6E6">      </span><span style="color: #C586C0">if</span><span style="color: #E6E6E6"> state</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">step </span><span style="color: #D4D4D4">==</span><span style="color: #E6E6E6"> </span><span style="color: #B5CEA8">0</span></span>
<span class="line"><span style="color: #E6E6E6">        state</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">step </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #B5CEA8">1</span></span>
<span class="line"><span style="color: #E6E6E6">        </span><span style="color: #C586C0">if</span><span style="color: #E6E6E6"> (state</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">tree</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">left </span><span style="color: #D4D4D4">!=</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">null</span><span style="color: #E6E6E6">)</span></span>
<span class="line"><span style="color: #E6E6E6">          </span><span style="color: #DCDCAA">push</span><span style="color: #E6E6E6">(stack, </span><span style="color: #C586C0">new</span><span style="color: #E6E6E6"> [[IterateState </span><span style="color: #9CDCFE">tree</span><span style="color: #E6E6E6"> </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> state</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">tree</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">left]])</span></span>
<span class="line"><span style="color: #E6E6E6">      </span><span style="color: #C586C0">elif</span><span style="color: #E6E6E6"> state</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">step </span><span style="color: #D4D4D4">==</span><span style="color: #E6E6E6"> </span><span style="color: #B5CEA8">1</span></span>
<span class="line"><span style="color: #E6E6E6">        state</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">step </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #B5CEA8">2</span></span>
<span class="line"><span style="color: #E6E6E6">        current </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> state</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">tree</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">data</span></span>
<span class="line"><span style="color: #E6E6E6">        hasValue </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">true</span></span>
<span class="line"><span style="color: #E6E6E6">      </span><span style="color: #C586C0">else</span></span>
<span class="line"><span style="color: #E6E6E6">        pop(stack)</span></span>
<span class="line"><span style="color: #E6E6E6">        </span><span style="color: #C586C0">if</span><span style="color: #E6E6E6"> (state</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">tree</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">right </span><span style="color: #D4D4D4">!=</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">null</span><span style="color: #E6E6E6">)</span></span>
<span class="line"><span style="color: #E6E6E6">          </span><span style="color: #DCDCAA">push</span><span style="color: #E6E6E6">(stack, </span><span style="color: #C586C0">new</span><span style="color: #E6E6E6"> [[IterateState </span><span style="color: #9CDCFE">tree</span><span style="color: #E6E6E6"> </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> state</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">tree</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">right]])</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">return</span><span style="color: #E6E6E6"> hasValue</span></span>
<span class="line"><span style="color: #E6E6E6">  </span><span style="color: #C586C0">for</span><span style="color: #E6E6E6"> v </span><span style="color: #C586C0">in</span><span style="color: #E6E6E6"> each(treeIterator)</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #DCDCAA">print</span><span style="color: #E6E6E6">(</span><span style="color: #CE9178">&quot;{</span><span style="color: #9CDCFE">v</span><span style="color: #CE9178">}</span><span style="color: #D7BA7D">\n</span><span style="color: #CE9178">&quot;</span><span style="color: #E6E6E6">)</span></span></code></pre></div></div></figure></p>
<p>Можно также написать итератор в ООП стиле, определив класс в C++ и перегрузив функцию <a target="_blank" rel="noopener" href="https://github.com/GaijinEntertainment/daScript/blob/6f0f1a7025f20cb5a0fc73838e97ba371eb5c263/include/daScript/ast/ast.h#L415">isIterable</a>, но пример в ООП-стиле есть в [1], он там занимает также занимает 50 строк.</p>
<p>На <code>daScript</code> получилось 26, но всё равно, как, во имя Святой Матери Тьюринга, из четырёх-строчной рекурсивной функции получилась такая каша?</p>
<h2><span id="kolstek">Колстек</span><a href="#kolstek" class="header-anchor">#</a></h2><p>Часть работы в функции <code>printTree</code> за нас выполнила скрытая структура данных, <strong><code>callstack</code></strong>. </p>
<p>Во время рекурсивного первого рекурсивного вызова программа кладёт в стек адрес возврата, и осуществляет вызов этой функции, затем проделывает работу по вызову “полезной нагрузки” (<code>print</code>). После чего в следует второй рекурсивный вызов.</p>
<blockquote><p>Если на собеседовании у вас спросят, какая у вас любимая структура данных, смело отвечайте “стек вызовов”, и рассказывайте про то, как было бы плохо писать программы без него</p>
</blockquote>
<p>Если внимательно посмотреть на структуру функции <code>treeIterator</code>, можно заметить, что она выполняет те же шаги, в той же последовательности!</p>
<figure class="shiki dascript"><div class="codeblock"><div class="code"><pre class="shiki slack-dark"><code><span class="line"><span style="color: #569CD6">def</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">printTree</span><span style="color: #E6E6E6">(</span><span style="color: #9CDCFE">a</span><span style="color: #E6E6E6">: Tree?)</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #6A9955">//step 0 - кладём в стек адрес возврата, и начинаем новую итерацию вызова функции</span></span>
<span class="line"><span style="color: #E6E6E6">    printTree(a</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">left)</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #6A9955">//step 1 - выполняем &quot;полезную нагрузку&quot;</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #DCDCAA">print</span><span style="color: #E6E6E6">(</span><span style="color: #CE9178">&quot;{</span><span style="color: #9CDCFE">a</span><span style="color: #D4D4D4">.</span><span style="color: #9CDCFE">data</span><span style="color: #CE9178">}</span><span style="color: #D7BA7D">\n</span><span style="color: #CE9178">&quot;</span><span style="color: #E6E6E6">)</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #6A9955">//step 2 - кладём в стек адрес возврата</span></span>
<span class="line"><span style="color: #E6E6E6">    printTree(a</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">right)</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #6A9955">//невидимый</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #6A9955">//step 3 - ..выходим из функции, удаляем из стека верхнее значение, возвращаемся выше по стеку</span></span></code></pre></div></div></figure>
<p>Можно заметить небольшое различие на шаге 2 — в реализации <code>printTree</code> сначала происходит второй рекурсивный вызов, и затем возврат из основной функции, а в <code>treeIterator</code> значение сначала удаляется из стека, а затем в него кладётся новое. Это похоже на то, как происходит <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Tail_call">tail call optimization</a> — вместо того, чтобы положить в стек второе значение, а потом удалить и два верхних значения, мы сразу же удаляем ненужный более адрес возврата, т.е. выполняем step3, еще до step2.</p>
<p>Также функция <code>printTree</code> приостанавливается в точках 0 и 2, на момент вызова подпрограммы, и продолжает выполнение после возврата из подпрограммы. Это вторая крутая возможность, которую предоставляет колстек, и о которой при программировании обычно даже не задумываются. Однако при кастомной реализации итератора мы сталкиваемся с тем, что без каких-либо особых трюков приостановить выполнение функции и продолжить его с того же места невозможно. Вместо этого приходится эмулировать паузы с помощью конечного автомата, реализуемого с помощью цикла и переключения пути выполнения изменением переменной <code>state</code>.</p>
<p>Собственно, большинство идей, связанных с сопрограммами (википедия <a target="_blank" rel="noopener" href="https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B0">напоминает</a>, что ни в коем случае не следует путать их с копрограммами!), так или иначе связаны с тем, чтобы предоставить нам возможность приостанавливать выполнение функции и продолжать его.</p>
<p>Уже может стать понятно, что для этого язык должен каким-либо образом предоставить языковые конструкции, которые позволили бы нам не определять переменную <code>var stack: array&lt;IterateState?&gt;</code> явно, а “отдавать команду” положить туда что-то неявно, в идеале так же прозрачно, как это происходит в момент вызова функции.</p>
<p>Также стоит обратить внимание на то, где выделяется и хранится эта переменная. Здесь это просто локальная переменная, захваченная лямбда-функцией, но перед компилятором при реализации сопрограмм стоит серьёзная задача — где разместить этот “другой” стек. С одной стороны — его можно выделить в куче, чтобы он мог “пережить” область создания итератора, с другой — такая аллокация замедляет создание сопрограмм.</p>
<p>В общем-то, практически все отличия в реализации сопрограмм в разных языках сводятся к тому, чтобы различными способами решить эти вопросы — где и как будут выделяться <em>“другие стеки”</em>, и каким образом к ним можно обращаться из языка. Различных подходов много, и они имеют свои плюсы и минусы. Если с этого момента <em>прояснилось</em>, можно походить по ссылкам, заглянуть, кто что придумал в различных языках. Впрочем, можно снова зависнуть где-нибудь на Лиспе, или языках с ленивыми вычислениями.</p>
<p>Но пока вернёмся к колстеку — стоит ещё раз сравнить функции <code>printTree</code> и более общую <code>treeIterator</code>, и помедитировать на способ, которым сделано обобщение. Такое представление “невидимого” в коде колстека в явном виде называется <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Reification_(computer_science">реификацией</a>.</p>
<h2><span id="vnutrennie-iteratory">Внутренние итераторы</span><a href="#vnutrennie-iteratory" class="header-anchor">#</a></h2><p>Внутренний итератор — функция-callback, которая передаётся в функцию обхода коллекции.</p>
<p>Итерация разделяет код на 2 части: (1) код ответственный за генерацию серии объектов, и  (2) код, который выполняет над переданным ему объектом некоторую операцию. Для внешних итераторов это (1) тип, который может реализовывать протокол итерации и (2) тело цикла обхода. В этом стиле (2) является главным, он решает, когда запросить следующее значение, или когда прекратить итерации. Внутренние итераторы выворачивают всё наизнанку. Код, который генерирует значения, решает, когда ему вызвать переданный ему колбек.</p>
<p>Внешние функции, перебирающие значения, могут быть реализованы как методы объекта (<a target="_blank" rel="noopener" href="https://apidock.com/ruby/Array/each">array.each</a> в Ruby), или generic-функции (<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/algorithm/ranges/find">std::find_if</a> в C++)</p>
<p>Элегантно решаемые внутренними итераторами задачи:</p>
<p><strong><code>Итерация по дереву</code></strong></p>
<figure class="shiki dascript"><div class="codeblock"><div class="code"><pre class="shiki slack-dark"><code><span class="line"><span style="color: #569CD6">def</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">each</span><span style="color: #E6E6E6">(</span><span style="color: #569CD6">var</span><span style="color: #E6E6E6"> </span><span style="color: #9CDCFE">tree</span><span style="color: #E6E6E6">:Tree?; </span><span style="color: #9CDCFE">blk</span><span style="color: #E6E6E6">:</span><span style="color: #4EC9B0">lambda</span><span style="color: #D4D4D4">&lt;</span><span style="color: #E6E6E6">(what: </span><span style="color: #9CDCFE">int</span><span style="color: #E6E6E6">):</span><span style="color: #4EC9B0">void</span><span style="color: #D4D4D4">&gt;</span><span style="color: #E6E6E6">)</span></span>
<span class="line"><span style="color: #E6E6E6">  </span><span style="color: #C586C0">if</span><span style="color: #E6E6E6"> (tree</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">left </span><span style="color: #D4D4D4">!=</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">null</span><span style="color: #E6E6E6">)  { each(tree</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">left, blk); }</span></span>
<span class="line"><span style="color: #E6E6E6">  </span><span style="color: #DCDCAA">invoke</span><span style="color: #E6E6E6">(blk, tree</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">data)</span></span>
<span class="line"><span style="color: #E6E6E6">  </span><span style="color: #C586C0">if</span><span style="color: #E6E6E6"> (tree</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">right </span><span style="color: #D4D4D4">!=</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">null</span><span style="color: #E6E6E6">) { each(tree</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">right, blk); }</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E6E6E6">tree </span><span style="color: #D4D4D4">|&gt;</span><span style="color: #E6E6E6"> each() </span><span style="color: #D4D4D4">&lt;|</span><span style="color: #E6E6E6"> @(value: </span><span style="color: #4EC9B0">int</span><span style="color: #E6E6E6">)</span></span>
<span class="line"><span style="color: #E6E6E6">  </span><span style="color: #DCDCAA">print</span><span style="color: #E6E6E6">(</span><span style="color: #CE9178">&quot;{</span><span style="color: #9CDCFE">value</span><span style="color: #CE9178">}</span><span style="color: #D7BA7D">\n</span><span style="color: #CE9178">&quot;</span><span style="color: #E6E6E6">)</span></span></code></pre></div></div></figure>
<p>Отлично, в 3 строчки.</p>
<p><strong><code>Поиск элемента</code></strong></p>
<p>Возьмём общий внутренний генератор <code>map</code> из стандартной-библиотеки <a target="_blank" rel="noopener" href="https://github.com/GaijinEntertainment/daScript/blob/master/daslib/functional.das">functional</a> функцию поиска индекса элемента в массиве по условию (это синтетический пример, в модуле <code>buildin</code> есть более эффективная реализация этой <a target="_blank" rel="noopener" href="https://github.com/GaijinEntertainment/daScript/blob/a7c6565f652b56d0eee82b6e27974cdc09f06574/src/builtin/builtin.das#L701">функции</a>)</p>
<figure class="shiki dascript"><div class="codeblock"><div class="code"><pre class="shiki slack-dark"><code><span class="line"><span style="color: #569CD6">def</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">my_find_index_if</span><span style="color: #E6E6E6">(</span><span style="color: #569CD6">var</span><span style="color: #E6E6E6"> </span><span style="color: #9CDCFE">arr</span><span style="color: #E6E6E6">: </span><span style="color: #C586C0">iterator</span><span style="color: #D4D4D4">&lt;</span><span style="color: #E6E6E6">auto(TT)</span><span style="color: #D4D4D4">&gt;</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">explicit</span><span style="color: #E6E6E6">; </span><span style="color: #9CDCFE">blk</span><span style="color: #E6E6E6">:</span><span style="color: #4EC9B0">lambda</span><span style="color: #D4D4D4">&lt;</span><span style="color: #E6E6E6">(what:TT -&amp;):auto(QQ)</span><span style="color: #D4D4D4">&gt;</span><span style="color: #E6E6E6">)</span></span>
<span class="line"><span style="color: #E6E6E6">  </span><span style="color: #C586C0">for</span><span style="color: #E6E6E6"> value, i </span><span style="color: #C586C0">in</span><span style="color: #E6E6E6"> map(arr, blk), range(INT_MAX)</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">if</span><span style="color: #E6E6E6"> value</span></span>
<span class="line"><span style="color: #E6E6E6">      </span><span style="color: #C586C0">return</span><span style="color: #E6E6E6"> i</span></span>
<span class="line"><span style="color: #E6E6E6">  </span><span style="color: #C586C0">return</span><span style="color: #E6E6E6"> </span><span style="color: #D4D4D4">-</span><span style="color: #B5CEA8">1</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">//using</span></span>
<span class="line"><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> it </span><span style="color: #D4D4D4">&lt;-</span><span style="color: #E6E6E6"> each ([[</span><span style="color: #4EC9B0">int</span><span style="color: #E6E6E6"> </span><span style="color: #B5CEA8">0</span><span style="color: #E6E6E6">;</span><span style="color: #B5CEA8">1</span><span style="color: #E6E6E6">;</span><span style="color: #B5CEA8">2</span><span style="color: #E6E6E6">;</span><span style="color: #B5CEA8">3</span><span style="color: #E6E6E6">;</span><span style="color: #B5CEA8">4</span><span style="color: #E6E6E6">]])</span></span>
<span class="line"><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> answer </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> it </span><span style="color: #D4D4D4">|&gt;</span><span style="color: #E6E6E6"> my_find_index_if </span><span style="color: #D4D4D4">&lt;|</span><span style="color: #E6E6E6"> @(value: </span><span style="color: #4EC9B0">int</span><span style="color: #E6E6E6">)</span></span>
<span class="line"><span style="color: #E6E6E6">  </span><span style="color: #DCDCAA">print</span><span style="color: #E6E6E6">(</span><span style="color: #CE9178">&quot;check: {</span><span style="color: #9CDCFE">value</span><span style="color: #CE9178">}</span><span style="color: #D7BA7D">\n</span><span style="color: #CE9178">&quot;</span><span style="color: #E6E6E6">)</span></span>
<span class="line"><span style="color: #E6E6E6">  </span><span style="color: #C586C0">return</span><span style="color: #E6E6E6"> value </span><span style="color: #D4D4D4">&gt;</span><span style="color: #E6E6E6"> </span><span style="color: #B5CEA8">1</span></span>
<span class="line"><span style="color: #DCDCAA">print</span><span style="color: #E6E6E6">(</span><span style="color: #CE9178">&quot;{</span><span style="color: #9CDCFE">answer</span><span style="color: #CE9178">}</span><span style="color: #D7BA7D">\n</span><span style="color: #CE9178">&quot;</span><span style="color: #E6E6E6">)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">//output</span></span>
<span class="line"><span style="color: #E6E6E6">check: </span><span style="color: #B5CEA8">0</span></span>
<span class="line"><span style="color: #E6E6E6">check: </span><span style="color: #B5CEA8">1</span></span>
<span class="line"><span style="color: #E6E6E6">check: </span><span style="color: #B5CEA8">2</span></span>
<span class="line"><span style="color: #B5CEA8">2</span></span></code></pre></div></div></figure>
<p>Здесь таится интересный момент, связанный с прерыванием итерации. Почему функция <code>map</code> не выполнила проверку 3 и 4 элемента массива? Каким именно образом функция <code>map</code> “узнала”, что нужно остановить итерацию?<br>Если вы попробуете реализовать функцию <code>find_index</code> с помощью <code>std::for_each</code> в C++, то стокнётесь в проблемой, что <code>return</code> не может остановить итерацию <code>for_each</code>.</p>
<figure class="shiki cpp"><div class="codeblock"><div class="code"><pre class="shiki slack-dark"><code><span class="line"><span style="color: #E6E6E6">std::vector</span><span style="color: #D4D4D4">&lt;</span><span style="color: #569CD6">int</span><span style="color: #D4D4D4">&gt;</span><span style="color: #E6E6E6"> myvector </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> {</span><span style="color: #B5CEA8">0</span><span style="color: #E6E6E6">,</span><span style="color: #B5CEA8">1</span><span style="color: #E6E6E6">,</span><span style="color: #B5CEA8">2</span><span style="color: #E6E6E6">,</span><span style="color: #B5CEA8">3</span><span style="color: #E6E6E6">,</span><span style="color: #B5CEA8">4</span><span style="color: #E6E6E6">};</span></span>
<span class="line"></span>
<span class="line"><span style="color: #569CD6">int</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">find_index</span><span style="color: #E6E6E6">(std::</span><span style="color: #4EC9B0">vector</span><span style="color: #E6E6E6">&lt;</span><span style="color: #569CD6">int</span><span style="color: #E6E6E6">&gt;</span><span style="color: #569CD6">&amp;</span><span style="color: #E6E6E6"> </span><span style="color: #9CDCFE">myvector</span><span style="color: #E6E6E6">, std::</span><span style="color: #4EC9B0">function</span><span style="color: #E6E6E6">&lt;</span><span style="color: #569CD6">bool</span><span style="color: #E6E6E6">(</span><span style="color: #569CD6">int</span><span style="color: #E6E6E6">)&gt; </span><span style="color: #9CDCFE">checker</span><span style="color: #E6E6E6">) {</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #569CD6">int</span><span style="color: #E6E6E6"> answer </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #D4D4D4">-</span><span style="color: #B5CEA8">1</span><span style="color: #E6E6E6">;</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #569CD6">bool</span><span style="color: #E6E6E6"> answerFound </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #569CD6">false</span><span style="color: #E6E6E6">;</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #569CD6">auto</span><span style="color: #E6E6E6"> fn </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> std::</span><span style="color: #DCDCAA">for_each</span><span style="color: #E6E6E6">(</span><span style="color: #9CDCFE">myvector</span><span style="color: #E6E6E6">.</span><span style="color: #DCDCAA">begin</span><span style="color: #E6E6E6">(), </span><span style="color: #9CDCFE">myvector</span><span style="color: #E6E6E6">.</span><span style="color: #DCDCAA">end</span><span style="color: #E6E6E6">(), [</span><span style="color: #D4D4D4">&amp;</span><span style="color: #E6E6E6">](</span><span style="color: #569CD6">int</span><span style="color: #E6E6E6"> </span><span style="color: #9CDCFE">i</span><span style="color: #E6E6E6">) {</span></span>
<span class="line"><span style="color: #E6E6E6">        std::cout </span><span style="color: #D4D4D4">&lt;&lt;</span><span style="color: #E6E6E6"> </span><span style="color: #CE9178">&quot;check:&quot;</span><span style="color: #E6E6E6"> </span><span style="color: #D4D4D4">&lt;&lt;</span><span style="color: #E6E6E6"> i </span><span style="color: #D4D4D4">&lt;&lt;</span><span style="color: #E6E6E6"> std::endl;</span></span>
<span class="line"><span style="color: #E6E6E6">        </span><span style="color: #C586C0">if</span><span style="color: #E6E6E6"> (</span><span style="color: #D4D4D4">!</span><span style="color: #E6E6E6">answerFound) {</span></span>
<span class="line"><span style="color: #E6E6E6">            </span><span style="color: #C586C0">if</span><span style="color: #E6E6E6">(</span><span style="color: #DCDCAA">checker</span><span style="color: #E6E6E6">(i)) {</span></span>
<span class="line"><span style="color: #E6E6E6">                answer </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> i;</span></span>
<span class="line"><span style="color: #E6E6E6">                answerFound </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #569CD6">true</span><span style="color: #E6E6E6">;</span></span>
<span class="line"><span style="color: #E6E6E6">                </span><span style="color: #C586C0">return</span><span style="color: #E6E6E6">;</span><span style="color: #6A9955"> //невозможно остановить выполнение for_each</span></span>
<span class="line"><span style="color: #E6E6E6">            }</span></span>
<span class="line"><span style="color: #E6E6E6">        }</span></span>
<span class="line"><span style="color: #E6E6E6">    });</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">return</span><span style="color: #E6E6E6"> answer;</span></span>
<span class="line"><span style="color: #E6E6E6">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">//</span></span>
<span class="line"><span style="color: #569CD6">int</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">main</span><span style="color: #E6E6E6">() {</span></span>
<span class="line"><span style="color: #E6E6E6">  std::cout </span><span style="color: #D4D4D4">&lt;&lt;</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">find_index</span><span style="color: #E6E6E6">(myvector, [](</span><span style="color: #569CD6">int</span><span style="color: #E6E6E6"> </span><span style="color: #9CDCFE">i</span><span style="color: #E6E6E6">) {</span></span>
<span class="line"><span style="color: #E6E6E6">      </span><span style="color: #C586C0">return</span><span style="color: #E6E6E6"> i </span><span style="color: #D4D4D4">&gt;</span><span style="color: #E6E6E6"> </span><span style="color: #B5CEA8">1</span><span style="color: #E6E6E6">;</span></span>
<span class="line"><span style="color: #E6E6E6">  });</span></span>
<span class="line"><span style="color: #E6E6E6">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E6E6E6">std::cout </span><span style="color: #D4D4D4">&lt;&lt;</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">find_index</span><span style="color: #E6E6E6">(myvector);</span></span>
<span class="line"><span style="color: #6A9955">//Output</span></span>
<span class="line"><span style="color: #E6E6E6">check:</span><span style="color: #B5CEA8">0</span></span>
<span class="line"><span style="color: #E6E6E6">check:</span><span style="color: #B5CEA8">1</span></span>
<span class="line"><span style="color: #E6E6E6">check:</span><span style="color: #B5CEA8">2</span></span>
<span class="line"><span style="color: #E6E6E6">check:</span><span style="color: #B5CEA8">3</span></span>
<span class="line"><span style="color: #E6E6E6">check:</span><span style="color: #B5CEA8">4</span></span>
<span class="line"><span style="color: #B5CEA8">2</span></span></code></pre></div></div></figure>
<p>Что именно мешает лямбда-функции, переданной в <code>for_each</code> прекратить итерацию? Ответ - колстек, а точнее стекфрейм функций. В момент вызова лямбда-функции внутри for_each он выглядит так:<br><figure class="shiki"><div class="codeblock"><div class="code"><pre class="shiki slack-dark"><code><span class="line"><span style="color: #E6E6E6">main</span></span>
<span class="line"><span style="color: #E6E6E6">  find_index</span></span>
<span class="line"><span style="color: #E6E6E6">    for_each</span></span>
<span class="line"><span style="color: #E6E6E6">    стекфрейм for_each</span></span>
<span class="line"><span style="color: #E6E6E6">      for_each_lambda</span></span>
<span class="line"><span style="color: #E6E6E6">        checker_lambda</span></span></code></pre></div></div></figure></p>
<p><code>for_each</code> как и любая функция, может выделить себе дополнительную память на стеке под свои нужны, и если <code>for_each_lambda</code> или <code>checker_lambda</code> захотят выйти на уровень выше <code>for_each</code>, им нужно уметь раскручивать стек (скорее всего, конкретно для for_each там ничего нет, но сама необходимость раскрутки всего, что находится между функциями разного уровня на стеке блокирует возможность выхода)</p>
<p>Конечно, раскручивать стек в C++ умеют исключения, но… просто посмотрите на этот код и никогда так не делайте:<br><figure class="shiki cpp"><div class="codeblock"><div class="code"><pre class="shiki slack-dark"><code><span class="line"><span style="color: #569CD6">int</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">find_index</span><span style="color: #E6E6E6">(std::</span><span style="color: #4EC9B0">vector</span><span style="color: #E6E6E6">&lt;</span><span style="color: #569CD6">int</span><span style="color: #E6E6E6">&gt;</span><span style="color: #569CD6">&amp;</span><span style="color: #E6E6E6"> </span><span style="color: #9CDCFE">myvector</span><span style="color: #E6E6E6">, std::</span><span style="color: #4EC9B0">function</span><span style="color: #E6E6E6">&lt;</span><span style="color: #569CD6">bool</span><span style="color: #E6E6E6">(</span><span style="color: #569CD6">int</span><span style="color: #E6E6E6">)&gt; </span><span style="color: #9CDCFE">checker</span><span style="color: #E6E6E6">) {</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">try</span><span style="color: #E6E6E6"> {</span></span>
<span class="line"><span style="color: #E6E6E6">        </span><span style="color: #569CD6">auto</span><span style="color: #E6E6E6"> fn </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> std::</span><span style="color: #DCDCAA">for_each</span><span style="color: #E6E6E6">(</span><span style="color: #9CDCFE">myvector</span><span style="color: #E6E6E6">.</span><span style="color: #DCDCAA">begin</span><span style="color: #E6E6E6">(), </span><span style="color: #9CDCFE">myvector</span><span style="color: #E6E6E6">.</span><span style="color: #DCDCAA">end</span><span style="color: #E6E6E6">(), [</span><span style="color: #D4D4D4">&amp;</span><span style="color: #E6E6E6">](</span><span style="color: #569CD6">int</span><span style="color: #E6E6E6"> </span><span style="color: #9CDCFE">i</span><span style="color: #E6E6E6">) {</span></span>
<span class="line"><span style="color: #E6E6E6">            std::cout </span><span style="color: #D4D4D4">&lt;&lt;</span><span style="color: #E6E6E6"> </span><span style="color: #CE9178">&quot;check:&quot;</span><span style="color: #E6E6E6"> </span><span style="color: #D4D4D4">&lt;&lt;</span><span style="color: #E6E6E6"> i </span><span style="color: #D4D4D4">&lt;&lt;</span><span style="color: #E6E6E6"> std::endl;</span></span>
<span class="line"><span style="color: #E6E6E6">            </span><span style="color: #C586C0">if</span><span style="color: #E6E6E6">(</span><span style="color: #DCDCAA">checker</span><span style="color: #E6E6E6">(i)) {</span></span>
<span class="line"><span style="color: #E6E6E6">                </span><span style="color: #C586C0">throw</span><span style="color: #E6E6E6"> i;</span><span style="color: #6A9955"> //&quot;выбрасываем&quot; ответ из foreach</span></span>
<span class="line"><span style="color: #E6E6E6">            }            </span></span>
<span class="line"><span style="color: #E6E6E6">        });</span></span>
<span class="line"><span style="color: #E6E6E6">    }</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">catch</span><span style="color: #E6E6E6"> (</span><span style="color: #569CD6">int</span><span style="color: #E6E6E6"> throwedAnswer) {</span></span>
<span class="line"><span style="color: #E6E6E6">        </span><span style="color: #C586C0">return</span><span style="color: #E6E6E6"> throwedAnswer;</span></span>
<span class="line"><span style="color: #E6E6E6">    }</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">return</span><span style="color: #E6E6E6"> </span><span style="color: #D4D4D4">-</span><span style="color: #B5CEA8">1</span><span style="color: #E6E6E6">;</span></span>
<span class="line"><span style="color: #E6E6E6">}</span></span></code></pre></div></div></figure></p>
<p>Возможность раскручивать стек называется <code>non-local returns</code> и присутствует в языках типа <code>Ruby</code> (пример в [1]) или <code>Kotlin</code> [24]:<br><figure class="shiki kotlin"><div class="codeblock"><div class="code"><pre class="shiki slack-dark"><code><span class="line"><span style="color: #569CD6">val</span><span style="color: #E6E6E6"> list </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">listOf</span><span style="color: #E6E6E6">(</span><span style="color: #B5CEA8">1</span><span style="color: #E6E6E6">, </span><span style="color: #B5CEA8">2</span><span style="color: #E6E6E6">, </span><span style="color: #B5CEA8">3</span><span style="color: #E6E6E6">, </span><span style="color: #B5CEA8">4</span><span style="color: #E6E6E6">, </span><span style="color: #B5CEA8">5</span><span style="color: #E6E6E6">)</span></span>
<span class="line"><span style="color: #569CD6">val</span><span style="color: #E6E6E6"> </span><span style="color: #569CD6">value</span><span style="color: #E6E6E6"> </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #B5CEA8">3</span></span>
<span class="line"><span style="color: #569CD6">var</span><span style="color: #E6E6E6"> result </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #CE9178">&quot;&quot;</span></span>
<span class="line"><span style="color: #E6E6E6">list.</span><span style="color: #DCDCAA">forEach</span><span style="color: #E6E6E6"> { </span></span>
<span class="line"><span style="color: #E6E6E6">  result </span><span style="color: #D4D4D4">+=</span><span style="color: #E6E6E6"> </span><span style="color: #CE9178">&quot;</span><span style="color: #9CDCFE">$it</span><span style="color: #CE9178">&quot;</span></span>
<span class="line"><span style="color: #E6E6E6">  </span><span style="color: #C586C0">if</span><span style="color: #E6E6E6"> (it </span><span style="color: #D4D4D4">==</span><span style="color: #E6E6E6"> </span><span style="color: #569CD6">value</span><span style="color: #E6E6E6">)</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">return</span><span style="color: #E6E6E6">@forEach </span><span style="color: #6A9955">//выход из foreach</span></span>
<span class="line"><span style="color: #E6E6E6">}</span></span>
<span class="line"><span style="color: #6A9955">//result=&quot;123&quot;</span></span></code></pre></div></div></figure></p>
<p>Другой более универсальный подход, реализованный в <code>daScript</code> и других языках с поддержкой генераторов — приостанавливать выполнение <code>map/for_each</code> и передавать промежуточные результаты “вовне”, с возможностью по желанию прекратить приостановленную итерацию на уровень выше (генераторы также известны как “елды” среди добравшихся до Unity артистов).</p>
<p>Совсем нехороший пример</p>
<p><strong><code>Проверка двух коллекций на равенство</code></strong></p>
<p>Без задействования генераторов, корутин, потоков или продолжений, или других способов приостановить функцию, не пишется. Мешают, как и в предыдущем примере, всё те же стекфреймы в колстеке. Но если в примере с ранним выходом из внутреннего итератора удавалось хотя бы выкрутиться хаком и “выпрыгнуть” с помощью исключений, необратимо раскрутив стек, то здесь для приостановки каждой из двух функций-колбеков нужно хранить оба состояния обеих функций.</p>
<h2><span id="generatory">Генераторы</span><a href="#generatory" class="header-anchor">#</a></h2><p>Генераторы — это возобновляемые функции. Возвращаемый тип генератора — итератор (гибрид между внутренним и внешним)</p>
<figure class="shiki dascript"><div class="codeblock"><div class="code"><pre class="shiki slack-dark"><code><span class="line"><span style="color: #C586C0">let</span><span style="color: #E6E6E6"> gen </span><span style="color: #D4D4D4">&lt;-</span><span style="color: #E6E6E6"> </span><span style="color: #4EC9B0">generator</span><span style="color: #D4D4D4">&lt;</span><span style="color: #4EC9B0">int</span><span style="color: #D4D4D4">&gt;</span><span style="color: #E6E6E6">() </span><span style="color: #D4D4D4">&lt;|</span><span style="color: #E6E6E6"> </span><span style="color: #569CD6">$</span><span style="color: #E6E6E6">()</span></span>
<span class="line"><span style="color: #E6E6E6">  </span><span style="color: #C586C0">for</span><span style="color: #E6E6E6"> t </span><span style="color: #C586C0">in</span><span style="color: #E6E6E6"> range(</span><span style="color: #B5CEA8">0</span><span style="color: #E6E6E6">,</span><span style="color: #B5CEA8">10</span><span style="color: #E6E6E6">)</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #4EC9B0">yield</span><span style="color: #E6E6E6"> t</span></span>
<span class="line"><span style="color: #E6E6E6">  </span><span style="color: #C586C0">return</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">false</span></span></code></pre></div></div></figure>
<p><code>map</code>, как и большинство функций из модуля <code>functional</code> в <code>daScript</code>, возвращают генераторы, так что с помощью неё должно быть возможно (хотя и не нужно) реализовать проверку двух коллекций на равенство, недоступную для внутренних итераторов в языках без поддержки генераторов:</p>
<figure class="shiki dascript"><div class="codeblock"><div class="code"><pre class="shiki slack-dark"><code><span class="line"><span style="color: #569CD6">def</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">is_equal</span><span style="color: #E6E6E6">(</span><span style="color: #569CD6">var</span><span style="color: #E6E6E6"> </span><span style="color: #9CDCFE">it1, it2</span><span style="color: #E6E6E6">: </span><span style="color: #C586C0">iterator</span><span style="color: #D4D4D4">&lt;</span><span style="color: #E6E6E6">auto(TT)</span><span style="color: #D4D4D4">&gt;</span><span style="color: #E6E6E6">)</span></span>
<span class="line"><span style="color: #E6E6E6">  </span><span style="color: #C586C0">unsafe</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> equalResult </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">true</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #6A9955">//один из генераторов возвращает значения из коллекции</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> aGenerator </span><span style="color: #D4D4D4">&lt;-</span><span style="color: #E6E6E6"> it1 </span><span style="color: #D4D4D4">|&gt;</span><span style="color: #E6E6E6"> map </span><span style="color: #D4D4D4">&lt;|</span><span style="color: #E6E6E6"> @(aValue:TT</span><span style="color: #D4D4D4">-&amp;</span><span style="color: #E6E6E6">)</span></span>
<span class="line"><span style="color: #E6E6E6">      </span><span style="color: #C586C0">return</span><span style="color: #E6E6E6"> aValue</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #6A9955">//второй генератор берёт значение из второй коллекции и сравниваем со значением из другого генератора</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #6A9955">//лямбда-функция захватывает первый генератор для получения значений из него</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> bGenerator </span><span style="color: #D4D4D4">&lt;-</span><span style="color: #E6E6E6"> it2 </span><span style="color: #D4D4D4">|&gt;</span><span style="color: #E6E6E6"> map </span><span style="color: #D4D4D4">&lt;|</span><span style="color: #E6E6E6"> @ [[</span><span style="color: #D4D4D4">&amp;</span><span style="color: #E6E6E6">aGenerator]](bValue:TT</span><span style="color: #D4D4D4">-&amp;</span><span style="color: #E6E6E6">)</span></span>
<span class="line"><span style="color: #E6E6E6">      </span><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> aValue : TT</span><span style="color: #D4D4D4">-&amp;</span></span>
<span class="line"><span style="color: #E6E6E6">      </span><span style="color: #C586C0">if</span><span style="color: #E6E6E6"> </span><span style="color: #D4D4D4">!</span><span style="color: #E6E6E6">next(aGenerator, aValue)</span></span>
<span class="line"><span style="color: #E6E6E6">        </span><span style="color: #C586C0">return</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">false</span></span>
<span class="line"><span style="color: #E6E6E6">      </span><span style="color: #DCDCAA">print</span><span style="color: #E6E6E6">(</span><span style="color: #CE9178">&quot;{</span><span style="color: #9CDCFE">bValue</span><span style="color: #CE9178">} {</span><span style="color: #9CDCFE">aValue</span><span style="color: #CE9178">}</span><span style="color: #D7BA7D">\n</span><span style="color: #CE9178">&quot;</span><span style="color: #E6E6E6">)</span></span>
<span class="line"><span style="color: #E6E6E6">      </span><span style="color: #C586C0">return</span><span style="color: #E6E6E6"> bValue </span><span style="color: #D4D4D4">==</span><span style="color: #E6E6E6"> aValue</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #6A9955">//продолжаем брать из генераторов значения, пока она эквивалентны</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">while</span><span style="color: #E6E6E6"> equalResult </span><span style="color: #D4D4D4">&amp;&amp;</span><span style="color: #E6E6E6"> next(bGenerator, equalResult)</span></span>
<span class="line"><span style="color: #E6E6E6">      </span><span style="color: #C586C0">pass</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #6A9955">//коллекции эквивалентны, если оба итератора обработали все значения</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> aLast : </span><span style="color: #4EC9B0">int</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">return</span><span style="color: #E6E6E6"> </span><span style="color: #D4D4D4">!</span><span style="color: #E6E6E6">next(aGenerator, aLast) </span><span style="color: #D4D4D4">&amp;&amp;</span><span style="color: #E6E6E6"> empty(bGenerator)</span></span></code></pre></div></div></figure>
<p><strong><code>Двунаправленные генераторы</code></strong></p>
<p><code>Python</code> поддерживает также <a target="_blank" rel="noopener" href="https://docs.python.org/3/reference/expressions.html#generator.send">отправку</a> данных генератору из вызывающего кода</p>
<figure class="shiki python"><div class="codeblock"><div class="code"><pre class="shiki slack-dark"><code><span class="line"><span style="color: #D4D4D4">&gt;&gt;&gt;</span><span style="color: #E6E6E6"> </span><span style="color: #569CD6">def</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">double_inputs</span><span style="color: #E6E6E6">():</span></span>
<span class="line"><span style="color: #E6E6E6">...     </span><span style="color: #C586C0">while</span><span style="color: #E6E6E6"> </span><span style="color: #569CD6">True</span><span style="color: #E6E6E6">:</span></span>
<span class="line"><span style="color: #E6E6E6">...         x </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">yield</span></span>
<span class="line"><span style="color: #E6E6E6">...         </span><span style="color: #C586C0">yield</span><span style="color: #E6E6E6"> x </span><span style="color: #D4D4D4">*</span><span style="color: #E6E6E6"> </span><span style="color: #B5CEA8">2</span></span>
<span class="line"><span style="color: #E6E6E6">...</span></span>
<span class="line"><span style="color: #D4D4D4">&gt;&gt;&gt;</span><span style="color: #E6E6E6"> gen </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> double_inputs()</span></span>
<span class="line"><span style="color: #D4D4D4">&gt;&gt;&gt;</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">next</span><span style="color: #E6E6E6">(gen)</span></span>
<span class="line"><span style="color: #D4D4D4">&gt;&gt;&gt;</span><span style="color: #E6E6E6"> gen.send(</span><span style="color: #B5CEA8">10</span><span style="color: #E6E6E6">)</span></span>
<span class="line"><span style="color: #B5CEA8">20</span></span>
<span class="line"><span style="color: #D4D4D4">&gt;&gt;&gt;</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">next</span><span style="color: #E6E6E6">(gen)</span></span>
<span class="line"><span style="color: #D4D4D4">&gt;&gt;&gt;</span><span style="color: #E6E6E6"> gen.send(</span><span style="color: #B5CEA8">6</span><span style="color: #E6E6E6">)</span></span>
<span class="line"><span style="color: #B5CEA8">12</span></span></code></pre></div></div></figure>
<h2><span id="razvorachivanie-iteratorov">Разворачивание итераторов</span><a href="#razvorachivanie-iteratorov" class="header-anchor">#</a></h2><p>Теперь рассмотрим возможность “выворачивания” итераторов. К примеру, у нас есть “красивая” версия внутреннего итератора <code>each</code> для дерева, и функция сравнения, принимающая внешние итераторы, в которую хочется передать итератор обхода дерева.</p>
<p>Для начала посмотрим, как можно передать значения из лямбда функции “наружу”, с помощью захвата в замыкание (closure) лямбда-функции:</p>
<figure class="shiki dascript"><div class="codeblock"><div class="code"><pre class="shiki slack-dark"><code><span class="line"><span style="color: #569CD6">def</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">to_array</span><span style="color: #E6E6E6">(</span><span style="color: #569CD6">var</span><span style="color: #E6E6E6"> </span><span style="color: #9CDCFE">tree </span><span style="color: #E6E6E6">: Tree?)</span></span>
<span class="line"><span style="color: #E6E6E6">  </span><span style="color: #C586C0">unsafe</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> arr: </span><span style="color: #C586C0">array</span><span style="color: #D4D4D4">&lt;</span><span style="color: #4EC9B0">int</span><span style="color: #D4D4D4">&gt;</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #6A9955">//захватываем arr в замыкание по ссылке</span></span>
<span class="line"><span style="color: #E6E6E6">    each(tree) </span><span style="color: #D4D4D4">&lt;|</span><span style="color: #E6E6E6"> @[[</span><span style="color: #D4D4D4">&amp;</span><span style="color: #E6E6E6">arr]](value: </span><span style="color: #4EC9B0">int</span><span style="color: #E6E6E6">)</span></span>
<span class="line"><span style="color: #E6E6E6">      arr </span><span style="color: #D4D4D4">|&gt;</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">push</span><span style="color: #E6E6E6">(value)</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">return</span><span style="color: #E6E6E6"> </span><span style="color: #D4D4D4">&lt;-</span><span style="color: #E6E6E6"> arr</span></span></code></pre></div></div></figure>
<p>Функция накапливает все значения в переменной <code>arr</code> и возвращает полностью собранный массив. Следующим шагом попробуем избавиться от этого накопления и вернуть управление вызывающему коду, как только будет получено следующее значение из <code>each</code>. Но тут возникает следующая проблема. Если <code>each</code> не задизайнена так, чтобы её можно было останавливать, то её и невозможно будет остановить из колбека. Т.е. нам нужна другая функция <code>each_async</code>, которая будет возвращать значение через генератор <code>yield</code>.</p>
<figure class="shiki dascript"><div class="codeblock"><div class="code"><pre class="shiki slack-dark"><code><span class="line"><span style="color: #569CD6">def</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">each_async</span><span style="color: #E6E6E6">(</span><span style="color: #9CDCFE">tree</span><span style="color: #E6E6E6">:Tree?) : </span><span style="color: #C586C0">iterator</span><span style="color: #D4D4D4">&lt;</span><span style="color: #4EC9B0">int</span><span style="color: #D4D4D4">&gt;</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">return</span><span style="color: #E6E6E6"> </span><span style="color: #D4D4D4">&lt;-</span><span style="color: #E6E6E6"> </span><span style="color: #4EC9B0">generator</span><span style="color: #D4D4D4">&lt;</span><span style="color: #4EC9B0">int</span><span style="color: #D4D4D4">&gt;</span><span style="color: #E6E6E6">() </span><span style="color: #D4D4D4">&lt;|</span><span style="color: #E6E6E6"> </span><span style="color: #569CD6">$</span><span style="color: #E6E6E6"> ()</span></span>
<span class="line"><span style="color: #E6E6E6">      </span><span style="color: #C586C0">if</span><span style="color: #E6E6E6"> tree</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">left </span><span style="color: #D4D4D4">!=</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">null</span></span>
<span class="line"><span style="color: #E6E6E6">        </span><span style="color: #C586C0">for</span><span style="color: #E6E6E6"> newVal </span><span style="color: #C586C0">in</span><span style="color: #E6E6E6"> each_async(tree</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">left)</span></span>
<span class="line"><span style="color: #E6E6E6">          </span><span style="color: #4EC9B0">yield</span><span style="color: #E6E6E6"> newVal</span></span>
<span class="line"><span style="color: #E6E6E6">      </span><span style="color: #4EC9B0">yield</span><span style="color: #E6E6E6"> tree</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">data</span></span>
<span class="line"><span style="color: #E6E6E6">      </span><span style="color: #C586C0">if</span><span style="color: #E6E6E6"> tree</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">right </span><span style="color: #D4D4D4">!=</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">null</span></span>
<span class="line"><span style="color: #E6E6E6">        </span><span style="color: #C586C0">for</span><span style="color: #E6E6E6"> newVal </span><span style="color: #C586C0">in</span><span style="color: #E6E6E6"> each_async(tree</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">right)</span></span>
<span class="line"><span style="color: #E6E6E6">          </span><span style="color: #4EC9B0">yield</span><span style="color: #E6E6E6"> newVal</span></span>
<span class="line"><span style="color: #E6E6E6">      </span><span style="color: #C586C0">return</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">false</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> eq </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> is_equal(each_async(tree1), each_async(tree2))</span></span></code></pre></div></div></figure>
<p>Чуть менее компактно, чем первоначальная версия, за счёт того, что из вложенных генераторов приходится доставать данные с помощью дополнительных циклов обхода (<code>yield</code> должно возвращать <code>int</code>, а вложенный генератор возвращает <code>iterator&lt;int&gt;</code>, из которого нужно достать данные для выдачи внешнему генератору).</p>
<p><code>Python</code> и некоторые другие языки поддерживают <strong><code>делегацию генераторов</code></strong> — синтаксический сахар, который позволяет избежать написания таких циклов<br><figure class="shiki python"><div class="codeblock"><div class="code"><pre class="shiki slack-dark"><code><span class="line"><span style="color: #569CD6">def</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">concat</span><span style="color: #E6E6E6">(</span><span style="color: #9CDCFE">a</span><span style="color: #E6E6E6">, </span><span style="color: #9CDCFE">b</span><span style="color: #E6E6E6">):</span></span>
<span class="line"><span style="color: #E6E6E6">  </span><span style="color: #6A9955">#for item in walkFirst(a): yield item</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E6E6E6">  </span><span style="color: #6A9955">#&quot;берём значение из генератора и передаём дальше</span></span>
<span class="line"><span style="color: #E6E6E6">  </span><span style="color: #C586C0">yield from</span><span style="color: #E6E6E6"> walkFirst(a)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #569CD6">def</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">walkFirst</span><span style="color: #E6E6E6">(</span><span style="color: #9CDCFE">a</span><span style="color: #E6E6E6">):</span></span>
<span class="line"><span style="color: #E6E6E6">  </span><span style="color: #C586C0">for</span><span style="color: #E6E6E6"> item </span><span style="color: #C586C0">in</span><span style="color: #E6E6E6"> a: </span><span style="color: #C586C0">yield</span><span style="color: #E6E6E6"> item</span></span></code></pre></div></div></figure></p>
<p><strong>update</strong><br>Аналогичный макрос <a target="_blank" rel="noopener" href="https://github.com/GaijinEntertainment/daScript/commit/3acb98e7c13456f59c73f482ef4396481cf30293">yield_from</a> для <code>daScript</code></p>
<p>Но тут есть важный момент, снова возвращающий нас к колстекам. Делегация генераторов — это просто синтаксический сахар, но мы не можем написать возврат значения из вложенных функций, не прокидывая эту делегацию через каждый уровень вложенности. Чтобы полноценно выйти на несколько уровней вверх, в затем вернуться, нам потребуется структура, которая реифицирует не один уровень стека, а весь стек. Следующий пример на <code>ruby</code> показывает такую структуру.</p>
<h2><span id="faybery">Файберы</span><a href="#faybery" class="header-anchor">#</a></h2><p>В [2] есть пример разворачивания итераторов из <code>Ruby</code>:</p>
<figure class="shiki ruby"><div class="codeblock"><div class="code"><pre class="shiki slack-dark"><code><span class="line"><span style="color: #C586C0">class</span><span style="color: #E6E6E6"> </span><span style="color: #4EC9B0">MyEnumerator</span></span>
<span class="line"><span style="color: #E6E6E6">  </span><span style="color: #569CD6">include</span><span style="color: #E6E6E6"> </span><span style="color: #9CDCFE">Enumerable</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E6E6E6">  </span><span style="color: #C586C0">def</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">initialize</span><span style="color: #E6E6E6">(</span><span style="color: #9CDCFE">obj</span><span style="color: #E6E6E6">)</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #9CDCFE">@fiber</span><span style="color: #E6E6E6"> </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #4EC9B0">Fiber</span><span style="color: #E6E6E6">.</span><span style="color: #569CD6">new</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">do</span><span style="color: #E6E6E6">  </span><span style="color: #6A9955"># Spin up a new fiber.</span></span>
<span class="line"><span style="color: #E6E6E6">      obj.each </span><span style="color: #C586C0">do</span><span style="color: #E6E6E6"> |</span><span style="color: #9CDCFE">value</span><span style="color: #E6E6E6">|  </span><span style="color: #6A9955"># Run the internal iterator on it.</span></span>
<span class="line"><span style="color: #E6E6E6">        </span><span style="color: #4EC9B0">Fiber</span><span style="color: #E6E6E6">.yield(value) </span><span style="color: #6A9955"># When it yields a value, suspend</span></span>
<span class="line"><span style="color: #E6E6E6">                          </span><span style="color: #6A9955"># the fiber and emit the value.</span></span>
<span class="line"><span style="color: #E6E6E6">      </span><span style="color: #C586C0">end</span></span>
<span class="line"><span style="color: #E6E6E6">      </span><span style="color: #569CD6">raise</span><span style="color: #E6E6E6"> </span><span style="color: #9CDCFE">StopIteration</span><span style="color: #E6E6E6">  </span><span style="color: #6A9955"># Then signal that we&#39;re done.</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">end</span></span>
<span class="line"><span style="color: #E6E6E6">  </span><span style="color: #C586C0">end</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E6E6E6">  </span><span style="color: #C586C0">def</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">next</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #9CDCFE">@fiber</span><span style="color: #E6E6E6">.resume          </span><span style="color: #6A9955"># When the next value is requested,</span></span>
<span class="line"><span style="color: #E6E6E6">                           </span><span style="color: #6A9955"># resume the fiber.</span></span>
<span class="line"><span style="color: #E6E6E6">  </span><span style="color: #C586C0">end</span></span>
<span class="line"><span style="color: #C586C0">end</span></span></code></pre></div></div></figure>
<p><code>Yield</code> происходит прямо из <code>each</code> во внешнюю функцию! Если обратиться к предыдущим замечаниям про колстеки, то здесь будет:</p>
<ul>
<li><code>each</code> для дерева создаёт стек, в котором хранит адреса возвратом рекурсивных вызовов</li>
<li>метод <code>next</code> полностью “замораживает” этот стек, и переключается на другой, в управляющем коде.</li>
</ul>
<p>Так что <code>Fiber</code> здесь — структура, которая реифицирует не только фрейм стека, как генераторы, но весь стек полностью.<br><code>Файберы</code> имеют свой стек и копии локальных переменных. Один выполняются в одном потоке, и передача управления между ними управляется кодом пользователя — пока один файбер не передаст управление следующему, переключения не будет.</p>
<p>Файберы — своеобразная “точка связи” итерации с параллелизмом.</p>
<h2><span id="funkcii-bez-stekfreyma">Функции без стекфрейма</span><a href="#funkcii-bez-stekfreyma" class="header-anchor">#</a></h2><p>В [12] рассматриваются альтернативы хранению временных переменных функции в стеке. В качестве примера рассматривается создание языков для визуального программирования типа <code>Kismet</code>/<code>Blueprint</code> из Unreal. Каждая функция-строительный кирпич заранее выделяет необходимую ей память и просто использует её повторно, если вызывается вновь. Если нужно вызвать функцию дважды — выделяется два блока памяти. Преимущество такого подхода — можно легко связывать цепочки функций вида “пойти в точку А, подождать секунду, затем проиграть анимацию и звук одновременно”.</p>
<p>Чтобы создать код связи нод на C++, может потребоваться код вида:<br><figure class="shiki cpp"><div class="codeblock"><div class="code"><pre class="shiki slack-dark"><code><span class="line"><span style="color: #569CD6">bool</span><span style="color: #E6E6E6"> bMoved </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #569CD6">false</span><span style="color: #E6E6E6">;</span></span>
<span class="line"><span style="color: #E6E6E6">CompareBoolNode </span><span style="color: #D4D4D4">*</span><span style="color: #E6E6E6"> cmp </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #569CD6">new</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">CompareBoolNode</span><span style="color: #E6E6E6">(bMoved);</span></span>
<span class="line"><span style="color: #E6E6E6">DelayNode </span><span style="color: #D4D4D4">*</span><span style="color: #E6E6E6"> first_delay </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #569CD6">new</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">DelayNode</span><span style="color: #E6E6E6">(some_hardcoded_number);</span></span>
<span class="line"><span style="color: #E6E6E6">DelayNode </span><span style="color: #D4D4D4">*</span><span style="color: #E6E6E6"> second_delay </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #569CD6">new</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">DelayNode</span><span style="color: #E6E6E6">(another_hardcoded_number);</span></span>
<span class="line"><span style="color: #E6E6E6">DelayNode </span><span style="color: #D4D4D4">*</span><span style="color: #E6E6E6"> third_delay </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #569CD6">new</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">DelayNode</span><span style="color: #E6E6E6">(a_third_hardcoded_number);</span></span>
<span class="line"><span style="color: #E6E6E6">MatineeNode </span><span style="color: #D4D4D4">*</span><span style="color: #E6E6E6"> matinee </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #569CD6">new</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">MatineeNode</span><span style="color: #E6E6E6">(Matinee_0, Interior_Elevator_3);</span></span>
<span class="line"><span style="color: #E6E6E6">BoolNode </span><span style="color: #D4D4D4">*</span><span style="color: #E6E6E6"> set_moved </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #569CD6">new</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">BoolNode</span><span style="color: #E6E6E6">(bMoved, </span><span style="color: #569CD6">true</span><span style="color: #E6E6E6">);</span></span>
<span class="line"><span style="color: #E6E6E6">BoolNode </span><span style="color: #D4D4D4">*</span><span style="color: #E6E6E6"> clear_moved </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #569CD6">new</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">BoolNode</span><span style="color: #E6E6E6">(bMoved, </span><span style="color: #569CD6">false</span><span style="color: #E6E6E6">);</span></span>
<span class="line"><span style="color: #9CDCFE">cmp</span><span style="color: #E6E6E6">-&gt;</span><span style="color: #9CDCFE">onFalse</span><span style="color: #E6E6E6"> </span><span style="color: #D4D4D4">+=</span><span style="color: #E6E6E6"> </span><span style="color: #D4D4D4">&amp;</span><span style="color: #9CDCFE">first_delay</span><span style="color: #E6E6E6">-&gt;</span><span style="color: #9CDCFE">start</span></span>
<span class="line"><span style="color: #9CDCFE">first_delay</span><span style="color: #E6E6E6">-&gt;</span><span style="color: #9CDCFE">onFinished</span><span style="color: #E6E6E6"> </span><span style="color: #D4D4D4">+=</span><span style="color: #E6E6E6"> </span><span style="color: #D4D4D4">&amp;</span><span style="color: #9CDCFE">matinee</span><span style="color: #E6E6E6">-&gt;</span><span style="color: #9CDCFE">play</span><span style="color: #E6E6E6">;</span></span>
<span class="line"><span style="color: #9CDCFE">matinee</span><span style="color: #E6E6E6">-&gt;</span><span style="color: #9CDCFE">onCompleted</span><span style="color: #E6E6E6"> </span><span style="color: #D4D4D4">+=</span><span style="color: #E6E6E6"> </span><span style="color: #D4D4D4">&amp;</span><span style="color: #9CDCFE">second_delay</span><span style="color: #E6E6E6">-&gt;</span><span style="color: #9CDCFE">start</span><span style="color: #E6E6E6">;</span></span>
<span class="line"><span style="color: #9CDCFE">second_delay</span><span style="color: #E6E6E6">-&gt;</span><span style="color: #9CDCFE">onFinished</span><span style="color: #E6E6E6"> </span><span style="color: #D4D4D4">+=</span><span style="color: #E6E6E6"> </span><span style="color: #D4D4D4">&amp;</span><span style="color: #9CDCFE">matinee</span><span style="color: #E6E6E6">-&gt;</span><span style="color: #9CDCFE">reverse</span><span style="color: #E6E6E6">;</span></span>
<span class="line"><span style="color: #9CDCFE">second_delay</span><span style="color: #E6E6E6">-&gt;</span><span style="color: #9CDCFE">onFinished</span><span style="color: #E6E6E6"> </span><span style="color: #D4D4D4">+=</span><span style="color: #E6E6E6"> </span><span style="color: #D4D4D4">&amp;</span><span style="color: #9CDCFE">set_moved</span><span style="color: #E6E6E6">-&gt;</span><span style="color: #9CDCFE">in</span><span style="color: #E6E6E6">;</span></span>
<span class="line"><span style="color: #9CDCFE">set_moved</span><span style="color: #E6E6E6">-&gt;</span><span style="color: #9CDCFE">out</span><span style="color: #E6E6E6"> </span><span style="color: #D4D4D4">+=</span><span style="color: #E6E6E6"> </span><span style="color: #D4D4D4">&amp;</span><span style="color: #9CDCFE">third_delay</span><span style="color: #E6E6E6">-&gt;</span><span style="color: #9CDCFE">start</span><span style="color: #E6E6E6">;</span></span>
<span class="line"><span style="color: #9CDCFE">third</span><span style="color: #E6E6E6">-&gt;</span><span style="color: #9CDCFE">delay</span><span style="color: #E6E6E6">-&gt;</span><span style="color: #9CDCFE">onFinished</span><span style="color: #E6E6E6"> </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #D4D4D4">&amp;</span><span style="color: #9CDCFE">clear_moved</span><span style="color: #E6E6E6">-&gt;</span><span style="color: #9CDCFE">in</span><span style="color: #E6E6E6">;</span></span>
<span class="line"><span style="color: #E6E6E6"> </span></span>
<span class="line"><span style="color: #9CDCFE">RTriggerVolume_0</span><span style="color: #E6E6E6">.</span><span style="color: #9CDCFE">onTouched</span><span style="color: #E6E6E6"> </span><span style="color: #D4D4D4">+=</span><span style="color: #E6E6E6"> </span><span style="color: #D4D4D4">&amp;</span><span style="color: #9CDCFE">cmp</span><span style="color: #E6E6E6">-&gt;</span><span style="color: #9CDCFE">in</span><span style="color: #E6E6E6">;</span></span></code></pre></div></div></figure></p>
<p> При этом, на самом деле программист хотел бы написать этот же код, в таком виде:</p>
 <figure class="shiki cpp"><div class="codeblock"><div class="code"><pre class="shiki slack-dark"><code><span class="line"><span style="color: #569CD6">bool</span><span style="color: #E6E6E6"> bMoved </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #569CD6">false</span><span style="color: #E6E6E6">;</span></span>
<span class="line"><span style="color: #9CDCFE">RTriggerVolume_0</span><span style="color: #E6E6E6">.</span><span style="color: #9CDCFE">Touched</span><span style="color: #E6E6E6"> </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> [</span><span style="color: #9CDCFE">bMoved</span><span style="color: #E6E6E6">]() </span><span style="color: #569CD6">mutable</span><span style="color: #E6E6E6"> {</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">if</span><span style="color: #E6E6E6"> (bMoved)</span></span>
<span class="line"><span style="color: #E6E6E6">        </span><span style="color: #C586C0">return</span><span style="color: #E6E6E6">;</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #DCDCAA">Delay</span><span style="color: #E6E6E6">(some_hardcoded_delay);</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #9CDCFE">Matinee_0</span><span style="color: #E6E6E6">.</span><span style="color: #DCDCAA">Play</span><span style="color: #E6E6E6">(Interior_Elevator_3);</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #DCDCAA">Delay</span><span style="color: #E6E6E6">(another_hardcoded_delay);</span></span>
<span class="line"><span style="color: #E6E6E6">    bMoved </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #569CD6">true</span><span style="color: #E6E6E6">;</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #9CDCFE">Matinee_0</span><span style="color: #E6E6E6">.</span><span style="color: #DCDCAA">Reverse</span><span style="color: #E6E6E6">(Interior_Elevator_3);</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #DCDCAA">Delay</span><span style="color: #E6E6E6">(a_third_hardcoded_delay);</span></span>
<span class="line"><span style="color: #E6E6E6">    bMoved </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #569CD6">false</span><span style="color: #E6E6E6">;</span></span>
<span class="line"><span style="color: #E6E6E6">};</span></span></code></pre></div></div></figure>
<p> Проблема в том, что в C++ сложно нет функции <code>Delay</code>. Файберы могут помочь с её реализацией, но иметь отдельный стек для каждой мелкой сопрограммы может быть дорого. Вместо этого компиляторы визуальных языков могут подсчитать, сколько памяти потребуется для всего скрипта, и выделить ему это весь этот блок целиком. Таким образом, во время выполнения нет аллокаций. Это не особо влияет на скорость, но влияет на то, все функции такого языка могут быть в любой момент прерваны и возобновлены — функции без фреймов на стеке не страдают от того, что кто-то другой перехватывает управление.</p>
<h2><span id="korutiny-v-c">Корутины в C++</span><a href="#korutiny-v-c" class="header-anchor">#</a></h2><p><strong><code>Реализация замаскированным конечным автоматом</code></strong><br>В [13] приведён хак-пример с тем, чтобы реализовать корутины с ограничениями на макросах с помощью объединения цикла и <code>switch</code> (грязный трюк, названный метод Даффа).</p>
<p><strong><code>Реализации корутин в виде платформо-зависимых библиотек</code></strong><br>Серьёзные реализации, использующие трюки на ассемблере или ucontext — [18] и [19] от Malte Skarupke и [20] <code>Boost::Context</code> от Oliver Kowalke. От него же, <a target="_blank" rel="noopener" href="https://www.boost.org/doc/libs/?view=category_concurrent">реализации</a> <code>coroutine2</code>(с выделением стеков на хипе, и first-class продолжениями) и <code>fiber</code> (<a target="_blank" rel="noopener" href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4024.pdf">отличия</a> между ними, файбер здесь — green thread, поток, управляемый диспетчером. Файберы “живут” в одном кернел-треде. Ключевое отличие - корутины передают управление друг другу, буст-файберы — планировщику).</p>
<p>Бекграунд для реализации буст библиотек — переключатели контекста (через примитив <code>call/cc</code> из <code>Boost::Context</code>).</p>
<ul>
<li>fcontext_t - переключение асм-кодом (самое быстрое)</li>
<li>ucontext_t и WinFiber - в <a target="_blank" rel="noopener" href="https://www.boost.org/doc/libs/1_79_0/libs/fiber/doc/html/fiber/overview/implementations__fcontext_t__ucontext_t_and_winfiber.html">10-100 раз</a> более медленное переключение с использованием функций ядра ОС</li>
</ul>
<blockquote><p>Хороший ответ на вопросы из собеседований вроде “зачем может потребоваться писать код на ассемблере в 20XX году?”</p>
</blockquote>
<p><strong><code>Корутины из стандарта C++20</code></strong></p>
<p>В стандарте C++ 20 года реализована минимальная поддержка корутин. Корутины из стандарта, в отличие от <code>boost:coroutine</code> не имеют своего стека (стандарт отделался тем, что заявил “если хотите возвращать управление из вложенных функций — вам нужны файберы, а не корутины”). Также не содержит в std готовых примитивов-паттернов для удобной работы, вариант их реализации можно посмотреть в библиотеке <code>cppcoro</code> [16].</p>
<figure class="shiki cpp"><div class="codeblock"><div class="code"><pre class="shiki slack-dark"><code><span class="line"><span style="color: #569CD6">template</span><span style="color: #E6E6E6">&lt;</span><span style="color: #569CD6">class</span><span style="color: #E6E6E6"> </span><span style="color: #4EC9B0">Visitor</span><span style="color: #E6E6E6">&gt;</span></span>
<span class="line"><span style="color: #569CD6">void</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">f</span><span style="color: #E6E6E6">(</span><span style="color: #4EC9B0">Visitor</span><span style="color: #569CD6">&amp;</span><span style="color: #E6E6E6"> </span><span style="color: #9CDCFE">v</span><span style="color: #E6E6E6">);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">//stackfull-корутина с передачей управления, boost::context</span></span>
<span class="line"><span style="color: #E6E6E6">asymmetric_coroutine&lt;</span><span style="color: #4EC9B0">T</span><span style="color: #E6E6E6">&gt;::</span><span style="color: #4EC9B0">pull_type</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">pull_from</span><span style="color: #E6E6E6">([](asymmetric_coroutine&lt;</span><span style="color: #4EC9B0">T</span><span style="color: #E6E6E6">&gt;::</span><span style="color: #4EC9B0">push_type</span><span style="color: #569CD6">&amp;</span><span style="color: #E6E6E6"> </span><span style="color: #9CDCFE">yield</span><span style="color: #E6E6E6">) {</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #DCDCAA">f</span><span style="color: #E6E6E6">(yield);</span></span>
<span class="line"><span style="color: #E6E6E6">});</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">//stackless-корутина, C++ 20</span></span>
<span class="line"><span style="color: #4EC9B0">generator</span><span style="color: #E6E6E6">&lt;</span><span style="color: #4EC9B0">T</span><span style="color: #E6E6E6">&gt; </span><span style="color: #DCDCAA">pull_from</span><span style="color: #E6E6E6">() {</span></span>
<span class="line"><span style="color: #6A9955">    // yield может быть вызвана только отсюда</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #DCDCAA">f</span><span style="color: #E6E6E6">(</span><span style="color: #D4D4D4">???</span><span style="color: #E6E6E6">);</span></span>
<span class="line"><span style="color: #E6E6E6">}</span></span></code></pre></div></div></figure>
<p>Можно вернуться к примерам с разворачиванием итераторов на <code>daScript</code> и <code>ruby</code>, и попробовать “спроецировать” их на синтаксис stackful-корутин.</p>
<p>В <a target="_blank" rel="noopener" href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3708.pdf">пропозале</a> по добавлению <code>boost::coroutine</code> в стандарт <code>C++</code> приведён как раз аналогичный пример с деревом, с явным продолжением-аргументом он выглядит впечатляюще круто:</p>
<figure class="shiki cpp"><div class="codeblock"><div class="code"><pre class="shiki slack-dark"><code><span class="line"><span style="color: #569CD6">using</span><span style="color: #E6E6E6"> </span><span style="color: #4EC9B0">ContPush</span><span style="color: #E6E6E6"> </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> boost::coroutines::coroutine&lt;std::</span><span style="color: #4EC9B0">string</span><span style="color: #E6E6E6">&gt;::</span><span style="color: #4EC9B0">push_type</span><span style="color: #E6E6E6">;</span></span>
<span class="line"><span style="color: #569CD6">using</span><span style="color: #E6E6E6"> </span><span style="color: #4EC9B0">ContPull</span><span style="color: #E6E6E6"> </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> boost::coroutines::coroutine&lt;std::</span><span style="color: #4EC9B0">string</span><span style="color: #E6E6E6">&gt;::</span><span style="color: #4EC9B0">pull_type</span><span style="color: #E6E6E6">;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #569CD6">void</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">traverse</span><span style="color: #E6E6E6">(</span><span style="color: #4EC9B0">tree</span><span style="color: #569CD6">*</span><span style="color: #E6E6E6"> </span><span style="color: #9CDCFE">n</span><span style="color: #E6E6E6">, </span><span style="color: #4EC9B0">ContPush</span><span style="color: #569CD6">&amp;</span><span style="color: #E6E6E6"> </span><span style="color: #9CDCFE">out</span><span style="color: #E6E6E6">) {</span></span>
<span class="line"><span style="color: #E6E6E6">  </span><span style="color: #C586C0">if</span><span style="color: #E6E6E6"> (</span><span style="color: #9CDCFE">n</span><span style="color: #E6E6E6">-&gt;</span><span style="color: #9CDCFE">left</span><span style="color: #E6E6E6">) </span><span style="color: #DCDCAA">traverse</span><span style="color: #E6E6E6">(</span><span style="color: #9CDCFE">n</span><span style="color: #E6E6E6">-&gt;</span><span style="color: #9CDCFE">left</span><span style="color: #E6E6E6">, out);</span></span>
<span class="line"><span style="color: #E6E6E6">  </span><span style="color: #DCDCAA">out</span><span style="color: #E6E6E6">(</span><span style="color: #9CDCFE">n</span><span style="color: #E6E6E6">-&gt;</span><span style="color: #9CDCFE">value</span><span style="color: #E6E6E6">);</span></span>
<span class="line"><span style="color: #E6E6E6">  </span><span style="color: #C586C0">if</span><span style="color: #E6E6E6">( </span><span style="color: #9CDCFE">n</span><span style="color: #E6E6E6">-&gt;</span><span style="color: #9CDCFE">right</span><span style="color: #E6E6E6">) </span><span style="color: #DCDCAA">traverse</span><span style="color: #E6E6E6">(</span><span style="color: #9CDCFE">n</span><span style="color: #E6E6E6">-&gt;</span><span style="color: #9CDCFE">right</span><span style="color: #E6E6E6">, out);</span></span>
<span class="line"><span style="color: #E6E6E6">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E6E6E6">tree</span><span style="color: #D4D4D4">*</span><span style="color: #E6E6E6"> tree1 </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">testCreateTree1</span><span style="color: #E6E6E6">(), tree2 </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">testCreateTree2</span><span style="color: #E6E6E6">();</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">//трансформация внутреннего итератора во внешний</span></span>
<span class="line"><span style="color: #4EC9B0">ContPull</span><span style="color: #569CD6">&amp;</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">iterator1</span><span style="color: #E6E6E6">([</span><span style="color: #D4D4D4">&amp;</span><span style="color: #E6E6E6">](</span><span style="color: #4EC9B0">ContPush</span><span style="color: #569CD6">&amp;</span><span style="color: #E6E6E6"> </span><span style="color: #9CDCFE">out</span><span style="color: #E6E6E6">) {</span></span>
<span class="line"><span style="color: #E6E6E6">  </span><span style="color: #DCDCAA">traverse</span><span style="color: #E6E6E6">(tree1, out);</span></span>
<span class="line"><span style="color: #E6E6E6">});</span></span>
<span class="line"></span>
<span class="line"><span style="color: #4EC9B0">ContPull</span><span style="color: #569CD6">&amp;</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">iterator2</span><span style="color: #E6E6E6">([</span><span style="color: #D4D4D4">&amp;</span><span style="color: #E6E6E6">](</span><span style="color: #4EC9B0">ContPush</span><span style="color: #569CD6">&amp;</span><span style="color: #E6E6E6"> </span><span style="color: #9CDCFE">out</span><span style="color: #E6E6E6">) {</span></span>
<span class="line"><span style="color: #E6E6E6">  </span><span style="color: #DCDCAA">traverse</span><span style="color: #E6E6E6">(tree2, out);</span></span>
<span class="line"><span style="color: #E6E6E6">});</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">//у boost::coroutines::coroutine&lt;std::string&gt;::pull_type есть iterator</span></span>
<span class="line"><span style="color: #569CD6">bool</span><span style="color: #E6E6E6"> isEqual </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> std::</span><span style="color: #DCDCAA">equal</span><span style="color: #E6E6E6">(std::</span><span style="color: #DCDCAA">begin</span><span style="color: #E6E6E6">(iterator1), std::</span><span style="color: #DCDCAA">end</span><span style="color: #E6E6E6">(iterator1), std::</span><span style="color: #DCDCAA">begin</span><span style="color: #E6E6E6">(itertor2));</span></span></code></pre></div></div></figure>
<p>Stackless-корутины не позволяют таких трюков, так как используют стек вызывающего их кода, но более эффективны.<br>Benchmark из либы <a target="_blank" rel="noopener" href="https://github.com/jamboree/co2">CO2</a>, эмулирующей stackless-корутины (цена вызова корутины):<br><img src="/blog/2550823652/co2_benchmark.png" alt="bench"></p>
<p>Кроме вызова важна также стоимость создания корутины. В случае с <code>CO2</code> корутина — это только синтаксический сахар, и код работает быстро (но в этой библиотеки и нельзя “захватить” переменные на стеке в корутину после восстановления). В корутинах из стандарта C++, генерируется код с аллокацией таких данных в куче, и затем компилятор <strong>может</strong> оптимизировать эти аллокации в случае, если код удастся трансформировать и инлайнить. Сделает он это или нет — неизвестно.</p>
<p>В [14] Malte Skarupke приводит примеры, когда это не работало даже в относительно простых случаях, когда должно быть возможно. Узнать, будет или нет выполнена оптимизация — сложно, а разница в скорости между двумя вариантами — на два порядка, так что часто создавать корутины, полагаясь на то, что будет быстро, без постоянных проверок сгенерированного кода невозможно. Как происходит трансформация кода в LLVM детально рассматривается в [17] (ещё один большой кусок информации, которую должен держать в голове хороший C++ программист). Вдобавок меня пугает то, что такая трансформация требует повторного прохода всех стадий оптимизации (если я правильно понял презентацию, 32:14), время сборки большой программы — больное место языка.</p>
<p>Кому хотелось конкурентности, много лет как запилили себе файберы (чаще всего пулом, чтобы без переаллокаций, и с явным или неявным разбросом по тредам):<br><a target="_blank" rel="noopener" href="https://www.gdcvault.com/play/1022186/Parallelizing-the-Naughty-Dog-Engine">Naughty Dog: Parallelizing the Naughty Dog Engine Using Fibers</a><br><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=v2Q_zHG3vqg">Multithreading the Entire Destiny Engine</a></p>
<p>Где-то дочитав досюда можно почитать туториал [15] по корутинам в C++ 20 и посмотреть на libcoro [16].</p>
<h2><span id="razlichiya-v-terminologii">Различия в терминологии</span><a href="#razlichiya-v-terminologii" class="header-anchor">#</a></h2><p>Стоит отметить различие в определении файберов в различных языках. В некоторых файберы отличаются от генераторов только тем, что имеют стек. Такую таксономию например предлагает стандарт <code>C++ 20</code>. В других языках файберы может отличать ещё и то, что они передают управление не другому файберу, а диспетчеру, который выбирает, кому передать управление дальше.</p>
<p>Например, <code>boost::coroutine</code> называет корутину со стеком не файбером а <code>stackful coroutine</code>, а <code>fiber</code> — это то же + управление через диспетчер. Я тут встану на сторону C++ 20, потому что для корутин со стеком (файберов), которые вдобавок ещё и управляемые диспетчером, и так придумана куча названий. Встречаются:</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.lua.org/pil/9.html">просто корутины</a> (в <code>lua</code> для большей путаницы назвали это так)</li>
<li><a target="_blank" rel="noopener" href="https://github.com/stackless-dev/stackless/wiki/">тасклеты</a> (<code>Stackless Python</code>, вообще богат на термины)</li>
<li><a target="_blank" rel="noopener" href="https://go.dev/doc/effective_go#goroutines">горутины</a> из <code>golang</code> ([22], [23]), причисляемыми в статьях к файберам, отличаются по функционалу, и могут раскидываться по различным тредам планировщиком задач языка (а следовательно, требуют синхронизации доступа к общим ресурсам), так что должны рассматривать отдельно.</li>
<li>зелёные потоки, протопотоки, микропотоки</li>
</ul>
<p>На этом закончу первую половину статьи. Вторая будет про диспетчеры, способы блокирования и комбинирования различных корутин между собой.</p>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"Ov23liG1mZbiQOIdi91X","clientSecret":"e05812685eb741a752982b89dcf6f5b58dc10251","repo":"spiiin.github.io","owner":"spiiin","admin":["spiiin"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script></div></article><div class="pagination"><a class="pagination__link pagination__prev" href="/blog/3774050611/">Позже</a><a class="pagination__link pagination__next" href="/blog/1067581840/">Раньше</a></div></main><footer class="footer metadata"><p class="footer__text">© 2024 spiiin</p><p class="footer__text">Powered by <a class="footer__text__link" href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a class="footer__text__link" href="https://pages.github.com/" target="_blank">Github Page</a></p></footer></div><!-- hexo injector body_end start -->
  <script>
  const CODE_CONFIG = {
    beautify: undefined,
    highlightCopy: undefined,
    highlightLang: undefined,
    highlightHeightLimit: undefined,
    isHighlightShrink: undefined,
    copy: {
      success: 'undefined',
      error: 'undefined',
      noSupport: 'undefined',
    }
  };
  console.log(
    `%c hexo-shiki-plugin %c v1.0.27 %c https://github.com/nova1751/hexo-shiki-plugin`,
    "color: #fff; background: #5f5f5f",
    "color: #fff; background: #80c8f8",
    ""
  );
  </script>
  <!-- hexo injector body_end end --></body></html>