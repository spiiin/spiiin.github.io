<!DOCTYPE html><html lang="ru"><head><meta charset="UTF-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Spiiin's blog | Итераторы, колстеки, корутины</title><meta name="description" content=""><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=PT+Serif&amp;display=swap"><link rel="stylesheet" href="/css/highlights/darkula.css"><link rel="stylesheet" href="/css/main.css"><link rel="search" type="application/opensearchdescription+xml" href="http://spiiin.github.io/atom.xml" title="Spiiin's blog"><script>(function (i, s, o, g, r, a, m) {
  i['GoogleAnalyticsObject'] = r;
  i[r] = i[r] || function () {
    (i[r].q = i[r].q || []).push(arguments)
  }, i[r].l = 1 * new Date();
  a = s.createElement(o),
    m = s.getElementsByTagName(o)[0];
  a.async = 1;
  a.src = g;
  m.parentNode.insertBefore(a, m)
})(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');
ga('create', 'UA-00000000-0', 'auto');
ga('send', 'pageview');</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Spiiin's blog" type="application/atom+xml">
</head><body><div class="container"><header class="main-header"><h1 class="main-header__title uplize"><a class="main-header__title__link" href="/"><img class="header-image" src="/images/favicon.png" width="36" height="36">Spiiin's blog</a></h1><nav class="main-header__nav"><ul class="main-nav"><li class="main-nav__list"><a class="main-nav__list__link" href="/" target="_self">HOME</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/archives/" target="_self">ARCHIVE</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/tags/meta" target="_self">TAGS</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/blog/1" target="_self">ABOUT</a></li></ul></nav></header><main class="container__wrapper"><div class="pagination"><a class="pagination__link pagination__prev" href="/blog/3774050611/">Позже</a><a class="pagination__link pagination__next" href="/blog/1067581840/">Раньше</a></div><article class="article post"><h3 class="article__title">Итераторы, колстеки, корутины</h3><div class="article__date metadata"><div class="post-info">2022/08/01</div></div><div class="article__tags metadata">Tags:
<a class="article__tags__link metadata" href="/tags/dev/">dev</a><a class="article__tags__link metadata" href="/tags/link/">link</a><a class="article__tags__link metadata" href="/tags/dascript/">dascript</a><a class="article__tags__link metadata" href="/tags/cpp/">cpp</a></div><div class="article__body"><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Малость нырнул в кучу статей про асихнронность и корутины в различных языках. Напишу небольшую выдержку (с переводами примеров на <code>daScript</code> там, где актуально), о том, что корутины можно начинать рассматривать как расширение возможностей итераторов и колбеков (функторов), а не с более часто встречающихся генерации последовательностей или реализации паттерна “продюсер-консюмер”.</p>
<p>Ссылки<br> [1] <a href="http://journal.stuffwithstuff.com/2013/01/13/iteration-inside-and-out/" target="_blank" rel="noopener">Iterators Inside and Out</a> - обзор итераторов в различных языках, для каких задач удобны<br> [2] <a href="http://journal.stuffwithstuff.com/2013/02/24/iteration-inside-and-out-part-2/" target="_blank" rel="noopener">Iterators Inside and Out. Part 2</a> - подводка к тому, что абстракция итераторов требует примитивов работы с параллельным кодом<br> [3] <a href="http://journal.stuffwithstuff.com/2013/04/17/well-done/" target="_blank" rel="noopener">Well Done: A Sentinel Value</a> - каналы<br> [4] <a href="https://users.livejournal.com/-winnie/421941.html" target="_blank" rel="noopener">Итератор: внутрь и наружу</a> - совсем краткий вывод из статей [1] и [2], и дополнения в комментариях<br> [5] <a href="https://fprog.ru/lib/ferguson-dwight-call-cc-patterns/" target="_blank" rel="noopener">Паттерны использования «call with current continuation»</a> - перевод статьи про паттерны использования call with continuations в Lisp, среди которых — реализация корутин<br> [6] Журнал “Практика функционального программирования”. Статья “Продолжения на практике” - пример “выворачивания” внутреннего итератора во внешний<br> [7] <a href="https://yehudakatz.com/2010/02/07/the-building-blocks-of-ruby/" target="_blank" rel="noopener">The building blocks of Ruby</a> - особенности блоков в Ruby, нелокальные возвраты из итераторов<br> [8] <a href="https://okmij.org/ftp/Scheme/enumerators-callcc.html" target="_blank" rel="noopener">General ways to traverse collections</a> - обзоры способов обхода коллекций, примеры на Scheme. Итератор с памятью (стейт-машина) в функциональном стиле<br> [9] <a href="https://okmij.org/ftp/papers/LL3-collections-enumerators.txt" target="_blank" rel="noopener">Towards the best collection API</a> - пример “выворачивания” итераторов на Scheme<br> [10] <a href="https://legacy.cs.indiana.edu/~sabry/papers/yield.pdf" target="_blank" rel="noopener">Yield: Mainstream Delimited Continuations</a> - yield в разных языках. <a href="https://en.wikipedia.org/wiki/Delimited_continuation" target="_blank" rel="noopener">Delimited continuations</a><br> [11] <a href="http://pllab.is.ocha.ac.jp/~asai/cw2011tutorial/main-e.pdf" target="_blank" rel="noopener">Introduction to Programming with Shift and Reset</a> - операторы shift и reset<br> [12] <a href="https://probablydance.com/2015/01/11/ideas-for-a-programming-language-part-2-a-more-liberal-call-stack/" target="_blank" rel="noopener">Ideas for a Programming Language Part 2: A more liberal call stack</a> - про недостатки абстракции стека вызовов<br> [13] <a href="https://www.chiark.greenend.org.uk/~sgtatham/coroutines.html" target="_blank" rel="noopener">Coroutines in C</a> - классическая статья про проблемы реализации корутин в C. Трюк с реализацией корутин с помощью <a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%B5%D1%82%D0%BE%D0%B4_%D0%94%D0%B0%D1%84%D1%84%D0%B0" target="_blank" rel="noopener">метода Даффа</a><br> [14] <a href="https://probablydance.com/2021/10/31/c-coroutines-do-not-spark-joy" target="_blank" rel="noopener">C++ Coroutines Do Not Spark Joy</a> - обзор реализации корутин в стандарте C++<br> [15] <a href="https://www.scs.stanford.edu/~dm/blog/c++-coroutines.html#the-promise-object" target="_blank" rel="noopener">My tutorial and take on C++20 coroutines</a> - ещё одна статья про корутины в C++ 20, трюк с хранением результата корутины на стеке через Promise Object<br> [16] <a href="https://github.com/lewissbaker/cppcoro" target="_blank" rel="noopener">CppCoro - A coroutine library for C++</a> - библиотека обёрток над корутинами из стандарта C++<br> [17] <a href="https://www.youtube.com/watch?v=8C8NnE1Dg4A" target="_blank" rel="noopener">CppCon 2016: Gor Nishanov “C++ Coroutines: Under the covers”</a> - доклад про реализацию корутин в стандарте C++, особенности реализации генерируемого кода в LLVM, возможности по оптимизации кода на уровне LLVM. Хорошо для понимания того, когда возможна элиминация выделения памяти. <a href="https://llvm.org/docs/Coroutines.html" target="_blank" rel="noopener">LLVM coroutines</a> - интринсики для корутины в LLVM.<br> [18] <a href="https://probablydance.com/2013/02/20/handmade-coroutines-for-windows/" target="_blank" rel="noopener">Handmade Coroutines for Windows</a> - альтернативные реализации корутин для windows. Раз C++ не даёт прямого доступа к указателю на стек, можно подменить его на ассемблере<br> [19] <a href="https://probablydance.com/2012/11/18/implementing-coroutines-with-ucontext/" target="_blank" rel="noopener">Implementing coroutines with ucontext</a> - реализация корутин через posix ucontext<br> [20] <a href="https://www.boost.org/doc/libs/1_79_0/libs/context/doc/html/index.html" target="_blank" rel="noopener">Boost::Context</a> - реализации переключения контекста из boost. Используют обёртки над posix или платформенные заголовки для переключения контекста, или <a href="https://gcc.gnu.org/wiki/SplitStacks" target="_blank" rel="noopener">ассемблерный трюк</a> из gcc (<a href="https://gcc.gnu.org/legacy-ml/gcc-help/2012-03/msg00395.html" target="_blank" rel="noopener">особенности реализации</a>)<br> [21] <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0534r3.pdf" target="_blank" rel="noopener">call/cc (call-with-current-continuation): A low-level API for stackful context switching</a> - пропозал по добавлению в стандарт c++ функционала call/cc<br> [22] <a href="https://go.dev/doc/effective_go#goroutines" target="_blank" rel="noopener">Goroutines</a> - горутины из go, управляются рантаймом языка. <a href="https://go.dev/tour/concurrency/1" target="_blank" rel="noopener">Tour of Go. Goroutines</a>. Планировщик горутин кооперативный, но “ощущается”, как вытесняющий<br> [23] <a href="https://www.youtube.com/watch?v=YEKjSzIwAdA" target="_blank" rel="noopener">Concurrency Patterns In Go</a> - каналы, оператор select выбора из нескольких каналов<br> [24] <a href="https://www.raywenderlich.com/books/kotlin-coroutines-by-tutorials/v2.0/chapters/5-async-await" target="_blank" rel="noopener">Kotlin coroutines. async/await</a> - многопточные async/await в Kotlin. Идиомы future/promise, async/await/deffered<br> [25] <a href="http://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/" target="_blank" rel="noopener">What Color is Your Function?</a> - проблемы с комбинированием синхронных и асинхронных функций<br> [26] <a href="https://kristoff.it/blog/zig-colorblind-async-await/" target="_blank" rel="noopener">What is Zig’s “Colorblind” Async/Await?</a> - необычный подход Zig, трансформация синхронных функций в асихнронные и наоборот<br> [27] <a href="https://ziglearn.org/chapter-5/" target="_blank" rel="noopener">Zyg’s Async</a> - Async в Zig (<a href="https://ziglang.org/documentation/master/#Async-Functions" target="_blank" rel="noopener">документация</a>)</p>
<h2 id="Внешние-итераторы"><a href="#Внешние-итераторы" class="headerlink" title="Внешние итераторы"></a>Внешние итераторы</h2><p>Внешний итератор — объект, реализующий некоторый интерфейс Iterator (<a href="http://msdn.microsoft.com/en-us/library/system.collections.ienumerable.aspx" target="_blank" rel="noopener">C#</a>, <a href="https://docs.python.org/2/library/stdtypes.html#iterator-types" target="_blank" rel="noopener">Python</a>), у которого есть методы получения первого элемента коллекции (метод у коллекции или свободная функция), перехода на следующий элемент, и проверки на то, есть ли ещё элементы. На шаблонах C++ — явного интерфейса нет, но есть протокол, декларирующий способы описания итератора для своих типов.</p>
<p>Рассматривается в книге Банды Четырёх. В [8] критикуется название за активный суффикс -or, хотя методы итератор зовёт внешний код, предлагается название iteratee. Итераторы в стиле C++ также называют курсорами.</p>
<p><a href="https://dascript.org/doc/reference/language/iterators.html?highlight=iterator" target="_blank" rel="noopener">Итераторы</a> в <code>daScript</code>:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var it &lt;- each ([[<span class="keyword">int</span> <span class="number">1</span>;<span class="number">2</span>;<span class="number">3</span>;<span class="number">4</span>;<span class="number">5</span>]]) <span class="comment">//создание итератора</span></span><br><span class="line">var x : <span class="keyword">int</span></span><br><span class="line"><span class="function"><span class="keyword">while</span> <span class="title">next</span><span class="params">(it, x)</span>      <span class="comment">// получение следующего значения</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"x = &#123;x&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">verify</span><span class="params">(empty(it))</span>      <span class="comment">// функция проверки проверки существования следующего значения</span></span></span><br></pre></td></tr></table></figure>
<p>Часто в языках есть синтаксический сахар для того, чтобы записывать выражение выше как <code>for-each</code> цикл:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var it &lt;- each ([[<span class="keyword">int</span> <span class="number">1</span>;<span class="number">2</span>;<span class="number">3</span>;<span class="number">4</span>;<span class="number">5</span>]])</span><br><span class="line"><span class="keyword">for</span> x in it</span><br><span class="line">  print(<span class="string">"x = &#123;x&#125;\n"</span>)</span><br></pre></td></tr></table></figure></p>
<p>Элегантно решаемая внешним итератором задача:</p>
<p><strong><code>Поиск элемента</code></strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//TT - generic-тип, TT-&amp; - "убрать из определения типа символ ссыслки"</span></span><br><span class="line"><span class="function">def <span class="title">find</span><span class="params">(it: iterator&lt;<span class="keyword">auto</span>(TT)&gt;; value:TT-&amp;)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">for</span> x in it</span></span><br><span class="line"><span class="function">    <span class="keyword">if</span> x </span>== value &#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>Более неаккуратное решение</p>
<p><strong><code>Проверка двух коллекций на равенство</code></strong><br>(и эквивалентные задачи, требуюшие поочередного обращения к двум или более коллекциям — функция <code>zip</code>; итератор выдающий по очереди элементы каждой коллекции)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">is_equal</span><span class="params">(it1, it2: iterator&lt;<span class="keyword">auto</span>(TT)&gt;)</span></span></span><br><span class="line">  var i2: TT-&amp;</span><br><span class="line">  var it2Ended: <span class="keyword">bool</span></span><br><span class="line">  <span class="keyword">for</span> i1 in it1               <span class="comment">//обращение к первому итератору</span></span><br><span class="line">    it2Ended = next(it2, i2)  <span class="comment">//обращение ко второму итератору</span></span><br><span class="line">    <span class="keyword">if</span> !it2Ended || (i1 != i2)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  <span class="keyword">return</span> !next(it2, i2)</span><br></pre></td></tr></table></figure>
<p>Неэлегантный пример</p>
<p><strong><code>Итератор в дереве</code></strong></p>
<p>Рекурсивная функция печати дерева на экран занимает 4 строки<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span></span></span><br><span class="line"><span class="class">  <span class="title">data</span>:</span> <span class="keyword">int</span></span><br><span class="line">  left, right: Tree?</span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">printTree</span><span class="params">(a: Tree?)</span></span></span><br><span class="line">  if a != null</span><br><span class="line">    printTree(a.left)</span><br><span class="line">    print(<span class="string">"&#123;a.data&#125;\n"</span>)</span><br><span class="line">    printTree(a.right)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">let tree = <span class="keyword">new</span> [[ Tree </span><br><span class="line">    data = <span class="number">5</span>,</span><br><span class="line">    left = <span class="keyword">new</span> [[Tree </span><br><span class="line">      data = <span class="number">1</span></span><br><span class="line">    ]],</span><br><span class="line">    right = <span class="keyword">new</span> [[Tree</span><br><span class="line">      data = <span class="number">7</span>,</span><br><span class="line">      right = <span class="keyword">new</span> [[Tree</span><br><span class="line">        data = <span class="number">10</span></span><br><span class="line">      ]]</span><br><span class="line">    ]]</span><br><span class="line">  ]] </span><br><span class="line">printTree(tree)</span><br></pre></td></tr></table></figure></p>
<p>Попробуем написать итератор для дерева. Строительным блоком для кастомных внешних итераторов в <code>daScript</code> служат <a href="https://dascript.org/doc/reference/language/lambdas.html?highlight=lambda#iterators" target="_blank" rel="noopener">лямбда-функции</a>.<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IterateState</span></span></span><br><span class="line"><span class="class">  <span class="title">tree</span>:</span> Tree?</span><br><span class="line">  step: <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">var <span class="built_in">stack</span>: <span class="built_in">array</span>&lt;IterateState?&gt;</span><br><span class="line"><span class="built_in">stack</span> |&gt; push(<span class="keyword">new</span> [[IterateState tree = tree]])</span><br><span class="line">unsafe</span><br><span class="line">  let treeIterator &lt;- @ &lt;| (var current: <span class="keyword">int</span>&amp;) : <span class="keyword">bool</span></span><br><span class="line">    var hasValue = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">while</span> !empty(<span class="built_in">stack</span>) &amp;&amp; !hasValue</span><br><span class="line">      var state = back(<span class="built_in">stack</span>)</span><br><span class="line">      <span class="keyword">if</span> state.step == <span class="number">0</span></span><br><span class="line">        state.step = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (state.tree.left != null)</span><br><span class="line">          push(<span class="built_in">stack</span>, <span class="keyword">new</span> [[IterateState tree = state.tree.left]])</span><br><span class="line">      elif state.step == <span class="number">1</span></span><br><span class="line">        state.step = <span class="number">2</span></span><br><span class="line">        current = state.tree.data</span><br><span class="line">        hasValue = <span class="literal">true</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        pop(<span class="built_in">stack</span>)</span><br><span class="line">        <span class="keyword">if</span> (state.tree.right != null)</span><br><span class="line">          push(<span class="built_in">stack</span>, <span class="keyword">new</span> [[IterateState tree = state.tree.right]])</span><br><span class="line">    <span class="keyword">return</span> hasValue</span><br><span class="line">  <span class="keyword">for</span> v in each(treeIterator)</span><br><span class="line">    print(<span class="string">"&#123;v&#125;\n"</span>)</span><br></pre></td></tr></table></figure></p>
<p>Можно также написать итератор в ООП стиле, определив класс в C++ и перегрузив функцию <a href="https://github.com/GaijinEntertainment/daScript/blob/6f0f1a7025f20cb5a0fc73838e97ba371eb5c263/include/daScript/ast/ast.h#L415" target="_blank" rel="noopener">isIterable</a>, но пример в ООП-стиле есть в [1], он там занимает также занимает 50 строк.</p>
<p>На <code>daScript</code> получилось 26, но всё равно, как, во имя Святой Матери Тьюринга, из четырёх-строчной рекурсивной функции получилась такая каша?</p>
<h2 id="Колстек"><a href="#Колстек" class="headerlink" title="Колстек"></a>Колстек</h2><p>Часть работы в функции <code>printTree</code> за нас выполнила скрытая структура данных, <strong><code>callstack</code></strong>. </p>
<p>Во время рекурсивного первого рекурсивного вызова программа кладёт в стек адрес возврата, и осуществляет вызов этой функции, затем проделывает работу по вызову “полезной нагрузки” (<code>print</code>). После чего в следует второй рекурсивный вызов.</p>
<blockquote><p>Если на собеседовании у вас спросят, какая у вас любимая структура данных, смело отвечайте “стек вызовов”, и рассказывайте про то, как было бы плохо писать программы без него</p>
</blockquote>
<p>Если внимательно посмотреть на структуру функции <code>treeIterator</code>, можно заметить, что она выполняет те же шаги, в той же последовательности!</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">printTree</span><span class="params">(a: Tree?)</span></span></span><br><span class="line"><span class="function">    <span class="comment">//step 0 - кладём в стек адрес возврата, и начинаем новую итерацию вызова функции</span></span></span><br><span class="line"><span class="function">    <span class="title">printTree</span><span class="params">(a.left)</span></span></span><br><span class="line"><span class="function">    <span class="comment">//step 1 - выполняем "полезную нагрузку"</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;a.data&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function">    <span class="comment">//step 2 - кладём в стек адрес возврата</span></span></span><br><span class="line"><span class="function">    <span class="title">printTree</span><span class="params">(a.right)</span></span></span><br><span class="line"><span class="function">    <span class="comment">//невидимый</span></span></span><br><span class="line"><span class="function">    <span class="comment">//step 3 - ..выходим из функции, удаляем из стека верхнее значение, возвращаемся выше по стеку</span></span></span><br></pre></td></tr></table></figure>
<p>Можно заметить небольшое различие на шаге 2 — в реализации <code>printTree</code> сначала происходит второй рекурсивный вызов, и затем возврат из основной функции, а в <code>treeIterator</code> значение сначала удаляется из стека, а затем в него кладётся новое. Это похоже на то, как происходит <a href="https://en.wikipedia.org/wiki/Tail_call" target="_blank" rel="noopener">tail call optimization</a> — вместо того, чтобы положить в стек второе значение, а потом удалить и два верхних значения, мы сразу же удаляем ненужный более адрес возврата, т.е. выполняем step3, еще до step2.</p>
<p>Также функция <code>printTree</code> приостанавливается в точках 0 и 2, на момент вызова подпрограммы, и продолжает выполнение после возврата из подпрограммы. Это вторая крутая возможность, которую предоставляет колстек, и о которой при программировании обычно даже не задумываются. Однако при кастомной реализации итератора мы сталкиваемся с тем, что без каких-либо особых трюков приостановить выполнение функции и продолжить его с того же места невозможно. Вместо этого приходится эмулировать паузы с помощью конечного автомата, реализуемого с помощью цикла и переключения пути выполнения изменением переменной <code>state</code>.</p>
<p>Собственно, большинство идей, связанных с сопрограммами (википедия <a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B0" target="_blank" rel="noopener">напоминает</a>, что ни в коем случае не следует путать их с копрограммами!), так или иначе связаны с тем, чтобы предоставить нам возможность приостанавливать выполнение функции и продолжать его.</p>
<p>Уже может стать понятно, что для этого язык должен каким-либо образом предоставить языковые конструкции, которые позволили бы нам не определять переменную <code>var stack: array&lt;IterateState?&gt;</code> явно, а “отдавать команду” положить туда что-то неявно, в идеале так же прозрачно, как это происходит в момент вызова функции.</p>
<p>Также стоит обратить внимание на то, где выделяется и хранится эта переменная. Здесь это просто локальная переменная, захваченная лямбда-функцией, но перед компилятором при реализации сопрограмм стоит серьёзная задача — где разместить этот “другой” стек. С одной стороны — его можно выделить в куче, чтобы он мог “пережить” область создания итератора, с другой — такая аллокация замедляет создание сопрограмм.</p>
<p>В общем-то, практически все отличия в реализации сопрограмм в разных языках сводятся к тому, чтобы различными способами решить эти вопросы — где и как будут выделяться <em>“другие стеки”</em>, и каким образом к ним можно обращаться из языка. Различных подходов много, и они имеют свои плюсы и минусы. Если с этого момента <em>прояснилось</em>, можно походить по ссылкам, заглянуть, кто что придумал в различных языках. Впрочем, можно снова зависнуть где-нибудь на Лиспе, или языках с ленивыми вычислениями.</p>
<p>Но пока вернёмся к колстеку — стоит ещё раз сравнить функции <code>printTree</code> и более общую <code>treeIterator</code>, и помедитировать на способ, которым сделано обобщение. Такое представление “невидимого” в коде колстека в явном виде называется <a href="https://en.wikipedia.org/wiki/Reification_(computer_science" target="_blank" rel="noopener">реификацией</a>.</p>
<h2 id="Внутренние-итераторы"><a href="#Внутренние-итераторы" class="headerlink" title="Внутренние итераторы"></a>Внутренние итераторы</h2><p>Внутренний итератор — функция-callback, которая передаётся в функцию обхода коллекции.</p>
<p>Итерация разделяет код на 2 части: (1) код ответственный за генерацию серии объектов, и  (2) код, который выполняет над переданным ему объектом некоторую операцию. Для внешних итераторов это (1) тип, который может реализовывать протокол итерации и (2) тело цикла обхода. В этом стиле (2) является главным, он решает, когда запросить следующее значение, или когда прекратить итерации. Внутренние итераторы выворачивают всё наизнанку. Код, который генерирует значения, решает, когда ему вызвать переданный ему колбек.</p>
<p>Внешние функции, перебирающие значения, могут быть реализованы как методы объекта (<a href="https://apidock.com/ruby/Array/each" target="_blank" rel="noopener">array.each</a> в Ruby), или generic-функции (<a href="https://en.cppreference.com/w/cpp/algorithm/ranges/find" target="_blank" rel="noopener">std::find_if</a> в C++)</p>
<p>Элегантно решаемые внутренними итераторами задачи:</p>
<p><strong><code>Итерация по дереву</code></strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">each</span><span class="params">(var tree:Tree?; blk:lambda&lt;(what: <span class="keyword">int</span>):<span class="keyword">void</span>&gt;)</span></span></span><br><span class="line"><span class="function">  <span class="title">if</span> <span class="params">(tree.left != null)</span>  </span>&#123; each(tree.left, blk); &#125;</span><br><span class="line">  invoke(blk, tree.data)</span><br><span class="line">  <span class="keyword">if</span> (tree.right != null) &#123; each(tree.right, blk); &#125;</span><br><span class="line"></span><br><span class="line">tree |&gt; each() &lt;| @(value: <span class="keyword">int</span>)</span><br><span class="line">  print(<span class="string">"&#123;value&#125;\n"</span>)</span><br></pre></td></tr></table></figure>
<p>Отлично, в 3 строчки.</p>
<p><strong><code>Поиск элемента</code></strong></p>
<p>Возьмём общий внутренний генератор <code>map</code> из стандартной-библиотеки <a href="https://github.com/GaijinEntertainment/daScript/blob/master/daslib/functional.das" target="_blank" rel="noopener">functional</a> функцию поиска индекса элемента в массиве по условию (это синтетический пример, в модуле <code>buildin</code> есть более эффективная реализация этой <a href="https://github.com/GaijinEntertainment/daScript/blob/a7c6565f652b56d0eee82b6e27974cdc09f06574/src/builtin/builtin.das#L701" target="_blank" rel="noopener">функции</a>)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">my_find_index_if</span><span class="params">(var arr: iterator&lt;<span class="keyword">auto</span>(TT)&gt; <span class="keyword">explicit</span>; blk:lambda&lt;(what:TT -&amp;):<span class="keyword">auto</span>(QQ)&gt;)</span></span></span><br><span class="line">  for value, i in map(arr, blk), range(INT_MAX)</span><br><span class="line">    <span class="keyword">if</span> value</span><br><span class="line">      <span class="keyword">return</span> i</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//using</span></span><br><span class="line">var it &lt;- each ([[<span class="keyword">int</span> <span class="number">0</span>;<span class="number">1</span>;<span class="number">2</span>;<span class="number">3</span>;<span class="number">4</span>]])</span><br><span class="line">var answer = it |&gt; my_find_index_if &lt;| @(value: <span class="keyword">int</span>)</span><br><span class="line">  print(<span class="string">"check: &#123;value&#125;\n"</span>)</span><br><span class="line">  <span class="keyword">return</span> value &gt; <span class="number">1</span></span><br><span class="line">print(<span class="string">"&#123;answer&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">check: <span class="number">0</span></span><br><span class="line">check: <span class="number">1</span></span><br><span class="line">check: <span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>Здесь таится интересный момент, связанный с прерыванием итерации. Почему функция <code>map</code> не выполнила проверку 3 и 4 элемента массива? Каким именно образом функция <code>map</code> “узнала”, что нужно остановить итерацию?<br>Если вы попробуете реализовать функцию <code>find_index</code> с помощью <code>std::for_each</code> в C++, то стокнётесь в проблемой, что <code>return</code> не может остановить итерацию <code>for_each</code>.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_index</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; myvector, <span class="built_in">std</span>::function&lt;<span class="keyword">bool</span>(<span class="keyword">int</span>)&gt; checker)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> answer = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">bool</span> answerFound = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">auto</span> fn = <span class="built_in">std</span>::for_each(myvector.begin(), myvector.end(), [&amp;](<span class="keyword">int</span> i) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"check:"</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span> (!answerFound) &#123;</span><br><span class="line">            <span class="keyword">if</span>(checker(i)) &#123;</span><br><span class="line">                answer = i;</span><br><span class="line">                answerFound = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">//невозможно остановить выполнение for_each</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; find_index(myvector, [](<span class="keyword">int</span> i) &#123;</span><br><span class="line">      <span class="keyword">return</span> i &gt; <span class="number">1</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; find_index(myvector);</span><br><span class="line"><span class="comment">//Output</span></span><br><span class="line">check:<span class="number">0</span></span><br><span class="line">check:<span class="number">1</span></span><br><span class="line">check:<span class="number">2</span></span><br><span class="line">check:<span class="number">3</span></span><br><span class="line">check:<span class="number">4</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>Что именно лямбда-функции, переданной в <code>for_each</code> выйти из неё? Ответ - колстек, а точнее стекфрейм функций. В момент вызова лямбда-функции внутри for_each он выглядит так:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main</span><br><span class="line">  find_index</span><br><span class="line">    for_each</span><br><span class="line">    стекфрейм for_each</span><br><span class="line">      for_each_lambda</span><br><span class="line">        checker_lambda</span><br></pre></td></tr></table></figure></p>
<p><code>for_each</code> как и любая функция, может выделить себе дополнительную память на стеке под свои нужны, и если <code>for_each_lambda</code> или <code>checker_lambda</code> захотят выйти на уровень выше <code>for_each</code>, им нужно уметь разкручивать стек (скорее всего, конкретно для for_each там ничего нет, но сама необходимость раскрутки всего, что находится между функциями разного уровня на стеке блокирует возможность выхода)</p>
<p>Конечно, раскручивать стек в C++ умеют исключения, но… просто посмотрите на этот код и никогда так не делайте:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_index</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; myvector, <span class="built_in">std</span>::function&lt;<span class="keyword">bool</span>(<span class="keyword">int</span>)&gt; checker)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">auto</span> fn = <span class="built_in">std</span>::for_each(myvector.begin(), myvector.end(), [&amp;](<span class="keyword">int</span> i) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"check:"</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">if</span>(checker(i)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> i; <span class="comment">//"выбрасываем" ответ из foreach</span></span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (<span class="keyword">int</span> throwedAnswer) &#123;</span><br><span class="line">        <span class="keyword">return</span> throwedAnswer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Возможность раскручивать стек называется <code>non-local returns</code> и присутствует в языках типа <code>Ruby</code> (пример в [1]) или <code>Kotlin</code> [24]:<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">val</span> value = <span class="number">3</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="string">""</span></span><br><span class="line">list.forEach &#123; </span><br><span class="line">  result += <span class="string">"<span class="variable">$it</span>"</span></span><br><span class="line">  <span class="keyword">if</span> (it == value)</span><br><span class="line">    <span class="keyword">return</span><span class="symbol">@forEach</span> <span class="comment">//выход из foreach</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//result="123"</span></span><br></pre></td></tr></table></figure></p>
<p>Другой более универсальный подход, реализованный в <code>daScript</code> и других языках с поддержкой генераторов — приостанавливать выполнение <code>map/for_each</code> и передавать промежуточные результаты “вовне”, с возможностью по желанию прекратить приостановленную итерацию на уровень выше (генераторы также известны как “елды” среди добравшихся до Unity артистов).</p>
<p>Совсем нехороший пример</p>
<p><strong><code>Проверка двух коллекций на равенство</code></strong></p>
<p>Без задействования генераторов, корутин, тредов или продолжений, или других способов приостановить функцию, не пишется. Мешают, как и в предыдущем примере, всё те же стекфреймы в колстеке. Но если в примере с раннимм выходом из внутреннего итератора удавалось хотя бы выкрутиться хаком и “выпрыгнуть” с помощью исключений, необратимо раскрутив стек, то здесь для приостановки каждой из двух функций-колбеков нужно хранить оба состояния обеих функций.</p>
<h2 id="Генераторы"><a href="#Генераторы" class="headerlink" title="Генераторы"></a>Генераторы</h2><p>Генераторы — это возобновляемые функции. Возвращаемый тип генератора — итератор (гибрид между внутренним и внешним)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">let gen &lt;- generator&lt;<span class="keyword">int</span>&gt;() &lt;| $()</span><br><span class="line">  <span class="function"><span class="keyword">for</span> t in <span class="title">range</span><span class="params">(<span class="number">0</span>,<span class="number">10</span>)</span></span></span><br><span class="line"><span class="function">    yield t</span></span><br><span class="line"><span class="function">  <span class="keyword">return</span> <span class="literal">false</span></span></span><br></pre></td></tr></table></figure>
<p><code>map</code>, как и большинство функций из модуля <code>functional</code> в <code>daScript</code>, возвращают генераторы, так что с помощью неё должно быть возможно (хотя и не нужно) реализовать проверку двух коллекций на равенство, недоступную для внутренних итераторов в языках без поддержки генераторов:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">is_equal</span><span class="params">(var it1, it2: iterator&lt;<span class="keyword">auto</span>(TT)&gt;)</span></span></span><br><span class="line"><span class="function">  unsafe</span></span><br><span class="line"><span class="function">    var equalResult </span>= <span class="literal">true</span></span><br><span class="line">    <span class="comment">//один из генераторов возвращает значения из коллекции</span></span><br><span class="line">    var aGenerator &lt;- it1 |&gt; <span class="built_in">map</span> &lt;| @(aValue:TT-&amp;)</span><br><span class="line">      <span class="keyword">return</span> aValue</span><br><span class="line">    //второй генератор берёт значение из второй коллекции и сравниваем со значением из другого генератора</span><br><span class="line">    //лямбда-функция захватывает первый генератор для получения значений из него</span><br><span class="line">    var bGenerator &lt;- it2 |&gt; <span class="built_in">map</span> &lt;| @ [[&amp;aGenerator]](bValue:TT-&amp;)</span><br><span class="line">      var aValue : TT-&amp;</span><br><span class="line">      <span class="keyword">if</span> !next(aGenerator, aValue)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      print("&#123;bValue&#125; &#123;aValue&#125;\n")</span><br><span class="line">      <span class="keyword">return</span> bValue == aValue</span><br><span class="line">    //продолжаем брать из генераторов значения, пока она эквивалентны</span><br><span class="line">    <span class="keyword">while</span> equalResult &amp;&amp; next(bGenerator, equalResult)</span><br><span class="line">      pass</span><br><span class="line">    //коллекции эквивалентны, если оба итератора обработали все значения</span><br><span class="line">    var aLast : <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">return</span> !next(aGenerator, aLast) &amp;&amp; empty(bGenerator)</span><br></pre></td></tr></table></figure>
<p><strong><code>Двунаправленные генераторы</code></strong></p>
<p><code>Python</code> поддерживает также <a href="https://docs.python.org/3/reference/expressions.html#generator.send" target="_blank" rel="noopener">отправку</a> данных генератору из вызываюшего кода</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">double_inputs</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="meta">... </span>        x = <span class="keyword">yield</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">yield</span> x * <span class="number">2</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gen = double_inputs()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(gen)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gen.send(<span class="number">10</span>)</span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(gen)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gen.send(<span class="number">6</span>)</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>
<h2 id="Разворачивание-итераторов"><a href="#Разворачивание-итераторов" class="headerlink" title="Разворачивание итераторов"></a>Разворачивание итераторов</h2><p>Теперь рассмотрим возможность “выворачивания” итераторов. К примеру, у нас есть “красивая” версия внутреннего итератора <code>each</code> для дерева, и функция сравнения, принимающая внешние итераторы, в которую хочется передать итератор обхода дерева.</p>
<p>Для начала посмотрим, как можно передать значения из лямбда функции “наружу”, с помощью захвата в замыкание (closure) лямбда-функции:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">to_array</span><span class="params">(var tree : Tree?)</span></span></span><br><span class="line"><span class="function">  unsafe</span></span><br><span class="line"><span class="function">    var arr: <span class="built_in">array</span>&lt;<span class="keyword">int</span>&gt;</span></span><br><span class="line"><span class="function">    <span class="comment">//захватываем arr в замыкание по ссылке</span></span></span><br><span class="line">    each(tree) &lt;| @[[&amp;arr]](value: int)</span><br><span class="line">      arr |&gt; push(value)</span><br><span class="line">    <span class="keyword">return</span> &lt;- arr</span><br></pre></td></tr></table></figure>
<p>Функция накапливает все значения в переменной <code>arr</code> и возвращает полностью собранный массив. Следуюшим шагом попробуем избавиться от этого накопления и вернуть управление вызывающему коду, как только будет получено следующее значение из <code>each</code>. Но тут возникает следующая проблема. Если <code>each</code> не задизайнена так, чтобы её можно было останавливать, то её и невозможно будет остановить из колбека. Т.е. нам нужна другая функция <code>each_async</code>, которая будет возращать значение через генератор <code>yield</code>.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">each_async</span><span class="params">(var tree:Tree?)</span> : iterator&lt;<span class="keyword">int</span>&gt;</span></span><br><span class="line"><span class="function">  unsafe</span></span><br><span class="line">    var gen &lt;- generator&lt;int&gt; [[&lt;-tree]] () &lt;| $ ()</span><br><span class="line">      <span class="keyword">if</span> tree.left != null</span><br><span class="line">        <span class="keyword">for</span> newVal in each_async(tree.left)</span><br><span class="line">          yield newVal</span><br><span class="line">      yield tree.data</span><br><span class="line">      <span class="keyword">if</span> tree.right != null</span><br><span class="line">        <span class="keyword">for</span> newVal in each_async(tree.right)</span><br><span class="line">          yield newVal</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">return</span> &lt;- gen</span><br><span class="line"></span><br><span class="line">var eq = is_equal(each_async(tree1), each_async(tree2))</span><br></pre></td></tr></table></figure>
<p>Чуть менее компакто, чем первоначальная версия, за счёт того, что из вложенных генераторов приходится доставать данные с помощью дополнительных циклов обхода (<code>yield</code> должно возвращать <code>int</code>, а вложенные генератор возвращает <code>iterator&lt;int&gt;</code>, и которого нужно достать данные для выдачи внешнему генератору).</p>
<p><code>Python</code> и некоторые другие языки поддерживают <strong><code>делегацию генераторов</code></strong> — синтаксический сахар, который позволяет избежать написания таких циклов<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">concat</span><span class="params">(a, b)</span>:</span></span><br><span class="line">  <span class="comment">#for item in walkFirst(a): yield item</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">#"берём значение из генератора и передаём дальше</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="keyword">from</span> walkFirst(a)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">walkFirst</span><span class="params">(a)</span>:</span></span><br><span class="line">  <span class="keyword">for</span> item <span class="keyword">in</span> a: <span class="keyword">yield</span> item</span><br></pre></td></tr></table></figure></p>
<p>Но тут есть важный момент, снова возвращающий нас к колстекам. Делегация генераторов — это просто синтаксический сахар, но мы не можем написать возврат значения из вложенных функций, не прокидывая эту делегацию через каждый уровень вложенности. Чтобы полноценно выйти на несколько уровней вверх, в затем вернуться, нам потребуется структура, которая реифицирует не один уровень стека, а весь стек. Следующий пример на <code>ruby</code> показывает такую структуру.</p>
<h2 id="Файберы"><a href="#Файберы" class="headerlink" title="Файберы"></a>Файберы</h2><p>В [2] есть пример разворачивания итераторов из <code>Ruby</code>:</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyEnumerator</span></span></span><br><span class="line">  <span class="keyword">include</span> Enumerable</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(obj)</span></span></span><br><span class="line">    @fiber = Fiber.new <span class="keyword">do</span>  <span class="comment"># Spin up a new fiber.</span></span><br><span class="line">      obj.each <span class="keyword">do</span> <span class="params">|value|</span>  <span class="comment"># Run the internal iterator on it.</span></span><br><span class="line">        Fiber.<span class="keyword">yield</span>(value) <span class="comment"># When it yields a value, suspend</span></span><br><span class="line">                          <span class="comment"># the fiber and emit the value.</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      raise StopIteration  <span class="comment"># Then signal that we're done.</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">next</span></span></span><br><span class="line">    @fiber.resume          <span class="comment"># When the next value is requested,</span></span><br><span class="line">                           <span class="comment"># resume the fiber.</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><code>Yield</code> прямо из <code>each</code> во внешнюю функцию! Если обратиться к предыдущим замечаниям про колстеки, то здесь будет:</p>
<ul>
<li><code>each</code> для дерева создаёт стек, к котором хранит адреса возвратом рекурсивных вызовов</li>
<li>метод <code>next</code> полностью “замораживает” этот стек, и переключается на другой, в управляюшем коде.</li>
</ul>
<p>Так что <code>Fiber</code> здесь — структура, которая реифицирует не только фрейм стека, как генераторы, но весь стек полностью.<br><code>Файберы</code> имеют свой стек и копии локальных переменных. Один выполняются в одном потоке, и передача управления между ними управляется кодом пользователя — пока один файбер не передаст управление следующему, переключения не будет.</p>
<p>Файберы — своеобразная “точка связи” итерации с параллелизмом.</p>
<h2 id="Функции-без-стекфрейма"><a href="#Функции-без-стекфрейма" class="headerlink" title="Функции без стекфрейма"></a>Функции без стекфрейма</h2><p>В [12] рассматриваются альтернативы хранению временных переменных функции в стеке. В качестве примера рассматривается создание языков для визуального программирования типа <code>Kismet</code>/<code>Blueprint</code> из Unreal. Каждая функция-строительный кирпич заранее выделяет необходимую ей память и просто использует её повторно, если вызывается вновь. Если нужно вызвать функцию дважды — выделяется два блока памяти. Преимущество такого подхода — можно легко связывать цепочки функций вида “пойти в точку А, подождать секунду, затем проиграть анимацию и звук одновременно”.</p>
<p>Чтобы создать код связи нод на C++, может потребоваться код вида:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> bMoved = <span class="literal">false</span>;</span><br><span class="line">CompareBoolNode * cmp = <span class="keyword">new</span> CompareBoolNode(bMoved);</span><br><span class="line">DelayNode * first_delay = <span class="keyword">new</span> DelayNode(some_hardcoded_number);</span><br><span class="line">DelayNode * second_delay = <span class="keyword">new</span> DelayNode(another_hardcoded_number);</span><br><span class="line">DelayNode * third_delay = <span class="keyword">new</span> DelayNode(a_third_hardcoded_number);</span><br><span class="line">MatineeNode * matinee = <span class="keyword">new</span> MatineeNode(Matinee_0, Interior_Elevator_3);</span><br><span class="line">BoolNode * set_moved = <span class="keyword">new</span> BoolNode(bMoved, <span class="literal">true</span>);</span><br><span class="line">BoolNode * clear_moved = <span class="keyword">new</span> BoolNode(bMoved, <span class="literal">false</span>);</span><br><span class="line">cmp-&gt;onFalse += &amp;first_delay-&gt;start</span><br><span class="line">first_delay-&gt;onFinished += &amp;matinee-&gt;play;</span><br><span class="line">matinee-&gt;onCompleted += &amp;second_delay-&gt;start;</span><br><span class="line">second_delay-&gt;onFinished += &amp;matinee-&gt;reverse;</span><br><span class="line">second_delay-&gt;onFinished += &amp;set_moved-&gt;in;</span><br><span class="line">set_moved-&gt;out += &amp;third_delay-&gt;start;</span><br><span class="line">third-&gt;delay-&gt;onFinished = &amp;clear_moved-&gt;in;</span><br><span class="line"> </span><br><span class="line">RTriggerVolume_0.onTouched += &amp;cmp-&gt;in;</span><br></pre></td></tr></table></figure></p>
<p> При этом, на самом деле программист хотел бы написать этот же код, в таком виде:</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> bMoved = <span class="literal">false</span>;</span><br><span class="line">RTriggerVolume_0.Touched = [bMoved]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (bMoved)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    Delay(some_hardcoded_delay);</span><br><span class="line">    Matinee_0.Play(Interior_Elevator_3);</span><br><span class="line">    Delay(another_hardcoded_delay);</span><br><span class="line">    bMoved = <span class="literal">true</span>;</span><br><span class="line">    Matinee_0.Reverse(Interior_Elevator_3);</span><br><span class="line">    Delay(a_third_hardcoded_delay);</span><br><span class="line">    bMoved = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p> Проблема в том, что в C++ сложно нет функции <code>Delay</code>. Файберы могут помочь с её реализацией, но иметь отдельный стек для каждой мелкой сопрограммы может быть дорого. Вместо этого компиляторы визуальных языков могут подсчитать, сколько памяти потребуется для всего скрипта, и выделить ему это весь этот блок целиком. Таким образом, во время выполнения нет аллокаций. Это не особо влияет на скорость, но влияет на то, все функции такого языка могут быть в любой момент прерваны и возобновлены — функции без фреймов на стеке не страдают от того, что кто-то другой перехватывает управление.</p>
<h2 id="Корутины-в-C"><a href="#Корутины-в-C" class="headerlink" title="Корутины в C++"></a>Корутины в C++</h2><p><strong><code>Реализация замаскированным конечным автоматом</code></strong><br>В [13] приведён хак-пример с тем, чтобы реализовать корутины с ограничениями на макросах с помощью объединения цикла и <code>switch</code> (грязный трюк, названный [метод Дафа]).</p>
<p><strong><code>Реализации корутин в виде платформо-зависимых библиотек</code></strong><br>Серьёзные реализации, использующие трюки на ассемблере или ucontext — [18] и [19] от Malte Skarupke и [20] <code>Boost::Context</code> от Oliver Kowalke. От него же, <a href="https://www.boost.org/doc/libs/?view=category_concurrent" target="_blank" rel="noopener">реализации</a> <code>coroutine2</code>(с выделением стеков на хипе, и first-class продолжениями) и <code>fiber</code> (<a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4024.pdf" target="_blank" rel="noopener">отличия</a> между ними, файбер здесь — green thread, поток, управляемый диспетчером. Файберы “живут” в одном кернел-треде. Ключевое отличие - корутины передают управление друг другу, буст-файберы — планировщику).</p>
<p>Бекграунд для реализации буст библиотек — переключатели контекста (через примитив <code>call/cc</code> из <code>Boost::Context</code>).</p>
<ul>
<li>fcontext_t - переключение асм-кодом (самое быстрое)</li>
<li>ucontext_t и WinFiber - в <a href="https://www.boost.org/doc/libs/1_79_0/libs/fiber/doc/html/fiber/overview/implementations__fcontext_t__ucontext_t_and_winfiber.html" target="_blank" rel="noopener">10-100 раз</a> более медленное переключение с использованием функций ядра ОС</li>
</ul>
<blockquote><p>Хороший ответ на вопросы из собеседований вроде “зачем может потребоваться писать код на ассемблере в 20XX году?”</p>
</blockquote>
<p><strong><code>Корутины из стандарта C++20</code></strong></p>
<p>В стандарте C++ 20 года реализована минимальная поддержка корутин. Корутины из стандарта, в отличие от <code>boost:coroutine</code> не имеют своего стека (стандарт отделался тем, что заявил “если хотите возвращать управление из вложенных функций — вам нужны файберы, а не корутины”). Также не содержит в std готовых примитивов-паттернов для удобной работы, вариант их реализации можно посмотреть в библиотеке <code>cppcoro</code> [16].</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Visitor</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">f</span>(<span class="title">Visitor</span>&amp; <span class="title">v</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//stackfull-корутина с передачей управления, boost::context</span></span><br><span class="line">asymmetric_coroutine&lt;T&gt;::<span class="function">pull_type <span class="title">pull_from</span><span class="params">([](asymmetric_coroutine&lt;T&gt;::push_type&amp; yield) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    f(yield);</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//stackless-корутина, C++ 20</span></span><br><span class="line"><span class="function">generator&lt;T&gt; <span class="title">pull_from</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// yield может быть вызвана только отсюда</span></span><br><span class="line">    f(???);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Можно вернуться к примерам с разворачиванием итераторов на <code>daScript</code> и <code>ruby</code>, и попробовать “спроецировать” их на синтаксис stackful-корутин.</p>
<p>В <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3708.pdf" target="_blank" rel="noopener">пропозале</a> по добавлению <code>boost::coroutine</code> в стандарт <code>C++</code> приведён как раз аналогичный пример с деревом, с явным продолжением-аргументом он выглядит впечатляюще круто:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> ContPush = boost::coroutines::coroutine&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;::push_type;</span><br><span class="line"><span class="keyword">using</span> ContPull = boost::coroutines::coroutine&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;::pull_type;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(tree* n, ContPush&amp; out)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n-&gt;left) traverse(n-&gt;left, out);</span><br><span class="line">  out(n-&gt;value);</span><br><span class="line">  <span class="keyword">if</span>( n-&gt;right) traverse(n-&gt;right, out);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tree* tree1 = testCreateTree1(), tree2 = testCreateTree2();</span><br><span class="line"></span><br><span class="line"><span class="comment">//трансформация внутреннего итератора во внешний</span></span><br><span class="line"><span class="function">ContPull&amp; <span class="title">iterator1</span><span class="params">([&amp;](ContPush&amp; out) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  traverse(tree1, out);</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ContPull&amp; <span class="title">iterator2</span><span class="params">([&amp;](ContPush&amp; out) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  traverse(tree2, out);</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//у boost::coroutines::coroutine&lt;std::string&gt;::pull_type есть iterator</span></span><br><span class="line"><span class="keyword">bool</span> isEqual = <span class="built_in">std</span>::equal(<span class="built_in">std</span>::begin(iterator1), <span class="built_in">std</span>::end(iterator1), <span class="built_in">std</span>::begin(itertor2));</span><br></pre></td></tr></table></figure>
<p>Stackless-корутины не позволяют таких трюков, так как используют стек вызывающего их кода, но более эффективны.<br>Benchmark из либы <a href="https://github.com/jamboree/co2" target="_blank" rel="noopener">CO2</a>, эмулирующей stackless-корутины (цена вызова корутины):<br><img src="/blog/2550823652/co2_benchmark.png" alt="bench"></p>
<p>Кроме вызова важна также стоимость создания корутины. В случае с <code>CO2</code> корутина — это только синтаксический сахар, и код работает быстро (но в этой библиотеки и нельзя “захватить” переменные на стеке в корутину после восстановления). В корутинах из стандарта C++, генерируется код с аллокацией таких данных в куче, и затем компилятор <strong>может</strong> оптимизировать эти аллокации в случае, если код удастся трансформировать и инлайнить. Сделает он это или нет — неизвестно.</p>
<p>В [14] Malte Skarupke приводит примеры, когда это не работало даже в относительно простых случаях, когда должно быть возможно. Узнать, будет или нет выполнена оптимизация — сложно, а разница в скорости между двумя вариантами — на два порядка, так что часто создавать корутины, полагаясь на то, что будет быстро, без постоянных проверок сгенерированного кода невозможно. Как происходит трансформация кода в LLVM детально рассматривается в [17] (ещё один большой кусок информации, которую должен держать в голове хороший C++ программист). Вдобавок меня пугает то, что такая трансформация требует повторного прохода всех стадий оптимизации (если я правильно понял презентацию, 32:14), время сборки большой программы — больное место языка.</p>
<p>Кому хотелось конкурентности, много лет как запилили себе файберы (чаще всего пулом, чтобы без переаллокаций, и с явным или неявным разбросом по тредам):<br><a href="https://www.gdcvault.com/play/1022186/Parallelizing-the-Naughty-Dog-Engine" target="_blank" rel="noopener">Naughty Dog: Parallelizing the Naughty Dog Engine Using Fibers</a><br><a href="https://www.youtube.com/watch?v=v2Q_zHG3vqg" target="_blank" rel="noopener">Multithreading the Entire Destiny Engine</a></p>
<p>Где-то дочитав досюда можно почитать туториал [15] по корутинам в C++ 20 и посмотреть на libcoro [16].</p>
<h2 id="Различия-в-терминологии"><a href="#Различия-в-терминологии" class="headerlink" title="Различия в терминологии"></a>Различия в терминологии</h2><p>Стоит отметить различие в определении файберов в различных языках. В некоторых файберы отличаются от генераторов только тем, что имеют стек. Такую таксономию например предлагает стандарт <code>C++ 20</code>. В других языках файберы может отличать ещё и то, что они передают управление не другому файберу, а диспетчеру, который выбирает, кому передать управление дальше.</p>
<p>Например, <code>boost::coroutine</code> называет корутину со стеком не файбером а <code>stackful coroutine</code>, а <code>fiber</code> — это то же + управление через диспетчер. Я тут встану на сторону C++ 20, потому что для корутин со стеком (файберов), которые вдобавок ещё и управляемые диспетчером, и так придумана куча названий. Встречаются:</p>
<ul>
<li><a href="http://www.lua.org/pil/9.html" target="_blank" rel="noopener">просто корутины</a> (в <code>lua</code> для большей путаницы назвали это так)</li>
<li><a href="https://github.com/stackless-dev/stackless/wiki/" target="_blank" rel="noopener">тасклеты</a> (<code>Stackless Python</code>, вообще богат на термины)</li>
<li><a href="https://go.dev/doc/effective_go#goroutines" target="_blank" rel="noopener">горутины</a> из <code>golang</code> ([22], [23]), причисляемыми в статьях к файберам, отличаются по функционалу, и могут раскидываться по различным тредам планировщиком задач языка (а следовательно, требуют синхронизации доступа к общим ресурсам), так что должны рассматривать отдельно.</li>
<li>зелёные потоки, протопотоки, микропотоки</li>
</ul>
<p>На этом закончу первую половину статьи. Вторая будет про диспетчеры, способы блокирования и комбинирования различных корутин между собой.</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script></div></article><div class="pagination"><a class="pagination__link pagination__prev" href="/blog/3774050611/">Позже</a><a class="pagination__link pagination__next" href="/blog/1067581840/">Раньше</a></div></main><footer class="footer metadata"><p class="footer__text">© 2022 spiiin</p><p class="footer__text">Powered by <a class="footer__text__link" href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a class="footer__text__link" href="https://pages.github.com/" target="_blank">Github Page</a></p></footer></div></body></html>