<!DOCTYPE html><html lang="ru"><head><meta charset="UTF-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Spiiin's blog | ECS для казуальных игр</title><meta name="description" content="&lt;p&gt;Чем может быть полезно применение паттерна &lt;strong&gt;&lt;code&gt;Entity Component System&lt;/code&gt;&lt;/strong&gt; в казуальных играх.&lt;/p&gt;
&lt;p&gt;TL,DR:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Уменьшается связность между классами&lt;/li&gt;
&lt;li&gt;DOD упрощает управление параметрами из нескольких мест&lt;/li&gt;
&lt;li&gt;Упрощается написание читов&lt;/li&gt;
&lt;li&gt;Возможно, игра будет работать быстрее&lt;/li&gt;
&lt;/ul&gt;"><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=PT+Serif&amp;display=swap"><link rel="stylesheet" href="/css/highlights/darkula.css"><link rel="stylesheet" href="/css/main.css"><link rel="search" type="application/opensearchdescription+xml" href="http://spiiin.github.io/atom.xml" title="Spiiin's blog"><script>(function (i, s, o, g, r, a, m) {
  i['GoogleAnalyticsObject'] = r;
  i[r] = i[r] || function () {
    (i[r].q = i[r].q || []).push(arguments)
  }, i[r].l = 1 * new Date();
  a = s.createElement(o),
    m = s.getElementsByTagName(o)[0];
  a.async = 1;
  a.src = g;
  m.parentNode.insertBefore(a, m)
})(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');
ga('create', 'UA-00000000-0', 'auto');
ga('send', 'pageview');</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Spiiin's blog" type="application/atom+xml">
</head><body><div class="container"><header class="main-header"><h1 class="main-header__title uplize"><a class="main-header__title__link" href="/"><img class="header-image" src="/images/favicon.png" width="36" height="36">Spiiin's blog</a></h1><nav class="main-header__nav"><ul class="main-nav"><li class="main-nav__list"><a class="main-nav__list__link" href="/" target="_self">HOME</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/archives/" target="_self">ARCHIVE</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/tags/meta" target="_self">TAGS</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/blog/1" target="_self">ABOUT</a></li></ul></nav></header><main class="container__wrapper"><div class="pagination"><a class="pagination__link pagination__prev" href="/blog/413676133/">Позже</a><a class="pagination__link pagination__next" href="/blog/381238762/">Раньше</a></div><article class="article post"><h3 class="article__title">ECS для казуальных игр</h3><div class="article__date metadata"><div class="post-info">2021/01/07</div></div><div class="article__tags metadata">Tags:
<a class="article__tags__link metadata" href="/tags/gamedev/">gamedev</a><a class="article__tags__link metadata" href="/tags/dev-method/">dev_method</a><a class="article__tags__link metadata" href="/tags/ecs/">ecs</a></div><div class="article__body"><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Чем может быть полезно применение паттерна <strong><code>Entity Component System</code></strong> в казуальных играх.</p>
<p>TL,DR:</p>
<ul>
<li>Уменьшается связность между классами</li>
<li>DOD упрощает управление параметрами из нескольких мест</li>
<li>Упрощается написание читов</li>
<li>Возможно, игра будет работать быстрее</li>
</ul>
<a id="more"></a>
<h2 id="Уменьшается-связность-между-классами"><a href="#Уменьшается-связность-между-классами" class="headerlink" title="Уменьшается связность между классами"></a>Уменьшается связность между классами</h2><p>Это первое и самое важное, одного этого пункта хватило бы.</p>
<p>Геймдев не особо богат на архитектурные паттерны. Часто, высший уровень абстракции игровой логики (описание сцены и геймплея) - это классы <strong><code>&quot;поле&quot;</code></strong> (<em>уровень/сцена/зона/whatever</em>), и наследники <strong><code>&quot;игровых объектов&quot;</code></strong>. Часто встречаются ещё какие-нибудь <strong><code>&quot;фабрики эффектов&quot;</code></strong>, содержащиеся методы для запуска всего, чего только можно.</p>
<p>Первая освещаемая в <a href="/blog/381238762/" title="презентациях по ECS">презентациях по ECS</a>  проблема - это то, что игровых объектов очень много, разных типов, со взаимно-пересекающейся функциональностью.</p>
<p>К примеру, в <code>RTS</code> это могут быть юниты, герои, здания, ландшафт, снаряды. В <code>match-3</code> - множество отдельных типов клеток, фишек, существующих вне игровых клеток и между клетками механик, бустеры и бонусные фишки. В простом <code>скролл-шутере</code> – игрок, враги, стены и снаряды. В <a href="https://www.gamedevs.org/uploads/data-driven-game-object-system.pdf" target="_blank" rel="noopener">докладе о разработке Dungeon Siege</a> упоминается о &gt;7300 уникальных типов объектов. </p>
<p>Выстроить такое количество объектов в иерархию наследования практически невозможно, выделить несколько простых базовых классов, от которых наследуются все объекты – тоже. Возможное решение проблемы – выделять не базовые классы, а компоненты, из которых как из кирпичиков будут составлены объекты.</p>
<p>При таком подходе, судя по различным докладам, в зависимости от игры, может получиться 50-150 компонентов, которыми возможно описать все типы игровых объектов.</p>
<hr>
<p>Вторая проблема, более серьёзная с точки зрения архитектуры игры - <strong>куда писать код логики игры?</strong>.<br>Паттерн ECS обещает, что ответ будет чуть более простым, чем при использовании ООП - в системы, отвечающие за необходимый функционал.</p>
<p>Несколько примеров из одной match-3 игры, в которой используются компоненты для описания игровых фишек, но нет систем.</p>
<p>Реалзиция механика спецфишки “самолёт” (типа <a href="https://youtu.be/PqF3uKDgLsA?t=412" target="_blank" rel="noopener">такого</a>) в ней выглядит как показано ниже.</p>
<p>Самолёт запускается методом:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createAirplaneExplosion</span><span class="params">(airplaneBlock* plane, match3cell* parentCell, <span class="keyword">const</span> explosionSpineSettings&amp; settings)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>Сам самолёт состоит из компонентов:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">airplaneBlock</span> :</span></span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">public</span> customPieceWithVisualFeedback, <span class="comment">//имеет анимацию</span></span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">public</span> customPieceWithCombination,    <span class="comment">//может участвовать в комбинациях</span></span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">public</span> customPieceDestructive,        <span class="comment">//может быть разрушен</span></span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">public</span> customPieceWithObjective,      <span class="comment">//может быть целью уровня</span></span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">public</span> customPieceWithDynamicLayer    <span class="comment">//может динамически менять слой</span></span><br><span class="line">    ...                                           <span class="comment">//и т.д.</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//но так же имеет и методы, которые кто-то должен вызывать :(</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">playDestroyAnimation</span><span class="params">(<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(Event*)&gt; callback)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setHighestLayer</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">restoreLayer</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Соответственно, без использования ECS встаёт вопрос о том, куда дописывать код и где искать проблемы, когда они появляются.</p>
<p>Один из случаев в этом проекте:</p>
<p><strong>Иногда самолёты запускаются при старте игры</strong><br>В качестве бонуса игроку на старте. При этом другие бонусы от различных событий или покупок игрока расставляются по полю динамически. Программисту приходит баг от QA, что иногда поле от этого нестабильно (самолеты бьют в те клетки, куда не должны - логика самолётов подразумевает, что они умеют кружить по полю до того момента, пока одна из клеток не станет стабильной, т.е. в ней до момента удара гарантировано не будет происходить других событий). </p>
<p>Механика игры подразумевает, что можно заблокировать клетку от удара самолёта через метод <code>match3cell-&gt;lock</code>, но куда вставить его вызов?</p>
<ul>
<li>в коде <code>createAirplaneExplosion</code>?</li>
<li>в коде самого <code>airplaneBlock</code>? (тогда он будет знать о существовании всего поля и клеток на нём)</li>
<li>в коде событий, добавляющих на поле бустеры?</li>
<li>добавить компонент особой блокировки в класс клетку match3cell?</li>
<li>Программист, которому прилетел баг, пошёл ещё дальше, и добавил блокировку в код туториала на старте уровня %).</li>
</ul>
<p>В подходе с ECS, код, по идее, должен был бы выглядеть понятнее:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateSystems</span><span class="params">(<span class="keyword">float</span> dt)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">	createPreboosterAirplaneSystem(dt);  <span class="comment">//выставить компонент блокировки клеток поля на старте полёта самолётов</span></span><br><span class="line">	createOtherPreboostersSystem(dt);  <span class="comment">//обновить логику всех бонусов игрока, отработки которых нужно дождаться</span></span><br><span class="line">	normalGamePlayLogic(dt);         <span class="comment">//обычная геймплейная логика, </span></span><br><span class="line">         <span class="comment">//включает в себя обновление самолётов:</span></span><br><span class="line">         <span class="comment">//"если нет блокировки, ударить по клетке, иначе  - продолжать летать над полем"</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Т.е. на вопрос <strong><code>&quot;куда дописать логику блокировки клеток от удара самолётами-пребустерами&quot;</code></strong> следует очевидный ответ <strong><code>&quot;в систему создания блокировки от удара самолётами-пребустерами&quot;</code></strong>, вместо распутывания ада взаимных вызовов и колбеков между полем, клеткой, самолётом, суперклассом запуска всех событий или ещё какими-нибудь объектами, и медитации на тему, какой из объектов более отвечает за это.</p>
<p>Поиск по коду суперкласса запуска всех событий даёт 25 мест, в которых клетка может быть заблокирована или разблокирована обратно %). Гораздо лучше было бы иметь 4-5 систем, которые выбирают все сущности с компонентами блокировки и удаляют эти компоненты или создают их.</p>
<hr>
<p>Одна из фишек архитектуры ECS - возможность отследить связи между системами и компонентами - <a href="https://youtu.be/W3aieHjyNvw?t=324" target="_blank" rel="noopener">пример в докладе Тимоти Форда по Overwatch</a>. Я попробовал перевести на ECS (с использованием библиотеки EnTT) готовую игру - сделанный за день для хакатона <a href="https://apps.apple.com/ru/app/comatosis/id1537791573#?platform=ipad" target="_blank" rel="noopener">небольшой shoot-them-up</a> на закрытом движке, использующем Component Systems. Заменил часть, отвечающую за апдейт на системы, и оставил без изменений систему рендера (она использует Scene Graph).</p>
<p>На мой взгляд, небольшие игры с хакатонов хорошо подходят для подобных тестов - бардак в коде, вызванный нехваткой времени сделать “как правильно”, реалистично симулирует состояние кода игры после длительного периода разработки, а небольшой объём кода позволяет довести задуманное до конца.</p>
<p>Для визуализации связей сделал такой скрипт на питоне:<br><a href="https://gist.github.com/spiiin/c70c3bf0711fd952d48e505ead7bffe5" target="_blank" rel="noopener">https://gist.github.com/spiiin/c70c3bf0711fd952d48e505ead7bffe5</a><br><img src="/blog/1488389622/diagram1.png" alt="ecs-doc"></p>
<p>Кашу из зависимостей между игровыми классами удалось превратить в 24 системы и 30 компонентов. При этом большинство систем использует 2-4 компонента, большинство компонентов используется 1-2-3 системами. Большая часть систем может быть без особых усилий переделана на <code>реактивные</code> (чтобы вызывать их не каждый кадр, а по колбекам на изменение каких-либо компонент на любой из сущностей) или на <code>владеющие компонентами</code> (для оптимизации по скорости обходов, <a href="https://skypjack.github.io/2019-04-12-entt-tips-and-tricks-part-1/" target="_blank" rel="noopener">статья с объяснением</a>).</p>
<p>Компоненты по способу использования разделяются на <code>логические</code> (для композиции из них сущностей - в основном, игровых объектов), <code>события</code> (для передачи информации между системами и выделения сущностей, с которыми произошло действие), <code>синглтоны</code> (существующие в единственном экземпляре для всего пула сущностей), и <code>прокси-компоненты</code> (для передачи данных в подсистемы движка/игры, написанные без ecs, и получения данных из этих подсистем).</p>
<h2 id="DOD-упрощает-управление-параметрами-из-нескольких-мест"><a href="#DOD-упрощает-управление-параметрами-из-нескольких-мест" class="headerlink" title="DOD упрощает управление параметрами из нескольких мест"></a>DOD упрощает управление параметрами из нескольких мест</h2><p>Простейший пример -<strong> <code>возможность удаления игрового объекта из нескольких разных мест</code></strong>.<br>Игровой снаряд может быть уничтожен через 5 секунд по окончанию времени жизни, либо при столкновениях во стеной или врагом, то удаление может выглядеть так:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> bullet = createBullet();</span><br><span class="line"><span class="keyword">auto</span> waitAction = createWaitAction(<span class="number">5.0f</span>); <span class="comment">//создаём объект действия ожидания</span></span><br><span class="line"><span class="comment">//в конце действия уничтожаем объект</span></span><br><span class="line">waitAction.onEnd = [bullet]() &#123;</span><br><span class="line">    <span class="comment">//тут не забыть проверить, что за 5 секунд объект может быть уничтожен кем-либо ещё</span></span><br><span class="line">    bullet-&gt;destroySelf();</span><br><span class="line">&#125;;</span><br><span class="line">bullet-&gt;addAction(waitAction); <span class="comment">//добавляем действие на объект пули</span></span><br></pre></td></tr></table></figure>
<p>Как проверить, что пуля не была уничтожена?<br>Один из способ из стандартной библиотеки с++ – использование слабого указателя на объект. Такие проверки необходимо добавлять в каждое асинхронное действие.</p>
<p>Другой подход - перепроверять, жив ли объект в текущий момент, через глобальный менеджер объектов. Более детально про организацию этого в игровых движках - <a href="https://floooh.github.io/2018/06/17/handles-vs-pointers.html" target="_blank" rel="noopener">статья Andre Weissflog</a>. В этом случае хендлер объекта может быть представлен в виде пары <strong><code>(индекс объекта в массиве, номер поколения)</code></strong>. Использование номера поколения позволяет избежать случайного обращения к уже удалённому объекту при размещении на месте удалённого объекта следующего созданного.</p>
<p>Если решать проблему с использованием ECS-подхода, решение может быть таким: система обновления жизни пули (и других объектов с компонентом <code>lifetimeComponent</code>) читает компонент таймера жизни и уменьшают его. В случае если таймер дошёл до нуля - система просто добавляет на сущность компонент-событие <code>removeNodeComponent</code> - маркер, что в конце кадра сущность должна быть уничтожена.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateLifetimeSystem</span><span class="params">(<span class="keyword">float</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//read components </span></span><br><span class="line">    <span class="comment">// &lt;------------------------------------------------(0)</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; lifetimeView = ECS().view&lt;nodeComponent, lifetimeComponent&gt;(entt::exclude&lt;removeNodeComponent&gt;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//logic</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> [entity, nodeComponent, lifetimeComp] : lifetimeView.each()) &#123;</span><br><span class="line">        lifetimeComp.lifetime -= delta;</span><br><span class="line">        <span class="keyword">if</span> (lifetimeComp.lifetime &lt;= <span class="number">0.0f</span>) &#123;</span><br><span class="line">            <span class="keyword">auto</span> action = MEActionFactory::changeAlphaAction(<span class="number">0.0f</span>, lifetimeComp.fadeinTime);</span><br><span class="line">            action-&gt;onEnd = [entity=entity](MENode* node) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ECS().valid(entity)) &#123;  <span class="comment">//&lt;-------  (1)</span></span><br><span class="line">                    ECS().emplace_or_replace&lt;removeNodeComponent&gt;(entity);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">if</span> (!nodeComponent.dead) &#123;      <span class="comment">//&lt;-------- (2)</span></span><br><span class="line">                nodeComponent.node-&gt;addAction(action);</span><br><span class="line">                ECS().<span class="built_in">remove</span>&lt;lifetimeComponent&gt;(entity);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(0) - выборка всех сущностей, у которых есть компоненты <code>nodeComponent</code> (визуальное отображение), <code>lifetimeComponent</code> (время жизни), но нет компонента <code>removeNodeComponent</code> (умирает)<br>(1) - так как используется отложенное действие - нужно проверить, что сущность ещё жива и не была уничтожена (проверка через менеджер) - <code>ECS().valid</code><br>(2) - компонент для хранения не владеющего указателя, имеет кроме указателя флаг <code>nodeComponent.dead</code> , показывающий не был ли уничтожен объект, вместо использования weak_ptr/intrusive_ptr. Вместо флага может быть использован счётчик, если нужно shared-владение.</p>
<hr>
<p>Другой пример - есть стратегия с игровым полем с персонажами на нём, и по желаниям гейм-дизайнеров, персонажи на этом поле должны плавно исчезать при открытии окна режима редактирования зданий или появления немодального игрового окна (и соответственно, плавно появляться обратно при закрытии этих режимов). Появление персонажей не мгновенно, и игроки могут успеть за это время запустить исчезновение обратно. <strong><code>Как добиться того, чтобы появление/исчезновение персонажей работало корректно в этом случае?</code></strong></p>
<p>В <code>ООП-подходе</code> возможно, что каждое из действий появления напрямую будет пытаться влезть в другие действия, навешенные на персонажа, и узнать, нет ли на нём действий исчезновения и как-то обработать ситуацию, если персонажи одновременно появляются и исчезают. <em>(при <strong>правильном</strong> ооп-подходе, конечно, возможна и нормальная реализация)</em></p>
<p>С <code>ECS-подходом</code> - можно выделить два различных компонента исчезновения и появления персонажа, и различные системы для работы с ними. Одной из идиом работы совместной работы таких систем является непосредственное применение сайд-эффектов в одном месте (сайд-эффект в этом случае - это непосредственное изменение альфа-компонента цвета для рендер-системы). <a href="https://youtu.be/W3aieHjyNvw?t=1062" target="_blank" rel="noopener">Объяснение причин в докладе по Overwatch</a> - если системы A, B, C как-либо меняют логическое состояние компонента, то лучше собрать их действие в отдельном компоненте для системы D, которые непосредственно применит все собранные изменения в одном месте.</p>
<p>Так формула рассчёта альфа компонента персонажа будет находиться в одном месте и её можно будет изменить по желанию гейм-дизайнеров. Например, можно будет настроить поведение в таком случае одновременного появления и исчезновения персонажа - выстроить ли эти действия в цепочку, мгновенно завершить действие, которое было начато раньше, или же настроить таймеры действия так, чтобы они доигрались быстрее.</p>
<h2 id="Упрощается-написание-читов"><a href="#Упрощается-написание-читов" class="headerlink" title="Упрощается написание читов"></a>Упрощается написание читов</h2><p>Не секрет, что при разработке игр редко заморачиваются с покрытием кода тестами, поэтому часто читы - это средство создания сложных сценариев проверки игры, так что они становятся настолько важными, насколько важно вообще провести QA-проверку игры.</p>
<p>ECS подход должен помочь:</p>
<p><strong><code>- Легко включать и отключать каждую отдельную систему через читы</code></strong><br>Лучше даже, группу систем, отвечающую за определённую логику.</p>
<p>Отключение системы может само по себе быть удобным готовым читом, который при ООП подходе необходимо создавать дополнительно к основной логике (отключение системы получения урона, отключение системы коллизий, отключение ИИ).</p>
<p>При проектировании объектов редко задумываются о том, чтобы частично отключать функционал класса. С системами, вызов которых сгруппирован в одном месте, это может быть сильно проще.</p>
<p><strong><code>- Проще сделать загрузку/сохранение сцены, проигрывание повторов</code></strong><br>Сохранение - это просто сериализация всех сущностей со всеми компонентами. Если после этого запустить все системы - логика игры должна начать работать также, как если бы состояние сущностей/компонент было получено любым другим образом.</p>
<p><strong><code>- Проще составить сценарии тестирования</code></strong><br>Включение/отключение систем может быть сериализовано или включено в запись повтора, результаты работы после нескольких циклов могут быть сериализованы и сверены с эталонным результатом.</p>
<h2 id="Возможно-игра-будет-работать-быстрее"><a href="#Возможно-игра-будет-работать-быстрее" class="headerlink" title="Возможно, игра будет работать быстрее"></a>Возможно, игра будет работать быстрее</h2><p>(не проверял, пересказ чужих докладов, но вообще это основная идея дизайна, основанного на данных — обращения к данным спроектированы так, чтобы данные лежали рядом и за ними не нужно было “далеко ходить”)</p>
<p><strong><code>- Проще запустить системы, несвязанные с другими, в отдельном потоке</code></strong><br>Если отслеживать граф зависимостей компонентов, с которыми работают системы, то можно найти системы, которые могут работать параллельно с другими. С обычным ООП подходом сложно перенести часть логики в отдельный поток.</p>
<p><strong><code>- Прирост скорости за счёт более быстрого обхода и чтения из кеша</code></strong><br>Компоненты хранятся в памяти отдельными массивами, однако можно добиться того, чтобы ECS хранила контейнер для каждой группы сущностей с определённой группой компонент в памяти последовательно.</p>
<p>Для ECS на архетипах это делается по умолчанию (при создании или удалении компонента для сущности, они будет перенесена в другой контейнер).</p>
<p>Для ECS на разреженных множествах также существуют способы организовать хранение сущностей с одинаковыми компонентами в памяти последовательно. Для EnTT - это группы (<code>group</code>) - <a href="https://github.com/abeimler/ecs_benchmark" target="_blank" rel="noopener">синтетические бенчмарки</a> показывают, что это наиболее быстрый способ работы.</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script></div></article><div class="pagination"><a class="pagination__link pagination__prev" href="/blog/413676133/">Позже</a><a class="pagination__link pagination__next" href="/blog/381238762/">Раньше</a></div></main><footer class="footer metadata"><p class="footer__text">© 2023 spiiin</p><p class="footer__text">Powered by <a class="footer__text__link" href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a class="footer__text__link" href="https://pages.github.com/" target="_blank">Github Page</a></p></footer></div></body></html>