<!DOCTYPE html><html lang="ru"><head><meta charset="UTF-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Spiiin's blog | Формат сжатия уровней в Jurassic Park [NES]</title><meta name="description" content="&lt;p&gt;Давно не затрагивал тему реверс-инжиниринга NES игр. После разбора блочного формата описания &lt;a href=&quot;(https://spiiin.github.io/CadEditor/cadeditor-supported-games.html&quot;&gt;уровней&lt;/a&gt;), остались несколько игр, отмеченных как &lt;em&gt;comp&lt;/em&gt; (уровень в ROM сжат). Сжатие уровней редко используется в играх NES, чаще сжимается текст или данные описания графики. Да и сам блочный формат уровня уже является формой экономии информации.&lt;/p&gt;
&lt;p&gt;Тем не менее некоторые игры используют сжатие &lt;a href=&quot;https://en.wikipedia.org/wiki/Run-length_encoding&quot;&gt;RLE&lt;/a&gt;. В простых формах, как в &lt;code&gt;Contra&lt;/code&gt;, или в более сложных, как в &lt;a href=&quot;/blog/1486764983/&quot; title=&quot;Формат компрессии уровней в игре Felix The Cat [NES]&quot;&gt;Felix The Cat&lt;/a&gt; , где применяется гибрид RLE и словарного метода. Другие применяют формы &lt;strong&gt;&lt;code&gt;&amp;quot;описания на холсте&amp;quot;&lt;/code&gt;&lt;/strong&gt;, когда команды отрисовки задаются в виде “нарисуй что-то в координатах X,Y” (описание карты мира в играх &lt;code&gt;Capcom&lt;/code&gt; или уровней в &lt;code&gt;Super Mario Bros&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Это относительно простые алгоритмы. Но отдельные игры идут дальше и применяют более совершенные формы сжатия:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://romhack.github.io/doc/halCompression/&quot;&gt;Kirby&lt;/a&gt; и другие игры &lt;code&gt;HAL&lt;/code&gt; - гибрид LZ алгоритмов и RLE, с несколькими командами вроде “следующие биты развернуть”.&lt;br&gt;&lt;a href=&quot;https://github.com/romhack/codemastersMarkov&quot;&gt;Dizzy&lt;/a&gt; и другие игры &lt;code&gt;Codemasters&lt;/code&gt; - сжатие графики цепями Маркова.&lt;/p&gt;
&lt;p&gt;Формат уровней этих игр описан. Однако, в моём списке игр, добавленных в &lt;a href=&quot;https://github.com/spiiin/CadEditor/blob/master/CadEditor/cad_editor_supported_games.txt&quot;&gt;CadEditor&lt;/a&gt; были ещё две — &lt;code&gt;Jurassic Park&lt;/code&gt; и &lt;code&gt;James Bond Jr&lt;/code&gt;. Я выбрал для разбора &lt;code&gt;Jurassic Park&lt;/code&gt;, потому что знал, что в нём используется разновидность &lt;a href=&quot;https://en.wikipedia.org/wiki/LZ77_and_LZ78&quot;&gt;LZ&lt;/a&gt;, потому что хотел заодно прочитать про сам алгоритм и его разновидности.&lt;/p&gt;"><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=PT+Serif&amp;display=swap"><link rel="stylesheet" href="/css/highlights/darkula.css"><link rel="stylesheet" href="/css/main.css"><link rel="search" type="application/opensearchdescription+xml" href="http://spiiin.github.io/atom.xml" title="Spiiin's blog"><script>(function (i, s, o, g, r, a, m) {
  i['GoogleAnalyticsObject'] = r;
  i[r] = i[r] || function () {
    (i[r].q = i[r].q || []).push(arguments)
  }, i[r].l = 1 * new Date();
  a = s.createElement(o),
    m = s.getElementsByTagName(o)[0];
  a.async = 1;
  a.src = g;
  m.parentNode.insertBefore(a, m)
})(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');
ga('create', 'UA-00000000-0', 'auto');
ga('send', 'pageview');</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-shiki-plugin@latest/lib/codeblock.css">
<style>:root{--hl-color:#abb2bf;--hl-bg:#282c34;--hltools-bg:#21252b;--hltools-color:#bbbbbc;--hlnumber-bg:#282c34;--hlnumber-color:#495162;--hlscrollbar-bg:#373c47;--hlexpand-bg:linear-gradient(180deg,rgba(40,44,52,0.1),rgba(40,44,52,0.9))}</style><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Spiiin's blog" type="application/atom+xml">
</head><body><div class="container"><header class="main-header"><h1 class="main-header__title uplize"><a class="main-header__title__link" href="/"><img class="header-image" src="/images/favicon.png" width="36" height="36">Spiiin's blog</a></h1><nav class="main-header__nav"><ul class="main-nav"><li class="main-nav__list"><a class="main-nav__list__link" href="/" target="_self">HOME</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/archives/" target="_self">ARCHIVE</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/tags/meta" target="_self">TAGS</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/blog/1" target="_self">ABOUT</a></li></ul></nav></header><main class="container__wrapper"><div class="pagination"><a class="pagination__link pagination__prev" href="/blog/2455145615/">Позже</a><a class="pagination__link pagination__next" href="/blog/3460926079/">Раньше</a></div><article class="article post"><h3 class="article__title">Формат сжатия уровней в Jurassic Park [NES]</h3><div class="article__date metadata"><div class="post-info">2023/12/19</div></div><div class="article__tags metadata">Tags:
<a class="article__tags__link metadata" href="/tags/nes/">nes</a><a class="article__tags__link metadata" href="/tags/hack/">hack</a></div><div class="article__body"><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Давно не затрагивал тему реверс-инжиниринга NES игр. После разбора блочного формата описания <a href="(https://spiiin.github.io/CadEditor/cadeditor-supported-games.html">уровней</a>), остались несколько игр, отмеченных как <em>comp</em> (уровень в ROM сжат). Сжатие уровней редко используется в играх NES, чаще сжимается текст или данные описания графики. Да и сам блочный формат уровня уже является формой экономии информации.</p>
<p>Тем не менее некоторые игры используют сжатие <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Run-length_encoding">RLE</a>. В простых формах, как в <code>Contra</code>, или в более сложных, как в <a href="/blog/1486764983/" title="Формат компрессии уровней в игре Felix The Cat [NES]">Felix The Cat</a> , где применяется гибрид RLE и словарного метода. Другие применяют формы <strong><code>&quot;описания на холсте&quot;</code></strong>, когда команды отрисовки задаются в виде “нарисуй что-то в координатах X,Y” (описание карты мира в играх <code>Capcom</code> или уровней в <code>Super Mario Bros</code>).</p>
<p>Это относительно простые алгоритмы. Но отдельные игры идут дальше и применяют более совершенные формы сжатия:</p>
<p><a target="_blank" rel="noopener" href="https://romhack.github.io/doc/halCompression/">Kirby</a> и другие игры <code>HAL</code> - гибрид LZ алгоритмов и RLE, с несколькими командами вроде “следующие биты развернуть”.<br><a target="_blank" rel="noopener" href="https://github.com/romhack/codemastersMarkov">Dizzy</a> и другие игры <code>Codemasters</code> - сжатие графики цепями Маркова.</p>
<p>Формат уровней этих игр описан. Однако, в моём списке игр, добавленных в <a target="_blank" rel="noopener" href="https://github.com/spiiin/CadEditor/blob/master/CadEditor/cad_editor_supported_games.txt">CadEditor</a> были ещё две — <code>Jurassic Park</code> и <code>James Bond Jr</code>. Я выбрал для разбора <code>Jurassic Park</code>, потому что знал, что в нём используется разновидность <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/LZ77_and_LZ78">LZ</a>, потому что хотел заодно прочитать про сам алгоритм и его разновидности.</p>
<span id="more"></span>
<h2><span id="vstuplenie">Вступление</span><a href="#vstuplenie" class="header-anchor">#</a></h2><p>(оно же отступление)</p>
<p>При исследовании нового ты оказываешься перед уникальной задачей <strong>один на один</strong>. В CadEditor-е есть пара кусков кода, связанных с LZ-сжатием ( <a href="https://spiiin.github.io/CadEditor/cadeditor-using-lzkn.html">LZKN</a>, написанный <code>DrMephisto</code>, и <a href="/blog/1579894033/" title="Формат карт Final Fantasy Tactics Advance [GBA]">карты FFTA</a> авторства <code>DarcyMiles</code>), но я не касался этого алгоритма на NES.</p>
<p>Я не реверсил NES-игры на протяжении пяти лет, и успел забыть, что это скорее не навык, а состояние. </p>
<blockquote><p>“Глядя на мерцающие экраны и на безбрежный поток данных, поднятый моими алгоритмами и мчащийся в никуда по виртуальному пространству цифрового мира, я часто думаю: где я в этом потоке битов и байтов?”</p>
<footer><strong>ChatGPT который плагиатит Анонима который плагиатит Чингизхана</strong></footer></blockquote>
<p>Когда результат УЖЕ найден, алгоритм кажется тривиальным. Но до этого смотришь на матрицу байт, и бесконечный ассемблерный листинг, вообще без понятия, что перед тобой. Потом, когда нашёл свой Диснейленд (<a target="_blank" rel="noopener" href="https://exsistencia.livejournal.com/3261.html">Бодрийаровский</a>) в пещере, забываешь о состоянии, в котором был, пока смотрел в темноту. Поэтому я ценю описание состояния, а не откомментированный результат.</p>
<h2><span id="bloki">Блоки</span><a href="#bloki" class="header-anchor">#</a></h2><p>Первое, что можно сделать — закинуть в темноту <a href="/blog/2598119234/" title="Самый лучший способ поиска форматов блоков для NES-игр.">лидар</a> (<code>autocorrupter + blockfinder</code>), который покажет “общую форму пещеры”.</p>
<p>Он отлично работает и на сжатых картах, единственное, что запускать его нужно не на область ROM, а на область RAM, в которой находятся расжатые данные. Он показывает, что:</p>
<ul>
<li><p>описание карты уровня расположено по адресам 0x60C8-0x72CB, индексами блоков, по 2 байта на блок. 3 нибла кодируют номер блока, 4-й - физические свойства блока<br>(является ли блок выходом из уровня, препятствием, передним или задним фоном)</p>
</li>
<li><p>размер блока 2x2, описание которых асположено по адресам 0x76CC, блоков 352 штуки</p>
</li>
<li><p>слой бит палитры блоков описан отдельно от описания блоков. Т.е. любой блок можно окрасить в любую из 4х палитр<br><img src="/blog/17440519/jp_map0_small.png" alt></p>
</li>
</ul>
<p>Также обнаруживается интересная особенность — игра переключает активный банк видеопамяти блоков, когда игрок выходит из нижней или верхней трети экрана в центральную часть. Так что блоки с индексами &gt;0x80 могут распологаться только в нижней трети уровня (ими в первом уровне отрисованы здания).<br><img src="/blog/17440519/jp_map1_small.png" alt></p>
<p>(<a target="_blank" rel="noopener" href="https://github.com/spiiin/CadEditor/blob/master/CadEditor/settings_nes/jurassic_park/Settings_JurassicPark_1.cs">Конфиг для CadEditor-а</a>)</p>
<p>Область 0x1000-0x7FFF - это 6-кб CHR-RAM, память доступная для записи, располагается на картридже, в дополнение к 2кб памяти NES (это один из самых больших <a target="_blank" rel="noopener" href="https://nescartdb.com/profile/view/1038/jurassic-park">картриджей</a>)</p>
<h2><span id="dekompressiya">Декомпрессия</span><a href="#dekompressiya" class="header-anchor">#</a></h2><p>Если поставить брейкпоинт на запись в 0x60C8 (это значение прописано в игре хардкодом как область распаковки), можно выйти на адрес архива в ROM - 0x9D94 (адрес записан в ячейки памяти 95-96).</p>
<p>Также, изучай трейслог между чтением байта из ROM и записью в RAM, стоит запомнить все ячейки, которые изменяются походу — 6F, 70, 73, 74, 75.<br>(<em>меня восхищает, что трейслог команд на ассемблере 6502 может разобрать chatgpt, очень интересно было бы узнать, на каких входных данных он обучился</em>)</p>
<p>Первые байты архива в ROM и соответствующие им байты распакованных данных:<br><figure class="shiki"><div class="codeblock"><div class="code"><pre class="shiki dracula"><code><span class="line"><span style="color: #F8F8F2">0x9D94: 18 00 20 04 0C 84 00 64</span></span>
<span class="line"><span style="color: #F8F8F2">0x60C8: 30 00 30 00 06 84 00 84</span></span></code></pre></div></div></figure></p>
<p>Пока что связь между сжатыми данными и расжатыми неочевидна. Просто изменять наугад байты архива в ROM (например 0x648C) бесполезно, меняется большая группа распакованных данных, на стенках нашей тёмной пещеры из байт оказывается калейдоскоп из зеркал, отражающих лучи по непредсказуемым траекториям<br><img src="/blog/17440519/jp3.png" alt></p>
<p>Более изящный способ — написать lua-скрипт для эмулятора, который будет трассировать в файл все чтения из архива и записи распакованных данных, а также состояние управляющих распаковкой ячеек.</p>
<figure class="shiki lua"><div class="codeblock"><div class="code"><pre class="shiki dracula"><code><span class="line"><span style="color: #FF79C6">local</span><span style="color: #F8F8F2"> logFile </span><span style="color: #FF79C6">=</span><span style="color: #F8F8F2"> </span><span style="color: #8BE9FD">io.open</span><span style="color: #F8F8F2">(</span><span style="color: #E9F284">&quot;</span><span style="color: #F1FA8C">jp_unpack1.txt</span><span style="color: #E9F284">&quot;</span><span style="color: #F8F8F2">, </span><span style="color: #E9F284">&quot;</span><span style="color: #F1FA8C">w</span><span style="color: #E9F284">&quot;</span><span style="color: #F8F8F2">)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF79C6">local</span><span style="color: #F8F8F2"> </span><span style="color: #FF79C6">function</span><span style="color: #F8F8F2"> </span><span style="color: #50FA7B">readMemoryValues</span><span style="color: #F8F8F2">()</span></span>
<span class="line"><span style="color: #F8F8F2">    </span><span style="color: #FF79C6">return</span><span style="color: #F8F8F2"> {</span></span>
<span class="line"><span style="color: #F8F8F2">        memory.</span><span style="color: #50FA7B">readbyte</span><span style="color: #F8F8F2">(</span><span style="color: #BD93F9">0x73</span><span style="color: #F8F8F2">),</span></span>
<span class="line"><span style="color: #F8F8F2">        memory.</span><span style="color: #50FA7B">readbyte</span><span style="color: #F8F8F2">(</span><span style="color: #BD93F9">0x74</span><span style="color: #F8F8F2">),</span></span>
<span class="line"><span style="color: #F8F8F2">        memory.</span><span style="color: #50FA7B">readbyte</span><span style="color: #F8F8F2">(</span><span style="color: #BD93F9">0x75</span><span style="color: #F8F8F2">),</span></span>
<span class="line"><span style="color: #F8F8F2">        memory.</span><span style="color: #50FA7B">readbyte</span><span style="color: #F8F8F2">(</span><span style="color: #BD93F9">0x6F</span><span style="color: #F8F8F2">),</span></span>
<span class="line"><span style="color: #F8F8F2">        memory.</span><span style="color: #50FA7B">readbyte</span><span style="color: #F8F8F2">(</span><span style="color: #BD93F9">0x70</span><span style="color: #F8F8F2">)</span></span>
<span class="line"><span style="color: #F8F8F2">    }</span></span>
<span class="line"><span style="color: #FF79C6">end</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF79C6">local</span><span style="color: #F8F8F2"> </span><span style="color: #FF79C6">function</span><span style="color: #F8F8F2"> </span><span style="color: #50FA7B">logMemoryOperation</span><span style="color: #F8F8F2">(</span><span style="color: #FFB86C; font-style: italic">operation</span><span style="color: #F8F8F2">, </span><span style="color: #FFB86C; font-style: italic">address</span><span style="color: #F8F8F2">, </span><span style="color: #FFB86C; font-style: italic">value</span><span style="color: #F8F8F2">)</span></span>
<span class="line"><span style="color: #F8F8F2">    </span><span style="color: #FF79C6">local</span><span style="color: #F8F8F2"> values </span><span style="color: #FF79C6">=</span><span style="color: #F8F8F2"> </span><span style="color: #50FA7B">readMemoryValues</span><span style="color: #F8F8F2">()</span></span>
<span class="line"><span style="color: #F8F8F2">    </span><span style="color: #8BE9FD">logFile</span><span style="color: #F8F8F2">:</span><span style="color: #50FA7B">write</span><span style="color: #F8F8F2">(</span><span style="color: #8BE9FD">string.format</span><span style="color: #F8F8F2">(</span><span style="color: #E9F284">&quot;</span><span style="color: #F1FA8C">%s %04X %s %02X --- 73: %02X, 74: %02X, 75: %02X, 6F: %02X, 70: %02X</span><span style="color: #FF79C6">\n</span><span style="color: #E9F284">&quot;</span><span style="color: #F8F8F2">,</span></span>
<span class="line"><span style="color: #F8F8F2">                                operation, address, operation </span><span style="color: #FF79C6">==</span><span style="color: #F8F8F2"> </span><span style="color: #E9F284">&quot;</span><span style="color: #F1FA8C">WRITE</span><span style="color: #E9F284">&quot; </span><span style="color: #FF79C6">and</span><span style="color: #F8F8F2"> </span><span style="color: #E9F284">&quot;</span><span style="color: #F1FA8C">-&gt;</span><span style="color: #E9F284">&quot; </span><span style="color: #FF79C6">or</span><span style="color: #F8F8F2"> </span><span style="color: #E9F284">&quot;</span><span style="color: #F1FA8C">&lt;-</span><span style="color: #E9F284">&quot;</span><span style="color: #F8F8F2">, value,</span></span>
<span class="line"><span style="color: #F8F8F2">                                </span><span style="color: #8BE9FD">table.unpack</span><span style="color: #F8F8F2">(values)))</span></span>
<span class="line"><span style="color: #FF79C6">end</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF79C6">local</span><span style="color: #F8F8F2"> </span><span style="color: #FF79C6">function</span><span style="color: #F8F8F2"> </span><span style="color: #50FA7B">onRead</span><span style="color: #F8F8F2">(</span><span style="color: #FFB86C; font-style: italic">address</span><span style="color: #F8F8F2">, </span><span style="color: #FFB86C; font-style: italic">size</span><span style="color: #F8F8F2">, </span><span style="color: #FFB86C; font-style: italic">value</span><span style="color: #F8F8F2">)</span></span>
<span class="line"><span style="color: #F8F8F2">    </span><span style="color: #50FA7B">logMemoryOperation</span><span style="color: #F8F8F2">(</span><span style="color: #E9F284">&quot;</span><span style="color: #F1FA8C">READ </span><span style="color: #E9F284">&quot;</span><span style="color: #F8F8F2">, address, value)</span></span>
<span class="line"><span style="color: #FF79C6">end</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF79C6">local</span><span style="color: #F8F8F2"> </span><span style="color: #FF79C6">function</span><span style="color: #F8F8F2"> </span><span style="color: #50FA7B">onWrite</span><span style="color: #F8F8F2">(</span><span style="color: #FFB86C; font-style: italic">address</span><span style="color: #F8F8F2">, </span><span style="color: #FFB86C; font-style: italic">size</span><span style="color: #F8F8F2">, </span><span style="color: #FFB86C; font-style: italic">value</span><span style="color: #F8F8F2">)</span></span>
<span class="line"><span style="color: #F8F8F2">    </span><span style="color: #50FA7B">logMemoryOperation</span><span style="color: #F8F8F2">(</span><span style="color: #E9F284">&quot;</span><span style="color: #F1FA8C">WRITE</span><span style="color: #E9F284">&quot;</span><span style="color: #F8F8F2">, address, value)</span></span>
<span class="line"><span style="color: #FF79C6">end</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF79C6">local</span><span style="color: #F8F8F2"> </span><span style="color: #FF79C6">function</span><span style="color: #F8F8F2"> </span><span style="color: #50FA7B">onWriteExt</span><span style="color: #F8F8F2">(</span><span style="color: #FFB86C; font-style: italic">address</span><span style="color: #F8F8F2">, </span><span style="color: #FFB86C; font-style: italic">size</span><span style="color: #F8F8F2">, </span><span style="color: #FFB86C; font-style: italic">value</span><span style="color: #F8F8F2">)</span></span>
<span class="line"><span style="color: #F8F8F2">    </span><span style="color: #50FA7B">logMemoryOperation</span><span style="color: #F8F8F2">(</span><span style="color: #E9F284">&quot;</span><span style="color: #F1FA8C">     </span><span style="color: #E9F284">&quot;</span><span style="color: #F8F8F2">, address, value)</span></span>
<span class="line"><span style="color: #FF79C6">end</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF79C6">local</span><span style="color: #F8F8F2"> </span><span style="color: #FF79C6">function</span><span style="color: #F8F8F2"> </span><span style="color: #50FA7B">registerMemoryCallbacks</span><span style="color: #F8F8F2">()</span></span>
<span class="line"><span style="color: #F8F8F2">    </span><span style="color: #FF79C6">local</span><span style="color: #F8F8F2"> readRangeStart, readRangeEnd </span><span style="color: #FF79C6">=</span><span style="color: #F8F8F2"> </span><span style="color: #BD93F9">0x9D94</span><span style="color: #F8F8F2">, </span><span style="color: #BD93F9">0xA4B1</span></span>
<span class="line"><span style="color: #F8F8F2">    </span><span style="color: #FF79C6">local</span><span style="color: #F8F8F2"> writeRangeStart, writeRangeEnd </span><span style="color: #FF79C6">=</span><span style="color: #F8F8F2"> </span><span style="color: #BD93F9">0x60C8</span><span style="color: #F8F8F2">, </span><span style="color: #BD93F9">0x72CB</span></span>
<span class="line"><span style="color: #F8F8F2">    </span><span style="color: #FF79C6">local</span><span style="color: #F8F8F2"> extendedWriteAddresses </span><span style="color: #FF79C6">=</span><span style="color: #F8F8F2"> {</span><span style="color: #BD93F9">0x6F</span><span style="color: #F8F8F2">, </span><span style="color: #BD93F9">0x70</span><span style="color: #F8F8F2">, </span><span style="color: #BD93F9">0x73</span><span style="color: #F8F8F2">, </span><span style="color: #BD93F9">0x74</span><span style="color: #F8F8F2">, </span><span style="color: #BD93F9">0x75</span><span style="color: #F8F8F2">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F8F8F2">    memory.</span><span style="color: #50FA7B">registerread</span><span style="color: #F8F8F2">(readRangeStart, readRangeEnd </span><span style="color: #FF79C6">-</span><span style="color: #F8F8F2"> readRangeStart </span><span style="color: #FF79C6">+</span><span style="color: #F8F8F2"> </span><span style="color: #BD93F9">1</span><span style="color: #F8F8F2">, onRead)</span></span>
<span class="line"><span style="color: #F8F8F2">    memory.</span><span style="color: #50FA7B">registerwrite</span><span style="color: #F8F8F2">(writeRangeStart, writeRangeEnd </span><span style="color: #FF79C6">-</span><span style="color: #F8F8F2"> writeRangeStart </span><span style="color: #FF79C6">+</span><span style="color: #F8F8F2"> </span><span style="color: #BD93F9">1</span><span style="color: #F8F8F2">, onWrite)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F8F8F2">    </span><span style="color: #FF79C6">for</span><span style="color: #F8F8F2"> _, address </span><span style="color: #FF79C6">in</span><span style="color: #F8F8F2"> </span><span style="color: #8BE9FD">ipairs</span><span style="color: #F8F8F2">(extendedWriteAddresses) </span><span style="color: #FF79C6">do</span></span>
<span class="line"><span style="color: #F8F8F2">        memory.</span><span style="color: #50FA7B">registerwrite</span><span style="color: #F8F8F2">(address, </span><span style="color: #BD93F9">1</span><span style="color: #F8F8F2">, onWriteExt)</span></span>
<span class="line"><span style="color: #F8F8F2">    </span><span style="color: #FF79C6">end</span></span>
<span class="line"><span style="color: #FF79C6">end</span></span>
<span class="line"></span>
<span class="line"><span style="color: #50FA7B">registerMemoryCallbacks</span><span style="color: #F8F8F2">()</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F8F8F2">emu.</span><span style="color: #50FA7B">registerexit</span><span style="color: #F8F8F2">(</span><span style="color: #FF79C6">function</span><span style="color: #F8F8F2">()</span></span>
<span class="line"><span style="color: #F8F8F2">    </span><span style="color: #FF79C6">if</span><span style="color: #F8F8F2"> logFile </span><span style="color: #FF79C6">then</span></span>
<span class="line"><span style="color: #F8F8F2">        </span><span style="color: #8BE9FD">logFile</span><span style="color: #F8F8F2">:</span><span style="color: #50FA7B">close</span><span style="color: #F8F8F2">()</span></span>
<span class="line"><span style="color: #F8F8F2">    </span><span style="color: #FF79C6">end</span></span>
<span class="line"><span style="color: #FF79C6">end</span><span style="color: #F8F8F2">)</span></span></code></pre></div></div></figure>
<p>Получается такой лог (большая часть незначащей информации вырезана)</p>
<figure class="shiki"><div class="codeblock"><div class="code"><pre class="shiki dracula"><code><span class="line"><span style="color: #F8F8F2">READ  9D94 &lt;- 18    --- 73: 00, 74: 00, 75: 00, 6F: 00, 70: 00</span></span>
<span class="line"><span style="color: #F8F8F2">READ  9D95 &lt;- 00    --- 73: 00, 74: 02, 75: 00, 6F: 18, 70: 00</span></span>
<span class="line"><span style="color: #F8F8F2">   WRITE 60C8 -&gt; 30 --- 73: 00, 74: 00, 75: 00, 6F: 30, 70: 00</span></span>
<span class="line"><span style="color: #F8F8F2">READ  9D96 &lt;- 20    --- 73: 00, 74: 03, 75: 00, 6F: 00, 70: 00</span></span>
<span class="line"><span style="color: #F8F8F2">   WRITE 60C9 -&gt; 00 --- 73: 80, 74: 00, 75: 00, 6F: 00, 70: 00</span></span>
<span class="line"><span style="color: #F8F8F2">                 75 --- 73: 00, 74: 00, 75: 02, 6F: 02, 70: 00</span></span>
<span class="line"><span style="color: #F8F8F2">                 74 --- 73: 00, 74: 0A, 75: 02, 6F: 02, 70: 00</span></span>
<span class="line"><span style="color: #F8F8F2">                 73 --- 73: 00, 74: 0A, 75: 02, 6F: 02, 70: 00</span></span>
<span class="line"><span style="color: #F8F8F2">                 6F --- 73: 00, 74: 0A, 75: 02, 6F: 04, 70: 00</span></span>
<span class="line"><span style="color: #F8F8F2">                 70 --- 73: 00, 74: 0A, 75: 02, 6F: 04, 70: 00</span></span>
<span class="line"><span style="color: #F8F8F2">                 74 --- 73: 00, 74: 09, 75: 02, 6F: 04, 70: 00</span></span>
<span class="line"><span style="color: #F8F8F2">                 73 --- 73: 00, 74: 09, 75: 02, 6F: 04, 70: 00</span></span>
<span class="line"><span style="color: #F8F8F2">                 6F --- 73: 00, 74: 09, 75: 02, 6F: 08, 70: 00</span></span>
<span class="line"><span style="color: #F8F8F2">                 70 --- 73: 00, 74: 09, 75: 02, 6F: 08, 70: 00</span></span>
<span class="line"><span style="color: #F8F8F2">                 74 --- 73: 00, 74: 08, 75: 02, 6F: 08, 70: 00</span></span>
<span class="line"><span style="color: #F8F8F2">                 73 --- 73: 00, 74: 08, 75: 02, 6F: 08, 70: 00</span></span>
<span class="line"><span style="color: #F8F8F2">                 6F --- 73: 00, 74: 08, 75: 02, 6F: 10, 70: 00</span></span>
<span class="line"><span style="color: #F8F8F2">                 70 --- 73: 00, 74: 08, 75: 02, 6F: 10, 70: 00</span></span>
<span class="line"><span style="color: #F8F8F2">                 74 --- 73: 00, 74: 07, 75: 02, 6F: 10, 70: 00</span></span>
<span class="line"><span style="color: #F8F8F2">                 73 --- 73: 00, 74: 07, 75: 02, 6F: 10, 70: 00</span></span>
<span class="line"><span style="color: #F8F8F2">                 6F --- 73: 00, 74: 07, 75: 02, 6F: 20, 70: 00</span></span>
<span class="line"><span style="color: #F8F8F2">                 70 --- 73: 00, 74: 07, 75: 02, 6F: 20, 70: 00</span></span>
<span class="line"><span style="color: #F8F8F2">READ  9D97 &lt;- 04    --- 73: 00, 74: 07, 75: 02, 6F: 20, 70: 00</span></span>
<span class="line"><span style="color: #F8F8F2">   WRITE 60CA -&gt; 30 --- 73: 00, 74: 00, 75: 02, 6F: 01, 70: 00</span></span>
<span class="line"><span style="color: #F8F8F2">   WRITE 60CB -&gt; 00 --- 73: 00, 74: 00, 75: 01, 6F: 01, 70: 00</span></span>
<span class="line"><span style="color: #F8F8F2">READ  9D98 &lt;- 0C    --- 73: 00, 74: 08, 75: 00, 6F: 04, 70: 00</span></span>
<span class="line"><span style="color: #F8F8F2">   WRITE 60CC -&gt; 06 --- 73: 00, 74: 00, 75: 00, 6F: 06, 70: 00</span></span>
<span class="line"><span style="color: #F8F8F2">READ  9D99 &lt;- 84    --- 73: 00, 74: 01, 75: 00, 6F: 0C, 70: 00</span></span>
<span class="line"><span style="color: #F8F8F2">READ  9D9A &lt;- 00    --- 73: 00, 74: 01, 75: 00, 6F: 84, 70: 00</span></span>
<span class="line"><span style="color: #F8F8F2">   WRITE 60CD -&gt; 84 --- 73: 00, 74: 00, 75: 00, 6F: 84, 70: 00</span></span>
<span class="line"><span style="color: #F8F8F2">READ  9D9B &lt;- 64    --- 73: 00, 74: 02, 75: 00, 6F: 00, 70: 00</span></span>
<span class="line"><span style="color: #F8F8F2">   WRITE 60CE -&gt; 00 --- 73: C8, 74: 00, 75: 00, 6F: 00, 70: 00</span></span>
<span class="line"><span style="color: #F8F8F2">READ  9D9C &lt;- 01    --- 73: 00, 74: 09, 75: 03, 6F: 64, 70: 00</span></span>
<span class="line"><span style="color: #F8F8F2">READ  9D9D &lt;- 00    --- 73: 00, 74: 01, 75: 03, 6F: 01, 70: 64</span></span>
<span class="line"><span style="color: #F8F8F2">   WRITE 60CF -&gt; 84 --- 73: 00, 74: 00, 75: 03, 6F: 01, 70: 00</span></span>
<span class="line"><span style="color: #F8F8F2">   WRITE 60D0 -&gt; 00 --- 73: 00, 74: 00, 75: 02, 6F: 01, 70: 00</span></span>
<span class="line"><span style="color: #F8F8F2">   WRITE 60D1 -&gt; 84 --- 73: 00, 74: 00, 75: 01, 6F: 01, 70: 00</span></span>
<span class="line"><span style="color: #F8F8F2">READ  9D9E &lt;- A1    --- 73: 00, 74: 02, 75: 00, 6F: 00, 70: 00</span></span></code></pre></div></div></figure>
<p>Из этого лога уже можно извлечь почти всё, что нужно для понимания распаковки.</p>
<p>Это очень важный момент! Можно реверс-инжинирить алгоритм в IDA, или долго играться с отладчиком. А можно и не делать этого и перечитать раздел “вступление” ещё раз. <strong>РЕВЕРС НЕ НАВЫК, А СОСТОЯНИЕ</strong>. Т.е. можно обнаружить, что ты уже знаешь решение, просто глядя на трейс-лог, или гуляя по улице — это не фигура речи. Для проверки правильности решения придётся, конечно, использовать листик и ручку, или отладчик, и скорее всего первичная идея будет содержать ошибки, на само понимание находится где-то до использования инструментов. Всё, что дальше — уже просто проверка, тривиальная часть.</p>
<ul>
<li><p>Байты на выход выдаются не сразу после команды чтения, а с задержкой на какие-то операции, т.е. скорее всего команды кодируются некратным 8 числом бит</p>
</li>
<li><p>в ячейке 75 хранится число байт, который будут скопированы из самого выходного потока. Так как это значение не зависит от других управляющих ячеек, вероятно, существуют специальные команды, в которых количество повторов кодируется самой командой. Это важный вывод, который можно и нужно перепроверить</p>
</li>
</ul>
<figure class="shiki asm"><div class="codeblock"><div class="code"><pre class="shiki dracula"><code><span class="line"><span style="color: #BD93F9">07</span><span style="color: #F8F8F2">:</span><span style="color: #50FA7B">D4B0:</span><span style="color: #F8F8F2"> A9 </span><span style="color: #BD93F9">02</span><span style="color: #F8F8F2">     LDA #</span><span style="color: #BD93F9">$02</span><span style="color: #F8F8F2"> //immediate set</span></span>
<span class="line"><span style="color: #BD93F9">07</span><span style="color: #F8F8F2">:</span><span style="color: #50FA7B">D4B2:</span><span style="color: #F8F8F2"> </span><span style="color: #BD93F9">85</span><span style="color: #F8F8F2"> </span><span style="color: #BD93F9">75</span><span style="color: #F8F8F2">     STA </span><span style="color: #BD93F9">$75</span><span style="color: #F8F8F2"> repeats = #</span><span style="color: #BD93F9">$02</span></span></code></pre></div></div></figure>
<ul>
<li>в ячейке 74 — количество оставшихся для считывания бит для текущей команды. Если при этом “заканчиваются” биты в очередном байте из входной последовательности, считывается следующий</li>
</ul>
<p>Осталось разобрать, как именно работают команды, выдающие в выходой поток значения, которые уже находились в нём ранее.<br>Можно поставить точки остановки на область записи распакованных данных и внимательно посмотреть на байты на выходе в тех случаях, когда они не читаются из входного архива.</p>
<figure class="shiki"><div class="codeblock"><div class="code"><pre class="shiki dracula"><code><span class="line"><span style="color: #F8F8F2">WRITE 60C8 -&gt; 30  &lt;-----------\</span></span>
<span class="line"><span style="color: #F8F8F2">WRITE 60C9 -&gt; 00              |</span></span>
<span class="line"><span style="color: #F8F8F2">WRITE 60CA -&gt; 30 00 (2 байта) |</span></span>
<span class="line"><span style="color: #F8F8F2">WRITE 60CC -&gt; 06</span></span>
<span class="line"><span style="color: #F8F8F2">WRITE 60CD -&gt; 84  &lt;--------------\</span></span>
<span class="line"><span style="color: #F8F8F2">WRITE 60CE -&gt; 00                 |</span></span>
<span class="line"><span style="color: #F8F8F2">WRITE 60CF -&gt; 84 00 84 (3 байта) |</span></span>
<span class="line"><span style="color: #F8F8F2">...</span></span></code></pre></div></div></figure>
<p>Это и есть основной принцип работы алгоритма <code>LZSS</code> — он умеет ссылаться на уже существующие в выходной последовательности цепочки байт.</p>
<p>Можно заодно обратить внимание на интересную особенность — цепочка байт 60CF-60D1 использует ссылку на 60CD-60CF - конец этой цепочки еще не существует в выходной последовательности к моменту использования ссылки на неё (<code>overlapping-lookingahead</code>).</p>
<p><code>LZSS</code> можно считать обобщением <code>RLE</code> — <code>RLE</code> умеет ссылаться лишь 1 последний символ в выходной последовательности, а <code>LZSS</code> — на любую уже встреченную цепочку символов. Различные разновидности <code>LZSS</code>, в зависимости от выделенных на кодирование бит, ограничены в том, насколько далеко назад они могут заглянуть (<strong><code>размер скользящего окна</code></strong>) и на длину цепочки повторяющихся байт.</p>
<p>Раз входной поток работает на уровне бит, а не байт, то удобно было бы представить его в трейслоге в виде бит. Можно или вписать дополнительную информацию в скрипт трейса (чаще всего работа с битами осуществляется через сдвиги + проверку флага, в который попадаёт сдвинутый бит). Ну или просто набросать скрипт, который парсит уже имеющийся лог, но следит при этом за накопленными битами:</p>
<figure class="shiki python"><div class="codeblock"><div class="code"><pre class="shiki dracula"><code><span class="line"><span style="color: #FF79C6">def</span><span style="color: #F8F8F2"> </span><span style="color: #50FA7B">extract_byte_from_read_line</span><span style="color: #F8F8F2">(</span><span style="color: #FFB86C; font-style: italic">line</span><span style="color: #F8F8F2">):</span></span>
<span class="line"><span style="color: #F8F8F2">    hex_value </span><span style="color: #FF79C6">=</span><span style="color: #F8F8F2"> line.split(</span><span style="color: #E9F284">&#39;</span><span style="color: #F1FA8C">&lt;-</span><span style="color: #E9F284">&#39;</span><span style="color: #F8F8F2">)[</span><span style="color: #BD93F9">1</span><span style="color: #F8F8F2">].strip()[:</span><span style="color: #BD93F9">2</span><span style="color: #F8F8F2">]</span></span>
<span class="line"><span style="color: #F8F8F2">    </span><span style="color: #FF79C6">return</span><span style="color: #F8F8F2"> </span><span style="color: #8BE9FD">format</span><span style="color: #F8F8F2">(</span><span style="color: #8BE9FD; font-style: italic">int</span><span style="color: #F8F8F2">(hex_value, </span><span style="color: #BD93F9">16</span><span style="color: #F8F8F2">), </span><span style="color: #E9F284">&#39;</span><span style="color: #F1FA8C">08b</span><span style="color: #E9F284">&#39;</span><span style="color: #F8F8F2">)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF79C6">def</span><span style="color: #F8F8F2"> </span><span style="color: #50FA7B">extract_argument_from_74_line</span><span style="color: #F8F8F2">(</span><span style="color: #FFB86C; font-style: italic">line</span><span style="color: #F8F8F2">):</span></span>
<span class="line"><span style="color: #F8F8F2">    hex_argument </span><span style="color: #FF79C6">=</span><span style="color: #F8F8F2"> line.split(</span><span style="color: #E9F284">&#39;</span><span style="color: #F1FA8C">74:</span><span style="color: #E9F284">&#39;</span><span style="color: #F8F8F2">)[</span><span style="color: #BD93F9">1</span><span style="color: #F8F8F2">].split(</span><span style="color: #E9F284">&#39;</span><span style="color: #F1FA8C">,</span><span style="color: #E9F284">&#39;</span><span style="color: #F8F8F2">)[</span><span style="color: #BD93F9">0</span><span style="color: #F8F8F2">].strip()</span></span>
<span class="line"><span style="color: #F8F8F2">    </span><span style="color: #FF79C6">return</span><span style="color: #F8F8F2"> </span><span style="color: #8BE9FD; font-style: italic">int</span><span style="color: #F8F8F2">(hex_argument, </span><span style="color: #BD93F9">16</span><span style="color: #F8F8F2">)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF79C6">def</span><span style="color: #F8F8F2"> </span><span style="color: #50FA7B">process_write_command</span><span style="color: #F8F8F2">(</span><span style="color: #FFB86C; font-style: italic">accumulated_bits</span><span style="color: #F8F8F2">):</span></span>
<span class="line"><span style="color: #F8F8F2">    bit_string </span><span style="color: #FF79C6">=</span><span style="color: #F8F8F2"> </span><span style="color: #E9F284">&#39;&#39;</span><span style="color: #F8F8F2">.join(accumulated_bits)</span></span>
<span class="line"><span style="color: #F8F8F2">    </span><span style="color: #8BE9FD">print</span><span style="color: #F8F8F2">(</span><span style="color: #FF79C6">f</span><span style="color: #F1FA8C">&quot;</span><span style="color: #BD93F9">{</span><span style="color: #F8F8F2">bit_string</span><span style="color: #BD93F9">}</span><span style="color: #F1FA8C"> (</span><span style="color: #BD93F9">{</span><span style="color: #8BE9FD">len</span><span style="color: #F8F8F2">(accumulated_bits)</span><span style="color: #BD93F9">}</span><span style="color: #F1FA8C"> bits)&quot;</span><span style="color: #F8F8F2">)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF79C6">def</span><span style="color: #F8F8F2"> </span><span style="color: #50FA7B">parse_and_print_bits</span><span style="color: #F8F8F2">(</span><span style="color: #FFB86C; font-style: italic">lines</span><span style="color: #F8F8F2">):</span></span>
<span class="line"><span style="color: #F8F8F2">    current_byte </span><span style="color: #FF79C6">=</span><span style="color: #F8F8F2"> </span><span style="color: #BD93F9">None</span></span>
<span class="line"><span style="color: #F8F8F2">    bit_index </span><span style="color: #FF79C6">=</span><span style="color: #F8F8F2"> </span><span style="color: #BD93F9">0</span></span>
<span class="line"><span style="color: #F8F8F2">    accumulated_bits </span><span style="color: #FF79C6">=</span><span style="color: #F8F8F2"> []</span></span>
<span class="line"><span style="color: #F8F8F2">    command_lengths </span><span style="color: #FF79C6">=</span><span style="color: #F8F8F2"> </span><span style="color: #8BE9FD; font-style: italic">set</span><span style="color: #F8F8F2">()</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F8F8F2">    </span><span style="color: #FF79C6">for</span><span style="color: #F8F8F2"> line </span><span style="color: #FF79C6">in</span><span style="color: #F8F8F2"> lines:</span></span>
<span class="line"><span style="color: #F8F8F2">        line </span><span style="color: #FF79C6">=</span><span style="color: #F8F8F2"> line.strip()</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F8F8F2">        </span><span style="color: #FF79C6">if</span><span style="color: #F8F8F2"> line.startswith(</span><span style="color: #E9F284">&#39;</span><span style="color: #F1FA8C">READ</span><span style="color: #E9F284">&#39;</span><span style="color: #F8F8F2">):</span></span>
<span class="line"><span style="color: #F8F8F2">            current_byte </span><span style="color: #FF79C6">=</span><span style="color: #F8F8F2"> extract_byte_from_read_line(line)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F8F8F2">        </span><span style="color: #FF79C6">elif</span><span style="color: #F8F8F2"> line.startswith(</span><span style="color: #E9F284">&#39;</span><span style="color: #F1FA8C">74 ---</span><span style="color: #E9F284">&#39;</span><span style="color: #F8F8F2">):</span></span>
<span class="line"><span style="color: #F8F8F2">            argument </span><span style="color: #FF79C6">=</span><span style="color: #F8F8F2"> extract_argument_from_74_line(line)</span></span>
<span class="line"><span style="color: #F8F8F2">            </span><span style="color: #FF79C6">if</span><span style="color: #F8F8F2"> argument </span><span style="color: #FF79C6">!=</span><span style="color: #F8F8F2"> </span><span style="color: #BD93F9">0</span><span style="color: #F8F8F2"> </span><span style="color: #FF79C6">and</span><span style="color: #F8F8F2"> current_byte </span><span style="color: #FF79C6">is</span><span style="color: #F8F8F2"> </span><span style="color: #FF79C6">not</span><span style="color: #F8F8F2"> </span><span style="color: #BD93F9">None</span><span style="color: #F8F8F2">:</span></span>
<span class="line"><span style="color: #F8F8F2">                accumulated_bits.append(current_byte[bit_index])</span></span>
<span class="line"><span style="color: #F8F8F2">                bit_index </span><span style="color: #FF79C6">=</span><span style="color: #F8F8F2"> (bit_index </span><span style="color: #FF79C6">+</span><span style="color: #F8F8F2"> </span><span style="color: #BD93F9">1</span><span style="color: #F8F8F2">) </span><span style="color: #FF79C6">%</span><span style="color: #F8F8F2"> </span><span style="color: #BD93F9">8</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F8F8F2">        </span><span style="color: #FF79C6">elif</span><span style="color: #F8F8F2"> line.startswith(</span><span style="color: #E9F284">&#39;</span><span style="color: #F1FA8C">WRITE</span><span style="color: #E9F284">&#39;</span><span style="color: #F8F8F2">):</span></span>
<span class="line"><span style="color: #F8F8F2">            </span><span style="color: #FF79C6">if</span><span style="color: #F8F8F2"> accumulated_bits:</span></span>
<span class="line"><span style="color: #F8F8F2">                command_lengths.add(</span><span style="color: #8BE9FD">len</span><span style="color: #F8F8F2">(accumulated_bits))</span></span>
<span class="line"><span style="color: #F8F8F2">                process_write_command(accumulated_bits)</span></span>
<span class="line"><span style="color: #F8F8F2">                </span><span style="color: #8BE9FD">print</span><span style="color: #F8F8F2">(</span><span style="color: #E9F284">&quot;</span><span style="color: #F1FA8C">  </span><span style="color: #E9F284">&quot;</span><span style="color: #F8F8F2"> </span><span style="color: #FF79C6">+</span><span style="color: #F8F8F2"> line.split(</span><span style="color: #E9F284">&quot;</span><span style="color: #F1FA8C">---</span><span style="color: #E9F284">&quot;</span><span style="color: #F8F8F2">)[</span><span style="color: #BD93F9">0</span><span style="color: #F8F8F2">])</span></span>
<span class="line"><span style="color: #F8F8F2">            accumulated_bits </span><span style="color: #FF79C6">=</span><span style="color: #F8F8F2"> []</span></span>
<span class="line"><span style="color: #F8F8F2">            </span></span>
<span class="line"><span style="color: #F8F8F2">    </span><span style="color: #8BE9FD">print</span><span style="color: #F8F8F2">(</span><span style="color: #FF79C6">f</span><span style="color: #F1FA8C">&quot;Commands lengths: </span><span style="color: #BD93F9">{</span><span style="color: #F8F8F2">command_lengths</span><span style="color: #BD93F9">}</span><span style="color: #F1FA8C">&quot;</span><span style="color: #F8F8F2">)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF79C6">with</span><span style="color: #F8F8F2"> </span><span style="color: #8BE9FD">open</span><span style="color: #F8F8F2">(</span><span style="color: #E9F284">&quot;</span><span style="color: #F1FA8C">jp_unpack_60C8_72CB.txt</span><span style="color: #E9F284">&quot;</span><span style="color: #F8F8F2">, </span><span style="color: #E9F284">&quot;</span><span style="color: #F1FA8C">rt</span><span style="color: #E9F284">&quot;</span><span style="color: #F8F8F2">) </span><span style="color: #FF79C6">as</span><span style="color: #F8F8F2"> file:</span></span>
<span class="line"><span style="color: #F8F8F2">    lines </span><span style="color: #FF79C6">=</span><span style="color: #F8F8F2"> file.readlines()</span></span>
<span class="line"><span style="color: #F8F8F2">parse_and_print_bits(lines)</span></span></code></pre></div></div></figure>
<p>(тривиальная логика, следим за состоянием 74 - ячейки которая контроллирует, сколько бит осталось прочитать в текущей команде)</p>
<p>Обнаруживаем, что есть всего 4 типа команд - из 9, 13, 15 и 23 бит:</p>
<figure class="shiki"><div class="codeblock"><div class="code"><pre class="shiki dracula"><code><span class="line"><span style="color: #F8F8F2">000110000 (9 bits)</span></span>
<span class="line"><span style="color: #F8F8F2">  WRITE 60C8 -&gt; 30</span></span>
<span class="line"><span style="color: #F8F8F2">100000000001 (12 bits)</span></span>
<span class="line"><span style="color: #F8F8F2">  WRITE 60CA -&gt; 30 </span></span>
<span class="line"><span style="color: #F8F8F2">  WRITE 60CB -&gt; 00</span></span>
<span class="line"><span style="color: #F8F8F2">110010000000001 (15 bits)</span></span>
<span class="line"><span style="color: #F8F8F2">  WRITE 60CF -&gt; 84 </span></span>
<span class="line"><span style="color: #F8F8F2">  WRITE 60D0 -&gt; 00 </span></span>
<span class="line"><span style="color: #F8F8F2">  WRITE 60D1 -&gt; 84</span></span>
<span class="line"><span style="color: #F8F8F2">11000000001100001011101 (23 bits)</span></span>
<span class="line"><span style="color: #F8F8F2">  WRITE 729F -&gt; 84 </span></span>
<span class="line"><span style="color: #F8F8F2">  WRITE 72A0 -&gt; 3A </span></span>
<span class="line"><span style="color: #F8F8F2">  WRITE 72A1 -&gt; 84 </span></span>
<span class="line"><span style="color: #F8F8F2">  WRITE 72A2 -&gt; 3A </span></span>
<span class="line"><span style="color: #F8F8F2">  WRITE 72A3 -&gt; 84 </span></span>
<span class="line"><span style="color: #F8F8F2">  WRITE 72A4 -&gt; 3A </span></span>
<span class="line"><span style="color: #F8F8F2">  WRITE 72A5 -&gt; 84 </span></span>
<span class="line"><span style="color: #F8F8F2">  WRITE 72A6 -&gt; 3A </span></span>
<span class="line"><span style="color: #F8F8F2">  WRITE 72A7 -&gt; 84 </span></span>
<span class="line"><span style="color: #F8F8F2">  WRITE 72A8 -&gt; 3A </span></span>
<span class="line"><span style="color: #F8F8F2">  WRITE 72A9 -&gt; 84 </span></span>
<span class="line"><span style="color: #F8F8F2">  WRITE 72AA -&gt; 3A </span></span>
<span class="line"><span style="color: #F8F8F2">  WRITE 72AB -&gt; 84 </span></span>
<span class="line"><span style="color: #F8F8F2">  WRITE 72AC -&gt; 34 </span></span>
<span class="line"><span style="color: #F8F8F2">  WRITE 72AD -&gt; 84</span></span></code></pre></div></div></figure>
<p>Такого лога достаточно для расшифровки формата команд (в полном логе их сотни)<br><figure class="shiki"><div class="codeblock"><div class="code"><pre class="shiki dracula"><code><span class="line"><span style="color: #F8F8F2">0 00110000</span></span>
<span class="line"><span style="color: #F8F8F2">команда выдачи несжатого байта из входного потока, 0 - код команды</span></span>
<span class="line"><span style="color: #F8F8F2"></span></span>
<span class="line"><span style="color: #F8F8F2">10 0000000001</span></span>
<span class="line"><span style="color: #F8F8F2">команда копирования 2х байт (2 - константа, не закодировано в команде)</span></span>
<span class="line"><span style="color: #F8F8F2">Биты 10 - код команды</span></span>
<span class="line"><span style="color: #F8F8F2">Байты считываются по 10-битному смещению назад от текушей позиции выходного потока</span></span>
<span class="line"><span style="color: #F8F8F2"></span></span>
<span class="line"><span style="color: #F8F8F2">11000 00000110 0001011101</span></span>
<span class="line"><span style="color: #F8F8F2">команда копирования 9+X байт из выходного потока</span></span>
<span class="line"><span style="color: #F8F8F2">Биты 11000 - код команды</span></span>
<span class="line"><span style="color: #F8F8F2">Количество закодировано 8 битами (9+0b00000110 = 15 байт)</span></span>
<span class="line"><span style="color: #F8F8F2">Смещение закодировано 10 битами</span></span>
<span class="line"><span style="color: #F8F8F2"></span></span>
<span class="line"><span style="color: #F8F8F2">11 001 0000000001</span></span>
<span class="line"><span style="color: #F8F8F2">команда копирования 2+X байт из выходного потока</span></span>
<span class="line"><span style="color: #F8F8F2">Количество закодировано 3 битами - (2+0b001 = 3 байта)</span></span>
<span class="line"><span style="color: #F8F8F2">Смещение закодировано 10 битами</span></span></code></pre></div></div></figure></p>
<p>Или в виде блок-схемы:<br><img src="/blog/17440519/diagram.png" alt></p>
<p>4612 байт карты сжимаются этим алгоритмом в 1822 байт архива.</p>
<h2><span id="semeystvo-lzss">Семейство LZSS</span><a href="#semeystvo-lzss" class="header-anchor">#</a></h2><p>В отличие от классического <a target="_blank" rel="noopener" href="https://ru.wikipedia.org/wiki/LZSS">LZSS</a>, здесь использованы 3 типа команд копирования фразы разной длины, чтобы сэкономить немного места на более коротких повторяющихся последовательностях.</p>
<p>Алгоритм активно использовался еще как минимум 2 поколения консолей, так что похожие трюки и вариации можно найти в большинстве компрессоров для Sega Mega Drive или SNES:<br><a target="_blank" rel="noopener" href="https://github.com/lab313ru/lzkn">lzkn</a> — 3 варианта сжатия <code>Konami</code><br><a target="_blank" rel="noopener" href="https://github.com/flamewing/mdcomp">mdcomp</a> — компрессоры из <code>Sonic</code> (Kosinski, Nemesis, Saxman и другие). Generic код, с поддержкой нескольких вариантов алгоритма.</p>
<p>Отличия в вариациях алгоритмов:</p>
<ul>
<li>Часто биты команд сгруппированаы в отдельные байты (description fields), а не перемешаны с битами данных. Связано это с тем, что считывать и работать с целыми байтами быстрее — можно передать 8 несжатых байт выравненными блоками</li>
<li>С этим же связана подстройка размера команд и сжатых данных под выравнивание</li>
<li>Биты/байты команд могут вообще храниться в отдельном потоке, независимом от потока аргументов этих команд (смещений и длин цепочек). Опционально — в little или big-endian.</li>
<li>Некоторые вариации умеют брать данные не только из окна выходного буфера, а откуда-нибудь ещё (захардкоженные словари или просто нули)</li>
<li>Небольшие отличия в порядке хранения байт данных и байт команд из сжатого потока:<ul>
<li>пишется ли следующий байт команд сразу, как заканчиваются биты предыдущего, или только когда потребуются новые биты </li>
<li>необходим ли финальный байт команд (например, если в нём могут содержаться биты окончания потока)</li>
</ul>
</li>
</ul>
<p>В <strong><code>mdcomp</code></strong> эти настройки вынесены в шаблонный класс-адаптор <a target="_blank" rel="noopener" href="https://github.com/flamewing/mdcomp/blob/26bfc205b96afe04e0941d3092865eaf6c972f81/include/mdcomp/lzss.hh#L223">LZSSAdaptor</a></p>
<p>Кроме различий в кодировании команд могут отличаться также и алгоритмы компрессии. Большинство компрессоров реализуют примитивный алгоритм поиска подстроки в скользящем окне. Возможные оптимизации:</p>
<ul>
<li>использование структур для более быстрого поиска подстроки (<a target="_blank" rel="noopener" href="https://github.com/flamewing/mdcomp/blob/26bfc205b96afe04e0941d3092865eaf6c972f81/include/mdcomp/lzss.hh#L223">сравнение</a>).</li>
<li>проверка не только самой длинной подстроки, не и более коротких — с набором укороченных команд это может дать лучший результат (<a target="_blank" rel="noopener" href="https://sonicresearch.org/community/index.php?threads/konami-compression-tools.5937/#post-84424">пример</a> для Kosinki)</li>
<li>учёт самопересечения цепочки — байт начала цепочки, выданные в выходной буфер, могут служить концом этой же цепочки (<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/31347593/matches-overlapping-lookahead-on-lz77-lzss-with-suffix-trees">overlapping-lookahead</a>)</li>
</ul>
<p>Репо со скриптами и логами<br><a target="_blank" rel="noopener" href="https://github.com/spiiin/nes_compression/tree/main/jurassic_park">https://github.com/spiiin/nes_compression/tree/main/jurassic_park</a></p>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"Ov23liG1mZbiQOIdi91X","clientSecret":"e05812685eb741a752982b89dcf6f5b58dc10251","repo":"spiiin.github.io","owner":"spiiin","admin":["spiiin"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script></div></article><div class="pagination"><a class="pagination__link pagination__prev" href="/blog/2455145615/">Позже</a><a class="pagination__link pagination__next" href="/blog/3460926079/">Раньше</a></div></main><footer class="footer metadata"><p class="footer__text">© 2024 spiiin</p><p class="footer__text">Powered by <a class="footer__text__link" href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a class="footer__text__link" href="https://pages.github.com/" target="_blank">Github Page</a></p></footer></div><!-- hexo injector body_end start -->
  <script>
  const CODE_CONFIG = {
    beautify: undefined,
    highlightCopy: undefined,
    highlightLang: undefined,
    highlightHeightLimit: undefined,
    isHighlightShrink: undefined,
    copy: {
      success: 'undefined',
      error: 'undefined',
      noSupport: 'undefined',
    }
  };
  console.log(
    `%c hexo-shiki-plugin %c v1.0.27 %c https://github.com/nova1751/hexo-shiki-plugin`,
    "color: #fff; background: #5f5f5f",
    "color: #fff; background: #80c8f8",
    ""
  );
  </script>
  <!-- hexo injector body_end end --></body></html>