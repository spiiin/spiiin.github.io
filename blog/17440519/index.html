<!DOCTYPE html><html lang="ru"><head><meta charset="UTF-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Spiiin's blog | Формат сжатия уровней в Jurassic Park [NES]</title><meta name="description" content="&lt;p&gt;Давно не затрагивал тему реверс-инжиниринга NES игр. После разбора блочного формата описания &lt;a href=&quot;(https://spiiin.github.io/CadEditor/cadeditor-supported-games.html&quot;&gt;уровней&lt;/a&gt;), остались несколько игр, отмеченных как &lt;em&gt;comp&lt;/em&gt; (уровень в ROM сжат). Сжатие уровней редко используется в играх NES, чаще сжимается текст или данные описания графики. Да и сам блочный формат уровня уже является формой экономии информации.&lt;/p&gt;
&lt;p&gt;Тем не менее некоторые игры используют сжатие &lt;a href=&quot;https://en.wikipedia.org/wiki/Run-length_encoding&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;RLE&lt;/a&gt;. В простых формах, как в &lt;code&gt;Contra&lt;/code&gt;, или в более сложных, как в &lt;a href=&quot;/blog/1486764983/&quot; title=&quot;Felix The Cat&quot;&gt;Felix The Cat&lt;/a&gt; , где применяется гибрид RLE и словарного метода. Другие применяют формы &lt;strong&gt;&lt;code&gt;&amp;quot;описания на холсте&amp;quot;&lt;/code&gt;&lt;/strong&gt;, когда команды отрисовки задаются в виде “нарисуй что-то в координатах X,Y” (описание карты мира в играх &lt;code&gt;Capcom&lt;/code&gt; или уровней в &lt;code&gt;Super Mario Bros&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Это относительно простые алгоритмы. Но отдельные игры идут дальше и применяют более совершенные формы сжатия:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://romhack.github.io/doc/halCompression/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Kirby&lt;/a&gt; и другие игры &lt;code&gt;HAL&lt;/code&gt; - гибрид LZ алгоритмов и RLE, с несколькими командами вроде “следующие биты развернуть”.&lt;br&gt;&lt;a href=&quot;https://github.com/romhack/codemastersMarkov&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Dizzy&lt;/a&gt; и другие игры &lt;code&gt;Codemasters&lt;/code&gt; - сжатие графики цепями Маркова.&lt;/p&gt;
&lt;p&gt;Формат уровней этих игр описан. Однако, в моём списке игр, добавленных в &lt;a href=&quot;https://github.com/spiiin/CadEditor/blob/master/CadEditor/cad_editor_supported_games.txt&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CadEditor&lt;/a&gt; были ещё две — &lt;code&gt;Jurassic Park&lt;/code&gt; и &lt;code&gt;James Bond Jr&lt;/code&gt;. Я выбрал для разбора &lt;code&gt;Jurassic Park&lt;/code&gt;, потому что знал, что в нём используется разновидность &lt;a href=&quot;https://en.wikipedia.org/wiki/LZ77_and_LZ78&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LZ&lt;/a&gt;, потому что хотел заодно прочитать про сам алгоритм и его разновидности.&lt;/p&gt;"><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=PT+Serif&amp;display=swap"><link rel="stylesheet" href="/css/highlights/darkula.css"><link rel="stylesheet" href="/css/main.css"><link rel="search" type="application/opensearchdescription+xml" href="http://spiiin.github.io/atom.xml" title="Spiiin's blog"><script>(function (i, s, o, g, r, a, m) {
  i['GoogleAnalyticsObject'] = r;
  i[r] = i[r] || function () {
    (i[r].q = i[r].q || []).push(arguments)
  }, i[r].l = 1 * new Date();
  a = s.createElement(o),
    m = s.getElementsByTagName(o)[0];
  a.async = 1;
  a.src = g;
  m.parentNode.insertBefore(a, m)
})(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');
ga('create', 'UA-00000000-0', 'auto');
ga('send', 'pageview');</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Spiiin's blog" type="application/atom+xml">
</head><body><div class="container"><header class="main-header"><h1 class="main-header__title uplize"><a class="main-header__title__link" href="/"><img class="header-image" src="/images/favicon.png" width="36" height="36">Spiiin's blog</a></h1><nav class="main-header__nav"><ul class="main-nav"><li class="main-nav__list"><a class="main-nav__list__link" href="/" target="_self">HOME</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/archives/" target="_self">ARCHIVE</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/tags/meta" target="_self">TAGS</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/blog/1" target="_self">ABOUT</a></li></ul></nav></header><main class="container__wrapper"><div class="pagination"><a class="pagination__link pagination__prev" href="/blog/2455145615/">Позже</a><a class="pagination__link pagination__next" href="/blog/3460926079/">Раньше</a></div><article class="article post"><h3 class="article__title">Формат сжатия уровней в Jurassic Park [NES]</h3><div class="article__date metadata"><div class="post-info">2023/12/19</div></div><div class="article__tags metadata">Tags:
<a class="article__tags__link metadata" href="/tags/nes/">nes</a><a class="article__tags__link metadata" href="/tags/hack/">hack</a></div><div class="article__body"><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Давно не затрагивал тему реверс-инжиниринга NES игр. После разбора блочного формата описания <a href="(https://spiiin.github.io/CadEditor/cadeditor-supported-games.html">уровней</a>), остались несколько игр, отмеченных как <em>comp</em> (уровень в ROM сжат). Сжатие уровней редко используется в играх NES, чаще сжимается текст или данные описания графики. Да и сам блочный формат уровня уже является формой экономии информации.</p>
<p>Тем не менее некоторые игры используют сжатие <a href="https://en.wikipedia.org/wiki/Run-length_encoding" target="_blank" rel="noopener">RLE</a>. В простых формах, как в <code>Contra</code>, или в более сложных, как в <a href="/blog/1486764983/" title="Felix The Cat">Felix The Cat</a> , где применяется гибрид RLE и словарного метода. Другие применяют формы <strong><code>&quot;описания на холсте&quot;</code></strong>, когда команды отрисовки задаются в виде “нарисуй что-то в координатах X,Y” (описание карты мира в играх <code>Capcom</code> или уровней в <code>Super Mario Bros</code>).</p>
<p>Это относительно простые алгоритмы. Но отдельные игры идут дальше и применяют более совершенные формы сжатия:</p>
<p><a href="https://romhack.github.io/doc/halCompression/" target="_blank" rel="noopener">Kirby</a> и другие игры <code>HAL</code> - гибрид LZ алгоритмов и RLE, с несколькими командами вроде “следующие биты развернуть”.<br><a href="https://github.com/romhack/codemastersMarkov" target="_blank" rel="noopener">Dizzy</a> и другие игры <code>Codemasters</code> - сжатие графики цепями Маркова.</p>
<p>Формат уровней этих игр описан. Однако, в моём списке игр, добавленных в <a href="https://github.com/spiiin/CadEditor/blob/master/CadEditor/cad_editor_supported_games.txt" target="_blank" rel="noopener">CadEditor</a> были ещё две — <code>Jurassic Park</code> и <code>James Bond Jr</code>. Я выбрал для разбора <code>Jurassic Park</code>, потому что знал, что в нём используется разновидность <a href="https://en.wikipedia.org/wiki/LZ77_and_LZ78" target="_blank" rel="noopener">LZ</a>, потому что хотел заодно прочитать про сам алгоритм и его разновидности.</p>
<a id="more"></a>
<h2 id="Вступление"><a href="#Вступление" class="headerlink" title="Вступление"></a>Вступление</h2><p>(оно же отступление)</p>
<p>При исследовании нового ты оказываешься перед уникальной задачей <strong>один на один</strong>. В CadEditor-е есть пара кусков кода, связанных с LZ-сжатием ( <a href="https://spiiin.github.io/CadEditor/cadeditor-using-lzkn.html">LZKN</a>, написанный <code>DrMephisto</code>, и <a href="/blog/1579894033/" title="карты FFTA">карты FFTA</a> авторства <code>DarcyMiles</code>), но я не касался этого алгоритма на NES.</p>
<p>Я не реверсил NES-игры на протяжении пяти лет, и успел забыть, что это скорее не навык, а состояние. </p>
<blockquote><p>“Глядя на мерцающие экраны и на безбрежный поток данных, поднятый моими алгоритмами и мчащийся в никуда по виртуальному пространству цифрового мира, я часто думаю: где я в этом потоке битов и байтов?”</p>
<footer><strong>ChatGPT который плагиатит Анонима который плагиатит Чингизхана</strong></footer></blockquote>
<p>Когда результат УЖЕ найден, алгоритм кажется тривиальным. Но до этого смотришь на матрицу байт, и бесконечный ассемблерный листинг, вообще без понятия, что перед тобой. Потом, когда нашёл свой Диснейленд (<a href="https://exsistencia.livejournal.com/3261.html" target="_blank" rel="noopener">Бодрийаровский</a>) в пещере, забываешь о состоянии, в котором был, пока смотрел в темноту. Поэтому я ценю описание состояния, а не откомментированный результат.</p>
<h2 id="Блоки"><a href="#Блоки" class="headerlink" title="Блоки"></a>Блоки</h2><p>Первое, что можно сделать — закинуть в темноту <a href="/blog/2598119234/" title="лидар">лидар</a> (<code>autocorrupter + blockfinder</code>), который покажет “общую форму пещеры”.</p>
<p>Он отлично работает и на сжатых картах, единственное, что запускать его нужно не на область ROM, а на область RAM, в которой находятся расжатые данные. Он показывает, что:</p>
<ul>
<li><p>описание карты уровня расположено по адресам 0x60C8-0x72CB, индексами блоков, по 2 байта на блок. 3 нибла кодируют номер блока, 4-й - физические свойства блока<br>(является ли блок выходом из уровня, препятствием, передним или задним фоном)</p>
</li>
<li><p>размер блока 2x2, описание которых асположено по адресам 0x76CC, блоков 352 штуки</p>
</li>
<li><p>слой бит палитры блоков описан отдельно от описания блоков. Т.е. любой блок можно окрасить в любую из 4х палитр<br><img src="/blog/17440519/jp_map0_small.png" alt=""></p>
</li>
</ul>
<p>Также обнаруживается интересная особенность — игра переключает активный банк видеопамяти блоков, когда игрок выходит из нижней или верхней трети экрана в центральную часть. Так что блоки с индексами &gt;0x80 могут распологаться только в нижней трети уровня (ими в первом уровне отрисованы здания).<br><img src="/blog/17440519/jp_map1_small.png" alt=""></p>
<p>(<a href="https://github.com/spiiin/CadEditor/blob/master/CadEditor/settings_nes/jurassic_park/Settings_JurassicPark_1.cs" target="_blank" rel="noopener">Конфиг для CadEditor-а</a>)</p>
<p>Область 0x1000-0x7FFF - это 6-кб CHR-RAM, память доступная для записи, располагается на картридже, в дополнение к 2кб памяти NES (это один из самых больших <a href="https://nescartdb.com/profile/view/1038/jurassic-park" target="_blank" rel="noopener">картриджей</a>)</p>
<h2 id="Декомпрессия"><a href="#Декомпрессия" class="headerlink" title="Декомпрессия"></a>Декомпрессия</h2><p>Если поставить брейкпоинт на запись в 0x60C8 (это значение прописано в игре хардкодом как область распаковки), можно выйти на адрес архива в ROM - 0x9D94 (адрес записан в ячейки памяти 95-96).</p>
<p>Также, изучай трейслог между чтением байта из ROM и записью в RAM, стоит запомнить все ячейки, которые изменяются походу — 6F, 70, 73, 74, 75.<br>(<em>меня восхищает, что трейслог команд на ассемблере 6502 может разобрать chatgpt, очень интересно было бы узнать, на каких входных данных он обучился</em>)</p>
<p>Первые байты архива в ROM и соответствующие им байты распакованных данных:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x9D94: 18 00 20 04 0C 84 00 64</span><br><span class="line">0x60C8: 30 00 30 00 06 84 00 84</span><br></pre></td></tr></table></figure></p>
<p>Пока что связь между сжатыми данными и расжатыми неочевидна. Просто изменять наугад байты архива в ROM (например 0x648C) бесполезно, меняется большая группа распакованных данных, на стенках нашей тёмной пещеры из байт оказывается калейдоскоп из зеркал, отражающих лучи по непредсказуемым траекториям<br><img src="/blog/17440519/jp3.png" alt=""></p>
<p>Более изящный способ — написать lua-скрипт для эмулятора, который будет трассировать в файл все чтения из архива и записи распакованных данных, а также состояние управляющих распаковкой ячеек.</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> logFile = <span class="built_in">io</span>.<span class="built_in">open</span>(<span class="string">"jp_unpack1.txt"</span>, <span class="string">"w"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">readMemoryValues</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        memory.readbyte(<span class="number">0x73</span>),</span><br><span class="line">        memory.readbyte(<span class="number">0x74</span>),</span><br><span class="line">        memory.readbyte(<span class="number">0x75</span>),</span><br><span class="line">        memory.readbyte(<span class="number">0x6F</span>),</span><br><span class="line">        memory.readbyte(<span class="number">0x70</span>)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">logMemoryOperation</span><span class="params">(operation, address, value)</span></span></span><br><span class="line">    <span class="keyword">local</span> values = readMemoryValues()</span><br><span class="line">    logFile:<span class="built_in">write</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">"%s %04X %s %02X --- 73: %02X, 74: %02X, 75: %02X, 6F: %02X, 70: %02X\n"</span>,</span><br><span class="line">                                operation, address, operation == <span class="string">"WRITE"</span> <span class="keyword">and</span> <span class="string">"-&gt;"</span> <span class="keyword">or</span> <span class="string">"&lt;-"</span>, value,</span><br><span class="line">                                <span class="built_in">table</span>.<span class="built_in">unpack</span>(values)))</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">onRead</span><span class="params">(address, size, value)</span></span></span><br><span class="line">    logMemoryOperation(<span class="string">"READ "</span>, address, value)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">onWrite</span><span class="params">(address, size, value)</span></span></span><br><span class="line">    logMemoryOperation(<span class="string">"WRITE"</span>, address, value)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">onWriteExt</span><span class="params">(address, size, value)</span></span></span><br><span class="line">    logMemoryOperation(<span class="string">"     "</span>, address, value)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">registerMemoryCallbacks</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> readRangeStart, readRangeEnd = <span class="number">0x9D94</span>, <span class="number">0xA4B1</span></span><br><span class="line">    <span class="keyword">local</span> writeRangeStart, writeRangeEnd = <span class="number">0x60C8</span>, <span class="number">0x72CB</span></span><br><span class="line">    <span class="keyword">local</span> extendedWriteAddresses = &#123;<span class="number">0x6F</span>, <span class="number">0x70</span>, <span class="number">0x73</span>, <span class="number">0x74</span>, <span class="number">0x75</span>&#125;</span><br><span class="line"></span><br><span class="line">    memory.registerread(readRangeStart, readRangeEnd - readRangeStart + <span class="number">1</span>, onRead)</span><br><span class="line">    memory.registerwrite(writeRangeStart, writeRangeEnd - writeRangeStart + <span class="number">1</span>, onWrite)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, address <span class="keyword">in</span> <span class="built_in">ipairs</span>(extendedWriteAddresses) <span class="keyword">do</span></span><br><span class="line">        memory.registerwrite(address, <span class="number">1</span>, onWriteExt)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">registerMemoryCallbacks()</span><br><span class="line"></span><br><span class="line">emu.registerexit(<span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">if</span> logFile <span class="keyword">then</span></span><br><span class="line">        logFile:<span class="built_in">close</span>()</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>)</span><br></pre></td></tr></table></figure>
<p>Получается такой лог (большая часть незначащей информации вырезана)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">READ  9D94 &lt;- 18    --- 73: 00, 74: 00, 75: 00, 6F: 00, 70: 00</span><br><span class="line">READ  9D95 &lt;- 00    --- 73: 00, 74: 02, 75: 00, 6F: 18, 70: 00</span><br><span class="line">   WRITE 60C8 -&gt; 30 --- 73: 00, 74: 00, 75: 00, 6F: 30, 70: 00</span><br><span class="line">READ  9D96 &lt;- 20    --- 73: 00, 74: 03, 75: 00, 6F: 00, 70: 00</span><br><span class="line">   WRITE 60C9 -&gt; 00 --- 73: 80, 74: 00, 75: 00, 6F: 00, 70: 00</span><br><span class="line">                 75 --- 73: 00, 74: 00, 75: 02, 6F: 02, 70: 00</span><br><span class="line">                 74 --- 73: 00, 74: 0A, 75: 02, 6F: 02, 70: 00</span><br><span class="line">                 73 --- 73: 00, 74: 0A, 75: 02, 6F: 02, 70: 00</span><br><span class="line">                 6F --- 73: 00, 74: 0A, 75: 02, 6F: 04, 70: 00</span><br><span class="line">                 70 --- 73: 00, 74: 0A, 75: 02, 6F: 04, 70: 00</span><br><span class="line">                 74 --- 73: 00, 74: 09, 75: 02, 6F: 04, 70: 00</span><br><span class="line">                 73 --- 73: 00, 74: 09, 75: 02, 6F: 04, 70: 00</span><br><span class="line">                 6F --- 73: 00, 74: 09, 75: 02, 6F: 08, 70: 00</span><br><span class="line">                 70 --- 73: 00, 74: 09, 75: 02, 6F: 08, 70: 00</span><br><span class="line">                 74 --- 73: 00, 74: 08, 75: 02, 6F: 08, 70: 00</span><br><span class="line">                 73 --- 73: 00, 74: 08, 75: 02, 6F: 08, 70: 00</span><br><span class="line">                 6F --- 73: 00, 74: 08, 75: 02, 6F: 10, 70: 00</span><br><span class="line">                 70 --- 73: 00, 74: 08, 75: 02, 6F: 10, 70: 00</span><br><span class="line">                 74 --- 73: 00, 74: 07, 75: 02, 6F: 10, 70: 00</span><br><span class="line">                 73 --- 73: 00, 74: 07, 75: 02, 6F: 10, 70: 00</span><br><span class="line">                 6F --- 73: 00, 74: 07, 75: 02, 6F: 20, 70: 00</span><br><span class="line">                 70 --- 73: 00, 74: 07, 75: 02, 6F: 20, 70: 00</span><br><span class="line">READ  9D97 &lt;- 04    --- 73: 00, 74: 07, 75: 02, 6F: 20, 70: 00</span><br><span class="line">   WRITE 60CA -&gt; 30 --- 73: 00, 74: 00, 75: 02, 6F: 01, 70: 00</span><br><span class="line">   WRITE 60CB -&gt; 00 --- 73: 00, 74: 00, 75: 01, 6F: 01, 70: 00</span><br><span class="line">READ  9D98 &lt;- 0C    --- 73: 00, 74: 08, 75: 00, 6F: 04, 70: 00</span><br><span class="line">   WRITE 60CC -&gt; 06 --- 73: 00, 74: 00, 75: 00, 6F: 06, 70: 00</span><br><span class="line">READ  9D99 &lt;- 84    --- 73: 00, 74: 01, 75: 00, 6F: 0C, 70: 00</span><br><span class="line">READ  9D9A &lt;- 00    --- 73: 00, 74: 01, 75: 00, 6F: 84, 70: 00</span><br><span class="line">   WRITE 60CD -&gt; 84 --- 73: 00, 74: 00, 75: 00, 6F: 84, 70: 00</span><br><span class="line">READ  9D9B &lt;- 64    --- 73: 00, 74: 02, 75: 00, 6F: 00, 70: 00</span><br><span class="line">   WRITE 60CE -&gt; 00 --- 73: C8, 74: 00, 75: 00, 6F: 00, 70: 00</span><br><span class="line">READ  9D9C &lt;- 01    --- 73: 00, 74: 09, 75: 03, 6F: 64, 70: 00</span><br><span class="line">READ  9D9D &lt;- 00    --- 73: 00, 74: 01, 75: 03, 6F: 01, 70: 64</span><br><span class="line">   WRITE 60CF -&gt; 84 --- 73: 00, 74: 00, 75: 03, 6F: 01, 70: 00</span><br><span class="line">   WRITE 60D0 -&gt; 00 --- 73: 00, 74: 00, 75: 02, 6F: 01, 70: 00</span><br><span class="line">   WRITE 60D1 -&gt; 84 --- 73: 00, 74: 00, 75: 01, 6F: 01, 70: 00</span><br><span class="line">READ  9D9E &lt;- A1    --- 73: 00, 74: 02, 75: 00, 6F: 00, 70: 00</span><br></pre></td></tr></table></figure>
<p>Из этого лога уже можно извлечь почти всё, что нужно для понимания распаковки.</p>
<p>Это очень важный момент! Можно реверс-инжинирить алгоритм в IDA, или долго играться с отладчиком. А можно и не делать этого и перечитать раздел “вступление” ещё раз. <strong>РЕВЕРС НЕ НАВЫК, А СОСТОЯНИЕ</strong>. Т.е. можно обнаружить, что ты уже знаешь решение, просто глядя на трейс-лог, или гуляя по улице — это не фигура речи. Для проверки правильности решения придётся, конечно, использовать листик и ручку, или отладчик, и скорее всего первичная идея будет содержать ошибки, на само понимание находится где-то до использования инструментов. Всё, что дальше — уже просто проверка, тривиальная часть.</p>
<ul>
<li><p>Байты на выход выдаются не сразу после команды чтения, а с задержкой на какие-то операции, т.е. скорее всего команды кодируются некратным 8 числом бит</p>
</li>
<li><p>в ячейке 75 хранится число байт, который будут скопированы из самого выходного потока. Так как это значение не зависит от других управляющих ячеек, вероятно, существуют специальные команды, в которых количество повторов кодируется самой командой. Это важный вывод, который можно и нужно перепроверить</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">07:D4B0: A9 02     LDA #$02 &#x2F;&#x2F;immediate set</span><br><span class="line">07:D4B2: 85 75     STA $75 repeats &#x3D; #$02</span><br></pre></td></tr></table></figure>
<ul>
<li>в ячейке 74 — количество оставшихся для считывания бит для текущей команды. Если при этом “заканчиваются” биты в очередном байте из входной последовательности, считывается следующий</li>
</ul>
<p>Осталось разобрать, как именно работают команды, выдающие в выходой поток значения, которые уже находились в нём ранее.<br>Можно поставить точки остановки на область записи распакованных данных и внимательно посмотреть на байты на выходе в тех случаях, когда они не читаются из входного архива.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WRITE 60C8 -&gt; 30  &lt;-----------\</span><br><span class="line">WRITE 60C9 -&gt; 00              |</span><br><span class="line">WRITE 60CA -&gt; 30 00 (2 байта) |</span><br><span class="line">WRITE 60CC -&gt; 06</span><br><span class="line">WRITE 60CD -&gt; 84  &lt;--------------\</span><br><span class="line">WRITE 60CE -&gt; 00                 |</span><br><span class="line">WRITE 60CF -&gt; 84 00 84 (3 байта) |</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>Это и есть основной принцип работы алгоритма <code>LZSS</code> — он умеет ссылаться на уже существующие в выходной последовательности цепочки байт.</p>
<p>Можно заодно обратить внимание на интересную особенность — цепочка байт 60CF-60D1 использует ссылку на 60CD-60CF - конец этой цепочки еще не существует в выходной последовательности к моменту использования ссылки на неё (<code>overlapping-lookingahead</code>).</p>
<p><code>LZSS</code> можно считать обобщением <code>RLE</code> — <code>RLE</code> умеет ссылаться лишь 1 последний символ в выходной последовательности, а <code>LZSS</code> — на любую уже встреченную цепочку символов. Различные разновидности <code>LZSS</code>, в зависимости от выделенных на кодирование бит, ограничены в том, насколько далеко назад они могут заглянуть (<strong><code>размер скользящего окна</code></strong>) и на длину цепочки повторяющихся байт.</p>
<p>Раз входной поток работает на уровне бит, а не байт, то удобно было бы представить его в трейслоге в виде бит. Можно или вписать дополнительную информацию в скрипт трейса (чаще всего работа с битами осуществляется через сдвиги + проверку флага, в который попадаёт сдвинутый бит). Ну или просто набросать скрипт, который парсит уже имеющийся лог, но следит при этом за накопленными битами:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract_byte_from_read_line</span><span class="params">(line)</span>:</span></span><br><span class="line">    hex_value = line.split(<span class="string">'&lt;-'</span>)[<span class="number">1</span>].strip()[:<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">return</span> format(int(hex_value, <span class="number">16</span>), <span class="string">'08b'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract_argument_from_74_line</span><span class="params">(line)</span>:</span></span><br><span class="line">    hex_argument = line.split(<span class="string">'74:'</span>)[<span class="number">1</span>].split(<span class="string">','</span>)[<span class="number">0</span>].strip()</span><br><span class="line">    <span class="keyword">return</span> int(hex_argument, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_write_command</span><span class="params">(accumulated_bits)</span>:</span></span><br><span class="line">    bit_string = <span class="string">''</span>.join(accumulated_bits)</span><br><span class="line">    print(<span class="string">f"<span class="subst">&#123;bit_string&#125;</span> (<span class="subst">&#123;len(accumulated_bits)&#125;</span> bits)"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_and_print_bits</span><span class="params">(lines)</span>:</span></span><br><span class="line">    current_byte = <span class="literal">None</span></span><br><span class="line">    bit_index = <span class="number">0</span></span><br><span class="line">    accumulated_bits = []</span><br><span class="line">    command_lengths = set()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        line = line.strip()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> line.startswith(<span class="string">'READ'</span>):</span><br><span class="line">            current_byte = extract_byte_from_read_line(line)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> line.startswith(<span class="string">'74 ---'</span>):</span><br><span class="line">            argument = extract_argument_from_74_line(line)</span><br><span class="line">            <span class="keyword">if</span> argument != <span class="number">0</span> <span class="keyword">and</span> current_byte <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                accumulated_bits.append(current_byte[bit_index])</span><br><span class="line">                bit_index = (bit_index + <span class="number">1</span>) % <span class="number">8</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> line.startswith(<span class="string">'WRITE'</span>):</span><br><span class="line">            <span class="keyword">if</span> accumulated_bits:</span><br><span class="line">                command_lengths.add(len(accumulated_bits))</span><br><span class="line">                process_write_command(accumulated_bits)</span><br><span class="line">                print(<span class="string">"  "</span> + line.split(<span class="string">"---"</span>)[<span class="number">0</span>])</span><br><span class="line">            accumulated_bits = []</span><br><span class="line">            </span><br><span class="line">    print(<span class="string">f"Commands lengths: <span class="subst">&#123;command_lengths&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"jp_unpack_60C8_72CB.txt"</span>, <span class="string">"rt"</span>) <span class="keyword">as</span> file:</span><br><span class="line">    lines = file.readlines()</span><br><span class="line">parse_and_print_bits(lines)</span><br></pre></td></tr></table></figure>
<p>(тривиальная логика, следим за состоянием 74 - ячейки которая контроллирует, сколько бит осталось прочитать в текущей команде)</p>
<p>Обнаруживаем, что есть всего 4 типа команд - из 9, 13, 15 и 23 бит:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">000110000 (9 bits)</span><br><span class="line">  WRITE 60C8 -&gt; 30</span><br><span class="line">100000000001 (12 bits)</span><br><span class="line">  WRITE 60CA -&gt; 30 </span><br><span class="line">  WRITE 60CB -&gt; 00</span><br><span class="line">110010000000001 (15 bits)</span><br><span class="line">  WRITE 60CF -&gt; 84 </span><br><span class="line">  WRITE 60D0 -&gt; 00 </span><br><span class="line">  WRITE 60D1 -&gt; 84</span><br><span class="line">11000000001100001011101 (23 bits)</span><br><span class="line">  WRITE 729F -&gt; 84 </span><br><span class="line">  WRITE 72A0 -&gt; 3A </span><br><span class="line">  WRITE 72A1 -&gt; 84 </span><br><span class="line">  WRITE 72A2 -&gt; 3A </span><br><span class="line">  WRITE 72A3 -&gt; 84 </span><br><span class="line">  WRITE 72A4 -&gt; 3A </span><br><span class="line">  WRITE 72A5 -&gt; 84 </span><br><span class="line">  WRITE 72A6 -&gt; 3A </span><br><span class="line">  WRITE 72A7 -&gt; 84 </span><br><span class="line">  WRITE 72A8 -&gt; 3A </span><br><span class="line">  WRITE 72A9 -&gt; 84 </span><br><span class="line">  WRITE 72AA -&gt; 3A </span><br><span class="line">  WRITE 72AB -&gt; 84 </span><br><span class="line">  WRITE 72AC -&gt; 34 </span><br><span class="line">  WRITE 72AD -&gt; 84</span><br></pre></td></tr></table></figure>
<p>Такого лога достаточно для расшифровки формата команд (в полном логе их сотни)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 00110000</span><br><span class="line">команда выдачи несжатого байта из входного потока, 0 - код команды</span><br><span class="line"></span><br><span class="line">10 0000000001</span><br><span class="line">команда копирования 2х байт (2 - константа, не закодировано в команде)</span><br><span class="line">Биты 10 - код команды</span><br><span class="line">Байты считываются по 10-битному смещению назад от текушей позиции выходного потока</span><br><span class="line"></span><br><span class="line">11000 00000110 0001011101</span><br><span class="line">команда копирования 9+X байт из выходного потока</span><br><span class="line">Биты 11000 - код команды</span><br><span class="line">Количество закодировано 8 битами (9+0b00000110 &#x3D; 15 байт)</span><br><span class="line">Смещение закодировано 10 битами</span><br><span class="line"></span><br><span class="line">11 001 0000000001</span><br><span class="line">команда копирования 2+X байт из выходного потока</span><br><span class="line">Количество закодировано 3 битами - (2+0b001 &#x3D; 3 байта)</span><br><span class="line">Смещение закодировано 10 битами</span><br></pre></td></tr></table></figure></p>
<p>Или в виде блок-схемы:<br><img src="/blog/17440519/diagram.png" alt=""></p>
<p>4612 байт карты сжимаются этим алгоритмом в 1822 байт архива.</p>
<h2 id="Семейство-LZSS"><a href="#Семейство-LZSS" class="headerlink" title="Семейство LZSS"></a>Семейство LZSS</h2><p>В отличие от классического <a href="https://ru.wikipedia.org/wiki/LZSS" target="_blank" rel="noopener">LZSS</a>, здесь использованы 3 типа команд копирования фразы разной длины, чтобы сэкономить немного места на более коротких повторяющихся последовательностях.</p>
<p>Алгоритм активно использовался еще как минимум 2 поколения консолей, так что похожие трюки и вариации можно найти в большинстве компрессоров для Sega Mega Drive или SNES:<br><a href="https://github.com/lab313ru/lzkn" target="_blank" rel="noopener">lzkn</a> — 3 варианта сжатия <code>Konami</code><br><a href="https://github.com/flamewing/mdcomp" target="_blank" rel="noopener">mdcomp</a> — компрессоры из <code>Sonic</code> (Kosinski, Nemesis, Saxman и другие). Generic код, с поддержкой нескольких вариантов алгоритма.</p>
<p>Отличия в вариациях алгоритмов:</p>
<ul>
<li>Часто биты команд сгруппированаы в отдельные байты (description fields), а не перемешаны с битами данных. Связано это с тем, что считывать и работать с целыми байтами быстрее — можно передать 8 несжатых байт выравненными блоками</li>
<li>С этим же связана подстройка размера команд и сжатых данных под выравнивание</li>
<li>Биты/байты команд могут вообще храниться в отдельном потоке, независимом от потока аргументов этих команд (смещений и длин цепочек). Опционально — в little или big-endian.</li>
<li>Некоторые вариации умеют брать данные не только из окна выходного буфера, а откуда-нибудь ещё (захардкоженные словари или просто нули)</li>
<li>Небольшие отличия в порядке хранения байт данных и байт команд из сжатого потока:<ul>
<li>пишется ли следующий байт команд сразу, как заканчиваются биты предыдущего, или только когда потребуются новые биты </li>
<li>необходим ли финальный байт команд (например, если в нём могут содержаться биты окончания потока)</li>
</ul>
</li>
</ul>
<p>В <strong><code>mdcomp</code></strong> эти настройки вынесены в шаблонный класс-адаптор <a href="https://github.com/flamewing/mdcomp/blob/26bfc205b96afe04e0941d3092865eaf6c972f81/include/mdcomp/lzss.hh#L223" target="_blank" rel="noopener">LZSSAdaptor</a></p>
<p>Кроме различий в кодировании команд могут отличаться также и алгоритмы компрессии. Большинство компрессоров реализуют примитивный алгоритм поиска подстроки в скользящем окне. Возможные оптимизации:</p>
<ul>
<li>использование структур для более быстрого поиска подстроки (<a href="https://github.com/flamewing/mdcomp/blob/26bfc205b96afe04e0941d3092865eaf6c972f81/include/mdcomp/lzss.hh#L223" target="_blank" rel="noopener">сравнение</a>).</li>
<li>проверка не только самой длинной подстроки, не и более коротких — с набором укороченных команд это может дать лучший результат (<a href="https://sonicresearch.org/community/index.php?threads/konami-compression-tools.5937/#post-84424" target="_blank" rel="noopener">пример</a> для Kosinki)</li>
<li>учёт самопересечения цепочки — байт начала цепочки, выданные в выходной буфер, могут служить концом этой же цепочки (<a href="https://stackoverflow.com/questions/31347593/matches-overlapping-lookahead-on-lz77-lzss-with-suffix-trees" target="_blank" rel="noopener">overlapping-lookahead</a>)</li>
</ul>
<p>Репо со скриптами и логами<br><a href="https://github.com/spiiin/nes_compression/tree/main/jurassic_park" target="_blank" rel="noopener">https://github.com/spiiin/nes_compression/tree/main/jurassic_park</a></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script></div></article><div class="pagination"><a class="pagination__link pagination__prev" href="/blog/2455145615/">Позже</a><a class="pagination__link pagination__next" href="/blog/3460926079/">Раньше</a></div></main><footer class="footer metadata"><p class="footer__text">© 2024 spiiin</p><p class="footer__text">Powered by <a class="footer__text__link" href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a class="footer__text__link" href="https://pages.github.com/" target="_blank">Github Page</a></p></footer></div></body></html>