<!DOCTYPE html><html lang="ru"><head><meta charset="UTF-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Spiiin's blog | daScript OpenGL</title><meta name="description" content="&lt;p&gt;Пример использования байдингов OpenGL для языка daScript&lt;br&gt;"><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=PT+Serif&amp;display=swap"><link rel="stylesheet" href="/css/highlights/darkula.css"><link rel="stylesheet" href="/css/main.css"><link rel="search" type="application/opensearchdescription+xml" href="http://spiiin.github.io/atom.xml" title="Spiiin's blog"><script>(function (i, s, o, g, r, a, m) {
  i['GoogleAnalyticsObject'] = r;
  i[r] = i[r] || function () {
    (i[r].q = i[r].q || []).push(arguments)
  }, i[r].l = 1 * new Date();
  a = s.createElement(o),
    m = s.getElementsByTagName(o)[0];
  a.async = 1;
  a.src = g;
  m.parentNode.insertBefore(a, m)
})(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');
ga('create', 'UA-00000000-0', 'auto');
ga('send', 'pageview');</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Spiiin's blog" type="application/atom+xml">
</head><body><div class="container"><header class="main-header"><h1 class="main-header__title uplize"><a class="main-header__title__link" href="/"><img class="header-image" src="/images/favicon.png" width="36" height="36">Spiiin's blog</a></h1><nav class="main-header__nav"><ul class="main-nav"><li class="main-nav__list"><a class="main-nav__list__link" href="/" target="_self">HOME</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/archives/" target="_self">ARCHIVE</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/tags/meta" target="_self">TAGS</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/blog/1" target="_self">ABOUT</a></li></ul></nav></header><main class="container__wrapper"><div class="pagination"><a class="pagination__link pagination__prev" href="/blog/2371214813/">Позже</a><a class="pagination__link pagination__next" href="/blog/1547564887/">Раньше</a></div><article class="article post"><h3 class="article__title">daScript OpenGL</h3><div class="article__date metadata"><div class="post-info">2022/02/21</div></div><div class="article__tags metadata">Tags:
<a class="article__tags__link metadata" href="/tags/opengl/">opengl</a><a class="article__tags__link metadata" href="/tags/dascript/">dascript</a></div><div class="article__body"><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Пример использования байдингов OpenGL для языка daScript<br><a id="more"></a></p>
<p>Попробовал разобраться с использованием байндингов библиотек к языку daScript. В качестве тестовой задачки решил портировать на daScript + OpenGL <a href="https://github.com/bkaradzic/bgfx/issues/1857" target="_blank" rel="noopener">эту демку</a>. Программа реализует алгоритм клиппинга модели несколькими плоскостями, с заполненнием отрезанных частей “крышками”, чтобы не было видно внутренней поверхности модели (<a href="https://github.com/daign/clipping-with-caps/blob/master/screenshot_01.png" target="_blank" rel="noopener">скрин</a>).</p>
<p>Алгоритм:</p>
<ul>
<li>Отрисовать модель с шейдером отсечения (с “дырками”)</li>
<li>Заполнить буфер трафарета значениями так, чтобы пометить пиксели, которые нужно закрыть:<br>— Отрисовать внутреннюю сторону модели, увеличивая значение в буфере трафарета<br>— Отрисовать внешнюю сторону модели, уменьшая значение в буфере трафарета<br>— Заполнять буфер трафарета в только в точках, в которых плоскость отсечения повернута к камере (для корректной работы нескольких плоскостей отсечения одновременно)</li>
<li>Отрисовать плоскости отсечения по полученной маске (получаются закрывающие “крышки”)</li>
</ul>
<h2 id="Каркас-приложения"><a href="#Каркас-приложения" class="headerlink" title="Каркас приложения"></a>Каркас приложения</h2><p>Для создания байндингов библиотек к daScript используется <a href="https://github.com/GaijinEntertainment/daScript/issues/231" target="_blank" rel="noopener">dasClangBind</a>, с помощью которого сделаны обёртки для <a href="https://github.com/GaijinEntertainment/daScript/tree/master/modules" target="_blank" rel="noopener">нескольких</a> библиотек, включая OpenGL. Последний из <a href="https://github.com/GaijinEntertainment/daScript/blob/master/modules/dasOpenGL/examples/09_hello_mesh.das" target="_blank" rel="noopener">примеров</a> демонстрирует загрузку и отображение модели из obj-файла. Этот пример можно взять за основу. Для задания настроек отсекающих плоскостей можно взять байндинг к <a href="https://github.com/borisbat/dasImgui/" target="_blank" rel="noopener">imgui</a>.</p>
<p>Эти модули также тащат за собой <code>glfw</code> для создания окна и <code>stbImage</code>. Шаблон C++ кода для подключения модулей:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../modules/dasGlfw/src/dasGLFW.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../modules/dasImgui/src/dasIMGUI.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../modules/dasStbImage/src/dasStbImage.h"</span></span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span>, <span class="keyword">char</span> * [] )</span> </span>&#123;</span><br><span class="line">    NEED_ALL_DEFAULT_MODULES;</span><br><span class="line">    NEED_MODULE(Module_dasGLFW)</span><br><span class="line">    NEED_MODULE(Module_StbImage)</span><br><span class="line">    NEED_MODULE(Module_dasIMGUI)</span><br><span class="line">    NEED_MODULE(Module_imgui_app)</span><br><span class="line">    Module::Initialize();</span><br><span class="line">    tutorial();</span><br><span class="line">    Module::Shutdown();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Пустое окно на glfw + imgui можно создать так:</p>
<div style="color: #d4d4d4;background-color: #1e1e1e;font-family: Consolas, 'Courier New', monospace;font-weight: normal;font-size: 14px;line-height: 19px;white-space: pre;"><div><span style="color: #569cd6;">def</span><span style="color: #d4d4d4;"> </span><span style="color: #dcdcaa;">imgui_app</span><span style="color: #d4d4d4;">(</span><span style="color: #9cdcfe;">title</span><span style="color: #d4d4d4;">:</span><span style="color: #4ec9b0;">string</span><span style="color: #d4d4d4;">; </span><span style="color: #9cdcfe;">blk </span><span style="color: #d4d4d4;">: </span><span style="color: #4ec9b0;">block</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">if</span><span style="color: #d4d4d4;"> glfwInit()==</span><span style="color: #b5cea8;">0</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #dcdcaa;">panic</span><span style="color: #d4d4d4;">(</span><span style="color: #ce9178;">"can't init glfw"</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; defer &lt;|</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; glfwTerminate()</span></div><div><span style="color: #d4d4d4;">&#160; &#160; glfwInitOpenGL(</span><span style="color: #b5cea8;">3</span><span style="color: #d4d4d4;">,</span><span style="color: #b5cea8;">3</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> window = glfwCreateWindow(</span><span style="color: #b5cea8;">1280</span><span style="color: #d4d4d4;">, </span><span style="color: #b5cea8;">720</span><span style="color: #d4d4d4;">, </span><span style="color: #ce9178;">"OpenGL - Hello shader clipping"</span><span style="color: #d4d4d4;">, </span><span style="color: #c586c0;">null</span><span style="color: #d4d4d4;">, </span><span style="color: #c586c0;">null</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">if</span><span style="color: #d4d4d4;"> window==</span><span style="color: #c586c0;">null</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #dcdcaa;">panic</span><span style="color: #d4d4d4;">(</span><span style="color: #ce9178;">"can't create window"</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; defer &lt;|</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; glfwDestroyWindow(window)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; glfwMakeContextCurrent(window)</span></div><br><div><span style="color: #d4d4d4;">&#160; &#160; CreateContext(</span><span style="color: #c586c0;">null</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> io &amp; = </span><span style="color: #c586c0;">unsafe</span><span style="color: #d4d4d4;">(GetIO())</span></div><div><span style="color: #d4d4d4;">&#160; &#160; StyleColorsDark(</span><span style="color: #c586c0;">null</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; ImGui_ImplGlfw_InitForOpenGL(window, </span><span style="color: #c586c0;">true</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; ImGui_ImplOpenGL3_Init(</span><span style="color: #ce9178;">"#version 330"</span><span style="color: #d4d4d4;">)</span></div><br><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">while</span><span style="color: #d4d4d4;"> glfwWindowShouldClose(window)==</span><span style="color: #b5cea8;">0</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; glfwPollEvents()</span></div><br><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; ImGui_ImplOpenGL3_NewFrame()</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; ImGui_ImplGlfw_NewFrame()</span></div><br><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #dcdcaa;">invoke</span><span style="color: #d4d4d4;">(blk)</span></div><br><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> display_w, display_h : </span><span style="color: #4ec9b0;">int</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; glfwGetFramebufferSize(window, display_w, display_h)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">let</span><span style="color: #d4d4d4;"> aspect = display_h!=</span><span style="color: #b5cea8;">0</span><span style="color: #d4d4d4;"> ? float(display_w)/float(display_h) : </span><span style="color: #b5cea8;">1.</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #6a9955;">// render</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; glViewport(</span><span style="color: #b5cea8;">0</span><span style="color: #d4d4d4;">, </span><span style="color: #b5cea8;">0</span><span style="color: #d4d4d4;">, display_w, display_h)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; glClearColor(</span><span style="color: #b5cea8;">0.2</span><span style="color: #d4d4d4;">, </span><span style="color: #b5cea8;">0.2</span><span style="color: #d4d4d4;">, </span><span style="color: #b5cea8;">0.2</span><span style="color: #d4d4d4;">, </span><span style="color: #b5cea8;">1.0</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; glClearDepth(</span><span style="color: #b5cea8;">1.0l</span><span style="color: #d4d4d4;">f)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT|GL_STENCIL_BUFFER_BIT)</span></div><br><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; ImGui_ImplOpenGL3_RenderDrawData(GetDrawData())</span></div><br><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; glfwMakeContextCurrent(window)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; glfwSwapBuffers(window)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #6a9955;">//close app</span></div><div><span style="color: #d4d4d4;">&#160; &#160; DestroyContext(</span><span style="color: #c586c0;">null</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; glfwDestroyWindow(window)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; glfwTerminate()</span></div><br><div><span style="color: #d4d4d4;">[</span><span style="color: #569cd6;">export</span><span style="color: #d4d4d4;">]</span></div><div><span style="color: #c586c0;">def</span><span style="color: #d4d4d4;"> test</span></div><div><span style="color: #d4d4d4;">&#160; &#160; imgui_app(</span><span style="color: #ce9178;">"imgui"</span><span style="color: #d4d4d4;">) &lt;|</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; NewFrame()</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; Begin(</span><span style="color: #ce9178;">"Crop params"</span><span style="color: #d4d4d4;">);</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; End();</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; Render()</span></div></div>
<ul>
<li>не забыли создать и очистить буфер трафарета (GL_STENCIL_BUFFER_BIT)</li>
<li><a href="https://dascript.org/doc/reference/language/blocks.html?highlight=block" target="_blank" rel="noopener">block</a> в daScript — безымянная функция, которая захватывает переменные по ссылке (более быстрая, чем лямбда-функции, которые могут управлять способом захвата)</li>
<li><code>defer</code> — макрос для добавления выражений в блок <a href="https://dascript.org/doc/reference/language/statements.html?highlight=defer#finally-statement" target="_blank" rel="noopener">finally</a></li>
</ul>
<p>Исходная демка использует библиотеки three.js и ColladaLoader.js для загрузки меша из dae файла, но можно <a href="https://products.aspose.app/3d/ru/conversion/dae-to-obj" target="_blank" rel="noopener">конвертировать</a> dae в obj, чтобы использовать код загрузки меша из примера daScript. Загрузка меша:</p>
<div style="color: #d4d4d4;background-color: #1e1e1e;font-family: Consolas, 'Courier New', monospace;font-weight: normal;font-size: 14px;line-height: 19px;white-space: pre;"><div><span style="color: #c586c0;">require</span><span style="color: #d4d4d4;"> opengl/opengl_gen</span></div><br><div><span style="color: #c586c0;">let</span><span style="color: #d4d4d4;"> mesh_file_name = </span><span style="color: #ce9178;">"{get_das_root()}/house.obj"</span></div><div><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> mesh &lt;- load_obj_mesh(mesh_file_name) |&gt; create_geometry_fragment</span></div></div>
<h2 id="Отрисовка-меша"><a href="#Отрисовка-меша" class="headerlink" title="Отрисовка меша"></a>Отрисовка меша</h2><p>Задание стандартных шейдеров:</p>
<div style="color: #d4d4d4;background-color: #1e1e1e;font-family: Consolas, 'Courier New', monospace;font-weight: normal;font-size: 14px;line-height: 19px;white-space: pre;"><div><span style="color: #c586c0;">require</span><span style="color: #d4d4d4;"> glsl/glsl_common</span></div><div><span style="color: #c586c0;">require</span><span style="color: #d4d4d4;"> glsl/glsl_internal</span></div><br><div><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> [[</span><span style="color: #c586c0;">in</span><span style="color: #d4d4d4;">, location=</span><span style="color: #b5cea8;">0</span><span style="color: #d4d4d4;">]] v_position : </span><span style="color: #4ec9b0;">float3</span></div><div><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> [[</span><span style="color: #c586c0;">in</span><span style="color: #d4d4d4;">, location=</span><span style="color: #b5cea8;">1</span><span style="color: #d4d4d4;">]] v_normal &#160; : </span><span style="color: #4ec9b0;">float3</span></div><div><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> [[</span><span style="color: #c586c0;">in</span><span style="color: #d4d4d4;">, location=</span><span style="color: #b5cea8;">2</span><span style="color: #d4d4d4;">]] v_texcoord : </span><span style="color: #4ec9b0;">float2</span></div><div><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> [[uniform]] v_model : float4x4</span></div><div><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> [[uniform]] v_view : float4x4</span></div><div><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> [[uniform]] v_projection : float4x4</span></div><div><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> [[inout]] f_texcoord : </span><span style="color: #4ec9b0;">float2</span></div><div><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> [[inout]] f_normal : </span><span style="color: #4ec9b0;">float3</span></div><div><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> [[inout]] f_position : </span><span style="color: #4ec9b0;">float3</span></div><div><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> [[inout]] f_worldpos : </span><span style="color: #4ec9b0;">float3</span></div><br><div><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> [[uniform, stage=</span><span style="color: #b5cea8;">0</span><span style="color: #d4d4d4;">]] f_tex : sampler2D</span></div><div><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> [[out]] f_FragColor : </span><span style="color: #4ec9b0;">float4</span></div><br><div><span style="color: #d4d4d4;">[</span><span style="color: #569cd6;">vertex_program</span><span style="color: #d4d4d4;">]</span></div><div><span style="color: #c586c0;">def</span><span style="color: #d4d4d4;"> vs_preview</span></div><div><span style="color: #d4d4d4;">&#160; &#160; f_texcoord = v_texcoord</span></div><div><span style="color: #d4d4d4;">&#160; &#160; f_normal = normalize ( float3x3(v_model) * v_normal )</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">let</span><span style="color: #d4d4d4;"> tpos = v_model * float4(v_position, </span><span style="color: #b5cea8;">1.0</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; f_position = tpos.xyz</span></div><div><span style="color: #d4d4d4;">&#160; &#160; f_worldpos = v_position</span></div><div><span style="color: #d4d4d4;">&#160; &#160; gl_Position = v_projection * v_view * tpos</span></div><br><div><span style="color: #d4d4d4;">[</span><span style="color: #569cd6;">fragment_program</span><span style="color: #d4d4d4;"> (version=400)]</span></div><div><span style="color: #c586c0;">def</span><span style="color: #d4d4d4;"> fs_preview</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">let</span><span style="color: #d4d4d4;"> pS = </span><span style="color: #b5cea8;">24.0</span></div><br><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">let</span><span style="color: #d4d4d4;"> light_dir = normalize(float3(-</span><span style="color: #b5cea8;">1</span><span style="color: #d4d4d4;">,-</span><span style="color: #b5cea8;">2</span><span style="color: #d4d4d4;">,-</span><span style="color: #b5cea8;">3</span><span style="color: #d4d4d4;">))</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">let</span><span style="color: #d4d4d4;"> camera_dir = normalize(f_position)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">let</span><span style="color: #d4d4d4;"> normal = normalize(f_normal)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">let</span><span style="color: #d4d4d4;"> k = -dot(light_dir,normal)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">let</span><span style="color: #d4d4d4;"> diffuse = float3(saturate(k))</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">let</span><span style="color: #d4d4d4;"> refl = normalize ( reflect(camera_dir,normal) )</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">let</span><span style="color: #d4d4d4;"> kS = saturate(dot(-light_dir,refl))</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">let</span><span style="color: #d4d4d4;"> kS1 = saturate(dot(-light_dir,refl))</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">let</span><span style="color: #d4d4d4;"> specular = float3(pow(kS,pS)*kS)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; f_FragColor.xyz = texture(f_tex,f_texcoord).xyz * diffuse + specular</span></div><div><span style="color: #d4d4d4;">&#160; &#160; f_FragColor.w = </span><span style="color: #b5cea8;">1.</span></div></div>
<p>Интересная штука — DSL для работы с шейдерами (<a href="https://github.com/GaijinEntertainment/daScript/blob/master/modules/dasGlsl/glsl/glsl_internal.das" target="_blank" rel="noopener">glsl_internal</a>, набор макросов для того, чтобы писать шейдеры как обычные функции в daScript, а также работать с uniform переменными почти как с обычными переменными языка. Пример передачи uniform-ов в шейдер:</p>
<div style="color: #d4d4d4;background-color: #1e1e1e;font-family: Consolas, 'Courier New', monospace;font-weight: normal;font-size: 14px;line-height: 19px;white-space: pre;"><div><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> [[uniform]] v_projection : float4x4 &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; </span><span style="color: #6a9955;">//объявление uniform переменной для шейдера</span></div><br><div><span style="color: #c586c0;">let</span><span style="color: #d4d4d4;"> aspect = display_h!=</span><span style="color: #b5cea8;">0</span><span style="color: #d4d4d4;"> ? float(display_w)/float(display_h) : </span><span style="color: #b5cea8;">1.</span></div><div><span style="color: #d4d4d4;">v_projection = perspective_rh_opengl( </span><span style="color: #b5cea8;">45.0f</span><span style="color: #d4d4d4;">*PI/</span><span style="color: #b5cea8;">180.</span><span style="color: #d4d4d4;">, aspect, </span><span style="color: #b5cea8;">0.1f</span><span style="color: #d4d4d4;">, </span><span style="color: #b5cea8;">10.0f</span><span style="color: #d4d4d4;">) &#160; </span><span style="color: #6a9955;">//определяем матрицу проекции (daScript-структура)</span></div><div><span style="color: #d4d4d4;">vs_preview_bind_uniform(program_front) &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;</span><span style="color: #6a9955;">//передаём uniform переменные в шейдер</span></div><div><span style="color: #d4d4d4;">fs_preview_bind_uniform(program_front) &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;</span><span style="color: #6a9955;">// vs_preview_bind_uniform - сгенерированная макросом [vertex_program] функция!</span></div></div>
<p>Помимо простой привязки функций библиотеки, сгенерированной с помощью <code>dasClangBind</code>, написаны также макросы для “daScript-ивизации” кода. Вместо императивного вызова функции <code>glUniformXXX</code>, программист декларирует намерение “эта переменная - uniform для шейдера” — аннотация <code>uniform</code>.</p>
<p><strong><code>За счёт этого скриптовый язык становится не &quot;условным бейсиком&quot; для императивного вызова функций, а способом приблизить библиотеку к предметной области, в терминах которой мыслит и работает программист</code></strong></p>
<p>Отрисовка:</p>
<div style="color: #d4d4d4;background-color: #1e1e1e;font-family: Consolas, 'Courier New', monospace;font-weight: normal;font-size: 14px;line-height: 19px;white-space: pre;"><div><span style="color: #d4d4d4;">glUseProgram(program)</span></div><div><span style="color: #d4d4d4;">vs_preview_bind_uniform(program)</span></div><div><span style="color: #d4d4d4;">fs_preview_bind_uniform(program)</span></div><div><span style="color: #d4d4d4;">draw_geometry_fragment(mesh)</span></div></div>
<p><img src="/blog/4232971949/clip_1_small.png" alt="1"></p>
<h2 id="Клиппинг-плоскостями-отсечения"><a href="#Клиппинг-плоскостями-отсечения" class="headerlink" title="Клиппинг плоскостями отсечения"></a>Клиппинг плоскостями отсечения</h2><p>Изменим пиксельный шейдер отрисовки объекта:<br><div style="color: #d4d4d4;background-color: #1e1e1e;font-family: Consolas, 'Courier New', monospace;font-weight: normal;font-size: 14px;line-height: 19px;white-space: pre;"><div><span style="color: #d4d4d4;">[</span><span style="color: #569cd6;">fragment_program</span><span style="color: #d4d4d4;"> (version=400)]</span></div><div><span style="color: #c586c0;">def</span><span style="color: #d4d4d4;"> fs_preview</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #6a9955;">//если вершина отсекается плоскостями -- отбросить её</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">if</span><span style="color: #d4d4d4;"> (f_worldpos.x &lt; f_crop_plane_x) || (f_worldpos.y &lt; f_crop_plane_y) || (f_worldpos.x &gt; f_crop_plane_x_max) || (f_worldpos.y &gt; f_crop_plane_y_max)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; discard()</span></div><div><span style="color: #d4d4d4;">...</span></div><br><div><span style="color: #d4d4d4;">Установка uniform-переменных через панель imGui</span></div></div><br><img src="/blog/4232971949/clip_2_small.png" alt="2"></p>
<p>Сквозь отброшенные пиксели пока видны внутренние грани объекта.</p>
<h2 id="Заполнение-буфера-трафарета"><a href="#Заполнение-буфера-трафарета" class="headerlink" title="Заполнение буфера трафарета"></a>Заполнение буфера трафарета</h2><p>Исходная демка на three.js использует для описания состояния рендера концепцию <a href="https://github.com/daign/clipping-with-caps/blob/master/js/material.js" target="_blank" rel="noopener">материалов</a> этой библиотеки, но несложно сопоставить свойства материлов с параметрами OpenGL</p>
<div style="color: #d4d4d4;background-color: #1e1e1e;font-family: Consolas, 'Courier New', monospace;font-weight: normal;font-size: 14px;line-height: 19px;white-space: pre;"><div><span style="color: #6a9955;">//упрощенный шейдер для вывода в буфер трафарета</span></div><div><span style="color: #d4d4d4;">[</span><span style="color: #569cd6;">fragment_program</span><span style="color: #d4d4d4;"> (version=400)]</span></div><div><span style="color: #c586c0;">def</span><span style="color: #d4d4d4;"> fs_preview_front</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">let</span><span style="color: #d4d4d4;"> not_inside_camera = (f_worldpos.x &lt; f_crop_plane_x) || (f_worldpos.y &lt; f_crop_plane_y) || (f_worldpos.x &gt; f_crop_plane_x_max) || (f_worldpos.y &gt; f_crop_plane_y_max)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">if</span><span style="color: #d4d4d4;"> not_inside_camera</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; discard()</span></div><div><span style="color: #d4d4d4;">&#160; &#160; f_FragColor = float4(</span><span style="color: #b5cea8;">0.0</span><span style="color: #d4d4d4;">, </span><span style="color: #b5cea8;">0.0</span><span style="color: #d4d4d4;">, </span><span style="color: #b5cea8;">0.0</span><span style="color: #d4d4d4;">, </span><span style="color: #b5cea8;">1.0</span><span style="color: #d4d4d4;">)</span></div><br><div><span style="color: #d4d4d4;">...</span></div><br><div><span style="color: #6a9955;">//Включаем рендер в буфер трафарета, отключаем запись в буфера цвета и глубины</span></div><div><span style="color: #d4d4d4;">glEnable(GL_STENCIL_TEST)</span></div><div><span style="color: #d4d4d4;">glColorMask(</span><span style="color: #c586c0;">false</span><span style="color: #d4d4d4;">, </span><span style="color: #c586c0;">false</span><span style="color: #d4d4d4;">, </span><span style="color: #c586c0;">false</span><span style="color: #d4d4d4;">, </span><span style="color: #c586c0;">false</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">glDepthMask(</span><span style="color: #c586c0;">false</span><span style="color: #d4d4d4;">)</span></div><br><div><span style="color: #6a9955;">//установка шейдера</span></div><div><span style="color: #d4d4d4;">glUseProgram(program_front)</span></div><div><span style="color: #d4d4d4;">vs_preview_bind_uniform(program_front)</span></div><div><span style="color: #d4d4d4;">fs_preview_front_bind_uniform(program_front)</span></div><br><div><span style="color: #6a9955;">//рендер только задних граней объекта с увеличением значения в буфере трафарета</span></div><div><span style="color: #d4d4d4;">glEnable(GL_CULL_FACE);</span></div><div><span style="color: #d4d4d4;">glCullFace(GL_FRONT);</span></div><div><span style="color: #d4d4d4;">glStencilFunc(GL_ALWAYS, </span><span style="color: #b5cea8;">1</span><span style="color: #d4d4d4;">, </span><span style="color: #b5cea8;">0xFF</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">glStencilOp(GL_KEEP, GL_KEEP, GL_INCR)</span></div><div><span style="color: #d4d4d4;">draw_geometry_fragment(mesh)</span></div><br><div><span style="color: #6a9955;">//Рендер только передних граней объекта с уменьшения значения в буфере трафарета</span></div><div><span style="color: #d4d4d4;">glEnable(GL_CULL_FACE);</span></div><div><span style="color: #d4d4d4;">glCullFace(GL_BACK);</span></div><div><span style="color: #d4d4d4;">glStencilFunc(GL_ALWAYS, </span><span style="color: #b5cea8;">1</span><span style="color: #d4d4d4;">, </span><span style="color: #b5cea8;">0xFF</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">glStencilOp(GL_KEEP, GL_KEEP, GL_DECR)</span></div><div><span style="color: #d4d4d4;">draw_geometry_fragment(mesh)</span></div></div>
<p>Вывод отсекающих граней:</p>
<div style="color: #d4d4d4;background-color: #1e1e1e;font-family: Consolas, 'Courier New', monospace;font-weight: normal;font-size: 14px;line-height: 19px;white-space: pre;"><div><span style="color: #6a9955;">//функция генерации прямоугольника заданного размера</span></div><div><span style="color: #569cd6;">def</span><span style="color: #d4d4d4;"> </span><span style="color: #dcdcaa;">gen_axis_rect</span><span style="color: #d4d4d4;">(</span><span style="color: #9cdcfe;">plt </span><span style="color: #d4d4d4;">: GenDirection; </span><span style="color: #9cdcfe;">x1, x2, y1, y2, coord</span><span style="color: #d4d4d4;">: </span><span style="color: #4ec9b0;">float</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> frag : GeometryFragment</span></div><div><span style="color: #d4d4d4;">&#160; &#160; frag.vertices &lt;- [</span><span style="color: #569cd6;">{GeometryPreviewVertex</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; xyz=float3( x1, y1, coord), normal=float3( &#160;0, 0, 1), &#160;uv=float2(0,0);</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; xyz=float3(x2, y1, coord), normal=float3( &#160;0, 0, 1), &#160;uv=float2(1,0);</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; xyz=float3(x2,y2, coord), normal=float3( &#160;0, 0, 1), &#160;uv=float2(1,1);</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; xyz=float3( x1,y2, coord), normal=float3( &#160;0, 0, 1), &#160;uv=float2(0,1)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; }]</span></div><div><span style="color: #d4d4d4;">&#160; &#160; apply_gen_direction_tm(plt, frag)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; frag.indices &lt;- [</span><span style="color: #569cd6;">{int</span><span style="color: #d4d4d4;"> 0; 1; 2; 2; 3; 0 }]</span></div><div><span style="color: #d4d4d4;">&#160; &#160; frag.prim = GeometryFragmentType triangles</span></div><div><span style="color: #d4d4d4;">&#160; &#160; gen_bbox(frag)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">return</span><span style="color: #d4d4d4;"> &lt;- frag</span></div><br><div><span style="color: #d4d4d4;">...</span></div><br><div><span style="color: #d4d4d4;">[</span><span style="color: #569cd6;">fragment_program</span><span style="color: #d4d4d4;"> (version=400)]</span></div><div><span style="color: #c586c0;">def</span><span style="color: #d4d4d4;"> fs_preview_caps</span></div><div><span style="color: #d4d4d4;">&#160; &#160; f_FragColor = float4(</span><span style="color: #b5cea8;">0.0</span><span style="color: #d4d4d4;">, </span><span style="color: #b5cea8;">1.0</span><span style="color: #d4d4d4;">, </span><span style="color: #b5cea8;">0.0</span><span style="color: #d4d4d4;">, </span><span style="color: #b5cea8;">1.0</span><span style="color: #d4d4d4;">)</span></div><br><div><span style="color: #d4d4d4;">glUseProgram(program_caps)</span></div><br><div><span style="color: #6a9955;">//отрисовка через полученную в буфере трафарета маску</span></div><div><span style="color: #d4d4d4;">glStencilFunc(GL_EQUAL, </span><span style="color: #b5cea8;">1</span><span style="color: #d4d4d4;">, </span><span style="color: #b5cea8;">0xFF</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">glStencilOp(GL_KEEP, GL_KEEP, GL_KEEP)</span></div><div><span style="color: #d4d4d4;">vs_preview_bind_uniform(program_caps)</span></div><div><span style="color: #d4d4d4;">fs_preview_caps_bind_uniform(program_caps)</span></div><br><div><span style="color: #6a9955;">//генерация отсекающих плоскостей</span></div><div><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> planeX &lt;- gen_axis_rect(GenDirection yz, </span><span style="color: #b5cea8;">2.0</span><span style="color: #d4d4d4;">, -</span><span style="color: #b5cea8;">2.0</span><span style="color: #d4d4d4;">, f_crop_plane_y_max, f_crop_plane_y, -f_crop_plane_x) |&gt; create_geometry_fragment</span></div><div><span style="color: #d4d4d4;">draw_geometry_fragment(planeX)</span></div><div><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> planeXMax &lt;- gen_axis_rect(GenDirection yz, </span><span style="color: #b5cea8;">2.0</span><span style="color: #d4d4d4;">, -</span><span style="color: #b5cea8;">2.0</span><span style="color: #d4d4d4;">, f_crop_plane_y_max,f_crop_plane_y, -f_crop_plane_x_max) |&gt; create_geometry_fragment</span></div><div><span style="color: #d4d4d4;">draw_geometry_fragment(planeXMax)</span></div><br><div><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> planeY &lt;- gen_axis_rect(GenDirection xz, f_crop_plane_x, f_crop_plane_x_max, </span><span style="color: #b5cea8;">2.0</span><span style="color: #d4d4d4;">, -</span><span style="color: #b5cea8;">2.0</span><span style="color: #d4d4d4;">, f_crop_plane_y) |&gt; create_geometry_fragment</span></div><div><span style="color: #d4d4d4;">draw_geometry_fragment(planeY)</span></div><div><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> planeYMax &lt;- gen_axis_rect(GenDirection xz, f_crop_plane_x, f_crop_plane_x_max, </span><span style="color: #b5cea8;">2.0</span><span style="color: #d4d4d4;">, -</span><span style="color: #b5cea8;">2.0</span><span style="color: #d4d4d4;">, f_crop_plane_y_max) |&gt; create_geometry_fragment</span></div><div><span style="color: #d4d4d4;">draw_geometry_fragment(planeYMax)</span></div></div>
<p>Как отмечено в описании алгоритма <a href="https://github.com/daign/clipping-with-caps#clipping-with-caps" target="_blank" rel="noopener">референсной демки</a>, такой подход нормально работает с одной плоскостью отсечения, но с нескольими плоскостями даёт неверный результат (повёрнутые “от камеры” плоскости отсечения также вносят вклад в маску и портят результат в буфере трафарета — выводят лишние “дырки” или “крышки” в таких местах:</p>
<p><img src="/blog/4232971949/clip_3_small.png" alt="3"></p>
<h2 id="Коррекция-буфера-трафарета-для-граней-повернутых-от-камеры"><a href="#Коррекция-буфера-трафарета-для-граней-повернутых-от-камеры" class="headerlink" title="Коррекция буфера трафарета для граней, повернутых от камеры"></a>Коррекция буфера трафарета для граней, повернутых от камеры</h2><p>На этом этапе обнаруживаются отличия между демкой-референсом и примером из daScript. Позиция камеры в референсной демке попадает в шейдера “автоматически”, эта переменная <a href="https://threejs.org/docs/#api/en/renderers/webgl/WebGLProgram" target="_blank" rel="noopener">устанавливается</a> библиотекой three.js. Для примера на daScript нужно передать её вручную и учесть то, что системы координат в демках различаются. Поворот в примере daScript задаётся через матрицу <code>v_model</code>, так что для трансформации камеры в систему координат модели и плоскостей отсечения нужно также “довернуть” её, умножив на матрицу модели.</p>
<div style="color: #d4d4d4;background-color: #1e1e1e;font-family: Consolas, 'Courier New', monospace;font-weight: normal;font-size: 14px;line-height: 19px;white-space: pre;"><div><span style="color: #6a9955;">//позиция камеры в пространстве координат модели</span></div><div><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> [[uniform]] f_camera_position_rotated : </span><span style="color: #4ec9b0;">float3</span></div><br><div><span style="color: #6a9955;">//шейдер для вывода в буфер трафарета</span></div><div><span style="color: #d4d4d4;">[</span><span style="color: #569cd6;">fragment_program</span><span style="color: #d4d4d4;"> (version=400)]</span></div><div><span style="color: #c586c0;">def</span><span style="color: #d4d4d4;"> fs_preview_front</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #6a9955;">//let not_inside_camera = &#160;(f_worldpos.x &lt; f_crop_plane_x) || (f_worldpos.y &lt; f_crop_plane_y) || (f_worldpos.x &gt; f_crop_plane_x_max) || (f_worldpos.y &gt; f_crop_plane_y_max)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">let</span><span style="color: #d4d4d4;"> not_inside_camera = (f_worldpos.x &lt; f_crop_plane_x) &amp;&amp; (f_camera_position_rotated.x &gt; -f_crop_plane_x) || (f_worldpos.y &lt; f_crop_plane_y) &amp;&amp; (f_camera_position_rotated.y &lt; f_crop_plane_y) || (f_worldpos.x &gt; f_crop_plane_x_max) &amp;&amp; (f_camera_position_rotated.x &lt; -f_crop_plane_x_max) || (f_worldpos.y &gt; f_crop_plane_y_max) &amp;&amp; (f_camera_position_rotated.y &gt; f_crop_plane_y_max)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">if</span><span style="color: #d4d4d4;"> not_inside_camera</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; discard()</span></div><div><span style="color: #d4d4d4;">&#160; &#160; f_FragColor = float4(</span><span style="color: #b5cea8;">0.0</span><span style="color: #d4d4d4;">, </span><span style="color: #b5cea8;">0.0</span><span style="color: #d4d4d4;">, </span><span style="color: #b5cea8;">0.0</span><span style="color: #d4d4d4;">, </span><span style="color: #b5cea8;">1.0</span><span style="color: #d4d4d4;">)</span></div><br><div><span style="color: #d4d4d4;">...</span></div><div><span style="color: #6a9955;">//поворот камеры в пространство координат модели</span></div><div><span style="color: #c586c0;">let</span><span style="color: #d4d4d4;"> camPos = v_model * float4(camera_position, </span><span style="color: #b5cea8;">1.0</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">f_camera_position_rotated = camPos.xyz</span></div></div>
<p>Можно обратить внимание на идентичный синтаксис умножения вектора на матрицу в коде вершинного шейдера для трансфорфмации вершин меша,  и обычном скрипте на daScript.</p>
<p>Теперь наконец отсечения смотрятся корректно под любым углом.</p>
<p><img src="/blog/4232971949/clip_4_small.png" alt="4"></p>
<p><a href="https://github.com/spiiin/dascript_macro_tutorial/blob/master/clipping_with_caps/tutorial01.das" target="_blank" rel="noopener">Исходный код туториала</a></p>
<ul>
<li>daScript хорош, чтобы поиграться с демками графических эффектов :)</li>
<li>подход авторов к написанию байндингов — автоматическая обёртка на c/c++-функциями + “daScript-тификация” кода — создание макросов, упрощающих работу с библиотекой</li>
<li>вообще, демку стоило бы ещё перевести на режим <a href="https://github.com/borisbat/dasGlfw/blob/48f2715f0fe4cb8076866365a4bf0a29b7104765/dasglfw/glfw_live.das" target="_blank" rel="noopener">live-изменений</a>, тянет на отдельный туториал</li>
</ul>
<p>Ну и более глобальный вывод про совокупность всех фич языка — если большая часть кода на языке делает то, что сложно или долго делать на других языках, с какого-то момента разработки сама программа может получить какие-то свойства, которых нет у программ на других языках (потому что их было слишком долго или трудно реализовывать).</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script></div></article><div class="pagination"><a class="pagination__link pagination__prev" href="/blog/2371214813/">Позже</a><a class="pagination__link pagination__next" href="/blog/1547564887/">Раньше</a></div></main><footer class="footer metadata"><p class="footer__text">© 2024 spiiin</p><p class="footer__text">Powered by <a class="footer__text__link" href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a class="footer__text__link" href="https://pages.github.com/" target="_blank">Github Page</a></p></footer></div></body></html>