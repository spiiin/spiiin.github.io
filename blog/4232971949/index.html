<!DOCTYPE html><html lang="ru"><head><meta charset="UTF-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Spiiin's blog | daScript OpenGL</title><meta name="description" content="&lt;p&gt;Пример использования байдингов OpenGL для языка daScript&lt;br&gt;"><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=PT+Serif&amp;display=swap"><link rel="stylesheet" href="/css/highlights/darkula.css"><link rel="stylesheet" href="/css/main.css"><link rel="search" type="application/opensearchdescription+xml" href="http://spiiin.github.io/atom.xml" title="Spiiin's blog"><script>(function (i, s, o, g, r, a, m) {
  i['GoogleAnalyticsObject'] = r;
  i[r] = i[r] || function () {
    (i[r].q = i[r].q || []).push(arguments)
  }, i[r].l = 1 * new Date();
  a = s.createElement(o),
    m = s.getElementsByTagName(o)[0];
  a.async = 1;
  a.src = g;
  m.parentNode.insertBefore(a, m)
})(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');
ga('create', 'UA-00000000-0', 'auto');
ga('send', 'pageview');</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Spiiin's blog" type="application/atom+xml">
</head><body><div class="container"><header class="main-header"><h1 class="main-header__title uplize"><a class="main-header__title__link" href="/"><img class="header-image" src="/images/favicon.png" width="36" height="36">Spiiin's blog</a></h1><nav class="main-header__nav"><ul class="main-nav"><li class="main-nav__list"><a class="main-nav__list__link" href="/" target="_self">HOME</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/archives/" target="_self">ARCHIVE</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/tags/meta" target="_self">TAGS</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/blog/1" target="_self">ABOUT</a></li></ul></nav></header><main class="container__wrapper"><div class="pagination"><a class="pagination__link pagination__prev" href="/blog/2371214813/">Позже</a><a class="pagination__link pagination__next" href="/blog/1547564887/">Раньше</a></div><article class="article post"><h3 class="article__title">daScript OpenGL</h3><div class="article__date metadata"><div class="post-info">2022/02/21</div></div><div class="article__tags metadata">Tags:
<a class="article__tags__link metadata" href="/tags/opengl/">opengl</a><a class="article__tags__link metadata" href="/tags/dascript/">dascript</a></div><div class="article__body"><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Пример использования байдингов OpenGL для языка daScript<br><a id="more"></a></p>
<p>Попробовал разобраться с использованием байндингов библиотек к языку daScript. В качестве тестовой задачки решил портировать на daScript + OpenGL <a href="https://github.com/bkaradzic/bgfx/issues/1857" target="_blank" rel="noopener">эту демку</a>. Программа реализует алгоритм клиппинга модели несколькими плоскостями, с заполненнием отрезанных частей “крышками”, чтобы не было видно внутренней поверхности модели (<a href="https://github.com/daign/clipping-with-caps/blob/master/screenshot_01.png" target="_blank" rel="noopener">скрин</a>).</p>
<p>Алгоритм:</p>
<ul>
<li>Отрисовать модель с шейдером отсечения (с “дырками”)</li>
<li>Заполнить буфер трафарета значениями так, чтобы пометить пиксели, которые нужно закрыть:<br>— Отрисовать внутреннюю сторону модели, увеличивая значение в буфере трафарета<br>— Отрисовать внешнюю сторону модели, уменьшая значение в буфере трафарета<br>— Заполнять буфер трафарета в только в точках, в которых плоскость отсечения повернута к камере (для корректной работы нескольких плоскостей отсечения одновременно)</li>
<li>Отрисовать плоскости отсечения по полученной маске (получаются закрывающие “крышки”)</li>
</ul>
<h2 id="Каркас-приложения"><a href="#Каркас-приложения" class="headerlink" title="Каркас приложения"></a>Каркас приложения</h2><p>Для создания байндингов библиотек к daScript используется <a href="https://github.com/GaijinEntertainment/daScript/issues/231" target="_blank" rel="noopener">dasClangBind</a>, с помощью которого сделаны обёртки для <a href="https://github.com/GaijinEntertainment/daScript/tree/master/modules" target="_blank" rel="noopener">нескольких</a> библиотек, включая OpenGL. Последний из <a href="https://github.com/GaijinEntertainment/daScript/blob/master/modules/dasOpenGL/examples/09_hello_mesh.das" target="_blank" rel="noopener">примеров</a> демонстрирует загрузку и отображение модели из obj-файла. Этот пример можно взять за основу. Для задания настроек отсекающих плоскостей можно взять байндинг к <a href="https://github.com/borisbat/dasImgui/" target="_blank" rel="noopener">imgui</a>.</p>
<p>Эти модули также тащат за собой <code>glfw</code> для создания окна и <code>stbImage</code>. Шаблон C++ кода для подключения модулей:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../modules/dasGlfw/src/dasGLFW.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../modules/dasImgui/src/dasIMGUI.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../modules/dasStbImage/src/dasStbImage.h"</span></span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span>, <span class="keyword">char</span> * [] )</span> </span>&#123;</span><br><span class="line">    NEED_ALL_DEFAULT_MODULES;</span><br><span class="line">    NEED_MODULE(Module_dasGLFW)</span><br><span class="line">    NEED_MODULE(Module_StbImage)</span><br><span class="line">    NEED_MODULE(Module_dasIMGUI)</span><br><span class="line">    NEED_MODULE(Module_imgui_app)</span><br><span class="line">    Module::Initialize();</span><br><span class="line">    tutorial();</span><br><span class="line">    Module::Shutdown();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Пустое окно на glfw + imgui можно создать так:</p>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">def imgui_app(title:string; blk : block)</span><br><span class="line">    <span class="keyword">if</span> glfwInit()==<span class="number">0</span></span><br><span class="line">		panic(<span class="string">"can't init glfw"</span>)</span><br><span class="line">    defer &lt;|</span><br><span class="line">        glfwTerminate()</span><br><span class="line">    glfwInitOpenGL(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line">    var window = glfwCreateWindow(<span class="number">1280</span>, <span class="number">720</span>, <span class="string">"OpenGL - Hello shader clipping"</span>, <span class="keyword">null</span>, <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">if</span> window==<span class="keyword">null</span></span><br><span class="line">		panic(<span class="string">"can't create window"</span>)</span><br><span class="line">    defer &lt;|</span><br><span class="line">        glfwDestroyWindow(window)</span><br><span class="line">    glfwMakeContextCurrent(window)</span><br><span class="line"></span><br><span class="line">    CreateContext(<span class="keyword">null</span>)</span><br><span class="line">    var io &amp; = unsafe(GetIO())</span><br><span class="line">    StyleColorsDark(<span class="keyword">null</span>)</span><br><span class="line">    ImGui_ImplGlfw_InitForOpenGL(window, <span class="keyword">true</span>)</span><br><span class="line">    ImGui_ImplOpenGL3_Init(<span class="string">"#version 330"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> glfwWindowShouldClose(window)==<span class="number">0</span></span><br><span class="line">        glfwPollEvents()</span><br><span class="line"></span><br><span class="line">        ImGui_ImplOpenGL3_NewFrame()</span><br><span class="line">        ImGui_ImplGlfw_NewFrame()</span><br><span class="line"></span><br><span class="line">        invoke(blk)</span><br><span class="line"></span><br><span class="line">        var display_w, display_h : int</span><br><span class="line">        glfwGetFramebufferSize(window, display_w, display_h)</span><br><span class="line">        <span class="keyword">let</span> aspect = display_h!=<span class="number">0</span> ? float(display_w)/float(display_h) : <span class="number">1.</span></span><br><span class="line">        <span class="comment">// render</span></span><br><span class="line">        glViewport(<span class="number">0</span>, <span class="number">0</span>, display_w, display_h)</span><br><span class="line">        glClearColor(<span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">1.0</span>)</span><br><span class="line">        glClearDepth(<span class="number">1.0</span>lf)</span><br><span class="line">        glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT|GL_STENCIL_BUFFER_BIT)</span><br><span class="line"></span><br><span class="line">        ImGui_ImplOpenGL3_RenderDrawData(GetDrawData())</span><br><span class="line"></span><br><span class="line">        glfwMakeContextCurrent(window)</span><br><span class="line">        glfwSwapBuffers(window)</span><br><span class="line">    <span class="comment">//close app</span></span><br><span class="line">    DestroyContext(<span class="keyword">null</span>)</span><br><span class="line">    glfwDestroyWindow(window)</span><br><span class="line">    glfwTerminate()</span><br><span class="line"></span><br><span class="line">[export]</span><br><span class="line">def test</span><br><span class="line">	imgui_app(<span class="string">"imgui"</span>) &lt;|</span><br><span class="line">        NewFrame()</span><br><span class="line">        Begin(<span class="string">"Crop params"</span>);</span><br><span class="line">        End();</span><br><span class="line">        Render()</span><br></pre></td></tr></table></figure>
<ul>
<li>не забыли создать и очистить буфер трафарета (GL_STENCIL_BUFFER_BIT)</li>
<li><a href="https://dascript.org/doc/reference/language/blocks.html?highlight=block" target="_blank" rel="noopener">block</a> в daScript — безымянная функция, которая захватывает переменные по ссылке (более быстрая, чем лямбда-функции, которые могут управлять способом захвата)</li>
<li><code>defer</code> — макрос для добавления выражений в блок <a href="https://dascript.org/doc/reference/language/statements.html?highlight=defer#finally-statement" target="_blank" rel="noopener">finally</a></li>
</ul>
<p>Исходная демка использует библиотеки three.js и ColladaLoader.js для загрузки меша из dae файла, но можно <a href="https://products.aspose.app/3d/ru/conversion/dae-to-obj" target="_blank" rel="noopener">конвертировать</a> dae в obj, чтобы использовать код загрузки меша из примера daScript. Загрузка меша:</p>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">require opengl/opengl_gen</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mesh_file_name = <span class="string">"&#123;get_das_root()&#125;/house.obj"</span></span><br><span class="line">var mesh &lt;- load_obj_mesh(mesh_file_name) |&gt; create_geometry_fragment</span><br></pre></td></tr></table></figure>
<h2 id="Отрисовка-меша"><a href="#Отрисовка-меша" class="headerlink" title="Отрисовка меша"></a>Отрисовка меша</h2><p>Задание стандартных шейдеров:</p>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">require glsl/glsl_common</span><br><span class="line">require glsl/glsl_internal</span><br><span class="line"></span><br><span class="line">var [[<span class="keyword">in</span>, location=<span class="number">0</span>]] v_position : float3</span><br><span class="line">var [[<span class="keyword">in</span>, location=<span class="number">1</span>]] v_normal   : float3</span><br><span class="line">var [[<span class="keyword">in</span>, location=<span class="number">2</span>]] v_texcoord : float2</span><br><span class="line">var [[uniform]] v_model : float4x4</span><br><span class="line">var [[uniform]] v_view : float4x4</span><br><span class="line">var [[uniform]] v_projection : float4x4</span><br><span class="line">var [[inout]] f_texcoord : float2</span><br><span class="line">var [[inout]] f_normal : float3</span><br><span class="line">var [[inout]] f_position : float3</span><br><span class="line">var [[inout]] f_worldpos : float3</span><br><span class="line"></span><br><span class="line">var [[uniform, stage=<span class="number">0</span>]] f_tex : sampler2D</span><br><span class="line">var [[out]] f_FragColor : float4</span><br><span class="line"></span><br><span class="line">[vertex_program]</span><br><span class="line">def vs_preview</span><br><span class="line">    f_texcoord = v_texcoord</span><br><span class="line">    f_normal = normalize ( float3x3(v_model) * v_normal )</span><br><span class="line">    <span class="keyword">let</span> tpos = v_model * float4(v_position, <span class="number">1.0</span>)</span><br><span class="line">    f_position = tpos.xyz</span><br><span class="line">    f_worldpos = v_position</span><br><span class="line">    gl_Position = v_projection * v_view * tpos</span><br><span class="line"></span><br><span class="line">[fragment_program (version=<span class="number">400</span>)]</span><br><span class="line">def fs_preview</span><br><span class="line">    <span class="keyword">let</span> pS = <span class="number">24.0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> light_dir = normalize(float3(<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">-3</span>))</span><br><span class="line">    <span class="keyword">let</span> camera_dir = normalize(f_position)</span><br><span class="line">    <span class="keyword">let</span> normal = normalize(f_normal)</span><br><span class="line">    <span class="keyword">let</span> k = -dot(light_dir,normal)</span><br><span class="line">    <span class="keyword">let</span> diffuse = float3(saturate(k))</span><br><span class="line">    <span class="keyword">let</span> refl = normalize ( reflect(camera_dir,normal) )</span><br><span class="line">    <span class="keyword">let</span> kS = saturate(dot(-light_dir,refl))</span><br><span class="line">    <span class="keyword">let</span> kS1 = saturate(dot(-light_dir,refl))</span><br><span class="line">    <span class="keyword">let</span> specular = float3(pow(kS,pS)*kS)</span><br><span class="line">    f_FragColor.xyz = texture(f_tex,f_texcoord).xyz * diffuse + specular</span><br><span class="line">    f_FragColor.w = <span class="number">1.</span></span><br></pre></td></tr></table></figure>
<p>Интересная штука — DSL для работы с шейдерами (<a href="https://github.com/GaijinEntertainment/daScript/blob/master/modules/dasGlsl/glsl/glsl_internal.das" target="_blank" rel="noopener">glsl_internal</a>, набор макросов для того, чтобы писать шейдеры как обычные функции в daScript, а также работать с uniform переменными почти как с обычными переменными языка. Пример передачи uniform-ов в шейдер:</p>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">var [[uniform]] v_projection : float4x4                                     <span class="comment">//объявление uniform переменной для шейдера</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> aspect = display_h!=<span class="number">0</span> ? float(display_w)/float(display_h) : <span class="number">1.</span></span><br><span class="line">v_projection = perspective_rh_opengl( <span class="number">45.0</span>f*PI/<span class="number">180.</span>, aspect, <span class="number">0.1</span>f, <span class="number">10.0</span>f)   <span class="comment">//определяем матрицу проекции (daScript-структура)</span></span><br><span class="line">vs_preview_bind_uniform(program_front)                                      <span class="comment">//передаём uniform переменные в шейдер</span></span><br><span class="line">fs_preview_bind_uniform(program_front)                                      <span class="comment">// vs_preview_bind_uniform - сгенерированная макросом [vertex_program] функция!</span></span><br></pre></td></tr></table></figure>
<p>Помимо простой привязки функций библиотеки, сгенерированной с помощью <code>dasClangBind</code>, написаны также макросы для “daScript-ивизации” кода. Вместо императивного вызова функции <code>glUniformXXX</code>, программист декларирует намерение “эта переменная - uniform для шейдера” — аннотация <code>uniform</code>.</p>
<p><strong><code>За счёт этого скриптовый язык становится не &quot;условным бейсиком&quot; для императивного вызова функций, а способом приблизить библиотеку к предметной области, в терминах которой мыслит и работает программист</code></strong></p>
<p>Отрисовка:</p>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">glUseProgram(program)</span><br><span class="line">vs_preview_bind_uniform(program)</span><br><span class="line">fs_preview_bind_uniform(program)</span><br><span class="line">draw_geometry_fragment(mesh)</span><br></pre></td></tr></table></figure>
<p><img src="/blog/4232971949/clip_1_small.png" alt="1"></p>
<h2 id="Клиппинг-плоскостями-отсечения"><a href="#Клиппинг-плоскостями-отсечения" class="headerlink" title="Клиппинг плоскостями отсечения"></a>Клиппинг плоскостями отсечения</h2><p>Изменим пиксельный шейдер отрисовки объекта:<br><figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">[fragment_program (version=<span class="number">400</span>)]</span><br><span class="line">def fs_preview</span><br><span class="line">    <span class="comment">//если вершина отсекается плоскостями -- отбросить её</span></span><br><span class="line">    <span class="keyword">if</span> (f_worldpos.x &lt; f_crop_plane_x) || (f_worldpos.y &lt; f_crop_plane_y) || (f_worldpos.x &gt; f_crop_plane_x_max) || (f_worldpos.y &gt; f_crop_plane_y_max)</span><br><span class="line">        discard()</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">Установка uniform-переменных через панель imGui</span><br><span class="line">```fsharp</span><br><span class="line">    Begin(<span class="string">"Crop params"</span>);</span><br><span class="line">    SliderFloat(<span class="string">"Crop plane X"</span>, safe_addr(f_crop_plane_x), <span class="number">-1.0</span>f, <span class="number">1.0</span>f)</span><br><span class="line">    SliderFloat(<span class="string">"Crop plane Xnax"</span>, safe_addr(f_crop_plane_x_max), <span class="number">-1.0</span>f, <span class="number">1.0</span>f)</span><br><span class="line">    SliderFloat(<span class="string">"Crop plane Y"</span>, safe_addr(f_crop_plane_y), <span class="number">-1.0</span>f, <span class="number">1.0</span>f)</span><br><span class="line">    SliderFloat(<span class="string">"Crop plane Ymax"</span>, safe_addr(f_crop_plane_y_max), <span class="number">-1.0</span>f, <span class="number">1.0</span>f)</span><br><span class="line">    End();</span><br></pre></td></tr></table></figure><br><img src="/blog/4232971949/clip_2_small.png" alt="2"></p>
<p>Сквозь отброшенные пиксели пока видны внутренние грани объекта.</p>
<h2 id="Заполнение-буфера-трафарета"><a href="#Заполнение-буфера-трафарета" class="headerlink" title="Заполнение буфера трафарета"></a>Заполнение буфера трафарета</h2><p>Исходная демка на three.js использует для описания состояния рендера концепцию <a href="https://github.com/daign/clipping-with-caps/blob/master/js/material.js" target="_blank" rel="noopener">материалов</a> этой библиотеки, но несложно сопоставить свойства материлов с параметрами OpenGL</p>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//упрощенный шейдер для вывода в буфер трафарета</span></span><br><span class="line">[fragment_program (version=<span class="number">400</span>)]</span><br><span class="line">def fs_preview_front</span><br><span class="line">    <span class="keyword">let</span> not_inside_camera = (f_worldpos.x &lt; f_crop_plane_x) || (f_worldpos.y &lt; f_crop_plane_y) || (f_worldpos.x &gt; f_crop_plane_x_max) || (f_worldpos.y &gt; f_crop_plane_y_max)</span><br><span class="line">    <span class="keyword">if</span> not_inside_camera</span><br><span class="line">        discard()</span><br><span class="line">    f_FragColor = float4(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">//Включаем рендер в буфер трафарета, отключаем запись в буфера цвета и глубины</span></span><br><span class="line">glEnable(GL_STENCIL_TEST)</span><br><span class="line">glColorMask(<span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>)</span><br><span class="line">glDepthMask(<span class="keyword">false</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//установка шейдера</span></span><br><span class="line">glUseProgram(program_front)</span><br><span class="line">vs_preview_bind_uniform(program_front)</span><br><span class="line">fs_preview_front_bind_uniform(program_front)</span><br><span class="line"></span><br><span class="line"><span class="comment">//рендер только задних граней объекта с увеличением значения в буфере трафарета</span></span><br><span class="line">glEnable(GL_CULL_FACE);</span><br><span class="line">glCullFace(GL_FRONT);</span><br><span class="line">glStencilFunc(GL_ALWAYS, <span class="number">1</span>, <span class="number">0xFF</span>)</span><br><span class="line">glStencilOp(GL_KEEP, GL_KEEP, GL_INCR)</span><br><span class="line">draw_geometry_fragment(mesh)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Рендер только передних граней объекта с уменьшения значения в буфере трафарета</span></span><br><span class="line">glEnable(GL_CULL_FACE);</span><br><span class="line">glCullFace(GL_BACK);</span><br><span class="line">glStencilFunc(GL_ALWAYS, <span class="number">1</span>, <span class="number">0xFF</span>)</span><br><span class="line">glStencilOp(GL_KEEP, GL_KEEP, GL_DECR)</span><br><span class="line">draw_geometry_fragment(mesh)</span><br></pre></td></tr></table></figure>
<p>Вывод отсекающих граней:</p>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//функция генерации прямоугольника заданного размера</span></span><br><span class="line">def gen_axis_rect(plt : GenDirection; x1, x2, y1, y2, coord: float)</span><br><span class="line">    var frag : GeometryFragment</span><br><span class="line">    frag.vertices &lt;- [&#123;GeometryPreviewVertex</span><br><span class="line">        xyz=float3( x1, y1, coord), normal=float3(  <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>),  uv=float2(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        xyz=float3(x2, y1, coord), normal=float3(  <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>),  uv=float2(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        xyz=float3(x2,y2, coord), normal=float3(  <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>),  uv=float2(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        xyz=float3( x1,y2, coord), normal=float3(  <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>),  uv=float2(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">    &#125;]</span><br><span class="line">    apply_gen_direction_tm(plt, frag)</span><br><span class="line">    frag.indices &lt;- [&#123;int <span class="number">0</span>; <span class="number">1</span>; <span class="number">2</span>; <span class="number">2</span>; <span class="number">3</span>; <span class="number">0</span> &#125;]</span><br><span class="line">    frag.prim = GeometryFragmentType triangles</span><br><span class="line">    gen_bbox(frag)</span><br><span class="line">    <span class="keyword">return</span> &lt;- frag</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">[fragment_program (version=<span class="number">400</span>)]</span><br><span class="line">def fs_preview_caps</span><br><span class="line">    f_FragColor = float4(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>)</span><br><span class="line"></span><br><span class="line">glUseProgram(program_caps)</span><br><span class="line"></span><br><span class="line"><span class="comment">//отрисовка через полученную в буфере трафарета маску</span></span><br><span class="line">glStencilFunc(GL_EQUAL, <span class="number">1</span>, <span class="number">0xFF</span>)</span><br><span class="line">glStencilOp(GL_KEEP, GL_KEEP, GL_KEEP)</span><br><span class="line">vs_preview_bind_uniform(program_caps)</span><br><span class="line">fs_preview_caps_bind_uniform(program_caps)</span><br><span class="line"></span><br><span class="line"><span class="comment">//генерация отсекающих плоскостей</span></span><br><span class="line">var planeX &lt;- gen_axis_rect(GenDirection yz, <span class="number">2.0</span>, <span class="number">-2.0</span>, f_crop_plane_y_max, f_crop_plane_y, -f_crop_plane_x) |&gt; create_geometry_fragment</span><br><span class="line">draw_geometry_fragment(planeX)</span><br><span class="line">var planeXMax &lt;- gen_axis_rect(GenDirection yz, <span class="number">2.0</span>, <span class="number">-2.0</span>, f_crop_plane_y_max,f_crop_plane_y, -f_crop_plane_x_max) |&gt; create_geometry_fragment</span><br><span class="line">draw_geometry_fragment(planeXMax)</span><br><span class="line"></span><br><span class="line">var planeY &lt;- gen_axis_rect(GenDirection xz, f_crop_plane_x, f_crop_plane_x_max, <span class="number">2.0</span>, <span class="number">-2.0</span>, f_crop_plane_y) |&gt; create_geometry_fragment</span><br><span class="line">draw_geometry_fragment(planeY)</span><br><span class="line">var planeYMax &lt;- gen_axis_rect(GenDirection xz, f_crop_plane_x, f_crop_plane_x_max, <span class="number">2.0</span>, <span class="number">-2.0</span>, f_crop_plane_y_max) |&gt; create_geometry_fragment</span><br><span class="line">draw_geometry_fragment(planeYMax)</span><br></pre></td></tr></table></figure>
<p>Как отмечено в описании алгоритма <a href="https://github.com/daign/clipping-with-caps#clipping-with-caps" target="_blank" rel="noopener">референсной демки</a>, такой подход нормально работает с одной плоскостью отсечения, но с нескольими плоскостями даёт неверный результат (повёрнутые “от камеры” плоскости отсечения также вносят вклад в маску и портят результат в буфере трафарета — выводят лишние “дырки” или “крышки” в таких местах:</p>
<p><img src="/blog/4232971949/clip_3_small.png" alt="3"></p>
<h2 id="Коррекция-буфера-трафарета-для-граней-повернутых-от-камеры"><a href="#Коррекция-буфера-трафарета-для-граней-повернутых-от-камеры" class="headerlink" title="Коррекция буфера трафарета для граней, повернутых от камеры"></a>Коррекция буфера трафарета для граней, повернутых от камеры</h2><p>На этом этапе обнаруживаются отличия между демкой-референсом и примером из daScript. Позиция камеры в референсной демке попадает в шейдера “автоматически”, эта переменная <a href="https://threejs.org/docs/#api/en/renderers/webgl/WebGLProgram" target="_blank" rel="noopener">устанавливается</a> библиотекой three.js. Для примера на daScript нужно передать её вручную и учесть то, что системы координат в демках различаются. Поворот в примере daScript задаётся через матрицу <code>v_model</code>, так что для трансформации камеры в систему координат модели и плоскостей отсечения нужно также “довернуть” её, умножив на матрицу модели.</p>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//позиция камеры в пространстве координат модели</span></span><br><span class="line">var [[uniform]] f_camera_position_rotated : float3</span><br><span class="line"></span><br><span class="line"><span class="comment">//шейдер для вывода в буфер трафарета</span></span><br><span class="line">[fragment_program (version=<span class="number">400</span>)]</span><br><span class="line">def fs_preview_front</span><br><span class="line">    <span class="comment">//let not_inside_camera =  (f_worldpos.x &lt; f_crop_plane_x) || (f_worldpos.y &lt; f_crop_plane_y) || (f_worldpos.x &gt; f_crop_plane_x_max) || (f_worldpos.y &gt; f_crop_plane_y_max)</span></span><br><span class="line">    <span class="keyword">let</span> not_inside_camera = (f_worldpos.x &lt; f_crop_plane_x) &amp;&amp; (f_camera_position_rotated.x &gt; -f_crop_plane_x) || (f_worldpos.y &lt; f_crop_plane_y) &amp;&amp; (f_camera_position_rotated.y &lt; f_crop_plane_y) || (f_worldpos.x &gt; f_crop_plane_x_max) &amp;&amp; (f_camera_position_rotated.x &lt; -f_crop_plane_x_max) || (f_worldpos.y &gt; f_crop_plane_y_max) &amp;&amp; (f_camera_position_rotated.y &gt; f_crop_plane_y_max)</span><br><span class="line">    <span class="keyword">if</span> not_inside_camera</span><br><span class="line">        discard()</span><br><span class="line">    f_FragColor = float4(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">//поворот камеры в пространство координат модели</span></span><br><span class="line"><span class="keyword">let</span> camPos = v_model * float4(camera_position, <span class="number">1.0</span>)</span><br><span class="line">f_camera_position_rotated = camPos.xyz</span><br></pre></td></tr></table></figure>
<p>Можно обратить внимание на идентичный синтаксис умножения вектора на матрицу в коде вершинного шейдера для трансфорфмации вершин меша,  и обычном скрипте на daScript.</p>
<p>Теперь наконец отсечения смотрятся корректно под любым углом.</p>
<p><img src="/blog/4232971949/clip_4_small.png" alt="4"></p>
<p><a href="https://github.com/spiiin/dascript_macro_tutorial/blob/master/clipping_with_caps/tutorial01.das" target="_blank" rel="noopener">Исходный код туториала</a></p>
<ul>
<li>daScript хорош, чтобы поиграться с демками графических эффектов :)</li>
<li>подход авторов к написанию байндингов — автоматическая обёртка на c/c++-функциями + “daScript-тификация” кода — создание макросов, упрощающих работу с библиотекой</li>
<li>вообще, демку стоило бы ещё перевести на режим <a href="https://github.com/borisbat/dasGlfw/blob/48f2715f0fe4cb8076866365a4bf0a29b7104765/dasglfw/glfw_live.das" target="_blank" rel="noopener">live-изменений</a>, тянет на отдельный туториал</li>
</ul>
<p>Ну и более глобальный вывод про совокупность всех фич языка — если большая часть кода на языке делает то, что сложно или долго делать на других языках, с какого-то момента разработки сама программа может получить какие-то свойства, которых нет у программ на других языках (потому что их было слишком долго или трудно реализовывать).</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script></div></article><div class="pagination"><a class="pagination__link pagination__prev" href="/blog/2371214813/">Позже</a><a class="pagination__link pagination__next" href="/blog/1547564887/">Раньше</a></div></main><footer class="footer metadata"><p class="footer__text">© 2024 spiiin</p><p class="footer__text">Powered by <a class="footer__text__link" href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a class="footer__text__link" href="https://pages.github.com/" target="_blank">Github Page</a></p></footer></div></body></html>