---
title: C++ Metaprogramming - ссылки
abbrlink: 4174799834
date: 2023-03-19 02:30:26
tags: [cpp, link, книги]
---

Список книг и ресурсов по метапрограммированию в C++. Грубая карта небольшой части огромной территории.

Желание разобраться с очередным трюком с шаблонами в C++ приходит после обнаружения какой-либо библиотеки или кода, который непонятно как работает, но вроде что-то ловко делает. И заканчивается мыслью "это ж ебануться можно, так писать".

<!-- more -->

Такие мысли приходят в голову всем практикующим и работающим в командах программистам. Пара примеров лютых исходников -- [cppcoro](https://github.com/lewissbaker/cppcoro), [range-v3](https://github.com/ericniebler/range-v3) (["Modern" C++ Lamenations](https://aras-p.info/blog/2018/12/28/Modern-C-Lamentations/)).
![](230319-cpp-templates-links/spiderman.jpg)

{% post_link 210526-programming-languages %} -- про использование различных языков для решения задач различных уровней, а также подходы к борьбе с возрастающей сложностью при масштабируемости.
{% post_link 220130-about-cpp-gamedev %} -- "высокоуровневый" С++ - часть задач решаемых метапрограммированием.

## Общий обзор возможностей шаблонов и списки примеров использования:
**`Vandervoorde D. Josuttis N. Gregor D. - C++ Templates: The Complete Guide`** - полный обзор возможностей языка, второе издание -- по C++17
**`Александреску А. - Современное проектирование на C++`** - pre-C++11, но классические идеи
**`Di Genaro D. - Advanced Metaprogramming in Classic C++`** - много небольших примеров
[More C++ idioms](https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms) - еще больше примеров, не только с шаблонами
[Boost](https://www.boost.org/) - лучший учебник

## Generic-типы

Часто первое столкновение с шаблонами -- обобщенные контейнеры, итераторы и умные указатели из `stl`
Более продвинутые примеры -- стратегии Александреску, задание отношений между типами, CRTP, template template параметры

[EnTT dense set](https://github.com/skypjack/entt/blob/master/src/entt/container/dense_set.hpp) - пример кода контейнера и итератора не из stl
[libnest2d](https://github.com/tamasmeszaros/libnest2d/blob/master/include/libnest2d/libnest2d.hpp) - небольшая библиотека для паковки многоугольников, использующая стратегии для выбора вариантов оптимизации, паковки и математического бекэнда

## Задание ограничений и свойств для типов

Контракты, распознавание свойств типов (`std::is_XXX`), частичная специализация

**`Stepanov A. - Elements of programming`** - математическое описание типов и структур, контракты
[Lecture and presentation Sean Parent](https://sean-parent.stlab.cc/papers-and-presentations/) - и другие лекции Шона Парента, про value-oriented programming

[Пример из daScript](https://github.com/GaijinEntertainment/daScript/pull/472/files#diff-2a42eb62b92995bc578cc927dc871b66a1a00f003c819a108abd291e23b33bb1R150) -- частичная специализация с захватом новых шаблонных параметров
[Templated class specialization where template argument is a template](https://stackoverflow.com/questions/4189945/templated-class-specialization-where-template-argument-is-a-template) - описание возможных подходов к созданию связи между шаблонными параметрами

## Работа с типами как с данными

Типы не являются объектами первого класса, поэтому работы с ними, поэтому все действия выполняются во время компиляции. Один из ключевых приёмов -- выбор того, или иного типа в зависимости от статически известного условия. При этом не определяется новый тип, а создаётся псевдоним для существуюшего, "слот", в который можно сохранить любой тип (`typedef`). Типы используются не для создания экземпляров, а для вообще чего угодно, от управляющих конструкций и отправки сигналов в рантайм, до операций группировки других типов.

**`Abrahams D. Gurtovoy A. - C++ Template Metaprogramming`** - одна из наиболее замороченных книг, pre-C++11. Частично описывает [Boost.MPL](https://www.boost.org/doc/libs/1_43_0/libs/mpl/doc/index.html)
[Boost.Mp11](https://www.boost.org/doc/libs/master/libs/mp11/doc/html/mp11.html) - C++11-версия библиотеки для манипуляции с типами, несколько статей сравнения новых подходов со старыми

## Domain Specific Language

Следующая идея -- пойти еще дальше: построить на специальных типах свой язык, с управляющими конструкциями. Примеры задач -- парсинг команд и создание деревьев выражений для последующего вычисления в рантайме.

[Hana Dusíková — A state of сompile time regular expressions](https://www.youtube.com/watch?v=r_ZASJFQGQI) -- регулярные выражения в compile-time ([compile-time.re](https://github.com/hanickadot/compile-time-regular-expressions))
[Ben Deane & Jason Turner “constexpr ALL the Things!”](https://www.youtube.com/watch?v=PJwd4JLYJJY) -- парсинг json в compile-time

{% post_link 210531-cpp-dynamic-polymorphism%} - пост со ссылками на серию видео про построение в compile-time кастомных версий динамического полиморфизма. [dyno](https://github.com/ldionne/dyno) - библиотека Louis Dionne, автора Boost.Hana

## Выполнение кода в compile-time

Изначально возможность выполнения кода во время компиляции в С++ была артефактом шаблонов (первая "программа" - вывод простых чисел в сообщении об ошибке). Со временем добавляются более серьёзные возможности, однако код времени компиляции серьёзно ограничен и отличается от среды выполнения.

Примеры задач в compile-time:
- заранее предпосчитать значение выражение, все части которого известны на момент компиляции
- построить таблицу значений чистой функции, которая долго вычисляется

Основная возможность в pre-C++11 - SFINAE и рекурсивные+терминальные пары функций, и дополнительно const-expr/if/eval в более поздних стандартах.

[Don't constexpr All the Things - David Sankel CppNow 2021](https://www.youtube.com/watch?v=NNU6cbG96M4) - обзор ограничений подъязыка времени выполнения
[Circle](https://www.circle-lang.org/) - wip компилятор C++ Шона Бакстера, с возможностью выполнение кода на этапе компиляции без ограничений
[Ideas for a Programming Language Part 3: No Shadow Worlds](https://probablydance.com/2015/02/16/ideas-for-a-programming-language-part-3-no-shadow-worlds/) - похожие рассуждения на тему того, что не полностью интегрированные в основной язык подмножества создают "теневые миры", в которых приходится переизобреть заново возможности основного языка

*В Circle меня настораживает, что код, кажется, должен компилироваться дважды, особенно с учетом того, что скорее всего выполнение кода в compile-time будет медленнее, чем в рантайм. Для nim выполнение кода в compile-time -- раз в 10 медленее*

## Доступ к данным о типах в рантайм

Отсутствует в C, и не zero-cost абстракция, так что в стандарте языка отсутствует механизм неявной передачи информации о типах в рантайм (можно откопать [пачку](https://youtu.be/NWIsRFDaHhs?t=847) предложений для будущих улучшений).

Поэтому задачи типа `рефлексии/инстроспекции` решаются либо явной декларацией полей и методов класса (как при создании врапперов для других языков), либо предварительным внешним парсингом кода -- либо кастомной метаинформации, которую пропускает компилятор C++ (в комментариях), либо полноценным разбором кода (`clang`), с последующей генерацией по этой информации кода.

Аналогично, без явной интроспекции и вещи вроде `сериализации` или описания RPC не могут быть неявными -- необходимо явно аннотировать типы. 

`Кодогенерация` выражений на C++ в рантайме также отсутствует в стандарте, и заменяется генерации во время компиляции -- текста, либо бинарного кода (или промежуточного кода, вроде IR для LLVM).

{% post_link 221009-llvm-review %} -- обзор тулзов из набора LLVM, для парсинга и генерации кода, в настоящий момент state-of-art для генерации кода на C++
[Automatic C++ source code generation with clang - Sergei Sadovnikov ACCU 2017](https://www.youtube.com/watch?v=aPTyatTI42k) - доклад с обзором подходов, и способа генерации с помощью clang
[Reflection in C++ Next - Anton Bikineev - Meeting C++ 2017](https://www.youtube.com/watch?v=NWIsRFDaHhs) - обзор пропозалов в стандарт, связанных с рефлексией
[Boost.Serialization](https://www.boost.org/doc/libs/1_79_0/libs/serialization/doc/tutorial.html) - сериализация в Boost

## Функциональное программирование

Обширная тема. Элементы функционального стиля программирования -- `комбинирование функций` (функции высшего порядка, частичное применение, отложенные вычисления) и их `чистота`. Часть перечисленных выше методов метапрограммирования направлена на борьбу со возрастающей при масштабировании программ сложностью путем создания новых абстракций. Функциональное программирование также работает с абстракциями, но выбирает их со стороны математики, ради того, чтобы использовать свойства уже изученных объектов (с поправкой на то, что в языках программирования реализуются приближения к математическим объектам).

**`Чукич И. - Функциональное программирование на языке С++`** -- книга о том, как использовать элементы функционального программирования на C++, ссылки на библиотеки буста, реализующие концепции
[Milewski B. - Category Theory For Programmers](https://github.com/hmemcpy/milewski-ctfp-pdf/) - серия статей (собранная в книгу), по теории категорий для программистов, с примерами на C++ и хаскелл. [Видеолекции](https://www.youtube.com/watch?v=I8LbkfSSR58&list=PLbgaMIhjbmEnaH_LTkxLI7FMa2HsnawM_) на ту же тему
[In-depth: Functional programming in C++](https://www.gamedeveloper.com/programming/in-depth-functional-programming-in-c-) - статья Кармака про бонусы, которые можно получить, если использовать функциональный подход, в частности, бонусы от чистоты функций

