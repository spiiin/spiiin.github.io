<!DOCTYPE html><html lang="ru"><head><meta charset="UTF-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Spiiin's blog | Расположение объектов C++ в памяти. Часть 2</title><meta name="description" content="&lt;p&gt;Продолжение экспериментов с изучением расположения объектов C++ в памяти.&lt;br&gt;"><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=PT+Serif&amp;display=swap"><link rel="stylesheet" href="/css/highlights/darkula.css"><link rel="stylesheet" href="/css/main.css"><link rel="search" type="application/opensearchdescription+xml" href="http://spiiin.github.io/atom.xml" title="Spiiin's blog"><script>(function (i, s, o, g, r, a, m) {
  i['GoogleAnalyticsObject'] = r;
  i[r] = i[r] || function () {
    (i[r].q = i[r].q || []).push(arguments)
  }, i[r].l = 1 * new Date();
  a = s.createElement(o),
    m = s.getElementsByTagName(o)[0];
  a.async = 1;
  a.src = g;
  m.parentNode.insertBefore(a, m)
})(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');
ga('create', 'UA-00000000-0', 'auto');
ga('send', 'pageview');</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Spiiin's blog" type="application/atom+xml">
</head><body><div class="container"><header class="main-header"><h1 class="main-header__title uplize"><a class="main-header__title__link" href="/"><img class="header-image" src="/images/favicon.png" width="36" height="36">Spiiin's blog</a></h1><nav class="main-header__nav"><ul class="main-nav"><li class="main-nav__list"><a class="main-nav__list__link" href="/" target="_self">HOME</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/archives/" target="_self">ARCHIVE</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/tags/meta" target="_self">TAGS</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/blog/1" target="_self">ABOUT</a></li></ul></nav></header><main class="container__wrapper"><div class="pagination"><a class="pagination__link pagination__prev" href="/blog/2701222076/">Позже</a><a class="pagination__link pagination__next" href="/blog/854775037/">Раньше</a></div><article class="article post"><h3 class="article__title">Расположение объектов C++ в памяти. Часть 2</h3><div class="article__date metadata"><div class="post-info">2021/06/15</div></div><div class="article__tags metadata">Tags:
<a class="article__tags__link metadata" href="/tags/cpp/">cpp</a><a class="article__tags__link metadata" href="/tags/dev-method/">dev_method</a><a class="article__tags__link metadata" href="/tags/llvm/">llvm</a><a class="article__tags__link metadata" href="/tags/longread/">longread</a></div><div class="article__body"><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Продолжение экспериментов с изучением расположения объектов C++ в памяти.<br><a id="more"></a></p>
<a href="/blog/854775037/" title="Предыдущая заметка">Предыдущая заметка</a> 
<p>закончилась на том, что самым удобным способом изучения оказался статический анализ информации для отладчика из исполнимого файла или отладочной базы данных. Этот способ удобен, если нужно оптимизировать большую готовую кодовую базу. Но у него есть два серьёзных минуса.</p>
<h2 id="Минусы-статического-анализа"><a href="#Минусы-статического-анализа" class="headerlink" title="Минусы статического анализа"></a>Минусы статического анализа</h2><p>Во-первых, инструменты и библиотеки требуют написания большого количества кода, из-за чего 1) ни одна из них не покрывает нормально бинарники обеих платформ iOS/Android, 2) написанные руками формулы по спецификации не покрывают всех corner-case и могут содержать ошибки, которые сложно заметить и исправить - поддерживать такой скрипт/инструмент сложно. Было бы намного удобнее воспользоваться кодовой базой самого компилятора или отладчика, чтобы избавиться от необходимости поддержки своего кода.</p>
<p>Во-вторых, изучение базы классов и оптимизация таким способом производится слишком редко, и зачастую слишком поздно, когда времени остаётся только на исправление самых больных мест.</p>
<h2 id="Ранняя-оптимизация"><a href="#Ранняя-оптимизация" class="headerlink" title="Ранняя оптимизация"></a>Ранняя оптимизация</h2><p>Идеология “не оптимизировать код пока не потребуют” растёт из цитаты Дональда Кнута <em>“Преждевременная оптимизация – корень всех зол”</em>.</p>
<p>Проблема такого подхода - программисты пишут изначально плохой код, вообще не задумываясь о том, чтобы его оптимизировать. Ведь пока не найдено “бутылочное горлышко” - твой код не самый плохой, и трогать его не надо. В итоге получается, что среднестатистический код проекта содержит большое количество балласта, который можно было легко выбросить, если сразу его увидеть.</p>
<p>Сама стадия измерения производительности откладывается как можно дальше, чаще всего на оставшееся до релиза время (а его никогда не бывает слишком много), или вообще забрасывается. Любая некритическая, а, возможно, и критическая) todo-шка в коде в стиле “я сделаю это нормально” рискует прожить в коде много лет. Чаще всего программисты относятся к кодовой базе по принципу “работает - не трогай”, такой подход имеет определенный смысл - переписывание всегда добавляет новые ошибки, но он совсем не способствует тому, чтобы переписывать код на более быстрый.</p>
<p>Можно попробовать сменить подход, и вытащить стадию оптимизации размера структур и расположения их в памяти как можно раньше. В идеале, ещё до написания кода или хотя бы на момент его компиляции.</p>
<p>Тогда каждая компиляция станет проверкой прототипа лучшей версии кода.</p>
<p><strong><code>Чем раньше узнаешь, что с твоими данными что-то не так, тем скорее можешь это исправить</code></strong> (<a href="https://www.dataorienteddesign.com/dodbook/node2.html" target="_blank" rel="noopener">It’s all about your data!</a>).</p>
<p>Такое исправление не будет “корнем зол”, если на него не потребуется много времени - а с этим и должны помочь инструменты.</p>
<h2 id="Получение-данных-от-компилятора"><a href="#Получение-данных-от-компилятора" class="headerlink" title="Получение данных от компилятора"></a>Получение данных от компилятора</h2><p>Простое получение данных от <code>Clang</code> и <code>Visual C++</code> во время компиляции рассматривалось в предудыщей заметке - они поддерживают ключи <code>fdump-record-layouts</code>/<code>d1reportAllClassLayout</code> для вывода выравнивания структуры в stdout, однако оно не удобно, так как порождает слишком много текста, плохо фильтруется, и показывает абсолютное выравнивание структур и классов вместо относительного и держать его включенным постоянно неудобно.</p>
<p>Другой возможный подход - написание плагина к компилятору. Это не очень сложно в теории, Clang задумывался расширяемым, несколько статей для поисков в нужном направлении:<br><a href="https://kevinaboos.wordpress.com/2013/07/23/clang-tutorial-part-i-introduction/" target="_blank" rel="noopener">Clang tutorial introduction</a> - примеры использования интерфейсов к Clang - <code>плагины, LibTooling, LibClang</code>.<br><a href="https://clang.llvm.org/docs/ExternalClangExamples.html" target="_blank" rel="noopener">External Clang examples</a> - примеры расширения компилятора, в частности:<br><a href="https://github.com/LibreOffice/core/tree/master/compilerplugins/clang" target="_blank" rel="noopener">LibreOffice compiler plugins</a> - примеры плагинов, реализующих различные проверки. Местами linux-specific (pahole-all-classes.py использует linux-утилиту pahole, чтобы показывать выравнивание и дыры в структурах, почто то что нужно).<br><a href="https://sudonull.com/post/114803-Creating-and-Using-the-Clang-Plugin-in-Xcode" target="_blank" rel="noopener">Creating and Using the Clang Plugin in Xcode</a> - “Hello, world”-плагин для Xcode.</p>
<p>Плагин собирается в dll/.so/.dylib файл, который передаётся компилятору через командную строку:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$LLVM_HOME</span>/llvm_build/bin/clang ../test.cpp \</span><br><span class="line">  -Xclang -load \</span><br><span class="line">  -Xclang lib/Debug/TestClangPlugin.dylib \</span><br><span class="line">  -Xclang -plugin \</span><br><span class="line">  -Xclang TestClangPlugin</span><br></pre></td></tr></table></figure>
<p>Но, ключевое слово здесь “в теории”. Сборка плагина требует сборки компилятора из исходников, причём исходников той версии, для которую собирается плагин. Для большой кодовой базы старые версии исходников могут просто не собраться новые версиями средств сборки (а учитывая желание иметь кросс-платформенный плагин - количество требуемых усилий нужно умножать на количество платформ). Кроме того, автор плагина для Xcode отмечает, что компилятор Clang от Apple не поддерживает плагины (и скорее всего может ещё в чем-то отличаться от оригинального), что уже не очень удобно - требуется или использовать обычный компилятор для сборки приложения и модифицированные - для работы с плагинами, либо положиться на то, что Apple не использовала каких-либо специфичных хаков для сборки своего компилятора.</p>
<p>Кроме того, API компилятора <a href="https://chromium.googlesource.com/chromium/src/+/HEAD/docs/writing_clang_plugins.md" target="_blank" rel="noopener">нестабильно</a>, так что всё равно возникает необходимость поддержки своих плагинов, а код плагина может быть немаленьким (хотя, по большей части, нужная функциональность почти вся сосредоточена в <a href="https://clang.llvm.org/doxygen/RecordLayoutBuilder_8cpp_source.html" target="_blank" rel="noopener">одном файле</a>.</p>
<p>Дополнительной проблемой может стать увеличенное время компиляции (я не измерял, насколько постоянно включенные плагины замедляют сборку), хотя тут можно было бы попробовать помечать для обработки отдельные классы (например, <a href="https://en.cppreference.com/w/cpp/language/attributes" target="_blank" rel="noopener">атрибутом</a>) и перекомпилировать только отдельные единицы компиляции, а не весь проект.</p>
<p>Но пока я возился с документацией по плагинам, я нашёл способ удобнее. Расширяемым сделан не только компилятор, но и отладчик <a href="https://lldb.llvm.org/use/python.html" target="_blank" rel="noopener">LLDB</a>. И самое главное, он расширяется не плагинами, а имеет python-интерфейс. А значит, есть шанс, что скрипт будет работать под любую платформу!</p>
<h2 id="Интерактивная-отладка-в-LLDB-с-Python"><a href="#Интерактивная-отладка-в-LLDB-с-Python" class="headerlink" title="Интерактивная отладка в LLDB с Python"></a>Интерактивная отладка в LLDB с Python</h2><p>После небольших экспериментов я понял, что это то, что нужно, скрипт работает в <code>XCode</code>, <code>Android Studio</code> и <code>Visual Studio Code</code> (с использованием плагина <a href="https://marketplace.visualstudio.com/items?itemName=vadimcn.vscode-lldb" target="_blank" rel="noopener">CodeLLDB</a>).</p>
<p><a href="https://github.com/spiiin/lldb_dump_class_layout" target="_blank" rel="noopener">https://github.com/spiiin/lldb_dump_class_layout</a> - скрипт для LLDB.</p>
<p>Для загрузки скрипта из отладчика нужно выполнить команду для импорта скрипта:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">command script import ~&#x2F;PATH_TO_SCRIPT&#x2F;dump_class_laouyt.py</span><br></pre></td></tr></table></figure>
<p>После чего из lldb можно выполнять команды <code>layout STRUCT_NAME</code> (для поиска в загруженных образах информации о типе STRUCT_NAME) и <code>layoutvar VARIABLE_NAME</code> (для получения информации о переменной на фрейме стека).</p>
<p><img src="/blog/1170009669/lldb1.png" alt="lldb1"><br><img src="/blog/1170009669/lldb2.png" alt="lldb2"><br><img src="/blog/1170009669/lldb3.png" alt="lldb3"></p>
<p>Одна из интересных возможностей скрипта - изучения памяти для типов из STL, например, для <code>std::map</code>:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; aaa;</span><br><span class="line">(<span class="keyword">void</span>)<span class="keyword">sizeof</span>(aaa); <span class="comment">//чтобы компилятор не выбросил неиспользуемый тип</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(lldb) layoutvar aaa</span><br><span class="line"><span class="built_in">std</span>::__1::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="built_in">std</span>::__1::less&lt;<span class="keyword">int</span>&gt;, SimpleAllocator&lt;<span class="built_in">std</span>::__1::pair&lt;<span class="keyword">const</span> <span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; &gt;</span><br><span class="line"> +<span class="number">0</span> &lt; <span class="number">24</span>&gt; <span class="built_in">std</span>::__1::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="built_in">std</span>::__1::less&lt;<span class="keyword">int</span>&gt;, SimpleAllocator&lt;<span class="built_in">std</span>::__1::pair&lt;<span class="keyword">const</span> <span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; &gt;</span><br><span class="line"> +<span class="number">0</span> &lt; <span class="number">24</span>&gt;   <span class="built_in">std</span>::__1::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="built_in">std</span>::__1::less&lt;<span class="keyword">int</span>&gt;, SimpleAllocator&lt;<span class="built_in">std</span>::__1::pair&lt;<span class="keyword">const</span> <span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; &gt;::__base __tree_</span><br><span class="line"> +<span class="number">0</span> &lt; <span class="number">8</span>&gt;    <span class="built_in">std</span>::__1::__tree&lt;<span class="built_in">std</span>::__1::__value_type&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="built_in">std</span>::__1::__map_value_compare&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::__1::__value_type&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="built_in">std</span>::__1::less&lt;<span class="keyword">int</span>&gt;, <span class="literal">true</span>&gt;, SimpleAllocator&lt;<span class="built_in">std</span>::__1::__value_type&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; &gt;::__iter_pointer __begin_node_</span><br><span class="line"> +<span class="number">8</span> &lt; <span class="number">8</span>&gt;     <span class="built_in">std</span>::__1::__compressed_pair&lt;<span class="built_in">std</span>::__1::__tree_end_node&lt;<span class="built_in">std</span>::__1::__tree_node_base&lt;<span class="keyword">void</span> *&gt; *&gt;, SimpleAllocator&lt;<span class="built_in">std</span>::__1::__tree_node&lt;<span class="built_in">std</span>::__1::__value_type&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">void</span> *&gt; &gt; &gt; __pair1_</span><br><span class="line"> +<span class="number">8</span> &lt; <span class="number">8</span>&gt;       <span class="built_in">std</span>::__1::__compressed_pair_elem&lt;<span class="built_in">std</span>::__1::__tree_end_node&lt;<span class="built_in">std</span>::__1::__tree_node_base&lt;<span class="keyword">void</span> *&gt; *&gt;, <span class="number">0</span>, <span class="literal">false</span>&gt; <span class="built_in">std</span>::__1::__compressed_pair_elem&lt;<span class="built_in">std</span>::__1::__tree_end_node&lt;<span class="built_in">std</span>::__1::__tree_node_base&lt;<span class="keyword">void</span> *&gt; *&gt;, <span class="number">0</span>, <span class="literal">false</span>&gt;</span><br><span class="line"> +<span class="number">8</span> &lt; <span class="number">8</span>&gt;         <span class="built_in">std</span>::__1::__tree_end_node&lt;<span class="built_in">std</span>::__1::__tree_node_base&lt;<span class="keyword">void</span> *&gt; *&gt; __value_</span><br><span class="line"> +<span class="number">8</span> &lt; <span class="number">8</span>&gt;          <span class="built_in">std</span>::__1::__tree_end_node&lt;<span class="built_in">std</span>::__1::__tree_node_base&lt;<span class="keyword">void</span> *&gt; *&gt;::pointer __left_</span><br><span class="line"> +<span class="number">8</span> &lt; <span class="number">1</span>&gt;       <span class="built_in">std</span>::__1::__compressed_pair_elem&lt;SimpleAllocator&lt;<span class="built_in">std</span>::__1::__tree_node&lt;<span class="built_in">std</span>::__1::__value_type&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">void</span> *&gt; &gt;, <span class="number">1</span>, <span class="literal">true</span>&gt; <span class="built_in">std</span>::__1::__compressed_pair_elem&lt;SimpleAllocator&lt;<span class="built_in">std</span>::__1::__tree_node&lt;<span class="built_in">std</span>::__1::__value_type&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">void</span> *&gt; &gt;, <span class="number">1</span>, <span class="literal">true</span>&gt;</span><br><span class="line"> +<span class="number">8</span> &lt; <span class="number">1</span>&gt;         SimpleAllocator&lt;<span class="built_in">std</span>::__1::__tree_node&lt;<span class="built_in">std</span>::__1::__value_type&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">void</span> *&gt; &gt; SimpleAllocator&lt;<span class="built_in">std</span>::__1::__tree_node&lt;<span class="built_in">std</span>::__1::__value_type&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">void</span> *&gt; &gt;</span><br><span class="line"> +<span class="number">8</span> &lt; <span class="number">1</span>&gt;           <span class="built_in">std</span>::__1::allocator&lt;<span class="built_in">std</span>::__1::__tree_node&lt;<span class="built_in">std</span>::__1::__value_type&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">void</span> *&gt; &gt; <span class="built_in">std</span>::__1::allocator&lt;<span class="built_in">std</span>::__1::__tree_node&lt;<span class="built_in">std</span>::__1::__value_type&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">void</span> *&gt; &gt;</span><br><span class="line"> +<span class="number">16</span> &lt; <span class="number">8</span>&gt;     <span class="built_in">std</span>::__1::__compressed_pair&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="built_in">std</span>::__1::__map_value_compare&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::__1::__value_type&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="built_in">std</span>::__1::less&lt;<span class="keyword">int</span>&gt;, <span class="literal">true</span>&gt; &gt; __pair3_</span><br><span class="line"> +<span class="number">16</span> &lt; <span class="number">8</span>&gt;       <span class="built_in">std</span>::__1::__compressed_pair_elem&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="number">0</span>, <span class="literal">false</span>&gt; <span class="built_in">std</span>::__1::__compressed_pair_elem&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="number">0</span>, <span class="literal">false</span>&gt;</span><br><span class="line"> +<span class="number">16</span> &lt; <span class="number">8</span>&gt;        <span class="keyword">unsigned</span> <span class="keyword">long</span> __value_</span><br><span class="line"> +<span class="number">16</span> &lt; <span class="number">1</span>&gt;       <span class="built_in">std</span>::__1::__compressed_pair_elem&lt;<span class="built_in">std</span>::__1::__map_value_compare&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::__1::__value_type&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="built_in">std</span>::__1::less&lt;<span class="keyword">int</span>&gt;, <span class="literal">true</span>&gt;, <span class="number">1</span>, <span class="literal">true</span>&gt; <span class="built_in">std</span>::__1::__compressed_pair_elem&lt;<span class="built_in">std</span>::__1::__map_value_compare&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::__1::__value_type&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="built_in">std</span>::__1::less&lt;<span class="keyword">int</span>&gt;, <span class="literal">true</span>&gt;, <span class="number">1</span>, <span class="literal">true</span>&gt;</span><br><span class="line"> +<span class="number">16</span> &lt; <span class="number">1</span>&gt;         <span class="built_in">std</span>::__1::__map_value_compare&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::__1::__value_type&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="built_in">std</span>::__1::less&lt;<span class="keyword">int</span>&gt;, <span class="literal">true</span>&gt; <span class="built_in">std</span>::__1::__map_value_compare&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::__1::__value_type&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="built_in">std</span>::__1::less&lt;<span class="keyword">int</span>&gt;, <span class="literal">true</span>&gt;</span><br><span class="line"> +<span class="number">16</span> &lt; <span class="number">1</span>&gt;           <span class="built_in">std</span>::__1::less&lt;<span class="keyword">int</span>&gt; <span class="built_in">std</span>::__1::less&lt;<span class="keyword">int</span>&gt;</span><br><span class="line"> +<span class="number">16</span> &lt; <span class="number">1</span>&gt;             <span class="built_in">std</span>::__1::binary_function&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">bool</span>&gt; <span class="built_in">std</span>::__1::binary_function&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">bool</span>&gt;</span><br><span class="line">Total byte size: <span class="number">24</span></span><br><span class="line">Total pad bytes: <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>Итог, 24 байта на стеке. Плюс, что интереснее, можно посмотреть, сколько занимает каждая нода в куче.<br>Напрямую сама нода спрятана от программиста, но можно написать код аллокатора, который может засечь размер:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SimpleAllocator</span> :</span> <span class="keyword">private</span> <span class="built_in">std</span>::allocator&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">using</span> value_type = T;</span><br><span class="line">	<span class="keyword">using</span> pointer = <span class="keyword">typename</span> <span class="built_in">std</span>::allocator&lt;T&gt;::pointer;</span><br><span class="line">	<span class="keyword">using</span> size_type = <span class="keyword">typename</span> <span class="built_in">std</span>::allocator&lt;T&gt;::size_type;</span><br><span class="line">	<span class="function">pointer <span class="title">allocate</span><span class="params">(size_type n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Allocator sizeof(T)=="</span> &lt;&lt; <span class="keyword">sizeof</span>(T) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">std</span>::allocator&lt;T&gt;::allocate(n);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(pointer p, size_type n)</span></span></span><br><span class="line"><span class="function">	</span>&#123; <span class="keyword">return</span> <span class="built_in">std</span>::allocator&lt;T&gt;::deallocate(p, n); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="built_in">std</span>::less&lt;<span class="keyword">int</span>&gt;, SimpleAllocator&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">const</span> <span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt;&gt; aaa;</span><br><span class="line">aaa[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Allocator sizeof(T)==40 bytes</span></span><br></pre></td></tr></table></figure>
<p>Или запросить у скрипта нужную структуру данных (название структуры можно узнать из вывода предыдущего запроса:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(lldb) layout <span class="string">"std::__1::__tree_node&lt;std::__1::__value_type&lt;int, int&gt;, void *&gt;"</span></span><br><span class="line"> +<span class="number">0</span> &lt; <span class="number">40</span>&gt; <span class="built_in">std</span>::__1::__tree_node&lt;<span class="built_in">std</span>::__1::__value_type&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">void</span> *&gt;</span><br><span class="line"> +<span class="number">0</span> &lt; <span class="number">32</span>&gt;   <span class="built_in">std</span>::__1::__tree_node_base&lt;<span class="keyword">void</span> *&gt; <span class="built_in">std</span>::__1::__tree_node_base&lt;<span class="keyword">void</span> *&gt;</span><br><span class="line"> +<span class="number">0</span> &lt; <span class="number">8</span>&gt;     <span class="built_in">std</span>::__1::__tree_node_base_types&lt;<span class="keyword">void</span> *&gt;::__end_node_type <span class="built_in">std</span>::__1::__tree_node_base_types&lt;<span class="keyword">void</span> *&gt;::__end_node_type</span><br><span class="line"> +<span class="number">0</span> &lt; <span class="number">8</span>&gt;      <span class="built_in">std</span>::__1::__tree_end_node&lt;<span class="built_in">std</span>::__1::__tree_node_base&lt;<span class="keyword">void</span> *&gt; *&gt;::pointer __left_</span><br><span class="line"> +<span class="number">8</span> &lt; <span class="number">8</span>&gt;    <span class="built_in">std</span>::__1::__tree_node_base&lt;<span class="keyword">void</span> *&gt;::pointer __right_</span><br><span class="line"> +<span class="number">16</span> &lt; <span class="number">8</span>&gt;    <span class="built_in">std</span>::__1::__tree_node_base&lt;<span class="keyword">void</span> *&gt;::__parent_pointer __parent_</span><br><span class="line"> +<span class="number">24</span> &lt; <span class="number">1</span>&gt;    <span class="keyword">bool</span> __is_black_</span><br><span class="line"> +<span class="number">25</span> &lt; <span class="number">3</span>&gt;  &lt;PADDING: <span class="number">3</span> bytes&gt;</span><br><span class="line"> +<span class="number">28</span> &lt; <span class="number">8</span>&gt;   <span class="built_in">std</span>::__1::__tree_node&lt;<span class="built_in">std</span>::__1::__value_type&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">void</span> *&gt;::__node_value_type __value_</span><br><span class="line"> +<span class="number">28</span> &lt; <span class="number">8</span>&gt;     <span class="built_in">std</span>::__1::__value_type&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::value_type __cc</span><br><span class="line"> +<span class="number">28</span> &lt; <span class="number">4</span>&gt;      <span class="keyword">const</span> <span class="keyword">int</span> first</span><br><span class="line"> +<span class="number">32</span> &lt; <span class="number">4</span>&gt;      <span class="keyword">int</span> second</span><br><span class="line"> +<span class="number">36</span> &lt; <span class="number">4</span>&gt;  &lt;PADDING: <span class="number">4</span> bytes&gt;</span><br><span class="line">Total byte size: <span class="number">40</span></span><br><span class="line">Total pad bytes: <span class="number">7</span></span><br><span class="line">Padding percentage: <span class="number">17.50</span> %</span><br></pre></td></tr></table></figure>
<p>Каждая нода красно-чёрного дерева пар из двух 32-битных целых занимает 40 байт - 3 указателя  (на родителя, левую и правую ноды), один флаг (красная/чёрная нода), выровненный на 8 байт, ну и само значение ноды - пара из двух целых 8 байт:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> * __left_, __right_, __parent_; <span class="comment">//24 bytes</span></span><br><span class="line"><span class="keyword">bool</span> __black_;                       <span class="comment">//1 bytes</span></span><br><span class="line"><span class="keyword">char</span> padding[<span class="number">3</span>];                     <span class="comment">//3 bytes padding</span></span><br><span class="line"><span class="built_in">std</span>::pair&lt;<span class="keyword">const</span> <span class="keyword">int</span>, <span class="keyword">int</span>&gt; __value_;  <span class="comment">//8 bytes</span></span><br><span class="line"><span class="keyword">char</span> padding[<span class="number">4</span>];                     <span class="comment">//4 bytes paddding</span></span><br></pre></td></tr></table></figure></p>
<p>(попробуйте найти эти данные, читая код <code>map.h/tree.h</code>)</p>
<p>Для сравнения - положив пары целых в отсортированный <code>std::vector</code>, можно полностью избавиться от лишних данных (<a href="https://cpp-optimizations.netlify.app/dont_need_map/" target="_blank" rel="noopener">бенчмарк результатов</a>).</p>
<p>С плагином можно смотреть в получающуюся структуру класса в памяти для загруженного приложения в любой момент из любой среды разработки или просто из консоли, <code>LLDB</code> умеет загружать данные как из DWARF-секций, так и из PDB-базы Visual Studio.</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script></div></article><div class="pagination"><a class="pagination__link pagination__prev" href="/blog/2701222076/">Позже</a><a class="pagination__link pagination__next" href="/blog/854775037/">Раньше</a></div></main><footer class="footer metadata"><p class="footer__text">© 2024 spiiin</p><p class="footer__text">Powered by <a class="footer__text__link" href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a class="footer__text__link" href="https://pages.github.com/" target="_blank">Github Page</a></p></footer></div></body></html>