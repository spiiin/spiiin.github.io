<!DOCTYPE html><html lang="ru"><head><meta charset="UTF-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Spiiin's blog | Рандомные мысли про функциональные языки программирования</title><meta name="description" content=""><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=PT+Serif&amp;display=swap"><link rel="stylesheet" href="/css/highlights/darkula.css"><link rel="stylesheet" href="/css/main.css"><link rel="search" type="application/opensearchdescription+xml" href="http://spiiin.github.io/atom.xml" title="Spiiin's blog"><script>(function (i, s, o, g, r, a, m) {
  i['GoogleAnalyticsObject'] = r;
  i[r] = i[r] || function () {
    (i[r].q = i[r].q || []).push(arguments)
  }, i[r].l = 1 * new Date();
  a = s.createElement(o),
    m = s.getElementsByTagName(o)[0];
  a.async = 1;
  a.src = g;
  m.parentNode.insertBefore(a, m)
})(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');
ga('create', 'UA-00000000-0', 'auto');
ga('send', 'pageview');</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-shiki-plugin@latest/lib/codeblock.css">
<style>:root{--hl-color:#abb2bf;--hl-bg:#282c34;--hltools-bg:#21252b;--hltools-color:#bbbbbc;--hlnumber-bg:#282c34;--hlnumber-color:#495162;--hlscrollbar-bg:#373c47;--hlexpand-bg:linear-gradient(180deg,rgba(40,44,52,0.1),rgba(40,44,52,0.9))}</style><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Spiiin's blog" type="application/atom+xml">
</head><body><div class="container"><header class="main-header"><h1 class="main-header__title uplize"><a class="main-header__title__link" href="/"><img class="header-image" src="/images/favicon.png" width="36" height="36">Spiiin's blog</a></h1><nav class="main-header__nav"><ul class="main-nav"><li class="main-nav__list"><a class="main-nav__list__link" href="/" target="_self">HOME</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/archives/" target="_self">ARCHIVE</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/tags/meta" target="_self">TAGS</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/blog/1" target="_self">ABOUT</a></li></ul></nav></header><main class="container__wrapper"><div class="pagination"><a class="pagination__link pagination__next" href="/blog/4269339516/">Раньше</a></div><article class="article post"><h3 class="article__title">Рандомные мысли про функциональные языки программирования</h3><div class="article__date metadata"><div class="post-info">2024/12/18</div></div><div class="article__tags metadata">Tags:
<a class="article__tags__link metadata" href="/tags/dev-method/">dev_method</a><a class="article__tags__link metadata" href="/tags/fsharp/">fsharp</a></div><div class="article__body"><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Решил поучаствовать в <a target="_blank" rel="noopener" href="https://adventofcode.com/2024">AdventOfCode</a> на <a target="_blank" rel="noopener" href="https://github.com/spiiin/advent_of_code">F#</a> (<a target="_blank" rel="noopener" href="https://adventofcode.com/2024/leaderboard/private/view/393584">лидерборд</a>). Не помню откуда, но знаю синтаксис ML (кажется когда-то на F# 2.0 смотрел), так что только немного прочитал про язык в общем, и поставил себе условие не скатываться в <code>let mutable x</code>, а писать в функциональном стиле. Немного заметок по ходу.</p>
<div class="toc">

<!-- toc -->
<ul>
<li><a href="#derevya-iz-dannyh-i-koda">Деревья из данных и кода</a></li>
<li><a href="#spiski-iz-dannyh-i-koda">Списки из данных и кода</a></li>
<li><a href="#cherepashki-i-sintonnost">Черепашки и синтонность</a></li>
<li><a href="#pro-kod-kak-sposob-rasshireniya-sushchestvuyushchih-sistem">Про код как способ расширения существующих систем</a></li>
</ul>
<!-- tocstop -->
</div>

<h2><span id="derevya-iz-dannyh-i-koda">Деревья из данных и кода</span><a href="#derevya-iz-dannyh-i-koda" class="header-anchor">#</a></h2><p>Программист смотрит на код как на текст, но тулзам и компиляторам удобнее иметь более высокоуровневое представление. Для них программа — это дерево выражений (AST). AST можно рассматривать как <code>model</code> в MVC, тогда как её текст - это <code>view/controller</code>.</p>
<p>При этом, если программист пишет программы, которые обрабатывают код  (плагины к ide/компилятору, кодогенераторы, синтаксические макросы, парсеры) — то он должен знать не только синтаксис своего языка, но и работать с его синтаксическим деревом (если и программа, и код, который она обрабатывает на одном языке).</p>
<p><strong>Такая работа будет проще, если:</strong></p>
<ul>
<li>синтаксис программы удобно проецировать на генерируемый AST (код программы можно мысленно легко отобразить на дерево, и обратно). То есть синтаксис является не только вопросом вкуса, но и способом уменьшить ментальные усилия при программировании</li>
<li>язык предлагает удобное представления для кода обработки деревьев (в основном — что умеет и как расширяется pattern matching)</li>
<li>язык предлагает средства трансформации своего собственного представления из одного в другое (цитирование, синтаксические макросы), чтобы изменять собсвенный синтаксический view.</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://graydon.livejournal.com/256533.html">“What next?”</a> - автор rust об идеях в языках программирования. <em>Open implementations</em> — дизайн языка с предпосылкой о том, чтобы компилятор (или программист) был в любой момент “на связи” с программой ведёт к определённой эстетике языка, оказывает давление (в сторону программируемости) на синтаксис, систему типов, модель компиляции (<em>проще, единообразнее, программируемо</em>)</p>
<p><a target="_blank" rel="noopener" href="https://parentheticallyspeaking.org/articles/bicameral-not-homoiconic/">Bicameral, Not Homoiconic</a> — о Lispy-языках и идее <code>Syntax is a view</code>. Языки могут разделять <em>философию синтаксиса</em>, но отличаться в деталях.</p>
<p><em>S-выражения удобны для представления синтаксического дерева, но не всегда удобны для человека. Имхо, философия синтаксиса ML намного приятнее. Хотя некоторые не любят ни скобок, ни значащих отступов. Но синтаксис — это только “фронтэнд” языка, “бекэнд” — это то, как компилятор/интерпретатор может обрабатывать построенное синтаксическое дерево. От синтаксиса эта не зависит почти никак</em>.</p>
<p><a target="_blank" rel="noopener" href="https://d22yoqkt46k26p.cloudfront.net/graydon/talks/CompilerTalk-2019.pdf">21 compilers and 3 orders of magnitude in 60 minutes</a> - ML designed as implementation language for symbolic logic (expression-tree wrangling) system</p>
<p>Данные тоже удобно представлять как дерево (<code>json/xml/yaml/toml/cue/etc</code>) — узлы могут быть атомами, либо деревьями данных. Форматы для описания данных обычно не предполагают описания правил интерпретации этих данных.</p>
<p>Но эволюция систем, которые используют описания данных в таких упрощенных форматах,  приводит их к тому, чтобы начать хранить внутри данных код. Причины могут быть разными:</p>
<ul>
<li>уменьшение избыточности описания (в качестве примера подойдут всякие текстовые template-движки, или какие-нибудь системы анимации типа <a target="_blank" rel="noopener" href="https://youtu.be/GlQJvuU7Z_8?si=iKBr9m4ELN0id2wC&amp;t=1498">Nodezator</a>) </li>
<li>необходимость задания связей между различными частями одного описания, или с внешними данными/кодом (валидации значений, взаимо-зависимости, реактивная связь с внешним источником, пользовательские типы объектов с уникальными правилами конфигурации)</li>
<li>желание описать поведение данных во времени</li>
<li>необходимость сложной конфигурации с помощью данных (например xml в ant или spring)</li>
</ul>
<p>Причём выбор способа представления такого кода внутри данных — сложная задача. С одной стороны, не хочется опускаться до описания кода строками (ведь почти точно нужен не какой-то посторонний код, а обрабатывающий эти данные). С другой стороны, добавлять полноценный ast для кода внутри данных выглядит овер-инжинирингом. В итоге создаются упрощенные микроязыки, которые постоянно требуют расширения. </p>
<p><em>В качестве примера можно погуглить недоумение обнаруживающих, что в WPF XAML отсутствует оператор <code>not</code></em></p>
<p><a target="_blank" rel="noopener" href="https://probablydance.com/2015/02/16/ideas-for-a-programming-language-part-3-no-shadow-worlds/">Ideas for a Programming Language Part 3: No Shadow Worlds</a> — микроязыки как теневые разрастающиеся миры</p>
<p>Хорошие примеры “данных с внедрённым кодом” — <code>табличные редакторы и SQL</code>.</p>
<h2><span id="spiski-iz-dannyh-i-koda">Списки из данных и кода</span><a href="#spiski-iz-dannyh-i-koda" class="header-anchor">#</a></h2><p>Код трансформации списков часто можно разделить на две части:</p>
<ul>
<li>как обрабатывается элемент списка,</li>
<li>как соединяются обработанные коллекции вместе.</li>
</ul>
<p><em>код который на императивном языке выглядел бы линейно, тут разделяется на 2 части, соединение коллекций друг с другом — оригами-программирование. При этом если встречается линейный код, обёрнутый в вычислительное выражение, то скорее всего между строк спрятано что-то монадное, и вычисления будут далеко нелинейными</em></p>
<p>Синтаксис может либо способствовать визуальному/мысленному отделению этих потоков друг от друга, либо мешать.</p>
<p><a target="_blank" rel="noopener" href="https://probablydance.com/2015/06/16/ideas-for-a-programming-language-part-4-reactive-programming/">Ideas for a Programming Language Part 4: Reactive Programming</a> - о синтаксисе для обработки списков.</p>
<figure class="shiki cpp"><div class="codeblock"><div class="code"><pre class="shiki dracula"><code><span class="line"><span style="color: #F8F8F2">std</span><span style="color: #FF79C6">::</span><span style="color: #50FA7B">transform</span><span style="color: #F8F8F2">(vec.</span><span style="color: #50FA7B">begin</span><span style="color: #F8F8F2">(), vec.</span><span style="color: #50FA7B">end</span><span style="color: #F8F8F2">(), std</span><span style="color: #FF79C6">::</span><span style="color: #50FA7B">back_inserter</span><span style="color: #F8F8F2">(ovec), [](</span><span style="color: #FF79C6">int</span><span style="color: #F8F8F2"> </span><span style="color: #FFB86C; font-style: italic">a</span><span style="color: #F8F8F2">){ </span><span style="color: #FF79C6">return</span><span style="color: #F8F8F2"> a </span><span style="color: #FF79C6">+</span><span style="color: #F8F8F2"> </span><span style="color: #BD93F9">5</span><span style="color: #F8F8F2">; });</span></span>
<span class="line"><span style="color: #F8F8F2">ovec.</span><span style="color: #50FA7B">erase</span><span style="color: #F8F8F2">(std</span><span style="color: #FF79C6">::</span><span style="color: #50FA7B">remove_if</span><span style="color: #F8F8F2">(ovec.</span><span style="color: #50FA7B">begin</span><span style="color: #F8F8F2">(), ovec.</span><span style="color: #50FA7B">end</span><span style="color: #F8F8F2">(), [](</span><span style="color: #FF79C6">int</span><span style="color: #F8F8F2"> </span><span style="color: #FFB86C; font-style: italic">a</span><span style="color: #F8F8F2">){ </span><span style="color: #FF79C6">return</span><span style="color: #F8F8F2"> a </span><span style="color: #FF79C6">&gt;</span><span style="color: #F8F8F2"> </span><span style="color: #BD93F9">10</span><span style="color: #F8F8F2">; }), ovec.</span><span style="color: #50FA7B">end</span><span style="color: #F8F8F2">());</span></span>
<span class="line"><span style="color: #6272A4">//сложно визуально отделить поток преобразований элемента (a -&gt; a+5) и (a -&gt; a&gt;10) от потока транформаций</span></span></code></pre></div></div></figure>
<ul>
<li><a href="/blog/2550823652/" title="Итераторы, колстеки, корутины">Итераторы, колстеки, корутины</a> - этот же синтаксический узор встречается не только в обработке списков, но и любых коллекций</li>
</ul>
<p>В ML-синтаксисе без лишних скобок выглядит так:<br><figure class="shiki fsharp"><div class="codeblock"><div class="code"><pre class="shiki dracula"><code><span class="line"><span style="color: #FF79C6">let</span><span style="color: #F8F8F2"> ovec </span><span style="color: #FF79C6">=</span><span style="color: #F8F8F2"> </span></span>
<span class="line"><span style="color: #F8F8F2">	vec</span></span>
<span class="line"><span style="color: #F8F8F2">	</span><span style="color: #FF79C6">|&gt;</span><span style="color: #F8F8F2"> List.map </span><span style="color: #FF79C6">(fun</span><span style="color: #FFB86C; font-style: italic"> a </span><span style="color: #FF79C6">-&gt;</span><span style="color: #F8F8F2"> a </span><span style="color: #FF79C6">+</span><span style="color: #F8F8F2"> </span><span style="color: #BD93F9">5</span><span style="color: #FF79C6">)</span><span style="color: #F8F8F2"> </span><span style="color: #6272A4">//or ((+) 5)</span></span>
<span class="line"><span style="color: #F8F8F2">	</span><span style="color: #FF79C6">|&gt;</span><span style="color: #F8F8F2"> List.filter </span><span style="color: #FF79C6">(fun</span><span style="color: #FFB86C; font-style: italic"> a </span><span style="color: #FF79C6">-&gt;</span><span style="color: #F8F8F2"> a </span><span style="color: #FF79C6">&lt;=</span><span style="color: #F8F8F2"> </span><span style="color: #BD93F9">10</span><span style="color: #FF79C6">)</span><span style="color: #F8F8F2"> </span><span style="color: #6272A4">//or (&gt;=) 10)</span></span>
<span class="line"><span style="color: #6272A4">//or |&gt; List.choose (fun a -&gt; if a + 5 &lt;= 10 then Some(a + 5) else None)</span></span>
<span class="line"><span style="color: #6272A4">//or |&gt; List.collect (fun a -&gt; if a + 5 &lt;= 10 then [a + 5] else [])</span></span></code></pre></div></div></figure><br>Здесь легче отделить отделить поток оригами-функций для коллекций <code>map |&gt; filter</code> от функций преобразования элемента.<br><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=6mTbuzafcII">Transducers by Rich Hickey</a> - Рич Хики от том, что имя коллекции (<code>List.</code>) перед именами функций в принципе можно было бы и выбросить.</p>
<p><em>В таком стиле необходимо отлично ориентироваться в наборе этих оригами-функций, поиск нужного иногда напоминает поиск подходящего кусочка пазла. Причём подходить могут несколько, но подобрать сходу какие именно, сложно. Порой даже забываешь, что Хиндли-Милнер твои друзья. Но в принципе, доверить поиск соединителей можно ИИ, главное, не забыть, что кроме соответвия типов, функции могут отличаться по поведению и выбрать из нескольких предложенных подходящую по поведению.</em></p>
<p><a target="_blank" rel="noopener" href="https://probablydance.com/2016/02/27/functional-programming-is-not-popular-because-it-is-weird/">Functional Programming Is Not Popular Because It Is Weird</a></p>
<p>Из плюсов такого подхода — часть вычислений можно распараллелить просто добавив в поток “оригами-функций” распараллеливание<br><figure class="shiki fsharp"><div class="codeblock"><div class="code"><pre class="shiki dracula"><code><span class="line"><span style="color: #FF79C6">let</span><span style="color: #F8F8F2"> more </span><span style="color: #FF79C6">=</span></span>
<span class="line"><span style="color: #F8F8F2">	sortedPaths</span></span>
<span class="line"><span style="color: #F8F8F2">	</span><span style="color: #FF79C6">|&gt;</span><span style="color: #F8F8F2"> PSeq.withDegreeOfParallelism Environment.ProcessorCount </span><span style="color: #6272A4">//обрабатываем параллельно</span></span>
<span class="line"><span style="color: #F8F8F2">	</span><span style="color: #FF79C6">|&gt;</span><span style="color: #F8F8F2"> PSeq.collect </span><span style="color: #FF79C6">(fun</span><span style="color: #FFB86C; font-style: italic"> path </span><span style="color: #FF79C6">-&gt;</span></span>
<span class="line"><span style="color: #F8F8F2">		moves</span></span>
<span class="line"><span style="color: #F8F8F2">		</span><span style="color: #FF79C6">|&gt;</span><span style="color: #F8F8F2"> Seq.map </span><span style="color: #FF79C6">(fun</span><span style="color: #FFB86C; font-style: italic"> move </span><span style="color: #FF79C6">-&gt;</span><span style="color: #F8F8F2"> path.Extend</span><span style="color: #FF79C6">(</span><span style="color: #F8F8F2">move</span><span style="color: #FF79C6">,</span><span style="color: #F8F8F2"> endState</span><span style="color: #FF79C6">,</span><span style="color: #F8F8F2"> rate</span><span style="color: #FF79C6">))</span></span>
<span class="line"><span style="color: #F8F8F2">		</span><span style="color: #FF79C6">|&gt;</span><span style="color: #F8F8F2"> Seq.filter filterPath</span></span>
<span class="line"><span style="color: #F8F8F2">	</span><span style="color: #FF79C6">)</span></span>
<span class="line"><span style="color: #F8F8F2">	</span><span style="color: #FF79C6">|&gt;</span><span style="color: #F8F8F2"> Seq.toList</span></span></code></pre></div></div></figure></p>
<p><a target="_blank" rel="noopener" href="http://venge.net/graydon/talks/VectorizedInterpretersTalk-2023-05-12.pdf">Vectorized Interpreters</a> — про векторизированные интерпретаторы, в которых можно избежать прыжков между вызывающим/вызываемым кодом. Происходит сначала настройка путей выполнения кода, а затем вызов вычисления всего построенного выражения в нейтивном коде (в качестве примеров — <code>Numpy/R/Matlab</code>).</p>
<p>   <em>еще один отбитый вариант синтаксиса, берущий худшее из обоих миров (не видно ни 2 столбцов, ни императивности в теле лямбд) — записывать все операторы в строку: <code>ovec =: (&gt;. 10&amp;&lt;) @: (5&amp;+)&quot;0 vec</code></em></p>
<h2><span id="cherepashki-i-sintonnost">Черепашки и синтонность</span><a href="#cherepashki-i-sintonnost" class="header-anchor">#</a></h2><p><a target="_blank" rel="noopener" href="https://worrydream.com/LearnableProgramming/">Learnable Programming - Designing a programming system for understanding program</a> - статья Виктора Брата о том, как проектировать системы так, чтобы можно было понимать написанные в них программы. Традиционно относится к обучению программированию, но полезно для любых систем.</p>
<p><em>Брат и сам по себе крут, и часто ссылается на Алана Кея и Сеймура Пайперта</em></p>
<blockquote>
<p>Maybe we don’t need a silver bullet. We just need to take off our blindfolds to see where we’re firing.</p>
</blockquote>
<p>В статье приводится рекомендация книги <a target="_blank" rel="noopener" href="https://worrydream.com/refs/Papert_1980_-_Mindstorms,_1st_ed.pdf">Seymour Papert’s “Mindstorms”</a>, с описанием того, как проектировался и работает язык LOGO, и знаменитая черепашья графика в нём. Важное свойство черепашки — <strong><code>синтонность</code></strong> другим объектам.</p>
<p>“Если не знаешь, как нарисовать с помощью черепашки круг, представь себя черепашкой”. Даже ребёнок знает, как ходить по кругу, но не задумывается об алгоритме. Кроме того, более взрослый программист может не ходить по кругу, а моделировать работу черепашки с помощью листа бумаги и ручки. Компьютерная черепашка синтонна телу, или физическому роботу, который умеет выполнять те же команды. Но кроме этого она также синтонна математическому объекту, абстракции, с помощью которой можно понять принципы и приёмы программирования (аргументы, рекурсия, отладка), или дифференциальное исчисление. Черепашка позволяет развивать эмпанию так, чтобы было проще осваивать сложные концепции.</p>
<p><strong>В широком смысле, все доступные нам способы познания — это разделение объекта на части+пересборка, и эмпатия (имперсонификация)</strong> — <a target="_blank" rel="noopener" href="https://youtu.be/I8LbkfSSR58?si=OVQEC_tWjknqgALI&amp;t=2085">теория категорий 1.1: Мотивация и философия</a><br><em>(и эти навыки не обязательно коррелируют с умением решать логические задачки)</em></p>
<p>Проблема функциональных языков в том, что у них нет своей черепашки, развивающей нужную интуицию (<a target="_blank" rel="noopener" href="https://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/">1</a>, <a target="_blank" rel="noopener" href="https://fsharpforfunandprofit.com/posts/why-i-wont-be-writing-a-monad-tutorial/">2</a>) - <a target="_blank" rel="noopener" href="https://mbuffett.com/posts/all-tacit-knowledge/">Programming and Tacit Knowledge</a> Наиболее полезная абстракция, кажется — <strong><code>железнодорожные пути и паровозики с вагонами, в которых лежат данные</code></strong>.</p>
<h2><span id="pro-kod-kak-sposob-rasshireniya-sushchestvuyushchih-sistem">Про код как способ расширения существующих систем</span><a href="#pro-kod-kak-sposob-rasshireniya-sushchestvuyushchih-sistem" class="header-anchor">#</a></h2><p>Текстовый редактор может обращаться к структурам в AST, за данными для подсветки, рефакторинга или структурного редактирования. Если это нужно для интерактивного редактирования (т.е. всегда), то удобнее изменения дерева, а не строить его заново.</p>
<p><a target="_blank" rel="noopener" href="https://youtu.be/Jes3bD6P0To?si=0G4Ugppx-qcp9w6B&amp;t=957">Tree-sitter - a new parsing system for programming tools</a> by Max Brunsfeld - структурное выделение текста в редакторе.</p>
<p>Компилятор может иметь хуки для встраивания своих вычислений, чтобы (в порядке от простого к продвинутому):</p>
<ul>
<li>генерировать код — templates в С++</li>
<li>изменять код произвольным образом — синтаксические макросы</li>
<li>производить произвольные вычисления - <a target="_blank" rel="noopener" href="https://youtu.be/UTqZNujQOlA?si=37vNnAEI2fE13hBZ&amp;t=4755">Jai</a> или <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/dotnet/fsharp/tutorials/type-providers/">Type Providers</a> в F#.</li>
</ul>
<p>Если язык не проектировался с целью делать что-то во время компиляции, то встроить в него позже что-нибудь сложнее генерации кода будет сложно (и то, иногда парсинг кода проще сделать внешним препроцессором).</p>
<p>Метаинформация в коде может быть адресована не IDE/компилятору, а среде, в которой он будет выполняться — какие-нибудь <a target="_blank" rel="noopener" href="https://docs.godotengine.org/en/stable/tutorials/scripting/c_sharp/c_sharp_differences.html#onready-annotation">аннотации</a>  для редактора в Godot или Unity. Это вроде не требуют особого синтаксиса, кроме конвенций об именах (которые вообще-то по хорошему тоже нужно заставить проверять компилятор, а не внешний скрипт, или хуже, run-time среду).</p>
<p> Ну и, собственно, среда выполнения может уметь собирать из рантайм объектов, построенных с помощью этой метаинформации, другие составные объекты. Для построения помощью встроить скриптовый или визуальный язык (<code>Dataflow/Block/Event tables</code>), отличающийся от исходного языка. Или можно тащить в рантайм компилятор основого языка, если он не монструозный.</p>
<ul>
<li><a href="/blog/3414198781/" title="Визуальные языки программирования">Визуальные языки программирования</a></li>
<li><a href="/blog/3601773065/" title="Рандомные мысли про код, дизайн, C++ и геймдев">Рандомные мысли про код, дизайн, C++ и геймдев</a> — раздел про волны развития технологий. Более зрелый язык обрастает тулзами с способами связи его с внешними системами предметной области.</li>
</ul>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"Ov23liG1mZbiQOIdi91X","clientSecret":"e05812685eb741a752982b89dcf6f5b58dc10251","repo":"spiiin.github.io","owner":"spiiin","admin":["spiiin"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script></div></article><div class="pagination"><a class="pagination__link pagination__next" href="/blog/4269339516/">Раньше</a></div></main><footer class="footer metadata"><p class="footer__text">© 2024 spiiin</p><p class="footer__text">Powered by <a class="footer__text__link" href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a class="footer__text__link" href="https://pages.github.com/" target="_blank">Github Page</a></p></footer></div><!-- hexo injector body_end start -->
  <script>
  const CODE_CONFIG = {
    beautify: undefined,
    highlightCopy: undefined,
    highlightLang: undefined,
    highlightHeightLimit: undefined,
    isHighlightShrink: undefined,
    copy: {
      success: 'undefined',
      error: 'undefined',
      noSupport: 'undefined',
    }
  };
  console.log(
    `%c hexo-shiki-plugin %c v1.0.27 %c https://github.com/nova1751/hexo-shiki-plugin`,
    "color: #fff; background: #5f5f5f",
    "color: #fff; background: #80c8f8",
    ""
  );
  </script>
  <!-- hexo injector body_end end --></body></html>