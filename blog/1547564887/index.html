<!DOCTYPE html><html lang="ru"><head><meta charset="UTF-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Spiiin's blog | daScript macro</title><meta name="description" content="&lt;p&gt;&lt;a href=&quot;https://dascript.org/&quot;&gt;daScript&lt;/a&gt; - скриптовый язык для игр от Gaijin Entertaiment.&lt;/p&gt;
&lt;p&gt;После нескольких дней изучения понял, что испытываю интерес и хороший страх по отношению к этому языку. Такой, как если бы нашёл лазерную указку и решил поиграть с котом, но понял, что этой указкой можно легко резать металл. &lt;/p&gt;
&lt;p&gt;Гайдзины делают не замену &lt;code&gt;Lua&lt;/code&gt;, они делают замену &lt;code&gt;C++&lt;/code&gt;! Точнее даже, не “делают”, а практически “сделали”, язык сейчас находится в версии 0.2, но полноценно используется ими в продакшене в &lt;code&gt;Warthunder&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Доклад и документация акцентируют внимание на быстродействии языка и возможности серьёзных изменений без перезапуска игры, но только вскользь упоминают о мощных возможностях макросов. Так что я решил попробовать решить задачку, требующую их использования. Это моя первая программа на &lt;code&gt;daScript&lt;/code&gt;, после трёх дней изучения, так что где-то возможны и неизбежны косяки.&lt;/p&gt;"><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=PT+Serif&amp;display=swap"><link rel="stylesheet" href="/css/highlights/darkula.css"><link rel="stylesheet" href="/css/main.css"><link rel="search" type="application/opensearchdescription+xml" href="http://spiiin.github.io/atom.xml" title="Spiiin's blog"><script>(function (i, s, o, g, r, a, m) {
  i['GoogleAnalyticsObject'] = r;
  i[r] = i[r] || function () {
    (i[r].q = i[r].q || []).push(arguments)
  }, i[r].l = 1 * new Date();
  a = s.createElement(o),
    m = s.getElementsByTagName(o)[0];
  a.async = 1;
  a.src = g;
  m.parentNode.insertBefore(a, m)
})(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');
ga('create', 'UA-00000000-0', 'auto');
ga('send', 'pageview');</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-shiki-plugin@latest/lib/codeblock.css">
<style>:root{--hl-color:#abb2bf;--hl-bg:#282c34;--hltools-bg:#21252b;--hltools-color:#bbbbbc;--hlnumber-bg:#282c34;--hlnumber-color:#495162;--hlscrollbar-bg:#373c47;--hlexpand-bg:linear-gradient(180deg,rgba(40,44,52,0.1),rgba(40,44,52,0.9))}</style><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Spiiin's blog" type="application/atom+xml">
</head><body><div class="container"><header class="main-header"><h1 class="main-header__title uplize"><a class="main-header__title__link" href="/"><img class="header-image" src="/images/favicon.png" width="36" height="36">Spiiin's blog</a></h1><nav class="main-header__nav"><ul class="main-nav"><li class="main-nav__list"><a class="main-nav__list__link" href="/" target="_self">HOME</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/archives/" target="_self">ARCHIVE</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/tags/meta" target="_self">TAGS</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/blog/1" target="_self">ABOUT</a></li></ul></nav></header><main class="container__wrapper"><div class="pagination"><a class="pagination__link pagination__prev" href="/blog/4232971949/">Позже</a><a class="pagination__link pagination__next" href="/blog/1728194429/">Раньше</a></div><article class="article post"><h3 class="article__title">daScript macro</h3><div class="article__date metadata"><div class="post-info">2022/02/06</div></div><div class="article__tags metadata">Tags:
<a class="article__tags__link metadata" href="/tags/longread/">longread</a><a class="article__tags__link metadata" href="/tags/dascript/">dascript</a></div><div class="article__body"><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p><a target="_blank" rel="noopener" href="https://dascript.org/">daScript</a> - скриптовый язык для игр от Gaijin Entertaiment.</p>
<p>После нескольких дней изучения понял, что испытываю интерес и хороший страх по отношению к этому языку. Такой, как если бы нашёл лазерную указку и решил поиграть с котом, но понял, что этой указкой можно легко резать металл. </p>
<p>Гайдзины делают не замену <code>Lua</code>, они делают замену <code>C++</code>! Точнее даже, не “делают”, а практически “сделали”, язык сейчас находится в версии 0.2, но полноценно используется ими в продакшене в <code>Warthunder</code>.</p>
<p>Доклад и документация акцентируют внимание на быстродействии языка и возможности серьёзных изменений без перезапуска игры, но только вскользь упоминают о мощных возможностях макросов. Так что я решил попробовать решить задачку, требующую их использования. Это моя первая программа на <code>daScript</code>, после трёх дней изучения, так что где-то возможны и неизбежны косяки.</p>
<span id="more"></span>
<h2><span id="zadacha">Задача</span><a href="#zadacha" class="header-anchor">#</a></h2><p>В качестве задачи выбрал такую, которую было бы нетривиально или сложно решить на C++:</p>
<blockquote><ul>
<li>Подсказка компилятору аллоцировать блок данных для структуры в линейном блоке памяти без явного написания кода работы с указателями в самой структуре</li>
</ul>
</blockquote>
<a href="/blog/1728194429/" title="С++ в геймдеве">C++ в геймдеве</a>
<p>Формулировка проблемы из видео про язык <a target="_blank" rel="noopener" href="https://youtu.be/TH9VCN6UkyQ?t=4047">Jai</a> — пример кода, в котором тривиальное объявление медленнее сложного, но быстрого.</p>
<figure class="shiki c++"><div class="codeblock"><div class="code"><pre class="shiki slack-dark"><code><span class="line"><span style="color: #6A9955">//Тривиальное объявление меша для моделей</span></span>
<span class="line"><span style="color: #6A9955">//  2 аллокации, возможно в разных местах памяти</span></span>
<span class="line"><span style="color: #569CD6">struct</span><span style="color: #E6E6E6"> </span><span style="color: #4EC9B0">Mesh</span><span style="color: #E6E6E6"> {</span></span>
<span class="line"><span style="color: #E6E6E6">    std::vector</span><span style="color: #D4D4D4">&lt;</span><span style="color: #E6E6E6">Vector3</span><span style="color: #D4D4D4">&gt;</span><span style="color: #E6E6E6"> positions;</span></span>
<span class="line"><span style="color: #E6E6E6">    std::vector</span><span style="color: #D4D4D4">&lt;</span><span style="color: #569CD6">int</span><span style="color: #D4D4D4">&gt;</span><span style="color: #E6E6E6"> indexes;</span></span>
<span class="line"><span style="color: #E6E6E6">}</span></span></code></pre></div></div></figure>
<figure class="shiki c++"><div class="codeblock"><div class="code"><pre class="shiki slack-dark"><code><span class="line"><span style="color: #6A9955">//Более реальный вариант для продакшена</span></span>
<span class="line"><span style="color: #6A9955">//  синтаксис сильно отличается от тривиального варианта </span></span>
<span class="line"><span style="color: #569CD6">struct</span><span style="color: #E6E6E6"> </span><span style="color: #4EC9B0">Mesh</span><span style="color: #E6E6E6"> {</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #569CD6">void</span><span style="color: #D4D4D4">*</span><span style="color: #E6E6E6"> memblock </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #569CD6">nullptr</span><span style="color: #E6E6E6">;</span></span>
<span class="line"><span style="color: #E6E6E6">    Vector3</span><span style="color: #D4D4D4">*</span><span style="color: #E6E6E6"> positions </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #569CD6">nullptr</span><span style="color: #E6E6E6">;</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #569CD6">int</span><span style="color: #D4D4D4">*</span><span style="color: #E6E6E6"> indices </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #569CD6">nullptr</span><span style="color: #E6E6E6">;</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #569CD6">int</span><span style="color: #E6E6E6"> num_vertices </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #B5CEA8">0</span><span style="color: #E6E6E6">;</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #569CD6">int</span><span style="color: #E6E6E6"> num_indices </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #B5CEA8">0</span><span style="color: #E6E6E6">;</span></span>
<span class="line"><span style="color: #E6E6E6">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #569CD6">int</span><span style="color: #E6E6E6"> positions_size </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> num_vertices </span><span style="color: #D4D4D4">*</span><span style="color: #E6E6E6"> </span><span style="color: #569CD6">sizeof</span><span style="color: #E6E6E6"> (</span><span style="color: #9CDCFE">positions</span><span style="color: #E6E6E6">[</span><span style="color: #B5CEA8">0</span><span style="color: #E6E6E6">]);</span></span>
<span class="line"><span style="color: #569CD6">int</span><span style="color: #E6E6E6"> indices_size </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> num_indices </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #569CD6">sizeof</span><span style="color: #E6E6E6">(</span><span style="color: #9CDCFE">indices</span><span style="color: #E6E6E6">[</span><span style="color: #B5CEA8">0</span><span style="color: #E6E6E6">]);</span></span>
<span class="line"><span style="color: #9CDCFE">mesh</span><span style="color: #E6E6E6">-&gt;</span><span style="color: #9CDCFE">memory_block</span><span style="color: #E6E6E6"> </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #569CD6">new</span><span style="color: #E6E6E6"> </span><span style="color: #569CD6">char</span><span style="color: #E6E6E6">[positions_size </span><span style="color: #D4D4D4">+</span><span style="color: #E6E6E6"> indices_size];</span></span>
<span class="line"><span style="color: #9CDCFE">mesh</span><span style="color: #E6E6E6">-&gt;</span><span style="color: #9CDCFE">positions</span><span style="color: #E6E6E6"> </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> (Vector3</span><span style="color: #D4D4D4">*</span><span style="color: #E6E6E6">)</span><span style="color: #9CDCFE">mesh</span><span style="color: #E6E6E6">-&gt;</span><span style="color: #9CDCFE">memblock</span><span style="color: #E6E6E6">;</span></span>
<span class="line"><span style="color: #9CDCFE">mesh</span><span style="color: #E6E6E6">-&gt;</span><span style="color: #9CDCFE">indices</span><span style="color: #E6E6E6"> </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> (</span><span style="color: #569CD6">int</span><span style="color: #D4D4D4">*</span><span style="color: #E6E6E6">)(</span><span style="color: #9CDCFE">mesh</span><span style="color: #E6E6E6">-&gt;</span><span style="color: #9CDCFE">memblock</span><span style="color: #E6E6E6"> </span><span style="color: #D4D4D4">+</span><span style="color: #E6E6E6"> positions_size);</span></span></code></pre></div></div></figure>
<p>Второй вариант требует написания рутинного кода вручную при добавлении новых полей в структуру, а также ёмкий в плане количества переписывания кода из существующего. Если захочется переделать в таком стиле для ускорения несколько структур — для каждой потребуется ручная работа. Из-за этого большинство структур навсегда останутся описанными в первой, медленной форме.</p>
<p>Джонатан Блоу предлагает в качестве решения проблемы вариант синтаксиса своего языка, который позволит легко “переключить” структуру из медленной формы в быструю.</p>
<figure class="shiki c++"><div class="codeblock"><div class="code"><pre class="shiki slack-dark"><code><span class="line"><span style="color: #569CD6">struct</span><span style="color: #E6E6E6"> </span><span style="color: #4EC9B0">Mesh</span><span style="color: #E6E6E6"> {</span></span>
<span class="line"><span style="color: #E6E6E6">    Vector3 []</span><span style="color: #D4D4D4">!</span><span style="color: #E6E6E6"> positions;</span><span style="color: #6A9955">           //[]! - семантика для указателя на память, которую должна выделить и освободить сама структура</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #569CD6">int</span><span style="color: #E6E6E6">[]</span><span style="color: #D4D4D4">!</span><span style="color: #E6E6E6"> indices; @joint positions</span><span style="color: #6A9955"> //@joint - семантика для того, что попросить компилятор</span></span>
<span class="line"><span style="color: #6A9955">                                     //    расположить данные в памяти одним блоком</span></span>
<span class="line"><span style="color: #E6E6E6">}</span></span></code></pre></div></div></figure>
<p>Я захотел попробовать реализовать подобную подсказку компилятору daScript с помощью макросов.</p>
<h2><span id="dokumentaciya-k-dascript">Документация к daScript</span><a href="#dokumentaciya-k-dascript" class="header-anchor">#</a></h2><p>Порядок изучения информации про язык:</p>
<ul>
<li>Доклад Антона Юдинцева<style>.embed-container {
    position: relative;
    padding-bottom: 56.25%;
    height: 0;
    overflow: hidden;
    max-width: 100%;
  }
  .embed-container iframe, .embed-container object, .embed-container embed {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
  }
  </style>

<div class="embed-container"><iframe src="https://www.youtube.com/embed/IvHGczF6Go0" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></li>
<li>Инфа с оффициального сайта и <a target="_blank" rel="noopener" href="https://dascript.org/doc/index.html">документация</a></li>
<li><a target="_blank" rel="noopener" href="https://youtu.be/inGb9R1NowY">Live Stream Coding on daScript - Breakoid</a> - стрим с примером реализации арканоида, можно посмотреть на макросы и синтаксис системы ECS, реализованной с помощью макросов</li>
<li><a target="_blank" rel="noopener" href="https://github.com/GaijinEntertainment/daScript/tree/073bc29145207b39180069ae60f00ed43fad6ea7/examples/tutorial">Серия туториалов</a> - примеры привязки скриптов к C++, Ahead-of-Time компиляции, реализация генерации кода через cmake, архитектура игрового объекта с возможностью hot-reloading кода из скриптов.</li>
<li><a target="_blank" rel="noopener" href="https://github.com/GaijinEntertainment/daScript/tree/073bc29145207b39180069ae60f00ed43fad6ea7/examples/test/misc">Больше примеров кода</a>, в том числе несколько макросов</li>
<li><a target="_blank" rel="noopener" href="https://github.com/GaijinEntertainment/daScript/tree/073bc29145207b39180069ae60f00ed43fad6ea7/daslib">Стандартная библиотека</a> языка и <a target="_blank" rel="noopener" href="https://github.com/GaijinEntertainment/daScript/tree/073bc29145207b39180069ae60f00ed43fad6ea7/modules">модули</a>, можно использовать поиск по коду с гитхаба, чтобы найти пример использования той или иной фичи</li>
</ul>
<p>Макросы являются достаточно сложной темой, и освещены в документации daScript-а достаточно кратко, поэтому приведу несколько ссылок на туториалы из других языков:<br><a target="_blank" rel="noopener" href="https://www.greghendershott.com/fear-of-macros/">Fear of macros</a> - Racket<br><a target="_blank" rel="noopener" href="https://rsdn.org/article/nemerle/NemerleStingFormating.xml">Макросы в Nemerle</a> - Nemerle<br><a target="_blank" rel="noopener" href="https://nim-lang.org/docs/tut3.html">Nim Tutorial Part 3</a> - Nim</p>
<h2><span id="naivnaya-realizaciya">Наивная реализация</span><a href="#naivnaya-realizaciya" class="header-anchor">#</a></h2><p>Прежде, чем начинать шаманить с макросами, нужно набросать наивную реализацию “быстрой” версии класса, хранящего свои данные в одном блоке памяти. Для этого можно использовать <a target="_blank" rel="noopener" href="https://tiorun.gaijin.team/##S0ksTi7KLCj5/z86taIgv6gklislNU0hNzEzj0sBCAqKMvNKNJQ8UnNy8nUUwvOLclIUlTS5/v8HAA">онлайн компилятор tio</a>.</p>
<figure class="shiki dascript"><div class="codeblock"><div class="code"><pre class="shiki slack-dark"><code><span class="line"><span style="color: #C586C0">struct</span><span style="color: #E6E6E6"> Memblock</span></span>
<span class="line"><span style="color: #E6E6E6">    mem : </span><span style="color: #C586C0">array</span><span style="color: #D4D4D4">&lt;</span><span style="color: #4EC9B0">uint8</span><span style="color: #D4D4D4">&gt;</span></span>
<span class="line"><span style="color: #E6E6E6">    a: </span><span style="color: #4EC9B0">int</span><span style="color: #E6E6E6">?</span></span>
<span class="line"><span style="color: #E6E6E6">    aCount: </span><span style="color: #4EC9B0">int</span></span>
<span class="line"><span style="color: #E6E6E6">    b: </span><span style="color: #4EC9B0">float</span><span style="color: #E6E6E6">?</span></span>
<span class="line"><span style="color: #E6E6E6">    bCount: </span><span style="color: #4EC9B0">int</span></span>
<span class="line"></span>
<span class="line"><span style="color: #569CD6">def</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">initMemblock</span><span style="color: #E6E6E6">(</span><span style="color: #569CD6">var</span><span style="color: #E6E6E6"> </span><span style="color: #9CDCFE">memblock</span><span style="color: #E6E6E6">: Memblock; </span><span style="color: #9CDCFE">aCount</span><span style="color: #E6E6E6">:</span><span style="color: #4EC9B0">int</span><span style="color: #E6E6E6">; </span><span style="color: #9CDCFE">bCount</span><span style="color: #E6E6E6">:</span><span style="color: #4EC9B0">int</span><span style="color: #E6E6E6">)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">let</span><span style="color: #E6E6E6"> aSize </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">typeinfo</span><span style="color: #E6E6E6">(sizeof </span><span style="color: #D4D4D4">*</span><span style="color: #E6E6E6">memblock</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">a) </span><span style="color: #D4D4D4">*</span><span style="color: #E6E6E6"> aCount</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">let</span><span style="color: #E6E6E6"> bSize </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">typeinfo</span><span style="color: #E6E6E6">(sizeof </span><span style="color: #D4D4D4">*</span><span style="color: #E6E6E6">memblock</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">b) </span><span style="color: #D4D4D4">*</span><span style="color: #E6E6E6"> bCount</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> arr: </span><span style="color: #C586C0">array</span><span style="color: #D4D4D4">&lt;</span><span style="color: #4EC9B0">uint8</span><span style="color: #D4D4D4">&gt;</span></span>
<span class="line"><span style="color: #E6E6E6">    arr </span><span style="color: #D4D4D4">|&gt;</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">resize</span><span style="color: #E6E6E6">(aSize </span><span style="color: #D4D4D4">+</span><span style="color: #E6E6E6"> bSize )</span></span>
<span class="line"><span style="color: #E6E6E6">    memblock</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">mem </span><span style="color: #D4D4D4">&lt;-</span><span style="color: #E6E6E6"> arr</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E6E6E6">    memblock</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">aCount </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> aCount</span></span>
<span class="line"><span style="color: #E6E6E6">    memblock</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">bCount </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> bCount</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">unsafe</span></span>
<span class="line"><span style="color: #E6E6E6">        memblock</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">a </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">reinterpret</span><span style="color: #D4D4D4">&lt;</span><span style="color: #4EC9B0">int</span><span style="color: #E6E6E6">?</span><span style="color: #D4D4D4">&gt;</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">addr</span><span style="color: #E6E6E6">(memblock</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">mem[</span><span style="color: #B5CEA8">0</span><span style="color: #E6E6E6">])</span></span>
<span class="line"><span style="color: #E6E6E6">        memblock</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">b </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">reinterpret</span><span style="color: #D4D4D4">&lt;</span><span style="color: #4EC9B0">float</span><span style="color: #E6E6E6">?</span><span style="color: #D4D4D4">&gt;</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">addr</span><span style="color: #E6E6E6">(memblock</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">mem[</span><span style="color: #569CD6">aSize</span><span style="color: #E6E6E6">])</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E6E6E6">        memblock</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">a[</span><span style="color: #B5CEA8">0</span><span style="color: #E6E6E6">] </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> int(</span><span style="color: #B5CEA8">0x11223344</span><span style="color: #E6E6E6">)</span></span>
<span class="line"><span style="color: #E6E6E6">        memblock</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">a[</span><span style="color: #B5CEA8">1</span><span style="color: #E6E6E6">] </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #B5CEA8">0</span></span>
<span class="line"><span style="color: #E6E6E6">        memblock</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">a[</span><span style="color: #B5CEA8">2</span><span style="color: #E6E6E6">] </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #D4D4D4">-</span><span style="color: #B5CEA8">1</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E6E6E6">        memblock</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">b[</span><span style="color: #B5CEA8">0</span><span style="color: #E6E6E6">] </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">reinterpret</span><span style="color: #D4D4D4">&lt;</span><span style="color: #4EC9B0">float</span><span style="color: #D4D4D4">&gt;</span><span style="color: #E6E6E6">(</span><span style="color: #B5CEA8">0x55667788</span><span style="color: #E6E6E6">)</span></span>
<span class="line"><span style="color: #E6E6E6">        memblock</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">b[</span><span style="color: #B5CEA8">1</span><span style="color: #E6E6E6">] </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #B5CEA8">0.0</span></span>
<span class="line"><span style="color: #E6E6E6">        memblock</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">b[</span><span style="color: #B5CEA8">2</span><span style="color: #E6E6E6">] </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #B5CEA8">123.456</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E6E6E6">[</span><span style="color: #569CD6">export</span><span style="color: #E6E6E6">]</span></span>
<span class="line"><span style="color: #C586C0">def</span><span style="color: #E6E6E6"> main</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> memblock: Memblock</span></span>
<span class="line"><span style="color: #E6E6E6">    memblock </span><span style="color: #D4D4D4">|&gt;</span><span style="color: #E6E6E6"> initMemblock(</span><span style="color: #B5CEA8">5</span><span style="color: #E6E6E6">,</span><span style="color: #B5CEA8">5</span><span style="color: #E6E6E6">)</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #DCDCAA">print</span><span style="color: #E6E6E6">(</span><span style="color: #CE9178">&quot;Memblock = {</span><span style="color: #9CDCFE">memblock</span><span style="color: #CE9178">}&quot;</span><span style="color: #E6E6E6">)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">//Output:</span></span>
<span class="line"><span style="color: #6A9955">//  Memblock = [[ [[0x44; 0x33; 0x22; 0x11; 0x0; 0x0; 0x0; 0x0; 0xff; 0xff; 0xff; 0xff; 0x0; 0x0;</span></span>
<span class="line"><span style="color: #6A9955">//     0x0; 0x0; 0x0; 0x0; 0x0; 0x0; 0x88; 0x77; 0x66; 0x55; 0x0; 0x0; 0x0; 0x0; 0x79; 0xe9; 0xf6; </span></span>
<span class="line"><span style="color: #6A9955">//     0x42; 0x0; 0x0; 0x0; 0x0; 0x0; 0x0; 0x0; 0x0]]; 287454020; 5; 15837566074880.000000000; 5]]</span></span></code></pre></div></div></figure>
<p>Несколько замечаний про язык:</p>
<ul>
<li>Питоноподобный синтаксис с отступами. Для тех, кто не переносит такой формы синтаксиса, есть вариант без оступов, со скобочками и точками-с-запятыми.</li>
<li>Пайпы (<code>|&gt;</code> и <code>&lt;|</code>) как синтаксический сахар различных записи вызова функции (<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Uniform_Function_Call_Syntax">UFCS</a>).</li>
<li>Более строгая типизация, чем в C/C++, из-за чего сложнее изучать язык и играться с ним — иногда приходится отвлекаться на то, чтобы разобраться, что именно компилятор от тебя хочет. По идее, должно помогать ловить в компайл-тайм больше того, что поймалось бы только в рантайме.</li>
<li><em>unsafe</em>, чтобы сказать компилятору “дай мне играться с указателями, как мне хочется, я знаю, что делаю”.</li>
<li>print умеет выводить внутренности структуры, можно убедиться, что данные действительно лежат в одном блоке памяти, как задумывалось.</li>
<li>Отсутствие семантики “=” для типов, для которых нет её однозначного определения. Вместо этого компилятор явно предлагает выбрать между клонированием (“:=”) и перемещением (“&lt;-“). В языке есть generic-функции, в них вроде можно попросить у компилятора данные о типах так, чтобы выбрать желаемое поведение.</li>
</ul>
<h2><span id="pervyy-makros">Первый макрос</span><a href="#pervyy-makros" class="header-anchor">#</a></h2><p>Попробуем для начала написать простейший макрос, который выведет на экран список полей структуры. С этого момента не получится использовать онлайн компилятор, так как он не поддерживает загрузку кода из нескольких файлов, а макрос должен располагаться в отдельном модуле.</p>
<p>Причина того, что макрос не может находиться в том же модуле, что и структура, которую он обрабатывает, понятна — чтобы выполнить какой-либо код, обрабатывающий структуру на этапе компиляции, необходимо, чтобы сам этот код к этому моменту был уже скомпилирован.</p>
<p>В репозитории языка валяется готовый <a target="_blank" rel="noopener" href="https://github.com/GaijinEntertainment/daScript/blob/073bc29145207b39180069ae60f00ed43fad6ea7/examples/test/misc/dump_fields.das">пример</a> такого макроса, но в учебных целях немного перепишем его:</p>
<figure class="shiki dascript"><div class="codeblock"><div class="code"><pre class="shiki slack-dark"><code><span class="line"><span style="color: #C586C0">module</span><span style="color: #E6E6E6"> macro_test</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C586C0">require</span><span style="color: #E6E6E6"> ast</span></span>
<span class="line"><span style="color: #C586C0">require</span><span style="color: #E6E6E6"> daslib</span><span style="color: #D4D4D4">/</span><span style="color: #E6E6E6">ast_boost</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E6E6E6">[</span><span style="color: #569CD6">structure_macro</span><span style="color: #E6E6E6">(name</span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6">memblock)]</span></span>
<span class="line"><span style="color: #569CD6">class</span><span style="color: #E6E6E6"> </span><span style="color: #4EC9B0">DumpFields</span><span style="color: #E6E6E6"> : </span><span style="color: #4EC9B0">AstStructureAnnotation</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #569CD6">def</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">override </span><span style="color: #DCDCAA">finish</span><span style="color: #E6E6E6"> ( </span><span style="color: #569CD6">var</span><span style="color: #E6E6E6"> </span><span style="color: #9CDCFE">st</span><span style="color: #E6E6E6">:StructurePtr; </span><span style="color: #569CD6">var</span><span style="color: #E6E6E6"> </span><span style="color: #9CDCFE">group</span><span style="color: #E6E6E6">:ModuleGroup; </span><span style="color: #9CDCFE">args</span><span style="color: #E6E6E6">:AnnotationArgumentList; </span><span style="color: #569CD6">var</span><span style="color: #E6E6E6"> </span><span style="color: #9CDCFE">errors </span><span style="color: #E6E6E6">: das_string ) : </span><span style="color: #4EC9B0">bool</span></span>
<span class="line"><span style="color: #E6E6E6">        </span><span style="color: #DCDCAA">print</span><span style="color: #E6E6E6">(</span><span style="color: #CE9178">&quot;struct {</span><span style="color: #9CDCFE">st</span><span style="color: #D4D4D4">.</span><span style="color: #9CDCFE">name</span><span style="color: #CE9178">} </span><span style="color: #D7BA7D">\{\n</span><span style="color: #CE9178">&quot;</span><span style="color: #E6E6E6">)</span></span>
<span class="line"><span style="color: #E6E6E6">        </span><span style="color: #C586C0">for</span><span style="color: #E6E6E6"> field </span><span style="color: #C586C0">in</span><span style="color: #E6E6E6"> st</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">fields</span></span>
<span class="line"><span style="color: #E6E6E6">            </span><span style="color: #DCDCAA">print</span><span style="color: #E6E6E6">(</span><span style="color: #CE9178">&quot;</span><span style="color: #D7BA7D">\t</span><span style="color: #CE9178">{describe_cpp(field</span><span style="color: #D4D4D4">.</span><span style="color: #CE9178">_type)} {</span><span style="color: #9CDCFE">field</span><span style="color: #D4D4D4">.</span><span style="color: #9CDCFE">name</span><span style="color: #CE9178">};</span><span style="color: #D7BA7D">\n</span><span style="color: #CE9178">&quot;</span><span style="color: #E6E6E6">)</span></span>
<span class="line"><span style="color: #E6E6E6">        </span><span style="color: #DCDCAA">print</span><span style="color: #E6E6E6">(</span><span style="color: #CE9178">&quot;</span><span style="color: #D7BA7D">\}\n</span><span style="color: #CE9178">&quot;</span><span style="color: #E6E6E6">)</span></span>
<span class="line"><span style="color: #E6E6E6">        </span><span style="color: #C586C0">return</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">true</span></span></code></pre></div></div></figure>
<p>Макрос наследуется от класса <code>AstStructureAnnotation</code>, определённого в модуле <a target="_blank" rel="noopener" href="https://github.com/GaijinEntertainment/daScript/blob/073bc29145207b39180069ae60f00ed43fad6ea7/src/builtin/ast.das#L75">ast</a>, который представляет собой шаблон для аннотации структуры. К самому классу также применяется аннотация <code>structure_macro</code>, которая регистрирует данный макрос для применения к каждой структуре, отмеченной аннотацией <code>memblock</code>.</p>
<figure class="shiki dascript"><div class="codeblock"><div class="code"><pre class="shiki slack-dark"><code><span class="line"><span style="color: #C586C0">class</span><span style="color: #E6E6E6"> AstStructureAnnotation</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #569CD6">def</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">abstract </span><span style="color: #DCDCAA">apply</span><span style="color: #E6E6E6"> ( </span><span style="color: #569CD6">var</span><span style="color: #E6E6E6"> </span><span style="color: #9CDCFE">st</span><span style="color: #E6E6E6">:StructurePtr; </span><span style="color: #569CD6">var</span><span style="color: #E6E6E6"> </span><span style="color: #9CDCFE">group</span><span style="color: #E6E6E6">:ModuleGroup; </span><span style="color: #9CDCFE">args</span><span style="color: #E6E6E6">:AnnotationArgumentList; </span><span style="color: #569CD6">var</span><span style="color: #E6E6E6"> </span><span style="color: #9CDCFE">errors </span><span style="color: #E6E6E6">: das_string ) : </span><span style="color: #4EC9B0">bool</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #569CD6">def</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">abstract </span><span style="color: #DCDCAA">finish</span><span style="color: #E6E6E6"> ( </span><span style="color: #569CD6">var</span><span style="color: #E6E6E6"> </span><span style="color: #9CDCFE">st</span><span style="color: #E6E6E6">:StructurePtr; </span><span style="color: #569CD6">var</span><span style="color: #E6E6E6"> </span><span style="color: #9CDCFE">group</span><span style="color: #E6E6E6">:ModuleGroup; </span><span style="color: #9CDCFE">args</span><span style="color: #E6E6E6">:AnnotationArgumentList; </span><span style="color: #569CD6">var</span><span style="color: #E6E6E6"> </span><span style="color: #9CDCFE">errors </span><span style="color: #E6E6E6">: das_string ) : </span><span style="color: #4EC9B0">bool</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #569CD6">def</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">abstract </span><span style="color: #DCDCAA">patch</span><span style="color: #E6E6E6"> ( </span><span style="color: #569CD6">var</span><span style="color: #E6E6E6"> </span><span style="color: #9CDCFE">st</span><span style="color: #E6E6E6">:StructurePtr; </span><span style="color: #569CD6">var</span><span style="color: #E6E6E6"> </span><span style="color: #9CDCFE">group</span><span style="color: #E6E6E6">:ModuleGroup; </span><span style="color: #9CDCFE">args</span><span style="color: #E6E6E6">:AnnotationArgumentList; </span><span style="color: #569CD6">var</span><span style="color: #E6E6E6"> </span><span style="color: #9CDCFE">errors </span><span style="color: #E6E6E6">: das_string; </span><span style="color: #569CD6">var</span><span style="color: #E6E6E6"> </span><span style="color: #9CDCFE">astChanged</span><span style="color: #E6E6E6">:</span><span style="color: #4EC9B0">bool</span><span style="color: #D4D4D4">&amp;</span><span style="color: #E6E6E6"> ) : </span><span style="color: #4EC9B0">bool</span></span></code></pre></div></div></figure>
<p>Интерфейс макроса позволяет переопределить три функции, чтобы “вклиниться” в процесс того, как компилятор обрабатывает определения структуры, на различных этапах. <a target="_blank" rel="noopener" href="https://dascript.org/doc/reference/language/macros.html?highlight=macro#compilation-passes">Документация по фазам компиляции</a>. <code>Apply</code> - наиболее подходящий момент, чтобы попробовать изменить поля структуры или сгенерировать код.</p>
<p>Если теперь отметить описание структуры аннотацией <code>memblock</code>, то компилятор “пропустит” её определение через макрос, который выведет названия полей на экран. В момент обработки информация о создаваемой структуре хранится в классе <code>StructurePtr</code>, определение которого можно найти поиском по C++ коду. На данном этапе макрос просто проходит по всем полям структуры и выводит информацию о каждом из них на экран. <code>describe_cpp</code> - это функция, которая выводит определения типа, как если бы он был объявлен в C++.</p>
<p>При запуске приложения на экран выведется:<br><figure class="shiki cpp"><div class="codeblock"><div class="code"><pre class="shiki slack-dark"><code><span class="line"><span style="color: #569CD6">struct</span><span style="color: #E6E6E6"> </span><span style="color: #4EC9B0">Memblock</span><span style="color: #E6E6E6"> {</span></span>
<span class="line"><span style="color: #E6E6E6">    TArray</span><span style="color: #D4D4D4">&lt;</span><span style="color: #569CD6">uint8_t</span><span style="color: #D4D4D4">&gt;</span><span style="color: #E6E6E6"> mem;</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #569CD6">int32_t</span><span style="color: #E6E6E6"> </span><span style="color: #D4D4D4">*</span><span style="color: #E6E6E6"> a;</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #569CD6">int32_t</span><span style="color: #E6E6E6"> aСount;</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #569CD6">int32_t</span><span style="color: #E6E6E6"> </span><span style="color: #D4D4D4">*</span><span style="color: #E6E6E6"> b;</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #569CD6">int32_t</span><span style="color: #E6E6E6"> bCount;</span></span>
<span class="line"><span style="color: #E6E6E6">}</span></span></code></pre></div></div></figure></p>
<p>Можно немного поиграться с определением макроса:</p>
<figure class="shiki dascript"><div class="codeblock"><div class="code"><pre class="shiki slack-dark"><code><span class="line"><span style="color: #E6E6E6">[</span><span style="color: #569CD6">structure_macro</span><span style="color: #E6E6E6">(name</span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6">memblock)]</span></span>
<span class="line"><span style="color: #569CD6">class</span><span style="color: #E6E6E6"> </span><span style="color: #4EC9B0">GenMemblock</span><span style="color: #E6E6E6"> : </span><span style="color: #4EC9B0">AstStructureAnnotation</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #569CD6">def</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">override </span><span style="color: #DCDCAA">apply</span><span style="color: #E6E6E6"> ( </span><span style="color: #569CD6">var</span><span style="color: #E6E6E6"> </span><span style="color: #9CDCFE">st</span><span style="color: #E6E6E6">:StructurePtr; </span><span style="color: #569CD6">var</span><span style="color: #E6E6E6"> </span><span style="color: #9CDCFE">group</span><span style="color: #E6E6E6">:ModuleGroup; </span><span style="color: #9CDCFE">args</span><span style="color: #E6E6E6">:AnnotationArgumentList; </span><span style="color: #569CD6">var</span><span style="color: #E6E6E6"> </span><span style="color: #9CDCFE">errors </span><span style="color: #E6E6E6">: das_string ) : </span><span style="color: #4EC9B0">bool</span></span>
<span class="line"><span style="color: #E6E6E6">        </span><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> mkS </span><span style="color: #D4D4D4">&lt;-</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">new</span><span style="color: #E6E6E6"> [[ Structure() ]]         </span><span style="color: #6A9955">//создаём новую структуру</span></span>
<span class="line"><span style="color: #E6E6E6">        mkS</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">name </span><span style="color: #D4D4D4">:=</span><span style="color: #E6E6E6"> </span><span style="color: #CE9178">&quot;MemblockTest&quot;</span><span style="color: #E6E6E6">               </span><span style="color: #6A9955">//с именем MemblockTest</span></span>
<span class="line"><span style="color: #E6E6E6">        </span><span style="color: #C586C0">let</span><span style="color: #E6E6E6"> fieldsLen </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> st</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">fields </span><span style="color: #D4D4D4">|&gt;</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">length</span></span>
<span class="line"><span style="color: #E6E6E6">        mkS</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">fields </span><span style="color: #D4D4D4">|&gt;</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">resize</span><span style="color: #E6E6E6">(fieldsLen)       </span></span>
<span class="line"><span style="color: #E6E6E6">        </span><span style="color: #C586C0">for</span><span style="color: #E6E6E6"> i </span><span style="color: #C586C0">in</span><span style="color: #E6E6E6"> range(</span><span style="color: #B5CEA8">0</span><span style="color: #E6E6E6">, fieldsLen)</span></span>
<span class="line"><span style="color: #E6E6E6">            mkS</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">fields[i] </span><span style="color: #D4D4D4">:=</span><span style="color: #E6E6E6"> st</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">fields[i]        </span><span style="color: #6A9955">//копируем в неё все поля из обрабатываемой структуры</span></span>
<span class="line"><span style="color: #E6E6E6">        compiling_module() </span><span style="color: #D4D4D4">|&gt;</span><span style="color: #E6E6E6"> add_structure(mkS) </span><span style="color: #6A9955">//добавляем в компилирующийся сейчас модуль новый тип</span></span>
<span class="line"><span style="color: #E6E6E6">        </span><span style="color: #C586C0">return</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">true</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">//Скрипт, использующий модуль с макросом</span></span>
<span class="line"><span style="color: #C586C0">require</span><span style="color: #E6E6E6"> macro_test</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E6E6E6">[</span><span style="color: #569CD6">memblock</span><span style="color: #E6E6E6">]</span></span>
<span class="line"><span style="color: #C586C0">struct</span><span style="color: #E6E6E6"> Memblock</span></span>
<span class="line"><span style="color: #E6E6E6">    mem : </span><span style="color: #C586C0">array</span><span style="color: #D4D4D4">&lt;</span><span style="color: #4EC9B0">uint8</span><span style="color: #D4D4D4">&gt;</span></span>
<span class="line"><span style="color: #E6E6E6">    a: </span><span style="color: #4EC9B0">int</span><span style="color: #E6E6E6">?</span></span>
<span class="line"><span style="color: #E6E6E6">    aCount: </span><span style="color: #4EC9B0">int</span></span>
<span class="line"><span style="color: #E6E6E6">    b: </span><span style="color: #4EC9B0">float</span><span style="color: #E6E6E6">?</span></span>
<span class="line"><span style="color: #E6E6E6">    bCount: </span><span style="color: #4EC9B0">int</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> memblock1: Memblock</span></span>
<span class="line"><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> memblock2: MemblockTest </span><span style="color: #6A9955">//ага, новый тип MemblockTest!</span></span>
<span class="line"><span style="color: #DCDCAA">print</span><span style="color: #E6E6E6">(</span><span style="color: #CE9178">&quot;MemblockTest = {</span><span style="color: #9CDCFE">memblock2</span><span style="color: #CE9178">}&quot;</span><span style="color: #E6E6E6">)</span></span></code></pre></div></div></figure>
<h2><span id="generaciya-poley">Генерация полей</span><a href="#generaciya-poley" class="header-anchor">#</a></h2><p>Следующим шагом попробуем убрать поле <code>mem</code> из исходной структуры, и создать его из макроса.</p>
<figure class="shiki dascript"><div class="codeblock"><div class="code"><pre class="shiki slack-dark"><code><span class="line"><span style="color: #E6E6E6">[</span><span style="color: #569CD6">structure_macro</span><span style="color: #E6E6E6">(name</span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6">memblock)]</span></span>
<span class="line"><span style="color: #569CD6">class</span><span style="color: #E6E6E6"> </span><span style="color: #4EC9B0">GenMemblock</span><span style="color: #E6E6E6"> : </span><span style="color: #4EC9B0">AstStructureAnnotation</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #569CD6">def</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">override </span><span style="color: #DCDCAA">apply</span><span style="color: #E6E6E6"> ( </span><span style="color: #569CD6">var</span><span style="color: #E6E6E6"> </span><span style="color: #9CDCFE">st</span><span style="color: #E6E6E6">:StructurePtr; </span><span style="color: #569CD6">var</span><span style="color: #E6E6E6"> </span><span style="color: #9CDCFE">group</span><span style="color: #E6E6E6">:ModuleGroup; </span><span style="color: #9CDCFE">args</span><span style="color: #E6E6E6">:AnnotationArgumentList; </span><span style="color: #569CD6">var</span><span style="color: #E6E6E6"> </span><span style="color: #9CDCFE">errors </span><span style="color: #E6E6E6">: das_string ) : </span><span style="color: #4EC9B0">bool</span></span>
<span class="line"><span style="color: #E6E6E6">        </span><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> mkS </span><span style="color: #D4D4D4">&lt;-</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">new</span><span style="color: #E6E6E6"> [[ Structure() ]]</span></span>
<span class="line"><span style="color: #E6E6E6">        mkS</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">name </span><span style="color: #D4D4D4">:=</span><span style="color: #E6E6E6"> </span><span style="color: #CE9178">&quot;MemblockTest&quot;</span></span>
<span class="line"><span style="color: #E6E6E6">        </span><span style="color: #C586C0">let</span><span style="color: #E6E6E6"> fieldsLen </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> st</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">fields </span><span style="color: #D4D4D4">|&gt;</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">length</span></span>
<span class="line"><span style="color: #E6E6E6">        mkS</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">fields </span><span style="color: #D4D4D4">|&gt;</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">resize</span><span style="color: #E6E6E6">(fieldsLen</span><span style="color: #D4D4D4">+</span><span style="color: #B5CEA8">1</span><span style="color: #E6E6E6">)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E6E6E6">        </span><span style="color: #6A9955">//определение типа uint8, как это видит компилятор</span></span>
<span class="line"><span style="color: #E6E6E6">        </span><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> uint8Type </span><span style="color: #D4D4D4">&lt;-</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">new</span><span style="color: #E6E6E6"> [[TypeDecl() baseType</span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6">Type tUInt8]]</span></span>
<span class="line"><span style="color: #E6E6E6">        </span><span style="color: #6A9955">//определение array&lt;uint8&gt; </span></span>
<span class="line"><span style="color: #E6E6E6">        </span><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> uint8ArrayType </span><span style="color: #D4D4D4">&lt;-</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">new</span><span style="color: #E6E6E6"> [[TypeDecl() baseType</span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6">Type tArray, firstType </span><span style="color: #D4D4D4">&lt;-</span><span style="color: #E6E6E6"> uint8Type]]</span></span>
<span class="line"><span style="color: #E6E6E6">        </span><span style="color: #6A9955">//декларация нового поля с именем mem и типом array&lt;uint8&gt; </span></span>
<span class="line"><span style="color: #E6E6E6">        mkS</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">fields[</span><span style="color: #B5CEA8">0</span><span style="color: #E6E6E6">] </span><span style="color: #D4D4D4">:=</span><span style="color: #E6E6E6"> </span><span style="color: #D4D4D4">*</span><span style="color: #C586C0">new</span><span style="color: #E6E6E6"> [[ FieldDeclaration() name</span><span style="color: #D4D4D4">:=</span><span style="color: #CE9178">&quot;mem&quot;</span><span style="color: #E6E6E6">, _type </span><span style="color: #D4D4D4">&lt;-</span><span style="color: #E6E6E6"> uint8ArrayType]]</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E6E6E6">        </span><span style="color: #C586C0">for</span><span style="color: #E6E6E6"> i </span><span style="color: #C586C0">in</span><span style="color: #E6E6E6"> range(</span><span style="color: #B5CEA8">0</span><span style="color: #E6E6E6">, fieldsLen)</span></span>
<span class="line"><span style="color: #E6E6E6">            mkS</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">fields[i</span><span style="color: #D4D4D4">+</span><span style="color: #B5CEA8">1</span><span style="color: #E6E6E6">] </span><span style="color: #D4D4D4">:=</span><span style="color: #E6E6E6"> st</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">fields[i]</span></span>
<span class="line"><span style="color: #E6E6E6">        compiling_module() </span><span style="color: #D4D4D4">|&gt;</span><span style="color: #E6E6E6"> add_structure(mkS)</span></span>
<span class="line"><span style="color: #E6E6E6">        </span><span style="color: #C586C0">return</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">true</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">//Скрипт, использующий модуль с макросом</span></span>
<span class="line"><span style="color: #E6E6E6">[</span><span style="color: #569CD6">memblock</span><span style="color: #E6E6E6">]</span></span>
<span class="line"><span style="color: #C586C0">struct</span><span style="color: #E6E6E6"> Memblock</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #6A9955">//mem : array&lt;uint8&gt;  //теперь поля нет в исходной структуре</span></span>
<span class="line"><span style="color: #E6E6E6">    a: </span><span style="color: #4EC9B0">int</span><span style="color: #E6E6E6">?</span></span>
<span class="line"><span style="color: #E6E6E6">    aCount: </span><span style="color: #4EC9B0">int</span></span>
<span class="line"><span style="color: #E6E6E6">    b: </span><span style="color: #4EC9B0">float</span><span style="color: #E6E6E6">?</span></span>
<span class="line"><span style="color: #E6E6E6">    bCount: </span><span style="color: #4EC9B0">int</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> memblock: MemblockTest</span></span>
<span class="line"><span style="color: #6A9955">//у структуры MemblockTest появилось поле mem, сгенерированное макросом</span></span>
<span class="line"><span style="color: #DCDCAA">print</span><span style="color: #E6E6E6">(</span><span style="color: #CE9178">&quot;MemblockTest = {</span><span style="color: #9CDCFE">memblock</span><span style="color: #D4D4D4">.</span><span style="color: #9CDCFE">mem</span><span style="color: #CE9178">}&quot;</span><span style="color: #E6E6E6">)</span></span></code></pre></div></div></figure>
<ul>
<li>функция <code>resize</code> изменяет размер массива, <a target="_blank" rel="noopener" href="https://dascript.org/doc/stdlib/builtin.html#containers">документация</a> функций для работы с контейерами.</li>
<li>можно изменять поля определяемой структуры прямо на месте - макрос выполняется в сам момент её определения. Создание новой структуры с другим именем сделано для наглядности примера.</li>
<li>генерация структур компилятора для определения поля сперва выглядит немного “космически”, дальше будет пример использования функции <code>quote</code>, которая позволяет перевести код как его писал бы человек, в выражение, которое сгенерирует компилятор при парсинге этого кода. Но полезно разобраться с таким способом генерации кода, чтобы привыкнуть к нему. Также стоит найти определения <code>TypeDecl</code> и <code>FieldDeclaration</code> в исходном коде компилятора, это самая надёжная документация.</li>
<li>“оператор” обращения к конкретному значению перечисления — пробел (<code>Type tArray</code> - значение <code>tArray</code> перечисления <code>Type</code>). Очень необычное решение.</li>
<li>при кодогенерации необходимо заботиться о том, чтобы сгенерированное имя не пересекалось с тем, которое может захотеть использовать программист. В этом смысле <code>mem</code> — плохое имя для сгенерированного поля, в реальном коде необходимо было бы какое-либо соглашение об именах, авторы языка используют символ ‘`’ (гравис, backquote) для отметки генерированного кода.</li>
</ul>
<p>Таким же образом можно перенести поля <code>aCount</code> и <code>bCount</code> в генерирующий макрос:</p>
<figure class="shiki dascript"><div class="codeblock"><div class="code"><pre class="shiki slack-dark"><code><span class="line"><span style="color: #E6E6E6">[</span><span style="color: #569CD6">structure_macro</span><span style="color: #E6E6E6">(name</span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6">memblock)]</span></span>
<span class="line"><span style="color: #569CD6">class</span><span style="color: #E6E6E6"> </span><span style="color: #4EC9B0">GenMemblock</span><span style="color: #E6E6E6"> : </span><span style="color: #4EC9B0">AstStructureAnnotation</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #569CD6">def</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">override </span><span style="color: #DCDCAA">apply</span><span style="color: #E6E6E6"> ( </span><span style="color: #569CD6">var</span><span style="color: #E6E6E6"> </span><span style="color: #9CDCFE">st</span><span style="color: #E6E6E6">:StructurePtr; </span><span style="color: #569CD6">var</span><span style="color: #E6E6E6"> </span><span style="color: #9CDCFE">group</span><span style="color: #E6E6E6">:ModuleGroup; </span><span style="color: #9CDCFE">args</span><span style="color: #E6E6E6">:AnnotationArgumentList; </span><span style="color: #569CD6">var</span><span style="color: #E6E6E6"> </span><span style="color: #9CDCFE">errors </span><span style="color: #E6E6E6">: das_string ) : </span><span style="color: #4EC9B0">bool</span></span>
<span class="line"><span style="color: #E6E6E6">        </span><span style="color: #6A9955">//create &quot;mem&quot; field of type array&lt;uint8&gt;</span></span>
<span class="line"><span style="color: #E6E6E6">        </span><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> uint8Type </span><span style="color: #D4D4D4">&lt;-</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">new</span><span style="color: #E6E6E6"> [[TypeDecl() baseType</span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6">Type tUInt8]]</span></span>
<span class="line"><span style="color: #E6E6E6">        </span><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> uint8ArrayType </span><span style="color: #D4D4D4">&lt;-</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">new</span><span style="color: #E6E6E6"> [[TypeDecl() baseType</span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6">Type tArray, firstType </span><span style="color: #D4D4D4">&lt;-</span><span style="color: #E6E6E6"> uint8Type]]</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E6E6E6">        </span><span style="color: #C586C0">let</span><span style="color: #E6E6E6"> fieldsLen </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> st</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">fields </span><span style="color: #D4D4D4">|&gt;</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">length</span></span>
<span class="line"><span style="color: #E6E6E6">        </span><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> ptrsCount </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #B5CEA8">0</span></span>
<span class="line"><span style="color: #E6E6E6">        </span><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> ptrsTypeIndexes : </span><span style="color: #C586C0">array</span><span style="color: #D4D4D4">&lt;</span><span style="color: #4EC9B0">int</span><span style="color: #D4D4D4">&gt;</span></span>
<span class="line"><span style="color: #E6E6E6">        ptrsTypeIndexes </span><span style="color: #D4D4D4">|&gt;</span><span style="color: #E6E6E6"> reserve(fieldsLen)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E6E6E6">        </span><span style="color: #6A9955">//Проходим по списку всех полей и сохраняем индексы полей, тип которых -- указатель</span></span>
<span class="line"><span style="color: #E6E6E6">        </span><span style="color: #C586C0">for</span><span style="color: #E6E6E6"> i </span><span style="color: #C586C0">in</span><span style="color: #E6E6E6"> range(</span><span style="color: #B5CEA8">0</span><span style="color: #E6E6E6">, fieldsLen)</span></span>
<span class="line"><span style="color: #E6E6E6">            </span><span style="color: #C586C0">if</span><span style="color: #E6E6E6"> st</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">fields[i]</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">_type</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">baseType </span><span style="color: #D4D4D4">==</span><span style="color: #E6E6E6"> Type tPointer </span><span style="color: #6A9955">//проверка типа поля</span></span>
<span class="line"><span style="color: #E6E6E6">                ptrsCount</span><span style="color: #D4D4D4">++</span></span>
<span class="line"><span style="color: #E6E6E6">                ptrsTypeIndexes </span><span style="color: #D4D4D4">|&gt;</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">push</span><span style="color: #E6E6E6">(i)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E6E6E6">        </span><span style="color: #6A9955">//add one field for memblock and one field per pointer type to handle count of object per type</span></span>
<span class="line"><span style="color: #E6E6E6">        st</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">fields </span><span style="color: #D4D4D4">|&gt;</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">resize</span><span style="color: #E6E6E6">(fieldsLen</span><span style="color: #D4D4D4">+</span><span style="color: #E6E6E6"> ptrsCount </span><span style="color: #D4D4D4">+</span><span style="color: #E6E6E6"> </span><span style="color: #B5CEA8">1</span><span style="color: #E6E6E6">)</span></span>
<span class="line"><span style="color: #E6E6E6">        st</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">fields[</span><span style="color: #569CD6">fieldsLen</span><span style="color: #E6E6E6">] </span><span style="color: #D4D4D4">:=</span><span style="color: #E6E6E6"> </span><span style="color: #D4D4D4">*</span><span style="color: #C586C0">new</span><span style="color: #E6E6E6"> [[ FieldDeclaration() name</span><span style="color: #D4D4D4">:=</span><span style="color: #CE9178">&quot;mem&quot;</span><span style="color: #E6E6E6">, _type </span><span style="color: #D4D4D4">&lt;-</span><span style="color: #E6E6E6"> uint8ArrayType]]</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E6E6E6">        </span><span style="color: #C586C0">for</span><span style="color: #E6E6E6"> i </span><span style="color: #C586C0">in</span><span style="color: #E6E6E6"> range(</span><span style="color: #B5CEA8">0</span><span style="color: #E6E6E6">, ptrsCount)</span></span>
<span class="line"><span style="color: #E6E6E6">            </span><span style="color: #6A9955">//генерируем имя поля - добавляем к нему постфикс `count</span></span>
<span class="line"><span style="color: #E6E6E6">            </span><span style="color: #C586C0">let</span><span style="color: #E6E6E6"> fieldCountName </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #CE9178">&quot;{</span><span style="color: #9CDCFE">st</span><span style="color: #D4D4D4">.</span><span style="color: #9CDCFE">fields</span><span style="color: #CE9178">[</span><span style="color: #569CD6">ptrsTypeIndexes</span><span style="color: #CE9178">[i]]</span><span style="color: #D4D4D4">.</span><span style="color: #9CDCFE">name</span><span style="color: #CE9178">}{&quot;`count&quot;}&quot;</span></span>
<span class="line"><span style="color: #E6E6E6">            </span><span style="color: #6A9955">//генерируем новое поля типа int для каждого поля</span></span>
<span class="line"><span style="color: #E6E6E6">            st</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">fields[</span><span style="color: #569CD6">fieldsLen</span><span style="color: #E6E6E6">+1+i] </span><span style="color: #D4D4D4">:=</span><span style="color: #E6E6E6"> </span><span style="color: #D4D4D4">*</span><span style="color: #C586C0">new</span><span style="color: #E6E6E6"> [[ FieldDeclaration() name</span><span style="color: #D4D4D4">:=</span><span style="color: #E6E6E6">fieldCountName, _type </span><span style="color: #D4D4D4">&lt;-</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">new</span><span style="color: #E6E6E6"> [[TypeDecl() baseType</span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6">Type tInt]]]]</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E6E6E6">        </span><span style="color: #C586C0">return</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">true</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E6E6E6">[</span><span style="color: #569CD6">memblock</span><span style="color: #E6E6E6">]</span></span>
<span class="line"><span style="color: #6A9955">//сама структура теперь содержит только определение полей</span></span>
<span class="line"><span style="color: #C586C0">struct</span><span style="color: #E6E6E6"> Memblock</span></span>
<span class="line"><span style="color: #E6E6E6">    a: </span><span style="color: #4EC9B0">int</span><span style="color: #E6E6E6">?</span></span>
<span class="line"><span style="color: #E6E6E6">    b: </span><span style="color: #4EC9B0">float</span><span style="color: #E6E6E6">?</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">//вывод скрипта -- сгенерированные поля</span></span>
<span class="line"><span style="color: #C586C0">struct</span><span style="color: #E6E6E6"> Memblock {</span></span>
<span class="line"><span style="color: #E6E6E6">        int32_t </span><span style="color: #D4D4D4">*</span><span style="color: #E6E6E6"> a;</span></span>
<span class="line"><span style="color: #E6E6E6">        </span><span style="color: #4EC9B0">float</span><span style="color: #E6E6E6"> </span><span style="color: #D4D4D4">*</span><span style="color: #E6E6E6"> b;</span></span>
<span class="line"><span style="color: #E6E6E6">        TArray</span><span style="color: #D4D4D4">&lt;</span><span style="color: #E6E6E6">uint8_t</span><span style="color: #D4D4D4">&gt;</span><span style="color: #E6E6E6"> mem;</span></span>
<span class="line"><span style="color: #E6E6E6">        int32_t a`count;</span></span>
<span class="line"><span style="color: #E6E6E6">        int32_t b`count;</span></span>
<span class="line"><span style="color: #E6E6E6">}</span></span></code></pre></div></div></figure>
<p>Разумеется, в реальном мире бывают структуры, которые могут содержать одновременно как указатели на память, которую должна выделять и освобождать сама структура, так и те, которые указывают на память, которую структура трогать не должна. Пока что мы считаем, что структура, отмеченная как <code>memblock</code>, содержит только указатели на память, которую выделяет и освобождает сама. Забегая наперёд, реализовать поддержку обоих типов указателей можно с помощью аннотаций типа (я не нашёл ссылок на аннотации в документации, но их можно найти в коде (<a target="_blank" rel="noopener" href="https://github.com/borisbat/dasBGFX/blob/a1e10ab439e5996a0a4d8722689e2b0fab4e72d9/examples/01_hello_triangle.das#L7">пример</a>)). Аннотации типа будут рассмотрены сильно дальше, при реализации наследования от memblock-структур.</p>
<p>На данном этапе мы получили возможность описать структуру с любым количеством полей, и с помощью макроса сгенерировать по этому описанию недостающие поля. К сожалению, функцию <code>initMemblock</code> (конструктор структуры), по прежнему необходимо писать руками, что очень неприятно.</p>
<h2><span id="podgotovka-k-generaciya-koda-konstruktora">Подготовка к генерация кода конструктора</span><a href="#podgotovka-k-generaciya-koda-konstruktora" class="header-anchor">#</a></h2><p>Для начала стоит немного переписать код <code>initMemblock</code>, чтобы отделить часть инициализации структуры, которую нужно сгенерировать. Также добавлено третье поле, для того, чтобы увидеть, какие изменения потребуется сейчас внести в код <code>initMemblock</code></p>
<figure class="shiki dascript"><div class="codeblock"><div class="code"><pre class="shiki slack-dark"><code><span class="line"><span style="color: #6A9955">//аннотация того, что к структуре надо применить 2 макроса, добавляющий поля, и дебажный, отображающий все поля</span></span>
<span class="line"><span style="color: #E6E6E6">[</span><span style="color: #569CD6">memblock</span><span style="color: #E6E6E6">, dump_fields]</span></span>
<span class="line"><span style="color: #C586C0">struct</span><span style="color: #E6E6E6"> Memblock</span></span>
<span class="line"><span style="color: #E6E6E6">    a: </span><span style="color: #4EC9B0">int</span><span style="color: #E6E6E6">?</span></span>
<span class="line"><span style="color: #E6E6E6">    b: </span><span style="color: #4EC9B0">float</span><span style="color: #E6E6E6">?</span></span>
<span class="line"><span style="color: #E6E6E6">    c: </span><span style="color: #4EC9B0">int</span><span style="color: #E6E6E6">?</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">//Шаблонный код инициализации, типовой для memblock-структур</span></span>
<span class="line"><span style="color: #6A9955">//  необходимо научиться генерировать его, чтобы не писать руками для каждой структуры</span></span>
<span class="line"><span style="color: #569CD6">def</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">initMemblock</span><span style="color: #E6E6E6">(</span><span style="color: #569CD6">var</span><span style="color: #E6E6E6"> </span><span style="color: #9CDCFE">memblock</span><span style="color: #E6E6E6">: Memblock; </span><span style="color: #9CDCFE">aCount</span><span style="color: #E6E6E6">:</span><span style="color: #4EC9B0">int</span><span style="color: #E6E6E6">; </span><span style="color: #9CDCFE">bCount</span><span style="color: #E6E6E6">:</span><span style="color: #4EC9B0">int</span><span style="color: #E6E6E6">; </span><span style="color: #9CDCFE">cCount</span><span style="color: #E6E6E6">:</span><span style="color: #4EC9B0">int</span><span style="color: #E6E6E6">)</span></span>
<span class="line"><span style="color: #E6E6E6">    memblock</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">a`count </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> aCount</span></span>
<span class="line"><span style="color: #E6E6E6">    memblock</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">b`count </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> bCount</span></span>
<span class="line"><span style="color: #E6E6E6">    memblock</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">c`count </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> cCount                                          </span><span style="color: #6A9955">//новое</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">let</span><span style="color: #E6E6E6"> aSize </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">typeinfo</span><span style="color: #E6E6E6">(sizeof </span><span style="color: #D4D4D4">*</span><span style="color: #E6E6E6">memblock</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">a) </span><span style="color: #D4D4D4">*</span><span style="color: #E6E6E6"> aCount</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">let</span><span style="color: #E6E6E6"> bSize </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">typeinfo</span><span style="color: #E6E6E6">(sizeof </span><span style="color: #D4D4D4">*</span><span style="color: #E6E6E6">memblock</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">b) </span><span style="color: #D4D4D4">*</span><span style="color: #E6E6E6"> bCount</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">let</span><span style="color: #E6E6E6"> cSize </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">typeinfo</span><span style="color: #E6E6E6">(sizeof </span><span style="color: #D4D4D4">*</span><span style="color: #E6E6E6">memblock</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">c) </span><span style="color: #D4D4D4">*</span><span style="color: #E6E6E6"> cCount                  </span><span style="color: #6A9955">//новое</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E6E6E6">    memblock</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">mem </span><span style="color: #D4D4D4">|&gt;</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">resize</span><span style="color: #E6E6E6">(aSize </span><span style="color: #D4D4D4">+</span><span style="color: #E6E6E6"> bSize </span><span style="color: #D4D4D4">+</span><span style="color: #E6E6E6"> cSize)                      </span><span style="color: #6A9955">//новое</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">unsafe</span></span>
<span class="line"><span style="color: #E6E6E6">        memblock</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">a </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">reinterpret</span><span style="color: #D4D4D4">&lt;</span><span style="color: #4EC9B0">int</span><span style="color: #E6E6E6">?</span><span style="color: #D4D4D4">&gt;</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">addr</span><span style="color: #E6E6E6">(memblock</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">mem[</span><span style="color: #B5CEA8">0</span><span style="color: #E6E6E6">])</span></span>
<span class="line"><span style="color: #E6E6E6">        memblock</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">b </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">reinterpret</span><span style="color: #D4D4D4">&lt;</span><span style="color: #4EC9B0">float</span><span style="color: #E6E6E6">?</span><span style="color: #D4D4D4">&gt;</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">addr</span><span style="color: #E6E6E6">(memblock</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">mem[</span><span style="color: #569CD6">aSize</span><span style="color: #E6E6E6">])</span></span>
<span class="line"><span style="color: #E6E6E6">        memblock</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">c </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">reinterpret</span><span style="color: #D4D4D4">&lt;</span><span style="color: #4EC9B0">int</span><span style="color: #E6E6E6">?</span><span style="color: #D4D4D4">&gt;</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">addr</span><span style="color: #E6E6E6">(memblock</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">mem[</span><span style="color: #569CD6">aSize</span><span style="color: #E6E6E6">+bSize]) </span><span style="color: #6A9955">//новое</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">//Пример использования структуры</span></span>
<span class="line"><span style="color: #569CD6">def</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">fillMemblock</span><span style="color: #E6E6E6">(</span><span style="color: #569CD6">var</span><span style="color: #E6E6E6"> </span><span style="color: #9CDCFE">memblock</span><span style="color: #E6E6E6">: Memblock)</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">unsafe</span></span>
<span class="line"><span style="color: #E6E6E6">        memblock</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">a[</span><span style="color: #B5CEA8">0</span><span style="color: #E6E6E6">] </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> int(</span><span style="color: #B5CEA8">0x11223344</span><span style="color: #E6E6E6">)</span></span>
<span class="line"><span style="color: #E6E6E6">        memblock</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">a[</span><span style="color: #B5CEA8">1</span><span style="color: #E6E6E6">] </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #B5CEA8">0</span></span>
<span class="line"><span style="color: #E6E6E6">        memblock</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">a[</span><span style="color: #B5CEA8">2</span><span style="color: #E6E6E6">] </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #D4D4D4">-</span><span style="color: #B5CEA8">1</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E6E6E6">        memblock</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">b[</span><span style="color: #B5CEA8">0</span><span style="color: #E6E6E6">] </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">reinterpret</span><span style="color: #D4D4D4">&lt;</span><span style="color: #4EC9B0">float</span><span style="color: #D4D4D4">&gt;</span><span style="color: #E6E6E6">(</span><span style="color: #B5CEA8">0x55667788</span><span style="color: #E6E6E6">)</span></span>
<span class="line"><span style="color: #E6E6E6">        memblock</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">b[</span><span style="color: #B5CEA8">1</span><span style="color: #E6E6E6">] </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #B5CEA8">0.0</span></span>
<span class="line"><span style="color: #E6E6E6">        memblock</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">b[</span><span style="color: #B5CEA8">2</span><span style="color: #E6E6E6">] </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #B5CEA8">123.456</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E6E6E6">        memblock</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">c[</span><span style="color: #B5CEA8">0</span><span style="color: #E6E6E6">] </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> int(</span><span style="color: #B5CEA8">0xAABBCCDD</span><span style="color: #E6E6E6">)</span></span>
<span class="line"><span style="color: #E6E6E6">        memblock</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">c[</span><span style="color: #B5CEA8">1</span><span style="color: #E6E6E6">] </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #B5CEA8">0</span></span>
<span class="line"><span style="color: #E6E6E6">        memblock</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">c[</span><span style="color: #B5CEA8">2</span><span style="color: #E6E6E6">] </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #D4D4D4">-</span><span style="color: #B5CEA8">1</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">//Тест</span></span>
<span class="line"><span style="color: #E6E6E6">[</span><span style="color: #569CD6">export</span><span style="color: #E6E6E6">]</span></span>
<span class="line"><span style="color: #C586C0">def</span><span style="color: #E6E6E6"> test</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> memblock: Memblock</span></span>
<span class="line"><span style="color: #E6E6E6">    memblock </span><span style="color: #D4D4D4">|&gt;</span><span style="color: #E6E6E6"> initMemblock(</span><span style="color: #B5CEA8">5</span><span style="color: #E6E6E6">,</span><span style="color: #B5CEA8">5</span><span style="color: #E6E6E6">,</span><span style="color: #B5CEA8">5</span><span style="color: #E6E6E6">) </span><span style="color: #6A9955">//кол-во аргументов конструктора, зависит от количества полей структуры</span></span>
<span class="line"><span style="color: #E6E6E6">    memblock </span><span style="color: #D4D4D4">|&gt;</span><span style="color: #E6E6E6"> fillMemblock</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #DCDCAA">print</span><span style="color: #E6E6E6">(</span><span style="color: #CE9178">&quot;Memblock = {</span><span style="color: #9CDCFE">memblock</span><span style="color: #CE9178">}&quot;</span><span style="color: #E6E6E6">)</span></span></code></pre></div></div></figure>
<p>Прежде, чем приступать к написанию макроса, генерирующего функцию <code>initMemblock</code>, стоит разобраться с парой примеров:</p>
<p><a target="_blank" rel="noopener" href="https://github.com/GaijinEntertainment/daScript/blob/073bc29145207b39180069ae60f00ed43fad6ea7/examples/test/misc/gen_fields.das">gen_field.das</a> — генерация функции, логгирующей создание полей структуры.</p>
<ul>
<li>Приведены два макроса <code>DumpFields</code> и <code>Dump2Fields</code>, работающие на различных стадиях (apply/finish), во время генерации структуры, и после окончания.</li>
<li>На момент написание заметки пример был сломан, для фикса необходимо убрать код, касающийся типа <code>EntityId</code> — видимо, пример выдран из какого-то более масштабного кода, и опредения то ли забыли перенести, то ли забыли добавить модуль, содержащий их.</li>
<li>флаг функции “<code>fn.flags |= FunctionFlags init</code>“ говорит компилятору о том, что функция должна быть вызвана сразу после генерации (я какое-то время тупил с тем, чтобы понять, на какой стадии компиляции, кто и почему её вызывает).</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://github.com/GaijinEntertainment/daScript/blob/073bc29145207b39180069ae60f00ed43fad6ea7/examples/test/misc/ast_print.das">ast_print.das</a> - макрос, выводящий исходный текст на dascript переданного ему выражения на daScript.</p>
<ul>
<li>этот пример в репозитории тоже немного сломан (<a target="_blank" rel="noopener" href="https://github.com/spiiin/dascript_macro_tutorial/blob/master/examples/ast_print.das">Fixed version</a>)</li>
</ul>
<p>Теперь применим немного рекурсивной магии.</p>
<p>Этот макрос может быть очень полезным, если переделать его так, чтобы он печатал не исходный текст переданного ему выражения, а исходный текст МАКРОСА, генерирующего при выполнении само это выражение.</p>
<p>Это очень важная для упрощения метапрограммирования часть, поэтому повторю ещё раз. Вместо написания макроса, генерирующего функцию <code>initMemblock</code>, мы сначала напишем <strong><code>макрос ast_print_expression, который выведет на экран текст, который поможет нам написать макрос generateInitMemblockFunction, генерирующий функцию initMemblock</code></strong> (или любую другую функцию). Звучит запутанно, но это не так сложно, как кажется.<br>(всё, больше не буду повторять, язык сломать можно)</p>
<p>Модифицируем функцию <code>ast_print</code> так, чтобы она не просто печатала исходный текст переданного ей выражения, а дополнительно печатала тип каждого подвыражения (<code>Subexpression</code>) этого выражения.<br>Вот такая функция:<br><a target="_blank" rel="noopener" href="https://github.com/spiiin/dascript_macro_tutorial/blob/master/examples/macro_print_ast.das">ast_print_expression</a> (конечно, немного “наколенная”)</p>
<p>Теперь можно начать последовательно копировать типы подвыражений в макрос, генерирующий функцию <code>initMemblock</code>, постепенно модифицируя его так, чтобы добавлять параметры, позволяющие генерировать различные варианты этой функции.</p>
<p>Рабочий процесс на этом этапе удобно зациклить так:</p>
<ul>
<li>Модифицируем текст initMemblock</li>
<li>Перезапускаем компиляцию функции, чтобы макрос ast_print_expression применился к этой функции и вывел на экран выражение, в которое преобразуется функция</li>
<li>Копируем часть выражения в макрос generateInitMemblockFunction, который должен сгенерировать новую функцию initMemblock_generated, идентичную самой функции initMemblock</li>
<li>Модифицируем макрос generateInitMemblockFunction, чтобы добавить в него код, генерирующий переменную часть функции</li>
<li>Перекомпилируем функцию initMemblock_generated, чтобы применить к ней макрос ast_print, для того, чтобы получить исходный код функции и сверить его с исходный кодом initMemblock</li>
</ul>
<p>Выглядит запутанно, но это необходимо для того, чтобы иметь возможность выполнить шаг 4 - “переменная часть функции” — те строчки, которые изменяются в функции <code>initMemblock</code> после того, как мы изменяем какое-либо поле структуры <code>Memblock</code> (посмотрите исходный код функции <code>initMemblock</code> и отметки <code>//новое</code>, это строчки, которые добавились после добавления поля с именем <code>c</code> — это как раз эта “переменная часть функции”).</p>
<p>Самое интересное, что перевести программу в режим REPL практически элементарно, достаточно зациклить C++ часть самого первого туториала из репозитория daScript, перекомпилируя daScript-ы заново при вводе любого символа:</p>
<figure class="shiki cpp"><div class="codeblock"><div class="code"><pre class="shiki slack-dark"><code><span class="line"><span style="color: #569CD6">int</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">main</span><span style="color: #E6E6E6">( </span><span style="color: #569CD6">int</span><span style="color: #E6E6E6">, </span><span style="color: #569CD6">char</span><span style="color: #E6E6E6"> </span><span style="color: #569CD6">*</span><span style="color: #E6E6E6"> [] ) {</span></span>
<span class="line"><span style="color: #E6E6E6">    NEED_ALL_DEFAULT_MODULES;</span></span>
<span class="line"><span style="color: #E6E6E6">    Module::</span><span style="color: #DCDCAA">Initialize</span><span style="color: #E6E6E6">();</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #569CD6">char</span><span style="color: #E6E6E6"> a </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #CE9178">&#39;x&#39;</span><span style="color: #E6E6E6">;</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">while</span><span style="color: #E6E6E6"> (</span><span style="color: #B5CEA8">1</span><span style="color: #E6E6E6">) {</span></span>
<span class="line"><span style="color: #E6E6E6">        </span><span style="color: #DCDCAA">tutorial</span><span style="color: #E6E6E6">();</span></span>
<span class="line"><span style="color: #6A9955">        //тут скорее всего надо не забыть очистить память, выделенную в цикле работы</span></span>
<span class="line"><span style="color: #E6E6E6">        std::cin </span><span style="color: #D4D4D4">&gt;&gt;</span><span style="color: #E6E6E6"> a;</span></span>
<span class="line"><span style="color: #E6E6E6">    }</span></span>
<span class="line"><span style="color: #E6E6E6">    Module::</span><span style="color: #DCDCAA">Shutdown</span><span style="color: #E6E6E6">();</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">return</span><span style="color: #E6E6E6"> </span><span style="color: #B5CEA8">0</span><span style="color: #E6E6E6">;</span></span>
<span class="line"><span style="color: #E6E6E6">}</span></span></code></pre></div></div></figure>
<p>Рабочий процесс выглядит примерно так:<br><img src="/blog/1547564887/memblock_example.png" alt="fox"><br>Слева код в <a target="_blank" rel="noopener" href="https://marketplace.visualstudio.com/items?itemName=profelis.dascript-plugin">Visual Studio Code</a>, справа программа, выполняющая этот код без необходимости перезапуска. После подготовки можно переходить и к генерации кода, с Repl-режимом это будет значительно проще.</p>
<h2><span id="generaciya-funkcii-initmemblock">Генерация функции initMemblock</span><a href="#generaciya-funkcii-initmemblock" class="header-anchor">#</a></h2><p>Макрос <code>ast_print_expression</code> применённый к функции initMemblock, выводит на экран:</p>
<figure class="shiki dascript"><div class="codeblock"><div class="code"><pre class="shiki slack-dark"><code><span class="line"><span style="color: #D4D4D4">---</span><span style="color: #E6E6E6">das</span><span style="color: #D4D4D4">------------------</span><span style="color: #6A9955">// [modifyExternal][modifyArgument]</span></span>
<span class="line"><span style="color: #569CD6">def</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">initMemblock</span><span style="color: #E6E6E6"> ( </span><span style="color: #569CD6">var</span><span style="color: #E6E6E6"> </span><span style="color: #9CDCFE">memblock </span><span style="color: #E6E6E6">: Memblock </span><span style="color: #D4D4D4">-</span><span style="color: #569CD6">const</span><span style="color: #E6E6E6">; </span><span style="color: #9CDCFE">aCount </span><span style="color: #E6E6E6">: </span><span style="color: #4EC9B0">int</span><span style="color: #E6E6E6"> </span><span style="color: #569CD6">const</span><span style="color: #E6E6E6">; </span><span style="color: #9CDCFE">bCount </span><span style="color: #E6E6E6">: </span><span style="color: #4EC9B0">int</span><span style="color: #E6E6E6"> </span><span style="color: #569CD6">const</span><span style="color: #E6E6E6">; </span><span style="color: #9CDCFE">cCount </span><span style="color: #E6E6E6">: </span><span style="color: #4EC9B0">int</span><span style="color: #E6E6E6"> </span><span style="color: #569CD6">const</span><span style="color: #E6E6E6"> )</span></span>
<span class="line"><span style="color: #E6E6E6">        ExprVar memblock</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6"> ExprField a`count ExprCopyRight </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> ExprVar aCount</span></span>
<span class="line"><span style="color: #E6E6E6">        ExprVar memblock</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6"> ExprField b`count ExprCopyRight </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> ExprVar bCount</span></span>
<span class="line"><span style="color: #E6E6E6">        ExprVar memblock</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6"> ExprField c`count ExprCopyRight </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> ExprVar cCount</span></span>
<span class="line"><span style="color: #E6E6E6">        ExprLet </span><span style="color: #C586C0">var</span><span style="color: #E6E6E6">  ExprLetVariable aSize : </span><span style="color: #4EC9B0">int</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">const</span><span style="color: #E6E6E6"> </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6">  ExprOp2(ExprVar aCount ExprOp2Right </span><span style="color: #D4D4D4">*</span><span style="color: #E6E6E6"> </span><span style="color: #B5CEA8">4</span><span style="color: #E6E6E6">)</span></span>
<span class="line"><span style="color: #E6E6E6">        ExprLet </span><span style="color: #C586C0">var</span><span style="color: #E6E6E6">  ExprLetVariable bSize : </span><span style="color: #4EC9B0">int</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">const</span><span style="color: #E6E6E6"> </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6">  ExprOp2(ExprVar bCount ExprOp2Right </span><span style="color: #D4D4D4">*</span><span style="color: #E6E6E6"> </span><span style="color: #B5CEA8">4</span><span style="color: #E6E6E6">)</span></span>
<span class="line"><span style="color: #E6E6E6">        ExprLet </span><span style="color: #C586C0">var</span><span style="color: #E6E6E6">  ExprLetVariable cSize : </span><span style="color: #4EC9B0">int</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">const</span><span style="color: #E6E6E6"> </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6">  ExprOp2(ExprVar cCount ExprOp2Right </span><span style="color: #D4D4D4">*</span><span style="color: #E6E6E6"> </span><span style="color: #B5CEA8">4</span><span style="color: #E6E6E6">)</span></span>
<span class="line"><span style="color: #E6E6E6">        ExprCall __::builtin`</span><span style="color: #DCDCAA">resize</span><span style="color: #E6E6E6">( ExprCallArgument ExprVar memblock</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6"> ExprField mem, ExprCallArgument  ExprOp2( ExprOp2(ExprVar aSize ExprOp2Right </span><span style="color: #D4D4D4">+</span><span style="color: #E6E6E6"> ExprVar bSize) ExprOp2Right </span><span style="color: #D4D4D4">+</span><span style="color: #E6E6E6"> ExprVar cSize))</span></span>
<span class="line"><span style="color: #E6E6E6">        ExprVar memblock</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6"> ExprField a ExprCopyRight </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> ExprCast </span><span style="color: #C586C0">reinterpret</span><span style="color: #D4D4D4">&lt;</span><span style="color: #4EC9B0">int</span><span style="color: #E6E6E6">?</span><span style="color: #D4D4D4">&gt;</span><span style="color: #E6E6E6">  VisitExprRef2Ptr </span><span style="color: #C586C0">addr</span><span style="color: #E6E6E6">(ExprVar memblock</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6"> ExprField mem ExprAtIndex[</span><span style="color: #B5CEA8">0</span><span style="color: #E6E6E6">])</span></span>
<span class="line"><span style="color: #E6E6E6">        ExprVar memblock</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6"> ExprField b ExprCopyRight </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> ExprCast </span><span style="color: #C586C0">reinterpret</span><span style="color: #D4D4D4">&lt;</span><span style="color: #4EC9B0">float</span><span style="color: #E6E6E6">?</span><span style="color: #D4D4D4">&gt;</span><span style="color: #E6E6E6">  VisitExprRef2Ptr </span><span style="color: #C586C0">addr</span><span style="color: #E6E6E6">(ExprVar memblock</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6"> ExprField mem ExprAtIndex[</span><span style="color: #569CD6">ExprVar</span><span style="color: #E6E6E6"> aSize])</span></span>
<span class="line"><span style="color: #E6E6E6">        ExprVar memblock</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6"> ExprField c ExprCopyRight </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> ExprCast </span><span style="color: #C586C0">reinterpret</span><span style="color: #D4D4D4">&lt;</span><span style="color: #4EC9B0">int</span><span style="color: #E6E6E6">?</span><span style="color: #D4D4D4">&gt;</span><span style="color: #E6E6E6">  VisitExprRef2Ptr </span><span style="color: #C586C0">addr</span><span style="color: #E6E6E6">(ExprVar memblock</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6"> ExprField mem ExprAtIndex[ </span><span style="color: #569CD6">ExprOp2</span><span style="color: #E6E6E6">(ExprVar aSize ExprOp2Right + ExprVar bSize)])</span></span>
<span class="line"><span style="color: #E6E6E6">        ExprCall init`</span><span style="color: #C586C0">struct</span><span style="color: #E6E6E6">`Memblock( ExprCallArgument ExprVar memblock, ExprCallArgument </span><span style="color: #B5CEA8">5</span><span style="color: #E6E6E6">, ExprCallArgument </span><span style="color: #B5CEA8">5</span><span style="color: #E6E6E6">, ExprCallArgument </span><span style="color: #B5CEA8">5</span><span style="color: #E6E6E6">)</span></span></code></pre></div></div></figure>
<p>Здесь перед каждым daScript выражением показан тип этого выражения. Почти все типы выражений объявлены в заголовочных файлах <a target="_blank" rel="noopener" href="https://github.com/GaijinEntertainment/daScript/tree/master/include/daScript/ast">ast_*.h</a>.</p>
<blockquote><p>С определенного момента начинаешь ценить простые языки — вместо того, что изучать сложные и разрастающиеся правила языка, можно упростить их, чтобы ускорить изучение языка и сделать его более понятным, но при этом дать возможность задавать более сложные правила только в тех местах, где они действительно нужны программисту.</p>
</blockquote>
<p><strong><code>Работа с макросами сначала кажется сложной, но с какого-то момента понимаешь, что типичная программа содержит почти все распространённые типы выражений, и понимаешь, что вот они, все перед тобой, других, скрытых мелким шрифтом в примечаниях на 666-й странице стандарта, нет.</code></strong></p>
<p>Можно было бы пойти ещё дальше, и написать макрос, который выводит код, создающий выражение, но в образовательных целях можно попробовать для начала составить выражения вручную.</p>
<p>Для генерации функции нужно научиться генерировать строки 5 типов:</p>
<ul>
<li>Декларация функции <code>def initMemblock ( var memblock : Memblock, ...)</code></li>
<li>Присваивание  <code>memblock.a</code>count = aCount`</li>
<li>Объвление переменной <code>let aSize = typeinfo(sizeof *memblock.a) * aCount</code></li>
<li>Вызов функции <code>memblock.mem |&gt; resize(aSize + bSize + cSize)</code></li>
<li>Ещё одно присвание - <code>memblock.a = reinterpret&lt;int?&gt; addr(memblock.mem[0])</code></li>
</ul>
<p><strong><code>Декларация функции</code></strong></p>
<p>Практически готовый пример нужного кода есть в примерах из daScript-a <code>gen_field.das</code>.</p>
<figure class="shiki dascript"><div class="codeblock"><div class="code"><pre class="shiki slack-dark"><code><span class="line"><span style="color: #569CD6">def</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">generateStructureFields</span><span style="color: #E6E6E6">(</span><span style="color: #569CD6">var</span><span style="color: #E6E6E6"> </span><span style="color: #9CDCFE">st</span><span style="color: #E6E6E6">:StructurePtr)</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #6A9955">//create &quot;mem&quot; field of type array&lt;uint8&gt;</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> uint8Type </span><span style="color: #D4D4D4">&lt;-</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">new</span><span style="color: #E6E6E6"> [[TypeDecl() baseType</span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6">Type tUInt8]]</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> uint8ArrayType </span><span style="color: #D4D4D4">&lt;-</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">new</span><span style="color: #E6E6E6"> [[TypeDecl() baseType</span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6">Type tArray, firstType </span><span style="color: #D4D4D4">&lt;-</span><span style="color: #E6E6E6"> uint8Type]]</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">let</span><span style="color: #E6E6E6"> fieldsLen </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> st</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">fields </span><span style="color: #D4D4D4">|&gt;</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">length</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> ptrsCount </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #B5CEA8">0</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> ptrsTypeIndexes : </span><span style="color: #C586C0">array</span><span style="color: #D4D4D4">&lt;</span><span style="color: #4EC9B0">int</span><span style="color: #D4D4D4">&gt;</span></span>
<span class="line"><span style="color: #E6E6E6">    ptrsTypeIndexes </span><span style="color: #D4D4D4">|&gt;</span><span style="color: #E6E6E6"> reserve(fieldsLen)</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">for</span><span style="color: #E6E6E6"> i </span><span style="color: #C586C0">in</span><span style="color: #E6E6E6"> range(</span><span style="color: #B5CEA8">0</span><span style="color: #E6E6E6">, fieldsLen)</span></span>
<span class="line"><span style="color: #E6E6E6">        </span><span style="color: #C586C0">if</span><span style="color: #E6E6E6"> st</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">fields[i]</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">_type</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">baseType </span><span style="color: #D4D4D4">==</span><span style="color: #E6E6E6"> Type tPointer</span></span>
<span class="line"><span style="color: #E6E6E6">            ptrsCount</span><span style="color: #D4D4D4">++</span></span>
<span class="line"><span style="color: #E6E6E6">            ptrsTypeIndexes </span><span style="color: #D4D4D4">|&gt;</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">push</span><span style="color: #E6E6E6">(i) </span><span style="color: #6A9955">//сохраняем индексы полей-указателей</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #6A9955">//add one field for memblock and one field per pointer type to handle count of object per type</span></span>
<span class="line"><span style="color: #E6E6E6">    st</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">fields </span><span style="color: #D4D4D4">|&gt;</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">resize</span><span style="color: #E6E6E6">(fieldsLen</span><span style="color: #D4D4D4">+</span><span style="color: #E6E6E6"> ptrsCount </span><span style="color: #D4D4D4">+</span><span style="color: #E6E6E6"> </span><span style="color: #B5CEA8">1</span><span style="color: #E6E6E6">)</span></span>
<span class="line"><span style="color: #E6E6E6">    st</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">fields[</span><span style="color: #569CD6">fieldsLen</span><span style="color: #E6E6E6">] </span><span style="color: #D4D4D4">:=</span><span style="color: #E6E6E6"> </span><span style="color: #D4D4D4">*</span><span style="color: #C586C0">new</span><span style="color: #E6E6E6"> [[ FieldDeclaration() name</span><span style="color: #D4D4D4">:=</span><span style="color: #CE9178">&quot;mem&quot;</span><span style="color: #E6E6E6">, _type </span><span style="color: #D4D4D4">&lt;-</span><span style="color: #E6E6E6"> uint8ArrayType]]</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">for</span><span style="color: #E6E6E6"> i </span><span style="color: #C586C0">in</span><span style="color: #E6E6E6"> range(</span><span style="color: #B5CEA8">0</span><span style="color: #E6E6E6">, ptrsCount)</span></span>
<span class="line"><span style="color: #E6E6E6">        </span><span style="color: #C586C0">let</span><span style="color: #E6E6E6"> fieldCountName </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #CE9178">&quot;{</span><span style="color: #9CDCFE">st</span><span style="color: #D4D4D4">.</span><span style="color: #9CDCFE">fields</span><span style="color: #CE9178">[</span><span style="color: #569CD6">ptrsTypeIndexes</span><span style="color: #CE9178">[i]]</span><span style="color: #D4D4D4">.</span><span style="color: #9CDCFE">name</span><span style="color: #CE9178">}{&quot;`count&quot;}&quot;</span></span>
<span class="line"><span style="color: #E6E6E6">        st</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">fields[</span><span style="color: #569CD6">fieldsLen</span><span style="color: #E6E6E6">+1+i] </span><span style="color: #D4D4D4">:=</span><span style="color: #E6E6E6"> </span><span style="color: #D4D4D4">*</span><span style="color: #C586C0">new</span><span style="color: #E6E6E6"> [[ FieldDeclaration() name</span><span style="color: #D4D4D4">:=</span><span style="color: #E6E6E6">fieldCountName, _type </span><span style="color: #D4D4D4">&lt;-</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">new</span><span style="color: #E6E6E6"> [[TypeDecl() baseType</span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6">Type tInt]]]]</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">return</span><span style="color: #E6E6E6"> </span><span style="color: #D4D4D4">&lt;-</span><span style="color: #E6E6E6">ptrsTypeIndexes</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">//--------------------------</span></span>
<span class="line"><span style="color: #6A9955">// Генерация функции</span></span>
<span class="line"><span style="color: #569CD6">def</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">generateStructureInitFunction</span><span style="color: #E6E6E6">(</span><span style="color: #569CD6">var</span><span style="color: #E6E6E6"> </span><span style="color: #9CDCFE">st</span><span style="color: #E6E6E6">:StructurePtr; </span><span style="color: #9CDCFE">ptrsTypeIndexes</span><span style="color: #E6E6E6">:</span><span style="color: #C586C0">array</span><span style="color: #D4D4D4">&lt;</span><span style="color: #4EC9B0">int</span><span style="color: #D4D4D4">&gt;&amp;</span><span style="color: #E6E6E6">)</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">let</span><span style="color: #E6E6E6"> ptrFieldsLen </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> ptrsTypeIndexes </span><span style="color: #D4D4D4">|&gt;</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">length</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">let</span><span style="color: #E6E6E6"> fnname </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #CE9178">&quot;init`struct`{</span><span style="color: #9CDCFE">st</span><span style="color: #D4D4D4">.</span><span style="color: #9CDCFE">name</span><span style="color: #CE9178">}&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #6A9955">//генерируем объявление функции с именем init`struct`ИмяСтрутуры</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> fn </span><span style="color: #D4D4D4">&lt;-</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">new</span><span style="color: #E6E6E6"> [[Function() at</span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6">st</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">at, atDecl</span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6">st</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">at, name</span><span style="color: #D4D4D4">:=</span><span style="color: #E6E6E6">fnname]]</span></span>
<span class="line"><span style="color: #E6E6E6">    fn</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">flags </span><span style="color: #D4D4D4">|=</span><span style="color: #E6E6E6"> FunctionFlags generated</span></span>
<span class="line"><span style="color: #E6E6E6">    fn</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">flags </span><span style="color: #D4D4D4">|=</span><span style="color: #E6E6E6"> FunctionFlags privateFunction</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #6A9955">//генерируем список аргументов и тип результата функции</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">unsafe</span></span>
<span class="line"><span style="color: #E6E6E6">        fn</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">arguments </span><span style="color: #D4D4D4">|&gt;</span><span style="color: #E6E6E6"> emplace_new </span><span style="color: #D4D4D4">&lt;|</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">new</span><span style="color: #E6E6E6"> [[Variable() at</span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6">st</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">at, name</span><span style="color: #D4D4D4">:=</span><span style="color: #E6E6E6"> </span><span style="color: #CE9178">&quot;memblock&quot;</span><span style="color: #E6E6E6">, _type </span><span style="color: #D4D4D4">&lt;-</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">new</span><span style="color: #E6E6E6"> [[TypeDecl() baseType</span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6">Type tStructure, structType</span><span style="color: #D4D4D4">=</span><span style="color: #C586C0">addr</span><span style="color: #E6E6E6">(</span><span style="color: #D4D4D4">*</span><span style="color: #E6E6E6">st)]]]]</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">for</span><span style="color: #E6E6E6"> i </span><span style="color: #C586C0">in</span><span style="color: #E6E6E6"> range(</span><span style="color: #B5CEA8">0</span><span style="color: #E6E6E6">, ptrFieldsLen)</span></span>
<span class="line"><span style="color: #E6E6E6">        </span><span style="color: #C586C0">let</span><span style="color: #E6E6E6"> argumentName </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #CE9178">&quot;{</span><span style="color: #9CDCFE">st</span><span style="color: #D4D4D4">.</span><span style="color: #9CDCFE">fields</span><span style="color: #CE9178">[</span><span style="color: #569CD6">ptrsTypeIndexes</span><span style="color: #CE9178">[i]]</span><span style="color: #D4D4D4">.</span><span style="color: #9CDCFE">name</span><span style="color: #CE9178">}`count&quot;</span></span>
<span class="line"><span style="color: #E6E6E6">        fn</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">arguments </span><span style="color: #D4D4D4">|&gt;</span><span style="color: #E6E6E6"> emplace_new </span><span style="color: #D4D4D4">&lt;|</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">new</span><span style="color: #E6E6E6"> [[Variable() at</span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6">st</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">at, name</span><span style="color: #D4D4D4">:=</span><span style="color: #E6E6E6"> argumentName,  _type </span><span style="color: #D4D4D4">&lt;-</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">new</span><span style="color: #E6E6E6"> [[TypeDecl() baseType</span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6">Type tInt]] ]]</span></span>
<span class="line"><span style="color: #E6E6E6">    fn</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">result </span><span style="color: #D4D4D4">&lt;-</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">new</span><span style="color: #E6E6E6"> [[TypeDecl() baseType</span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6">Type tVoid, at</span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6">st</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">at]]</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #6A9955">//генерируем тело функции, пока просто вызов `print(&quot;Hello, world!&quot;)`</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> blk </span><span style="color: #D4D4D4">&lt;-</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">new</span><span style="color: #E6E6E6"> [[ExprBlock() at</span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6">st</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">at]]</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> printF </span><span style="color: #D4D4D4">&lt;-</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">new</span><span style="color: #E6E6E6"> [[ExprCall() name</span><span style="color: #D4D4D4">:=</span><span style="color: #CE9178">&quot;print&quot;</span><span style="color: #E6E6E6">]]</span></span>
<span class="line"><span style="color: #E6E6E6">    printF</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">arguments </span><span style="color: #D4D4D4">|&gt;</span><span style="color: #E6E6E6"> emplace_new </span><span style="color: #D4D4D4">&lt;|</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">new</span><span style="color: #E6E6E6"> [[ExprConstString() value</span><span style="color: #D4D4D4">:=</span><span style="color: #CE9178">&quot;Hello, world!</span><span style="color: #D7BA7D">\n</span><span style="color: #CE9178">&quot;</span><span style="color: #E6E6E6">]]</span></span>
<span class="line"><span style="color: #E6E6E6">    blk</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">list </span><span style="color: #D4D4D4">|&gt;</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">emplace</span><span style="color: #E6E6E6">(printF)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E6E6E6">    fn</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">body </span><span style="color: #D4D4D4">&lt;-</span><span style="color: #E6E6E6"> blk</span></span>
<span class="line"><span style="color: #E6E6E6">    compiling_module() </span><span style="color: #D4D4D4">|&gt;</span><span style="color: #E6E6E6"> add_function(fn)</span></span></code></pre></div></div></figure>
<p>Теперь если сгенерировать макросом функцию, и передать эту функцию в макрос, который возвращает исходный текст функции, то получится такой результат:</p>
<figure class="shiki dascript"><div class="codeblock"><div class="code"><pre class="shiki slack-dark"><code><span class="line"><span style="color: #C586C0">def</span><span style="color: #E6E6E6"> init`</span><span style="color: #C586C0">struct</span><span style="color: #E6E6E6">`Memblock ( </span><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> memblock : Memblock; </span><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> a`count : </span><span style="color: #4EC9B0">int</span><span style="color: #E6E6E6">; </span><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> b`count : </span><span style="color: #4EC9B0">int</span><span style="color: #E6E6E6">; </span><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> c`count : </span><span style="color: #4EC9B0">int</span><span style="color: #E6E6E6"> )</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #DCDCAA">print</span><span style="color: #E6E6E6">(</span><span style="color: #CE9178">&quot;Hello, world!&quot;</span><span style="color: #E6E6E6">,__context__)</span></span></code></pre></div></div></figure>
<p><strong><code>Присваивание и объявление переменной</code></strong></p>
<figure class="shiki dascript"><div class="codeblock"><div class="code"><pre class="shiki slack-dark"><code><span class="line"><span style="color: #6A9955">//-------------------------</span></span>
<span class="line"><span style="color: #6A9955">//1. Make Expressions</span></span>
<span class="line"><span style="color: #6A9955">//-------------------------</span></span>
<span class="line"><span style="color: #6A9955">//memblock.a`count = aCount</span></span>
<span class="line"><span style="color: #6A9955">//  ExprVar memblock. ExprField a`count ExprCopyRight = ExprVar aCount</span></span>
<span class="line"><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> exprVar_memblock </span><span style="color: #D4D4D4">&lt;-</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">new</span><span style="color: #E6E6E6"> [[ExprVar() name</span><span style="color: #D4D4D4">:=</span><span style="color: #CE9178">&quot;memblock&quot;</span><span style="color: #E6E6E6">]]</span></span>
<span class="line"><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> exprField_acount </span><span style="color: #D4D4D4">&lt;-</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">new</span><span style="color: #E6E6E6"> [[ExprField() name</span><span style="color: #D4D4D4">:=</span><span style="color: #CE9178">&quot;a`count&quot;</span><span style="color: #E6E6E6">, value </span><span style="color: #D4D4D4">&lt;-</span><span style="color: #E6E6E6"> exprVar_memblock]]</span></span>
<span class="line"><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> exprVar_acount </span><span style="color: #D4D4D4">&lt;-</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">new</span><span style="color: #E6E6E6"> [[ExprVar() name</span><span style="color: #D4D4D4">:=</span><span style="color: #CE9178">&quot;a`count&quot;</span><span style="color: #E6E6E6">]]</span></span>
<span class="line"><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> exprCopy </span><span style="color: #D4D4D4">&lt;-</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">new</span><span style="color: #E6E6E6"> [[ExprCopy() op</span><span style="color: #D4D4D4">:=</span><span style="color: #CE9178">&quot;=&quot;</span><span style="color: #E6E6E6">, left </span><span style="color: #D4D4D4">&lt;-</span><span style="color: #E6E6E6"> exprField_acount, right </span><span style="color: #D4D4D4">&lt;-</span><span style="color: #E6E6E6"> exprVar_acount]]</span></span>
<span class="line"><span style="color: #E6E6E6">blk</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">list </span><span style="color: #D4D4D4">|&gt;</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">emplace</span><span style="color: #E6E6E6">(exprCopy)</span></span></code></pre></div></div></figure>
<p>Тут всё достаточно тривиально, пока составляем только первую строку “memblock.a`count = aCount”</p>
<figure class="shiki dascript"><div class="codeblock"><div class="code"><pre class="shiki slack-dark"><code><span class="line"><span style="color: #6A9955">//-------------------------</span></span>
<span class="line"><span style="color: #6A9955">//2. Quotes</span></span>
<span class="line"><span style="color: #6A9955">//-------------------------</span></span>
<span class="line"><span style="color: #6A9955">//let aSize = typeinfo(sizeof *memblock.a) * aCount</span></span>
<span class="line"><span style="color: #6A9955">//  ExprLet var  ExprLetVariable aSize : int const =  ExprOp2(ExprVar aCount ExprOp2Right * 4)</span></span>
<span class="line"><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> exprLet_aSize_value </span><span style="color: #D4D4D4">&lt;-</span><span style="color: #E6E6E6"> quote(</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">typeinfo</span><span style="color: #E6E6E6">(sizeof </span><span style="color: #D4D4D4">*</span><span style="color: #E6E6E6"> memblock</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">a) </span><span style="color: #D4D4D4">*</span><span style="color: #E6E6E6"> a`count</span></span>
<span class="line"><span style="color: #E6E6E6">)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> exprLet_aSize </span><span style="color: #D4D4D4">&lt;-</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">new</span><span style="color: #E6E6E6"> [[ExprLet()]]</span></span>
<span class="line"><span style="color: #E6E6E6">exprLet_aSize</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">variables </span><span style="color: #D4D4D4">|&gt;</span><span style="color: #E6E6E6"> emplace_new() </span><span style="color: #D4D4D4">&lt;|</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">new</span><span style="color: #E6E6E6"> [[Variable()</span></span>
<span class="line"><span style="color: #E6E6E6">    name </span><span style="color: #D4D4D4">:=</span><span style="color: #E6E6E6"> </span><span style="color: #CE9178">&quot;aSize&quot;</span><span style="color: #E6E6E6">,</span></span>
<span class="line"><span style="color: #E6E6E6">    _type </span><span style="color: #D4D4D4">&lt;-</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">new</span><span style="color: #E6E6E6"> [[TypeDecl() baseType</span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6">Type tInt]],</span></span>
<span class="line"><span style="color: #E6E6E6">    init </span><span style="color: #D4D4D4">&lt;-</span><span style="color: #E6E6E6"> exprLet_aSize_value</span></span>
<span class="line"><span style="color: #E6E6E6">]]</span></span>
<span class="line"><span style="color: #E6E6E6">blk</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">list </span><span style="color: #D4D4D4">|&gt;</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">emplace</span><span style="color: #E6E6E6">(exprLet_aSize)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">//prevent drop unused code</span></span>
<span class="line"><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> exprCall_printUnused </span><span style="color: #D4D4D4">&lt;-</span><span style="color: #E6E6E6"> quote(</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #DCDCAA">print</span><span style="color: #E6E6E6">(</span><span style="color: #CE9178">&quot;{</span><span style="color: #9CDCFE">aSize</span><span style="color: #CE9178">}&quot;</span><span style="color: #E6E6E6">)</span></span>
<span class="line"><span style="color: #E6E6E6">)</span></span>
<span class="line"><span style="color: #E6E6E6">blk</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">list </span><span style="color: #D4D4D4">|&gt;</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">emplace</span><span style="color: #E6E6E6">(exprCall_printUnused)</span></span></code></pre></div></div></figure>
<p>При генерации следующей строки можно заметить, что:</p>
<ul>
<li>макрос ast_print_expression не описал выражение “typeinfo(sizeof *memblock.a)”, а вместо этого вывел его результат. Это происходит потому, что макрос был применён к уже сгенерированной и оптимизированной функции, для которой часть выражений может быть вычислена компилятором.</li>
<li>макрос ast_print, применённый к сгенерированной функции, не показывает неиспользуемые переменные, так как они были выброшены компилятором, так что увидеть их можно, если добавить использование (print”{aSize}” в данном случае).</li>
</ul>
<p>Кроме генерации выражений, здесь показано использование макроса <code>quote</code>, который превращает код в выражение:<br><figure class="shiki dascript"><div class="codeblock"><div class="code"><pre class="shiki slack-dark"><code><span class="line"><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> exprLet_aSize_value </span><span style="color: #D4D4D4">&lt;-</span><span style="color: #E6E6E6"> quote(</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">typeinfo</span><span style="color: #E6E6E6">(sizeof </span><span style="color: #D4D4D4">*</span><span style="color: #E6E6E6"> memblock</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">a) </span><span style="color: #D4D4D4">*</span><span style="color: #E6E6E6"> a`count</span></span>
<span class="line"><span style="color: #E6E6E6">)</span></span></code></pre></div></div></figure></p>
<p>Вот <a target="_blank" rel="noopener" href="https://github.com/GaijinEntertainment/daScript/blob/726d440be7618fb431815b18e6f785c37a335d5d/examples/test/misc/template_example.das">пример</a> (<a target="_blank" rel="noopener" href="https://github.com/spiiin/dascript_macro_tutorial/blob/master/examples/template_example.das">Fixed version</a>) более продвинутого использования цитирования, с возможностью задать правила переписывания выражения. Это можно использовать для того, чтобы перейти от явного указания названия поля структуры к переменной, в которую можно передать любое имя или выражение:</p>
<figure class="shiki dascript"><div class="codeblock"><div class="code"><pre class="shiki slack-dark"><code><span class="line"><span style="color: #C586C0">require</span><span style="color: #E6E6E6"> daslib</span><span style="color: #D4D4D4">/</span><span style="color: #E6E6E6">templates</span></span>
<span class="line"><span style="color: #C586C0">require</span><span style="color: #E6E6E6"> daslib</span><span style="color: #D4D4D4">/</span><span style="color: #E6E6E6">templates_boost</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">//-------------------------</span></span>
<span class="line"><span style="color: #6A9955">//2. Quotes and templates</span></span>
<span class="line"><span style="color: #6A9955">//-------------------------</span></span>
<span class="line"><span style="color: #6A9955">//let aSize = typeinfo(sizeof *memblock.a) * aCount</span></span>
<span class="line"><span style="color: #6A9955">//  ExprLet var  ExprLetVariable aSize : int const =  ExprOp2(ExprVar aCount ExprOp2Right * 4)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C586C0">for</span><span style="color: #E6E6E6"> i </span><span style="color: #C586C0">in</span><span style="color: #E6E6E6"> range(</span><span style="color: #B5CEA8">0</span><span style="color: #E6E6E6">, ptrFieldsLen)</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">let</span><span style="color: #E6E6E6"> argumentName </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #CE9178">&quot;{</span><span style="color: #9CDCFE">st</span><span style="color: #D4D4D4">.</span><span style="color: #9CDCFE">fields</span><span style="color: #CE9178">[</span><span style="color: #569CD6">ptrsTypeIndexes</span><span style="color: #CE9178">[i]]</span><span style="color: #D4D4D4">.</span><span style="color: #9CDCFE">name</span><span style="color: #CE9178">}&quot;</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> exprLet_aSize_value </span><span style="color: #D4D4D4">&lt;-</span><span style="color: #E6E6E6"> quote(</span></span>
<span class="line"><span style="color: #E6E6E6">        </span><span style="color: #C586C0">typeinfo</span><span style="color: #E6E6E6">(sizeof </span><span style="color: #D4D4D4">*</span><span style="color: #E6E6E6">ELEMENT) </span><span style="color: #D4D4D4">*</span><span style="color: #E6E6E6"> ELEMENTS_COUNT</span></span>
<span class="line"><span style="color: #E6E6E6">    )</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> exprVar_memblock2 </span><span style="color: #D4D4D4">&lt;-</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">new</span><span style="color: #E6E6E6"> [[ExprVar() name</span><span style="color: #D4D4D4">:=</span><span style="color: #CE9178">&quot;memblock&quot;</span><span style="color: #E6E6E6">]]</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> exprField_acount2 </span><span style="color: #D4D4D4">&lt;-</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">new</span><span style="color: #E6E6E6"> [[ExprField() name</span><span style="color: #D4D4D4">:=</span><span style="color: #E6E6E6">argumentName, value </span><span style="color: #D4D4D4">&lt;-</span><span style="color: #E6E6E6"> exprVar_memblock2]]</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> exprLet_rules : Template                                               </span><span style="color: #6A9955">//правила переписывания выражения</span></span>
<span class="line"><span style="color: #E6E6E6">    exprLet_rules </span><span style="color: #D4D4D4">|&gt;</span><span style="color: #E6E6E6"> replaceVariable(</span><span style="color: #CE9178">&quot;ELEMENT&quot;</span><span style="color: #E6E6E6">, exprField_acount2)             </span><span style="color: #6A9955">//подставляем выражение</span></span>
<span class="line"><span style="color: #E6E6E6">    exprLet_rules </span><span style="color: #D4D4D4">|&gt;</span><span style="color: #E6E6E6"> renameVariable(</span><span style="color: #CE9178">&quot;ELEMENTS_COUNT&quot;</span><span style="color: #E6E6E6">, </span><span style="color: #CE9178">&quot;{</span><span style="color: #9CDCFE">argumentName</span><span style="color: #CE9178">}`count&quot;</span><span style="color: #E6E6E6">)  </span><span style="color: #6A9955">//подставляем имя переменной</span></span>
<span class="line"><span style="color: #E6E6E6">    apply_template(exprLet_rules, exprLet_aSize_value</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">at, exprLet_aSize_value)</span></span>
<span class="line"><span style="color: #E6E6E6">    </span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> exprLet_aSize </span><span style="color: #D4D4D4">&lt;-</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">new</span><span style="color: #E6E6E6"> [[ExprLet()]]</span></span>
<span class="line"><span style="color: #E6E6E6">    exprLet_aSize</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">variables </span><span style="color: #D4D4D4">|&gt;</span><span style="color: #E6E6E6"> emplace_new() </span><span style="color: #D4D4D4">&lt;|</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">new</span><span style="color: #E6E6E6"> [[Variable()</span></span>
<span class="line"><span style="color: #E6E6E6">        name </span><span style="color: #D4D4D4">:=</span><span style="color: #E6E6E6"> </span><span style="color: #CE9178">&quot;{</span><span style="color: #9CDCFE">argumentName</span><span style="color: #CE9178">}Size&quot;</span><span style="color: #E6E6E6">,</span></span>
<span class="line"><span style="color: #E6E6E6">        _type </span><span style="color: #D4D4D4">&lt;-</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">new</span><span style="color: #E6E6E6"> [[TypeDecl() baseType</span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6">Type tInt]],</span></span>
<span class="line"><span style="color: #E6E6E6">        init </span><span style="color: #D4D4D4">&lt;-</span><span style="color: #E6E6E6"> exprLet_aSize_value</span></span>
<span class="line"><span style="color: #E6E6E6">    ]]</span></span>
<span class="line"><span style="color: #E6E6E6">    blk</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">list </span><span style="color: #D4D4D4">|&gt;</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">emplace</span><span style="color: #E6E6E6">(exprLet_aSize)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #6A9955">//Временно руками добавляем код использования переменных, чтобы их не отбросил компилятор</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> exprCall_printUnused </span><span style="color: #D4D4D4">&lt;-</span><span style="color: #E6E6E6"> quote(</span></span>
<span class="line"><span style="color: #E6E6E6">        </span><span style="color: #DCDCAA">print</span><span style="color: #E6E6E6">(</span><span style="color: #CE9178">&quot;{</span><span style="color: #9CDCFE">aSize</span><span style="color: #CE9178">},{</span><span style="color: #9CDCFE">bSize</span><span style="color: #CE9178">},{</span><span style="color: #9CDCFE">cSize</span><span style="color: #CE9178">}&quot;</span><span style="color: #E6E6E6">)</span></span>
<span class="line"><span style="color: #E6E6E6">    blk</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">list </span><span style="color: #D4D4D4">|&gt;</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">emplace</span><span style="color: #E6E6E6">(exprCall_printUnused)</span></span></code></pre></div></div></figure>
<p>Половина кода генерации написана, нужно двигаться дальше.</p>
<p><strong><code>Вызов функции memblock.mem |&gt; resize(aSize + bSize + cSize)</code></strong></p>
<p>Здесь есть небольшая хитрость. Строка <code>aSize + bSize + cSize</code>, трансформируется в выражение:<br><figure class="shiki dascript"><div class="codeblock"><div class="code"><pre class="shiki slack-dark"><code><span class="line"><span style="color: #E6E6E6">ExprOp2( ExprOp2(ExprVar aSize ExprOp2Right </span><span style="color: #D4D4D4">+</span><span style="color: #E6E6E6"> ExprVar bSize) ExprOp2Right </span><span style="color: #D4D4D4">+</span><span style="color: #E6E6E6"> ExprVar cSize))</span></span></code></pre></div></div></figure></p>
<p>У выражения есть определённый шаблон:<br><figure class="shiki dascript"><div class="codeblock"><div class="code"><pre class="shiki slack-dark"><code><span class="line"><span style="color: #E6E6E6">((((a</span><span style="color: #D4D4D4">+</span><span style="color: #E6E6E6">b)</span><span style="color: #D4D4D4">+</span><span style="color: #E6E6E6">c)</span><span style="color: #D4D4D4">+</span><span style="color: #E6E6E6">d)</span><span style="color: #D4D4D4">+...</span><span style="color: #E6E6E6">)</span></span></code></pre></div></div></figure></p>
<p>Подобные выражения удобно сгенерировать с помощью функции <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Fold_(higher-order_function">свёртки</a>). Я зачём-то использовал правостороннюю свёртку, но для ассоциативных операторов конечный результат будет одинаковым (не нашёл готовой в стандартной библиотеке):</p>
<figure class="shiki dascript"><div class="codeblock"><div class="code"><pre class="shiki slack-dark"><code><span class="line"><span style="color: #569CD6">def</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">foldR</span><span style="color: #E6E6E6">(</span><span style="color: #569CD6">var</span><span style="color: #E6E6E6"> </span><span style="color: #9CDCFE">a</span><span style="color: #E6E6E6">:</span><span style="color: #C586C0">array</span><span style="color: #D4D4D4">&lt;</span><span style="color: #E6E6E6">ExpressionPtr</span><span style="color: #D4D4D4">&gt;</span><span style="color: #E6E6E6">; </span><span style="color: #9CDCFE">foldOp</span><span style="color: #E6E6E6">:</span><span style="color: #4EC9B0">function</span><span style="color: #D4D4D4">&lt;</span><span style="color: #E6E6E6">(arg1, arg2: </span><span style="color: #9CDCFE">ExpressionPtr</span><span style="color: #E6E6E6">) : ExpressionPtr</span><span style="color: #D4D4D4">&gt;</span><span style="color: #E6E6E6"> )</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">let</span><span style="color: #E6E6E6"> aLen </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> a </span><span style="color: #D4D4D4">|&gt;</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">length</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> from </span><span style="color: #D4D4D4">&lt;-</span><span style="color: #E6E6E6"> a[</span><span style="color: #569CD6">aLen</span><span style="color: #E6E6E6">-1]</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">for</span><span style="color: #E6E6E6"> i </span><span style="color: #C586C0">in</span><span style="color: #E6E6E6"> range(</span><span style="color: #B5CEA8">1</span><span style="color: #E6E6E6">, aLen)</span></span>
<span class="line"><span style="color: #E6E6E6">        from </span><span style="color: #D4D4D4">:=</span><span style="color: #E6E6E6"> foldOp </span><span style="color: #D4D4D4">|&gt;</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">invoke</span><span style="color: #E6E6E6">(a[</span><span style="color: #569CD6">aLen</span><span style="color: #E6E6E6">-1-i], from)</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">return</span><span style="color: #E6E6E6"> from</span></span>
<span class="line"></span>
<span class="line"><span style="color: #569CD6">def</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">makeSumExpr</span><span style="color: #E6E6E6">(</span><span style="color: #9CDCFE">a, b</span><span style="color: #E6E6E6">: ExpressionPtr </span><span style="color: #569CD6">const</span><span style="color: #E6E6E6">): ExpressionPtr</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">return</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">new</span><span style="color: #E6E6E6"> [[ExprOp2() op</span><span style="color: #D4D4D4">:=</span><span style="color: #CE9178">&quot;+&quot;</span><span style="color: #E6E6E6">, left </span><span style="color: #D4D4D4">:=</span><span style="color: #E6E6E6"> a, right </span><span style="color: #D4D4D4">:=</span><span style="color: #E6E6E6"> b]]</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">//-------------------------</span></span>
<span class="line"><span style="color: #6A9955">// 3. Foldr</span></span>
<span class="line"><span style="color: #6A9955">//-------------------------</span></span>
<span class="line"><span style="color: #6A9955">//memblock.mem |&gt; resize(aSize + bSize + cSize)</span></span>
<span class="line"><span style="color: #6A9955">//     ExprCall __::builtin`resize( ExprCallArgument ExprVar memblock. ExprField mem, ExprCallArgument  ExprOp2( ExprOp2(ExprVar aSize ExprOp2Right + ExprVar bSize) ExprOp2Right + ExprVar cSize))</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> sumArgumentsArray: </span><span style="color: #C586C0">array</span><span style="color: #D4D4D4">&lt;</span><span style="color: #E6E6E6">ExpressionPtr</span><span style="color: #D4D4D4">&gt;</span></span>
<span class="line"><span style="color: #C586C0">for</span><span style="color: #E6E6E6"> i </span><span style="color: #C586C0">in</span><span style="color: #E6E6E6"> range(</span><span style="color: #B5CEA8">0</span><span style="color: #E6E6E6">, ptrFieldsLen) </span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">let</span><span style="color: #E6E6E6"> argumentName </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #CE9178">&quot;{</span><span style="color: #9CDCFE">st</span><span style="color: #D4D4D4">.</span><span style="color: #9CDCFE">fields</span><span style="color: #CE9178">[</span><span style="color: #569CD6">ptrsTypeIndexes</span><span style="color: #CE9178">[i]]</span><span style="color: #D4D4D4">.</span><span style="color: #9CDCFE">name</span><span style="color: #CE9178">}&quot;</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">let</span><span style="color: #E6E6E6"> nameSize </span><span style="color: #D4D4D4">:=</span><span style="color: #E6E6E6"> </span><span style="color: #CE9178">&quot;{</span><span style="color: #9CDCFE">argumentName</span><span style="color: #CE9178">}Size&quot;</span></span>
<span class="line"><span style="color: #E6E6E6">    sumArgumentsArray </span><span style="color: #D4D4D4">|&gt;</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">emplace</span><span style="color: #E6E6E6">(</span><span style="color: #C586C0">new</span><span style="color: #E6E6E6"> [[ExprVar() name</span><span style="color: #D4D4D4">:=</span><span style="color: #E6E6E6">nameSize]])</span></span>
<span class="line"><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> sumExpr </span><span style="color: #D4D4D4">&lt;-</span><span style="color: #E6E6E6"> foldR(sumArgumentsArray, @@makeSumExpr) </span><span style="color: #6A9955">//ага, свёртка массива в выражение</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">//--------</span></span>
<span class="line"><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> exprLet_totalSize </span><span style="color: #D4D4D4">&lt;-</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">new</span><span style="color: #E6E6E6"> [[ExprLet()]]</span></span>
<span class="line"><span style="color: #E6E6E6">exprLet_totalSize</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">variables </span><span style="color: #D4D4D4">|&gt;</span><span style="color: #E6E6E6"> emplace_new() </span><span style="color: #D4D4D4">&lt;|</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">new</span><span style="color: #E6E6E6"> [[Variable()</span></span>
<span class="line"><span style="color: #E6E6E6">    name </span><span style="color: #D4D4D4">:=</span><span style="color: #E6E6E6"> </span><span style="color: #CE9178">&quot;totalSize&quot;</span><span style="color: #E6E6E6">,</span></span>
<span class="line"><span style="color: #E6E6E6">    _type </span><span style="color: #D4D4D4">&lt;-</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">new</span><span style="color: #E6E6E6"> [[TypeDecl() baseType</span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6">Type tInt]],</span></span>
<span class="line"><span style="color: #E6E6E6">    init </span><span style="color: #D4D4D4">&lt;-</span><span style="color: #E6E6E6"> sumExpr</span></span>
<span class="line"><span style="color: #E6E6E6">]]</span></span>
<span class="line"><span style="color: #E6E6E6">blk</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">list </span><span style="color: #D4D4D4">|&gt;</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">emplace</span><span style="color: #E6E6E6">(exprLet_totalSize)</span></span>
<span class="line"><span style="color: #6A9955">//prevent drop unused code</span></span>
<span class="line"><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> exprCall_printUnused2 </span><span style="color: #D4D4D4">&lt;-</span><span style="color: #E6E6E6"> quote(</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #DCDCAA">print</span><span style="color: #E6E6E6">(</span><span style="color: #CE9178">&quot;{</span><span style="color: #9CDCFE">totalSize</span><span style="color: #CE9178">}&quot;</span><span style="color: #E6E6E6">)</span></span>
<span class="line"><span style="color: #E6E6E6">)</span></span>
<span class="line"><span style="color: #E6E6E6">blk</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">list </span><span style="color: #D4D4D4">|&gt;</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">emplace</span><span style="color: #E6E6E6">(exprCall_printUnused2)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">//сгенерирует код:</span></span>
<span class="line"><span style="color: #6A9955">//let totalSize : int = (aSize + (bSize + cSize))</span></span>
<span class="line"><span style="color: #6A9955">//__::builtin`resize(memblock.mem,totalSize)</span></span></code></pre></div></div></figure>
<p>(__::builtin`resize здесь просто замангленное название встроенной функции resize)</p>
<p><strong><code>memblock.a = reinterpret&lt;int?&gt; addr(memblock.mem[0])</code></strong></p>
<p>Можно немного изменить функцию <code>foldr</code>, чтобы она могла генерировать частичные суммы для получения кода вида:<br><figure class="shiki dascript"><div class="codeblock"><div class="code"><pre class="shiki slack-dark"><code><span class="line"><span style="color: #E6E6E6">memblock</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">a </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">reinterpret</span><span style="color: #D4D4D4">&lt;</span><span style="color: #4EC9B0">int</span><span style="color: #E6E6E6">?</span><span style="color: #D4D4D4">&gt;</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">addr</span><span style="color: #E6E6E6">(memblock</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">mem[</span><span style="color: #B5CEA8">0</span><span style="color: #E6E6E6">])</span></span>
<span class="line"><span style="color: #E6E6E6">memblock</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">b </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">reinterpret</span><span style="color: #D4D4D4">&lt;</span><span style="color: #4EC9B0">float</span><span style="color: #E6E6E6">?</span><span style="color: #D4D4D4">&gt;</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">addr</span><span style="color: #E6E6E6">(memblock</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">mem[(aSize </span><span style="color: #D4D4D4">+</span><span style="color: #E6E6E6"> </span><span style="color: #B5CEA8">0</span><span style="color: #E6E6E6">)])</span></span>
<span class="line"><span style="color: #E6E6E6">memblock</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">c </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">reinterpret</span><span style="color: #D4D4D4">&lt;</span><span style="color: #4EC9B0">int</span><span style="color: #E6E6E6">?</span><span style="color: #D4D4D4">&gt;</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">addr</span><span style="color: #E6E6E6">(memblock</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">mem[(aSize </span><span style="color: #D4D4D4">+</span><span style="color: #E6E6E6"> (bSize </span><span style="color: #D4D4D4">+</span><span style="color: #E6E6E6"> </span><span style="color: #B5CEA8">0</span><span style="color: #E6E6E6">))])</span></span>
<span class="line"><span style="color: #D4D4D4">...</span></span></code></pre></div></div></figure></p>
<figure class="shiki dascript"><div class="codeblock"><div class="code"><pre class="shiki slack-dark"><code><span class="line"><span style="color: #6A9955">//теперь можно задать, какую часть массива превратить в выражение</span></span>
<span class="line"><span style="color: #569CD6">def</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">foldR_partial</span><span style="color: #E6E6E6">(</span><span style="color: #569CD6">var</span><span style="color: #E6E6E6"> </span><span style="color: #9CDCFE">a</span><span style="color: #E6E6E6">:</span><span style="color: #C586C0">array</span><span style="color: #D4D4D4">&lt;</span><span style="color: #E6E6E6">ExpressionPtr</span><span style="color: #D4D4D4">&gt;</span><span style="color: #E6E6E6">; </span><span style="color: #9CDCFE">foldOp</span><span style="color: #E6E6E6">:</span><span style="color: #4EC9B0">function</span><span style="color: #D4D4D4">&lt;</span><span style="color: #E6E6E6">(arg1, arg2: </span><span style="color: #9CDCFE">ExpressionPtr</span><span style="color: #E6E6E6">) : ExpressionPtr</span><span style="color: #D4D4D4">&gt;</span><span style="color: #E6E6E6">; initial: ExpressionPtr; endIndex:</span><span style="color: #4EC9B0">int</span><span style="color: #E6E6E6">)</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">let</span><span style="color: #E6E6E6"> aLen </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> a </span><span style="color: #D4D4D4">|&gt;</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">length</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> from </span><span style="color: #D4D4D4">:=</span><span style="color: #E6E6E6"> initial</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">for</span><span style="color: #E6E6E6"> i </span><span style="color: #C586C0">in</span><span style="color: #E6E6E6"> range(endIndex, aLen)</span></span>
<span class="line"><span style="color: #E6E6E6">        from </span><span style="color: #D4D4D4">:=</span><span style="color: #E6E6E6"> foldOp </span><span style="color: #D4D4D4">|&gt;</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">invoke</span><span style="color: #E6E6E6">(a[</span><span style="color: #569CD6">aLen</span><span style="color: #E6E6E6">-1-i], from)</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">return</span><span style="color: #E6E6E6"> from</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> exprCall_resize </span><span style="color: #D4D4D4">&lt;-</span><span style="color: #E6E6E6"> quote(</span></span>
<span class="line"><span style="color: #E6E6E6">        memblock</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">mem </span><span style="color: #D4D4D4">|&gt;</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">resize</span><span style="color: #E6E6E6">(totalSize)</span></span>
<span class="line"><span style="color: #E6E6E6">    )</span></span>
<span class="line"><span style="color: #E6E6E6">    blk</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">list </span><span style="color: #D4D4D4">|&gt;</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">emplace</span><span style="color: #E6E6E6">(exprCall_resize)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">//-------------------------</span></span>
<span class="line"><span style="color: #6A9955">// 4. castType</span></span>
<span class="line"><span style="color: #6A9955">//-------------------------</span></span>
<span class="line"><span style="color: #6A9955">//memblock.a = reinterpret&lt;int?&gt; addr(memblock.mem[0])</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C586C0">for</span><span style="color: #E6E6E6"> i </span><span style="color: #C586C0">in</span><span style="color: #E6E6E6"> range(</span><span style="color: #B5CEA8">0</span><span style="color: #E6E6E6">, ptrFieldsLen)</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">let</span><span style="color: #E6E6E6"> argumentName </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #CE9178">&quot;{</span><span style="color: #9CDCFE">st</span><span style="color: #D4D4D4">.</span><span style="color: #9CDCFE">fields</span><span style="color: #CE9178">[</span><span style="color: #569CD6">ptrsTypeIndexes</span><span style="color: #CE9178">[i]]</span><span style="color: #D4D4D4">.</span><span style="color: #9CDCFE">name</span><span style="color: #CE9178">}&quot;</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> exprVar_memblock </span><span style="color: #D4D4D4">&lt;-</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">new</span><span style="color: #E6E6E6"> [[ExprVar() name</span><span style="color: #D4D4D4">:=</span><span style="color: #CE9178">&quot;memblock&quot;</span><span style="color: #E6E6E6">]]</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> exprField_a </span><span style="color: #D4D4D4">&lt;-</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">new</span><span style="color: #E6E6E6"> [[ExprField() name</span><span style="color: #D4D4D4">:=</span><span style="color: #E6E6E6">argumentName, value </span><span style="color: #D4D4D4">&lt;-</span><span style="color: #E6E6E6"> exprVar_memblock]]</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> exprAddr </span><span style="color: #D4D4D4">&lt;-</span><span style="color: #E6E6E6"> quote(</span></span>
<span class="line"><span style="color: #E6E6E6">        </span><span style="color: #C586C0">addr</span><span style="color: #E6E6E6">(memblock</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">mem[</span><span style="color: #569CD6">START_ADDRESS</span><span style="color: #E6E6E6">])</span></span>
<span class="line"><span style="color: #E6E6E6">    )</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> exprZero </span><span style="color: #D4D4D4">&lt;-</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">new</span><span style="color: #E6E6E6"> [[ExprConstInt() value</span><span style="color: #D4D4D4">=</span><span style="color: #B5CEA8">0</span><span style="color: #E6E6E6">]]</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> exprStartAddress </span><span style="color: #D4D4D4">&lt;-</span><span style="color: #E6E6E6"> foldR_partial(sumArgumentsArray, @@makeSumExpr, exprZero, ptrFieldsLen</span><span style="color: #D4D4D4">-</span><span style="color: #E6E6E6">i)</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> exprAddr_rules : Template</span></span>
<span class="line"><span style="color: #E6E6E6">    exprAddr_rules </span><span style="color: #D4D4D4">|&gt;</span><span style="color: #E6E6E6"> replaceVariable(</span><span style="color: #CE9178">&quot;START_ADDRESS&quot;</span><span style="color: #E6E6E6">, exprStartAddress)</span></span>
<span class="line"><span style="color: #E6E6E6">    apply_template(exprAddr_rules, exprAddr</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">at, exprAddr)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> exprReinterpretCast</span><span style="color: #D4D4D4">&lt;-</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">new</span><span style="color: #E6E6E6"> [[ExprCast() </span></span>
<span class="line"><span style="color: #E6E6E6">        castType </span><span style="color: #D4D4D4">:=</span><span style="color: #E6E6E6"> st</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">fields[</span><span style="color: #569CD6">ptrsTypeIndexes</span><span style="color: #E6E6E6">[i]]</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">_type,</span></span>
<span class="line"><span style="color: #E6E6E6">        castFlags </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> ExprCastFlags reinterpretCast,</span></span>
<span class="line"><span style="color: #E6E6E6">        subexpr </span><span style="color: #D4D4D4">&lt;-</span><span style="color: #E6E6E6"> exprAddr]]</span></span>
<span class="line"><span style="color: #E6E6E6">    </span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> exprUnsafe</span><span style="color: #D4D4D4">&lt;-</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">new</span><span style="color: #E6E6E6"> [[ExprUnsafe() body </span><span style="color: #D4D4D4">&lt;-</span><span style="color: #E6E6E6"> exprReinterpretCast]]</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> exprCopy </span><span style="color: #D4D4D4">&lt;-</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">new</span><span style="color: #E6E6E6"> [[ExprCopy() op</span><span style="color: #D4D4D4">:=</span><span style="color: #CE9178">&quot;=&quot;</span><span style="color: #E6E6E6">, left </span><span style="color: #D4D4D4">&lt;-</span><span style="color: #E6E6E6"> exprField_a, right </span><span style="color: #D4D4D4">&lt;-</span><span style="color: #E6E6E6"> exprUnsafe]]</span></span>
<span class="line"><span style="color: #E6E6E6">    blk</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">list </span><span style="color: #D4D4D4">|&gt;</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">emplace</span><span style="color: #E6E6E6">(exprCopy)</span></span></code></pre></div></div></figure>
<p>Все части генерации, составленные вместе, генерируют теперь такую функцию:<br><figure class="shiki dascript"><div class="codeblock"><div class="code"><pre class="shiki slack-dark"><code><span class="line"><span style="color: #C586C0">def</span><span style="color: #E6E6E6"> init`</span><span style="color: #C586C0">struct</span><span style="color: #E6E6E6">`Memblock ( </span><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> memblock : Memblock; </span><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> a`count : </span><span style="color: #4EC9B0">int</span><span style="color: #E6E6E6">; </span><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> b`count : </span><span style="color: #4EC9B0">int</span><span style="color: #E6E6E6">; </span><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> c`count : </span><span style="color: #4EC9B0">int</span><span style="color: #E6E6E6"> )</span></span>
<span class="line"><span style="color: #E6E6E6">        memblock</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">a`count </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> a`count</span></span>
<span class="line"><span style="color: #E6E6E6">        memblock</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">b`count </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> b`count</span></span>
<span class="line"><span style="color: #E6E6E6">        memblock</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">c`count </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> c`count</span></span>
<span class="line"><span style="color: #E6E6E6">        </span><span style="color: #C586C0">let</span><span style="color: #E6E6E6"> aSize : </span><span style="color: #4EC9B0">int</span><span style="color: #E6E6E6"> </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> (a`count </span><span style="color: #D4D4D4">*</span><span style="color: #E6E6E6"> </span><span style="color: #B5CEA8">4</span><span style="color: #E6E6E6">)</span></span>
<span class="line"><span style="color: #E6E6E6">        </span><span style="color: #C586C0">let</span><span style="color: #E6E6E6"> bSize : </span><span style="color: #4EC9B0">int</span><span style="color: #E6E6E6"> </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> (b`count </span><span style="color: #D4D4D4">*</span><span style="color: #E6E6E6"> </span><span style="color: #B5CEA8">4</span><span style="color: #E6E6E6">)</span></span>
<span class="line"><span style="color: #E6E6E6">        </span><span style="color: #C586C0">let</span><span style="color: #E6E6E6"> cSize : </span><span style="color: #4EC9B0">int</span><span style="color: #E6E6E6"> </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> (c`count </span><span style="color: #D4D4D4">*</span><span style="color: #E6E6E6"> </span><span style="color: #B5CEA8">4</span><span style="color: #E6E6E6">)</span></span>
<span class="line"><span style="color: #E6E6E6">        </span><span style="color: #C586C0">let</span><span style="color: #E6E6E6"> totalSize : </span><span style="color: #4EC9B0">int</span><span style="color: #E6E6E6"> </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> (aSize </span><span style="color: #D4D4D4">+</span><span style="color: #E6E6E6"> (bSize </span><span style="color: #D4D4D4">+</span><span style="color: #E6E6E6"> cSize))</span></span>
<span class="line"><span style="color: #E6E6E6">        __::builtin`</span><span style="color: #DCDCAA">resize</span><span style="color: #E6E6E6">(memblock</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">mem,totalSize)</span></span>
<span class="line"><span style="color: #E6E6E6">        memblock</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">a </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">reinterpret</span><span style="color: #D4D4D4">&lt;</span><span style="color: #4EC9B0">int</span><span style="color: #E6E6E6">?</span><span style="color: #D4D4D4">&gt;</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">addr</span><span style="color: #E6E6E6">(memblock</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">mem[</span><span style="color: #B5CEA8">0</span><span style="color: #E6E6E6">])</span></span>
<span class="line"><span style="color: #E6E6E6">        memblock</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">b </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">reinterpret</span><span style="color: #D4D4D4">&lt;</span><span style="color: #4EC9B0">float</span><span style="color: #E6E6E6">?</span><span style="color: #D4D4D4">&gt;</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">addr</span><span style="color: #E6E6E6">(memblock</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">mem[(aSize </span><span style="color: #D4D4D4">+</span><span style="color: #E6E6E6"> </span><span style="color: #B5CEA8">0</span><span style="color: #E6E6E6">)])</span></span>
<span class="line"><span style="color: #E6E6E6">        memblock</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">c </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">reinterpret</span><span style="color: #D4D4D4">&lt;</span><span style="color: #4EC9B0">int</span><span style="color: #E6E6E6">?</span><span style="color: #D4D4D4">&gt;</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">addr</span><span style="color: #E6E6E6">(memblock</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">mem[(aSize </span><span style="color: #D4D4D4">+</span><span style="color: #E6E6E6"> (bSize </span><span style="color: #D4D4D4">+</span><span style="color: #E6E6E6"> </span><span style="color: #B5CEA8">0</span><span style="color: #E6E6E6">))])</span></span></code></pre></div></div></figure></p>
<p>Сгенерированная функция делает то же, что и написанная руками. Но разница в том, что для любых новых типов структур больше не нужно писать код объявления полей и инициализации руками совсем!</p>
<h2><span id="nasledovanie">Наследование</span><a href="#nasledovanie" class="header-anchor">#</a></h2><p>Теперь можно использовать макрос, чтобы сгенерировать поля структуры и конструктор:<br><figure class="shiki dascript"><div class="codeblock"><div class="code"><pre class="shiki slack-dark"><code><span class="line"><span style="color: #E6E6E6">[</span><span style="color: #569CD6">memblock</span><span style="color: #E6E6E6">]</span></span>
<span class="line"><span style="color: #C586C0">struct</span><span style="color: #E6E6E6"> Memblock</span></span>
<span class="line"><span style="color: #E6E6E6">    a: </span><span style="color: #4EC9B0">int</span><span style="color: #E6E6E6">?</span></span>
<span class="line"><span style="color: #E6E6E6">    b: </span><span style="color: #4EC9B0">float</span><span style="color: #E6E6E6">?</span></span>
<span class="line"><span style="color: #E6E6E6">    c: </span><span style="color: #4EC9B0">int</span><span style="color: #E6E6E6">?</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E6E6E6">[</span><span style="color: #569CD6">export</span><span style="color: #E6E6E6">]</span></span>
<span class="line"><span style="color: #C586C0">def</span><span style="color: #E6E6E6"> test</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">unsafe</span></span>
<span class="line"><span style="color: #E6E6E6">        </span><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> memblock: Memblock</span></span>
<span class="line"><span style="color: #E6E6E6">        memblock </span><span style="color: #D4D4D4">|&gt;</span><span style="color: #E6E6E6"> init`</span><span style="color: #C586C0">struct</span><span style="color: #E6E6E6">`Memblock(</span><span style="color: #B5CEA8">5</span><span style="color: #E6E6E6">,</span><span style="color: #B5CEA8">5</span><span style="color: #E6E6E6">,</span><span style="color: #B5CEA8">5</span><span style="color: #E6E6E6">)</span></span>
<span class="line"><span style="color: #E6E6E6">        memblock </span><span style="color: #D4D4D4">|&gt;</span><span style="color: #E6E6E6"> fillMemblock</span></span>
<span class="line"><span style="color: #E6E6E6">        </span><span style="color: #DCDCAA">print</span><span style="color: #E6E6E6">(</span><span style="color: #CE9178">&quot;Memblock = {</span><span style="color: #9CDCFE">memblock</span><span style="color: #CE9178">}</span><span style="color: #D7BA7D">\n</span><span style="color: #CE9178">&quot;</span><span style="color: #E6E6E6">)</span></span></code></pre></div></div></figure></p>
<p>Всё работает как задумано (реальный код потребовал бы ещё некоторых доработок, вроде добавления паддинга для выравнивания полей в блоке памяти, а также обёрток для того, чтобы скрыть необходимость unsafe доступа к полям, раз уж границы массивов известны).</p>
<p>Но что будет, если отнаследоваться от такой структуры?</p>
<figure class="shiki dascript"><div class="codeblock"><div class="code"><pre class="shiki slack-dark"><code><span class="line"><span style="color: #C586C0">struct</span><span style="color: #E6E6E6"> Vec2</span></span>
<span class="line"><span style="color: #E6E6E6">    x, y : </span><span style="color: #4EC9B0">float</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E6E6E6">[</span><span style="color: #569CD6">memblock</span><span style="color: #E6E6E6">, dump_fields]</span></span>
<span class="line"><span style="color: #C586C0">struct</span><span style="color: #E6E6E6"> Memblock</span></span>
<span class="line"><span style="color: #E6E6E6">    a: </span><span style="color: #4EC9B0">int</span><span style="color: #E6E6E6">?</span></span>
<span class="line"><span style="color: #E6E6E6">    b: </span><span style="color: #4EC9B0">float</span><span style="color: #E6E6E6">?</span></span>
<span class="line"><span style="color: #E6E6E6">    c: </span><span style="color: #4EC9B0">int</span><span style="color: #E6E6E6">?</span></span>
<span class="line"><span style="color: #E6E6E6">    d: Vec2?</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E6E6E6">[</span><span style="color: #569CD6">memblock</span><span style="color: #E6E6E6">, dump_fields]</span></span>
<span class="line"><span style="color: #569CD6">struct</span><span style="color: #E6E6E6"> </span><span style="color: #4EC9B0">MemblockInheritor</span><span style="color: #E6E6E6"> : </span><span style="color: #4EC9B0">Memblock</span></span>
<span class="line"><span style="color: #E6E6E6">    e: </span><span style="color: #4EC9B0">int</span><span style="color: #E6E6E6">?</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E6E6E6">[</span><span style="color: #569CD6">export</span><span style="color: #E6E6E6">]</span></span>
<span class="line"><span style="color: #C586C0">def</span><span style="color: #E6E6E6"> test</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">unsafe</span></span>
<span class="line"><span style="color: #E6E6E6">        </span><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> memblock: Memblock</span></span>
<span class="line"><span style="color: #E6E6E6">        memblock </span><span style="color: #D4D4D4">|&gt;</span><span style="color: #E6E6E6"> init`</span><span style="color: #C586C0">struct</span><span style="color: #E6E6E6">`Memblock(</span><span style="color: #B5CEA8">5</span><span style="color: #E6E6E6">,</span><span style="color: #B5CEA8">5</span><span style="color: #E6E6E6">,</span><span style="color: #B5CEA8">5</span><span style="color: #E6E6E6">,</span><span style="color: #B5CEA8">1</span><span style="color: #E6E6E6">)</span></span>
<span class="line"><span style="color: #E6E6E6">        memblock </span><span style="color: #D4D4D4">|&gt;</span><span style="color: #E6E6E6"> fillMemblock</span></span>
<span class="line"><span style="color: #E6E6E6">        </span><span style="color: #DCDCAA">print</span><span style="color: #E6E6E6">(</span><span style="color: #CE9178">&quot;Memblock = {</span><span style="color: #9CDCFE">memblock</span><span style="color: #CE9178">}</span><span style="color: #D7BA7D">\n</span><span style="color: #CE9178">&quot;</span><span style="color: #E6E6E6">)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E6E6E6">        </span><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> memblock2: MemblockInheritor</span></span>
<span class="line"><span style="color: #E6E6E6">        </span><span style="color: #6A9955">//memblock2 |&gt; fillMemblock</span></span>
<span class="line"><span style="color: #E6E6E6">        memblock2 </span><span style="color: #D4D4D4">|&gt;</span><span style="color: #E6E6E6"> init`</span><span style="color: #C586C0">struct</span><span style="color: #E6E6E6">`MemblockInheritor(</span><span style="color: #B5CEA8">5</span><span style="color: #E6E6E6">,</span><span style="color: #B5CEA8">5</span><span style="color: #E6E6E6">,</span><span style="color: #B5CEA8">5</span><span style="color: #E6E6E6">,</span><span style="color: #B5CEA8">1</span><span style="color: #E6E6E6">,</span><span style="color: #B5CEA8">10</span><span style="color: #E6E6E6">)</span></span>
<span class="line"><span style="color: #E6E6E6">        </span><span style="color: #DCDCAA">print</span><span style="color: #E6E6E6">(</span><span style="color: #CE9178">&quot;Memblock2 = {</span><span style="color: #9CDCFE">memblock2</span><span style="color: #CE9178">}</span><span style="color: #D7BA7D">\n</span><span style="color: #CE9178">&quot;</span><span style="color: #E6E6E6">)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">//out:</span></span>
<span class="line"><span style="color: #C586C0">struct</span><span style="color: #E6E6E6"> Memblock {</span></span>
<span class="line"><span style="color: #E6E6E6">        int32_t </span><span style="color: #D4D4D4">*</span><span style="color: #E6E6E6"> a;</span></span>
<span class="line"><span style="color: #E6E6E6">        </span><span style="color: #4EC9B0">float</span><span style="color: #E6E6E6"> </span><span style="color: #D4D4D4">*</span><span style="color: #E6E6E6"> b;</span></span>
<span class="line"><span style="color: #E6E6E6">        int32_t </span><span style="color: #D4D4D4">*</span><span style="color: #E6E6E6"> c;</span></span>
<span class="line"><span style="color: #E6E6E6">        Vec2 </span><span style="color: #D4D4D4">*</span><span style="color: #E6E6E6"> d;</span></span>
<span class="line"><span style="color: #E6E6E6">        TArray</span><span style="color: #D4D4D4">&lt;</span><span style="color: #E6E6E6">uint8_t</span><span style="color: #D4D4D4">&gt;</span><span style="color: #E6E6E6"> mem;</span></span>
<span class="line"><span style="color: #E6E6E6">        int32_t a`count;</span></span>
<span class="line"><span style="color: #E6E6E6">        int32_t b`count;</span></span>
<span class="line"><span style="color: #E6E6E6">        int32_t c`count;</span></span>
<span class="line"><span style="color: #E6E6E6">        int32_t d`count;</span></span>
<span class="line"><span style="color: #E6E6E6">}</span></span>
<span class="line"><span style="color: #C586C0">struct</span><span style="color: #E6E6E6"> MemblockInheritor {</span></span>
<span class="line"><span style="color: #E6E6E6">        int32_t </span><span style="color: #D4D4D4">*</span><span style="color: #E6E6E6"> a;</span></span>
<span class="line"><span style="color: #E6E6E6">        </span><span style="color: #4EC9B0">float</span><span style="color: #E6E6E6"> </span><span style="color: #D4D4D4">*</span><span style="color: #E6E6E6"> b;</span></span>
<span class="line"><span style="color: #E6E6E6">        int32_t </span><span style="color: #D4D4D4">*</span><span style="color: #E6E6E6"> c;</span></span>
<span class="line"><span style="color: #E6E6E6">        Vec2 </span><span style="color: #D4D4D4">*</span><span style="color: #E6E6E6"> d;</span></span>
<span class="line"><span style="color: #E6E6E6">        TArray</span><span style="color: #D4D4D4">&lt;</span><span style="color: #E6E6E6">uint8_t</span><span style="color: #D4D4D4">&gt;</span><span style="color: #E6E6E6"> mem;</span></span>
<span class="line"><span style="color: #E6E6E6">        int32_t a`count;</span></span>
<span class="line"><span style="color: #E6E6E6">        int32_t b`count;</span></span>
<span class="line"><span style="color: #E6E6E6">        int32_t c`count;</span></span>
<span class="line"><span style="color: #E6E6E6">        int32_t d`count;</span></span>
<span class="line"><span style="color: #E6E6E6">        int32_t </span><span style="color: #D4D4D4">*</span><span style="color: #E6E6E6"> e;</span></span>
<span class="line"><span style="color: #E6E6E6">        TArray</span><span style="color: #D4D4D4">&lt;</span><span style="color: #E6E6E6">uint8_t</span><span style="color: #D4D4D4">&gt;</span><span style="color: #E6E6E6"> mem;</span></span>
<span class="line"><span style="color: #E6E6E6">        int32_t a`count;</span></span>
<span class="line"><span style="color: #E6E6E6">        int32_t b`count;</span></span>
<span class="line"><span style="color: #E6E6E6">        int32_t c`count;</span></span>
<span class="line"><span style="color: #E6E6E6">        int32_t d`count;</span></span>
<span class="line"><span style="color: #E6E6E6">        int32_t e`count;</span></span>
<span class="line"><span style="color: #E6E6E6">}</span></span></code></pre></div></div></figure>
<p>Ауч, все поля в наследнике продублированы. Обработка объявления наследования в языке реализована как копирование деклараций всех полей структуры-предка в дочернюю (можно порыться в документации, или написать макрос, который покажет, что происходит).</p>
<p>Возможно реализовать пару стратегий правильного размещения полей наследника в памяти:</p>
<ul>
<li>каким-либо образом пометить, что базовая структура имеет сгенерированные поля, и добавить только новые</li>
<li>каким-либо образом пометить поля структуры-предка, удалить их, и перестроить всю структуру заново</li>
</ul>
<p>Для пометки полей можно использовать аннотации типов (пример — <a target="_blank" rel="noopener" href="https://github.com/borisbat/dasBGFX/blob/a1e10ab439e5996a0a4d8722689e2b0fab4e72d9/examples/01_hello_triangle.das#L7">аннотации типов шейдеров</a>).</p>
<p>Простой макрос, который проверяет список аннотаций типа:<br><figure class="shiki dascript"><div class="codeblock"><div class="code"><pre class="shiki slack-dark"><code><span class="line"><span style="color: #569CD6">def</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">checkFields</span><span style="color: #E6E6E6">(</span><span style="color: #569CD6">var</span><span style="color: #E6E6E6"> </span><span style="color: #9CDCFE">st</span><span style="color: #E6E6E6">:StructurePtr)</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">for</span><span style="color: #E6E6E6"> field </span><span style="color: #C586C0">in</span><span style="color: #E6E6E6"> st</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">fields</span></span>
<span class="line"><span style="color: #E6E6E6">        </span><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> memblockAnnExist </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> find_arg(</span><span style="color: #CE9178">&quot;in_memblock&quot;</span><span style="color: #E6E6E6">, field</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">annotation) ?</span><span style="color: #C586C0">as</span><span style="color: #E6E6E6"> tBool </span><span style="color: #D4D4D4">??</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">false</span></span>
<span class="line"><span style="color: #E6E6E6">        </span><span style="color: #C586C0">if</span><span style="color: #E6E6E6"> memblockAnnExist</span></span>
<span class="line"><span style="color: #E6E6E6">            </span><span style="color: #DCDCAA">print</span><span style="color: #E6E6E6">(</span><span style="color: #CE9178">&quot;</span><span style="color: #D7BA7D">\t</span><span style="color: #CE9178">[in_memblock]</span><span style="color: #D7BA7D">\n</span><span style="color: #CE9178">&quot;</span><span style="color: #E6E6E6">)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">//можно добавить аннотацию типа</span></span>
<span class="line"><span style="color: #E6E6E6"> st</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">fields[i]</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">annotation </span><span style="color: #D4D4D4">|&gt;</span><span style="color: #E6E6E6"> add_annotation_argument(</span><span style="color: #CE9178">&quot;in_memblock&quot;</span><span style="color: #E6E6E6">, </span><span style="color: #C586C0">true</span><span style="color: #E6E6E6">)</span></span></code></pre></div></div></figure></p>
<p>Теперь можно реализовать логику добавления новых полей в уже существующий мемблок, а также генерацию конструктора с правильным количестом полей:</p>
<figure class="shiki dascript"><div class="codeblock"><div class="code"><pre class="shiki slack-dark"><code><span class="line"></span>
<span class="line"><span style="color: #C586C0">struct</span><span style="color: #E6E6E6"> Vec2</span></span>
<span class="line"><span style="color: #E6E6E6">    x, y : </span><span style="color: #4EC9B0">float</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E6E6E6">[</span><span style="color: #569CD6">memblock</span><span style="color: #E6E6E6">, dump_fields]</span></span>
<span class="line"><span style="color: #C586C0">struct</span><span style="color: #E6E6E6"> Memblock</span></span>
<span class="line"><span style="color: #E6E6E6">    a: </span><span style="color: #4EC9B0">int</span><span style="color: #E6E6E6">?</span></span>
<span class="line"><span style="color: #E6E6E6">    b: </span><span style="color: #4EC9B0">float</span><span style="color: #E6E6E6">?</span></span>
<span class="line"><span style="color: #E6E6E6">    c: </span><span style="color: #4EC9B0">int</span><span style="color: #E6E6E6">?</span></span>
<span class="line"><span style="color: #E6E6E6">    d: Vec2?</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E6E6E6">[</span><span style="color: #569CD6">memblock</span><span style="color: #E6E6E6">, dump_fields]</span></span>
<span class="line"><span style="color: #569CD6">struct</span><span style="color: #E6E6E6"> </span><span style="color: #4EC9B0">MemblockInheritor</span><span style="color: #E6E6E6"> : </span><span style="color: #4EC9B0">Memblock</span></span>
<span class="line"><span style="color: #E6E6E6">    e: </span><span style="color: #4EC9B0">int</span><span style="color: #E6E6E6">?</span></span>
<span class="line"></span>
<span class="line"><span style="color: #569CD6">def</span><span style="color: #E6E6E6"> </span><span style="color: #DCDCAA">fillMemblock</span><span style="color: #E6E6E6">(</span><span style="color: #569CD6">var</span><span style="color: #E6E6E6"> </span><span style="color: #9CDCFE">memblock</span><span style="color: #E6E6E6">: Memblock)</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">unsafe</span></span>
<span class="line"><span style="color: #E6E6E6">        memblock</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">a[</span><span style="color: #B5CEA8">0</span><span style="color: #E6E6E6">] </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> int(</span><span style="color: #B5CEA8">0x11223344</span><span style="color: #E6E6E6">)</span></span>
<span class="line"><span style="color: #E6E6E6">        memblock</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">a[</span><span style="color: #B5CEA8">1</span><span style="color: #E6E6E6">] </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #B5CEA8">0</span></span>
<span class="line"><span style="color: #E6E6E6">        memblock</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">a[</span><span style="color: #B5CEA8">2</span><span style="color: #E6E6E6">] </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #D4D4D4">-</span><span style="color: #B5CEA8">1</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E6E6E6">        memblock</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">b[</span><span style="color: #B5CEA8">0</span><span style="color: #E6E6E6">] </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #C586C0">reinterpret</span><span style="color: #D4D4D4">&lt;</span><span style="color: #4EC9B0">float</span><span style="color: #D4D4D4">&gt;</span><span style="color: #E6E6E6">(</span><span style="color: #B5CEA8">0x55667788</span><span style="color: #E6E6E6">)</span></span>
<span class="line"><span style="color: #E6E6E6">        memblock</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">b[</span><span style="color: #B5CEA8">1</span><span style="color: #E6E6E6">] </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #B5CEA8">0.0</span></span>
<span class="line"><span style="color: #E6E6E6">        memblock</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">b[</span><span style="color: #B5CEA8">2</span><span style="color: #E6E6E6">] </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #B5CEA8">123.456</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E6E6E6">        memblock</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">c[</span><span style="color: #B5CEA8">0</span><span style="color: #E6E6E6">] </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> int(</span><span style="color: #B5CEA8">0xAABBCCDD</span><span style="color: #E6E6E6">)</span></span>
<span class="line"><span style="color: #E6E6E6">        memblock</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">c[</span><span style="color: #B5CEA8">1</span><span style="color: #E6E6E6">] </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #B5CEA8">0</span></span>
<span class="line"><span style="color: #E6E6E6">        memblock</span><span style="color: #D4D4D4">.</span><span style="color: #E6E6E6">c[</span><span style="color: #B5CEA8">2</span><span style="color: #E6E6E6">] </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> </span><span style="color: #D4D4D4">-</span><span style="color: #B5CEA8">1</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E6E6E6">[</span><span style="color: #569CD6">export</span><span style="color: #E6E6E6">]</span></span>
<span class="line"><span style="color: #C586C0">def</span><span style="color: #E6E6E6"> test</span></span>
<span class="line"><span style="color: #E6E6E6">    </span><span style="color: #C586C0">unsafe</span></span>
<span class="line"><span style="color: #E6E6E6">        </span><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> memblock: Memblock</span></span>
<span class="line"><span style="color: #E6E6E6">        memblock </span><span style="color: #D4D4D4">|&gt;</span><span style="color: #E6E6E6"> init`</span><span style="color: #C586C0">struct</span><span style="color: #E6E6E6">`Memblock(</span><span style="color: #B5CEA8">5</span><span style="color: #E6E6E6">,</span><span style="color: #B5CEA8">5</span><span style="color: #E6E6E6">,</span><span style="color: #B5CEA8">5</span><span style="color: #E6E6E6">,</span><span style="color: #B5CEA8">1</span><span style="color: #E6E6E6">)</span></span>
<span class="line"><span style="color: #E6E6E6">        memblock </span><span style="color: #D4D4D4">|&gt;</span><span style="color: #E6E6E6"> fillMemblock</span></span>
<span class="line"><span style="color: #E6E6E6">        </span><span style="color: #DCDCAA">print</span><span style="color: #E6E6E6">(</span><span style="color: #CE9178">&quot;Memblock = {</span><span style="color: #9CDCFE">memblock</span><span style="color: #CE9178">}</span><span style="color: #D7BA7D">\n</span><span style="color: #CE9178">&quot;</span><span style="color: #E6E6E6">)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E6E6E6">        </span><span style="color: #C586C0">var</span><span style="color: #E6E6E6"> memblock2: MemblockInheritor</span></span>
<span class="line"><span style="color: #E6E6E6">        </span><span style="color: #6A9955">//memblock2 |&gt; fillMemblock</span></span>
<span class="line"><span style="color: #E6E6E6">        memblock2 </span><span style="color: #D4D4D4">|&gt;</span><span style="color: #E6E6E6"> init`</span><span style="color: #C586C0">struct</span><span style="color: #E6E6E6">`MemblockInheritor(</span><span style="color: #B5CEA8">5</span><span style="color: #E6E6E6">,</span><span style="color: #B5CEA8">5</span><span style="color: #E6E6E6">,</span><span style="color: #B5CEA8">5</span><span style="color: #E6E6E6">,</span><span style="color: #B5CEA8">1</span><span style="color: #E6E6E6">,</span><span style="color: #B5CEA8">10</span><span style="color: #E6E6E6">)</span></span>
<span class="line"><span style="color: #E6E6E6">        </span><span style="color: #DCDCAA">print</span><span style="color: #E6E6E6">(</span><span style="color: #CE9178">&quot;Memblock2 = {</span><span style="color: #9CDCFE">memblock2</span><span style="color: #CE9178">}</span><span style="color: #D7BA7D">\n</span><span style="color: #CE9178">&quot;</span><span style="color: #E6E6E6">)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">//Вывод:</span></span>
<span class="line"><span style="color: #C586C0">struct</span><span style="color: #E6E6E6"> Memblock {</span></span>
<span class="line"><span style="color: #E6E6E6">        int32_t </span><span style="color: #D4D4D4">*</span><span style="color: #E6E6E6"> a;</span></span>
<span class="line"><span style="color: #E6E6E6">        </span><span style="color: #4EC9B0">float</span><span style="color: #E6E6E6"> </span><span style="color: #D4D4D4">*</span><span style="color: #E6E6E6"> b;</span></span>
<span class="line"><span style="color: #E6E6E6">        int32_t </span><span style="color: #D4D4D4">*</span><span style="color: #E6E6E6"> c;</span></span>
<span class="line"><span style="color: #E6E6E6">        Vec2 </span><span style="color: #D4D4D4">*</span><span style="color: #E6E6E6"> d;</span></span>
<span class="line"><span style="color: #E6E6E6">        TArray</span><span style="color: #D4D4D4">&lt;</span><span style="color: #E6E6E6">uint8_t</span><span style="color: #D4D4D4">&gt;</span><span style="color: #E6E6E6"> mem;</span></span>
<span class="line"><span style="color: #E6E6E6">        int32_t a`count;</span></span>
<span class="line"><span style="color: #E6E6E6">        int32_t b`count;</span></span>
<span class="line"><span style="color: #E6E6E6">        int32_t c`count;</span></span>
<span class="line"><span style="color: #E6E6E6">        int32_t d`count;</span></span>
<span class="line"><span style="color: #E6E6E6">}</span></span>
<span class="line"><span style="color: #C586C0">struct</span><span style="color: #E6E6E6"> MemblockInheritor {</span></span>
<span class="line"><span style="color: #E6E6E6">        int32_t </span><span style="color: #D4D4D4">*</span><span style="color: #E6E6E6"> a;</span></span>
<span class="line"><span style="color: #E6E6E6">        </span><span style="color: #4EC9B0">float</span><span style="color: #E6E6E6"> </span><span style="color: #D4D4D4">*</span><span style="color: #E6E6E6"> b;</span></span>
<span class="line"><span style="color: #E6E6E6">        int32_t </span><span style="color: #D4D4D4">*</span><span style="color: #E6E6E6"> c;</span></span>
<span class="line"><span style="color: #E6E6E6">        Vec2 </span><span style="color: #D4D4D4">*</span><span style="color: #E6E6E6"> d;</span></span>
<span class="line"><span style="color: #E6E6E6">        TArray</span><span style="color: #D4D4D4">&lt;</span><span style="color: #E6E6E6">uint8_t</span><span style="color: #D4D4D4">&gt;</span><span style="color: #E6E6E6"> mem;</span></span>
<span class="line"><span style="color: #E6E6E6">        int32_t a`count;</span></span>
<span class="line"><span style="color: #E6E6E6">        int32_t b`count;</span></span>
<span class="line"><span style="color: #E6E6E6">        int32_t c`count;</span></span>
<span class="line"><span style="color: #E6E6E6">        int32_t d`count;</span></span>
<span class="line"><span style="color: #E6E6E6">        int32_t </span><span style="color: #D4D4D4">*</span><span style="color: #E6E6E6"> e;</span></span>
<span class="line"><span style="color: #E6E6E6">        int32_t e`count;</span></span>
<span class="line"><span style="color: #E6E6E6">}</span></span>
<span class="line"><span style="color: #E6E6E6">Memblock </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> [[ </span><span style="color: #B5CEA8">287454020</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">15837566074880.000000000</span><span style="color: #E6E6E6">; </span><span style="color: #D4D4D4">-</span><span style="color: #B5CEA8">1430532899</span><span style="color: #E6E6E6">; [[ </span><span style="color: #B5CEA8">0.000000000</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0.000000000</span><span style="color: #E6E6E6">]]; [[ </span><span style="color: #B5CEA8">0x44</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x33</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x22</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x11</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0xff</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0xff</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0xff</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0xff</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x88</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x77</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x66</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x55</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x79</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0xe9</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0xf6</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x42</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0xdd</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0xcc</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0xbb</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0xaa</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0xff</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0xff</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0xff</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0xff</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">]]; </span><span style="color: #B5CEA8">5</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">5</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">5</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">1</span><span style="color: #E6E6E6">]]</span></span>
<span class="line"><span style="color: #E6E6E6">Memblock2 </span><span style="color: #D4D4D4">=</span><span style="color: #E6E6E6"> [[ </span><span style="color: #B5CEA8">0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0.000000000</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0</span><span style="color: #E6E6E6">; [[ </span><span style="color: #B5CEA8">0.000000000</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0.000000000</span><span style="color: #E6E6E6">]]; [[ </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0x0</span><span style="color: #E6E6E6">]]; </span><span style="color: #B5CEA8">5</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">5</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">5</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">1</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">0</span><span style="color: #E6E6E6">; </span><span style="color: #B5CEA8">10</span><span style="color: #E6E6E6">]]</span></span></code></pre></div></div></figure>
<h2><span id="final">Финал</span><a href="#final" class="header-anchor">#</a></h2><p>С данным макросом можно продолжать играться, делая его всё круче, но примерно на этом этапе можно сказать, что исходная задача решена.</p>
<p>Макросы добавляют в язык способ серьёзно модифицировать код и данные по правилам, которые захочет реализовать программист. При этом разница между тривиальной структурой и “продвинутой” с точки зрения клиентского кода — всего одна аннотация.</p>
<p>Для сравнения с C++, например <a target="_blank" rel="noopener" href="https://youtu.be/gVGtNFg4ay0">доклад  Louis Dionne</a> про реализацию библиотеки, позволяющей переопределить способ реализации полиморфизма. Без макросов невозможно реализовать идею синтаксически так, чтобы это выглядело как наследование — в компиляторе жёстко прошиты правила того, что сгенерирует комплиятор при наследовании одной структуры от другой.</p>
<p>Естественно, что макросы — это не средство повседневного решения задач. Скорее это средство для того, чтобы лучше “подстроить” язык под предметную область, и уменьшить количество рукописного рутинного кода, не относящего непосредственно к решаемой задаче.</p>
<p>Для <code>daScript</code> предметная область — это разработка игр, и, возможно, макросы позволят ему уйти далеко вперед по сравнению с тем, что умели делать любые другие скриптовые языки для игр раньше.</p>
<p><a target="_blank" rel="noopener" href="https://github.com/spiiin/dascript_macro_tutorial">https://github.com/spiiin/dascript_macro_tutorial</a> - репозиторий с кодом из заметки:<br>    <code>/src_dirty</code> — можно посмотреть диффами между парами файлов эволюцию примера из статьи. Хостом для выполнения может послужить tutorial01 - базовый пример работы с языком из официального репозитория. В остальном — непричёсанный код.<br>    <code>/examples</code> — пофикшенные примеры макросов из официального репозитория.</p>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"Ov23liG1mZbiQOIdi91X","clientSecret":"e05812685eb741a752982b89dcf6f5b58dc10251","repo":"spiiin.github.io","owner":"spiiin","admin":["spiiin"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script></div></article><div class="pagination"><a class="pagination__link pagination__prev" href="/blog/4232971949/">Позже</a><a class="pagination__link pagination__next" href="/blog/1728194429/">Раньше</a></div></main><footer class="footer metadata"><p class="footer__text">© 2024 spiiin</p><p class="footer__text">Powered by <a class="footer__text__link" href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a class="footer__text__link" href="https://pages.github.com/" target="_blank">Github Page</a></p></footer></div><!-- hexo injector body_end start -->
  <script>
  const CODE_CONFIG = {
    beautify: undefined,
    highlightCopy: undefined,
    highlightLang: undefined,
    highlightHeightLimit: undefined,
    isHighlightShrink: undefined,
    copy: {
      success: 'undefined',
      error: 'undefined',
      noSupport: 'undefined',
    }
  };
  console.log(
    `%c hexo-shiki-plugin %c v1.0.27 %c https://github.com/nova1751/hexo-shiki-plugin`,
    "color: #fff; background: #5f5f5f",
    "color: #fff; background: #80c8f8",
    ""
  );
  </script>
  <!-- hexo injector body_end end --></body></html>