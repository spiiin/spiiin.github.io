<!DOCTYPE html><html lang="ru"><head><meta charset="UTF-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Spiiin's blog | daScript macro</title><meta name="description" content="&lt;p&gt;&lt;a href=&quot;https://dascript.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;daScript&lt;/a&gt; - скриптовый язык для игр от Gaijin Entertaiment.&lt;/p&gt;
&lt;p&gt;После нескольких дней изучения понял, что испытываю интерес и хороший страх по отношению к этому языку. Такой, как если бы нашёл лазерную указку и решил поиграть с котом, но понял, что этой указкой можно легко резать металл. &lt;/p&gt;
&lt;p&gt;Гайдзины делают не замену &lt;code&gt;Lua&lt;/code&gt;, они делают замену &lt;code&gt;C++&lt;/code&gt;! Точнее даже, не “делают”, а практически “сделали”, язык сейчас находится в версии 0.2, но полноценно используется ими в продакшене в &lt;code&gt;Warthunder&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Доклад и документация акцентируют внимание на быстродействии языка и возможности серьёзных изменений без перезапуска игры, но только вскользь упоминают о мощных возможностях макросов. Так что я решил попробовать решить задачку, требующую их использования. Это моя первая программа на &lt;code&gt;daScript&lt;/code&gt;, после трёх дней изучения, так что где-то возможны и неизбежны косяки.&lt;/p&gt;"><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=PT+Serif&amp;display=swap"><link rel="stylesheet" href="/css/highlights/darkula.css"><link rel="stylesheet" href="/css/main.css"><link rel="search" type="application/opensearchdescription+xml" href="http://spiiin.github.io/atom.xml" title="Spiiin's blog"><script>(function (i, s, o, g, r, a, m) {
  i['GoogleAnalyticsObject'] = r;
  i[r] = i[r] || function () {
    (i[r].q = i[r].q || []).push(arguments)
  }, i[r].l = 1 * new Date();
  a = s.createElement(o),
    m = s.getElementsByTagName(o)[0];
  a.async = 1;
  a.src = g;
  m.parentNode.insertBefore(a, m)
})(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');
ga('create', 'UA-00000000-0', 'auto');
ga('send', 'pageview');</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Spiiin's blog" type="application/atom+xml">
</head><body><div class="container"><header class="main-header"><h1 class="main-header__title uplize"><a class="main-header__title__link" href="/"><img class="header-image" src="/images/favicon.png" width="36" height="36">Spiiin's blog</a></h1><nav class="main-header__nav"><ul class="main-nav"><li class="main-nav__list"><a class="main-nav__list__link" href="/" target="_self">HOME</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/archives/" target="_self">ARCHIVE</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/tags/meta" target="_self">TAGS</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/blog/1" target="_self">ABOUT</a></li></ul></nav></header><main class="container__wrapper"><div class="pagination"><a class="pagination__link pagination__prev" href="/blog/4232971949/">Позже</a><a class="pagination__link pagination__next" href="/blog/1728194429/">Раньше</a></div><article class="article post"><h3 class="article__title">daScript macro</h3><div class="article__date metadata"><div class="post-info">2022/02/06</div></div><div class="article__tags metadata">Tags:
<a class="article__tags__link metadata" href="/tags/gamedev/">gamedev</a><a class="article__tags__link metadata" href="/tags/dascript/">dascript</a></div><div class="article__body"><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p><a href="https://dascript.org/" target="_blank" rel="noopener">daScript</a> - скриптовый язык для игр от Gaijin Entertaiment.</p>
<p>После нескольких дней изучения понял, что испытываю интерес и хороший страх по отношению к этому языку. Такой, как если бы нашёл лазерную указку и решил поиграть с котом, но понял, что этой указкой можно легко резать металл. </p>
<p>Гайдзины делают не замену <code>Lua</code>, они делают замену <code>C++</code>! Точнее даже, не “делают”, а практически “сделали”, язык сейчас находится в версии 0.2, но полноценно используется ими в продакшене в <code>Warthunder</code>.</p>
<p>Доклад и документация акцентируют внимание на быстродействии языка и возможности серьёзных изменений без перезапуска игры, но только вскользь упоминают о мощных возможностях макросов. Так что я решил попробовать решить задачку, требующую их использования. Это моя первая программа на <code>daScript</code>, после трёх дней изучения, так что где-то возможны и неизбежны косяки.</p>
<a id="more"></a>
<h2 id="Задача"><a href="#Задача" class="headerlink" title="Задача"></a>Задача</h2><p>В качестве задачи выбрал такую, которую было бы нетривиально или сложно решить на C++:</p>
<blockquote><ul>
<li>Подсказка компилятору аллоцировать блок данных для структуры в линейном блоке памяти без явного написания кода работы с указателями в самой структуре</li>
</ul>
</blockquote>
<a href="/blog/1728194429/" title="C++ в геймдеве">C++ в геймдеве</a>
<p>Формулировка проблемы из видео про язык <a href="https://youtu.be/TH9VCN6UkyQ?t=4047" target="_blank" rel="noopener">Jai</a> — пример кода, в котором тривиальное объявление медленнее сложного, но быстрого.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Тривиальное объявление меша для моделей</span></span><br><span class="line"><span class="comment">//  2 аллокации, возможно в разных местах памяти</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Mesh</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Vector3&gt; positions;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; indexes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Более реальный вариант для продакшена</span></span><br><span class="line"><span class="comment">//  синтаксис сильно отличается от тривиального варианта </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Mesh</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span>* memblock = <span class="literal">nullptr</span>;</span><br><span class="line">    Vector3* positions = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">int</span>* indices = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">int</span> num_vertices = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> num_indices = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> positions_size = num_vertices * <span class="keyword">sizeof</span> (positions[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">int</span> indices_size = num_indices = <span class="keyword">sizeof</span>(indices[<span class="number">0</span>]);</span><br><span class="line">mesh-&gt;memory_block = <span class="keyword">new</span> <span class="keyword">char</span>[positions_size + indices_size];</span><br><span class="line">mesh-&gt;positions = (Vector3*)mesh-&gt;memblock;</span><br><span class="line">mesh-&gt;indices = (<span class="keyword">int</span>*)(mesh-&gt;memblock + positions_size);</span><br></pre></td></tr></table></figure>
<p>Второй вариант требует написания рутинного кода вручную при добавлении новых полей в структуру, а также ёмкий в плане количества переписывания кода из существующего. Если захочется переделать в таком стиле для ускорения несколько структур — для каждой потребуется ручная работа. Из-за этого большинство структур навсегда останутся описанными в первой, медленной форме.</p>
<p>Джонатан Блоу предлагает в качестве решения проблемы вариант синтаксиса своего языка, который позволит легко “переключить” структуру из медленной формы в быструю.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Mesh</span> &#123;</span></span><br><span class="line">    Vector3 []! positions;           <span class="comment">//[]! - семантика для указателя на память, которую должна выделить и освободить сама структура</span></span><br><span class="line">    <span class="keyword">int</span>[]! indices; @joint positions <span class="comment">//@joint - семантика для того, что попросить компилятор</span></span><br><span class="line">                                     <span class="comment">//    расположить данные в памяти одним блоком</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Я захотел попробовать реализовать подобную подсказку компилятору daScript с помощью макросов.</p>
<h2 id="Документация-к-daScript"><a href="#Документация-к-daScript" class="headerlink" title="Документация к daScript"></a>Документация к daScript</h2><p>Порядок изучения информации про язык:</p>
<ul>
<li>Доклад Антона Юдинцева<style>.embed-container {
    position: relative;
    padding-bottom: 56.25%;
    height: 0;
    overflow: hidden;
    max-width: 100%;
  }
  .embed-container iframe, .embed-container object, .embed-container embed {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
  }
  </style>

<div class="embed-container"><iframe src="https://www.youtube.com/embed/IvHGczF6Go0" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></li>
<li>Инфа с оффициального сайта и <a href="https://dascript.org/doc/index.html" target="_blank" rel="noopener">документация</a></li>
<li><a href="https://youtu.be/inGb9R1NowY" target="_blank" rel="noopener">Live Stream Coding on daScript - Breakoid</a> - стрим с примером реализации арканоида, можно посмотреть на макросы и синтаксис системы ECS, реализованной с помощью макросов</li>
<li><a href="https://github.com/GaijinEntertainment/daScript/tree/073bc29145207b39180069ae60f00ed43fad6ea7/examples/tutorial" target="_blank" rel="noopener">Серия туториалов</a> - примеры привязки скриптов к C++, Ahead-of-Time компиляции, реализация генерации кода через cmake, архитектура игрового объекта с возможностью hot-reloading кода из скриптов.</li>
<li><a href="https://github.com/GaijinEntertainment/daScript/tree/073bc29145207b39180069ae60f00ed43fad6ea7/examples/test/misc" target="_blank" rel="noopener">Больше примеров кода</a>, в том числе несколько макросов</li>
<li><a href="https://github.com/GaijinEntertainment/daScript/tree/073bc29145207b39180069ae60f00ed43fad6ea7/daslib" target="_blank" rel="noopener">Стандартная библиотека</a> языка и <a href="https://github.com/GaijinEntertainment/daScript/tree/073bc29145207b39180069ae60f00ed43fad6ea7/modules" target="_blank" rel="noopener">модули</a>, можно использовать поиск по коду с гитхаба, чтобы найти пример использования той или иной фичи</li>
</ul>
<p>Макросы являются достаточно сложной темой, и освещены в документации daScript-а достаточно кратко, поэтому приведу несколько ссылок на туториалы из других языков:<br><a href="https://www.greghendershott.com/fear-of-macros/" target="_blank" rel="noopener">Fear of macros</a> - Racket<br><a href="https://rsdn.org/article/nemerle/NemerleStingFormating.xml" target="_blank" rel="noopener">Макросы в Nemerle</a> - Nemerle<br><a href="https://nim-lang.org/docs/tut3.html" target="_blank" rel="noopener">Nim Tutorial Part 3</a> - Nim</p>
<h2 id="Наивная-реализация"><a href="#Наивная-реализация" class="headerlink" title="Наивная реализация"></a>Наивная реализация</h2><p>Прежде, чем начинать шаманить с макросами, нужно набросать наивную реализацию “быстрой” версии класса, хранящего свои данные в одном блоке памяти. Для этого можно использовать <a href="https://tiorun.gaijin.team/##S0ksTi7KLCj5/z86taIgv6gklislNU0hNzEzj0sBCAqKMvNKNJQ8UnNy8nUUwvOLclIUlTS5/v8HAA" target="_blank" rel="noopener">онлайн компилятор tio</a>.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Memblock</span></span></span><br><span class="line"><span class="class">    <span class="title">mem</span> :</span> <span class="built_in">array</span>&lt;uint8&gt;</span><br><span class="line">    a: <span class="keyword">int</span>?</span><br><span class="line">    aCount: <span class="keyword">int</span></span><br><span class="line">    b: <span class="keyword">float</span>?</span><br><span class="line">    bCount: <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">initMemblock</span><span class="params">(var memblock: Memblock; aCount:<span class="keyword">int</span>; bCount:<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    let aSize </span>= typeinfo(<span class="keyword">sizeof</span> *memblock.a) * aCount</span><br><span class="line">    let bSize = typeinfo(<span class="keyword">sizeof</span> *memblock.b) * bCount</span><br><span class="line"></span><br><span class="line">    var arr: <span class="built_in">array</span>&lt;uint8&gt;</span><br><span class="line">    arr |&gt; resize(aSize + bSize )</span><br><span class="line">    memblock.mem &lt;- arr</span><br><span class="line"></span><br><span class="line">    memblock.aCount = aCount</span><br><span class="line">    memblock.bCount = bCount</span><br><span class="line">    unsafe</span><br><span class="line">        memblock.a = reinterpret&lt;<span class="keyword">int</span>?&gt; addr(memblock.mem[<span class="number">0</span>])</span><br><span class="line">        memblock.b = reinterpret&lt;<span class="keyword">float</span>?&gt; addr(memblock.mem[aSize])</span><br><span class="line"></span><br><span class="line">        memblock.a[<span class="number">0</span>] = <span class="keyword">int</span>(<span class="number">0x11223344</span>)</span><br><span class="line">        memblock.a[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">        memblock.a[<span class="number">2</span>] = <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        memblock.b[<span class="number">0</span>] = reinterpret&lt;<span class="keyword">float</span>&gt;(<span class="number">0x55667788</span>)</span><br><span class="line">        memblock.b[<span class="number">1</span>] = <span class="number">0.0</span></span><br><span class="line">        memblock.b[<span class="number">2</span>] = <span class="number">123.456</span></span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main</span><br><span class="line">    unsafe</span><br><span class="line">        var memblock: Memblock</span><br><span class="line">        memblock |&gt; initMemblock(<span class="number">5</span>,<span class="number">5</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Memblock = &#123;memblock&#125;"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Output:</span></span><br><span class="line"><span class="comment">//  Memblock = [[ [[0x44; 0x33; 0x22; 0x11; 0x0; 0x0; 0x0; 0x0; 0xff; 0xff; 0xff; 0xff; 0x0; 0x0;</span></span><br><span class="line"><span class="comment">//     0x0; 0x0; 0x0; 0x0; 0x0; 0x0; 0x88; 0x77; 0x66; 0x55; 0x0; 0x0; 0x0; 0x0; 0x79; 0xe9; 0xf6; </span></span><br><span class="line"><span class="comment">//     0x42; 0x0; 0x0; 0x0; 0x0; 0x0; 0x0; 0x0; 0x0]]; 287454020; 5; 15837566074880.000000000; 5]]</span></span><br></pre></td></tr></table></figure>
<p>Несколько замечаний про язык:</p>
<ul>
<li>Питоноподобный синтаксис с отступами. Для тех, кто не переносит такой формы синтаксиса, есть вариант без оступов, со скобочками и точками-с-запятыми.</li>
<li>Пайпы (<code>|&gt;</code> и <code>&lt;|</code>) как синтаксический сахар различных записи вызова функции (<a href="https://en.wikipedia.org/wiki/Uniform_Function_Call_Syntax" target="_blank" rel="noopener">UFCS</a>).</li>
<li>Более строгая типизация, чем в C/C++, из-за чего сложнее изучать язык и играться с ним — иногда приходится отвлекаться на то, чтобы разобраться, что именно компилятор от тебя хочет. По идее, должно помогать ловить в компайл-тайм больше того, что поймалось бы только в рантайме.</li>
<li><em>unsafe</em>, чтобы сказать компилятору “дай мне играться с указателями, как мне хочется, я знаю, что делаю”.</li>
<li>print умеет выводить внутренности структуры, можно убедиться, что данные действительно лежат в одном блоке памяти, как задумывалось.</li>
<li>Отсутствие семантики “=” для типов, для которых нет её однозначного определения. Вместо этого компилятор явно предлагает выбрать между клонированием (“:=”) и перемещением (“&lt;-“). В языке есть generic-функции, в них вроде можно попросить у компилятора данные о типах так, чтобы выбрать желаемое поведение.</li>
</ul>
<h2 id="Первый-макрос"><a href="#Первый-макрос" class="headerlink" title="Первый макрос"></a>Первый макрос</h2><p>Попробуем для начала написать простейший макрос, который выведет на экран список полей структуры. С этого момента не получится использовать онлайн компилятор, так как он не поддерживает загрузку кода из нескольких файлов, а макрос должен располагаться в отдельном модуле.</p>
<p>Причина того, что макрос не может находиться в том же модуле, что и структура, которую он обрабатывает, понятна — чтобы выполнить какой-либо код, обрабатывающий структуру на этапе компиляции, необходимо, чтобы сам этот код к этому моменту был уже скомпилирован.</p>
<p>В репозитории языка валяется готовый <a href="https://github.com/GaijinEntertainment/daScript/blob/073bc29145207b39180069ae60f00ed43fad6ea7/examples/test/misc/dump_fields.das" target="_blank" rel="noopener">пример</a> такого макроса, но в учебных целях немного перепишем его:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> macro_test</span><br><span class="line"></span><br><span class="line">require ast</span><br><span class="line">require daslib/ast_boost</span><br><span class="line"></span><br><span class="line">[structure_macro(name=memblock)]</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DumpFields</span> :</span> AstStructureAnnotation</span><br><span class="line">    <span class="function">def <span class="keyword">override</span> <span class="title">finish</span> <span class="params">( var st:StructurePtr; var group:ModuleGroup; args:AnnotationArgumentList; var errors : das_string )</span> : <span class="keyword">bool</span></span></span><br><span class="line"><span class="function">        <span class="title">print</span><span class="params">(<span class="string">"struct &#123;st.name&#125; \&#123;\n"</span>)</span></span></span><br><span class="line">        for field in st.fields</span><br><span class="line">            print(<span class="string">"\t&#123;describe_cpp(field._type)&#125; &#123;field.name&#125;;\n"</span>)</span><br><span class="line">        print(<span class="string">"\&#125;\n"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>Макрос наследуется от класса <code>AstStructureAnnotation</code>, определённого в модуле <a href="https://github.com/GaijinEntertainment/daScript/blob/073bc29145207b39180069ae60f00ed43fad6ea7/src/builtin/ast.das#L75" target="_blank" rel="noopener">ast</a>, который представляет собой шаблон для аннотации структуры. К самому классу также применяется аннотация <code>structure_macro</code>, которая регистрирует данный макрос для применения к каждой структуре, отмеченной аннотацией <code>memblock</code>.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AstStructureAnnotation</span></span></span><br><span class="line"><span class="class">    <span class="title">def</span> <span class="title">abstract</span> <span class="title">apply</span> ( <span class="title">var</span> <span class="title">st</span>:</span>StructurePtr; var group:ModuleGroup; args:AnnotationArgumentList; var errors : das_string ) : <span class="keyword">bool</span></span><br><span class="line">    <span class="function">def abstract <span class="title">finish</span> <span class="params">( var st:StructurePtr; var group:ModuleGroup; args:AnnotationArgumentList; var errors : das_string )</span> : <span class="keyword">bool</span></span></span><br><span class="line"><span class="function">    def abstract <span class="title">patch</span> <span class="params">( var st:StructurePtr; var group:ModuleGroup; args:AnnotationArgumentList; var errors : das_string; var astChanged:<span class="keyword">bool</span>&amp; )</span> : <span class="keyword">bool</span></span></span><br></pre></td></tr></table></figure>
<p>Интерфейс макроса позволяет переопределить три функции, чтобы “вклиниться” в процесс того, как компилятор обрабатывает определения структуры, на различных этапах. <a href="https://dascript.org/doc/reference/language/macros.html?highlight=macro#compilation-passes" target="_blank" rel="noopener">Документация по фазам компиляции</a>. <code>Apply</code> - наиболее подходящий момент, чтобы попробовать изменить поля структуры или сгенерировать код.</p>
<p>Если теперь отметить описание структуры аннотацией <code>memblock</code>, то компилятор “пропустит” её определение через макрос, который выведет названия полей на экран. В момент обработки информация о создаваемой структуре хранится в классе <code>StructurePtr</code>, определение которого можно найти поиском по C++ коду. На данном этапе макрос просто проходит по всем полям структуры и выводит информацию о каждом из них на экран. <code>describe_cpp</code> - это функция, которая выводит определения типа, как если бы он был объявлен в C++.</p>
<p>При запуске приложения на экран выведется:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct Memblock &#123;</span><br><span class="line">    TArray&lt;uint8_t&gt; mem;</span><br><span class="line">    int32_t * a;</span><br><span class="line">    int32_t aСount;</span><br><span class="line">    int32_t * b;</span><br><span class="line">    int32_t bCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Можно немного поиграться с определением макроса:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[structure_macro(name=memblock)]</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenMemblock</span> :</span> AstStructureAnnotation</span><br><span class="line">    <span class="function">def <span class="keyword">override</span> <span class="title">apply</span> <span class="params">( var st:StructurePtr; var group:ModuleGroup; args:AnnotationArgumentList; var errors : das_string )</span> : <span class="keyword">bool</span></span></span><br><span class="line">        var mkS &lt;- new [[ Structure() ]]         //создаём новую структуру</span><br><span class="line">        mkS.name := <span class="string">"MemblockTest"</span>               <span class="comment">//с именем MemblockTest</span></span><br><span class="line">        let fieldsLen = st.fields |&gt; length</span><br><span class="line">        mkS.fields |&gt; resize(fieldsLen)       </span><br><span class="line">        <span class="keyword">for</span> i in range(<span class="number">0</span>, fieldsLen)</span><br><span class="line">            mkS.fields[i] := st.fields[i]        <span class="comment">//копируем в неё все поля из обрабатываемой структуры</span></span><br><span class="line">        compiling_module() |&gt; add_structure(mkS) <span class="comment">//добавляем в компилирующийся сейчас модуль новый тип</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Скрипт, использующий модуль с макросом</span></span><br><span class="line">require macro_test</span><br><span class="line"></span><br><span class="line">[memblock]</span><br><span class="line">struct Memblock</span><br><span class="line">    mem : <span class="built_in">array</span>&lt;uint8&gt;</span><br><span class="line">    a: <span class="keyword">int</span>?</span><br><span class="line">    aCount: <span class="keyword">int</span></span><br><span class="line">    b: <span class="keyword">float</span>?</span><br><span class="line">    bCount: <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">var memblock1: Memblock</span><br><span class="line">var memblock2: MemblockTest <span class="comment">//ага, новый тип MemblockTest!</span></span><br><span class="line">print(<span class="string">"MemblockTest = &#123;memblock2&#125;"</span>)</span><br></pre></td></tr></table></figure>
<h2 id="Генерация-полей"><a href="#Генерация-полей" class="headerlink" title="Генерация полей"></a>Генерация полей</h2><p>Следующим шагом попробуем убрать поле <code>mem</code> из исходной структуры, и создать его из макроса.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[structure_macro(name=memblock)]</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenMemblock</span> :</span> AstStructureAnnotation</span><br><span class="line">    <span class="function">def <span class="keyword">override</span> <span class="title">apply</span> <span class="params">( var st:StructurePtr; var group:ModuleGroup; args:AnnotationArgumentList; var errors : das_string )</span> : <span class="keyword">bool</span></span></span><br><span class="line">        var mkS &lt;- new [[ Structure() ]]</span><br><span class="line">        mkS.name := <span class="string">"MemblockTest"</span></span><br><span class="line">        let fieldsLen = st.fields |&gt; length</span><br><span class="line">        mkS.fields |&gt; resize(fieldsLen+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//определение типа uint8, как это видит компилятор</span></span><br><span class="line">        var uint8Type &lt;- <span class="keyword">new</span> [[TypeDecl() baseType=Type tUInt8]]</span><br><span class="line">        <span class="comment">//определение array&lt;uint8&gt; </span></span><br><span class="line">        var uint8ArrayType &lt;- <span class="keyword">new</span> [[TypeDecl() baseType=Type tArray, firstType &lt;- uint8Type]]</span><br><span class="line">        <span class="comment">//декларация нового поля с именем mem и типом array&lt;uint8&gt; </span></span><br><span class="line">        mkS.fields[<span class="number">0</span>] := *<span class="keyword">new</span> [[ FieldDeclaration() name:=<span class="string">"mem"</span>, _type &lt;- uint8ArrayType]]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i in range(<span class="number">0</span>, fieldsLen)</span><br><span class="line">            mkS.fields[i+<span class="number">1</span>] := st.fields[i]</span><br><span class="line">        compiling_module() |&gt; add_structure(mkS)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Скрипт, использующий модуль с макросом</span></span><br><span class="line">[memblock]</span><br><span class="line">struct Memblock</span><br><span class="line">    <span class="comment">//mem : array&lt;uint8&gt;  //теперь поля нет в исходной структуре</span></span><br><span class="line">    a: <span class="keyword">int</span>?</span><br><span class="line">    aCount: <span class="keyword">int</span></span><br><span class="line">    b: <span class="keyword">float</span>?</span><br><span class="line">    bCount: <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">var memblock: MemblockTest</span><br><span class="line"><span class="comment">//у структуры MemblockTest появилось поле mem, сгенерированное макросом</span></span><br><span class="line">print(<span class="string">"MemblockTest = &#123;memblock.mem&#125;"</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>функция <code>resize</code> изменяет размер массива, <a href="https://dascript.org/doc/stdlib/builtin.html#containers" target="_blank" rel="noopener">документация</a> функций для работы с контейерами.</li>
<li>можно изменять поля определяемой структуры прямо на месте - макрос выполняется в сам момент её определения. Создание новой структуры с другим именем сделано для наглядности примера.</li>
<li>генерация структур компилятора для определения поля сперва выглядит немного “космически”, дальше будет пример использования функции <code>quote</code>, которая позволяет перевести код как его писал бы человек, в выражение, которое сгенерирует компилятор при парсинге этого кода. Но полезно разобраться с таким способом генерации кода, чтобы привыкнуть к нему. Также стоит найти определения <code>TypeDecl</code> и <code>FieldDeclaration</code> в исходном коде компилятора, это самая надёжная документация.</li>
<li>“оператор” обращения к конкретному значению перечисления — пробел (<code>Type tArray</code> - значение <code>tArray</code> перечисления <code>Type</code>). Очень необычное решение.</li>
<li>при кодогенерации необходимо заботиться о том, чтобы сгенерированное имя не пересекалось с тем, которое может захотеть использовать программист. В этом смысле <code>mem</code> — плохое имя для сгенерированного поля, в реальном коде необходимо было бы какое-либо соглашение об именах, авторы языка используют символ ‘`’ (гравис, backquote) для отметки генерированного кода.</li>
</ul>
<p>Таким же образом можно перенести поля <code>aCount</code> и <code>bCount</code> в генерирующий макрос:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[structure_macro(name=memblock)]</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenMemblock</span> :</span> AstStructureAnnotation</span><br><span class="line">    <span class="function">def <span class="keyword">override</span> <span class="title">apply</span> <span class="params">( var st:StructurePtr; var group:ModuleGroup; args:AnnotationArgumentList; var errors : das_string )</span> : <span class="keyword">bool</span></span></span><br><span class="line"><span class="function">        <span class="comment">//create "mem" field of type array&lt;uint8&gt;</span></span></span><br><span class="line">        var uint8Type &lt;- new [[TypeDecl() baseType=Type tUInt8]]</span><br><span class="line">        var uint8ArrayType &lt;- <span class="keyword">new</span> [[TypeDecl() baseType=Type tArray, firstType &lt;- uint8Type]]</span><br><span class="line"></span><br><span class="line">        let fieldsLen = st.fields |&gt; length</span><br><span class="line">        var ptrsCount = <span class="number">0</span></span><br><span class="line">        var ptrsTypeIndexes : <span class="built_in">array</span>&lt;<span class="keyword">int</span>&gt;</span><br><span class="line">        ptrsTypeIndexes |&gt; reserve(fieldsLen)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Проходим по списку всех полей и сохраняем индексы полей, тип которых -- указатель</span></span><br><span class="line">        <span class="keyword">for</span> i in range(<span class="number">0</span>, fieldsLen)</span><br><span class="line">            <span class="keyword">if</span> st.fields[i]._type.baseType == Type tPointer <span class="comment">//проверка типа поля</span></span><br><span class="line">                ptrsCount++</span><br><span class="line">                ptrsTypeIndexes |&gt; push(i)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//add one field for memblock and one field per pointer type to handle count of object per type</span></span><br><span class="line">        st.fields |&gt; resize(fieldsLen+ ptrsCount + <span class="number">1</span>)</span><br><span class="line">        st.fields[fieldsLen] := *<span class="keyword">new</span> [[ FieldDeclaration() name:=<span class="string">"mem"</span>, _type &lt;- uint8ArrayType]]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i in range(<span class="number">0</span>, ptrsCount)</span><br><span class="line">            <span class="comment">//генерируем имя поля - добавляем к нему постфикс `count</span></span><br><span class="line">            let fieldCountName = <span class="string">"&#123;st.fields[ptrsTypeIndexes[i]].name&#125;&#123;"</span>`count<span class="string">"&#125;"</span></span><br><span class="line">            <span class="comment">//генерируем новое поля типа int для каждого поля</span></span><br><span class="line">            st.fields[fieldsLen+<span class="number">1</span>+i] := *<span class="keyword">new</span> [[ FieldDeclaration() name:=fieldCountName, _type &lt;- <span class="keyword">new</span> [[TypeDecl() baseType=Type tInt]]]]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">[memblock]</span><br><span class="line"><span class="comment">//сама структура теперь содержит только определение полей</span></span><br><span class="line">struct Memblock</span><br><span class="line">    a: <span class="keyword">int</span>?</span><br><span class="line">    b: <span class="keyword">float</span>?</span><br><span class="line"></span><br><span class="line"><span class="comment">//вывод скрипта -- сгенерированные поля</span></span><br><span class="line">struct Memblock &#123;</span><br><span class="line">        <span class="keyword">int32_t</span> * a;</span><br><span class="line">        <span class="keyword">float</span> * b;</span><br><span class="line">        TArray&lt;<span class="keyword">uint8_t</span>&gt; mem;</span><br><span class="line">        <span class="keyword">int32_t</span> a`count;</span><br><span class="line">        <span class="keyword">int32_t</span> b`count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Разумеется, в реальном мире бывают структуры, которые могут содержать одновременно как указатели на память, которую должна выделять и освобождать сама структура, так и те, которые указывают на память, которую структура трогать не должна. Пока что мы считаем, что структура, отмеченная как <code>memblock</code>, содержит только указатели на память, которую выделяет и освобождает сама. Забегая наперёд, реализовать поддержку обоих типов указателей можно с помощью аннотаций типа (я не нашёл ссылок на аннотации в документации, но их можно найти в коде (<a href="https://github.com/borisbat/dasBGFX/blob/a1e10ab439e5996a0a4d8722689e2b0fab4e72d9/examples/01_hello_triangle.das#L7" target="_blank" rel="noopener">пример</a>)). Аннотации типа будут рассмотрены сильно дальше, при реализации наследования от memblock-структур.</p>
<p>На данном этапе мы получили возможность описать структуру с любым количеством полей, и с помощью макроса сгенерировать по этому описанию недостающие поля. К сожалению, функцию <code>initMemblock</code> (конструктор структуры), по прежнему необходимо писать руками, что очень неприятно.</p>
<h2 id="Подготовка-к-генерация-кода-конструктора"><a href="#Подготовка-к-генерация-кода-конструктора" class="headerlink" title="Подготовка к генерация кода конструктора"></a>Подготовка к генерация кода конструктора</h2><p>Для начала стоит немного переписать код <code>initMemblock</code>, чтобы отделить часть инициализации структуры, которую нужно сгенерировать. Также добавлено третье поле, для того, чтобы увидеть, какие изменения потребуется сейчас внести в код <code>initMemblock</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//аннотация того, что к структуре надо применить 2 макроса, добавляющий поля, и дебажный, отображающий все поля</span></span><br><span class="line">[memblock, dump_fields]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Memblock</span></span></span><br><span class="line"><span class="class">    <span class="title">a</span>:</span> <span class="keyword">int</span>?</span><br><span class="line">    b: <span class="keyword">float</span>?</span><br><span class="line">    c: <span class="keyword">int</span>?</span><br><span class="line"></span><br><span class="line"><span class="comment">//Шаблонный код инициализации, типовой для memblock-структур</span></span><br><span class="line"><span class="comment">//  необходимо научиться генерировать его, чтобы не писать руками для каждой структуры</span></span><br><span class="line"><span class="function">def <span class="title">initMemblock</span><span class="params">(var memblock: Memblock; aCount:<span class="keyword">int</span>; bCount:<span class="keyword">int</span>; cCount:<span class="keyword">int</span>)</span></span></span><br><span class="line">    memblock.a`count = aCount</span><br><span class="line">    memblock.b`count = bCount</span><br><span class="line">    memblock.c`count = cCount                                          <span class="comment">//новое</span></span><br><span class="line"></span><br><span class="line">    let aSize = typeinfo(<span class="keyword">sizeof</span> *memblock.a) * aCount</span><br><span class="line">    let bSize = typeinfo(<span class="keyword">sizeof</span> *memblock.b) * bCount</span><br><span class="line">    let cSize = typeinfo(<span class="keyword">sizeof</span> *memblock.c) * cCount                  <span class="comment">//новое</span></span><br><span class="line"></span><br><span class="line">    memblock.mem |&gt; resize(aSize + bSize + cSize)                      <span class="comment">//новое</span></span><br><span class="line"></span><br><span class="line">    unsafe</span><br><span class="line">        memblock.a = reinterpret&lt;<span class="keyword">int</span>?&gt; addr(memblock.mem[<span class="number">0</span>])</span><br><span class="line">        memblock.b = reinterpret&lt;<span class="keyword">float</span>?&gt; addr(memblock.mem[aSize])</span><br><span class="line">        memblock.c = reinterpret&lt;<span class="keyword">int</span>?&gt; addr(memblock.mem[aSize+bSize]) <span class="comment">//новое</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Пример использования структуры</span></span><br><span class="line">def fillMemblock(var memblock: Memblock)</span><br><span class="line">    unsafe</span><br><span class="line">        memblock.a[<span class="number">0</span>] = <span class="keyword">int</span>(<span class="number">0x11223344</span>)</span><br><span class="line">        memblock.a[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">        memblock.a[<span class="number">2</span>] = <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        memblock.b[<span class="number">0</span>] = reinterpret&lt;<span class="keyword">float</span>&gt;(<span class="number">0x55667788</span>)</span><br><span class="line">        memblock.b[<span class="number">1</span>] = <span class="number">0.0</span></span><br><span class="line">        memblock.b[<span class="number">2</span>] = <span class="number">123.456</span></span><br><span class="line"></span><br><span class="line">        memblock.c[<span class="number">0</span>] = <span class="keyword">int</span>(<span class="number">0xAABBCCDD</span>)</span><br><span class="line">        memblock.c[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">        memblock.c[<span class="number">2</span>] = <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Тест</span></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def test</span><br><span class="line">    unsafe</span><br><span class="line">        var memblock: Memblock</span><br><span class="line">        memblock |&gt; initMemblock(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>) <span class="comment">//кол-во аргументов конструктора, зависит от количества полей структуры</span></span><br><span class="line">        memblock |&gt; fillMemblock</span><br><span class="line">        print(<span class="string">"Memblock = &#123;memblock&#125;"</span>)</span><br></pre></td></tr></table></figure>
<p>Прежде, чем приступать к написанию макроса, генерирующего функцию <code>initMemblock</code>, стоит разобраться с парой примеров:</p>
<p><a href="https://github.com/GaijinEntertainment/daScript/blob/073bc29145207b39180069ae60f00ed43fad6ea7/examples/test/misc/gen_fields.das" target="_blank" rel="noopener">gen_field.das</a> — генерация функции, логгирующей создание полей структуры.</p>
<ul>
<li>Приведены два макроса <code>DumpFields</code> и <code>Dump2Fields</code>, работающие на различных стадиях (apply/finish), во время генерации структуры, и после окончания.</li>
<li>На момент написание заметки пример был сломан, для фикса необходимо убрать код, касающийся типа <code>EntityId</code> — видимо, пример выдран из какого-то более масштабного кода, и опредения то ли забыли перенести, то ли забыли добавить модуль, содержащий их.</li>
<li>флаг функции “<code>fn.flags |= FunctionFlags init</code>“ говорит компилятору о том, что функция должна быть вызвана сразу после генерации (я какое-то время тупил с тем, чтобы понять, на какой стадии компиляции, кто и почему её вызывает).</li>
</ul>
<p><a href="https://github.com/GaijinEntertainment/daScript/blob/073bc29145207b39180069ae60f00ed43fad6ea7/examples/test/misc/ast_print.das" target="_blank" rel="noopener">ast_print.das</a> - макрос, выводящий исходный текст на dascript переданного ему выражения на daScript.</p>
<ul>
<li>этот пример в репозитории тоже немного сломан (<a href="https://github.com/spiiin/dascript_macro_tutorial/blob/master/examples/ast_print.das" target="_blank" rel="noopener">Fixed version</a>)</li>
</ul>
<p>Теперь применим немного рекурсивной магии.</p>
<p>Этот макрос может быть очень полезным, если переделать его так, чтобы он печатал не исходный текст переданного ему выражения, а исходный текст МАКРОСА, генерирующего при выполнении само это выражение.</p>
<p>Это очень важная для упрощения метапрограммирования часть, поэтому повторю ещё раз. Вместо написания макроса, генерирующего функцию <code>initMemblock</code>, мы сначала напишем <strong><code>макрос ast_print_expression, который выведет на экран текст, который поможет нам написать макрос generateInitMemblockFunction, генерирующий функцию initMemblock</code></strong> (или любую другую функцию). Звучит запутанно, но это не так сложно, как кажется.<br>(всё, больше не буду повторять, язык сломать можно)</p>
<p>Модифицируем функцию <code>ast_print</code> так, чтобы она не просто печатала исходный текст переданного ей выражения, а дополнительно печатала тип каждого подвыражения (<code>Subexpression</code>) этого выражения.<br>Вот такая функция:<br><a href="https://github.com/spiiin/dascript_macro_tutorial/blob/master/examples/macro_print_ast.das" target="_blank" rel="noopener">ast_print_expression</a> (конечно, немного “наколенная”)</p>
<p>Теперь можно начать последовательно копировать типы подвыражений в макрос, генерирующий функцию <code>initMemblock</code>, постепенно модифицируя его так, чтобы добавлять параметры, позволяющие генерировать различные варианты этой функции.</p>
<p>Рабочий процесс на этом этапе удобно зациклить так:</p>
<ul>
<li>Модифицируем текст initMemblock</li>
<li>Перезапускаем компиляцию функции, чтобы макрос ast_print_expression применился к этой функции и вывел на экран выражение, в которое преобразуется функция</li>
<li>Копируем часть выражения в макрос generateInitMemblockFunction, который должен сгенерировать новую функцию initMemblock_generated, идентичную самой функции initMemblock</li>
<li>Модифицируем макрос generateInitMemblockFunction, чтобы добавить в него код, генерирующий переменную часть функции</li>
<li>Перекомпилируем функцию initMemblock_generated, чтобы применить к ней макрос ast_print, для того, чтобы получить исходный код функции и сверить его с исходный кодом initMemblock</li>
</ul>
<p>Выглядит запутанно, но это необходимо для того, чтобы иметь возможность выполнить шаг 4 - “переменная часть функции” — те строчки, которые изменяются в функции <code>initMemblock</code> после того, как мы изменяем какое-либо поле структуры <code>Memblock</code> (посмотрите исходный код функции <code>initMemblock</code> и отметки <code>//новое</code>, это строчки, которые добавились после добавления поля с именем <code>c</code> — это как раз эта “переменная часть функции”).</p>
<p>Самое интересное, что перевести программу в режим REPL практически элементарно, достаточно зациклить C++ часть самого первого туториала из репозитория daScript, перекомпилируя daScript-ы заново при вводе любого символа:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span>, <span class="keyword">char</span> * [] )</span> </span>&#123;</span><br><span class="line">    NEED_ALL_DEFAULT_MODULES;</span><br><span class="line">    Module::Initialize();</span><br><span class="line">    <span class="keyword">char</span> a = <span class="string">'x'</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        tutorial();</span><br><span class="line">        <span class="comment">//тут скорее всего надо не забыть очистить память, выделенную в цикле работы</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">    &#125;</span><br><span class="line">    Module::Shutdown();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Рабочий процесс выглядит примерно так:<br><img src="/blog/1547564887/memblock_example.png" alt="fox"><br>Слева код в <a href="https://marketplace.visualstudio.com/items?itemName=profelis.dascript-plugin" target="_blank" rel="noopener">Visual Studio Code</a>, справа программа, выполняющая этот код без необходимости перезапуска. После подготовки можно переходить и к генерации кода, с Repl-режимом это будет значительно проще.</p>
<h2 id="Генерация-функции-initMemblock"><a href="#Генерация-функции-initMemblock" class="headerlink" title="Генерация функции initMemblock"></a>Генерация функции initMemblock</h2><p>Макрос <code>ast_print_expression</code> применённый к функции initMemblock, выводит на экран:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">---das------------------<span class="comment">// [modifyExternal][modifyArgument]</span></span><br><span class="line"><span class="function">def <span class="title">initMemblock</span> <span class="params">( var memblock : Memblock -<span class="keyword">const</span>; aCount : <span class="keyword">int</span> <span class="keyword">const</span>; bCount : <span class="keyword">int</span> <span class="keyword">const</span>; cCount : <span class="keyword">int</span> <span class="keyword">const</span> )</span></span></span><br><span class="line">        ExprVar memblock. ExprField a`count ExprCopyRight = ExprVar aCount</span><br><span class="line">        ExprVar memblock. ExprField b`count ExprCopyRight = ExprVar bCount</span><br><span class="line">        ExprVar memblock. ExprField c`count ExprCopyRight = ExprVar cCount</span><br><span class="line">        ExprLet var  ExprLetVariable aSize : <span class="keyword">int</span> <span class="keyword">const</span> =  ExprOp2(ExprVar aCount ExprOp2Right * <span class="number">4</span>)</span><br><span class="line">        ExprLet var  ExprLetVariable bSize : <span class="keyword">int</span> <span class="keyword">const</span> =  ExprOp2(ExprVar bCount ExprOp2Right * <span class="number">4</span>)</span><br><span class="line">        ExprLet var  ExprLetVariable cSize : <span class="keyword">int</span> <span class="keyword">const</span> =  ExprOp2(ExprVar cCount ExprOp2Right * <span class="number">4</span>)</span><br><span class="line">        ExprCall __::builtin`resize( ExprCallArgument ExprVar memblock. ExprField mem, ExprCallArgument  ExprOp2( ExprOp2(ExprVar aSize ExprOp2Right + ExprVar bSize) ExprOp2Right + ExprVar cSize))</span><br><span class="line">        ExprVar memblock. ExprField a ExprCopyRight = ExprCast reinterpret&lt;<span class="keyword">int</span>?&gt;  VisitExprRef2Ptr addr(ExprVar memblock. ExprField mem ExprAtIndex[<span class="number">0</span>])</span><br><span class="line">        ExprVar memblock. ExprField b ExprCopyRight = ExprCast reinterpret&lt;<span class="keyword">float</span>?&gt;  VisitExprRef2Ptr addr(ExprVar memblock. ExprField mem ExprAtIndex[ExprVar aSize])</span><br><span class="line">        ExprVar memblock. ExprField c ExprCopyRight = ExprCast reinterpret&lt;<span class="keyword">int</span>?&gt;  VisitExprRef2Ptr addr(ExprVar memblock. ExprField mem ExprAtIndex[ ExprOp2(ExprVar aSize ExprOp2Right + ExprVar bSize)])</span><br><span class="line">        ExprCall init`struct`Memblock( ExprCallArgument ExprVar memblock, ExprCallArgument <span class="number">5</span>, ExprCallArgument <span class="number">5</span>, ExprCallArgument <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>Здесь перед каждым daScript выражением показан тип этого выражения. Почти все типы выражений объявлены в заголовочных файлах <a href="https://github.com/GaijinEntertainment/daScript/tree/master/include/daScript/ast" target="_blank" rel="noopener">ast_*.h</a>.</p>
<blockquote><p>С определенного момента начинаешь ценить простые языки — вместо того, что изучать сложные и разрастающиеся правила языка, можно упростить их, чтобы ускорить изучение языка и сделать его более понятным, но при этом дать возможность задавать более сложные правила только в тех местах, где они действительно нужны программисту.</p>
</blockquote>
<p><strong><code>Работа с макросами сначала кажется сложной, но с какого-то момента понимаешь, что типичная программа содержит почти все распространённые типы выражений, и понимаешь, что вот они, все перед тобой, других, скрытых мелким шрифтом в примечаниях на 666-й странице стандарта, нет.</code></strong></p>
<p>Можно было бы пойти ещё дальше, и написать макрос, который выводит код, создающий выражение, но в образовательных целях можно попробовать для начала составить выражения вручную.</p>
<p>Для генерации функции нужно научиться генерировать строки 5 типов:</p>
<ul>
<li>Декларация функции <code>def initMemblock ( var memblock : Memblock, ...)</code></li>
<li>Присваивание  <code>memblock.a</code>count = aCount`</li>
<li>Объвление переменной <code>let aSize = typeinfo(sizeof *memblock.a) * aCount</code></li>
<li>Вызов функции <code>memblock.mem |&gt; resize(aSize + bSize + cSize)</code></li>
<li>Ещё одно присвание - <code>memblock.a = reinterpret&lt;int?&gt; addr(memblock.mem[0])</code></li>
</ul>
<p><strong><code>Декларация функции</code></strong></p>
<p>Практически готовый пример нужного кода есть в примерах из daScript-a <code>gen_field.das</code>.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">generateStructureFields</span><span class="params">(var st:StructurePtr)</span></span></span><br><span class="line"><span class="function">    <span class="comment">//create "mem" field of type array&lt;uint8&gt;</span></span></span><br><span class="line">    var uint8Type &lt;- new [[TypeDecl() baseType=Type tUInt8]]</span><br><span class="line">    var uint8ArrayType &lt;- <span class="keyword">new</span> [[TypeDecl() baseType=Type tArray, firstType &lt;- uint8Type]]</span><br><span class="line"></span><br><span class="line">    let fieldsLen = st.fields |&gt; length</span><br><span class="line">    var ptrsCount = <span class="number">0</span></span><br><span class="line">    var ptrsTypeIndexes : <span class="built_in">array</span>&lt;<span class="keyword">int</span>&gt;</span><br><span class="line">    ptrsTypeIndexes |&gt; reserve(fieldsLen)</span><br><span class="line">    <span class="keyword">for</span> i in range(<span class="number">0</span>, fieldsLen)</span><br><span class="line">        <span class="keyword">if</span> st.fields[i]._type.baseType == Type tPointer</span><br><span class="line">            ptrsCount++</span><br><span class="line">            ptrsTypeIndexes |&gt; push(i) <span class="comment">//сохраняем индексы полей-указателей</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//add one field for memblock and one field per pointer type to handle count of object per type</span></span><br><span class="line">    st.fields |&gt; resize(fieldsLen+ ptrsCount + <span class="number">1</span>)</span><br><span class="line">    st.fields[fieldsLen] := *<span class="keyword">new</span> [[ FieldDeclaration() name:=<span class="string">"mem"</span>, _type &lt;- uint8ArrayType]]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i in range(<span class="number">0</span>, ptrsCount)</span><br><span class="line">        let fieldCountName = <span class="string">"&#123;st.fields[ptrsTypeIndexes[i]].name&#125;&#123;"</span>`count<span class="string">"&#125;"</span></span><br><span class="line">        st.fields[fieldsLen+<span class="number">1</span>+i] := *<span class="keyword">new</span> [[ FieldDeclaration() name:=fieldCountName, _type &lt;- <span class="keyword">new</span> [[TypeDecl() baseType=Type tInt]]]]</span><br><span class="line">    <span class="keyword">return</span> &lt;-ptrsTypeIndexes</span><br><span class="line"></span><br><span class="line"><span class="comment">//--------------------------</span></span><br><span class="line"><span class="comment">// Генерация функции</span></span><br><span class="line">def generateStructureInitFunction(var st:StructurePtr; ptrsTypeIndexes:<span class="built_in">array</span>&lt;<span class="keyword">int</span>&gt;&amp;)</span><br><span class="line">    let ptrFieldsLen = ptrsTypeIndexes |&gt; length</span><br><span class="line"></span><br><span class="line">    let fnname = <span class="string">"init`struct`&#123;st.name&#125;"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//генерируем объявление функции с именем init`struct`ИмяСтрутуры</span></span><br><span class="line">    var fn &lt;- <span class="keyword">new</span> [[Function() at=st.at, atDecl=st.at, name:=fnname]]</span><br><span class="line">    fn.flags |= FunctionFlags generated</span><br><span class="line">    fn.flags |= FunctionFlags privateFunction</span><br><span class="line"></span><br><span class="line">    <span class="comment">//генерируем список аргументов и тип результата функции</span></span><br><span class="line">    unsafe</span><br><span class="line">        fn.arguments |&gt; emplace_new &lt;| <span class="keyword">new</span> [[Variable() at=st.at, name:= <span class="string">"memblock"</span>, _type &lt;- <span class="keyword">new</span> [[TypeDecl() baseType=Type tStructure, structType=addr(*st)]]]]</span><br><span class="line">    <span class="keyword">for</span> i in range(<span class="number">0</span>, ptrFieldsLen)</span><br><span class="line">        let argumentName = <span class="string">"&#123;st.fields[ptrsTypeIndexes[i]].name&#125;`count"</span></span><br><span class="line">        fn.arguments |&gt; emplace_new &lt;| <span class="keyword">new</span> [[Variable() at=st.at, name:= argumentName,  _type &lt;- <span class="keyword">new</span> [[TypeDecl() baseType=Type tInt]] ]]</span><br><span class="line">    fn.result &lt;- <span class="keyword">new</span> [[TypeDecl() baseType=Type tVoid, at=st.at]]</span><br><span class="line"></span><br><span class="line">    <span class="comment">//генерируем тело функции, пока просто вызов `print("Hello, world!")`</span></span><br><span class="line">    var blk &lt;- <span class="keyword">new</span> [[ExprBlock() at=st.at]]</span><br><span class="line">    var printF &lt;- <span class="keyword">new</span> [[ExprCall() name:=<span class="string">"print"</span>]]</span><br><span class="line">    printF.arguments |&gt; emplace_new &lt;| <span class="keyword">new</span> [[ExprConstString() value:=<span class="string">"Hello, world!\n"</span>]]</span><br><span class="line">    blk.<span class="built_in">list</span> |&gt; emplace(printF)</span><br><span class="line"></span><br><span class="line">    fn.body &lt;- blk</span><br><span class="line">    compiling_module() |&gt; add_function(fn)</span><br></pre></td></tr></table></figure>
<p>Теперь если сгенерировать макросом функцию, и передать эту функцию в макрос, который возвращает исходный текст функции, то получится такой результат:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">def init`<span class="class"><span class="keyword">struct</span>`<span class="title">Memblock</span> ( <span class="title">var</span> <span class="title">memblock</span> :</span> Memblock; var a`count : <span class="keyword">int</span>; var b`count : <span class="keyword">int</span>; var c`count : <span class="keyword">int</span> )</span><br><span class="line">    print(<span class="string">"Hello, world!"</span>,__context__)</span><br></pre></td></tr></table></figure>
<p><strong><code>Присваивание и объявление переменной</code></strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//-------------------------</span></span><br><span class="line"><span class="comment">//1. Make Expressions</span></span><br><span class="line"><span class="comment">//-------------------------</span></span><br><span class="line"><span class="comment">//memblock.a`count = aCount</span></span><br><span class="line"><span class="comment">//  ExprVar memblock. ExprField a`count ExprCopyRight = ExprVar aCount</span></span><br><span class="line">var exprVar_memblock &lt;- <span class="keyword">new</span> [[ExprVar() name:=<span class="string">"memblock"</span>]]</span><br><span class="line">var exprField_acount &lt;- <span class="keyword">new</span> [[ExprField() name:=<span class="string">"a`count"</span>, value &lt;- exprVar_memblock]]</span><br><span class="line">var exprVar_acount &lt;- <span class="keyword">new</span> [[ExprVar() name:=<span class="string">"a`count"</span>]]</span><br><span class="line">var exprCopy &lt;- <span class="keyword">new</span> [[ExprCopy() op:=<span class="string">"="</span>, left &lt;- exprField_acount, right &lt;- exprVar_acount]]</span><br><span class="line">blk.<span class="built_in">list</span> |&gt; emplace(exprCopy)</span><br></pre></td></tr></table></figure>
<p>Тут всё достаточно тривиально, пока составляем только первую строку “memblock.a`count = aCount”</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//-------------------------</span></span><br><span class="line"><span class="comment">//2. Quotes</span></span><br><span class="line"><span class="comment">//-------------------------</span></span><br><span class="line"><span class="comment">//let aSize = typeinfo(sizeof *memblock.a) * aCount</span></span><br><span class="line"><span class="comment">//  ExprLet var  ExprLetVariable aSize : int const =  ExprOp2(ExprVar aCount ExprOp2Right * 4)</span></span><br><span class="line">var exprLet_aSize_value &lt;- quote(</span><br><span class="line">    typeinfo(<span class="keyword">sizeof</span> * memblock.a) * a`count</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var exprLet_aSize &lt;- <span class="keyword">new</span> [[ExprLet()]]</span><br><span class="line">exprLet_aSize.variables |&gt; emplace_new() &lt;| <span class="keyword">new</span> [[Variable()</span><br><span class="line">    name := <span class="string">"aSize"</span>,</span><br><span class="line">    _type &lt;- <span class="keyword">new</span> [[TypeDecl() baseType=Type tInt]],</span><br><span class="line">    init &lt;- exprLet_aSize_value</span><br><span class="line">]]</span><br><span class="line">blk.<span class="built_in">list</span> |&gt; emplace(exprLet_aSize)</span><br><span class="line"></span><br><span class="line"><span class="comment">//prevent drop unused code</span></span><br><span class="line">var exprCall_printUnused &lt;- quote(</span><br><span class="line">    print(<span class="string">"&#123;aSize&#125;"</span>)</span><br><span class="line">)</span><br><span class="line">blk.<span class="built_in">list</span> |&gt; emplace(exprCall_printUnused)</span><br></pre></td></tr></table></figure>
<p>При генерации следующей строки можно заметить, что:</p>
<ul>
<li>макрос ast_print_expression не описал выражение “typeinfo(sizeof *memblock.a)”, а вместо этого вывел его результат. Это происходит потому, что макрос был применён к уже сгенерированной и оптимизированной функции, для которой часть выражений может быть вычислена компилятором.</li>
<li>макрос ast_print, применённый к сгенерированной функции, не показывает неиспользуемые переменные, так как они были выброшены компилятором, так что увидеть их можно, если добавить использование (print”{aSize}” в данном случае).</li>
</ul>
<p>Кроме генерации выражений, здесь показано использование макроса <code>quote</code>, который превращает код в выражение:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var exprLet_aSize_value &lt;- quote(</span><br><span class="line">    typeinfo(<span class="keyword">sizeof</span> * memblock.a) * a`count</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>Вот <a href="https://github.com/GaijinEntertainment/daScript/blob/726d440be7618fb431815b18e6f785c37a335d5d/examples/test/misc/template_example.das" target="_blank" rel="noopener">пример</a> (<a href="https://github.com/spiiin/dascript_macro_tutorial/blob/master/examples/template_example.das" target="_blank" rel="noopener">Fixed version</a>) более продвинутого использования цитирования, с возможностью задать правила переписывания выражения. Это можно использовать для того, чтобы перейти от явного указания названия поля структуры к переменной, в которую можно передать любое имя или выражение:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">require daslib/templates</span><br><span class="line">require daslib/templates_boost</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------</span></span><br><span class="line"><span class="comment">//2. Quotes and templates</span></span><br><span class="line"><span class="comment">//-------------------------</span></span><br><span class="line"><span class="comment">//let aSize = typeinfo(sizeof *memblock.a) * aCount</span></span><br><span class="line"><span class="comment">//  ExprLet var  ExprLetVariable aSize : int const =  ExprOp2(ExprVar aCount ExprOp2Right * 4)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">for</span> i in <span class="title">range</span><span class="params">(<span class="number">0</span>, ptrFieldsLen)</span></span></span><br><span class="line"><span class="function">    let argumentName </span>= <span class="string">"&#123;st.fields[ptrsTypeIndexes[i]].name&#125;"</span></span><br><span class="line">    var exprLet_aSize_value &lt;- quote(</span><br><span class="line">        typeinfo(<span class="keyword">sizeof</span> *ELEMENT) * ELEMENTS_COUNT</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    var exprVar_memblock2 &lt;- <span class="keyword">new</span> [[ExprVar() name:=<span class="string">"memblock"</span>]]</span><br><span class="line">    var exprField_acount2 &lt;- <span class="keyword">new</span> [[ExprField() name:=argumentName, value &lt;- exprVar_memblock2]]</span><br><span class="line"></span><br><span class="line">    var exprLet_rules : Template                                               <span class="comment">//правила переписывания выражения</span></span><br><span class="line">    exprLet_rules |&gt; replaceVariable(<span class="string">"ELEMENT"</span>, exprField_acount2)             <span class="comment">//подставляем выражение</span></span><br><span class="line">    exprLet_rules |&gt; renameVariable(<span class="string">"ELEMENTS_COUNT"</span>, <span class="string">"&#123;argumentName&#125;`count"</span>)  <span class="comment">//подставляем имя переменной</span></span><br><span class="line">    apply_template(exprLet_rules, exprLet_aSize_value.at, exprLet_aSize_value)</span><br><span class="line">    </span><br><span class="line">    var exprLet_aSize &lt;- <span class="keyword">new</span> [[ExprLet()]]</span><br><span class="line">    exprLet_aSize.variables |&gt; emplace_new() &lt;| <span class="keyword">new</span> [[Variable()</span><br><span class="line">        name := <span class="string">"&#123;argumentName&#125;Size"</span>,</span><br><span class="line">        _type &lt;- <span class="keyword">new</span> [[TypeDecl() baseType=Type tInt]],</span><br><span class="line">        init &lt;- exprLet_aSize_value</span><br><span class="line">    ]]</span><br><span class="line">    blk.<span class="built_in">list</span> |&gt; emplace(exprLet_aSize)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Временно руками добавляем код использования переменных, чтобы их не отбросил компилятор</span></span><br><span class="line">    var exprCall_printUnused &lt;- quote(</span><br><span class="line">        print(<span class="string">"&#123;aSize&#125;,&#123;bSize&#125;,&#123;cSize&#125;"</span>)</span><br><span class="line">    blk.<span class="built_in">list</span> |&gt; emplace(exprCall_printUnused)</span><br></pre></td></tr></table></figure>
<p>Половина кода генерации написана, нужно двигаться дальше.</p>
<p><strong><code>Вызов функции memblock.mem |&gt; resize(aSize + bSize + cSize)</code></strong></p>
<p>Здесь есть небольшая хитрость. Строка <code>aSize + bSize + cSize</code>, трансформируется в выражение:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ExprOp2( ExprOp2(ExprVar aSize ExprOp2Right + ExprVar bSize) ExprOp2Right + ExprVar cSize))</span><br></pre></td></tr></table></figure></p>
<p>У выражения есть определённый шаблон:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">((((a+b)+c)+d)+...)</span><br></pre></td></tr></table></figure></p>
<p>Подобные выражения удобно сгенерировать с помощью функции <a href="https://en.wikipedia.org/wiki/Fold_(higher-order_function" target="_blank" rel="noopener">свёртки</a>). Я зачём-то использовал правостороннюю свёртку, но для ассоциативных операторов конечный результат будет одинаковым (не нашёл готовой в стандартной библиотеке):</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">foldR</span><span class="params">(var a:<span class="built_in">array</span>&lt;ExpressionPtr&gt;; foldOp:function&lt;(arg1, arg2: ExpressionPtr) : ExpressionPtr&gt; )</span></span></span><br><span class="line"><span class="function">    let aLen </span>= a |&gt; length</span><br><span class="line">    var from &lt;- a[aLen<span class="number">-1</span>]</span><br><span class="line">    <span class="function"><span class="keyword">for</span> i in <span class="title">range</span><span class="params">(<span class="number">1</span>, aLen)</span></span></span><br><span class="line"><span class="function">        from :</span>= foldOp |&gt; invoke(a[aLen<span class="number">-1</span>-i], from)</span><br><span class="line">    <span class="keyword">return</span> from</span><br><span class="line"></span><br><span class="line">def makeSumExpr(a, b: ExpressionPtr <span class="keyword">const</span>): ExpressionPtr</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> [[ExprOp2() op:=<span class="string">"+"</span>, left := a, right := b]]</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------</span></span><br><span class="line"><span class="comment">// 3. Foldr</span></span><br><span class="line"><span class="comment">//-------------------------</span></span><br><span class="line"><span class="comment">//memblock.mem |&gt; resize(aSize + bSize + cSize)</span></span><br><span class="line"><span class="comment">//     ExprCall __::builtin`resize( ExprCallArgument ExprVar memblock. ExprField mem, ExprCallArgument  ExprOp2( ExprOp2(ExprVar aSize ExprOp2Right + ExprVar bSize) ExprOp2Right + ExprVar cSize))</span></span><br><span class="line"></span><br><span class="line">var sumArgumentsArray: <span class="built_in">array</span>&lt;ExpressionPtr&gt;</span><br><span class="line"><span class="keyword">for</span> i in range(<span class="number">0</span>, ptrFieldsLen) </span><br><span class="line">    let argumentName = <span class="string">"&#123;st.fields[ptrsTypeIndexes[i]].name&#125;"</span></span><br><span class="line">    let nameSize := <span class="string">"&#123;argumentName&#125;Size"</span></span><br><span class="line">    sumArgumentsArray |&gt; emplace(<span class="keyword">new</span> [[ExprVar() name:=nameSize]])</span><br><span class="line">var sumExpr &lt;- foldR(sumArgumentsArray, @@makeSumExpr) <span class="comment">//ага, свёртка массива в выражение</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//--------</span></span><br><span class="line">var exprLet_totalSize &lt;- <span class="keyword">new</span> [[ExprLet()]]</span><br><span class="line">exprLet_totalSize.variables |&gt; emplace_new() &lt;| <span class="keyword">new</span> [[Variable()</span><br><span class="line">    name := <span class="string">"totalSize"</span>,</span><br><span class="line">    _type &lt;- <span class="keyword">new</span> [[TypeDecl() baseType=Type tInt]],</span><br><span class="line">    init &lt;- sumExpr</span><br><span class="line">]]</span><br><span class="line">blk.<span class="built_in">list</span> |&gt; emplace(exprLet_totalSize)</span><br><span class="line"><span class="comment">//prevent drop unused code</span></span><br><span class="line">var exprCall_printUnused2 &lt;- quote(</span><br><span class="line">    print(<span class="string">"&#123;totalSize&#125;"</span>)</span><br><span class="line">)</span><br><span class="line">blk.<span class="built_in">list</span> |&gt; emplace(exprCall_printUnused2)</span><br><span class="line"></span><br><span class="line"><span class="comment">//сгенерирует код:</span></span><br><span class="line"><span class="comment">//let totalSize : int = (aSize + (bSize + cSize))</span></span><br><span class="line"><span class="comment">//__::builtin`resize(memblock.mem,totalSize)</span></span><br></pre></td></tr></table></figure>
<p>(__::builtin`resize здесь просто замангленное название встроенной функции resize)</p>
<p><strong><code>memblock.a = reinterpret&lt;int?&gt; addr(memblock.mem[0])</code></strong></p>
<p>Можно немного изменить функцию <code>foldr</code>, чтобы она могла генерировать частичные суммы для получения кода вида:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">memblock.a = reinterpret&lt;<span class="keyword">int</span>?&gt; addr(memblock.mem[<span class="number">0</span>])</span><br><span class="line">memblock.b = reinterpret&lt;<span class="keyword">float</span>?&gt; addr(memblock.mem[(aSize + <span class="number">0</span>)])</span><br><span class="line">memblock.c = reinterpret&lt;<span class="keyword">int</span>?&gt; addr(memblock.mem[(aSize + (bSize + <span class="number">0</span>))])</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//теперь можно задать, какую часть массива превратить в выражение</span></span><br><span class="line"><span class="function">def <span class="title">foldR_partial</span><span class="params">(var a:<span class="built_in">array</span>&lt;ExpressionPtr&gt;; foldOp:function&lt;(arg1, arg2: ExpressionPtr) : ExpressionPtr&gt;; initial: ExpressionPtr; endIndex:<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">    let aLen </span>= a |&gt; length</span><br><span class="line">    var from := initial</span><br><span class="line">    <span class="keyword">for</span> i in range(endIndex, aLen)</span><br><span class="line">        from := foldOp |&gt; invoke(a[aLen<span class="number">-1</span>-i], from)</span><br><span class="line">    <span class="keyword">return</span> from</span><br><span class="line"></span><br><span class="line">var exprCall_resize &lt;- quote(</span><br><span class="line">        memblock.mem |&gt; resize(totalSize)</span><br><span class="line">    )</span><br><span class="line">    blk.<span class="built_in">list</span> |&gt; emplace(exprCall_resize)</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------</span></span><br><span class="line"><span class="comment">// 4. castType</span></span><br><span class="line"><span class="comment">//-------------------------</span></span><br><span class="line"><span class="comment">//memblock.a = reinterpret&lt;int?&gt; addr(memblock.mem[0])</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i in range(<span class="number">0</span>, ptrFieldsLen)</span><br><span class="line">    let argumentName = <span class="string">"&#123;st.fields[ptrsTypeIndexes[i]].name&#125;"</span></span><br><span class="line">    var exprVar_memblock &lt;- <span class="keyword">new</span> [[ExprVar() name:=<span class="string">"memblock"</span>]]</span><br><span class="line">    var exprField_a &lt;- <span class="keyword">new</span> [[ExprField() name:=argumentName, value &lt;- exprVar_memblock]]</span><br><span class="line">    var exprAddr &lt;- quote(</span><br><span class="line">        addr(memblock.mem[START_ADDRESS])</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    var exprZero &lt;- <span class="keyword">new</span> [[ExprConstInt() value=<span class="number">0</span>]]</span><br><span class="line">    var exprStartAddress &lt;- foldR_partial(sumArgumentsArray, @@makeSumExpr, exprZero, ptrFieldsLen-i)</span><br><span class="line">    var exprAddr_rules : Template</span><br><span class="line">    exprAddr_rules |&gt; replaceVariable(<span class="string">"START_ADDRESS"</span>, exprStartAddress)</span><br><span class="line">    apply_template(exprAddr_rules, exprAddr.at, exprAddr)</span><br><span class="line"></span><br><span class="line">    var exprReinterpretCast&lt;- <span class="keyword">new</span> [[ExprCast() </span><br><span class="line">        castType := st.fields[ptrsTypeIndexes[i]]._type,</span><br><span class="line">        castFlags = ExprCastFlags reinterpretCast,</span><br><span class="line">        subexpr &lt;- exprAddr]]</span><br><span class="line">    </span><br><span class="line">    var exprUnsafe&lt;- <span class="keyword">new</span> [[ExprUnsafe() body &lt;- exprReinterpretCast]]</span><br><span class="line">    var exprCopy &lt;- <span class="keyword">new</span> [[ExprCopy() op:=<span class="string">"="</span>, left &lt;- exprField_a, right &lt;- exprUnsafe]]</span><br><span class="line">    blk.<span class="built_in">list</span> |&gt; emplace(exprCopy)</span><br></pre></td></tr></table></figure>
<p>Все части генерации, составленные вместе, генерируют теперь такую функцию:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">def init`<span class="class"><span class="keyword">struct</span>`<span class="title">Memblock</span> ( <span class="title">var</span> <span class="title">memblock</span> :</span> Memblock; var a`count : <span class="keyword">int</span>; var b`count : <span class="keyword">int</span>; var c`count : <span class="keyword">int</span> )</span><br><span class="line">        memblock.a`count = a`count</span><br><span class="line">        memblock.b`count = b`count</span><br><span class="line">        memblock.c`count = c`count</span><br><span class="line">        let aSize : <span class="keyword">int</span> = (a`count * <span class="number">4</span>)</span><br><span class="line">        let bSize : <span class="keyword">int</span> = (b`count * <span class="number">4</span>)</span><br><span class="line">        let cSize : <span class="keyword">int</span> = (c`count * <span class="number">4</span>)</span><br><span class="line">        let totalSize : <span class="keyword">int</span> = (aSize + (bSize + cSize))</span><br><span class="line">        __::builtin`resize(memblock.mem,totalSize)</span><br><span class="line">        memblock.a = reinterpret&lt;<span class="keyword">int</span>?&gt; addr(memblock.mem[<span class="number">0</span>])</span><br><span class="line">        memblock.b = reinterpret&lt;<span class="keyword">float</span>?&gt; addr(memblock.mem[(aSize + <span class="number">0</span>)])</span><br><span class="line">        memblock.c = reinterpret&lt;<span class="keyword">int</span>?&gt; addr(memblock.mem[(aSize + (bSize + <span class="number">0</span>))])</span><br></pre></td></tr></table></figure></p>
<p>Сгенерированная функция делает то же, что и написанная руками. Но разница в том, что для любых новых типов структур больше не нужно писать код объявления полей и инициализации руками совсем!</p>
<h2 id="Наследование"><a href="#Наследование" class="headerlink" title="Наследование"></a>Наследование</h2><p>Теперь можно использовать макрос, чтобы сгенерировать поля структуры и конструктор:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[memblock]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Memblock</span></span></span><br><span class="line"><span class="class">    <span class="title">a</span>:</span> <span class="keyword">int</span>?</span><br><span class="line">    b: <span class="keyword">float</span>?</span><br><span class="line">    c: <span class="keyword">int</span>?</span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def test</span><br><span class="line">    unsafe</span><br><span class="line">        var memblock: Memblock</span><br><span class="line">        memblock |&gt; init`<span class="class"><span class="keyword">struct</span>`<span class="title">Memblock</span>(5,5,5)</span></span><br><span class="line"><span class="class">        <span class="title">memblock</span> |&gt; <span class="title">fillMemblock</span></span></span><br><span class="line"><span class="class">        <span class="title">print</span>("<span class="title">Memblock</span> = &#123;</span>memblock&#125;\n<span class="string">")</span></span><br></pre></td></tr></table></figure></p>
<p>Всё работает как задумано (реальный код потребовал бы ещё некоторых доработок, вроде добавления паддинга для выравнивания полей в блоке памяти, а также обёрток для того, чтобы скрыть необходимость unsafe доступа к полям, раз уж границы массивов известны).</p>
<p>Но что будет, если отнаследоваться от такой структуры?</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vec2</span></span></span><br><span class="line"><span class="class">    <span class="title">x</span>, <span class="title">y</span> :</span> <span class="keyword">float</span></span><br><span class="line"></span><br><span class="line">[memblock, dump_fields]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Memblock</span></span></span><br><span class="line"><span class="class">    <span class="title">a</span>:</span> <span class="keyword">int</span>?</span><br><span class="line">    b: <span class="keyword">float</span>?</span><br><span class="line">    c: <span class="keyword">int</span>?</span><br><span class="line">    d: Vec2?</span><br><span class="line"></span><br><span class="line">[memblock, dump_fields]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MemblockInheritor</span> :</span> Memblock</span><br><span class="line">    e: <span class="keyword">int</span>?</span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def test</span><br><span class="line">    unsafe</span><br><span class="line">        var memblock: Memblock</span><br><span class="line">        memblock |&gt; init`<span class="class"><span class="keyword">struct</span>`<span class="title">Memblock</span>(5,5,5,1)</span></span><br><span class="line"><span class="class">        <span class="title">memblock</span> |&gt; <span class="title">fillMemblock</span></span></span><br><span class="line"><span class="class">        <span class="title">print</span>("<span class="title">Memblock</span> = &#123;</span>memblock&#125;\n<span class="string">")</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        var memblock2: MemblockInheritor</span></span><br><span class="line"><span class="string">        //memblock2 |&gt; fillMemblock</span></span><br><span class="line"><span class="string">        memblock2 |&gt; init`struct`MemblockInheritor(5,5,5,1,10)</span></span><br><span class="line"><span class="string">        print("</span>Memblock2 = &#123;memblock2&#125;\n<span class="string">")</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//out:</span></span><br><span class="line"><span class="string">struct Memblock &#123;</span></span><br><span class="line"><span class="string">        int32_t * a;</span></span><br><span class="line"><span class="string">        float * b;</span></span><br><span class="line"><span class="string">        int32_t * c;</span></span><br><span class="line"><span class="string">        Vec2 * d;</span></span><br><span class="line"><span class="string">        TArray&lt;uint8_t&gt; mem;</span></span><br><span class="line"><span class="string">        int32_t a`count;</span></span><br><span class="line"><span class="string">        int32_t b`count;</span></span><br><span class="line"><span class="string">        int32_t c`count;</span></span><br><span class="line"><span class="string">        int32_t d`count;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">struct MemblockInheritor &#123;</span></span><br><span class="line"><span class="string">        int32_t * a;</span></span><br><span class="line"><span class="string">        float * b;</span></span><br><span class="line"><span class="string">        int32_t * c;</span></span><br><span class="line"><span class="string">        Vec2 * d;</span></span><br><span class="line"><span class="string">        TArray&lt;uint8_t&gt; mem;</span></span><br><span class="line"><span class="string">        int32_t a`count;</span></span><br><span class="line"><span class="string">        int32_t b`count;</span></span><br><span class="line"><span class="string">        int32_t c`count;</span></span><br><span class="line"><span class="string">        int32_t d`count;</span></span><br><span class="line"><span class="string">        int32_t * e;</span></span><br><span class="line"><span class="string">        TArray&lt;uint8_t&gt; mem;</span></span><br><span class="line"><span class="string">        int32_t a`count;</span></span><br><span class="line"><span class="string">        int32_t b`count;</span></span><br><span class="line"><span class="string">        int32_t c`count;</span></span><br><span class="line"><span class="string">        int32_t d`count;</span></span><br><span class="line"><span class="string">        int32_t e`count;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>Ауч, все поля в наследнике продублированы. Обработка объявления наследования в языке реализована как копирование деклараций всех полей структуры-предка в дочернюю (можно порыться в документации, или написать макрос, который покажет, что происходит).</p>
<p>Возможно реализовать пару стратегий правильного размещения полей наследника в памяти:</p>
<ul>
<li>каким-либо образом пометить, что базовая структура имеет сгенерированные поля, и добавить только новые</li>
<li>каким-либо образом пометить поля структуры-предка, удалить их, и перестроить всю структуру заново</li>
</ul>
<p>Для пометки полей можно использовать аннотации типов (пример — <a href="https://github.com/borisbat/dasBGFX/blob/a1e10ab439e5996a0a4d8722689e2b0fab4e72d9/examples/01_hello_triangle.das#L7" target="_blank" rel="noopener">аннотации типов шейдеров</a>).</p>
<p>Простой макрос, который проверяет список аннотаций типа:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">checkFields</span><span class="params">(var st:StructurePtr)</span></span></span><br><span class="line">    for field in st.fields</span><br><span class="line">        var memblockAnnExist = find_arg(<span class="string">"in_memblock"</span>, field.annotation) ?as tBool ?? <span class="literal">false</span></span><br><span class="line">        <span class="keyword">if</span> memblockAnnExist</span><br><span class="line">            print(<span class="string">"\t[in_memblock]\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//можно добавить аннотацию типа</span></span><br><span class="line"> st.fields[i].annotation |&gt; add_annotation_argument(<span class="string">"in_memblock"</span>, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure></p>
<p>Теперь можно реализовать логику добавления новых полей в уже существующий мемблок, а также генерацию конструктора с правильным количестом полей:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vec2</span></span></span><br><span class="line"><span class="class">    <span class="title">x</span>, <span class="title">y</span> :</span> <span class="keyword">float</span></span><br><span class="line"></span><br><span class="line">[memblock, dump_fields]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Memblock</span></span></span><br><span class="line"><span class="class">    <span class="title">a</span>:</span> <span class="keyword">int</span>?</span><br><span class="line">    b: <span class="keyword">float</span>?</span><br><span class="line">    c: <span class="keyword">int</span>?</span><br><span class="line">    d: Vec2?</span><br><span class="line"></span><br><span class="line">[memblock, dump_fields]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MemblockInheritor</span> :</span> Memblock</span><br><span class="line">    e: <span class="keyword">int</span>?</span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">fillMemblock</span><span class="params">(var memblock: Memblock)</span></span></span><br><span class="line"><span class="function">    unsafe</span></span><br><span class="line">        memblock.a[0] = int(0x11223344)</span><br><span class="line">        memblock.a[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">        memblock.a[<span class="number">2</span>] = <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        memblock.b[<span class="number">0</span>] = reinterpret&lt;<span class="keyword">float</span>&gt;(<span class="number">0x55667788</span>)</span><br><span class="line">        memblock.b[<span class="number">1</span>] = <span class="number">0.0</span></span><br><span class="line">        memblock.b[<span class="number">2</span>] = <span class="number">123.456</span></span><br><span class="line"></span><br><span class="line">        memblock.c[<span class="number">0</span>] = <span class="keyword">int</span>(<span class="number">0xAABBCCDD</span>)</span><br><span class="line">        memblock.c[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">        memblock.c[<span class="number">2</span>] = <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def test</span><br><span class="line">    unsafe</span><br><span class="line">        var memblock: Memblock</span><br><span class="line">        memblock |&gt; init`struct`Memblock(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">1</span>)</span><br><span class="line">        memblock |&gt; fillMemblock</span><br><span class="line">        print(<span class="string">"Memblock = &#123;memblock&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line">        var memblock2: MemblockInheritor</span><br><span class="line">        <span class="comment">//memblock2 |&gt; fillMemblock</span></span><br><span class="line">        memblock2 |&gt; init`struct`MemblockInheritor(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line">        print(<span class="string">"Memblock2 = &#123;memblock2&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Вывод:</span></span><br><span class="line">struct Memblock &#123;</span><br><span class="line">        <span class="keyword">int32_t</span> * a;</span><br><span class="line">        <span class="keyword">float</span> * b;</span><br><span class="line">        <span class="keyword">int32_t</span> * c;</span><br><span class="line">        Vec2 * d;</span><br><span class="line">        TArray&lt;<span class="keyword">uint8_t</span>&gt; mem;</span><br><span class="line">        <span class="keyword">int32_t</span> a`count;</span><br><span class="line">        <span class="keyword">int32_t</span> b`count;</span><br><span class="line">        <span class="keyword">int32_t</span> c`count;</span><br><span class="line">        <span class="keyword">int32_t</span> d`count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MemblockInheritor</span> &#123;</span></span><br><span class="line">        <span class="keyword">int32_t</span> * a;</span><br><span class="line">        <span class="keyword">float</span> * b;</span><br><span class="line">        <span class="keyword">int32_t</span> * c;</span><br><span class="line">        Vec2 * d;</span><br><span class="line">        TArray&lt;<span class="keyword">uint8_t</span>&gt; mem;</span><br><span class="line">        <span class="keyword">int32_t</span> a`count;</span><br><span class="line">        <span class="keyword">int32_t</span> b`count;</span><br><span class="line">        <span class="keyword">int32_t</span> c`count;</span><br><span class="line">        <span class="keyword">int32_t</span> d`count;</span><br><span class="line">        <span class="keyword">int32_t</span> * e;</span><br><span class="line">        <span class="keyword">int32_t</span> e`count;</span><br><span class="line">&#125;</span><br><span class="line">Memblock = [[ <span class="number">287454020</span>; <span class="number">15837566074880.000000000</span>; <span class="number">-1430532899</span>; [[ <span class="number">0.000000000</span>; <span class="number">0.000000000</span>]]; [[ <span class="number">0x44</span>; <span class="number">0x33</span>; <span class="number">0x22</span>; <span class="number">0x11</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0xff</span>; <span class="number">0xff</span>; <span class="number">0xff</span>; <span class="number">0xff</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x88</span>; <span class="number">0x77</span>; <span class="number">0x66</span>; <span class="number">0x55</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x79</span>; <span class="number">0xe9</span>; <span class="number">0xf6</span>; <span class="number">0x42</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0xdd</span>; <span class="number">0xcc</span>; <span class="number">0xbb</span>; <span class="number">0xaa</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0xff</span>; <span class="number">0xff</span>; <span class="number">0xff</span>; <span class="number">0xff</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>]]; <span class="number">5</span>; <span class="number">5</span>; <span class="number">5</span>; <span class="number">1</span>]]</span><br><span class="line">Memblock2 = [[ <span class="number">0</span>; <span class="number">0.000000000</span>; <span class="number">0</span>; [[ <span class="number">0.000000000</span>; <span class="number">0.000000000</span>]]; [[ <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>]]; <span class="number">5</span>; <span class="number">5</span>; <span class="number">5</span>; <span class="number">1</span>; <span class="number">0</span>; <span class="number">10</span>]]</span><br></pre></td></tr></table></figure>
<h2 id="Финал"><a href="#Финал" class="headerlink" title="Финал"></a>Финал</h2><p>С данным макросом можно продолжать играться, делая его всё круче, но примерно на этом этапе можно сказать, что исходная задача решена.</p>
<p>Макросы добавляют в язык способ серьёзно модифицировать код и данные по правилам, которые захочет реализовать программист. При этом разница между тривиальной структурой и “продвинутой” с точки зрения клиентского кода — всего одна аннотация.</p>
<p>Для сравнения с C++, например <a href="https://youtu.be/gVGtNFg4ay0" target="_blank" rel="noopener">доклад  Louis Dionne</a> про реализацию библиотеки, позволяющей переопределить способ реализации полиморфизма. Без макросов невозможно реализовать идею синтаксически так, чтобы это выглядело как наследование — в компиляторе жёстко прошиты правила того, что сгенерирует комплиятор при наследовании одной структуры от другой.</p>
<p>Естественно, что макросы — это не средство повседневного решения задач. Скорее это средство для того, чтобы лучше “подстроить” язык под предметную область, и уменьшить количество рукописного рутинного кода, не относящего непосредственно к решаемой задаче.</p>
<p>Для <code>daScript</code> предметная область — это разработка игр, и, возможно, макросы позволят ему уйти далеко вперед по сравнению с тем, что умели делать любые другие скриптовые языки для игр раньше.</p>
<p><a href="https://github.com/spiiin/dascript_macro_tutorial" target="_blank" rel="noopener">https://github.com/spiiin/dascript_macro_tutorial</a> - репозиторий с кодом из заметки:<br>    <code>/src_dirty</code> — можно посмотреть диффами между парами файлов эволюцию примера из статьи. Хостом для выполнения может послужить tutorial01 - базовый пример работы с языком из официального репозитория. В остальном — непричёсанный код.<br>    <code>/examples</code> — пофикшенные примеры макросов из официального репозитория.</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script></div></article><div class="pagination"><a class="pagination__link pagination__prev" href="/blog/4232971949/">Позже</a><a class="pagination__link pagination__next" href="/blog/1728194429/">Раньше</a></div></main><footer class="footer metadata"><p class="footer__text">© 2022 spiiin</p><p class="footer__text">Powered by <a class="footer__text__link" href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a class="footer__text__link" href="https://pages.github.com/" target="_blank">Github Page</a></p></footer></div></body></html>