<!DOCTYPE html><html lang="ru"><head><meta charset="UTF-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Spiiin's blog | daScript macro</title><meta name="description" content="&lt;p&gt;&lt;a href=&quot;https://dascript.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;daScript&lt;/a&gt; - скриптовый язык для игр от Gaijin Entertaiment.&lt;/p&gt;
&lt;p&gt;После нескольких дней изучения понял, что испытываю интерес и хороший страх по отношению к этому языку. Такой, как если бы нашёл лазерную указку и решил поиграть с котом, но понял, что этой указкой можно легко резать металл. &lt;/p&gt;
&lt;p&gt;Гайдзины делают не замену &lt;code&gt;Lua&lt;/code&gt;, они делают замену &lt;code&gt;C++&lt;/code&gt;! Точнее даже, не “делают”, а практически “сделали”, язык сейчас находится в версии 0.2, но полноценно используется ими в продакшене в &lt;code&gt;Warthunder&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Доклад и документация акцентируют внимание на быстродействии языка и возможности серьёзных изменений без перезапуска игры, но только вскользь упоминают о мощных возможностях макросов. Так что я решил попробовать решить задачку, требующую их использования. Это моя первая программа на &lt;code&gt;daScript&lt;/code&gt;, после трёх дней изучения, так что где-то возможны и неизбежны косяки.&lt;/p&gt;"><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=PT+Serif&amp;display=swap"><link rel="stylesheet" href="/css/highlights/darkula.css"><link rel="stylesheet" href="/css/main.css"><link rel="search" type="application/opensearchdescription+xml" href="http://spiiin.github.io/atom.xml" title="Spiiin's blog"><script>(function (i, s, o, g, r, a, m) {
  i['GoogleAnalyticsObject'] = r;
  i[r] = i[r] || function () {
    (i[r].q = i[r].q || []).push(arguments)
  }, i[r].l = 1 * new Date();
  a = s.createElement(o),
    m = s.getElementsByTagName(o)[0];
  a.async = 1;
  a.src = g;
  m.parentNode.insertBefore(a, m)
})(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');
ga('create', 'UA-00000000-0', 'auto');
ga('send', 'pageview');</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Spiiin's blog" type="application/atom+xml">
</head><body><div class="container"><header class="main-header"><h1 class="main-header__title uplize"><a class="main-header__title__link" href="/"><img class="header-image" src="/images/favicon.png" width="36" height="36">Spiiin's blog</a></h1><nav class="main-header__nav"><ul class="main-nav"><li class="main-nav__list"><a class="main-nav__list__link" href="/" target="_self">HOME</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/archives/" target="_self">ARCHIVE</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/tags/meta" target="_self">TAGS</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/blog/1" target="_self">ABOUT</a></li></ul></nav></header><main class="container__wrapper"><div class="pagination"><a class="pagination__link pagination__prev" href="/blog/4232971949/">Позже</a><a class="pagination__link pagination__next" href="/blog/1728194429/">Раньше</a></div><article class="article post"><h3 class="article__title">daScript macro</h3><div class="article__date metadata"><div class="post-info">2022/02/06</div></div><div class="article__tags metadata">Tags:
<a class="article__tags__link metadata" href="/tags/dascript/">dascript</a><a class="article__tags__link metadata" href="/tags/longread/">longread</a></div><div class="article__body"><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p><a href="https://dascript.org/" target="_blank" rel="noopener">daScript</a> - скриптовый язык для игр от Gaijin Entertaiment.</p>
<p>После нескольких дней изучения понял, что испытываю интерес и хороший страх по отношению к этому языку. Такой, как если бы нашёл лазерную указку и решил поиграть с котом, но понял, что этой указкой можно легко резать металл. </p>
<p>Гайдзины делают не замену <code>Lua</code>, они делают замену <code>C++</code>! Точнее даже, не “делают”, а практически “сделали”, язык сейчас находится в версии 0.2, но полноценно используется ими в продакшене в <code>Warthunder</code>.</p>
<p>Доклад и документация акцентируют внимание на быстродействии языка и возможности серьёзных изменений без перезапуска игры, но только вскользь упоминают о мощных возможностях макросов. Так что я решил попробовать решить задачку, требующую их использования. Это моя первая программа на <code>daScript</code>, после трёх дней изучения, так что где-то возможны и неизбежны косяки.</p>
<a id="more"></a>
<h2 id="Задача"><a href="#Задача" class="headerlink" title="Задача"></a>Задача</h2><p>В качестве задачи выбрал такую, которую было бы нетривиально или сложно решить на C++:</p>
<blockquote><ul>
<li>Подсказка компилятору аллоцировать блок данных для структуры в линейном блоке памяти без явного написания кода работы с указателями в самой структуре</li>
</ul>
</blockquote>
<a href="/blog/1728194429/" title="C++ в геймдеве">C++ в геймдеве</a>
<p>Формулировка проблемы из видео про язык <a href="https://youtu.be/TH9VCN6UkyQ?t=4047" target="_blank" rel="noopener">Jai</a> — пример кода, в котором тривиальное объявление медленнее сложного, но быстрого.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Тривиальное объявление меша для моделей</span></span><br><span class="line"><span class="comment">//  2 аллокации, возможно в разных местах памяти</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Mesh</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Vector3&gt; positions;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; indexes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Более реальный вариант для продакшена</span></span><br><span class="line"><span class="comment">//  синтаксис сильно отличается от тривиального варианта </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Mesh</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span>* memblock = <span class="literal">nullptr</span>;</span><br><span class="line">    Vector3* positions = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">int</span>* indices = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">int</span> num_vertices = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> num_indices = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> positions_size = num_vertices * <span class="keyword">sizeof</span> (positions[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">int</span> indices_size = num_indices = <span class="keyword">sizeof</span>(indices[<span class="number">0</span>]);</span><br><span class="line">mesh-&gt;memory_block = <span class="keyword">new</span> <span class="keyword">char</span>[positions_size + indices_size];</span><br><span class="line">mesh-&gt;positions = (Vector3*)mesh-&gt;memblock;</span><br><span class="line">mesh-&gt;indices = (<span class="keyword">int</span>*)(mesh-&gt;memblock + positions_size);</span><br></pre></td></tr></table></figure>
<p>Второй вариант требует написания рутинного кода вручную при добавлении новых полей в структуру, а также ёмкий в плане количества переписывания кода из существующего. Если захочется переделать в таком стиле для ускорения несколько структур — для каждой потребуется ручная работа. Из-за этого большинство структур навсегда останутся описанными в первой, медленной форме.</p>
<p>Джонатан Блоу предлагает в качестве решения проблемы вариант синтаксиса своего языка, который позволит легко “переключить” структуру из медленной формы в быструю.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Mesh</span> &#123;</span></span><br><span class="line">    Vector3 []! positions;           <span class="comment">//[]! - семантика для указателя на память, которую должна выделить и освободить сама структура</span></span><br><span class="line">    <span class="keyword">int</span>[]! indices; @joint positions <span class="comment">//@joint - семантика для того, что попросить компилятор</span></span><br><span class="line">                                     <span class="comment">//    расположить данные в памяти одним блоком</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Я захотел попробовать реализовать подобную подсказку компилятору daScript с помощью макросов.</p>
<h2 id="Документация-к-daScript"><a href="#Документация-к-daScript" class="headerlink" title="Документация к daScript"></a>Документация к daScript</h2><p>Порядок изучения информации про язык:</p>
<ul>
<li>Доклад Антона Юдинцева<style>.embed-container {
    position: relative;
    padding-bottom: 56.25%;
    height: 0;
    overflow: hidden;
    max-width: 100%;
  }
  .embed-container iframe, .embed-container object, .embed-container embed {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
  }
  </style>

<div class="embed-container"><iframe src="https://www.youtube.com/embed/IvHGczF6Go0" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></li>
<li>Инфа с оффициального сайта и <a href="https://dascript.org/doc/index.html" target="_blank" rel="noopener">документация</a></li>
<li><a href="https://youtu.be/inGb9R1NowY" target="_blank" rel="noopener">Live Stream Coding on daScript - Breakoid</a> - стрим с примером реализации арканоида, можно посмотреть на макросы и синтаксис системы ECS, реализованной с помощью макросов</li>
<li><a href="https://github.com/GaijinEntertainment/daScript/tree/073bc29145207b39180069ae60f00ed43fad6ea7/examples/tutorial" target="_blank" rel="noopener">Серия туториалов</a> - примеры привязки скриптов к C++, Ahead-of-Time компиляции, реализация генерации кода через cmake, архитектура игрового объекта с возможностью hot-reloading кода из скриптов.</li>
<li><a href="https://github.com/GaijinEntertainment/daScript/tree/073bc29145207b39180069ae60f00ed43fad6ea7/examples/test/misc" target="_blank" rel="noopener">Больше примеров кода</a>, в том числе несколько макросов</li>
<li><a href="https://github.com/GaijinEntertainment/daScript/tree/073bc29145207b39180069ae60f00ed43fad6ea7/daslib" target="_blank" rel="noopener">Стандартная библиотека</a> языка и <a href="https://github.com/GaijinEntertainment/daScript/tree/073bc29145207b39180069ae60f00ed43fad6ea7/modules" target="_blank" rel="noopener">модули</a>, можно использовать поиск по коду с гитхаба, чтобы найти пример использования той или иной фичи</li>
</ul>
<p>Макросы являются достаточно сложной темой, и освещены в документации daScript-а достаточно кратко, поэтому приведу несколько ссылок на туториалы из других языков:<br><a href="https://www.greghendershott.com/fear-of-macros/" target="_blank" rel="noopener">Fear of macros</a> - Racket<br><a href="https://rsdn.org/article/nemerle/NemerleStingFormating.xml" target="_blank" rel="noopener">Макросы в Nemerle</a> - Nemerle<br><a href="https://nim-lang.org/docs/tut3.html" target="_blank" rel="noopener">Nim Tutorial Part 3</a> - Nim</p>
<h2 id="Наивная-реализация"><a href="#Наивная-реализация" class="headerlink" title="Наивная реализация"></a>Наивная реализация</h2><p>Прежде, чем начинать шаманить с макросами, нужно набросать наивную реализацию “быстрой” версии класса, хранящего свои данные в одном блоке памяти. Для этого можно использовать <a href="https://tiorun.gaijin.team/##S0ksTi7KLCj5/z86taIgv6gklislNU0hNzEzj0sBCAqKMvNKNJQ8UnNy8nUUwvOLclIUlTS5/v8HAA" target="_blank" rel="noopener">онлайн компилятор tio</a>.</p>
<div style="color: #d4d4d4;background-color: #1e1e1e;font-family: Consolas, 'Courier New', monospace;font-weight: normal;font-size: 14px;line-height: 19px;white-space: pre;"><div><span style="color: #c586c0;">struct</span><span style="color: #d4d4d4;"> Memblock</span></div><div><span style="color: #d4d4d4;">&#160; &#160; mem : </span><span style="color: #c586c0;">array</span><span style="color: #d4d4d4;">&lt;</span><span style="color: #4ec9b0;">uint8</span><span style="color: #d4d4d4;">&gt;</span></div><div><span style="color: #d4d4d4;">&#160; &#160; a: </span><span style="color: #4ec9b0;">int</span><span style="color: #d4d4d4;">?</span></div><div><span style="color: #d4d4d4;">&#160; &#160; aCount: </span><span style="color: #4ec9b0;">int</span></div><div><span style="color: #d4d4d4;">&#160; &#160; b: </span><span style="color: #4ec9b0;">float</span><span style="color: #d4d4d4;">?</span></div><div><span style="color: #d4d4d4;">&#160; &#160; bCount: </span><span style="color: #4ec9b0;">int</span></div><br><div><span style="color: #569cd6;">def</span><span style="color: #d4d4d4;"> </span><span style="color: #dcdcaa;">initMemblock</span><span style="color: #d4d4d4;">(</span><span style="color: #569cd6;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">memblock</span><span style="color: #d4d4d4;">: Memblock; </span><span style="color: #9cdcfe;">aCount</span><span style="color: #d4d4d4;">:</span><span style="color: #4ec9b0;">int</span><span style="color: #d4d4d4;">; </span><span style="color: #9cdcfe;">bCount</span><span style="color: #d4d4d4;">:</span><span style="color: #4ec9b0;">int</span><span style="color: #d4d4d4;">)</span></div><br><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">let</span><span style="color: #d4d4d4;"> aSize = </span><span style="color: #c586c0;">typeinfo</span><span style="color: #d4d4d4;">(sizeof *memblock.a) * aCount</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">let</span><span style="color: #d4d4d4;"> bSize = </span><span style="color: #c586c0;">typeinfo</span><span style="color: #d4d4d4;">(sizeof *memblock.b) * bCount</span></div><br><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> arr: </span><span style="color: #c586c0;">array</span><span style="color: #d4d4d4;">&lt;</span><span style="color: #4ec9b0;">uint8</span><span style="color: #d4d4d4;">&gt;</span></div><div><span style="color: #d4d4d4;">&#160; &#160; arr |&gt; </span><span style="color: #dcdcaa;">resize</span><span style="color: #d4d4d4;">(aSize + bSize )</span></div><div><span style="color: #d4d4d4;">&#160; &#160; memblock.mem &lt;- arr</span></div><br><div><span style="color: #d4d4d4;">&#160; &#160; memblock.aCount = aCount</span></div><div><span style="color: #d4d4d4;">&#160; &#160; memblock.bCount = bCount</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">unsafe</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; memblock.a = </span><span style="color: #c586c0;">reinterpret</span><span style="color: #d4d4d4;">&lt;</span><span style="color: #4ec9b0;">int</span><span style="color: #d4d4d4;">?&gt; </span><span style="color: #c586c0;">addr</span><span style="color: #d4d4d4;">(memblock.mem[</span><span style="color: #569cd6;">0</span><span style="color: #d4d4d4;">])</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; memblock.b = </span><span style="color: #c586c0;">reinterpret</span><span style="color: #d4d4d4;">&lt;</span><span style="color: #4ec9b0;">float</span><span style="color: #d4d4d4;">?&gt; </span><span style="color: #c586c0;">addr</span><span style="color: #d4d4d4;">(memblock.mem[</span><span style="color: #569cd6;">aSize</span><span style="color: #d4d4d4;">])</span></div><br><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; memblock.a[</span><span style="color: #569cd6;">0</span><span style="color: #d4d4d4;">] = int(</span><span style="color: #b5cea8;">0x11223344</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; memblock.a[</span><span style="color: #569cd6;">1</span><span style="color: #d4d4d4;">] = </span><span style="color: #b5cea8;">0</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; memblock.a[</span><span style="color: #569cd6;">2</span><span style="color: #d4d4d4;">] = -</span><span style="color: #b5cea8;">1</span></div><br><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; memblock.b[</span><span style="color: #569cd6;">0</span><span style="color: #d4d4d4;">] = </span><span style="color: #c586c0;">reinterpret</span><span style="color: #d4d4d4;">&lt;</span><span style="color: #4ec9b0;">float</span><span style="color: #d4d4d4;">&gt;(</span><span style="color: #b5cea8;">0x55667788</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; memblock.b[</span><span style="color: #569cd6;">1</span><span style="color: #d4d4d4;">] = </span><span style="color: #b5cea8;">0.0</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; memblock.b[</span><span style="color: #569cd6;">2</span><span style="color: #d4d4d4;">] = </span><span style="color: #b5cea8;">123.456</span></div><br><div><span style="color: #d4d4d4;">[</span><span style="color: #569cd6;">export</span><span style="color: #d4d4d4;">]</span></div><div><span style="color: #c586c0;">def</span><span style="color: #d4d4d4;"> main</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> memblock: Memblock</span></div><div><span style="color: #d4d4d4;">&#160; &#160; memblock |&gt; initMemblock(</span><span style="color: #b5cea8;">5</span><span style="color: #d4d4d4;">,</span><span style="color: #b5cea8;">5</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #dcdcaa;">print</span><span style="color: #d4d4d4;">(</span><span style="color: #ce9178;">"Memblock = {</span><span style="color: #9cdcfe;">memblock</span><span style="color: #ce9178;">}"</span><span style="color: #d4d4d4;">)</span></div><br><div><span style="color: #6a9955;">//Output:</span></div><div><span style="color: #6a9955;">// &#160;Memblock = [[ [[0x44; 0x33; 0x22; 0x11; 0x0; 0x0; 0x0; 0x0; 0xff; 0xff; 0xff; 0xff; 0x0; 0x0;</span></div><div><span style="color: #6a9955;">// &#160; &#160; 0x0; 0x0; 0x0; 0x0; 0x0; 0x0; 0x88; 0x77; 0x66; 0x55; 0x0; 0x0; 0x0; 0x0; 0x79; 0xe9; 0xf6; </span></div><div><span style="color: #6a9955;">// &#160; &#160; 0x42; 0x0; 0x0; 0x0; 0x0; 0x0; 0x0; 0x0; 0x0]]; 287454020; 5; 15837566074880.000000000; 5]]</span></div></div>
<p>Несколько замечаний про язык:</p>
<ul>
<li>Питоноподобный синтаксис с отступами. Для тех, кто не переносит такой формы синтаксиса, есть вариант без оступов, со скобочками и точками-с-запятыми.</li>
<li>Пайпы (<code>|&gt;</code> и <code>&lt;|</code>) как синтаксический сахар различных записи вызова функции (<a href="https://en.wikipedia.org/wiki/Uniform_Function_Call_Syntax" target="_blank" rel="noopener">UFCS</a>).</li>
<li>Более строгая типизация, чем в C/C++, из-за чего сложнее изучать язык и играться с ним — иногда приходится отвлекаться на то, чтобы разобраться, что именно компилятор от тебя хочет. По идее, должно помогать ловить в компайл-тайм больше того, что поймалось бы только в рантайме.</li>
<li><em>unsafe</em>, чтобы сказать компилятору “дай мне играться с указателями, как мне хочется, я знаю, что делаю”.</li>
<li>print умеет выводить внутренности структуры, можно убедиться, что данные действительно лежат в одном блоке памяти, как задумывалось.</li>
<li>Отсутствие семантики “=” для типов, для которых нет её однозначного определения. Вместо этого компилятор явно предлагает выбрать между клонированием (“:=”) и перемещением (“&lt;-“). В языке есть generic-функции, в них вроде можно попросить у компилятора данные о типах так, чтобы выбрать желаемое поведение.</li>
</ul>
<h2 id="Первый-макрос"><a href="#Первый-макрос" class="headerlink" title="Первый макрос"></a>Первый макрос</h2><p>Попробуем для начала написать простейший макрос, который выведет на экран список полей структуры. С этого момента не получится использовать онлайн компилятор, так как он не поддерживает загрузку кода из нескольких файлов, а макрос должен располагаться в отдельном модуле.</p>
<p>Причина того, что макрос не может находиться в том же модуле, что и структура, которую он обрабатывает, понятна — чтобы выполнить какой-либо код, обрабатывающий структуру на этапе компиляции, необходимо, чтобы сам этот код к этому моменту был уже скомпилирован.</p>
<p>В репозитории языка валяется готовый <a href="https://github.com/GaijinEntertainment/daScript/blob/073bc29145207b39180069ae60f00ed43fad6ea7/examples/test/misc/dump_fields.das" target="_blank" rel="noopener">пример</a> такого макроса, но в учебных целях немного перепишем его:</p>
<div style="color: #d4d4d4;background-color: #1e1e1e;font-family: Consolas, 'Courier New', monospace;font-weight: normal;font-size: 14px;line-height: 19px;white-space: pre;"><div><span style="color: #c586c0;">module</span><span style="color: #d4d4d4;"> macro_test</span></div><br><div><span style="color: #c586c0;">require</span><span style="color: #d4d4d4;"> ast</span></div><div><span style="color: #c586c0;">require</span><span style="color: #d4d4d4;"> daslib/ast_boost</span></div><br><div><span style="color: #d4d4d4;">[</span><span style="color: #569cd6;">structure_macro</span><span style="color: #d4d4d4;">(name=memblock)]</span></div><div><span style="color: #569cd6;">class</span><span style="color: #d4d4d4;"> </span><span style="color: #4ec9b0;">DumpFields</span><span style="color: #d4d4d4;"> : </span><span style="color: #4ec9b0;">AstStructureAnnotation</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #569cd6;">def override</span><span style="color: #d4d4d4;"> </span><span style="color: #dcdcaa;">finish</span><span style="color: #d4d4d4;"> ( </span><span style="color: #569cd6;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">st</span><span style="color: #d4d4d4;">:StructurePtr; </span><span style="color: #569cd6;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">group</span><span style="color: #d4d4d4;">:ModuleGroup; </span><span style="color: #9cdcfe;">args</span><span style="color: #d4d4d4;">:AnnotationArgumentList; </span><span style="color: #569cd6;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">errors </span><span style="color: #d4d4d4;">: das_string ) : </span><span style="color: #4ec9b0;">bool</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #dcdcaa;">print</span><span style="color: #d4d4d4;">(</span><span style="color: #ce9178;">"struct {</span><span style="color: #9cdcfe;">st</span><span style="color: #d4d4d4;">.</span><span style="color: #9cdcfe;">name</span><span style="color: #ce9178;">} </span><span style="color: #d7ba7d;">\{\n</span><span style="color: #ce9178;">"</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">for</span><span style="color: #d4d4d4;"> field </span><span style="color: #c586c0;">in</span><span style="color: #d4d4d4;"> st.fields</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; </span><span style="color: #dcdcaa;">print</span><span style="color: #d4d4d4;">(</span><span style="color: #ce9178;">"</span><span style="color: #d7ba7d;">\t</span><span style="color: #ce9178;">{describe_cpp(field</span><span style="color: #d4d4d4;">.</span><span style="color: #ce9178;">_type)} {</span><span style="color: #9cdcfe;">field</span><span style="color: #d4d4d4;">.</span><span style="color: #9cdcfe;">name</span><span style="color: #ce9178;">};</span><span style="color: #d7ba7d;">\n</span><span style="color: #ce9178;">"</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #dcdcaa;">print</span><span style="color: #d4d4d4;">(</span><span style="color: #ce9178;">"</span><span style="color: #d7ba7d;">\}\n</span><span style="color: #ce9178;">"</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">return</span><span style="color: #d4d4d4;"> </span><span style="color: #c586c0;">true</span></div></div>
<p>Макрос наследуется от класса <code>AstStructureAnnotation</code>, определённого в модуле <a href="https://github.com/GaijinEntertainment/daScript/blob/073bc29145207b39180069ae60f00ed43fad6ea7/src/builtin/ast.das#L75" target="_blank" rel="noopener">ast</a>, который представляет собой шаблон для аннотации структуры. К самому классу также применяется аннотация <code>structure_macro</code>, которая регистрирует данный макрос для применения к каждой структуре, отмеченной аннотацией <code>memblock</code>.</p>
<div style="color: #d4d4d4;background-color: #1e1e1e;font-family: Consolas, 'Courier New', monospace;font-weight: normal;font-size: 14px;line-height: 19px;white-space: pre;"><div><span style="color: #c586c0;">class</span><span style="color: #d4d4d4;"> AstStructureAnnotation</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #569cd6;">def abstract</span><span style="color: #d4d4d4;"> </span><span style="color: #dcdcaa;">apply</span><span style="color: #d4d4d4;"> ( </span><span style="color: #569cd6;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">st</span><span style="color: #d4d4d4;">:StructurePtr; </span><span style="color: #569cd6;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">group</span><span style="color: #d4d4d4;">:ModuleGroup; </span><span style="color: #9cdcfe;">args</span><span style="color: #d4d4d4;">:AnnotationArgumentList; </span><span style="color: #569cd6;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">errors </span><span style="color: #d4d4d4;">: das_string ) : </span><span style="color: #4ec9b0;">bool</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #569cd6;">def abstract</span><span style="color: #d4d4d4;"> </span><span style="color: #dcdcaa;">finish</span><span style="color: #d4d4d4;"> ( </span><span style="color: #569cd6;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">st</span><span style="color: #d4d4d4;">:StructurePtr; </span><span style="color: #569cd6;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">group</span><span style="color: #d4d4d4;">:ModuleGroup; </span><span style="color: #9cdcfe;">args</span><span style="color: #d4d4d4;">:AnnotationArgumentList; </span><span style="color: #569cd6;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">errors </span><span style="color: #d4d4d4;">: das_string ) : </span><span style="color: #4ec9b0;">bool</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #569cd6;">def abstract</span><span style="color: #d4d4d4;"> </span><span style="color: #dcdcaa;">patch</span><span style="color: #d4d4d4;"> ( </span><span style="color: #569cd6;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">st</span><span style="color: #d4d4d4;">:StructurePtr; </span><span style="color: #569cd6;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">group</span><span style="color: #d4d4d4;">:ModuleGroup; </span><span style="color: #9cdcfe;">args</span><span style="color: #d4d4d4;">:AnnotationArgumentList; </span><span style="color: #569cd6;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">errors </span><span style="color: #d4d4d4;">: das_string; </span><span style="color: #569cd6;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">astChanged</span><span style="color: #d4d4d4;">:</span><span style="color: #4ec9b0;">bool</span><span style="color: #d4d4d4;">&amp; ) : </span><span style="color: #4ec9b0;">bool</span></div></div>
<p>Интерфейс макроса позволяет переопределить три функции, чтобы “вклиниться” в процесс того, как компилятор обрабатывает определения структуры, на различных этапах. <a href="https://dascript.org/doc/reference/language/macros.html?highlight=macro#compilation-passes" target="_blank" rel="noopener">Документация по фазам компиляции</a>. <code>Apply</code> - наиболее подходящий момент, чтобы попробовать изменить поля структуры или сгенерировать код.</p>
<p>Если теперь отметить описание структуры аннотацией <code>memblock</code>, то компилятор “пропустит” её определение через макрос, который выведет названия полей на экран. В момент обработки информация о создаваемой структуре хранится в классе <code>StructurePtr</code>, определение которого можно найти поиском по C++ коду. На данном этапе макрос просто проходит по всем полям структуры и выводит информацию о каждом из них на экран. <code>describe_cpp</code> - это функция, которая выводит определения типа, как если бы он был объявлен в C++.</p>
<p>При запуске приложения на экран выведется:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Memblock</span> &#123;</span></span><br><span class="line">    TArray&lt;<span class="keyword">uint8_t</span>&gt; mem;</span><br><span class="line">    <span class="keyword">int32_t</span> * a;</span><br><span class="line">    <span class="keyword">int32_t</span> aСount;</span><br><span class="line">    <span class="keyword">int32_t</span> * b;</span><br><span class="line">    <span class="keyword">int32_t</span> bCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Можно немного поиграться с определением макроса:</p>
<div style="color: #d4d4d4;background-color: #1e1e1e;font-family: Consolas, 'Courier New', monospace;font-weight: normal;font-size: 14px;line-height: 19px;white-space: pre;"><div><span style="color: #d4d4d4;">[</span><span style="color: #569cd6;">structure_macro</span><span style="color: #d4d4d4;">(name=memblock)]</span></div><div><span style="color: #569cd6;">class</span><span style="color: #d4d4d4;"> </span><span style="color: #4ec9b0;">GenMemblock</span><span style="color: #d4d4d4;"> : </span><span style="color: #4ec9b0;">AstStructureAnnotation</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #569cd6;">def override</span><span style="color: #d4d4d4;"> </span><span style="color: #dcdcaa;">apply</span><span style="color: #d4d4d4;"> ( </span><span style="color: #569cd6;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">st</span><span style="color: #d4d4d4;">:StructurePtr; </span><span style="color: #569cd6;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">group</span><span style="color: #d4d4d4;">:ModuleGroup; </span><span style="color: #9cdcfe;">args</span><span style="color: #d4d4d4;">:AnnotationArgumentList; </span><span style="color: #569cd6;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">errors </span><span style="color: #d4d4d4;">: das_string ) : </span><span style="color: #4ec9b0;">bool</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> mkS &lt;- </span><span style="color: #c586c0;">new</span><span style="color: #d4d4d4;"> [[ Structure() ]] &#160; &#160; &#160; &#160; </span><span style="color: #6a9955;">//создаём новую структуру</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; mkS.name := </span><span style="color: #ce9178;">"MemblockTest"</span><span style="color: #d4d4d4;"> &#160; &#160; &#160; &#160; &#160; &#160; &#160; </span><span style="color: #6a9955;">//с именем MemblockTest</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">let</span><span style="color: #d4d4d4;"> fieldsLen = st.fields |&gt; </span><span style="color: #dcdcaa;">length</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; mkS.fields |&gt; </span><span style="color: #dcdcaa;">resize</span><span style="color: #d4d4d4;">(fieldsLen) &#160; &#160; &#160; </span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">for</span><span style="color: #d4d4d4;"> i </span><span style="color: #c586c0;">in</span><span style="color: #d4d4d4;"> range(</span><span style="color: #b5cea8;">0</span><span style="color: #d4d4d4;">, fieldsLen)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; mkS.fields[</span><span style="color: #569cd6;">i</span><span style="color: #d4d4d4;">] := st.fields[</span><span style="color: #569cd6;">i</span><span style="color: #d4d4d4;">] &#160; &#160; &#160; &#160;</span><span style="color: #6a9955;">//копируем в неё все поля из обрабатываемой структуры</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; compiling_module() |&gt; add_structure(mkS) </span><span style="color: #6a9955;">//добавляем в компилирующийся сейчас модуль новый тип</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">return</span><span style="color: #d4d4d4;"> </span><span style="color: #c586c0;">true</span></div><br><div><span style="color: #6a9955;">//Скрипт, использующий модуль с макросом</span></div><div><span style="color: #c586c0;">require</span><span style="color: #d4d4d4;"> macro_test</span></div><br><div><span style="color: #d4d4d4;">[</span><span style="color: #569cd6;">memblock</span><span style="color: #d4d4d4;">]</span></div><div><span style="color: #c586c0;">struct</span><span style="color: #d4d4d4;"> Memblock</span></div><div><span style="color: #d4d4d4;">&#160; &#160; mem : </span><span style="color: #c586c0;">array</span><span style="color: #d4d4d4;">&lt;</span><span style="color: #4ec9b0;">uint8</span><span style="color: #d4d4d4;">&gt;</span></div><div><span style="color: #d4d4d4;">&#160; &#160; a: </span><span style="color: #4ec9b0;">int</span><span style="color: #d4d4d4;">?</span></div><div><span style="color: #d4d4d4;">&#160; &#160; aCount: </span><span style="color: #4ec9b0;">int</span></div><div><span style="color: #d4d4d4;">&#160; &#160; b: </span><span style="color: #4ec9b0;">float</span><span style="color: #d4d4d4;">?</span></div><div><span style="color: #d4d4d4;">&#160; &#160; bCount: </span><span style="color: #4ec9b0;">int</span></div><br><div><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> memblock1: Memblock</span></div><div><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> memblock2: MemblockTest </span><span style="color: #6a9955;">//ага, новый тип MemblockTest!</span></div><div><span style="color: #dcdcaa;">print</span><span style="color: #d4d4d4;">(</span><span style="color: #ce9178;">"MemblockTest = {</span><span style="color: #9cdcfe;">memblock2</span><span style="color: #ce9178;">}"</span><span style="color: #d4d4d4;">)</span></div></div>
<h2 id="Генерация-полей"><a href="#Генерация-полей" class="headerlink" title="Генерация полей"></a>Генерация полей</h2><p>Следующим шагом попробуем убрать поле <code>mem</code> из исходной структуры, и создать его из макроса.</p>
<div style="color: #d4d4d4;background-color: #1e1e1e;font-family: Consolas, 'Courier New', monospace;font-weight: normal;font-size: 14px;line-height: 19px;white-space: pre;"><div><span style="color: #d4d4d4;">[</span><span style="color: #569cd6;">structure_macro</span><span style="color: #d4d4d4;">(name=memblock)]</span></div><div><span style="color: #569cd6;">class</span><span style="color: #d4d4d4;"> </span><span style="color: #4ec9b0;">GenMemblock</span><span style="color: #d4d4d4;"> : </span><span style="color: #4ec9b0;">AstStructureAnnotation</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #569cd6;">def override</span><span style="color: #d4d4d4;"> </span><span style="color: #dcdcaa;">apply</span><span style="color: #d4d4d4;"> ( </span><span style="color: #569cd6;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">st</span><span style="color: #d4d4d4;">:StructurePtr; </span><span style="color: #569cd6;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">group</span><span style="color: #d4d4d4;">:ModuleGroup; </span><span style="color: #9cdcfe;">args</span><span style="color: #d4d4d4;">:AnnotationArgumentList; </span><span style="color: #569cd6;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">errors </span><span style="color: #d4d4d4;">: das_string ) : </span><span style="color: #4ec9b0;">bool</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> mkS &lt;- </span><span style="color: #c586c0;">new</span><span style="color: #d4d4d4;"> [[ Structure() ]]</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; mkS.name := </span><span style="color: #ce9178;">"MemblockTest"</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">let</span><span style="color: #d4d4d4;"> fieldsLen = st.fields |&gt; </span><span style="color: #dcdcaa;">length</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; mkS.fields |&gt; </span><span style="color: #dcdcaa;">resize</span><span style="color: #d4d4d4;">(fieldsLen+</span><span style="color: #b5cea8;">1</span><span style="color: #d4d4d4;">)</span></div><br><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #6a9955;">//определение типа uint8, как это видит компилятор</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> uint8Type &lt;- </span><span style="color: #c586c0;">new</span><span style="color: #d4d4d4;"> [[TypeDecl() baseType=Type tUInt8]]</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #6a9955;">//определение array&lt;uint8&gt; </span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> uint8ArrayType &lt;- </span><span style="color: #c586c0;">new</span><span style="color: #d4d4d4;"> [[TypeDecl() baseType=Type tArray, firstType &lt;- uint8Type]]</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #6a9955;">//декларация нового поля с именем mem и типом array&lt;uint8&gt; </span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; mkS.fields[</span><span style="color: #569cd6;">0</span><span style="color: #d4d4d4;">] := *</span><span style="color: #c586c0;">new</span><span style="color: #d4d4d4;"> [[ FieldDeclaration() name:=</span><span style="color: #ce9178;">"mem"</span><span style="color: #d4d4d4;">, _type &lt;- uint8ArrayType]]</span></div><br><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">for</span><span style="color: #d4d4d4;"> i </span><span style="color: #c586c0;">in</span><span style="color: #d4d4d4;"> range(</span><span style="color: #b5cea8;">0</span><span style="color: #d4d4d4;">, fieldsLen)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; mkS.fields[</span><span style="color: #569cd6;">i+1</span><span style="color: #d4d4d4;">] := st.fields[</span><span style="color: #569cd6;">i</span><span style="color: #d4d4d4;">]</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; compiling_module() |&gt; add_structure(mkS)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">return</span><span style="color: #d4d4d4;"> </span><span style="color: #c586c0;">true</span></div><br><div><span style="color: #6a9955;">//Скрипт, использующий модуль с макросом</span></div><div><span style="color: #d4d4d4;">[</span><span style="color: #569cd6;">memblock</span><span style="color: #d4d4d4;">]</span></div><div><span style="color: #c586c0;">struct</span><span style="color: #d4d4d4;"> Memblock</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #6a9955;">//mem : array&lt;uint8&gt; &#160;//теперь поля нет в исходной структуре</span></div><div><span style="color: #d4d4d4;">&#160; &#160; a: </span><span style="color: #4ec9b0;">int</span><span style="color: #d4d4d4;">?</span></div><div><span style="color: #d4d4d4;">&#160; &#160; aCount: </span><span style="color: #4ec9b0;">int</span></div><div><span style="color: #d4d4d4;">&#160; &#160; b: </span><span style="color: #4ec9b0;">float</span><span style="color: #d4d4d4;">?</span></div><div><span style="color: #d4d4d4;">&#160; &#160; bCount: </span><span style="color: #4ec9b0;">int</span></div><br><div><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> memblock: MemblockTest</span></div><div><span style="color: #6a9955;">//у структуры MemblockTest появилось поле mem, сгенерированное макросом</span></div><div><span style="color: #dcdcaa;">print</span><span style="color: #d4d4d4;">(</span><span style="color: #ce9178;">"MemblockTest = {</span><span style="color: #9cdcfe;">memblock</span><span style="color: #d4d4d4;">.</span><span style="color: #9cdcfe;">mem</span><span style="color: #ce9178;">}"</span><span style="color: #d4d4d4;">)</span></div></div>
<ul>
<li>функция <code>resize</code> изменяет размер массива, <a href="https://dascript.org/doc/stdlib/builtin.html#containers" target="_blank" rel="noopener">документация</a> функций для работы с контейерами.</li>
<li>можно изменять поля определяемой структуры прямо на месте - макрос выполняется в сам момент её определения. Создание новой структуры с другим именем сделано для наглядности примера.</li>
<li>генерация структур компилятора для определения поля сперва выглядит немного “космически”, дальше будет пример использования функции <code>quote</code>, которая позволяет перевести код как его писал бы человек, в выражение, которое сгенерирует компилятор при парсинге этого кода. Но полезно разобраться с таким способом генерации кода, чтобы привыкнуть к нему. Также стоит найти определения <code>TypeDecl</code> и <code>FieldDeclaration</code> в исходном коде компилятора, это самая надёжная документация.</li>
<li>“оператор” обращения к конкретному значению перечисления — пробел (<code>Type tArray</code> - значение <code>tArray</code> перечисления <code>Type</code>). Очень необычное решение.</li>
<li>при кодогенерации необходимо заботиться о том, чтобы сгенерированное имя не пересекалось с тем, которое может захотеть использовать программист. В этом смысле <code>mem</code> — плохое имя для сгенерированного поля, в реальном коде необходимо было бы какое-либо соглашение об именах, авторы языка используют символ ‘`’ (гравис, backquote) для отметки генерированного кода.</li>
</ul>
<p>Таким же образом можно перенести поля <code>aCount</code> и <code>bCount</code> в генерирующий макрос:</p>
<div style="color: #d4d4d4;background-color: #1e1e1e;font-family: Consolas, 'Courier New', monospace;font-weight: normal;font-size: 14px;line-height: 19px;white-space: pre;"><div><span style="color: #d4d4d4;">[</span><span style="color: #569cd6;">structure_macro</span><span style="color: #d4d4d4;">(name=memblock)]</span></div><div><span style="color: #569cd6;">class</span><span style="color: #d4d4d4;"> </span><span style="color: #4ec9b0;">GenMemblock</span><span style="color: #d4d4d4;"> : </span><span style="color: #4ec9b0;">AstStructureAnnotation</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #569cd6;">def override</span><span style="color: #d4d4d4;"> </span><span style="color: #dcdcaa;">apply</span><span style="color: #d4d4d4;"> ( </span><span style="color: #569cd6;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">st</span><span style="color: #d4d4d4;">:StructurePtr; </span><span style="color: #569cd6;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">group</span><span style="color: #d4d4d4;">:ModuleGroup; </span><span style="color: #9cdcfe;">args</span><span style="color: #d4d4d4;">:AnnotationArgumentList; </span><span style="color: #569cd6;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">errors </span><span style="color: #d4d4d4;">: das_string ) : </span><span style="color: #4ec9b0;">bool</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #6a9955;">//create "mem" field of type array&lt;uint8&gt;</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> uint8Type &lt;- </span><span style="color: #c586c0;">new</span><span style="color: #d4d4d4;"> [[TypeDecl() baseType=Type tUInt8]]</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> uint8ArrayType &lt;- </span><span style="color: #c586c0;">new</span><span style="color: #d4d4d4;"> [[TypeDecl() baseType=Type tArray, firstType &lt;- uint8Type]]</span></div><br><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">let</span><span style="color: #d4d4d4;"> fieldsLen = st.fields |&gt; </span><span style="color: #dcdcaa;">length</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> ptrsCount = </span><span style="color: #b5cea8;">0</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> ptrsTypeIndexes : </span><span style="color: #c586c0;">array</span><span style="color: #d4d4d4;">&lt;</span><span style="color: #4ec9b0;">int</span><span style="color: #d4d4d4;">&gt;</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; ptrsTypeIndexes |&gt; reserve(fieldsLen)</span></div><br><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #6a9955;">//Проходим по списку всех полей и сохраняем индексы полей, тип которых -- указатель</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">for</span><span style="color: #d4d4d4;"> i </span><span style="color: #c586c0;">in</span><span style="color: #d4d4d4;"> range(</span><span style="color: #b5cea8;">0</span><span style="color: #d4d4d4;">, fieldsLen)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">if</span><span style="color: #d4d4d4;"> st.fields[</span><span style="color: #569cd6;">i</span><span style="color: #d4d4d4;">]._type.baseType == Type tPointer </span><span style="color: #6a9955;">//проверка типа поля</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; ptrsCount++</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; ptrsTypeIndexes |&gt; </span><span style="color: #dcdcaa;">push</span><span style="color: #d4d4d4;">(i)</span></div><br><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #6a9955;">//add one field for memblock and one field per pointer type to handle count of object per type</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; st.fields |&gt; </span><span style="color: #dcdcaa;">resize</span><span style="color: #d4d4d4;">(fieldsLen+ ptrsCount + </span><span style="color: #b5cea8;">1</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; st.fields[</span><span style="color: #569cd6;">fieldsLen</span><span style="color: #d4d4d4;">] := *</span><span style="color: #c586c0;">new</span><span style="color: #d4d4d4;"> [[ FieldDeclaration() name:=</span><span style="color: #ce9178;">"mem"</span><span style="color: #d4d4d4;">, _type &lt;- uint8ArrayType]]</span></div><br><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">for</span><span style="color: #d4d4d4;"> i </span><span style="color: #c586c0;">in</span><span style="color: #d4d4d4;"> range(</span><span style="color: #b5cea8;">0</span><span style="color: #d4d4d4;">, ptrsCount)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; </span><span style="color: #6a9955;">//генерируем имя поля - добавляем к нему постфикс `count</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">let</span><span style="color: #d4d4d4;"> fieldCountName = </span><span style="color: #ce9178;">"{</span><span style="color: #9cdcfe;">st</span><span style="color: #d4d4d4;">.</span><span style="color: #9cdcfe;">fields</span><span style="color: #ce9178;">[</span><span style="color: #569cd6;">ptrsTypeIndexes[i</span><span style="color: #ce9178;">]]</span><span style="color: #d4d4d4;">.</span><span style="color: #9cdcfe;">name</span><span style="color: #ce9178;">}{"`count"}"</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; </span><span style="color: #6a9955;">//генерируем новое поля типа int для каждого поля</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; st.fields[</span><span style="color: #569cd6;">fieldsLen+1+i</span><span style="color: #d4d4d4;">] := *</span><span style="color: #c586c0;">new</span><span style="color: #d4d4d4;"> [[ FieldDeclaration() name:=fieldCountName, _type &lt;- </span><span style="color: #c586c0;">new</span><span style="color: #d4d4d4;"> [[TypeDecl() baseType=Type tInt]]]]</span></div><br><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">return</span><span style="color: #d4d4d4;"> </span><span style="color: #c586c0;">true</span></div><br><div><span style="color: #d4d4d4;">[</span><span style="color: #569cd6;">memblock</span><span style="color: #d4d4d4;">]</span></div><div><span style="color: #6a9955;">//сама структура теперь содержит только определение полей</span></div><div><span style="color: #c586c0;">struct</span><span style="color: #d4d4d4;"> Memblock</span></div><div><span style="color: #d4d4d4;">&#160; &#160; a: </span><span style="color: #4ec9b0;">int</span><span style="color: #d4d4d4;">?</span></div><div><span style="color: #d4d4d4;">&#160; &#160; b: </span><span style="color: #4ec9b0;">float</span><span style="color: #d4d4d4;">?</span></div><br><div><span style="color: #6a9955;">//вывод скрипта -- сгенерированные поля</span></div><div><span style="color: #c586c0;">struct</span><span style="color: #d4d4d4;"> Memblock {</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; int32_t * a;</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #4ec9b0;">float</span><span style="color: #d4d4d4;"> * b;</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; TArray&lt;uint8_t&gt; mem;</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; int32_t a`count;</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; int32_t b`count;</span></div><div><span style="color: #d4d4d4;">}</span></div></div>
<p>Разумеется, в реальном мире бывают структуры, которые могут содержать одновременно как указатели на память, которую должна выделять и освобождать сама структура, так и те, которые указывают на память, которую структура трогать не должна. Пока что мы считаем, что структура, отмеченная как <code>memblock</code>, содержит только указатели на память, которую выделяет и освобождает сама. Забегая наперёд, реализовать поддержку обоих типов указателей можно с помощью аннотаций типа (я не нашёл ссылок на аннотации в документации, но их можно найти в коде (<a href="https://github.com/borisbat/dasBGFX/blob/a1e10ab439e5996a0a4d8722689e2b0fab4e72d9/examples/01_hello_triangle.das#L7" target="_blank" rel="noopener">пример</a>)). Аннотации типа будут рассмотрены сильно дальше, при реализации наследования от memblock-структур.</p>
<p>На данном этапе мы получили возможность описать структуру с любым количеством полей, и с помощью макроса сгенерировать по этому описанию недостающие поля. К сожалению, функцию <code>initMemblock</code> (конструктор структуры), по прежнему необходимо писать руками, что очень неприятно.</p>
<h2 id="Подготовка-к-генерация-кода-конструктора"><a href="#Подготовка-к-генерация-кода-конструктора" class="headerlink" title="Подготовка к генерация кода конструктора"></a>Подготовка к генерация кода конструктора</h2><p>Для начала стоит немного переписать код <code>initMemblock</code>, чтобы отделить часть инициализации структуры, которую нужно сгенерировать. Также добавлено третье поле, для того, чтобы увидеть, какие изменения потребуется сейчас внести в код <code>initMemblock</code></p>
<div style="color: #d4d4d4;background-color: #1e1e1e;font-family: Consolas, 'Courier New', monospace;font-weight: normal;font-size: 14px;line-height: 19px;white-space: pre;"><div><span style="color: #6a9955;">//аннотация того, что к структуре надо применить 2 макроса, добавляющий поля, и дебажный, отображающий все поля</span></div><div><span style="color: #d4d4d4;">[</span><span style="color: #569cd6;">memblock,</span><span style="color: #d4d4d4;"> dump_fields]</span></div><div><span style="color: #c586c0;">struct</span><span style="color: #d4d4d4;"> Memblock</span></div><div><span style="color: #d4d4d4;">&#160; &#160; a: </span><span style="color: #4ec9b0;">int</span><span style="color: #d4d4d4;">?</span></div><div><span style="color: #d4d4d4;">&#160; &#160; b: </span><span style="color: #4ec9b0;">float</span><span style="color: #d4d4d4;">?</span></div><div><span style="color: #d4d4d4;">&#160; &#160; c: </span><span style="color: #4ec9b0;">int</span><span style="color: #d4d4d4;">?</span></div><br><div><span style="color: #6a9955;">//Шаблонный код инициализации, типовой для memblock-структур</span></div><div><span style="color: #6a9955;">// &#160;необходимо научиться генерировать его, чтобы не писать руками для каждой структуры</span></div><div><span style="color: #569cd6;">def</span><span style="color: #d4d4d4;"> </span><span style="color: #dcdcaa;">initMemblock</span><span style="color: #d4d4d4;">(</span><span style="color: #569cd6;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">memblock</span><span style="color: #d4d4d4;">: Memblock; </span><span style="color: #9cdcfe;">aCount</span><span style="color: #d4d4d4;">:</span><span style="color: #4ec9b0;">int</span><span style="color: #d4d4d4;">; </span><span style="color: #9cdcfe;">bCount</span><span style="color: #d4d4d4;">:</span><span style="color: #4ec9b0;">int</span><span style="color: #d4d4d4;">; </span><span style="color: #9cdcfe;">cCount</span><span style="color: #d4d4d4;">:</span><span style="color: #4ec9b0;">int</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; memblock.a`count = aCount</span></div><div><span style="color: #d4d4d4;">&#160; &#160; memblock.b`count = bCount</span></div><div><span style="color: #d4d4d4;">&#160; &#160; memblock.c`count = cCount &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;</span><span style="color: #6a9955;">//новое</span></div><br><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">let</span><span style="color: #d4d4d4;"> aSize = </span><span style="color: #c586c0;">typeinfo</span><span style="color: #d4d4d4;">(sizeof *memblock.a) * aCount</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">let</span><span style="color: #d4d4d4;"> bSize = </span><span style="color: #c586c0;">typeinfo</span><span style="color: #d4d4d4;">(sizeof *memblock.b) * bCount</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">let</span><span style="color: #d4d4d4;"> cSize = </span><span style="color: #c586c0;">typeinfo</span><span style="color: #d4d4d4;">(sizeof *memblock.c) * cCount &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;</span><span style="color: #6a9955;">//новое</span></div><br><div><span style="color: #d4d4d4;">&#160; &#160; memblock.mem |&gt; </span><span style="color: #dcdcaa;">resize</span><span style="color: #d4d4d4;">(aSize + bSize + cSize) &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;</span><span style="color: #6a9955;">//новое</span></div><br><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">unsafe</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; memblock.a = </span><span style="color: #c586c0;">reinterpret</span><span style="color: #d4d4d4;">&lt;</span><span style="color: #4ec9b0;">int</span><span style="color: #d4d4d4;">?&gt; </span><span style="color: #c586c0;">addr</span><span style="color: #d4d4d4;">(memblock.mem[</span><span style="color: #569cd6;">0</span><span style="color: #d4d4d4;">])</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; memblock.b = </span><span style="color: #c586c0;">reinterpret</span><span style="color: #d4d4d4;">&lt;</span><span style="color: #4ec9b0;">float</span><span style="color: #d4d4d4;">?&gt; </span><span style="color: #c586c0;">addr</span><span style="color: #d4d4d4;">(memblock.mem[</span><span style="color: #569cd6;">aSize</span><span style="color: #d4d4d4;">])</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; memblock.c = </span><span style="color: #c586c0;">reinterpret</span><span style="color: #d4d4d4;">&lt;</span><span style="color: #4ec9b0;">int</span><span style="color: #d4d4d4;">?&gt; </span><span style="color: #c586c0;">addr</span><span style="color: #d4d4d4;">(memblock.mem[</span><span style="color: #569cd6;">aSize+bSize</span><span style="color: #d4d4d4;">]) </span><span style="color: #6a9955;">//новое</span></div><br><div><span style="color: #6a9955;">//Пример использования структуры</span></div><div><span style="color: #569cd6;">def</span><span style="color: #d4d4d4;"> </span><span style="color: #dcdcaa;">fillMemblock</span><span style="color: #d4d4d4;">(</span><span style="color: #569cd6;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">memblock</span><span style="color: #d4d4d4;">: Memblock)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">unsafe</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; memblock.a[</span><span style="color: #569cd6;">0</span><span style="color: #d4d4d4;">] = int(</span><span style="color: #b5cea8;">0x11223344</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; memblock.a[</span><span style="color: #569cd6;">1</span><span style="color: #d4d4d4;">] = </span><span style="color: #b5cea8;">0</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; memblock.a[</span><span style="color: #569cd6;">2</span><span style="color: #d4d4d4;">] = -</span><span style="color: #b5cea8;">1</span></div><br><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; memblock.b[</span><span style="color: #569cd6;">0</span><span style="color: #d4d4d4;">] = </span><span style="color: #c586c0;">reinterpret</span><span style="color: #d4d4d4;">&lt;</span><span style="color: #4ec9b0;">float</span><span style="color: #d4d4d4;">&gt;(</span><span style="color: #b5cea8;">0x55667788</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; memblock.b[</span><span style="color: #569cd6;">1</span><span style="color: #d4d4d4;">] = </span><span style="color: #b5cea8;">0.0</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; memblock.b[</span><span style="color: #569cd6;">2</span><span style="color: #d4d4d4;">] = </span><span style="color: #b5cea8;">123.456</span></div><br><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; memblock.c[</span><span style="color: #569cd6;">0</span><span style="color: #d4d4d4;">] = int(</span><span style="color: #b5cea8;">0xAABBCCDD</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; memblock.c[</span><span style="color: #569cd6;">1</span><span style="color: #d4d4d4;">] = </span><span style="color: #b5cea8;">0</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; memblock.c[</span><span style="color: #569cd6;">2</span><span style="color: #d4d4d4;">] = -</span><span style="color: #b5cea8;">1</span></div><br><div><span style="color: #6a9955;">//Тест</span></div><div><span style="color: #d4d4d4;">[</span><span style="color: #569cd6;">export</span><span style="color: #d4d4d4;">]</span></div><div><span style="color: #c586c0;">def</span><span style="color: #d4d4d4;"> test</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> memblock: Memblock</span></div><div><span style="color: #d4d4d4;">&#160; &#160; memblock |&gt; initMemblock(</span><span style="color: #b5cea8;">5</span><span style="color: #d4d4d4;">,</span><span style="color: #b5cea8;">5</span><span style="color: #d4d4d4;">,</span><span style="color: #b5cea8;">5</span><span style="color: #d4d4d4;">) </span><span style="color: #6a9955;">//кол-во аргументов конструктора, зависит от количества полей структуры</span></div><div><span style="color: #d4d4d4;">&#160; &#160; memblock |&gt; fillMemblock</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #dcdcaa;">print</span><span style="color: #d4d4d4;">(</span><span style="color: #ce9178;">"Memblock = {</span><span style="color: #9cdcfe;">memblock</span><span style="color: #ce9178;">}"</span><span style="color: #d4d4d4;">)</span></div></div>
<p>Прежде, чем приступать к написанию макроса, генерирующего функцию <code>initMemblock</code>, стоит разобраться с парой примеров:</p>
<p><a href="https://github.com/GaijinEntertainment/daScript/blob/073bc29145207b39180069ae60f00ed43fad6ea7/examples/test/misc/gen_fields.das" target="_blank" rel="noopener">gen_field.das</a> — генерация функции, логгирующей создание полей структуры.</p>
<ul>
<li>Приведены два макроса <code>DumpFields</code> и <code>Dump2Fields</code>, работающие на различных стадиях (apply/finish), во время генерации структуры, и после окончания.</li>
<li>На момент написание заметки пример был сломан, для фикса необходимо убрать код, касающийся типа <code>EntityId</code> — видимо, пример выдран из какого-то более масштабного кода, и опредения то ли забыли перенести, то ли забыли добавить модуль, содержащий их.</li>
<li>флаг функции “<code>fn.flags |= FunctionFlags init</code>“ говорит компилятору о том, что функция должна быть вызвана сразу после генерации (я какое-то время тупил с тем, чтобы понять, на какой стадии компиляции, кто и почему её вызывает).</li>
</ul>
<p><a href="https://github.com/GaijinEntertainment/daScript/blob/073bc29145207b39180069ae60f00ed43fad6ea7/examples/test/misc/ast_print.das" target="_blank" rel="noopener">ast_print.das</a> - макрос, выводящий исходный текст на dascript переданного ему выражения на daScript.</p>
<ul>
<li>этот пример в репозитории тоже немного сломан (<a href="https://github.com/spiiin/dascript_macro_tutorial/blob/master/examples/ast_print.das" target="_blank" rel="noopener">Fixed version</a>)</li>
</ul>
<p>Теперь применим немного рекурсивной магии.</p>
<p>Этот макрос может быть очень полезным, если переделать его так, чтобы он печатал не исходный текст переданного ему выражения, а исходный текст МАКРОСА, генерирующего при выполнении само это выражение.</p>
<p>Это очень важная для упрощения метапрограммирования часть, поэтому повторю ещё раз. Вместо написания макроса, генерирующего функцию <code>initMemblock</code>, мы сначала напишем <strong><code>макрос ast_print_expression, который выведет на экран текст, который поможет нам написать макрос generateInitMemblockFunction, генерирующий функцию initMemblock</code></strong> (или любую другую функцию). Звучит запутанно, но это не так сложно, как кажется.<br>(всё, больше не буду повторять, язык сломать можно)</p>
<p>Модифицируем функцию <code>ast_print</code> так, чтобы она не просто печатала исходный текст переданного ей выражения, а дополнительно печатала тип каждого подвыражения (<code>Subexpression</code>) этого выражения.<br>Вот такая функция:<br><a href="https://github.com/spiiin/dascript_macro_tutorial/blob/master/examples/macro_print_ast.das" target="_blank" rel="noopener">ast_print_expression</a> (конечно, немного “наколенная”)</p>
<p>Теперь можно начать последовательно копировать типы подвыражений в макрос, генерирующий функцию <code>initMemblock</code>, постепенно модифицируя его так, чтобы добавлять параметры, позволяющие генерировать различные варианты этой функции.</p>
<p>Рабочий процесс на этом этапе удобно зациклить так:</p>
<ul>
<li>Модифицируем текст initMemblock</li>
<li>Перезапускаем компиляцию функции, чтобы макрос ast_print_expression применился к этой функции и вывел на экран выражение, в которое преобразуется функция</li>
<li>Копируем часть выражения в макрос generateInitMemblockFunction, который должен сгенерировать новую функцию initMemblock_generated, идентичную самой функции initMemblock</li>
<li>Модифицируем макрос generateInitMemblockFunction, чтобы добавить в него код, генерирующий переменную часть функции</li>
<li>Перекомпилируем функцию initMemblock_generated, чтобы применить к ней макрос ast_print, для того, чтобы получить исходный код функции и сверить его с исходный кодом initMemblock</li>
</ul>
<p>Выглядит запутанно, но это необходимо для того, чтобы иметь возможность выполнить шаг 4 - “переменная часть функции” — те строчки, которые изменяются в функции <code>initMemblock</code> после того, как мы изменяем какое-либо поле структуры <code>Memblock</code> (посмотрите исходный код функции <code>initMemblock</code> и отметки <code>//новое</code>, это строчки, которые добавились после добавления поля с именем <code>c</code> — это как раз эта “переменная часть функции”).</p>
<p>Самое интересное, что перевести программу в режим REPL практически элементарно, достаточно зациклить C++ часть самого первого туториала из репозитория daScript, перекомпилируя daScript-ы заново при вводе любого символа:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span>, <span class="keyword">char</span> * [] )</span> </span>&#123;</span><br><span class="line">    NEED_ALL_DEFAULT_MODULES;</span><br><span class="line">    Module::Initialize();</span><br><span class="line">    <span class="keyword">char</span> a = <span class="string">'x'</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        tutorial();</span><br><span class="line">        <span class="comment">//тут скорее всего надо не забыть очистить память, выделенную в цикле работы</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">    &#125;</span><br><span class="line">    Module::Shutdown();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Рабочий процесс выглядит примерно так:<br><img src="/blog/1547564887/memblock_example.png" alt="fox"><br>Слева код в <a href="https://marketplace.visualstudio.com/items?itemName=profelis.dascript-plugin" target="_blank" rel="noopener">Visual Studio Code</a>, справа программа, выполняющая этот код без необходимости перезапуска. После подготовки можно переходить и к генерации кода, с Repl-режимом это будет значительно проще.</p>
<h2 id="Генерация-функции-initMemblock"><a href="#Генерация-функции-initMemblock" class="headerlink" title="Генерация функции initMemblock"></a>Генерация функции initMemblock</h2><p>Макрос <code>ast_print_expression</code> применённый к функции initMemblock, выводит на экран:</p>
<div style="color: #d4d4d4;background-color: #1e1e1e;font-family: Consolas, 'Courier New', monospace;font-weight: normal;font-size: 14px;line-height: 19px;white-space: pre;"><div><span style="color: #d4d4d4;">---das------------------</span><span style="color: #6a9955;">// [modifyExternal][modifyArgument]</span></div><div><span style="color: #569cd6;">def</span><span style="color: #d4d4d4;"> </span><span style="color: #dcdcaa;">initMemblock</span><span style="color: #d4d4d4;"> ( </span><span style="color: #569cd6;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">memblock </span><span style="color: #d4d4d4;">: Memblock -</span><span style="color: #569cd6;">const</span><span style="color: #d4d4d4;">; </span><span style="color: #9cdcfe;">aCount </span><span style="color: #d4d4d4;">: </span><span style="color: #4ec9b0;">int</span><span style="color: #d4d4d4;"> </span><span style="color: #569cd6;">const</span><span style="color: #d4d4d4;">; </span><span style="color: #9cdcfe;">bCount </span><span style="color: #d4d4d4;">: </span><span style="color: #4ec9b0;">int</span><span style="color: #d4d4d4;"> </span><span style="color: #569cd6;">const</span><span style="color: #d4d4d4;">; </span><span style="color: #9cdcfe;">cCount </span><span style="color: #d4d4d4;">: </span><span style="color: #4ec9b0;">int</span><span style="color: #d4d4d4;"> </span><span style="color: #569cd6;">const</span><span style="color: #d4d4d4;"> )</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; ExprVar memblock. ExprField a`count ExprCopyRight = ExprVar aCount</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; ExprVar memblock. ExprField b`count ExprCopyRight = ExprVar bCount</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; ExprVar memblock. ExprField c`count ExprCopyRight = ExprVar cCount</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; ExprLet </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> &#160;ExprLetVariable aSize : </span><span style="color: #4ec9b0;">int</span><span style="color: #d4d4d4;"> </span><span style="color: #c586c0;">const</span><span style="color: #d4d4d4;"> = &#160;ExprOp2(ExprVar aCount ExprOp2Right * </span><span style="color: #b5cea8;">4</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; ExprLet </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> &#160;ExprLetVariable bSize : </span><span style="color: #4ec9b0;">int</span><span style="color: #d4d4d4;"> </span><span style="color: #c586c0;">const</span><span style="color: #d4d4d4;"> = &#160;ExprOp2(ExprVar bCount ExprOp2Right * </span><span style="color: #b5cea8;">4</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; ExprLet </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> &#160;ExprLetVariable cSize : </span><span style="color: #4ec9b0;">int</span><span style="color: #d4d4d4;"> </span><span style="color: #c586c0;">const</span><span style="color: #d4d4d4;"> = &#160;ExprOp2(ExprVar cCount ExprOp2Right * </span><span style="color: #b5cea8;">4</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; ExprCall __::builtin`</span><span style="color: #dcdcaa;">resize</span><span style="color: #d4d4d4;">( ExprCallArgument ExprVar memblock. ExprField mem, ExprCallArgument &#160;ExprOp2( ExprOp2(ExprVar aSize ExprOp2Right + ExprVar bSize) ExprOp2Right + ExprVar cSize))</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; ExprVar memblock. ExprField a ExprCopyRight = ExprCast </span><span style="color: #c586c0;">reinterpret</span><span style="color: #d4d4d4;">&lt;</span><span style="color: #4ec9b0;">int</span><span style="color: #d4d4d4;">?&gt; &#160;VisitExprRef2Ptr </span><span style="color: #c586c0;">addr</span><span style="color: #d4d4d4;">(ExprVar memblock. ExprField mem ExprAtIndex[</span><span style="color: #569cd6;">0</span><span style="color: #d4d4d4;">])</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; ExprVar memblock. ExprField b ExprCopyRight = ExprCast </span><span style="color: #c586c0;">reinterpret</span><span style="color: #d4d4d4;">&lt;</span><span style="color: #4ec9b0;">float</span><span style="color: #d4d4d4;">?&gt; &#160;VisitExprRef2Ptr </span><span style="color: #c586c0;">addr</span><span style="color: #d4d4d4;">(ExprVar memblock. ExprField mem ExprAtIndex[</span><span style="color: #569cd6;">ExprVar</span><span style="color: #d4d4d4;"> aSize])</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; ExprVar memblock. ExprField c ExprCopyRight = ExprCast </span><span style="color: #c586c0;">reinterpret</span><span style="color: #d4d4d4;">&lt;</span><span style="color: #4ec9b0;">int</span><span style="color: #d4d4d4;">?&gt; &#160;VisitExprRef2Ptr </span><span style="color: #c586c0;">addr</span><span style="color: #d4d4d4;">(ExprVar memblock. ExprField mem ExprAtIndex[ </span><span style="color: #569cd6;">ExprOp2</span><span style="color: #d4d4d4;">(ExprVar aSize ExprOp2Right + ExprVar bSize)])</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; ExprCall init`</span><span style="color: #c586c0;">struct</span><span style="color: #d4d4d4;">`Memblock( ExprCallArgument ExprVar memblock, ExprCallArgument </span><span style="color: #b5cea8;">5</span><span style="color: #d4d4d4;">, ExprCallArgument </span><span style="color: #b5cea8;">5</span><span style="color: #d4d4d4;">, ExprCallArgument </span><span style="color: #b5cea8;">5</span><span style="color: #d4d4d4;">)</span></div></div>
<p>Здесь перед каждым daScript выражением показан тип этого выражения. Почти все типы выражений объявлены в заголовочных файлах <a href="https://github.com/GaijinEntertainment/daScript/tree/master/include/daScript/ast" target="_blank" rel="noopener">ast_*.h</a>.</p>
<blockquote><p>С определенного момента начинаешь ценить простые языки — вместо того, что изучать сложные и разрастающиеся правила языка, можно упростить их, чтобы ускорить изучение языка и сделать его более понятным, но при этом дать возможность задавать более сложные правила только в тех местах, где они действительно нужны программисту.</p>
</blockquote>
<p><strong><code>Работа с макросами сначала кажется сложной, но с какого-то момента понимаешь, что типичная программа содержит почти все распространённые типы выражений, и понимаешь, что вот они, все перед тобой, других, скрытых мелким шрифтом в примечаниях на 666-й странице стандарта, нет.</code></strong></p>
<p>Можно было бы пойти ещё дальше, и написать макрос, который выводит код, создающий выражение, но в образовательных целях можно попробовать для начала составить выражения вручную.</p>
<p>Для генерации функции нужно научиться генерировать строки 5 типов:</p>
<ul>
<li>Декларация функции <code>def initMemblock ( var memblock : Memblock, ...)</code></li>
<li>Присваивание  <code>memblock.a</code>count = aCount`</li>
<li>Объвление переменной <code>let aSize = typeinfo(sizeof *memblock.a) * aCount</code></li>
<li>Вызов функции <code>memblock.mem |&gt; resize(aSize + bSize + cSize)</code></li>
<li>Ещё одно присвание - <code>memblock.a = reinterpret&lt;int?&gt; addr(memblock.mem[0])</code></li>
</ul>
<p><strong><code>Декларация функции</code></strong></p>
<p>Практически готовый пример нужного кода есть в примерах из daScript-a <code>gen_field.das</code>.</p>
<div style="color: #d4d4d4;background-color: #1e1e1e;font-family: Consolas, 'Courier New', monospace;font-weight: normal;font-size: 14px;line-height: 19px;white-space: pre;"><div><span style="color: #569cd6;">def</span><span style="color: #d4d4d4;"> </span><span style="color: #dcdcaa;">generateStructureFields</span><span style="color: #d4d4d4;">(</span><span style="color: #569cd6;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">st</span><span style="color: #d4d4d4;">:StructurePtr)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #6a9955;">//create "mem" field of type array&lt;uint8&gt;</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> uint8Type &lt;- </span><span style="color: #c586c0;">new</span><span style="color: #d4d4d4;"> [[TypeDecl() baseType=Type tUInt8]]</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> uint8ArrayType &lt;- </span><span style="color: #c586c0;">new</span><span style="color: #d4d4d4;"> [[TypeDecl() baseType=Type tArray, firstType &lt;- uint8Type]]</span></div><br><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">let</span><span style="color: #d4d4d4;"> fieldsLen = st.fields |&gt; </span><span style="color: #dcdcaa;">length</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> ptrsCount = </span><span style="color: #b5cea8;">0</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> ptrsTypeIndexes : </span><span style="color: #c586c0;">array</span><span style="color: #d4d4d4;">&lt;</span><span style="color: #4ec9b0;">int</span><span style="color: #d4d4d4;">&gt;</span></div><div><span style="color: #d4d4d4;">&#160; &#160; ptrsTypeIndexes |&gt; reserve(fieldsLen)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">for</span><span style="color: #d4d4d4;"> i </span><span style="color: #c586c0;">in</span><span style="color: #d4d4d4;"> range(</span><span style="color: #b5cea8;">0</span><span style="color: #d4d4d4;">, fieldsLen)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">if</span><span style="color: #d4d4d4;"> st.fields[</span><span style="color: #569cd6;">i</span><span style="color: #d4d4d4;">]._type.baseType == Type tPointer</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; ptrsCount++</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; ptrsTypeIndexes |&gt; </span><span style="color: #dcdcaa;">push</span><span style="color: #d4d4d4;">(i) </span><span style="color: #6a9955;">//сохраняем индексы полей-указателей</span></div><br><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #6a9955;">//add one field for memblock and one field per pointer type to handle count of object per type</span></div><div><span style="color: #d4d4d4;">&#160; &#160; st.fields |&gt; </span><span style="color: #dcdcaa;">resize</span><span style="color: #d4d4d4;">(fieldsLen+ ptrsCount + </span><span style="color: #b5cea8;">1</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; st.fields[</span><span style="color: #569cd6;">fieldsLen</span><span style="color: #d4d4d4;">] := *</span><span style="color: #c586c0;">new</span><span style="color: #d4d4d4;"> [[ FieldDeclaration() name:=</span><span style="color: #ce9178;">"mem"</span><span style="color: #d4d4d4;">, _type &lt;- uint8ArrayType]]</span></div><br><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">for</span><span style="color: #d4d4d4;"> i </span><span style="color: #c586c0;">in</span><span style="color: #d4d4d4;"> range(</span><span style="color: #b5cea8;">0</span><span style="color: #d4d4d4;">, ptrsCount)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">let</span><span style="color: #d4d4d4;"> fieldCountName = </span><span style="color: #ce9178;">"{</span><span style="color: #9cdcfe;">st</span><span style="color: #d4d4d4;">.</span><span style="color: #9cdcfe;">fields</span><span style="color: #ce9178;">[</span><span style="color: #569cd6;">ptrsTypeIndexes[i</span><span style="color: #ce9178;">]]</span><span style="color: #d4d4d4;">.</span><span style="color: #9cdcfe;">name</span><span style="color: #ce9178;">}{"`count"}"</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; st.fields[</span><span style="color: #569cd6;">fieldsLen+1+i</span><span style="color: #d4d4d4;">] := *</span><span style="color: #c586c0;">new</span><span style="color: #d4d4d4;"> [[ FieldDeclaration() name:=fieldCountName, _type &lt;- </span><span style="color: #c586c0;">new</span><span style="color: #d4d4d4;"> [[TypeDecl() baseType=Type tInt]]]]</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">return</span><span style="color: #d4d4d4;"> &lt;-ptrsTypeIndexes</span></div><br><div><span style="color: #6a9955;">//--------------------------</span></div><div><span style="color: #6a9955;">// Генерация функции</span></div><div><span style="color: #569cd6;">def</span><span style="color: #d4d4d4;"> </span><span style="color: #dcdcaa;">generateStructureInitFunction</span><span style="color: #d4d4d4;">(</span><span style="color: #569cd6;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">st</span><span style="color: #d4d4d4;">:StructurePtr; </span><span style="color: #9cdcfe;">ptrsTypeIndexes</span><span style="color: #d4d4d4;">:</span><span style="color: #c586c0;">array</span><span style="color: #d4d4d4;">&lt;</span><span style="color: #4ec9b0;">int</span><span style="color: #d4d4d4;">&gt;&amp;)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">let</span><span style="color: #d4d4d4;"> ptrFieldsLen = ptrsTypeIndexes |&gt; </span><span style="color: #dcdcaa;">length</span></div><br><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">let</span><span style="color: #d4d4d4;"> fnname = </span><span style="color: #ce9178;">"init`struct`{</span><span style="color: #9cdcfe;">st</span><span style="color: #d4d4d4;">.</span><span style="color: #9cdcfe;">name</span><span style="color: #ce9178;">}"</span></div><br><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #6a9955;">//генерируем объявление функции с именем init`struct`ИмяСтрутуры</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> fn &lt;- </span><span style="color: #c586c0;">new</span><span style="color: #d4d4d4;"> [[Function() at=st.at, atDecl=st.at, name:=fnname]]</span></div><div><span style="color: #d4d4d4;">&#160; &#160; fn.flags |= FunctionFlags generated</span></div><div><span style="color: #d4d4d4;">&#160; &#160; fn.flags |= FunctionFlags privateFunction</span></div><br><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #6a9955;">//генерируем список аргументов и тип результата функции</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">unsafe</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; fn.arguments |&gt; emplace_new &lt;| </span><span style="color: #c586c0;">new</span><span style="color: #d4d4d4;"> [[Variable() at=st.at, name:= </span><span style="color: #ce9178;">"memblock"</span><span style="color: #d4d4d4;">, _type &lt;- </span><span style="color: #c586c0;">new</span><span style="color: #d4d4d4;"> [[TypeDecl() baseType=Type tStructure, structType=</span><span style="color: #c586c0;">addr</span><span style="color: #d4d4d4;">(*st)]]]]</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">for</span><span style="color: #d4d4d4;"> i </span><span style="color: #c586c0;">in</span><span style="color: #d4d4d4;"> range(</span><span style="color: #b5cea8;">0</span><span style="color: #d4d4d4;">, ptrFieldsLen)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">let</span><span style="color: #d4d4d4;"> argumentName = </span><span style="color: #ce9178;">"{</span><span style="color: #9cdcfe;">st</span><span style="color: #d4d4d4;">.</span><span style="color: #9cdcfe;">fields</span><span style="color: #ce9178;">[</span><span style="color: #569cd6;">ptrsTypeIndexes[i</span><span style="color: #ce9178;">]]</span><span style="color: #d4d4d4;">.</span><span style="color: #9cdcfe;">name</span><span style="color: #ce9178;">}`count"</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; fn.arguments |&gt; emplace_new &lt;| </span><span style="color: #c586c0;">new</span><span style="color: #d4d4d4;"> [[Variable() at=st.at, name:= argumentName, &#160;_type &lt;- </span><span style="color: #c586c0;">new</span><span style="color: #d4d4d4;"> [[TypeDecl() baseType=Type tInt]] ]]</span></div><div><span style="color: #d4d4d4;">&#160; &#160; fn.result &lt;- </span><span style="color: #c586c0;">new</span><span style="color: #d4d4d4;"> [[TypeDecl() baseType=Type tVoid, at=st.at]]</span></div><br><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #6a9955;">//генерируем тело функции, пока просто вызов `print("Hello, world!")`</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> blk &lt;- </span><span style="color: #c586c0;">new</span><span style="color: #d4d4d4;"> [[ExprBlock() at=st.at]]</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> printF &lt;- </span><span style="color: #c586c0;">new</span><span style="color: #d4d4d4;"> [[ExprCall() name:=</span><span style="color: #ce9178;">"print"</span><span style="color: #d4d4d4;">]]</span></div><div><span style="color: #d4d4d4;">&#160; &#160; printF.arguments |&gt; emplace_new &lt;| </span><span style="color: #c586c0;">new</span><span style="color: #d4d4d4;"> [[ExprConstString() value:=</span><span style="color: #ce9178;">"Hello, world!</span><span style="color: #d7ba7d;">\n</span><span style="color: #ce9178;">"</span><span style="color: #d4d4d4;">]]</span></div><div><span style="color: #d4d4d4;">&#160; &#160; blk.list |&gt; </span><span style="color: #dcdcaa;">emplace</span><span style="color: #d4d4d4;">(printF)</span></div><br><div><span style="color: #d4d4d4;">&#160; &#160; fn.body &lt;- blk</span></div><div><span style="color: #d4d4d4;">&#160; &#160; compiling_module() |&gt; add_function(fn)</span></div></div>
<p>Теперь если сгенерировать макросом функцию, и передать эту функцию в макрос, который возвращает исходный текст функции, то получится такой результат:</p>
<div style="color: #d4d4d4;background-color: #1e1e1e;font-family: Consolas, 'Courier New', monospace;font-weight: normal;font-size: 14px;line-height: 19px;white-space: pre;"><div><span style="color: #c586c0;">def</span><span style="color: #d4d4d4;"> init`</span><span style="color: #c586c0;">struct</span><span style="color: #d4d4d4;">`Memblock ( </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> memblock : Memblock; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> a`count : </span><span style="color: #4ec9b0;">int</span><span style="color: #d4d4d4;">; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> b`count : </span><span style="color: #4ec9b0;">int</span><span style="color: #d4d4d4;">; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> c`count : </span><span style="color: #4ec9b0;">int</span><span style="color: #d4d4d4;"> )</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #dcdcaa;">print</span><span style="color: #d4d4d4;">(</span><span style="color: #ce9178;">"Hello, world!"</span><span style="color: #d4d4d4;">,__context__)</span></div></div>
<p><strong><code>Присваивание и объявление переменной</code></strong></p>
<div style="color: #d4d4d4;background-color: #1e1e1e;font-family: Consolas, 'Courier New', monospace;font-weight: normal;font-size: 14px;line-height: 19px;white-space: pre;"><div><span style="color: #6a9955;">//-------------------------</span></div><div><span style="color: #6a9955;">//1. Make Expressions</span></div><div><span style="color: #6a9955;">//-------------------------</span></div><div><span style="color: #6a9955;">//memblock.a`count = aCount</span></div><div><span style="color: #6a9955;">// &#160;ExprVar memblock. ExprField a`count ExprCopyRight = ExprVar aCount</span></div><div><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> exprVar_memblock &lt;- </span><span style="color: #c586c0;">new</span><span style="color: #d4d4d4;"> [[ExprVar() name:=</span><span style="color: #ce9178;">"memblock"</span><span style="color: #d4d4d4;">]]</span></div><div><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> exprField_acount &lt;- </span><span style="color: #c586c0;">new</span><span style="color: #d4d4d4;"> [[ExprField() name:=</span><span style="color: #ce9178;">"a`count"</span><span style="color: #d4d4d4;">, value &lt;- exprVar_memblock]]</span></div><div><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> exprVar_acount &lt;- </span><span style="color: #c586c0;">new</span><span style="color: #d4d4d4;"> [[ExprVar() name:=</span><span style="color: #ce9178;">"a`count"</span><span style="color: #d4d4d4;">]]</span></div><div><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> exprCopy &lt;- </span><span style="color: #c586c0;">new</span><span style="color: #d4d4d4;"> [[ExprCopy() op:=</span><span style="color: #ce9178;">"="</span><span style="color: #d4d4d4;">, left &lt;- exprField_acount, right &lt;- exprVar_acount]]</span></div><div><span style="color: #d4d4d4;">blk.list |&gt; </span><span style="color: #dcdcaa;">emplace</span><span style="color: #d4d4d4;">(exprCopy)</span></div></div>
<p>Тут всё достаточно тривиально, пока составляем только первую строку “memblock.a`count = aCount”</p>
<div style="color: #d4d4d4;background-color: #1e1e1e;font-family: Consolas, 'Courier New', monospace;font-weight: normal;font-size: 14px;line-height: 19px;white-space: pre;"><div><span style="color: #6a9955;">//-------------------------</span></div><div><span style="color: #6a9955;">//2. Quotes</span></div><div><span style="color: #6a9955;">//-------------------------</span></div><div><span style="color: #6a9955;">//let aSize = typeinfo(sizeof *memblock.a) * aCount</span></div><div><span style="color: #6a9955;">// &#160;ExprLet var &#160;ExprLetVariable aSize : int const = &#160;ExprOp2(ExprVar aCount ExprOp2Right * 4)</span></div><div><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> exprLet_aSize_value &lt;- quote(</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">typeinfo</span><span style="color: #d4d4d4;">(sizeof * memblock.a) * a`count</span></div><div><span style="color: #d4d4d4;">)</span></div><br><div><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> exprLet_aSize &lt;- </span><span style="color: #c586c0;">new</span><span style="color: #d4d4d4;"> [[ExprLet()]]</span></div><div><span style="color: #d4d4d4;">exprLet_aSize.variables |&gt; emplace_new() &lt;| </span><span style="color: #c586c0;">new</span><span style="color: #d4d4d4;"> [[Variable()</span></div><div><span style="color: #d4d4d4;">&#160; &#160; name := </span><span style="color: #ce9178;">"aSize"</span><span style="color: #d4d4d4;">,</span></div><div><span style="color: #d4d4d4;">&#160; &#160; _type &lt;- </span><span style="color: #c586c0;">new</span><span style="color: #d4d4d4;"> [[TypeDecl() baseType=Type tInt]],</span></div><div><span style="color: #d4d4d4;">&#160; &#160; init &lt;- exprLet_aSize_value</span></div><div><span style="color: #d4d4d4;">]]</span></div><div><span style="color: #d4d4d4;">blk.list |&gt; </span><span style="color: #dcdcaa;">emplace</span><span style="color: #d4d4d4;">(exprLet_aSize)</span></div><br><div><span style="color: #6a9955;">//prevent drop unused code</span></div><div><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> exprCall_printUnused &lt;- quote(</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #dcdcaa;">print</span><span style="color: #d4d4d4;">(</span><span style="color: #ce9178;">"{</span><span style="color: #9cdcfe;">aSize</span><span style="color: #ce9178;">}"</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">blk.list |&gt; </span><span style="color: #dcdcaa;">emplace</span><span style="color: #d4d4d4;">(exprCall_printUnused)</span></div></div>
<p>При генерации следующей строки можно заметить, что:</p>
<ul>
<li>макрос ast_print_expression не описал выражение “typeinfo(sizeof *memblock.a)”, а вместо этого вывел его результат. Это происходит потому, что макрос был применён к уже сгенерированной и оптимизированной функции, для которой часть выражений может быть вычислена компилятором.</li>
<li>макрос ast_print, применённый к сгенерированной функции, не показывает неиспользуемые переменные, так как они были выброшены компилятором, так что увидеть их можно, если добавить использование (print”{aSize}” в данном случае).</li>
</ul>
<p>Кроме генерации выражений, здесь показано использование макроса <code>quote</code>, который превращает код в выражение:<br><div style="color: #d4d4d4;background-color: #1e1e1e;font-family: Consolas, 'Courier New', monospace;font-weight: normal;font-size: 14px;line-height: 19px;white-space: pre;"><div><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> exprLet_aSize_value &lt;- quote(</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">typeinfo</span><span style="color: #d4d4d4;">(sizeof * memblock.a) * a`count</span></div><div><span style="color: #d4d4d4;">)</span></div></div></p>
<p>Вот <a href="https://github.com/GaijinEntertainment/daScript/blob/726d440be7618fb431815b18e6f785c37a335d5d/examples/test/misc/template_example.das" target="_blank" rel="noopener">пример</a> (<a href="https://github.com/spiiin/dascript_macro_tutorial/blob/master/examples/template_example.das" target="_blank" rel="noopener">Fixed version</a>) более продвинутого использования цитирования, с возможностью задать правила переписывания выражения. Это можно использовать для того, чтобы перейти от явного указания названия поля структуры к переменной, в которую можно передать любое имя или выражение:</p>
<div style="color: #d4d4d4;background-color: #1e1e1e;font-family: Consolas, 'Courier New', monospace;font-weight: normal;font-size: 14px;line-height: 19px;white-space: pre;"><div><span style="color: #c586c0;">require</span><span style="color: #d4d4d4;"> daslib/templates</span></div><div><span style="color: #c586c0;">require</span><span style="color: #d4d4d4;"> daslib/templates_boost</span></div><br><div><span style="color: #6a9955;">//-------------------------</span></div><div><span style="color: #6a9955;">//2. Quotes and templates</span></div><div><span style="color: #6a9955;">//-------------------------</span></div><div><span style="color: #6a9955;">//let aSize = typeinfo(sizeof *memblock.a) * aCount</span></div><div><span style="color: #6a9955;">// &#160;ExprLet var &#160;ExprLetVariable aSize : int const = &#160;ExprOp2(ExprVar aCount ExprOp2Right * 4)</span></div><br><div><span style="color: #c586c0;">for</span><span style="color: #d4d4d4;"> i </span><span style="color: #c586c0;">in</span><span style="color: #d4d4d4;"> range(</span><span style="color: #b5cea8;">0</span><span style="color: #d4d4d4;">, ptrFieldsLen)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">let</span><span style="color: #d4d4d4;"> argumentName = </span><span style="color: #ce9178;">"{</span><span style="color: #9cdcfe;">st</span><span style="color: #d4d4d4;">.</span><span style="color: #9cdcfe;">fields</span><span style="color: #ce9178;">[</span><span style="color: #569cd6;">ptrsTypeIndexes[i</span><span style="color: #ce9178;">]]</span><span style="color: #d4d4d4;">.</span><span style="color: #9cdcfe;">name</span><span style="color: #ce9178;">}"</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> exprLet_aSize_value &lt;- quote(</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">typeinfo</span><span style="color: #d4d4d4;">(sizeof *ELEMENT) * ELEMENTS_COUNT</span></div><div><span style="color: #d4d4d4;">&#160; &#160; )</span></div><br><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> exprVar_memblock2 &lt;- </span><span style="color: #c586c0;">new</span><span style="color: #d4d4d4;"> [[ExprVar() name:=</span><span style="color: #ce9178;">"memblock"</span><span style="color: #d4d4d4;">]]</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> exprField_acount2 &lt;- </span><span style="color: #c586c0;">new</span><span style="color: #d4d4d4;"> [[ExprField() name:=argumentName, value &lt;- exprVar_memblock2]]</span></div><br><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> exprLet_rules : Template &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; </span><span style="color: #6a9955;">//правила переписывания выражения</span></div><div><span style="color: #d4d4d4;">&#160; &#160; exprLet_rules |&gt; replaceVariable(</span><span style="color: #ce9178;">"ELEMENT"</span><span style="color: #d4d4d4;">, exprField_acount2) &#160; &#160; &#160; &#160; &#160; &#160; </span><span style="color: #6a9955;">//подставляем выражение</span></div><div><span style="color: #d4d4d4;">&#160; &#160; exprLet_rules |&gt; renameVariable(</span><span style="color: #ce9178;">"ELEMENTS_COUNT"</span><span style="color: #d4d4d4;">, </span><span style="color: #ce9178;">"{</span><span style="color: #9cdcfe;">argumentName</span><span style="color: #ce9178;">}`count"</span><span style="color: #d4d4d4;">) &#160;</span><span style="color: #6a9955;">//подставляем имя переменной</span></div><div><span style="color: #d4d4d4;">&#160; &#160; apply_template(exprLet_rules, exprLet_aSize_value.at, exprLet_aSize_value)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> exprLet_aSize &lt;- </span><span style="color: #c586c0;">new</span><span style="color: #d4d4d4;"> [[ExprLet()]]</span></div><div><span style="color: #d4d4d4;">&#160; &#160; exprLet_aSize.variables |&gt; emplace_new() &lt;| </span><span style="color: #c586c0;">new</span><span style="color: #d4d4d4;"> [[Variable()</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; name := </span><span style="color: #ce9178;">"{</span><span style="color: #9cdcfe;">argumentName</span><span style="color: #ce9178;">}Size"</span><span style="color: #d4d4d4;">,</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; _type &lt;- </span><span style="color: #c586c0;">new</span><span style="color: #d4d4d4;"> [[TypeDecl() baseType=Type tInt]],</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; init &lt;- exprLet_aSize_value</span></div><div><span style="color: #d4d4d4;">&#160; &#160; ]]</span></div><div><span style="color: #d4d4d4;">&#160; &#160; blk.list |&gt; </span><span style="color: #dcdcaa;">emplace</span><span style="color: #d4d4d4;">(exprLet_aSize)</span></div><br><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #6a9955;">//Временно руками добавляем код использования переменных, чтобы их не отбросил компилятор</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> exprCall_printUnused &lt;- quote(</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #dcdcaa;">print</span><span style="color: #d4d4d4;">(</span><span style="color: #ce9178;">"{</span><span style="color: #9cdcfe;">aSize</span><span style="color: #ce9178;">},{</span><span style="color: #9cdcfe;">bSize</span><span style="color: #ce9178;">},{</span><span style="color: #9cdcfe;">cSize</span><span style="color: #ce9178;">}"</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; blk.list |&gt; </span><span style="color: #dcdcaa;">emplace</span><span style="color: #d4d4d4;">(exprCall_printUnused)</span></div></div>
<p>Половина кода генерации написана, нужно двигаться дальше.</p>
<p><strong><code>Вызов функции memblock.mem |&gt; resize(aSize + bSize + cSize)</code></strong></p>
<p>Здесь есть небольшая хитрость. Строка <code>aSize + bSize + cSize</code>, трансформируется в выражение:<br><div style="color: #d4d4d4;background-color: #1e1e1e;font-family: Consolas, 'Courier New', monospace;font-weight: normal;font-size: 14px;line-height: 19px;white-space: pre;"><div><span style="color: #d4d4d4;">ExprOp2( ExprOp2(ExprVar aSize ExprOp2Right + ExprVar bSize) ExprOp2Right + ExprVar cSize))</span></div></div></p>
<p>У выражения есть определённый шаблон:<br><div style="color: #d4d4d4;background-color: #1e1e1e;font-family: Consolas, 'Courier New', monospace;font-weight: normal;font-size: 14px;line-height: 19px;white-space: pre;"><div><span style="color: #d4d4d4;">((((a+b)+c)+d)+...)</span></div></div></p>
<p>Подобные выражения удобно сгенерировать с помощью функции <a href="https://en.wikipedia.org/wiki/Fold_(higher-order_function" target="_blank" rel="noopener">свёртки</a>). Я зачём-то использовал правостороннюю свёртку, но для ассоциативных операторов конечный результат будет одинаковым (не нашёл готовой в стандартной библиотеке):</p>
<div style="color: #d4d4d4;background-color: #1e1e1e;font-family: Consolas, 'Courier New', monospace;font-weight: normal;font-size: 14px;line-height: 19px;white-space: pre;"><div><span style="color: #569cd6;">def</span><span style="color: #d4d4d4;"> </span><span style="color: #dcdcaa;">foldR</span><span style="color: #d4d4d4;">(</span><span style="color: #569cd6;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">a</span><span style="color: #d4d4d4;">:</span><span style="color: #c586c0;">array</span><span style="color: #d4d4d4;">&lt;ExpressionPtr&gt;; </span><span style="color: #9cdcfe;">foldOp</span><span style="color: #d4d4d4;">:</span><span style="color: #4ec9b0;">function</span><span style="color: #d4d4d4;">&lt;(arg1, arg2: </span><span style="color: #9cdcfe;">ExpressionPtr</span><span style="color: #d4d4d4;">) : ExpressionPtr&gt; )</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">let</span><span style="color: #d4d4d4;"> aLen = a |&gt; </span><span style="color: #dcdcaa;">length</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> from &lt;- a[</span><span style="color: #569cd6;">aLen-1</span><span style="color: #d4d4d4;">]</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">for</span><span style="color: #d4d4d4;"> i </span><span style="color: #c586c0;">in</span><span style="color: #d4d4d4;"> range(</span><span style="color: #b5cea8;">1</span><span style="color: #d4d4d4;">, aLen)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; from := foldOp |&gt; </span><span style="color: #dcdcaa;">invoke</span><span style="color: #d4d4d4;">(a[</span><span style="color: #569cd6;">aLen-1-i</span><span style="color: #d4d4d4;">], from)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">return</span><span style="color: #d4d4d4;"> from</span></div><br><div><span style="color: #569cd6;">def</span><span style="color: #d4d4d4;"> </span><span style="color: #dcdcaa;">makeSumExpr</span><span style="color: #d4d4d4;">(</span><span style="color: #9cdcfe;">a, b</span><span style="color: #d4d4d4;">: ExpressionPtr </span><span style="color: #569cd6;">const</span><span style="color: #d4d4d4;">): ExpressionPtr</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">return</span><span style="color: #d4d4d4;"> </span><span style="color: #c586c0;">new</span><span style="color: #d4d4d4;"> [[ExprOp2() op:=</span><span style="color: #ce9178;">"+"</span><span style="color: #d4d4d4;">, left := a, right := b]]</span></div><br><div><span style="color: #6a9955;">//-------------------------</span></div><div><span style="color: #6a9955;">// 3. Foldr</span></div><div><span style="color: #6a9955;">//-------------------------</span></div><div><span style="color: #6a9955;">//memblock.mem |&gt; resize(aSize + bSize + cSize)</span></div><div><span style="color: #6a9955;">// &#160; &#160; ExprCall __::builtin`resize( ExprCallArgument ExprVar memblock. ExprField mem, ExprCallArgument &#160;ExprOp2( ExprOp2(ExprVar aSize ExprOp2Right + ExprVar bSize) ExprOp2Right + ExprVar cSize))</span></div><br><div><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> sumArgumentsArray: </span><span style="color: #c586c0;">array</span><span style="color: #d4d4d4;">&lt;ExpressionPtr&gt;</span></div><div><span style="color: #c586c0;">for</span><span style="color: #d4d4d4;"> i </span><span style="color: #c586c0;">in</span><span style="color: #d4d4d4;"> range(</span><span style="color: #b5cea8;">0</span><span style="color: #d4d4d4;">, ptrFieldsLen) </span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">let</span><span style="color: #d4d4d4;"> argumentName = </span><span style="color: #ce9178;">"{</span><span style="color: #9cdcfe;">st</span><span style="color: #d4d4d4;">.</span><span style="color: #9cdcfe;">fields</span><span style="color: #ce9178;">[</span><span style="color: #569cd6;">ptrsTypeIndexes[i</span><span style="color: #ce9178;">]]</span><span style="color: #d4d4d4;">.</span><span style="color: #9cdcfe;">name</span><span style="color: #ce9178;">}"</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">let</span><span style="color: #d4d4d4;"> nameSize := </span><span style="color: #ce9178;">"{</span><span style="color: #9cdcfe;">argumentName</span><span style="color: #ce9178;">}Size"</span></div><div><span style="color: #d4d4d4;">&#160; &#160; sumArgumentsArray |&gt; </span><span style="color: #dcdcaa;">emplace</span><span style="color: #d4d4d4;">(</span><span style="color: #c586c0;">new</span><span style="color: #d4d4d4;"> [[ExprVar() name:=nameSize]])</span></div><div><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> sumExpr &lt;- foldR(sumArgumentsArray, @@makeSumExpr) </span><span style="color: #6a9955;">//ага, свёртка массива в выражение</span></div><br><div><span style="color: #6a9955;">//--------</span></div><div><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> exprLet_totalSize &lt;- </span><span style="color: #c586c0;">new</span><span style="color: #d4d4d4;"> [[ExprLet()]]</span></div><div><span style="color: #d4d4d4;">exprLet_totalSize.variables |&gt; emplace_new() &lt;| </span><span style="color: #c586c0;">new</span><span style="color: #d4d4d4;"> [[Variable()</span></div><div><span style="color: #d4d4d4;">&#160; &#160; name := </span><span style="color: #ce9178;">"totalSize"</span><span style="color: #d4d4d4;">,</span></div><div><span style="color: #d4d4d4;">&#160; &#160; _type &lt;- </span><span style="color: #c586c0;">new</span><span style="color: #d4d4d4;"> [[TypeDecl() baseType=Type tInt]],</span></div><div><span style="color: #d4d4d4;">&#160; &#160; init &lt;- sumExpr</span></div><div><span style="color: #d4d4d4;">]]</span></div><div><span style="color: #d4d4d4;">blk.list |&gt; </span><span style="color: #dcdcaa;">emplace</span><span style="color: #d4d4d4;">(exprLet_totalSize)</span></div><div><span style="color: #6a9955;">//prevent drop unused code</span></div><div><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> exprCall_printUnused2 &lt;- quote(</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #dcdcaa;">print</span><span style="color: #d4d4d4;">(</span><span style="color: #ce9178;">"{</span><span style="color: #9cdcfe;">totalSize</span><span style="color: #ce9178;">}"</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">blk.list |&gt; </span><span style="color: #dcdcaa;">emplace</span><span style="color: #d4d4d4;">(exprCall_printUnused2)</span></div><br><div><span style="color: #6a9955;">//сгенерирует код:</span></div><div><span style="color: #6a9955;">//let totalSize : int = (aSize + (bSize + cSize))</span></div><div><span style="color: #6a9955;">//__::builtin`resize(memblock.mem,totalSize)</span></div></div>
<p>(__::builtin`resize здесь просто замангленное название встроенной функции resize)</p>
<p><strong><code>memblock.a = reinterpret&lt;int?&gt; addr(memblock.mem[0])</code></strong></p>
<p>Можно немного изменить функцию <code>foldr</code>, чтобы она могла генерировать частичные суммы для получения кода вида:<br><div style="color: #d4d4d4;background-color: #1e1e1e;font-family: Consolas, 'Courier New', monospace;font-weight: normal;font-size: 14px;line-height: 19px;white-space: pre;"><div><span style="color: #d4d4d4;">memblock.a = </span><span style="color: #c586c0;">reinterpret</span><span style="color: #d4d4d4;">&lt;</span><span style="color: #4ec9b0;">int</span><span style="color: #d4d4d4;">?&gt; </span><span style="color: #c586c0;">addr</span><span style="color: #d4d4d4;">(memblock.mem[</span><span style="color: #569cd6;">0</span><span style="color: #d4d4d4;">])</span></div><div><span style="color: #d4d4d4;">memblock.b = </span><span style="color: #c586c0;">reinterpret</span><span style="color: #d4d4d4;">&lt;</span><span style="color: #4ec9b0;">float</span><span style="color: #d4d4d4;">?&gt; </span><span style="color: #c586c0;">addr</span><span style="color: #d4d4d4;">(memblock.mem[(aSize + </span><span style="color: #b5cea8;">0</span><span style="color: #d4d4d4;">)])</span></div><div><span style="color: #d4d4d4;">memblock.c = </span><span style="color: #c586c0;">reinterpret</span><span style="color: #d4d4d4;">&lt;</span><span style="color: #4ec9b0;">int</span><span style="color: #d4d4d4;">?&gt; </span><span style="color: #c586c0;">addr</span><span style="color: #d4d4d4;">(memblock.mem[(aSize + (bSize + </span><span style="color: #b5cea8;">0</span><span style="color: #d4d4d4;">))])</span></div><div><span style="color: #d4d4d4;">...</span></div></div></p>
<div style="color: #d4d4d4;background-color: #1e1e1e;font-family: Consolas, 'Courier New', monospace;font-weight: normal;font-size: 14px;line-height: 19px;white-space: pre;"><div><span style="color: #6a9955;">//теперь можно задать, какую часть массива превратить в выражение</span></div><div><span style="color: #569cd6;">def</span><span style="color: #d4d4d4;"> </span><span style="color: #dcdcaa;">foldR_partial</span><span style="color: #d4d4d4;">(</span><span style="color: #569cd6;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">a</span><span style="color: #d4d4d4;">:</span><span style="color: #c586c0;">array</span><span style="color: #d4d4d4;">&lt;ExpressionPtr&gt;; </span><span style="color: #9cdcfe;">foldOp</span><span style="color: #d4d4d4;">:</span><span style="color: #4ec9b0;">function</span><span style="color: #d4d4d4;">&lt;(arg1, arg2: </span><span style="color: #9cdcfe;">ExpressionPtr</span><span style="color: #d4d4d4;">) : ExpressionPtr&gt;; initial: ExpressionPtr; endIndex:</span><span style="color: #4ec9b0;">int</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">let</span><span style="color: #d4d4d4;"> aLen = a |&gt; </span><span style="color: #dcdcaa;">length</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> from := initial</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">for</span><span style="color: #d4d4d4;"> i </span><span style="color: #c586c0;">in</span><span style="color: #d4d4d4;"> range(endIndex, aLen)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; from := foldOp |&gt; </span><span style="color: #dcdcaa;">invoke</span><span style="color: #d4d4d4;">(a[</span><span style="color: #569cd6;">aLen-1-i</span><span style="color: #d4d4d4;">], from)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">return</span><span style="color: #d4d4d4;"> from</span></div><br><div><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> exprCall_resize &lt;- quote(</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; memblock.mem |&gt; </span><span style="color: #dcdcaa;">resize</span><span style="color: #d4d4d4;">(totalSize)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; )</span></div><div><span style="color: #d4d4d4;">&#160; &#160; blk.list |&gt; </span><span style="color: #dcdcaa;">emplace</span><span style="color: #d4d4d4;">(exprCall_resize)</span></div><br><div><span style="color: #6a9955;">//-------------------------</span></div><div><span style="color: #6a9955;">// 4. castType</span></div><div><span style="color: #6a9955;">//-------------------------</span></div><div><span style="color: #6a9955;">//memblock.a = reinterpret&lt;int?&gt; addr(memblock.mem[0])</span></div><br><div><span style="color: #c586c0;">for</span><span style="color: #d4d4d4;"> i </span><span style="color: #c586c0;">in</span><span style="color: #d4d4d4;"> range(</span><span style="color: #b5cea8;">0</span><span style="color: #d4d4d4;">, ptrFieldsLen)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">let</span><span style="color: #d4d4d4;"> argumentName = </span><span style="color: #ce9178;">"{</span><span style="color: #9cdcfe;">st</span><span style="color: #d4d4d4;">.</span><span style="color: #9cdcfe;">fields</span><span style="color: #ce9178;">[</span><span style="color: #569cd6;">ptrsTypeIndexes[i</span><span style="color: #ce9178;">]]</span><span style="color: #d4d4d4;">.</span><span style="color: #9cdcfe;">name</span><span style="color: #ce9178;">}"</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> exprVar_memblock &lt;- </span><span style="color: #c586c0;">new</span><span style="color: #d4d4d4;"> [[ExprVar() name:=</span><span style="color: #ce9178;">"memblock"</span><span style="color: #d4d4d4;">]]</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> exprField_a &lt;- </span><span style="color: #c586c0;">new</span><span style="color: #d4d4d4;"> [[ExprField() name:=argumentName, value &lt;- exprVar_memblock]]</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> exprAddr &lt;- quote(</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">addr</span><span style="color: #d4d4d4;">(memblock.mem[</span><span style="color: #569cd6;">START_ADDRESS</span><span style="color: #d4d4d4;">])</span></div><div><span style="color: #d4d4d4;">&#160; &#160; )</span></div><br><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> exprZero &lt;- </span><span style="color: #c586c0;">new</span><span style="color: #d4d4d4;"> [[ExprConstInt() value=</span><span style="color: #b5cea8;">0</span><span style="color: #d4d4d4;">]]</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> exprStartAddress &lt;- foldR_partial(sumArgumentsArray, @@makeSumExpr, exprZero, ptrFieldsLen-i)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> exprAddr_rules : Template</span></div><div><span style="color: #d4d4d4;">&#160; &#160; exprAddr_rules |&gt; replaceVariable(</span><span style="color: #ce9178;">"START_ADDRESS"</span><span style="color: #d4d4d4;">, exprStartAddress)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; apply_template(exprAddr_rules, exprAddr.at, exprAddr)</span></div><br><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> exprReinterpretCast&lt;- </span><span style="color: #c586c0;">new</span><span style="color: #d4d4d4;"> [[ExprCast() </span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; castType := st.fields[</span><span style="color: #569cd6;">ptrsTypeIndexes[i</span><span style="color: #d4d4d4;">]]._type,</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; castFlags = ExprCastFlags reinterpretCast,</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; subexpr &lt;- exprAddr]]</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> exprUnsafe&lt;- </span><span style="color: #c586c0;">new</span><span style="color: #d4d4d4;"> [[ExprUnsafe() body &lt;- exprReinterpretCast]]</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> exprCopy &lt;- </span><span style="color: #c586c0;">new</span><span style="color: #d4d4d4;"> [[ExprCopy() op:=</span><span style="color: #ce9178;">"="</span><span style="color: #d4d4d4;">, left &lt;- exprField_a, right &lt;- exprUnsafe]]</span></div><div><span style="color: #d4d4d4;">&#160; &#160; blk.list |&gt; </span><span style="color: #dcdcaa;">emplace</span><span style="color: #d4d4d4;">(exprCopy)</span></div></div>
<p>Все части генерации, составленные вместе, генерируют теперь такую функцию:<br><div style="color: #d4d4d4;background-color: #1e1e1e;font-family: Consolas, 'Courier New', monospace;font-weight: normal;font-size: 14px;line-height: 19px;white-space: pre;"><div><span style="color: #c586c0;">def</span><span style="color: #d4d4d4;"> init`</span><span style="color: #c586c0;">struct</span><span style="color: #d4d4d4;">`Memblock ( </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> memblock : Memblock; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> a`count : </span><span style="color: #4ec9b0;">int</span><span style="color: #d4d4d4;">; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> b`count : </span><span style="color: #4ec9b0;">int</span><span style="color: #d4d4d4;">; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> c`count : </span><span style="color: #4ec9b0;">int</span><span style="color: #d4d4d4;"> )</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; memblock.a`count = a`count</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; memblock.b`count = b`count</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; memblock.c`count = c`count</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">let</span><span style="color: #d4d4d4;"> aSize : </span><span style="color: #4ec9b0;">int</span><span style="color: #d4d4d4;"> = (a`count * </span><span style="color: #b5cea8;">4</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">let</span><span style="color: #d4d4d4;"> bSize : </span><span style="color: #4ec9b0;">int</span><span style="color: #d4d4d4;"> = (b`count * </span><span style="color: #b5cea8;">4</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">let</span><span style="color: #d4d4d4;"> cSize : </span><span style="color: #4ec9b0;">int</span><span style="color: #d4d4d4;"> = (c`count * </span><span style="color: #b5cea8;">4</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">let</span><span style="color: #d4d4d4;"> totalSize : </span><span style="color: #4ec9b0;">int</span><span style="color: #d4d4d4;"> = (aSize + (bSize + cSize))</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; __::builtin`</span><span style="color: #dcdcaa;">resize</span><span style="color: #d4d4d4;">(memblock.mem,totalSize)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; memblock.a = </span><span style="color: #c586c0;">reinterpret</span><span style="color: #d4d4d4;">&lt;</span><span style="color: #4ec9b0;">int</span><span style="color: #d4d4d4;">?&gt; </span><span style="color: #c586c0;">addr</span><span style="color: #d4d4d4;">(memblock.mem[</span><span style="color: #569cd6;">0</span><span style="color: #d4d4d4;">])</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; memblock.b = </span><span style="color: #c586c0;">reinterpret</span><span style="color: #d4d4d4;">&lt;</span><span style="color: #4ec9b0;">float</span><span style="color: #d4d4d4;">?&gt; </span><span style="color: #c586c0;">addr</span><span style="color: #d4d4d4;">(memblock.mem[(aSize + </span><span style="color: #b5cea8;">0</span><span style="color: #d4d4d4;">)])</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; memblock.c = </span><span style="color: #c586c0;">reinterpret</span><span style="color: #d4d4d4;">&lt;</span><span style="color: #4ec9b0;">int</span><span style="color: #d4d4d4;">?&gt; </span><span style="color: #c586c0;">addr</span><span style="color: #d4d4d4;">(memblock.mem[(aSize + (bSize + </span><span style="color: #b5cea8;">0</span><span style="color: #d4d4d4;">))])</span></div></div></p>
<p>Сгенерированная функция делает то же, что и написанная руками. Но разница в том, что для любых новых типов структур больше не нужно писать код объявления полей и инициализации руками совсем!</p>
<h2 id="Наследование"><a href="#Наследование" class="headerlink" title="Наследование"></a>Наследование</h2><p>Теперь можно использовать макрос, чтобы сгенерировать поля структуры и конструктор:<br><div style="color: #d4d4d4;background-color: #1e1e1e;font-family: Consolas, 'Courier New', monospace;font-weight: normal;font-size: 14px;line-height: 19px;white-space: pre;"><div><span style="color: #d4d4d4;">[</span><span style="color: #569cd6;">memblock</span><span style="color: #d4d4d4;">]</span></div><div><span style="color: #c586c0;">struct</span><span style="color: #d4d4d4;"> Memblock</span></div><div><span style="color: #d4d4d4;">&#160; &#160; a: </span><span style="color: #4ec9b0;">int</span><span style="color: #d4d4d4;">?</span></div><div><span style="color: #d4d4d4;">&#160; &#160; b: </span><span style="color: #4ec9b0;">float</span><span style="color: #d4d4d4;">?</span></div><div><span style="color: #d4d4d4;">&#160; &#160; c: </span><span style="color: #4ec9b0;">int</span><span style="color: #d4d4d4;">?</span></div><br><div><span style="color: #d4d4d4;">[</span><span style="color: #569cd6;">export</span><span style="color: #d4d4d4;">]</span></div><div><span style="color: #c586c0;">def</span><span style="color: #d4d4d4;"> test</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">unsafe</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> memblock: Memblock</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; memblock |&gt; init`</span><span style="color: #c586c0;">struct</span><span style="color: #d4d4d4;">`Memblock(</span><span style="color: #b5cea8;">5</span><span style="color: #d4d4d4;">,</span><span style="color: #b5cea8;">5</span><span style="color: #d4d4d4;">,</span><span style="color: #b5cea8;">5</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; memblock |&gt; fillMemblock</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #dcdcaa;">print</span><span style="color: #d4d4d4;">(</span><span style="color: #ce9178;">"Memblock = {</span><span style="color: #9cdcfe;">memblock</span><span style="color: #ce9178;">}</span><span style="color: #d7ba7d;">\n</span><span style="color: #ce9178;">"</span><span style="color: #d4d4d4;">)</span></div></div></p>
<p>Всё работает как задумано (реальный код потребовал бы ещё некоторых доработок, вроде добавления паддинга для выравнивания полей в блоке памяти, а также обёрток для того, чтобы скрыть необходимость unsafe доступа к полям, раз уж границы массивов известны).</p>
<p>Но что будет, если отнаследоваться от такой структуры?</p>
<div style="color: #d4d4d4;background-color: #1e1e1e;font-family: Consolas, 'Courier New', monospace;font-weight: normal;font-size: 14px;line-height: 19px;white-space: pre;"><div><span style="color: #c586c0;">struct</span><span style="color: #d4d4d4;"> Vec2</span></div><div><span style="color: #d4d4d4;">&#160; &#160; x, y : </span><span style="color: #4ec9b0;">float</span></div><br><div><span style="color: #d4d4d4;">[</span><span style="color: #569cd6;">memblock,</span><span style="color: #d4d4d4;"> dump_fields]</span></div><div><span style="color: #c586c0;">struct</span><span style="color: #d4d4d4;"> Memblock</span></div><div><span style="color: #d4d4d4;">&#160; &#160; a: </span><span style="color: #4ec9b0;">int</span><span style="color: #d4d4d4;">?</span></div><div><span style="color: #d4d4d4;">&#160; &#160; b: </span><span style="color: #4ec9b0;">float</span><span style="color: #d4d4d4;">?</span></div><div><span style="color: #d4d4d4;">&#160; &#160; c: </span><span style="color: #4ec9b0;">int</span><span style="color: #d4d4d4;">?</span></div><div><span style="color: #d4d4d4;">&#160; &#160; d: Vec2?</span></div><br><div><span style="color: #d4d4d4;">[</span><span style="color: #569cd6;">memblock,</span><span style="color: #d4d4d4;"> dump_fields]</span></div><div><span style="color: #569cd6;">struct</span><span style="color: #d4d4d4;"> </span><span style="color: #4ec9b0;">MemblockInheritor</span><span style="color: #d4d4d4;"> : </span><span style="color: #4ec9b0;">Memblock</span></div><div><span style="color: #d4d4d4;">&#160; &#160; e: </span><span style="color: #4ec9b0;">int</span><span style="color: #d4d4d4;">?</span></div><br><div><span style="color: #d4d4d4;">[</span><span style="color: #569cd6;">export</span><span style="color: #d4d4d4;">]</span></div><div><span style="color: #c586c0;">def</span><span style="color: #d4d4d4;"> test</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">unsafe</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> memblock: Memblock</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; memblock |&gt; init`</span><span style="color: #c586c0;">struct</span><span style="color: #d4d4d4;">`Memblock(</span><span style="color: #b5cea8;">5</span><span style="color: #d4d4d4;">,</span><span style="color: #b5cea8;">5</span><span style="color: #d4d4d4;">,</span><span style="color: #b5cea8;">5</span><span style="color: #d4d4d4;">,</span><span style="color: #b5cea8;">1</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; memblock |&gt; fillMemblock</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #dcdcaa;">print</span><span style="color: #d4d4d4;">(</span><span style="color: #ce9178;">"Memblock = {</span><span style="color: #9cdcfe;">memblock</span><span style="color: #ce9178;">}</span><span style="color: #d7ba7d;">\n</span><span style="color: #ce9178;">"</span><span style="color: #d4d4d4;">)</span></div><br><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> memblock2: MemblockInheritor</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #6a9955;">//memblock2 |&gt; fillMemblock</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; memblock2 |&gt; init`</span><span style="color: #c586c0;">struct</span><span style="color: #d4d4d4;">`MemblockInheritor(</span><span style="color: #b5cea8;">5</span><span style="color: #d4d4d4;">,</span><span style="color: #b5cea8;">5</span><span style="color: #d4d4d4;">,</span><span style="color: #b5cea8;">5</span><span style="color: #d4d4d4;">,</span><span style="color: #b5cea8;">1</span><span style="color: #d4d4d4;">,</span><span style="color: #b5cea8;">10</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #dcdcaa;">print</span><span style="color: #d4d4d4;">(</span><span style="color: #ce9178;">"Memblock2 = {</span><span style="color: #9cdcfe;">memblock2</span><span style="color: #ce9178;">}</span><span style="color: #d7ba7d;">\n</span><span style="color: #ce9178;">"</span><span style="color: #d4d4d4;">)</span></div><br><div><span style="color: #6a9955;">//out:</span></div><div><span style="color: #c586c0;">struct</span><span style="color: #d4d4d4;"> Memblock {</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; int32_t * a;</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #4ec9b0;">float</span><span style="color: #d4d4d4;"> * b;</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; int32_t * c;</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; Vec2 * d;</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; TArray&lt;uint8_t&gt; mem;</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; int32_t a`count;</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; int32_t b`count;</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; int32_t c`count;</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; int32_t d`count;</span></div><div><span style="color: #d4d4d4;">}</span></div><div><span style="color: #c586c0;">struct</span><span style="color: #d4d4d4;"> MemblockInheritor {</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; int32_t * a;</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #4ec9b0;">float</span><span style="color: #d4d4d4;"> * b;</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; int32_t * c;</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; Vec2 * d;</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; TArray&lt;uint8_t&gt; mem;</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; int32_t a`count;</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; int32_t b`count;</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; int32_t c`count;</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; int32_t d`count;</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; int32_t * e;</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; TArray&lt;uint8_t&gt; mem;</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; int32_t a`count;</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; int32_t b`count;</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; int32_t c`count;</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; int32_t d`count;</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; int32_t e`count;</span></div><div><span style="color: #d4d4d4;">}</span></div></div>
<p>Ауч, все поля в наследнике продублированы. Обработка объявления наследования в языке реализована как копирование деклараций всех полей структуры-предка в дочернюю (можно порыться в документации, или написать макрос, который покажет, что происходит).</p>
<p>Возможно реализовать пару стратегий правильного размещения полей наследника в памяти:</p>
<ul>
<li>каким-либо образом пометить, что базовая структура имеет сгенерированные поля, и добавить только новые</li>
<li>каким-либо образом пометить поля структуры-предка, удалить их, и перестроить всю структуру заново</li>
</ul>
<p>Для пометки полей можно использовать аннотации типов (пример — <a href="https://github.com/borisbat/dasBGFX/blob/a1e10ab439e5996a0a4d8722689e2b0fab4e72d9/examples/01_hello_triangle.das#L7" target="_blank" rel="noopener">аннотации типов шейдеров</a>).</p>
<p>Простой макрос, который проверяет список аннотаций типа:<br><div style="color: #d4d4d4;background-color: #1e1e1e;font-family: Consolas, 'Courier New', monospace;font-weight: normal;font-size: 14px;line-height: 19px;white-space: pre;"><div><span style="color: #569cd6;">def</span><span style="color: #d4d4d4;"> </span><span style="color: #dcdcaa;">checkFields</span><span style="color: #d4d4d4;">(</span><span style="color: #569cd6;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">st</span><span style="color: #d4d4d4;">:StructurePtr)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">for</span><span style="color: #d4d4d4;"> field </span><span style="color: #c586c0;">in</span><span style="color: #d4d4d4;"> st.fields</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> memblockAnnExist = find_arg(</span><span style="color: #ce9178;">"in_memblock"</span><span style="color: #d4d4d4;">, field.annotation) ?</span><span style="color: #c586c0;">as</span><span style="color: #d4d4d4;"> tBool ?? </span><span style="color: #c586c0;">false</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">if</span><span style="color: #d4d4d4;"> memblockAnnExist</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; &#160; &#160; </span><span style="color: #dcdcaa;">print</span><span style="color: #d4d4d4;">(</span><span style="color: #ce9178;">"</span><span style="color: #d7ba7d;">\t</span><span style="color: #ce9178;">[in_memblock]</span><span style="color: #d7ba7d;">\n</span><span style="color: #ce9178;">"</span><span style="color: #d4d4d4;">)</span></div><br><div><span style="color: #6a9955;">//можно добавить аннотацию типа</span></div><div><span style="color: #d4d4d4;">&#160;st.fields[</span><span style="color: #569cd6;">i</span><span style="color: #d4d4d4;">].annotation |&gt; add_annotation_argument(</span><span style="color: #ce9178;">"in_memblock"</span><span style="color: #d4d4d4;">, </span><span style="color: #c586c0;">true</span><span style="color: #d4d4d4;">)</span></div></div></p>
<p>Теперь можно реализовать логику добавления новых полей в уже существующий мемблок, а также генерацию конструктора с правильным количестом полей:</p>
<div style="color: #d4d4d4;background-color: #1e1e1e;font-family: Consolas, 'Courier New', monospace;font-weight: normal;font-size: 14px;line-height: 19px;white-space: pre;"><div><span style="color: #c586c0;">struct</span><span style="color: #d4d4d4;"> Vec2</span></div><div><span style="color: #d4d4d4;">&#160; &#160; x, y : </span><span style="color: #4ec9b0;">float</span></div><br><div><span style="color: #d4d4d4;">[</span><span style="color: #569cd6;">memblock,</span><span style="color: #d4d4d4;"> dump_fields]</span></div><div><span style="color: #c586c0;">struct</span><span style="color: #d4d4d4;"> Memblock</span></div><div><span style="color: #d4d4d4;">&#160; &#160; a: </span><span style="color: #4ec9b0;">int</span><span style="color: #d4d4d4;">?</span></div><div><span style="color: #d4d4d4;">&#160; &#160; b: </span><span style="color: #4ec9b0;">float</span><span style="color: #d4d4d4;">?</span></div><div><span style="color: #d4d4d4;">&#160; &#160; c: </span><span style="color: #4ec9b0;">int</span><span style="color: #d4d4d4;">?</span></div><div><span style="color: #d4d4d4;">&#160; &#160; d: Vec2?</span></div><br><div><span style="color: #d4d4d4;">[</span><span style="color: #569cd6;">memblock,</span><span style="color: #d4d4d4;"> dump_fields]</span></div><div><span style="color: #569cd6;">struct</span><span style="color: #d4d4d4;"> </span><span style="color: #4ec9b0;">MemblockInheritor</span><span style="color: #d4d4d4;"> : </span><span style="color: #4ec9b0;">Memblock</span></div><div><span style="color: #d4d4d4;">&#160; &#160; e: </span><span style="color: #4ec9b0;">int</span><span style="color: #d4d4d4;">?</span></div><br><div><span style="color: #569cd6;">def</span><span style="color: #d4d4d4;"> </span><span style="color: #dcdcaa;">fillMemblock</span><span style="color: #d4d4d4;">(</span><span style="color: #569cd6;">var</span><span style="color: #d4d4d4;"> </span><span style="color: #9cdcfe;">memblock</span><span style="color: #d4d4d4;">: Memblock)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">unsafe</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; memblock.a[</span><span style="color: #569cd6;">0</span><span style="color: #d4d4d4;">] = int(</span><span style="color: #b5cea8;">0x11223344</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; memblock.a[</span><span style="color: #569cd6;">1</span><span style="color: #d4d4d4;">] = </span><span style="color: #b5cea8;">0</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; memblock.a[</span><span style="color: #569cd6;">2</span><span style="color: #d4d4d4;">] = -</span><span style="color: #b5cea8;">1</span></div><br><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; memblock.b[</span><span style="color: #569cd6;">0</span><span style="color: #d4d4d4;">] = </span><span style="color: #c586c0;">reinterpret</span><span style="color: #d4d4d4;">&lt;</span><span style="color: #4ec9b0;">float</span><span style="color: #d4d4d4;">&gt;(</span><span style="color: #b5cea8;">0x55667788</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; memblock.b[</span><span style="color: #569cd6;">1</span><span style="color: #d4d4d4;">] = </span><span style="color: #b5cea8;">0.0</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; memblock.b[</span><span style="color: #569cd6;">2</span><span style="color: #d4d4d4;">] = </span><span style="color: #b5cea8;">123.456</span></div><br><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; memblock.c[</span><span style="color: #569cd6;">0</span><span style="color: #d4d4d4;">] = int(</span><span style="color: #b5cea8;">0xAABBCCDD</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; memblock.c[</span><span style="color: #569cd6;">1</span><span style="color: #d4d4d4;">] = </span><span style="color: #b5cea8;">0</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; memblock.c[</span><span style="color: #569cd6;">2</span><span style="color: #d4d4d4;">] = -</span><span style="color: #b5cea8;">1</span></div><br><div><span style="color: #d4d4d4;">[</span><span style="color: #569cd6;">export</span><span style="color: #d4d4d4;">]</span></div><div><span style="color: #c586c0;">def</span><span style="color: #d4d4d4;"> test</span></div><div><span style="color: #d4d4d4;">&#160; &#160; </span><span style="color: #c586c0;">unsafe</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> memblock: Memblock</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; memblock |&gt; init`</span><span style="color: #c586c0;">struct</span><span style="color: #d4d4d4;">`Memblock(</span><span style="color: #b5cea8;">5</span><span style="color: #d4d4d4;">,</span><span style="color: #b5cea8;">5</span><span style="color: #d4d4d4;">,</span><span style="color: #b5cea8;">5</span><span style="color: #d4d4d4;">,</span><span style="color: #b5cea8;">1</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; memblock |&gt; fillMemblock</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #dcdcaa;">print</span><span style="color: #d4d4d4;">(</span><span style="color: #ce9178;">"Memblock = {</span><span style="color: #9cdcfe;">memblock</span><span style="color: #ce9178;">}</span><span style="color: #d7ba7d;">\n</span><span style="color: #ce9178;">"</span><span style="color: #d4d4d4;">)</span></div><br><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #c586c0;">var</span><span style="color: #d4d4d4;"> memblock2: MemblockInheritor</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #6a9955;">//memblock2 |&gt; fillMemblock</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; memblock2 |&gt; init`</span><span style="color: #c586c0;">struct</span><span style="color: #d4d4d4;">`MemblockInheritor(</span><span style="color: #b5cea8;">5</span><span style="color: #d4d4d4;">,</span><span style="color: #b5cea8;">5</span><span style="color: #d4d4d4;">,</span><span style="color: #b5cea8;">5</span><span style="color: #d4d4d4;">,</span><span style="color: #b5cea8;">1</span><span style="color: #d4d4d4;">,</span><span style="color: #b5cea8;">10</span><span style="color: #d4d4d4;">)</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #dcdcaa;">print</span><span style="color: #d4d4d4;">(</span><span style="color: #ce9178;">"Memblock2 = {</span><span style="color: #9cdcfe;">memblock2</span><span style="color: #ce9178;">}</span><span style="color: #d7ba7d;">\n</span><span style="color: #ce9178;">"</span><span style="color: #d4d4d4;">)</span></div><br><div><span style="color: #6a9955;">//Вывод:</span></div><div><span style="color: #c586c0;">struct</span><span style="color: #d4d4d4;"> Memblock {</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; int32_t * a;</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #4ec9b0;">float</span><span style="color: #d4d4d4;"> * b;</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; int32_t * c;</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; Vec2 * d;</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; TArray&lt;uint8_t&gt; mem;</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; int32_t a`count;</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; int32_t b`count;</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; int32_t c`count;</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; int32_t d`count;</span></div><div><span style="color: #d4d4d4;">}</span></div><div><span style="color: #c586c0;">struct</span><span style="color: #d4d4d4;"> MemblockInheritor {</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; int32_t * a;</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; </span><span style="color: #4ec9b0;">float</span><span style="color: #d4d4d4;"> * b;</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; int32_t * c;</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; Vec2 * d;</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; TArray&lt;uint8_t&gt; mem;</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; int32_t a`count;</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; int32_t b`count;</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; int32_t c`count;</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; int32_t d`count;</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; int32_t * e;</span></div><div><span style="color: #d4d4d4;">&#160; &#160; &#160; &#160; int32_t e`count;</span></div><div><span style="color: #d4d4d4;">}</span></div><div><span style="color: #d4d4d4;">Memblock = [[ </span><span style="color: #b5cea8;">287454020</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">15837566074880.000000000</span><span style="color: #d4d4d4;">; -</span><span style="color: #b5cea8;">1430532899</span><span style="color: #d4d4d4;">; [[ </span><span style="color: #b5cea8;">0.000000000</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0.000000000</span><span style="color: #d4d4d4;">]]; [[ </span><span style="color: #b5cea8;">0x44</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x33</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x22</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x11</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0xff</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0xff</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0xff</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0xff</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x88</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x77</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x66</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x55</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x79</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0xe9</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0xf6</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x42</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0xdd</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0xcc</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0xbb</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0xaa</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0xff</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0xff</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0xff</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0xff</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">]]; </span><span style="color: #b5cea8;">5</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">5</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">5</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">1</span><span style="color: #d4d4d4;">]]</span></div><div><span style="color: #d4d4d4;">Memblock2 = [[ </span><span style="color: #b5cea8;">0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0.000000000</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0</span><span style="color: #d4d4d4;">; [[ </span><span style="color: #b5cea8;">0.000000000</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0.000000000</span><span style="color: #d4d4d4;">]]; [[ </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0x0</span><span style="color: #d4d4d4;">]]; </span><span style="color: #b5cea8;">5</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">5</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">5</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">1</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">0</span><span style="color: #d4d4d4;">; </span><span style="color: #b5cea8;">10</span><span style="color: #d4d4d4;">]]</span></div></div>
<h2 id="Финал"><a href="#Финал" class="headerlink" title="Финал"></a>Финал</h2><p>С данным макросом можно продолжать играться, делая его всё круче, но примерно на этом этапе можно сказать, что исходная задача решена.</p>
<p>Макросы добавляют в язык способ серьёзно модифицировать код и данные по правилам, которые захочет реализовать программист. При этом разница между тривиальной структурой и “продвинутой” с точки зрения клиентского кода — всего одна аннотация.</p>
<p>Для сравнения с C++, например <a href="https://youtu.be/gVGtNFg4ay0" target="_blank" rel="noopener">доклад  Louis Dionne</a> про реализацию библиотеки, позволяющей переопределить способ реализации полиморфизма. Без макросов невозможно реализовать идею синтаксически так, чтобы это выглядело как наследование — в компиляторе жёстко прошиты правила того, что сгенерирует комплиятор при наследовании одной структуры от другой.</p>
<p>Естественно, что макросы — это не средство повседневного решения задач. Скорее это средство для того, чтобы лучше “подстроить” язык под предметную область, и уменьшить количество рукописного рутинного кода, не относящего непосредственно к решаемой задаче.</p>
<p>Для <code>daScript</code> предметная область — это разработка игр, и, возможно, макросы позволят ему уйти далеко вперед по сравнению с тем, что умели делать любые другие скриптовые языки для игр раньше.</p>
<p><a href="https://github.com/spiiin/dascript_macro_tutorial" target="_blank" rel="noopener">https://github.com/spiiin/dascript_macro_tutorial</a> - репозиторий с кодом из заметки:<br>    <code>/src_dirty</code> — можно посмотреть диффами между парами файлов эволюцию примера из статьи. Хостом для выполнения может послужить tutorial01 - базовый пример работы с языком из официального репозитория. В остальном — непричёсанный код.<br>    <code>/examples</code> — пофикшенные примеры макросов из официального репозитория.</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script></div></article><div class="pagination"><a class="pagination__link pagination__prev" href="/blog/4232971949/">Позже</a><a class="pagination__link pagination__next" href="/blog/1728194429/">Раньше</a></div></main><footer class="footer metadata"><p class="footer__text">© 2024 spiiin</p><p class="footer__text">Powered by <a class="footer__text__link" href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a class="footer__text__link" href="https://pages.github.com/" target="_blank">Github Page</a></p></footer></div></body></html>