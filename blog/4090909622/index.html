<!DOCTYPE html><html lang="ru"><head><meta charset="UTF-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Spiiin's blog | daScript: C++ auto-bindings, msgpack</title><meta name="description" content=""><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=PT+Serif&amp;display=swap"><link rel="stylesheet" href="/css/highlights/darkula.css"><link rel="stylesheet" href="/css/main.css"><link rel="search" type="application/opensearchdescription+xml" href="http://spiiin.github.io/atom.xml" title="Spiiin's blog"><script>(function (i, s, o, g, r, a, m) {
  i['GoogleAnalyticsObject'] = r;
  i[r] = i[r] || function () {
    (i[r].q = i[r].q || []).push(arguments)
  }, i[r].l = 1 * new Date();
  a = s.createElement(o),
    m = s.getElementsByTagName(o)[0];
  a.async = 1;
  a.src = g;
  m.parentNode.insertBefore(a, m)
})(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');
ga('create', 'UA-00000000-0', 'auto');
ga('send', 'pageview');</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Spiiin's blog" type="application/atom+xml">
</head><body><div class="container"><header class="main-header"><h1 class="main-header__title uplize"><a class="main-header__title__link" href="/"><img class="header-image" src="/images/favicon.png" width="36" height="36">Spiiin's blog</a></h1><nav class="main-header__nav"><ul class="main-nav"><li class="main-nav__list"><a class="main-nav__list__link" href="/" target="_self">HOME</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/archives/" target="_self">ARCHIVE</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/tags/meta" target="_self">TAGS</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/blog/1" target="_self">ABOUT</a></li></ul></nav></header><main class="container__wrapper"><article class="article post"><h3 class="article__title">daScript: C++ auto-bindings, msgpack</h3><div class="article__date metadata"><div class="post-info">2022/05/30</div></div><div class="article__tags metadata">Tags:
<a class="article__tags__link metadata" href="/tags/gamedev/">gamedev</a></div><div class="article__body"><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Ещё один “подход” к языку daScript от Gaijin. В последней заметке про использование <a href="/blog/4232971949/" title="байндингов к OpenGL">байндингов к OpenGL</a> в daScript, я упоминал про наличие скрипта <a href="https://github.com/GaijinEntertainment/daScript/issues/231" target="_blank" rel="noopener">dasClangBind</a>, позволяюшего генерировать байндинги к библиотекам на C и C++. Так как из документации к скрипту только совет автора <code>Use it, abuse it</code>, то неплохо попробовать его в деле, чтобы разобраться, что он умеет/не умеет.</p>
<p>С помощью этого генератора байндингов сделаны обёртки над: <a href="https://github.com/VasiliyRyabtsev/dasRequests" target="_blank" rel="noopener">dasRequests</a>, <a href="https://github.com/VasiliyRyabtsev/dasPhys2d" target="_blank" rel="noopener">dasPhys2d</a>, а также добавленные в основной репозиторий <strong><code>dasGLFW, dasBGFX, dasImgui, dasOpenGL, dasClangBind</code></strong> (привязки для генератора байндингов тоже сгенерированы им самим).</p>
<p><code>dasClangBind</code> не собирается с дефолтными настройками cmake, поэтому сначала необходимо включить его сборку. В файле <a href="https://github.com/GaijinEntertainment/daScript/blob/master/modules/dasClangBind/CMakeLists.txt" target="_blank" rel="noopener">CMakeLists.txt</a> видим настройку пути с <code>libclang</code>:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET(PATH_TO_LIBCLANG $&#123;PROJECT_SOURCE_DIR&#125;&#x2F;..&#x2F;libclang)</span><br></pre></td></tr></table></figure></p>
<p>Можно скачать скомпилированные библиотеки <a href="https://github.com/llvm/llvm-project/releases/tag/llvmorg-14.0.0" target="_blank" rel="noopener">LLVM</a> (yay, даже для windows!), и указать путь к скачанной библиотеке с cmake-файле. Дальше перегенерируем решение с помощью команды <code>generate_msvc_XXX.bat</code> и компилируем проект <code>libDasModuleClangBind</code>.</p>
<p>Получаем библиотеку <code>libDasModuleClangBind.lib</code>, которую можно подключить для статической линковки из проекта, который будет использовать этот модуль (командой <code>TARGET_LINK_LIBRARIES</code>). В сгенерированном решении убеждаемся в том, что линкер подключает библиотеки <code>libDasModuleClangBind.lib</code> и <code>libclang.lib</code>:<br><img src="/blog/4090909622/lib.png" alt="lib"></p>
<p>Далее в коде подключаем заголовочный файл и макрос добавления модуля в daScript:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../modules/dasClangBind/src/dasClangBind.h"</span></span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span>, <span class="keyword">char</span> * [] )</span> </span>&#123;</span><br><span class="line">    NEED_ALL_DEFAULT_MODULES;</span><br><span class="line">    NEED_MODULE(Module_dasClangBind); <span class="comment">//&lt;---</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Теперь в das-скрипте можно импортировать модуль <code>cbind</code>, который предоставляет функции-обёртки над библиотекой <code>clang</code>, а главное — <code>cbind_boost</code>, классы, с помощью которых можно настроить поведение генераторы, без низкоуровневого обращения к c-апи clang-а:<br><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">require</span> cbind</span><br><span class="line"><span class="keyword">require</span> cbind_boost</span><br></pre></td></tr></table></figure></p>
<h2 id="libclang"><a href="#libclang" class="headerlink" title="libclang"></a>libclang</h2><p>Для начала лучше бегло ознакомиться с тем, что умеет <code>libclang</code>:<br><a href="https://shaharmike.com/cpp/libclang/" target="_blank" rel="noopener">Using libclang to Parse C++</a><br><a href="https://habr.com/ru/post/439270/" target="_blank" rel="noopener">Пример разбора C++ кода с помощью libclang на Python</a><br><a href="https://clang.llvm.org/docs/Tooling.html" target="_blank" rel="noopener">Choosing the Right Interface for Your Application</a></p>
<h2 id="DasGenBind"><a href="#DasGenBind" class="headerlink" title="DasGenBind"></a>DasGenBind</h2><p>У генератор привязок <code>dasClangBind</code>, есть 2 режима: генерация обёрток над функциями в виде daScript (с помощью ffi-интерфейса <code>dasbind</code>) — <code>DasGenBind</code>, и более мощная генерация “обвязочного” c++-кода библиотеки — <code>CppGenBind</code>. С помощью <code>DasGenBind</code> <a href="https://github.com/GaijinEntertainment/daScript/blob/master/modules/dasClangBind/bind/bind_opengl.das" target="_blank" rel="noopener">сгенерированы</a> байндинги к <a href="https://github.com/GaijinEntertainment/daScript/blob/master/modules/dasOpenGL/opengl/opengl_func.das" target="_blank" rel="noopener">OpenGL</a>, так как сама библиотека language-agnostic, и её обвязки тривиальны — используются только функции и примитивные типы.</p>
<h2 id="CppGenBind"><a href="#CppGenBind" class="headerlink" title="CppGenBind"></a>CppGenBind</h2><p>Более интересно посмотреть на байндинги к <a href="https://github.com/GaijinEntertainment/daScript/blob/master/modules/dasClangBind/bind/bind_glfw.das" target="_blank" rel="noopener">glfw</a>, по которым можно приблизительно понять, что генерируется автоматически, а что необходимо добавлять в исключения и дописывать руками. <code>dasClangBind</code> в ходе своей работы пишет, какие объявляния функций он пропускает (<a href="https://github.com/GaijinEntertainment/daScript/blob/master/modules/dasClangBind/cbind/cbind_boost.das" target="_blank" rel="noopener">код</a> - поиск по ключевому слову <code>skip</code>):</p>
<ul>
<li>шаблоны</li>
<li>функции с аргументами-указателями на функции (к примеру, колбеки)</li>
<li>чисто виртуальные функции</li>
<li>глобальные операторы<br>Также генерируются, но вызывают последующие ошибки компиляции, функции (в лучших традициях текстов ошибок шаблонов C++), получающие аргументы POD-типов по значению.</li>
</ul>
<p>Для таких функций предполагается добавление их в список пропускаемых при автоматической генерации и последующее написания обработчика в ручную:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//переопределение метода AnyGenBind</span></span><br><span class="line"> <span class="function">def <span class="keyword">override</span> <span class="title">skip_anyFunction</span> <span class="params">( var c : CXCursor; isMethod : <span class="keyword">bool</span> )</span></span></span><br><span class="line">        if AnyGenBind`skip_anyFunction(self, c, isMethod)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        <span class="comment">//свои проверки, нужно или нет генерировать обёртку для функции</span></span><br></pre></td></tr></table></figure></p>
<p>Для дописывания несгенерированных автоматически функций предусмотрен файл <code>MODULENAME.main.cpp</code>. На выходе генератор байндингов выдаёт <a href="https://github.com/borisbat/dasGlfw/tree/48f2715f0fe4cb8076866365a4bf0a29b7104765/src" target="_blank" rel="noopener">пачку</a> и кусок cmake-файла в stdout, с помощью которого можно собрать их в модуль. На практике почему-то у меня не создавались файлы <code>MODULE.func.reg.inc</code> и <code>MODULE.func.decl.,inc</code>, их для теста заполнил руками.</p>
<h2 id="CmakeList-txt"><a href="#CmakeList-txt" class="headerlink" title="CmakeList.txt"></a>CmakeList.txt</h2><p>В качестве шаблона cmake-файла можно взять готовый из других модулей, основная логика:</p>
<ul>
<li>собрать модуль из сгенерированных файлов (это за нас выводит сам <code>dasClangBind</code>)</li>
<li>подключить lib-файл самой C++ библиотеки, для которой делается обвязка</li>
<li>определить переменные сборки daScript, позволяющие отключить модуль по желанию пользователя</li>
</ul>
<h2 id="Генерация-байндингов-для-библиотеке-MessagePack"><a href="#Генерация-байндингов-для-библиотеке-MessagePack" class="headerlink" title="Генерация байндингов для библиотеке MessagePack"></a>Генерация байндингов для библиотеке MessagePack</h2><p>Исходя из ограничений генератора, для учебного примера проще всего выбрать для примера максимально простую библиотеку, имеющую C, а не С++-интерфейс. Например - <a href="https://github.com/msgpack/msgpack-c/tree/c_master" target="_blank" rel="noopener">MessagePack</a>.</p>
<p>Стартовый код генератора:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">require cbind/cbind_boost</span><br><span class="line">require daslib/safe_addr</span><br><span class="line">require daslib/strings</span><br><span class="line">require daslib/defer</span><br><span class="line">require daslib/fio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MsgpackGen</span> :</span> CppGenBind</span><br><span class="line">    override func_to_stdout = false</span><br><span class="line">    unique_functions : table&lt;string; bool&gt;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">MsgpackGen</span></span></span><br><span class="line">        bind_root = "&#123;get_das_root()&#125;/modules/dasMsgpack/src"</span><br><span class="line">        bind_module = <span class="string">"msgpack"</span></span><br><span class="line">        bind_das_module = <span class="string">"msgpack"</span></span><br><span class="line">        let pfn = <span class="string">"msgpack.h"</span></span><br><span class="line">        let pfp = <span class="string">"&#123;get_das_root()&#125;/modules/dasMsgpack/msgpack-c/include/"</span></span><br><span class="line"></span><br><span class="line">        let args &lt;- [&#123;string</span><br><span class="line">            <span class="string">"-xc++-header"</span>;</span><br><span class="line">            <span class="string">"-std=c++1z"</span>;</span><br><span class="line">            <span class="string">"-I&#123;get_full_file_name(pfp)&#125;"</span></span><br><span class="line">        &#125;]</span><br><span class="line"></span><br><span class="line">        func_per_chunk = <span class="number">20</span></span><br><span class="line">        init_args(pfn,pfp,args)</span><br><span class="line">        setDefaultFiles()</span><br><span class="line">        //init_skip_func()</span><br><span class="line">        openAllFiles()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">override</span> <span class="title">namespace_name</span><span class="params">(name:string; dash:string=<span class="string">"::"</span>)</span> :</span> string</span><br><span class="line">        <span class="keyword">return</span> AnyGenBind`namespace_name(self, name, dash)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">override</span> <span class="title">skip_struct</span><span class="params">(name : string)</span></span></span><br><span class="line"><span class="function">        <span class="title">return</span> <span class="title">false</span></span></span><br><span class="line"><span class="function">        //<span class="title">return</span> <span class="title">AnyGenBind</span>`<span class="title">skip_struct</span><span class="params">(name)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">def</span> <span class="title">override</span> <span class="title">skip_anyFunction</span><span class="params">(var c : CXCursor; isMethod:bool)</span> :</span> bool</span><br><span class="line">        let funcname = string(clang_getCursorSpelling(c))</span><br><span class="line">        //не генерировать обвязку для повторно встречаемой функции (не совсем понимаю, почему встречаются повторы)</span><br><span class="line">        <span class="keyword">if</span> unique_functions |&gt; find(funcname) != null</span><br><span class="line">            <span class="keyword">return</span> true</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            unique_functions[funcname] = true</span><br><span class="line">            <span class="keyword">return</span> AnyGenBind`skip_anyFunction(self, c, isMethod)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //генерируем код для файлов, подходящих по шаблону msgpack/*.h</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">override</span> <span class="title">skip_file</span><span class="params">(fname:string)</span> :</span> bool</span><br><span class="line">        <span class="keyword">if</span> fname |&gt; find(<span class="string">"msgpack/"</span>) != <span class="number">-1</span></span><br><span class="line">            <span class="keyword">return</span> false</span><br><span class="line">        <span class="keyword">return</span> ! fname |&gt; ends_with(PARSE_FILE_NAME)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">override</span> <span class="title">generateModuleHPrefix</span></span></span><br><span class="line"><span class="function">        <span class="title">module_h_file</span> |&gt; <span class="title">fwrite</span><span class="params">(<span class="string">"#include \"need_msgpack.h\"\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">[<span class="title">export</span>]</span></span><br><span class="line"><span class="function"><span class="title">def</span> <span class="title">main</span></span></span><br><span class="line">    var cgb = new MsgpackGen()</span><br><span class="line">    defer &lt;|</span><br><span class="line">        unsafe</span><br><span class="line">            delete cgb</span><br><span class="line">    cgb-&gt;generate()</span><br><span class="line">    cgb-&gt;genCMakeDecl("DAS_MSGPACK_BIND")</span><br></pre></td></tr></table></figure>
<p>Такой скрипт генерирует привязки к библиотеке, однако при её компиляции возникают несколько ошибок вида:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">использование неопределенного типа &quot;das::cast&lt;TT&gt;&quot; libDasModuleMsgpack \daScript\include\daScript\simulate\simulate.h</span><br></pre></td></tr></table></figure></p>
<p>Необходимо добавить эти функции в список исключаемых из генерации:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;передача в качестве аргумента POD-объекта по значению</span><br><span class="line">msgpack_object_print</span><br><span class="line">msgpack_object_print_buffer</span><br><span class="line">msgpack_object_equal</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;какие-то непонятки с передачей некоторых из базовых типов из C++ в daScript?</span><br><span class="line">msgpack_pack_char</span><br><span class="line">msgpack_pack_long</span><br><span class="line">msgpack_pack_unsigned_long</span><br></pre></td></tr></table></figure></p>
<p>Убрав их из генерации, получаем компилирующийся модуль daScript <code>dasMsgpack</code>.</p>
<h2 id="Тестовый-скрипт"><a href="#Тестовый-скрипт" class="headerlink" title="Тестовый скрипт"></a>Тестовый скрипт</h2><p>Попытаемся портировать тестовый <a href="https://github.com/msgpack/msgpack-c/blob/c_master/example/simple_c.c" target="_blank" rel="noopener">пример</a> библиотеки с <code>MessagePack</code> с языка C на daScript:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">require msgpack</span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main</span><br><span class="line">    var sbuf : msgpack_sbuffer</span><br><span class="line">    var pk : msgpack_packer</span><br><span class="line">    var mempool: msgpack_zone</span><br><span class="line">    var deserialized: msgpack_object</span><br><span class="line"></span><br><span class="line">    unsafe</span><br><span class="line">        var ptrBuf = addr(sbuf)</span><br><span class="line">        var ptrPk = addr(pk)</span><br><span class="line">        var ptrMempool = addr(mempool)</span><br><span class="line">        var ptrDeserialized = addr(deserialized)</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* msgpack::sbuffer is a simple buffer implementation. */</span></span><br><span class="line">        msgpack_sbuffer_init(ptrBuf)</span><br><span class="line">        <span class="comment">/* serialize values into the buffer using msgpack_sbuffer_write callback function. */</span></span><br><span class="line">        msgpack_packer_init(ptrPk, ptrBuf)</span><br><span class="line"></span><br><span class="line">        msgpack_pack_array(ptrPk, <span class="number">4u</span>l)</span><br><span class="line">        msgpack_pack_int(ptrPk, <span class="number">1</span>)</span><br><span class="line">        msgpack_pack_true(ptrPk)</span><br><span class="line">        msgpack_pack_float(ptrPk, <span class="number">3.0</span>)</span><br><span class="line">        msgpack_pack_str(ptrPk, <span class="number">7u</span>l)</span><br><span class="line">        msgpack_pack_str_body(ptrPk, <span class="string">"example"</span>, <span class="number">7u</span>l);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//print("&#123;sbuf.data&#125;, &#123;sbuf.size&#125;")</span></span><br><span class="line"></span><br><span class="line">        msgpack_zone_init(ptrMempool, <span class="number">2048u</span>l)</span><br><span class="line"></span><br><span class="line">        var data = <span class="number">0u</span>l;</span><br><span class="line">        var ptrData = addr(data)</span><br><span class="line">        msgpack_unpack(sbuf.data, sbuf.<span class="built_in">size</span>, ptrData, ptrMempool, ptrDeserialized);</span><br><span class="line">        msgpack_object_print(ptrDeserialized);</span><br><span class="line"></span><br><span class="line">        msgpack_zone_destroy(ptrMempool);</span><br><span class="line">        msgpack_sbuffer_destroy(ptrBuf)</span><br></pre></td></tr></table></figure>
<p>Некоторые функции из примеры не попали в автоматическую обвязку, поэтому необходимо дописать обвязку для них вручную в файле <code>msgpack.main.cpp</code>:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//передаём 3-й параметр по умолчанию</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">das_msgpack_packer_init</span><span class="params">(msgpack_packer* pk, <span class="keyword">void</span>* data)</span> </span>&#123;</span><br><span class="line">	msgpack_packer_init(pk, data, msgpack_sbuffer_write);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//передаём параметр по указателю, не по значению</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">das_msgpack_object_print</span><span class="params">(msgpack_object* o)</span> </span>&#123;</span><br><span class="line">	msgpack_object_print(<span class="built_in">stdout</span>, *o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//меняем тип второго указателя на const char* вместо неизвестного генератору void *</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">das_msgpack_pack_str_body</span><span class="params">(msgpack_packer* pk, <span class="keyword">const</span> <span class="keyword">char</span>* b, <span class="keyword">size_t</span> l)</span> </span>&#123;</span><br><span class="line">	msgpack_pack_str_body(pk, b, l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Module_msgpack::initMain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//добавляем функции в модуль</span></span><br><span class="line">	addExtern&lt;DAS_BIND_FUN(das_msgpack_packer_init)&gt;(*<span class="keyword">this</span>,lib,<span class="string">"msgpack_packer_init"</span>,</span><br><span class="line">            SideEffects::worstDefault,<span class="string">"das_msgpack_packer_init"</span>);</span><br><span class="line">	addExtern&lt;DAS_BIND_FUN(das_msgpack_object_print)&gt;(*<span class="keyword">this</span>, lib, <span class="string">"msgpack_object_print"</span>,</span><br><span class="line">		SideEffects::worstDefault, <span class="string">"das_msgpack_object_print"</span>);</span><br><span class="line">	addExtern&lt;DAS_BIND_FUN(das_msgpack_pack_str_body)&gt;(*<span class="keyword">this</span>, lib, <span class="string">"msgpack_pack_str_body"</span>,</span><br><span class="line">		SideEffects::worstDefault, <span class="string">"das_msgpack_pack_str_body"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Теперь скрипт работает и выдаёт корректный результат десериализации объекта:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1, true, 3.000000, &quot;example&quot;]</span><br></pre></td></tr></table></figure></p>
<p>Дальнейшая работа над модулем может предполагать:</p>
<ul>
<li>возможность устанавливать daScript колбеки (<a href="https://github.com/borisbat/dasGlfw/blob/48f2715f0fe4cb8076866365a4bf0a29b7104765/src/cb_dasGLFW.h" target="_blank" rel="noopener">пример из dasGlfw</a>)</li>
<li>daScript-обвязка над POD-структурой msgpack_object и корректная передача исключенных типов(?)</li>
<li>написание “daScript-ивизирующей” обёртки msgpack_boost, для перехода от с-апи к более удобной работы с библиотекой</li>
</ul>
<p><a href="https://github.com/spiiin/dasClangBind_modules" target="_blank" rel="noopener">Репозиторий с примерами кода</a></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script></div></article><section class="comments"><div id="disqus_thread"></div><script>var disqus_shortname = 'spiiin-github-io';
(function () {
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//#{theme.disqus}.disqus.com/count.js" async></script></section><div class="pagination"><a class="pagination__link pagination__prev" href="/blog/500729544/">Next</a><a class="pagination__link pagination__next" href="/blog/1257365288/">Back</a></div></main><footer class="footer metadata"><p class="footer__text">© 2022 spiiin</p><p class="footer__text">Powered by <a class="footer__text__link" href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a class="footer__text__link" href="https://pages.github.com/" target="_blank">Github Page</a></p></footer></div></body></html>