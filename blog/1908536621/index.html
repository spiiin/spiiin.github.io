<!DOCTYPE html><html lang="ru"><head><meta charset="UTF-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Spiiin's blog | daScript - binding tricks</title><meta name="description" content=""><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=PT+Serif&amp;display=swap"><link rel="stylesheet" href="/css/highlights/darkula.css"><link rel="stylesheet" href="/css/main.css"><link rel="search" type="application/opensearchdescription+xml" href="http://spiiin.github.io/atom.xml" title="Spiiin's blog"><script>(function (i, s, o, g, r, a, m) {
  i['GoogleAnalyticsObject'] = r;
  i[r] = i[r] || function () {
    (i[r].q = i[r].q || []).push(arguments)
  }, i[r].l = 1 * new Date();
  a = s.createElement(o),
    m = s.getElementsByTagName(o)[0];
  a.async = 1;
  a.src = g;
  m.parentNode.insertBefore(a, m)
})(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');
ga('create', 'UA-00000000-0', 'auto');
ga('send', 'pageview');</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Spiiin's blog" type="application/atom+xml">
</head><body><div class="container"><header class="main-header"><h1 class="main-header__title uplize"><a class="main-header__title__link" href="/"><img class="header-image" src="/images/favicon.png" width="36" height="36">Spiiin's blog</a></h1><nav class="main-header__nav"><ul class="main-nav"><li class="main-nav__list"><a class="main-nav__list__link" href="/" target="_self">HOME</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/archives/" target="_self">ARCHIVE</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/tags/meta" target="_self">TAGS</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/blog/1" target="_self">ABOUT</a></li></ul></nav></header><main class="container__wrapper"><div class="pagination"><a class="pagination__link pagination__prev" href="/blog/3778037319/">Позже</a><a class="pagination__link pagination__next" href="/blog/421834894/">Раньше</a></div><article class="article post"><h3 class="article__title">daScript - binding tricks</h3><div class="article__date metadata"><div class="post-info">2023/09/05</div></div><div class="article__tags metadata">Tags:
<a class="article__tags__link metadata" href="/tags/dascript/">dascript</a></div><div class="article__body"><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Несколько примеров дополнительно к <a href="https://dascript.org/doc/reference/embedding/modules.html" target="_blank" rel="noopener">Modules and C++ bindings</a></p>
<p><strong><code>Привязка метода класса</code></strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//структура с методами</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">42</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//тип-обёртка, описание структуры для daScript</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStructTypeAnnotation</span> :</span> ManagedStructureAnnotation &lt;MyStruct&gt; &#123;</span><br><span class="line">    MyStructTypeAnnotation(ModuleLibrary&amp; ml) : ManagedStructureAnnotation(<span class="string">"MyStruct"</span>, ml) &#123;</span><br><span class="line">        <span class="comment">//тут может быть описание полей</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">MAKE_TYPE_FACTORY(MyStruct, MyStruct)</span><br><span class="line"></span><br><span class="line"><span class="comment">//описание модуля</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Module_Tutorial02</span> :</span> <span class="keyword">public</span> Module &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Module_Tutorial02() : Module(<span class="string">"tutorial_02"</span>) &#123;   <span class="comment">// module name, when used from das file</span></span><br><span class="line">        ModuleLibrary lib;</span><br><span class="line">        lib.addModule(<span class="keyword">this</span>);</span><br><span class="line">        lib.addBuiltInModule();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//описание структуры</span></span><br><span class="line">        addAnnotation(make_smart&lt;MyStructTypeAnnotation&gt;(lib));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//регистрация метода</span></span><br><span class="line">        <span class="keyword">using</span> method_test = DAS_CALL_MEMBER(MyStruct::test);</span><br><span class="line">        addExtern&lt;DAS_CALL_METHOD(method_test)&gt;(*<span class="keyword">this</span>, lib, <span class="string">"mystruct_test"</span>, SideEffects::none,</span><br><span class="line">            DAS_CALL_MEMBER_CPP(MyStruct::test));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//возможный вызов метода в daScript</span></span><br><span class="line">var c: MyStruct</span><br><span class="line">print(<span class="string">"&#123;c |&gt; mystruct_test()&#125;"</span>)</span><br></pre></td></tr></table></figure>
<p><strong><code>Привязка перегруженных и шаблонных функций с явным указанием сигнатуры</code></strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test2</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123; <span class="keyword">return</span> a; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">test3</span><span class="params">(T a)</span> </span>&#123; <span class="keyword">return</span> a; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//явное указание сигнатуры функции для привязки</span></span><br><span class="line">addExtern&lt;<span class="keyword">int</span>(*)(<span class="keyword">int</span>),test2&gt;(*<span class="keyword">this</span>, lib, <span class="string">"test2"</span>, SideEffects::none, <span class="string">"test2"</span>);</span><br><span class="line">addExtern&lt;<span class="keyword">int</span>(*)(<span class="keyword">int</span>), test3&gt;(*<span class="keyword">this</span>, lib, <span class="string">"test3"</span>, SideEffects::none, <span class="string">"test3"</span>);</span><br></pre></td></tr></table></figure>
<p><strong><code>Возврат ссылки</code></strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> gValue = <span class="number">111</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">getRef</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> gValue; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span>&amp; <span class="title">getRefInline</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> gValue; &#125;</span><br><span class="line"></span><br><span class="line">addExtern&lt;DAS_BIND_FUN(getRef), SimNode_ExtFuncCallRef&gt;(*<span class="keyword">this</span>, lib, <span class="string">"getRef"</span>, SideEffects::accessExternal, <span class="string">"getRef"</span>);</span><br><span class="line">addExternTempRef&lt;DAS_BIND_FUN(getRefInline), SimNode_ExtFuncCallRef&gt;(*<span class="keyword">this</span>, lib, <span class="string">"getRefInline"</span>, SideEffects::accessExternal, <span class="string">"getRefInline"</span>);</span><br><span class="line">```</span><br></pre></td></tr></table></figure>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">getRef() = <span class="number">333</span></span><br><span class="line">print(<span class="string">"&#123;getRef()&#125;\n"</span>) <span class="comment">//333</span></span><br><span class="line"></span><br><span class="line">var v4&amp; = getRefInline()</span><br><span class="line">v4 = <span class="number">444</span></span><br><span class="line">print(<span class="string">"&#123;getRefInline()&#125;\n"</span>) <span class="comment">//444</span></span><br></pre></td></tr></table></figure>
<p><strong><code>Возврат ссылки по значению</code></strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//returns a ref type by value,</span></span><br><span class="line">addExtern&lt;DAS_BIND_FUN(float4x4_translation), SimNode_ExtFuncCallAndCopyOrMove&gt;(*<span class="keyword">this</span>, lib, <span class="string">"translation"</span>,</span><br><span class="line">        SideEffects::none, <span class="string">"float4x4_translation"</span>)-&gt;arg(<span class="string">"xyz"</span>);</span><br></pre></td></tr></table></figure>
<p><strong><code>Привязка других типов нод AST</code></strong><br>Способы привязать семантику вызова функции на стороне daScript к генерации других типов нод</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">__forceinline <span class="keyword">float</span> <span class="title">dot3</span><span class="params">(vec4f a, vec4f b)</span></span>&#123;<span class="keyword">return</span> v_extract_x(v_dot3_x(a, b));&#125;</span><br><span class="line">addExternEx&lt;<span class="keyword">float</span>(float3,float3),DAS_BIND_FUN(dot3)&gt;(*<span class="keyword">this</span>, lib, <span class="string">"dot"</span>, SideEffects::none, <span class="string">"dot3"</span>)-&gt;args(&#123;<span class="string">"x"</span>,<span class="string">"y"</span>&#125;);</span><br><span class="line"></span><br><span class="line">addFunction(make_smart&lt;BuiltInFn&lt;SimNode_MatrixCtor&lt;float3x3&gt;,float3x3&gt;&gt;(<span class="string">"float3x3"</span>,lib));</span><br></pre></td></tr></table></figure>
<p><strong><code>Хинты для аргументов</code></strong></p>
<p>//TODO<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TT&gt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">registerVectorFunctions</span>&lt;TT&gt; &#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    addExtern&lt;DAS_BIND_FUN(das_vector_pop&lt;TT&gt;)&gt;(*mod, lib, <span class="string">"pop"</span>,</span><br><span class="line">        SideEffects::modifyArgument, <span class="string">"das_vector_pop"</span>);</span><br><span class="line">    <span class="comment">//permanentArgFn</span></span><br><span class="line">    addExtern&lt;DAS_BIND_FUN(das_vector_clear&lt;TT&gt;),SimNode_ExtFuncCall,permanentArgFn&gt;(*mod, lib, <span class="string">"clear"</span>,</span><br><span class="line">        SideEffects::modifyArgument, <span class="string">"das_vector_clear"</span>);</span><br><span class="line">    <span class="comment">//explicitConstArgFn</span></span><br><span class="line">    addExtern&lt;DAS_BIND_FUN(das_vector_each&lt;TT&gt;),SimNode_ExtFuncCallAndCopyOrMove,explicitConstArgFn&gt;(*mod, lib, <span class="string">"each"</span>,</span><br><span class="line">        SideEffects::none, <span class="string">"das_vector_each"</span>);</span><br><span class="line">    <span class="comment">//temporaryArgFn</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong><code>Симуляция walk</code></strong></p>
<p>Создание своего типа-хендла, который в dascript будет обрабатываться как примитивный тип uint64</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyHandle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> id;</span><br><span class="line">    <span class="comment">//другие методы и свойства handle</span></span><br><span class="line">&#125;;</span><br><span class="line">MAKE_TYPE_FACTORY(MyHandle, MyHandle)</span><br><span class="line"></span><br><span class="line"><span class="comment">//описываем методы каста к примитивному типу и обратно</span></span><br><span class="line"><span class="keyword">namespace</span> das</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;&gt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cast</span>&lt;MyHandle&gt;</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> __forceinline MyHandle <span class="title">to</span><span class="params">(vec4f x)</span> </span>&#123; <span class="keyword">return</span> MyHandle&#123; (<span class="keyword">uint64_t</span>)v_extract_xi64(v_cast_vec4i(x)) &#125;; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> __forceinline vec4f <span class="title">from</span><span class="params">(MyHandle x)</span> </span>&#123; <span class="keyword">return</span> v_cast_vec4f(v_splatsi64(x.id)); &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//описываем аннотацию типа с перегруженным методом walk</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyHandleAnnotation</span> <span class="title">final</span> :</span> ManagedStructureAnnotation&lt;MyHandle&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyHandleAnnotation(ModuleLibrary&amp; ml) : ManagedStructureAnnotation(<span class="string">"MyHandle"</span>, ml) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasNonTrivialCtor</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125; <span class="comment">//trivial type</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canClone</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">(DataWalker&amp; walker, <span class="keyword">void</span>* data)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!walker.reading)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">const</span> MyHandle* t = (MyHandle*)data;</span><br><span class="line">            <span class="keyword">uint64_t</span> eidV = t-&gt;id;</span><br><span class="line">            walker.UInt64(eidV);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> SimNode* <span class="title">simulateClone</span><span class="params">(das::Context&amp; context, <span class="keyword">const</span> das::LineInfo&amp; at, das::SimNode* l, das::SimNode* r)</span> <span class="keyword">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> GenCloneNode&lt;MyHandle&gt;::simulateClone(context, at, l, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong><code>Симуляция итератора</code></strong><br>Для кастомного контейнера можно задать прямой способ обращения к элементам (для простоты — нешаблонная версия кода)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//кастомный вектор из элементов MyHandle</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyVector</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;MyHandle&gt; vec;</span><br><span class="line">&#125;;</span><br><span class="line">MAKE_TYPE_FACTORY(MyVector, MyVector)</span><br><span class="line"></span><br><span class="line"><span class="comment">//создаём вектор в C++ и делаем функцию доступа к нему из daScript</span></span><br><span class="line">MyVector gVector = &#123; &#123;MyHandle&#123;<span class="number">1</span>&#125;, MyHandle&#123;<span class="number">3</span>&#125;, MyHandle&#123;<span class="number">5</span>&#125;&#125; &#125;;</span><br><span class="line"><span class="function"><span class="keyword">auto</span>&amp; <span class="title">getArrayRef</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> gVector; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//кастомный итератор</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyIterator</span> :</span> Iterator</span><br><span class="line">&#123;</span><br><span class="line">    MyIterator(MyVector* ar) : <span class="built_in">array</span>(ar) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">first</span><span class="params">(das::Context&amp;, <span class="keyword">char</span>* _value)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">array</span>-&gt;vec.size())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        iterator_type* value = (iterator_type*)_value;</span><br><span class="line">        *value = <span class="built_in">array</span>-&gt;vec.begin(); <span class="comment">//пишем в память, выделенную в daScript под итератор</span></span><br><span class="line">        end = <span class="built_in">array</span>-&gt;vec.end();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">next</span><span class="params">(das::Context&amp;, <span class="keyword">char</span>* _value)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        iterator_type* value = (iterator_type*)_value;</span><br><span class="line">        ++(*value); <span class="comment">//сдвигаем курсор на следующий элемент</span></span><br><span class="line">        <span class="keyword">return</span> *value != end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(das::Context&amp; context, <span class="keyword">char</span>* _value)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//освобождаем итератор, по хорошему нужно еще занулить value</span></span><br><span class="line">        context.heap-&gt;<span class="built_in">free</span>((<span class="keyword">char</span>*)<span class="keyword">this</span>, <span class="keyword">sizeof</span>(MyIterator));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MyVector* <span class="built_in">array</span> = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(<span class="built_in">array</span>-&gt;vec.begin())</span> iterator_type</span>;</span><br><span class="line">    iterator_type end;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//в аннотации типа вектора говорим:</span></span><br><span class="line"><span class="comment">//"при обращении к итератору контейнера из daScript будет создан кастомный класс итератора и вызываться его методы"</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyVectorAnnotation</span> <span class="title">final</span> :</span> ManagedStructureAnnotation&lt;MyVector, <span class="literal">false</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    TypeDeclPtr vecType;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    MyVectorAnnotation(das::ModuleLibrary&amp; ml) : ManagedStructureAnnotation(<span class="string">"MyVector"</span>, ml)</span><br><span class="line">    &#123;</span><br><span class="line">        cppName = <span class="string">"MyVector"</span>;</span><br><span class="line"></span><br><span class="line">        vecType = makeType&lt;MyHandle&gt;(ml);</span><br><span class="line">        vecType-&gt;ref = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">isIterable</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> das::TypeDeclPtr <span class="title">makeIteratorType</span><span class="params">(<span class="keyword">const</span> das::ExpressionPtr&amp;)</span> <span class="keyword">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> das::make_smart&lt;das::TypeDecl&gt;(*vecType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//используем наш итератор для обхода</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> das::SimNode* <span class="title">simulateGetIterator</span><span class="params">(das::Context&amp; context, <span class="keyword">const</span> das::LineInfo&amp; at,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> das::ExpressionPtr&amp; src)</span> <span class="keyword">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> rv = src-&gt;simulate(context);</span><br><span class="line">        <span class="keyword">return</span> context.code-&gt;makeNode&lt;das::SimNode_AnyIterator&lt;MyVector, MyIterator&gt;&gt;(at, rv);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//не забываем добавить в модуль аннотации</span></span><br><span class="line">addAnnotation(make_smart&lt;MyHandleAnnotation&gt;(lib));</span><br><span class="line">addAnnotation(make_smart&lt;MyVectorAnnotation&gt;(lib));</span><br><span class="line">addExtern&lt;DAS_BIND_FUN(getArrayRef), SimNode_ExtFuncCallRef&gt;(*<span class="keyword">this</span>, lib, <span class="string">"getArrayRef"</span>,</span><br><span class="line">    SideEffects::accessExternal, <span class="string">"getArrayRef"</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//теперь можно пройти по C++-контейнеру из daScript без дополнительных затрат на итерации</span></span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> getArrayRef()</span><br><span class="line">    print(<span class="string">"&#123;v&#125;\n"</span>)</span><br></pre></td></tr></table></figure>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"Ov23liG1mZbiQOIdi91X","clientSecret":"e05812685eb741a752982b89dcf6f5b58dc10251","repo":"spiiin.github.io","owner":"spiiin","admin":["spiiin"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script></div></article><div class="pagination"><a class="pagination__link pagination__prev" href="/blog/3778037319/">Позже</a><a class="pagination__link pagination__next" href="/blog/421834894/">Раньше</a></div></main><footer class="footer metadata"><p class="footer__text">© 2024 spiiin</p><p class="footer__text">Powered by <a class="footer__text__link" href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a class="footer__text__link" href="https://pages.github.com/" target="_blank">Github Page</a></p></footer></div></body></html>