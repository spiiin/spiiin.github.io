<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Spiiin&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://spiiin.github.io/"/>
  <updated>2022-10-14T22:31:54.092Z</updated>
  <id>http://spiiin.github.io/</id>
  
  <author>
    <name>spiiin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Устройство интерпретаторов lua-jit и daScript</title>
    <link href="http://spiiin.github.io/blog/2115627465/"/>
    <id>http://spiiin.github.io/blog/2115627465/</id>
    <published>2022-10-14T09:37:34.000Z</published>
    <updated>2022-10-14T22:31:54.092Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Устройство виртуальных машин для самых быстрых скриптовых языков — <a href="https://luajit.org/" target="_blank" rel="noopener">lua-jit</a> и <a href="https://dascript.org/" target="_blank" rel="noopener">daScript</a>.<br>Более развёрнутое продолжение беглой заметки <a href="/blog/1067581840/" title="daScript - скорость">daScript - скорость</a></p><a id="more"></a><h2 id="Lua"><a href="#Lua" class="headerlink" title="Lua"></a>Lua</h2><p>По <a href="https://github.com/r-lyeh-archived/scriptorium" target="_blank" rel="noopener">бенчмаркам языков</a> <code>lua</code> находится высоко даже в режиме интерпретации.</p><p>Первые стадии трансформации текста скрипта — лексический и синтаксический анализ. Текст разбивается на отдельные лексемы/токены, которые затем собираются парсером во что-то, что можно интерпретировать. Чаще всего это или поток последовательных инструкций (байт код для интерпретатора) в случае с <code>lua</code>, или AST(дерево, которое будет обходить интерпретатор) в случае с <code>daScript</code>.</p><p>Я не буду заострять внимание на отличиях типов интерпретаторов, детально можно прочитать про это в книге <a href="http://craftinginterpreters.com/" target="_blank" rel="noopener">Crafting Interpreters</a>, с примерами интерпретаторов обоих типов (или даже более <a href="https://gameprogrammingpatterns.com/bytecode.html" target="_blank" rel="noopener">сжато</a>). Интереснее следующий шаг — посмотреть почему именно эти интерпретаторы быстрее других.</p><p>“Традиционный” подход к дизайну языков с байт-кодом — динамическая типизация, управление памятью с помощью подсчёта ссылок/garbage collector, небольшой набор базовых типов (примитивы + строки + массивы + функции/замыкания + таблицы, опционально - итераторы, корутины, исключения). Из таблиц (пары ключ-значения) можно построить объекты и “собрать” классы — некоторые ключи таблицы делаем зарезервированными, вызывая их для создания/удаления объектов, ссылки на родительскую таблицу, перегрузки операторов и т.п.</p><p>Возможные оптимизации:</p><ul><li>Так как чаще всего данные группируются в объекты (представленные таблицами) — то очень важна быстрая реализация этих хеш-таблиц, в чём lua традиционна считается хорошей.</li><li><a href="http://craftinginterpreters.com/optimization.html#nan-boxing" target="_blank" rel="noopener">Nan-tagging</a> — распространённая паковка базовых типов языка виртуальной машины в тип <code>double</code>. Возникает отчасти из желания хранить примитивные типы в той же форме, что и сложные — в динамически типизированном языке нужно где-то сохранить в том числе и тип аргумента, чтобы знать, как его интерпретировать, и при этом не хочется иметь оверхед для примитивных типов. </li></ul><p>Отчасти из этой оптимизаций возникает ограничение на количество базовых типов языка — с точки зрения скриптового языка два класса будут иметь разные типы, но для интерпретатора виртуальной машины они оба будут представлены типом “таблица”, и отличаться только значением ключа “название класса”. Также любой вызов метода означает поиск его в таблице. Ещё один минус — требование “раскодировать” аргументы из запакованной формы при взаимодействии с нативным кодом, из-за чего замедляется передача управления в хост язык и обратно. Т.е. нельзя оптимизировать код, просто переносом мелких функций в хост-язык — необходимо переписывать сразу большие куски кода.</p><ul><li>Поиск частых паттернов в инструкциях. <a href="http://craftinginterpreters.com/methods-and-initializers.html#optimized-invocations" target="_blank" rel="noopener">Optimizing invocation</a> — пример слияния пары инструкций “получение метода класса + вызов метода”. В общем случае, метод может быть получен не для вызова, а для сохранения в переменную, но чаще всего вызывается напрямую, так что две инструкции, идущие подряд, можно “слить” в одну. В lua вроде не применяется, но повсеместно юзается в daScript, примеры приведу дальше. Оптимизация известна под названиями <code>Instruction fusion</code> или <code>Super-instructions</code>.</li></ul><h2 id="Tracing-JIT"><a href="#Tracing-JIT" class="headerlink" title="Tracing JIT"></a>Tracing JIT</h2><p>Основная сила lut-jit - just-in-time компиляция. Каждый раз, при вызовах функций и циклов (<code>thermal function/cycle</code>), интерпретатор подсчитывает количество таких вызовов, и таким образом, определяет “горячий” код. Алгоритм подсчёта (NLF region-selection) также умеет обнаруживать вложенные циклы и вызовы.</p><p>При достижении предельного количества вызовов, интерпретатор выполняет отмеченный участок кода с “трассированием”, то есть кроме выполнения инструкции дополнительно сохраняет её же в список инструкций — уже на другом байт-код языке (intermediate representation, <a href="http://webcache.googleusercontent.com/search?q=cache:U5V-zQuM-ikJ:wiki.luajit.org/SSA-IR-2.0&amp;cd=1&amp;hl=ru&amp;ct=clnk&amp;gl=am" target="_blank" rel="noopener">спек</a>).</p><p>После записи всех инструкций из IR генерируется машинный код, и следующий вызов этого участка кода уже приведёт к тому, чтобы будет вызвана нативная версия кода. Подмена способов вызова функции реализована с помощью патчинга оп-кодов байт-кода lua (call gates).</p><p>Генерация нативного машинного кода разрешена не на всех платформах/ОС (память для выполнения нативного кода защищена от записи), поэтому недоступна для части платформ. Также нативный код для различных архитектур отличается, поэтому добавление новой платформы может требовать написания отдельного генератора кода.</p><p><a href="http://lua-users.org/lists/lua-l/2009-11/msg00089.html" target="_blank" rel="noopener">Список особенностей</a> jit-компилятора lua:</p><ul><li>оптимизация IR-кода - сворачивание и выбрасывание неиспользуемых блоков</li><li>при возврате из нативной части кода в интерпретируемую, оптимизиуется восстановление состояния виртуальной машины, сохраняются “дифы” между состояниями</li><li>типизация аргументов, при трассировании кода записываются реальные типы переменных</li></ul><p>Тривиальный пример, с неизвестными типами аргументов:<br><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(t, k)</span></span></span><br><span class="line">    <span class="keyword">return</span> t[k]</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><br>Может быть интерпретирован различными способами - t может быть таблицей или любым типом, у которого установлена метатаблица, k - числом, строкой или любым типом, и даже [] - метаметодом. В принципе, этот код может со всеми возможными комбинациями задействовать половину ветвей интерпретации ядры lua. Но если трассирующий компилятор запишет реально используемые типы, то он может сгенерировать быстрый нативный код, к примеру индексации массива (сгенерировав предварительно код проверки типов аргументов). Это даёт ускорение ~3 раза, по <a href="https://staff.fnwi.uva.nl/h.vandermeer/docs/lua/luajit/luajit_intro.html#:~:text=As%20the%20name%20says%20LuaJIT,are%20not%20compiled%20at%20all." target="_blank" rel="noopener">замерам</a> авторов.</p><h2 id="daScript"><a href="#daScript" class="headerlink" title="daScript"></a>daScript</h2><p>daScript серьёзно отличается от “традиционных” скриптовых языков.</p><p>В первую очередь — на выходе синтаксического анализатора получается на байт-код, а абстрактное синтаксическое дерево, причём типизированное.</p><p>Типизация немного усложняет изучение языка, но позволяет избавиться от огромного количества ошибок типов. Если рассмотреть синтетический пример на lua, то обнаружить фактические типы аргменутов t и k может быть сложно в цепочке вызовов, а проверить их корректность можно только в рантайме. Представьте, что <code>foo</code> ожидает в качестве t список из строк и выбирает из него первый элемент (допустим, сортированный список допустимых фраз персонажа игры). Список составляется и сортируется динамически. На каком-то этапе в ходе рефактора программист добавляет дополнительную функцию в цепочку вызовов, которая проверяет граничное условие (не то, чтобы это хороший код или пример, но подобную ошибку с подменой списка строкой встречал много раз):</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkIfGameOver</span><span class="params">(t, k)</span></span></span><br><span class="line">    <span class="keyword">if</span> life &lt;= <span class="number">0</span> <span class="keyword">then</span> </span><br><span class="line">        foo(<span class="string">"game over!"</span>, k) //вместо foo([<span class="string">"game over!"</span>], k)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        foo(t, k)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>Если условие редкое, и код кажется программисту слишком тривиальным, чтобы его проверить в рантайме, баг может остаться незамеченным для ревьюера, а то и для QA. В типизированном языке ошибка бы скорее всего обнаружилась компилятором.</p><p>Представление в виде AST, а не байт-кода, упрощает генерацию и анализ кода, например — с ним работают <a href="/blog/1547564887/" title="макросы">макросы</a>, а также упрощается написание тулзов, анализирующих код.</p><p>На уровне AST намного удобнее проводить оптимизации, в этот момент интерпретатор иметь достаточно много информации о коде. <code>daScript</code> позволяет изучить код на каждом шаге оптимизации. Простейший пример:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//log_optimization_passes - выводит результаты всех промежуточных стадий оптимизации AST</span></span><br><span class="line">options optimize=<span class="literal">true</span>, log_optimization_passes = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">def test(cond, a, b)</span><br><span class="line">    <span class="keyword">if</span> cond</span><br><span class="line">        <span class="keyword">return</span> a + b</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main()</span><br><span class="line">    print(<span class="string">"&#123;test(true, 2, 2)&#125;\n"</span>)</span><br></pre></td></tr></table></figure><p>После стадии <code>CONST_FOLDING</code> можно увидеть, что AST “свернулся” до:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;4&#125;\n"</span>)</span></span></span><br></pre></td></tr></table></figure></p><p>После оптимизаций <code>daScript</code> <strong>не интерпретирует AST</strong> и <strong>не генерирует</strong> байт-код. Вместо этого генерируется <a href="https://github.com/GaijinEntertainment/daScript/blob/master/src/ast/ast_simulate.cpp#L2912" target="_blank" rel="noopener">дерево симуляции</a>. На этом этапе также происходит оптимизация — AST ноды “отбрасывают” ненужную для симуляции информацию, например, информацию о типах (она больше не нужна, типы известны и статически проверены на уровне AST), и умеют генерировать более оптимизированные частные случаи (<a href="simulate">симуляция</a> simulate-ноды из ast-ноды ifThenElse, ветка <em>//good old if</em> - дефолтный вариант, остальные — оптимизированные).</p><p>Базовый класс нод simulate-ноды<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SimNode</span> &#123;</span></span><br><span class="line">    SimNode ( <span class="keyword">const</span> LineInfo &amp; at ) : debugInfo(at) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> SimNode * <span class="title">copyNode</span> <span class="params">( Context &amp; context, NodeAllocator * code )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> vec4f <span class="title">eval</span> <span class="params">( Context &amp; )</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> SimNode * <span class="title">visit</span> <span class="params">( SimVisitor &amp; vis )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> *      <span class="title">evalPtr</span> <span class="params">( Context &amp; context )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span>        <span class="title">evalBool</span> <span class="params">( Context &amp; context )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span>       <span class="title">evalFloat</span> <span class="params">( Context &amp; context )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span>      <span class="title">evalDouble</span> <span class="params">( Context &amp; context )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int32_t</span>     <span class="title">evalInt</span> <span class="params">( Context &amp; context )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">uint32_t</span>    <span class="title">evalUInt</span> <span class="params">( Context &amp; context )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int64_t</span>     <span class="title">evalInt64</span> <span class="params">( Context &amp; context )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">uint64_t</span>    <span class="title">evalUInt64</span> <span class="params">( Context &amp; context )</span></span>;</span><br><span class="line">    LineInfo debugInfo;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">rtti_node_isSourceBase</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>;  &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">rtti_node_isBlock</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">rtti_node_isInstrument</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">rtti_node_isInstrumentFunction</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">rtti_node_isJit</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~SimNode() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>У Sim-ноды есть универсальная функция <code>eval</code>, и частные случаи <code>evalXXX</code> для избегания копирования. <code>vec4f</code> в данном случае можно рассматривать не только как конкретный тип (очень полезный именно в геймдеве), но и как 128-битный “передатчик” данных, который в случае необходимости кастится в другим типам с помощью библиотеки <a href="https://github.com/GaijinEntertainment/vecmath" target="_blank" rel="noopener">vecmath</a>, в которой реализован быстрый каст для различных архитектур (HAL) вызовом интринсик-функций.</p><p>Сравнение дерева симуляции и байт-код представления:</p><ul><li>Ноды лежат в памяти плоско в линейном аллокаторе, как и байт-код</li><li>Обход дерева не требует интерпретации. Т.е. 1) не нужно сопоставлять байт-коду функцию, и 2) связь между нодами осуществляется по указателям, а не байт-кодом команд передачи управления/через регистры/стек</li><li>Типы данных хранятся также, как и в нативном коде, нет кодирования/декодирования аргументов, результатов</li><li>Нет ограничения на количество типов нод, когда bind-ится функция, то создаётся кастомная нода, за счёт чего вызов функций быстрый</li></ul><p>С таким дизайном возможны оптимизации добавлением частных случаев новых типов нод:</p><ul><li>Упомянутые выше уникальные типы нод для вызова функции</li><li>Специализированные версии нод для отдельных типов для чуть более быстрой математики, конкретных специализаций контейнеров (<a href="https://github.com/GaijinEntertainment/daScript/blob/master/include/daScript/simulate/sim_policy.h" target="_blank" rel="noopener">SimPolicy</a>)</li><li>Из-за того, что можно не экономить на типах нод, можно в полную силу использовать fusion нескольких нод в одну специализированную</li></ul><p>Цена большого количества специализированных версий нод — увеличение размера бинарника приложения, поэтому уровень “сплава” нескольких нод в одну регулируется через дефайн <code>DAS_FUSION</code>. 0 - не включать fusion-движок, 1 - “нормальный” уровень слияния, 2 - максимальное количество специализированных нод.</p><p>Пример работы fusion-движка:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">options log_nodes=<span class="literal">true</span>, optimize=<span class="literal">false</span></span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>] <span class="comment">//оставляем, чтобы оптимизатор не выбросил функцию</span></span><br><span class="line">def test(a, b)</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br></pre></td></tr></table></figure></p><p>Если изменить значение <code>optimize=true</code>, можно увидеть разницу в количестве нод:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; неоптимизированная версия, 6 нод</span><br><span class="line">(Return (Add_TT&lt;int&gt; (Ref2Value_TT&lt;int&gt; (GetArgumentRef #0)) (Ref2Value_TT&lt;int&gt; (GetArgumentRef #1))))</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; оптимизированная версия, 2 ноды</span><br><span class="line">(Return (AddArgArg_TT&lt;int&gt; #0 #1))</span><br></pre></td></tr></table></figure><p>Резюмируя — на скорость в режиме симуляции тут влияют:</p><ul><li>линейное расположение в памяти</li><li>отсутствие оверхеда интерпретации байт-кода</li><li>быстрый интероп с хост-языком - отсутствие конвертации аргументов, быстрые вызовы функций</li><li>уменьшение количества нод - проходы оптимизации, специализированные и объединённые ноды</li></ul><p>В сумме это позволяет в режиме интерпретации (без jit, и aot) обогнать самые быстрые интерпретаторы байт-кода с jit-компиляцией.</p><p>Опционально ещё:</p><ul><li>возможность с помощью макросов обработать AST и изменить семантику объявлений для более оптимального расположения в памяти</li><li>переопределить для своих типов кастомный <code>simulate</code> для генерации кастомного быстрого кода для их обработки</li></ul><h2 id="daJIT"><a href="#daJIT" class="headerlink" title="daJIT"></a>daJIT</h2><p>Кроме режима интерпретации, daScript тоже немного умеет jit-титься:<br><a href="https://github.com/borisbat/dasXbyak" target="_blank" rel="noopener">dasXbyak</a> - для x84/x64<br><a href="https://github.com/borisbat/dasLLVM" target="_blank" rel="noopener">dasLLVM</a> - для всего что может llvm (пока на начальной стадии)<br>jit-компиляция разрешена на PC/Unix/Mac/Web, запрещена на телефонах и консолях (везде, где разрешен запуск только подписанного кода)</p><p>А также хорошо AoT транспилироваться в C++-код. Перегонка “руками”:<br><code>daScript.exe -aot test.das test.das.cpp</code><br>или на уровне <a href="https://github.com/GaijinEntertainment/daScript/blob/master/examples/tutorial/CMakeLists.txt#L36" target="_blank" rel="noopener">cmake сборки</a>, настройки AoT кастомизируется на уровне отдельных модулей, функций и типов.<br><a href="/blog/1160489034/" title="daScript in imaginery world">daScript in imaginery world</a> - немного про прирост скорости от AoT-прекомпиляции. В отличие от jit, этим можно воспользоваться на всех платформах.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Устройство виртуальных машин для самых быстрых скриптовых языков — &lt;a href=&quot;https://luajit.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;lua-jit&lt;/a&gt; и &lt;a href=&quot;https://dascript.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;daScript&lt;/a&gt;.&lt;br&gt;Более развёрнутое продолжение беглой заметки &lt;a href=&quot;/blog/1067581840/&quot; title=&quot;daScript - скорость&quot;&gt;daScript - скорость&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="lua" scheme="http://spiiin.github.io/tags/lua/"/>
    
      <category term="dascript" scheme="http://spiiin.github.io/tags/dascript/"/>
    
  </entry>
  
  <entry>
    <title>Важность простых языков</title>
    <link href="http://spiiin.github.io/blog/3121981810/"/>
    <id>http://spiiin.github.io/blog/3121981810/</id>
    <published>2022-10-09T16:52:06.000Z</published>
    <updated>2022-10-09T21:44:57.290Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Про важность использования простых языков в геймдеве и не только.</p><a id="more"></a><p><a href="https://kristoff.it/blog/why-go-and-not-rust/" target="_blank" rel="noopener">Why Go and not Rust?</a> - статья вообще про преимущества простого go перед более сложным rust в блоге про zig :) Но в ней есть развернутый ответ на вопрос “почему обычно в корпоративном мире качество кода оставляет желать лучшего. В мире геймдева (там где я видел, во всяком случае), ситуация такая же — длительные в разработке проекты с большим количеством кода и широкой предметной областью, в которой эксперты предметной области слабо разбираются в технологии, а программисты — в особенностях предметной области, поэтому необходим <em>процесс</em>.</p><h2 id="Процесс"><a href="#Процесс" class="headerlink" title="Процесс"></a>Процесс</h2><p>Разработка больших систем — это всегда про масштаб. Понятие масштаба касается не количества данных или пользователей, а количества фич (scope) и процесса разработки. Опыт масштабирования как его понимают программисты часто неприменим к такому типу сложности, нетехнические трудности перевешивают технические.</p><p>Чтобы разобраться с масштабированием, менеджеры пытаются настроить процесс разработки, и привлекают экспертов и аналитиков, которые “знают как правильно” побороть сложности масштабирования.</p><p>Ссылки про “процессы” в геймдеве:<br><a href="https://sim0nsays.livejournal.com/38168.html" target="_blank" rel="noopener">Древние логи из IRC</a>, про то, как в геймдеве в принципе приходили к тому, чтобы разработка стала хоть как-то предсказуемее (если не ошибаюсь, обсуждается <code>Midway</code>).<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[09:17] &lt;look4awhile&gt; когда технические сложности - это всего-лишь технические сложности</span><br><span class="line">[09:17] &lt;look4awhile&gt; а оценивается работа продюсера</span><br><span class="line">[09:18] &lt;look4awhile&gt; наглядный пример, из последнего - дум-3.</span><br></pre></td></tr></table></figure><br>При этом забавно, что описанный там подход, начало 2000х — как будто попытка адаптировать к геймдеву методы, разработанные еще в 80х.</p><p><a href="/blog/1687824628/" title="Паттерны организации разработки уровней игр">Паттерны организации разработки уровней игр</a> — мои попытки обнаружить интересные идеи среди принятых сейчас Agile/Lean подходов.</p><p>Из этого взаимодействия бизнеса/управления/команды возникает несколько хорошо известных “причуд” корпоративной разработки.</p><h2 id="Джуниоры"><a href="#Джуниоры" class="headerlink" title="Джуниоры"></a>Джуниоры</h2><p>В командах всегда много джуниоров, которые учатся программировать на работе. И большинству из них не повезло найти работу, где они действительно могут научиться полезным практикам. Код больших систем далёк от того, что они видели в универе, или в своих в своих пет-проджектах.</p><p>Бывает, что джуниор вынужден реализовывать фичу, вообще впервые сталкиваясь с какой-либо технологией. Примеры из мобильной разработки — интеграция sdk с использованием нативных языков (java/kotlin/obj c/swift) в C++ код, программирование на gpu, скриптовые языки.</p><h2 id="Код-быстро-становится-запутанным"><a href="#Код-быстро-становится-запутанным" class="headerlink" title="Код быстро становится запутанным"></a>Код быстро становится запутанным</h2><p>Причин множество.</p><p>Для создания сложных систем требуется время, за которое приходят и уходят разработчики или целые команды. Постоянно рефакторить или переписывать код невозможно, так как время на разработку сильно ограниченно, так что разные части системы всегда будут находиться в очень разном состоянии по качеству и стилю кода.</p><p>Команды, работающие независимо, неизбежно будут создавать избыточный код.</p><p>Из-за сжатых сроков также кривой код попадает в релиз. “Когда-нибудь перепишем”.</p><p>С течением времени предметная область меняется, что неизбежно делает недействительными старые предположения и, следовательно, приводит к утечке абстракций. Чем сложнее абстракция, тем выше риск того, что она станет проблемой, когда гейм-дизайнер вернется с серьезным запросом на изменение. Проект никогда не может быть достаточно гибким, чтобы учесть все возможные пожелания и фантазии. Бизнес может прийти с запросами вроде “ситуация на рынке изменилась, меняем жанр/платформу/удваиваем количество фич”.</p><h2 id="Пайплайн-устаревший-жуткий"><a href="#Пайплайн-устаревший-жуткий" class="headerlink" title="Пайплайн устаревший/жуткий"></a>Пайплайн устаревший/жуткий</h2><p>Большое количество старого кода привязывает к определенным подходам, серьёзные технологические решения по улучшению принимать сложно, и не все менеджеры готовы вообще на это идти. Многие избегают рисков, результате чего происходят попытки копирования действий успешных конкурентов (или того, что, по утверджениям аналитиков, делают успешные конкуренты).</p><h2 id="Что-с-этим-делать"><a href="#Что-с-этим-делать" class="headerlink" title="Что с этим делать"></a>Что с этим делать</h2><p>Что может предоставить язык программирования, чтобы бороться с перечисленными проблемами?</p><p>Краткий ответ — быть максимально <strong>простым</strong> (только не примитивным, а именно незапутанным), <strong>гибким</strong> (не настраиваемым на все случаи жизни, а готовым к быстрым изменениям), и позволяющим мгновенно <strong>проверять гипотезы</strong>. </p><p>Именно возможность писать код так, чтобы он соответствовал этим критериям стоит использовать при сравнении языков между собой — они влияют на конечную продуктивность команды (продуктивность это не просто скорость, с которой можно делать фичи, а способность сделать продукт, который будет приносить деньги). Язык стимулирует писать код определенным способом — и этот способ может быть общепринятым для одного языка, но контр-интуитивным для другого. </p><p>Идти “против языка” при этом достаточно сложно в перспективе. Как в рамках одного проекта, так и распространяя паттерны работы — создание библиотек/тулзов/общепринятных подходов к разработке. Несколько случайных примеров не прижившихся или экспериментальных идей на C++ из русского геймдева (это не какие-то особенно продвинутые идеи, просто как пример подхода “против языка”, отчасти не прижившихся из-за необычности, отчасти из-за того, что это “не касается” языка, не выразимо на языке == будет отброшено, программист навряд ли наткнётся на такие подхода, если будет искать “как реализовать XXX”; старые ссылки выбраны отчасти потому, что я видел развитие каких-то из этих идей в движках, отчасти потому что, в современной геймдев культуре менее принято делиться интересными подходами, во всяком случае, если мониторить конференции и доклады, отчасти потому, что сохранились в коллекции ссылок):<br><a href="https://gamedev.ru/code/articles/?id=4234" target="_blank" rel="noopener">Compile-time vs run-time: назад в будущее</a> — генерация кода из данных в “build-time”<br><a href="https://sim0nsays.livejournal.com/27342.html" target="_blank" rel="noopener">Component-oriented design на консолях, лобзиком по шаблонам</a> — распиливание классов на компоненты на шаблонах<br><a href="https://plakhov.livejournal.com/201698.html" target="_blank" rel="noopener">Data structures baking</a> — чтение структур языка с диска без кода инициализации (еще <a href="https://probablydance.com/2015/12/19/quickly-loading-things-from-disk/" target="_blank" rel="noopener">пара</a> <a href="https://www.gamedeveloper.com/programming/delicious-data-baking" target="_blank" rel="noopener">ссылок</a>)<br><a href="https://plakhov.livejournal.com/101443.html" target="_blank" rel="noopener">Дзен-3, скрипт</a> — триггеры с минимальным функционалом вместо скриптов, создание минимального интерпретатора dsl на стороне игры. Хех, ну и почти <a href="https://twitter.com/YarKravtsov/status/1566004371044827137" target="_blank" rel="noopener">блюпринты</a> в движке SkyForge</p><p>При этом, почти любые современные языки дают возможность писать код, используя различныме парадигмы, так что команда должна уметь использовать язык именно так, чтобы эти свойства реально проявлялись.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Про важность использования простых языков в геймдеве и не только.&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="dev_method" scheme="http://spiiin.github.io/tags/dev-method/"/>
    
  </entry>
  
  <entry>
    <title>LLVM - обзор</title>
    <link href="http://spiiin.github.io/blog/315556844/"/>
    <id>http://spiiin.github.io/blog/315556844/</id>
    <published>2022-10-09T12:41:32.000Z</published>
    <updated>2022-10-09T14:58:55.395Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Попытка очень бегло пройтись по тому, что можно найти в LLVM.<br><a id="more"></a></p><h2 id="Инфраструктура-для-авторов-языков-программирования"><a href="#Инфраструктура-для-авторов-языков-программирования" class="headerlink" title="Инфраструктура для авторов языков программирования"></a>Инфраструктура для авторов языков программирования</h2><p>LLVM - это огромный проект. Чаще всего, когда говорят о нём - имеют ввиду возможность написать только фронтэнд для какого-нибудь языка - из языка в биткод llvm. Дальше автоматом можно получить следующие стадии трансформации: из <code>ir llvm -&gt; оптимизации различные -&gt;mir под конкретные платформы -&gt; бинарный код под платформы</code>.</p><p>Биткод может быть представлен в 3х формах: текстовый псевдоассемблер, бинарный формат, и in-memory api, с помощью которого можно нагенерить всё с помощью кода, в том числе сделать jit-компилятор.</p><p>В теории, jit быстрее статической компиляции, потому что:</p><ul><li>может задействовать динамические данные о том, какой код “горячее” (статическому компилятору тоже можно передать эту инфу, полученную уже после запуска приложения, при повторной компиляции/линковке)</li><li>может инлайнить больше, чем статический - например, библиотечные функции, которые иначе нельзя</li><li>может подстроиться под особенностью архитектуры или ос</li></ul><p>Java vm, .net или js-двики чаще всего jit так или иначе делают, быстрые версии интерпретаторов тоже. Jit-компиляция большая отдельная тема.<br><a href="https://github.com/borisbat/dasLLVM" target="_blank" rel="noopener">dasLLVM</a> — пример jit-компиляции из <a href="https://spiiin.github.io/tags/dascript/">daScript</a> на LLVM, пока на начальной стадии.</p><p>Если хочется погрузиться в теорию компиляции, можно читать что-нибудь типа:</p><ul><li>Learn LLVM 12</li><li>Классическую “Компиляторы: принципы, технологии и инструменты”</li><li><a href="http://craftinginterpreters.com/" target="_blank" rel="noopener">Crafting Interpreters</a></li></ul><p>Последняя интересна тем, что нацелена на практику, от автора <code>Game Programming Patterns</code>, а также нескольких скриптовых языков: <a href="https://wren.io/" target="_blank" rel="noopener">wren</a>, <a href="https://magpie-lang.org/" target="_blank" rel="noopener">magpie</a>. В его блоге также много <a href="https://journal.stuffwithstuff.com/category/language/" target="_blank" rel="noopener">статей</a> об устройстве языков программирования. В третьей части много продвинутого материала об оптимизации вызовов функций, замыканий и методам ускорения интерпретатора байт кода.</p><p>Несколько нестандартных применений:</p><ul><li><a href="https://andrewkelley.me/post/jamulator.html" target="_blank" rel="noopener">Statically Recompiling NES Games into Native Executables with LLVM and Go</a> - попытка перекомпилировать байт-код для NES в LLVM-биткод, без эмуляции от автора языка <code>Zig</code>, не очень успешная, так как в NES ассемблере очень много трюков, которые требуют реальной эмуляции особенностей железа (синхронизация с процессором, прыжки в середину инструкции, самомодифицирующийся код).</li><li>“Компиляция данных” — создание микроязыков для того, чтобы добавить возможность “положить” в игровые ресурсы код.</li></ul><p><a href="https://www.youtube.com/watch?v=3QQuhL-dSys" target="_blank" rel="noopener">2019 LLVM Developers’ Meeting: J. Paquette &amp; F. Hahn “Getting Started With LLVM: Basics”</a> — доклад про IR LLVM<br><a href="https://llvm.org/docs/WritingAnLLVMPass.html" target="_blank" rel="noopener">Writing an LLVM Pass</a> — как написать свой проход LLVM</p><h2 id="Clang-фронтэнд-компилятор-C"><a href="#Clang-фронтэнд-компилятор-C" class="headerlink" title="Clang - фронтэнд компилятор C++"></a>Clang - фронтэнд компилятор C++</h2><p>Отдельный проект — фронтэнд для С++ (а также С и  Objective C/C++) - <code>clang</code>. Собственно, у него есть несколько ключей, чтобы получать промежуточные представления кода, но это тоже прикладным разработчикам не особо надо чаще всего. Один из вариантов его использования - написание своих проходов при компиляции. Cобирается плагин в dll/dylib/a и компилятору clang ключом передаётся, чтобы он дёргал функции-колбека из этого плагина при каждой компиляции кода.</p><p>Apple в xcode clang не совсем из стандартной репы собирала, поэтому он у них с такими плагинами не работает, но в принципе пересобрав самому из исходников можно и им под ios код генерить. Вот <a href="https://railsware.com/blog/creation-and-using-clang-plugin-with-xcode/" target="_blank" rel="noopener">“hello world”</a> с плагинами. Таким способом можно решать что-то типа “хочу, чтобы если в лямбду кто-то захватил this неявно, то компиляция крешилась с сообщением, потому что в половине случаев автор забыл проверить время жизни this и упадёт в рантайме” (или другие правила, обычно написанные кровью в code convention проекта, которые невозможно выразить семантикой C++).</p><p>Так редко кто делает, но вот примеры проектов с набором плагинов, дополнительно проверяющих код:<br><a href="https://github.com/LibreOffice/core/tree/master/compilerplugins/clang" target="_blank" rel="noopener">libreoffice</a><br><a href="https://chromium.googlesource.com/chromium/src.git/+/master/docs/clang.md#using-plugins" target="_blank" rel="noopener">chrome</a> + <a href="https://ehsanakhgari.org/blog/2015-12-07/c-static-analysis-using-clang/" target="_blank" rel="noopener">Статья</a><br><a href="https://hg.mozilla.org/mozilla-central/file/tip/build/clang-plugin/" target="_blank" rel="noopener">firefox</a></p><p>Более основательный туториал про то, как писать плагины, и что с их помощью можно делать<br><a href="https://github.com/banach-space/llvm-tutor" target="_blank" rel="noopener">https://github.com/banach-space/llvm-tutor</a></p><h2 id="API-для-работы-с-Clang"><a href="#API-для-работы-с-Clang" class="headerlink" title="API для работы с Clang"></a>API для работы с Clang</h2><p>Особенность компилятора Clang — он предоставляет несколько API для того, чтобы можно было получать информацию о коде программы.</p><p>К примеру, можно пропарсить заголовочный файлы и автоматом нагенерить привязок к другим языкам. Из особенностей - не очень быстро работает (поэтому некоторые предпочитают велосипедить свои парсеры, передавая мета-информацию комментариями), и не очень хорошо работает с сложным шаблонным кодом. Но в целом можно целиком какую-нибудь либу привязать им к другому языку с небольшим количеством ручной работы.</p><p>Один из интерфейсов - <code>libclang</code>, библиотека на C++, к которой есть привязки на других языках.</p><p>Примеры использования <strong><code>генерации привязок</code></strong>:<br><a href="/blog/4090909622/" title="daScript: C++ auto-bindings, msgpack">daScript: C++ auto-bindings, msgpack</a> — генерация из daScript привязок к <code>msgpack</code><br><a href="/blog/500729544/" title="daScript: C++ auto-bindings, assimp">daScript: C++ auto-bindings, assimp</a> — генерация из daScript привязок к <code>assimp</code>, без написания кода (почти)<br>(с помощью <a href="https://github.com/GaijinEntertainment/daScript/tree/master/modules/dasClangBind" target="_blank" rel="noopener">dasClangBind</a>)<br><a href="https://floooh.github.io/2020/08/23/sokol-bindgen.html" target="_blank" rel="noopener">Automatic Language Bindings</a> — генерация из Python привязок к <code>solol</code> для различных языков (zig/nim/odin)</p><p><strong><code>Интерактивное получение данных из кода</code></strong><br><a href="https://root.cern/cling/" target="_blank" rel="noopener">Cling</a> - интерактивная комплиляция С++ кода, для использования с инструментами типа <code>Jupyter</code><br><a href="https://cppyy.readthedocs.io/en/latest/examples.html" target="_blank" rel="noopener">cppyy</a> - привязка cling к python, работает в том числе и под windows</p><p><strong><code>Написание тулзов для IDE</code></strong><br><a href="https://github.com/def-/ycmd" target="_blank" rel="noopener">ycmd</a> - сервер автодополнения кода для различных IDE<br><a href="https://marketplace.visualstudio.com/items?itemName=RamonViladomat.StructLayout" target="_blank" rel="noopener">StructLayout</a> - расширение для VS code, которое может показать то, как компилятор будет размещать структуру в памяти (надо помнить, что libclang, который использует это расширение, должен быть той же версии, что и сам компилятор, который будет генерировать код).</p><p>Можно также решать всякие задачи вроде “отсортировать функции по количеству байт и напечатать 10 самых больших”.</p><p><strong><code>Туториалы, как научиться пользоваться</code></strong><br><a href="https://jonasdevlieghere.com/understanding-the-clang-ast/" target="_blank" rel="noopener">Understanding the Clang AST</a> - 3 API для работы с AST в clang<br><a href="https://clang.llvm.org/docs/IntroductionToTheClangAST.html" target="_blank" rel="noopener">Introduction to the Clang AST</a> - ссылки на диаграммы классов AST, во что трансформируется код на C++<br><a href="https://clang.llvm.org/docs/RAVFrontendAction.html" target="_blank" rel="noopener">How to write RecursiveASTVisitor based ASTFrontendActions</a> - пример того, как сделать свой визитор для AST<br><a href="https://clang.llvm.org/docs/LibASTMatchersTutorial.html" target="_blank" rel="noopener">Tutorial for building tools using LibTooling and LibASTMatchers</a> - использование других интерфейсов для написания визиторов<br><a href="https://www.youtube.com/watch?v=VqCkCDFLSsc" target="_blank" rel="noopener">The Clang AST - a Tutorial</a> - доклад всё про то же<br><a href="http://www.goldsborough.me/c++/clang/llvm/tools/2017/02/24/00-00-06-emitting_diagnostics_and_fixithints_in_clang_tools/" target="_blank" rel="noopener">Emitting Diagnostics in Clang</a> — вывод своих сообщений об ошибках</p><p>В каком-то смысле, интерфейс для того, чтобы иметь доступ к AST языка, необходим из-за того, что этого не умеет сам C++ - шаблоны умеют заставить компилятор произвести эффекты, но не имеют доступа к самому коду. В языках вроде <code>daScript</code> аналогичную плагинам компилятора работы могут выполнять макросы.<br><a href="https://github.com/GaijinEntertainment/daScript/blob/master/daslib/jobque_boost.das#L142" target="_blank" rel="noopener">Пример</a> макроса в daScript, применяемого к замыканию и выполняющего дополнительную работу, если в замыкание передаются примитивы синхронизации <code>Channel</code> или <code>Job</code>.<br><a href="/blog/1547564887/" title="daScript macro">daScript macro</a> — пример генерации AST daScript из кода<br><a href="/blog/4046309382/" title="daScript macro - 2">daScript macro - 2</a> — пример работы с DSL, упрощающим написание AST</p><p>Также, для Clang, чтобы упростить работу с C++ AST, существует DSL для составления запросов - <strong><code>clang query</code></strong><br><a href="https://www.youtube.com/watch?v=yqi8U8Q0h2g" target="_blank" rel="noopener">2019 EuroLLVM Developers’ Meeting: S. Kelly “The Future of AST Matcher-based Refactoring</a> - использование запросов clang query для визуальной работы с кодом, расширение godbolt + интерфейс к qt контролам<br><a href="https://www.youtube.com/watch?v=38tYYrnfNrs" target="_blank" rel="noopener">Extending clang-tidy in the Present and in the Future - Stephen Kelly</a> - и для модификации кода/рефакторинга</p><p>Ещё один способ использования — глубже изучить, как устроена какая-либо абстракция в языке<br><a href="https://www.youtube.com/watch?v=8C8NnE1Dg4A" target="_blank" rel="noopener">CppCon 2016: Gor Nishanov “C++ Coroutines: Under the covers”</a> — реализация корутин в новом стандарте C++<br><a href="https://llvm.org/docs/LangRef.html" target="_blank" rel="noopener">LLVM Language Reference Manual</a> - справка по псевдо-ассемблеру LLVM</p><h2 id="Исходный-код-и-архитектура-LLVM"><a href="#Исходный-код-и-архитектура-LLVM" class="headerlink" title="Исходный код и архитектура LLVM"></a>Исходный код и архитектура LLVM</h2><p><a href="http://rus-linux.net/MyLDP/BOOKS/Architecture-Open-Source-Applications/Vol-1/llvm.html" target="_blank" rel="noopener">Глава в книге “Архитектура приложений с открытым исходным кодом”</a><br><a href="https://blog.regehr.org/archives/1453" target="_blank" rel="noopener">A Tourist’s Guide to the LLVM Source Code</a> - обзор исходников<br><a href="https://llvm.org/docs/ProgrammersManual.html" target="_blank" rel="noopener">Обзор используемых структур данных</a> + <a href="https://llvm.org/devmtg/2014-04/PDFs/LightningTalks/data_structure_llvm.pdf" target="_blank" rel="noopener">Ещё один</a></p><h2 id="LLDB"><a href="#LLDB" class="headerlink" title="LLDB"></a>LLDB</h2><p>Отладчик, также использующий инфраструктуру llvm. Одна из интересных возможностей — наличие <a href="https://lldb.llvm.org/python_reference/" target="_blank" rel="noopener">python api</a>.</p><p>Пример использования API:<br><a href="/blog/1170009669/" title="Расположение объектов C++ в памяти. Часть 2">Расположение объектов C++ в памяти. Часть 2</a> — рекурсивный обход структур, для запроса из отладчика выравнивания их в памяти, с отображением “дырок”</p><h2 id="Общие-ссылки"><a href="#Общие-ссылки" class="headerlink" title="Общие ссылки"></a>Общие ссылки</h2><p><a href="https://llvm.org/devmtg/" target="_blank" rel="noopener">https://llvm.org/devmtg/</a> + <a href="https://www.youtube.com/c/LLVMPROJ/playlists" target="_blank" rel="noopener">https://www.youtube.com/c/LLVMPROJ/playlists</a><br><a href="https://blog.llvm.org/" target="_blank" rel="noopener">https://blog.llvm.org/</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Попытка очень бегло пройтись по тому, что можно найти в LLVM.&lt;br&gt;
    
    </summary>
    
    
    
      <category term="dev" scheme="http://spiiin.github.io/tags/dev/"/>
    
      <category term="dascript" scheme="http://spiiin.github.io/tags/dascript/"/>
    
      <category term="cpp" scheme="http://spiiin.github.io/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>Git. ссылки</title>
    <link href="http://spiiin.github.io/blog/1186660544/"/>
    <id>http://spiiin.github.io/blog/1186660544/</id>
    <published>2022-09-29T19:04:35.000Z</published>
    <updated>2022-09-29T19:10:22.235Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Различные доки по git<br><a id="more"></a><br>  <a href="https://fabiensanglard.net/git_code_review/index.php" target="_blank" rel="noopener">https://fabiensanglard.net/git_code_review/index.php</a> - коллекция доков по гиту<br>  <a href="https://learngitbranching.js.org/?locale=ru_RU&amp;demo=" target="_blank" rel="noopener">https://learngitbranching.js.org/?locale=ru_RU&amp;demo=</a> - игра-практика<br>  <a href="https://github.com/pluralsight/git-internals-pdf/releases" target="_blank" rel="noopener">https://github.com/pluralsight/git-internals-pdf/releases</a> - книжка git internals<br>  <a href="https://gitimmersion.com/index.html" target="_blank" rel="noopener">https://gitimmersion.com/index.html</a> - практические команды<br>  <a href="http://marklodato.github.io/visual-git-guide/index-en.html" target="_blank" rel="noopener">http://marklodato.github.io/visual-git-guide/index-en.html</a> - туториал с картинками<br>  <a href="https://www.atlassian.com/git/tutorials" target="_blank" rel="noopener">https://www.atlassian.com/git/tutorials</a> - набор туториалов, advanced<br>  <a href="https://git-scm.com/book/en/v2" target="_blank" rel="noopener">https://git-scm.com/book/en/v2</a> - Pro Git ещё одна книжка</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Различные доки по git&lt;br&gt;
    
    </summary>
    
    
    
      <category term="dev" scheme="http://spiiin.github.io/tags/dev/"/>
    
      <category term="link" scheme="http://spiiin.github.io/tags/link/"/>
    
  </entry>
  
  <entry>
    <title>Файберы, диспетчеры, асинки</title>
    <link href="http://spiiin.github.io/blog/2826376146/"/>
    <id>http://spiiin.github.io/blog/2826376146/</id>
    <published>2022-09-04T16:11:33.000Z</published>
    <updated>2022-09-17T08:39:03.174Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><a href="/blog/2550823652/" title="Итераторы, колстеки, корутины">Итераторы, колстеки, корутины</a> -- первая часть статьи про итераторы и асинхронное программирование. В ней были перечислены особенности абстракций обхода коллекций в нескольких языках, а также описана связь между ними и возобновляемыми функциями. В конце статьи рассмотрено представление возобновляемых функций в различных языках и различная терминология для их обозначений. Дальше можно постепенно перейти к способам управления этими функциями.<a id="more"></a><h2 id="Ссылки"><a href="#Ссылки" class="headerlink" title="Ссылки"></a>Ссылки</h2><p>(также см. ссылки из первой статьи)<br>[1] Иван Чукич - Функциональное программирование на C++ — глава 7 Диапазоны<br>[2] Alex Davies - Async in C# 5.0<br>[3] <a href="https://www.researchgate.net/publication/220802950_The_F_Asynchronous_Programming_Model" target="_blank" rel="noopener">Don Syme - F Asynchronous Programming Model</a><br>[4] <a href="http://www.kegel.com/c10k.html" target="_blank" rel="noopener">The C10K problem</a><br>[5] <a href="https://www.youtube.com/watch?v=i0RB7UqxERE" target="_blank" rel="noopener">Async await in Nim A demonstration of the flexibility metaprogramming can bring to a language</a>. Еще несколько ссылок про async в Nim - <a href="https://nim-lang.org/blog/2014/04/21/version-094-released.html" target="_blank" rel="noopener">1</a>, <a href="https://nim-lang.org/docs/asyncdispatch.html" target="_blank" rel="noopener">2</a>, <a href="https://peterme.net/asynchronous-programming-in-nim.html" target="_blank" rel="noopener">3</a><br>[6] <a href="https://cpratt.co/async-tips-tricks/" target="_blank" rel="noopener">C# async tips and tricks</a> -  sequence tasks vs parallel. Tasks return “hot”<br>[7] <a href="https://docs.python.org/3/library/asyncio-task.html" target="_blank" rel="noopener">Python asyncio-task</a><br>[8] <a href="https://www.youtube.com/watch?v=OE45F3iKtv4" target="_blank" rel="noopener">Павел Новиков — Учимся готовить C++ корутины на практике</a><br>[9] <a href="https://developer.apple.com/videos/play/wwdc2021/10132/" target="_blank" rel="noopener">Meet async/await in Swift</a><br>[10] <a href="https://marek-g.github.io/posts/projects/archive/nemerle_async_await/" target="_blank" rel="noopener">Nemerle macro async/await</a>, еще одна реализация через <a href="https://habr.com/ru/post/108184/" target="_blank" rel="noopener">монады</a><br>[11] <a href="https://www.youtube.com/watch?v=yJxFPoxqzWE" target="_blank" rel="noopener">“Clojure core.async” by Rich Hickey (2013)</a><br>[12] <a href="http://hueypetersen.com/posts/2013/08/02/the-state-machines-of-core-async/" target="_blank" rel="noopener">The State Machines of core.async</a><br>[13] <a href="https://www.youtube.com/watch?v=R3PZMIwXN_g" target="_blank" rel="noopener">Core Async Go Macro Internals - Part I</a> - реализация goroutine-макроса в closure<br>[14] <a href="https://github.com/scylladb/seastar/blob/master/doc/tutorial.md" target="_blank" rel="noopener">Scylla DB Tutorial</a> - туториал по библиотеке c++, интенсивно использующий корутины. Еще больше статей - <a href="https://www.scylladb.com/2020/03/26/avi-kivity-at-core-c-2019/" target="_blank" rel="noopener">1</a>, <a href="https://www.scylladb.com/2020/05/05/how-io_uring-and-ebpf-will-revolutionize-programming-in-linux/" target="_blank" rel="noopener">2</a></p><h2 id="Асинхронность"><a href="#Асинхронность" class="headerlink" title="Асинхронность"></a>Асинхронность</h2><p>Если рассматривать итераторы как абстракцию способов обхода коллекции, то в первую очередь они напоминают “умный” индекс в коллекции, который может пропускать какие-либо элементы, менять направление, или даже управляться элементами самой коллекции (например, можно описать вектором цепь Маркова, и сделать итератор, который реализует переключение состояний в этой цепи).</p><p>Есть ещё одно важное свойство отделения итерации от вызывающего её кода — на момент запроса следующего элемента коллекции сама коллекция не обязана существовать целиком. Процесс создания следующих элементов коллекции может быть описан в виде функции — коллекция всех натуральных чисел, передача запроса на получение элемента из файла/от внешнего устройства/по сети (само чтение данных может происходит в других потоках, которые каким-либо образом вернут данные итератору).</p><h2 id="Описание-коллекции-в-виде-функции"><a href="#Описание-коллекции-в-виде-функции" class="headerlink" title="Описание коллекции в виде функции"></a>Описание коллекции в виде функции</h2><p>Простейший пример на <code>daScript</code> — бесконечная коллекция натуральных чисел, заданная в виде генератора:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var natural &lt;- generator&lt;<span class="keyword">int</span>&gt;() &lt;| $()</span><br><span class="line">  var i = <span class="number">1</span></span><br><span class="line">  <span class="keyword">while</span> <span class="literal">true</span></span><br><span class="line">    yield i</span><br><span class="line">    i++</span><br></pre></td></tr></table></figure></p><p>Мы не можем использовать её в цикле foreach напрямую, потому что этот цикл пытается пройти по всем элементам коллекции. Но можно сделать другой генератор, который возьмёт несколько элементов из бесконечной коллекции и остановится.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">take</span><span class="params">(var src:iterator&lt;<span class="keyword">auto</span>(TT)&gt;; count:<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">  unsafe</span></span><br><span class="line">    var gen &lt;- generator&lt;TT&gt;() &lt;| $()</span><br><span class="line">      var aValue : TT-&amp;</span><br><span class="line">      <span class="function"><span class="keyword">for</span> i in <span class="title">range</span><span class="params">(count)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">if</span> <span class="title">next</span><span class="params">(src, aValue)</span></span></span><br><span class="line"><span class="function">          yield aValue</span></span><br><span class="line"><span class="function">        <span class="keyword">else</span></span></span><br><span class="line"><span class="function">          <span class="keyword">return</span> <span class="literal">false</span></span></span><br><span class="line"><span class="function">      <span class="keyword">return</span> <span class="literal">false</span></span></span><br><span class="line">    return &lt;-gen</span><br><span class="line"><span class="keyword">for</span> num in natural |&gt; take(<span class="number">3</span>)</span><br><span class="line">  print(<span class="string">"&#123;num&#125; "</span>)</span><br><span class="line"><span class="comment">//Output: "1 2 3"</span></span><br></pre></td></tr></table></figure><h2 id="Композиция-функций-и-ленивые-вычисления"><a href="#Композиция-функций-и-ленивые-вычисления" class="headerlink" title="Композиция функций и ленивые вычисления"></a>Композиция функций и ленивые вычисления</h2><p>Попробуем “просеять” натуральные числа, оставив только простые. Пример реализации функции <a href="https://github.com/spiiin/dascript_macro_tutorial/blob/master/primes/primes_mix_compile_runtime.das" target="_blank" rel="noopener">prime</a> (самая быстрая реализация, без учёта потребляемой памяти — просто посчитать первые n чисел заранее в compile-time :) ).</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> num in natural |&gt; filter(@@is_prime) |&gt; take(<span class="number">10</span>)</span><br><span class="line">  print(<span class="string">"&#123;num&#125; "</span>)</span><br><span class="line"><span class="comment">//Output: 2, 3, 5, 7, 11, 13, 17, 19, 23, 29</span></span><br></pre></td></tr></table></figure><p>Можно заметить, что не существует вычисленной промежуточной коллекции <code>natural |&gt; filter(@@is_prime)</code>, которая представляла бы собой бесконечный список всех простых чисел). Вычисление следующего элемента коллекции, описанного композицией этих функций, вычисляется только по запросу этого элемента или <strong>лениво</strong> (lazy) — <code>take</code> запрашивает следующий элемент из <code>filter</code>, которая может запросить и вычислить один или несколько элементов из коллекции <code>natural</code>.</p><p>Если попробовать реализовать такую композицию на C++ с помощью итераторов и алгоритмов STL, окажется, что они не годятся для этого, функция <a href="https://en.cppreference.com/w/cpp/algorithm/copy" target="_blank" rel="noopener">std::copy_if</a>, с помощью которой можно было бы провести фильтр элементов, ожидает на вход итераторы <strong>существующей</strong> коллекции, что требует создания временной копии и её заполнения элементами. Но вместо итераторов можно воспользоваться библиотекой <code>ranges</code> - <a href="https://en.cppreference.com/w/cpp/algorithm/ranges/copy" target="_blank" rel="noopener">стандарт C++20</a>, <a href="https://github.com/ericniebler/range-v3" target="_blank" rel="noopener">range-v3</a>, она позволяет строить ленивые итераторы (<code>std::views</code>) или инплейсно изменять коллекции (<code>std::actions</code>).</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::views;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : iota(<span class="number">1</span>) | filter(is_prime) | take(<span class="number">10</span>)) &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2 3 5 7 11 13 17 19 23 29</span></span><br></pre></td></tr></table></figure><h2 id="Коллекция-как-данные-из-внешнего-источника"><a href="#Коллекция-как-данные-из-внешнего-источника" class="headerlink" title="Коллекция как данные из внешнего источника"></a>Коллекция как данные из внешнего источника</h2><p>В отличие от всех предыдущих случаев, при получении данных от внешнего источника мы не всегда знаем когда именно данные будут получены, что приводит к следующей проблеме — что делать, если все данные готовые данные обработаны, а новых ещё нет? Как и с итераторами, возможны два основных подхода — либо вызывающий код регулярно опрашивает источник данных, есть ли новые данные для обработки, либо же источнику данных передаётся колбек, который будет вызван, когда появятся новые данные для обработки.</p><h2 id="Опрос-источника-данных"><a href="#Опрос-источника-данных" class="headerlink" title="Опрос источника данных"></a>Опрос источника данных</h2><p>Игрушечная симуляция длительно выполняющейся задачи — счётчик до 100, который позволяет информировать внешний код о прогрессе каждые 10 итераций<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> </span><br><span class="line">  ValueOrReady = variant&lt;value:<span class="keyword">int</span>; ready:<span class="keyword">bool</span>&gt;</span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line"><span class="function">def <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  <span class="comment">//создаём генератор, который может возвращать значение или флаг "значение не готово"</span></span></span><br><span class="line">  var gen &lt;- generator&lt;ValueOrReady&gt;() &lt;| $()</span><br><span class="line">    var i = <span class="number">1</span></span><br><span class="line">    var answer: ValueOrReady</span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="number">100</span></span><br><span class="line">      unsafe</span><br><span class="line">        <span class="comment">//каждый 10 шагов выдаём значение</span></span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">10</span> == <span class="number">0</span></span><br><span class="line">          answer = [[ValueOrReady value = i]]</span><br><span class="line">        <span class="comment">//иначе выдаём флаг "работа в процессе", данных пока нет</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          answer = [[ValueOrReady ready = <span class="literal">false</span>]]</span><br><span class="line">      yield answer</span><br><span class="line">      i++</span><br><span class="line">    <span class="comment">//задача выполнена</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> num in gen</span><br><span class="line">    unsafe</span><br><span class="line">      <span class="keyword">if</span> num is value</span><br><span class="line">        print(<span class="string">"&#123;num.value&#125; "</span>)</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        print(<span class="string">"x "</span>)</span><br><span class="line">  print(<span class="string">"\ndone"</span>)</span><br><span class="line"><span class="comment">//Output: x x x x x x x x x 10 x x x x x x x x x 20 x x x x x x x x x 30 x x x x x x x x x 40 x x x x x x x x x 50 x x x x x x x x x 60 x x x x x x x x x 70 x x x x x x x x x 80 x x x x x x x x x 90 x x x x x x x x x</span></span><br><span class="line"><span class="comment">//done</span></span><br></pre></td></tr></table></figure></p><p>Видно, что опрос генератор требует двух специальных флагов — выполнена ли задача полностью, и готовы ли данные. Для возврата признака, готовы ли данные, использован тип <code>variant&lt;value:int; ready:bool&gt;</code> (задача возвращает либо данные, либо флаг неготовности, но не их одновременно).</p><p>Вместо такой искусственной задержки генератор может совершать реальную работу — например опрос сокетов операционной системы, и предоставлять не результат, а интерфейс для чтения данных, когда они будут готовы (один из подходов к решению проблемы 10000 соединений к серверу [2])</p><p>Такое примитивное описание асинхронной выполняемой задачи оставляет сразу серию вопросов и возможных улучшений:</p><ul><li>пока что наш “опрос” источника внешних данных заключался в том, чтобы проверить какой-то флаг, выставляемый этим источником, в основном потоке. Реальное получение данных после того, как был получен сигнал о готовности, требует синхронизации при чтении данных из источника, что можно выразить в виде паттерна с использованием примитивов синхронизации.</li><li>в программе может существовать несколько выполняемых задач, ожидающих данных. Где-то может существовать диспетчер, опрашивающий все ожидающие задачи, чтобы не писать цикл их опроса вручную. Диспетчер может даже раскидывать выполнение задач на несколько потоков выполнения.</li><li>различные ожидающие задачи могут требовать результатов других ожидающих задач. Какие-то результаты могут потребоваться раньше, какие-то позже. Есть различные способы выражения того, что в конкретном месте выполнения программа должна дождаться данных от одной или нескольких подзадач.</li><li>если задача полностью зависит от внешнего источника, недоступного для управления из программы, логично предусмотреть возможность её завершения не дожидаясь окончания</li></ul><h2 id="Ожидание-колбеков"><a href="#Ожидание-колбеков" class="headerlink" title="Ожидание колбеков"></a>Ожидание колбеков</h2><p>Можно переписать задачу вычисления чисел так, чтобы она информировала вызывающий код о прогрессе сама (аналог внутреннего итератора):<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">makeLongCalculation</span><span class="params">(blk)</span></span></span><br><span class="line"><span class="function">  var i </span>= <span class="number">1</span></span><br><span class="line">  <span class="keyword">while</span> i &lt; <span class="number">100</span></span><br><span class="line">    unsafe</span><br><span class="line">      <span class="keyword">if</span> i % <span class="number">10</span> == <span class="number">0</span></span><br><span class="line">        invoke(blk, [[ValueOrReady value = i]], <span class="literal">false</span>)</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        invoke(blk, [[ValueOrReady ready = <span class="literal">false</span>]], <span class="literal">false</span>)</span><br><span class="line">    i++</span><br><span class="line">  invoke(blk, [[ValueOrReady ready = <span class="literal">false</span>]], <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//использование функции</span></span><br><span class="line">makeLongCalculation &lt;| $(num: ValueOrReady; done: <span class="keyword">bool</span>)</span><br><span class="line">  <span class="keyword">if</span> !done</span><br><span class="line">    unsafe</span><br><span class="line">      <span class="keyword">if</span> num is value</span><br><span class="line">        print(<span class="string">"&#123;num.value&#125; "</span>)</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        print(<span class="string">"x "</span>)</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    print(<span class="string">"\ndone"</span>)</span><br><span class="line"><span class="comment">//Output: x x x x x x x x x 10 x x x x x x x x x 20 x x x x x x x x x 30 x x x x x x x x x 40 x x x x x x x x x 50 x x x x x x x x x 60 x x x x x x x x x 70 x x x x x x x x x 80 x x x x x x x x x 90 x x x x x x x x x</span></span><br><span class="line"><span class="comment">//done</span></span><br></pre></td></tr></table></figure></p><p>Таким способом часто выглядят функции запроса данных по сети — в колбек приходит информация о массиве частично-скачанных данных, и флаги — ожидать ли ещё данных, и были ли ошибки.</p><p>Рассмотрим эволюцию паттернов работы с колбеками на примере .Net, в дань тому, что в F# и затем в C# впервые ушли от них к более свежим подходам. Microsoft в C# называет паттерны асинхронного вызова с использованием колбеков умными аббревиатурами <code>EAP</code> и <code>APM</code>. Примеры кода:</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//.NET 1, APM (Asynchronous Programming Model)</span></span><br><span class="line">file.BeginCall(buffer, <span class="number">0</span>, maxLength, asyncResult =&gt; &#123;</span><br><span class="line">  <span class="comment">//вызовется через какое-то время</span></span><br><span class="line">  <span class="keyword">int</span> numBytesRead = file.EndRead(asyncResult);</span><br><span class="line">&#125;, <span class="literal">null</span>)</span><br></pre></td></tr></table></figure><p>В некоторых вызовах неочевидно, в каком контексте будет вызван колбек (из какого потока, нужно ли синхронизироваться и передавать результат обратно в поток, в котором будет обработан результат)<br>Если же нужно из колбека вызвать еще несколько вложенных операций, получается колбек-хелл, с жутким синтаксисом и смутным представлением контекста выполнения каждого из колбеков.</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//.NET 2, APM (Asynchronous Programming Model)</span></span><br><span class="line">webClient.DownloadStringCompleted += (sender, args) =&gt; &#123;</span><br><span class="line">  <span class="keyword">string</span> html = args.Result;</span><br><span class="line">&#125;</span><br><span class="line">webClient.DownloadStringAsync(<span class="keyword">new</span> Uri(<span class="string">"http://example.com"</span>));</span><br></pre></td></tr></table></figure><p>Примерно то же самое, но с необходимостью явно оторвать колбек от вызова (и возможностью навесить несколько обработчиков) — чуть меньше “лесенок” в коде</p><h2 id="Future-async-await"><a href="#Future-async-await" class="headerlink" title="Future, async/await"></a>Future, async/await</h2><p>Future (или Task в C#) — обёртка для результата, которая запускает задачу, и возвращает управление вызывающему коду. Код сам может решить что ему делать с объектом задачи, когда остановиться, чтобы дождаться результата, или как скомбинировать полученный объект с другими задачами.</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//.NET 4</span></span><br><span class="line">Task&lt;<span class="keyword">string</span>&gt; htmlTask = webClient.DownloadStringTaskAsync(url);</span><br><span class="line"><span class="comment">//тот можно выполнить код, которому не требуется результат hmtlTask</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">string</span> html = htmlTask.Result; <span class="comment">//тут блокировка до ожидания результата</span></span><br><span class="line"><span class="comment">//или прикрепить к задаче продолжение</span></span><br><span class="line">htmlTask.ContinueWith(task=&gt; &#123;</span><br><span class="line">  <span class="keyword">string</span> html = task.Result;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Следующий шаг, сделанный в F# и перенятый в других языках — продвинутый синтаксический сахар, который позволяет записать <code>ContinueWith</code> не в виде лямбда-функции, а кодом, который выглядит, ка<br><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//.NET 5</span></span><br><span class="line">Task&lt;<span class="keyword">string</span>&gt; htmlTask = webClient.DownloadStringTaskAsync(url);</span><br><span class="line"><span class="keyword">string</span> html = <span class="keyword">await</span> htmlTask; <span class="comment">//то же что и в прошлом примере с ContinueWith</span></span><br><span class="line">doSomething(html)             <span class="comment">//строки ниже await также "переписываются" внутрь ContinueWith</span></span><br></pre></td></tr></table></figure></p><p>Другие языки с async/await в похожем виде адаптируют эти идеи из C#</p><ul><li>[5] - вкручивание их в Nim синтаксическими макросами.</li><li>[8] приводится пример разбора устройства Task в стандарте C++</li><li>[9] Swift. Достаточно подробное объяснение, тайминги<br>22:14 — трансформация кода на колбеках в async код<br>22:53 — про “цвета” функций<br>30:38 — continuation pattern cc/resume<br>32:19 — сохранение continuation %)</li><li>[10] Nemerle</li><li>[11] Closure, [12]<br> 8:24 C# async, linear code -&gt; callbacks + state machine, обзор подходов async и channel</li></ul><p>Проще говоря, <code>co_await</code> в C++ позволяет записать:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">task&lt;&gt; <span class="title">tcp_echo_server</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> data[<span class="number">1024</span>];</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> n = <span class="keyword">co_await</span> socket.async_read_some(buffer(data));</span><br><span class="line">    <span class="function"><span class="keyword">co_await</span> <span class="title">async_write</span><span class="params">(socket, buffer(data, n))</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"resended\n"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>вместо чего-то типа:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">socket.async_read_some(buffer(data)).continueWith([&amp;](<span class="keyword">auto</span> task)&#123;</span><br><span class="line">  n = task.result();</span><br><span class="line">  async_write(socket, buffer(data, n)).continueWith([&amp;](<span class="keyword">auto</span> task)&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"resended\n"</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>(специально не хочу вникать в особенности именно С++ реализации переписывания из-за её вырвиглазности, при желании можно покопаться в этом в [8]).</p><p>Можно рассматривать оператор <code>co_await</code> как возможность приостановить выполнение и “подписаться” на уведомление о завершении или приостановке выражения-аргумента.</p><p>Разбор некоторых проблем сочетания синхронных функций с асинхронными в статье <a href="http://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/" target="_blank" rel="noopener">What Color is Your Function?</a>. Библиотечные функции для синхронной и асинхронной работы “разных цветов”, и необходимо иметь 2 версии функций для того, чтобы вызывающий код мог выбирать из них (к примеру, синхронный <a href="https://github.com/redis/redis-py" target="_blank" rel="noopener">redispy</a> и его асихронный двойник <a href="https://github.com/aio-libs/aioredis-py" target="_blank" rel="noopener">aioredis</a>, или асинхронная копия <a href="https://pypi.org/project/asynctkinter/" target="_blank" rel="noopener">tkinter</a>, <a href="https://github.com/aio-libs" target="_blank" rel="noopener">десятки их</a>). Язык <code>Zig</code> кажется, один из немногих, в котором реализована поддержка универсальных бесцветных функций, которые могут работать синхронно или асинхронно, решение переносится на вызывающий кода (см ссылки [26], [27] в первой части статьи).</p><p>Интересно, насколько просто добавляются подобные операторы в языки с поддержкой синтаксических макросов. Например, модуль <a href="https://github.com/GaijinEntertainment/daScript/blob/138f625c7f95943341a5e96cca114ae7d0772ba6/daslib/coroutines.das" target="_blank" rel="noopener">coroutine</a> в <code>daScript</code>, реализующий макрос <code>co_await</code>, и примеры его использования <a href="https://github.com/GaijinEntertainment/daScript/blob/138f625c7f95943341a5e96cca114ae7d0772ba6/examples/test/misc/coroutines_example_2.das" target="_blank" rel="noopener">1</a> и <a href="https://github.com/GaijinEntertainment/daScript/blob/110bb4313fa479d7b837413700ed7f6c68601e24/examples/test/misc/coroutines_example.das" target="_blank" rel="noopener">2</a>.</p><p>Первый пример — последовательная передача управления между двумя функциями:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[coroutine]</span><br><span class="line"><span class="function">def <span class="title">subcr</span><span class="params">(name:<span class="built_in">string</span>)</span></span></span><br><span class="line"><span class="function">  <span class="title">print</span><span class="params">(<span class="string">"&#123;name&#125; sub 1\n"</span>)</span></span></span><br><span class="line"><span class="function">  <span class="title">co_continue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  <span class="title">print</span><span class="params">(<span class="string">"&#123;name&#125; sub 2\n"</span>)</span></span></span><br><span class="line"><span class="function">  <span class="title">co_continue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  <span class="title">print</span><span class="params">(<span class="string">"&#123;name&#125; sub 3\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">[coroutine]</span><br><span class="line"><span class="function">def <span class="title">coroutine_example</span><span class="params">(name:<span class="built_in">string</span>;count:<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">  <span class="title">print</span><span class="params">(<span class="string">"&#123;name&#125; step 1\n"</span>)</span></span></span><br><span class="line"><span class="function">  <span class="title">co_continue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  <span class="title">print</span><span class="params">(<span class="string">"&#123;name&#125; step 2\n"</span>)</span></span></span><br><span class="line"><span class="function">  <span class="title">co_continue</span><span class="params">()</span></span></span><br><span class="line">  co_await &lt;| subcr(name)</span><br><span class="line">  co_continue()</span><br><span class="line">  print(<span class="string">"&#123;name&#125; step 3\n"</span>)</span><br><span class="line">  co_continue()</span><br><span class="line">  <span class="function"><span class="keyword">for</span> i in <span class="title">range</span><span class="params">(<span class="number">4</span>,<span class="number">4</span>+count)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;name&#125; step &#123;i&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">co_continue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">[export]</span><br><span class="line">def main</span><br><span class="line">    var crs &lt;- [&#123;<span class="keyword">auto</span></span><br><span class="line">        coroutine_example(<span class="string">"co1"</span>,<span class="number">1</span>);</span><br><span class="line">        coroutine_example(<span class="string">"co2"</span>,<span class="number">2</span>)</span><br><span class="line">    &#125;]</span><br><span class="line">    cr_run_all(crs)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Output:</span></span><br><span class="line"><span class="comment">//co2 step 1</span></span><br><span class="line"><span class="comment">//co1 step 1</span></span><br><span class="line"><span class="comment">//co2 step 2</span></span><br><span class="line"><span class="comment">//co1 step 2</span></span><br><span class="line"><span class="comment">//co2 sub 1</span></span><br><span class="line"><span class="comment">//co1 sub 1</span></span><br><span class="line"><span class="comment">//co2 sub 2</span></span><br><span class="line"><span class="comment">//co1 sub 2</span></span><br><span class="line"><span class="comment">//co2 sub 3</span></span><br><span class="line"><span class="comment">//co1 sub 3</span></span><br><span class="line"><span class="comment">//co2 step 3</span></span><br><span class="line"><span class="comment">//co1 step 3</span></span><br><span class="line"><span class="comment">//co2 step 4</span></span><br><span class="line"><span class="comment">//co1 step 4</span></span><br><span class="line"><span class="comment">//co2 step 5</span></span><br></pre></td></tr></table></figure></p><p>Второй пример — это внутренний итератор по дереву из первой части статьи (раздел <strong><code>Файберы</code></strong>), оформленный в виде корутины:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[coroutine]</span><br><span class="line"><span class="function">def <span class="title">each_async</span><span class="params">(tree : Tree?)</span> : <span class="keyword">int</span></span></span><br><span class="line">  if tree.left != null</span><br><span class="line">    <span class="keyword">co_await</span> &lt;| each_async(tree.left)</span><br><span class="line">  yield tree.data</span><br><span class="line">  <span class="keyword">if</span> tree.right != null</span><br><span class="line">    <span class="keyword">co_await</span> &lt;| each_async(tree.right)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> t in each_async(tree)</span><br><span class="line">  print(<span class="string">"&#123;t&#125;\n"</span>)</span><br></pre></td></tr></table></figure></p><p>Макрос corountine превращает функцию в генератор, который может быть приостановлен и возобновлён. Как показывает пример, асинхронные значения могут возвращаться в том числе и из рекурсивной функции. Теперь можно как в <code>ruby</code>, возвращать управление из вложенных функций!</p><h2 id="Каналы"><a href="#Каналы" class="headerlink" title="Каналы"></a>Каналы</h2><p>Отойдём ненадолго от асинхронных функций, и посмотрим на работу с потоками. В <code>daScript</code> функции для работы с ними собраны в модуле <a href="https://github.com/GaijinEntertainment/daScript/blob/d60f0a310086458d28bf4726e93aa0e6c1e06abe/daslib/jobque_boost.das" target="_blank" rel="noopener">jobque_boost</a>. Примеры использования - <a href="https://github.com/GaijinEntertainment/daScript/blob/fdc48d4d4cfc46f08f0ca2fd8938a05896b973a6/examples/test/unit_tests/test_job_que.das" target="_blank" rel="noopener">test_job_que</a> и <a href="https://github.com/GaijinEntertainment/daScript/blob/master/examples/test/misc/producer-consumer.das" target="_blank" rel="noopener">produser-consumer</a>.</p><p>Новый поток создаётся функцией <code>new_thread</code>, а передача данных осуществляется через каналы (<code>channel</code>), которые объединяют примитив синхронизации (мьютекс) и результат, который может быть отправлен в канал из одного потока и принят из другого.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Answer</span></span></span><br><span class="line"><span class="class">    <span class="title">text</span>:</span><span class="built_in">string</span></span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">work_in_thread</span><span class="params">(var channel)</span></span></span><br><span class="line"><span class="function"><span class="comment">//создаём потока (в реальном коде нужно обернуть в job, чтобы иметь возможность дождаться завершения)</span></span></span><br><span class="line">new_thread &lt;| @</span><br><span class="line">    print(<span class="string">"in thread\n"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">for</span> i in <span class="title">range</span><span class="params">(<span class="number">3</span>)</span></span></span><br><span class="line">      channel |&gt; push_clone([[Answer text="work in progress &#123;i&#125;"]])  //передаём данные в канал</span><br><span class="line">      sleep(<span class="number">1000u</span>)</span><br><span class="line">    channel |&gt; notify_and_release                                    <span class="comment">//закрываем канал</span></span><br><span class="line">    <span class="comment">//completion |&gt; notify_and_release</span></span><br><span class="line">    print(<span class="string">"done thread\n"</span>)</span><br><span class="line">  print(<span class="string">"work_in_thread done\n"</span>)</span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main</span><br><span class="line">  with_channel(<span class="number">1</span>) &lt;| $(channel)</span><br><span class="line">    work_in_thread(channel)</span><br><span class="line">    print(<span class="string">"thread created\n"</span>)</span><br><span class="line">    for_each(channel) &lt;| $(ans:Answer#)              <span class="comment">//принимаем данные из канала</span></span><br><span class="line">        print(<span class="string">"result from thread: &#123;ans.text&#125;\n"</span>)</span><br><span class="line">    print(<span class="string">"done"</span>)</span><br><span class="line"><span class="comment">//Output</span></span><br><span class="line"><span class="comment">//work_in_thread done</span></span><br><span class="line"><span class="comment">//thread created</span></span><br><span class="line"><span class="comment">//in thread</span></span><br><span class="line"><span class="comment">//result from thread: work in progress 0</span></span><br><span class="line"><span class="comment">//result from thread: work in progress 1</span></span><br><span class="line"><span class="comment">//result from thread: work in progress 2</span></span><br><span class="line"><span class="comment">//done thread</span></span><br><span class="line"><span class="comment">//done</span></span><br></pre></td></tr></table></figure><p>Каналы по интерфейсу похожи на итераторы, однако в <code>dascript</code> не встроены в язык, поэтому работают не с встроенной функцией <code>for</code>, а с функцией из модуля joque_boost <code>for_each</code>, которая на очередной итерации достаёт из канала очередное значение или блокирует поток до тех пор, пока канал пуст. Итерация заканчивается после того, как канал будет закрыт (<code>release/notify_and_release</code>).</p><p>Но можно попробовать переписать код так, чтобы работа выполнялась в потоке, но была спрятана внутри асинхронной функции-корутине, которая предоставляет интерфейс в виде стандартного итератора. Используем предыдущий игрушечный пример с асинхронным счётчиком.<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">require daslib/coroutines</span><br><span class="line">require daslib/jobque_boost</span><br><span class="line">require fio</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> </span><br><span class="line">    ValueOrReady = variant&lt;value:<span class="keyword">int</span>; ready:<span class="keyword">bool</span>&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Answer</span></span></span><br><span class="line"><span class="class">    <span class="title">value</span>:</span><span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">work_in_thread</span><span class="params">(var channel: Channel?)</span></span></span><br><span class="line">    new_thread &lt;| @</span><br><span class="line">        <span class="function"><span class="keyword">for</span> i in <span class="title">range</span><span class="params">(<span class="number">100</span>)</span></span></span><br><span class="line">            if i % 10 == 0</span><br><span class="line">                channel |&gt; push_clone([[Answer value=i]])</span><br><span class="line">            sleep(<span class="number">10u</span>)</span><br><span class="line">        channel |&gt; append(<span class="number">1</span>) <span class="comment">//create buffer to inform that channel finish send data increase size to satisfy assert inside channel::release </span></span><br><span class="line">        channel |&gt; release   <span class="comment">//we need to call release satisfy the condition of the ChannelAndStatusCapture macro </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//completion |&gt; notify_and_release //for thread completion logic</span></span><br><span class="line"></span><br><span class="line">[coroutine]</span><br><span class="line"><span class="function">def <span class="title">makeLongCalculationInThread</span><span class="params">(work)</span> : ValueOrReady</span></span><br><span class="line">    var channel : Channel?</span><br><span class="line">    unsafe &#123; channel = channel_create(); &#125;</span><br><span class="line">    invoke(work, channel)</span><br><span class="line">    <span class="keyword">while</span> channel.size == <span class="number">0</span> <span class="comment">// channel.size==1 is a signal to stop receiving</span></span><br><span class="line">        sleep(<span class="number">10u</span>)</span><br><span class="line">        var answer: ValueOrReady</span><br><span class="line">        <span class="keyword">if</span> !channel.isEmpty</span><br><span class="line">            let void_data = _builtin_channel_pop(channel)</span><br><span class="line">            unsafe</span><br><span class="line">                let typed_data = reinterpret&lt;Answer?#&gt; void_data</span><br><span class="line">                answer = [[ValueOrReady value = typed_data.value]]</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            answer = [[ValueOrReady ready = <span class="literal">false</span>]]</span><br><span class="line">        yield answer</span><br><span class="line">    unsafe &#123; channel_remove(channel); &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main</span><br><span class="line">    <span class="function"><span class="keyword">for</span> num in <span class="title">makeLongCalculationInThread</span><span class="params">(@@work_in_thread)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">if</span> num is value</span></span><br><span class="line"><span class="function">            <span class="title">print</span><span class="params">(<span class="string">"&#123;num as value&#125; "</span>)</span></span></span><br><span class="line"><span class="function"><span class="comment">//Output (async):</span></span></span><br><span class="line"><span class="function"><span class="comment">//0 10 20 30 40 50 60 70 80 90</span></span></span><br></pre></td></tr></table></figure></p><p><em>channel_create и channel_remove тут - функции, добавленные в библиотеку работы с каналами, потому что стандартное и безопасное api каналов daScript (with_channel) предоставляет доступ к созданному каналу только внутри блока, а из блока нельзя возвращать значение с помощью yield</em></p><p>Теперь внешний интерфейс — это асинхронная функция,  которая запускает вычисление в потоке и возвращает управление, но сохранит результат вычислений из потока в канале, как только он будет готов. Основной поток при этом не блокируется и может продолжать выполнение, до тех пор пока этот результат не потребуется. Когда результат потребуется — функция main либо приостановится, чтобы его дождаться, либо сразу прочитает его из канала, если он уже готов.</p><h2 id="Communicating-sequential-processes"><a href="#Communicating-sequential-processes" class="headerlink" title="Communicating sequential processes"></a>Communicating sequential processes</h2><p>Каналы повсеместно используются в <code>Go</code>, примитивы и паттерны работы с ними рассмотрены в [22] и [23] по ссылкам в первой части статьи (теорию по работе с каналами можно гуглить по аббревиатуре <a href="https://en.wikipedia.org/wiki/Communicating_sequential_processes" target="_blank" rel="noopener">CSP</a>). Поиграться с примерами в браузере в можно <a href="https://go.dev/tour/concurrency/1" target="_blank" rel="noopener">тут</a>. Go позволяет создавать буферизированные и небуферизированные каналы. Отличие в том, что при попытке отправить второе сообщение в канал, пока не прочитано первое, тред блокируется до тех пор, пока сообщение не будет прочитано. Каналы в <code>daScript</code> буферизированы, так что можно отправить сразу несколько сообщений без блокировки отправителя, даже если читатель ещё не принял эти сообщения.</p><p>В <code>Go</code> есть удобные примитивы для соединения выходов нескольких каналов:<br><img src="/blog/2826376146/dataflow.png" alt=""><br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Funnel_receiveOrTimeout</span><span class="params">(c &lt;- <span class="keyword">chan</span> <span class="keyword">int</span>, duration time.Duration)</span> <span class="params">(data <span class="keyword">int</span>, more, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> data, more = &lt;- c :       <span class="comment">//канал с данными</span></span><br><span class="line">      <span class="keyword">return</span> data, more, <span class="literal">true</span></span><br><span class="line">    <span class="keyword">case</span> &lt;- time.After(duration):  <span class="comment">//канал таймаута, выдаёт сообщение после указанного времени</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>, <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fanout</span><span class="params">(in &lt;- <span class="keyword">chan</span> <span class="keyword">int</span>, out1, out2 <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> data := <span class="keyword">range</span> in &#123; <span class="comment">//получает новые данные</span></span><br><span class="line">    <span class="keyword">select</span> &#123;             <span class="comment">//отправляет в первый попавшийся незаблокированный канал</span></span><br><span class="line">      <span class="keyword">case</span> out1 &lt;- data</span><br><span class="line">      <span class="keyword">case</span> out2 &lt;- data</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>select</code> в первом случае позволяет либо получить сообщение с данными из канала, либо сообщение из канала таймаута, если данных не поступило в течение определенного времени. Во втором — отправить данные в первый свободный канал из списка.</p><p><code>Go</code> также отличается тем, что имеет встроенный диспетчер горутин, который распределяет выполнений по нескольким потокам. Таким образом горутины в го — это корутины, которые могут быть выполнены или перенесены в другой поток. Выполнение горутины приостанавливается при ожидании при ожиданнии данных из канала.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;a href=&quot;/blog/2550823652/&quot; title=&quot;Итераторы, колстеки, корутины&quot;&gt;Итераторы, колстеки, корутины&lt;/a&gt; -- первая часть статьи про итераторы и асинхронное программирование. В ней были перечислены особенности абстракций обхода коллекций в нескольких языках, а также описана связь между ними и возобновляемыми функциями. В конце статьи рассмотрено представление возобновляемых функций в различных языках и различная терминология для их обозначений. Дальше можно постепенно перейти к способам управления этими функциями.
    
    </summary>
    
    
    
      <category term="dev" scheme="http://spiiin.github.io/tags/dev/"/>
    
      <category term="link" scheme="http://spiiin.github.io/tags/link/"/>
    
      <category term="dascript" scheme="http://spiiin.github.io/tags/dascript/"/>
    
      <category term="cpp" scheme="http://spiiin.github.io/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>Системы поиска сокровищ</title>
    <link href="http://spiiin.github.io/blog/3309518526/"/>
    <id>http://spiiin.github.io/blog/3309518526/</id>
    <published>2022-08-09T18:08:42.000Z</published>
    <updated>2022-08-20T19:33:55.779Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>В эссе <a href="https://probablydance.com/2019/06/08/treasure-hunting-systems-found-in-the-history-of-video-games/" target="_blank" rel="noopener">Treasure Hunting Systems Found in the History of Video Games</a> Malte Skarupke рассуждает о том, что в истории игр было несколько примеров случаев, когда появлялась платформа, в итоге порождающая сразу несколько новых успешных жанров. Он пытается выделить характеристики и свойства, общие для таких платформ, которые он называет “Системы поиска сокровищ”. Я не согласен со всеми наблюдениями автора, но попробую немного расширить его эссе. Это не перевод, а дополнение к оригинальной статье.</p><a id="more"></a><h2 id="Неравномерность-распределения-неизвестных-нам-величин"><a href="#Неравномерность-распределения-неизвестных-нам-величин" class="headerlink" title="Неравномерность распределения неизвестных нам величин"></a>Неравномерность распределения неизвестных нам величин</h2><p>Почему вообще на мой взгляд могут возникать такие системы?</p><p>Для начала два факта. Первый — в <strong><code>геймдеве очень много ОЧЕНЬ неравномерно распределённых величин</code></strong>. Главная из этих величин — количество фана от игры. Несколько примеров других:</p><ul><li>Большинство игр скучные, но есть очень небольшое количество очень весёлых и увлекательных. Они настолько лучше для нас, что затягивают невероятно сильнее — мы можем забывать про сон или важные дела, и возвращаемся к таким играм годами. У нас нет численной оценки удовольствия от игры, но вероятно, что эта разница этой нашей субъективной оценки между любимыми играми и просто хорошими была бы колоссально больше, чем между хорошими и плохими. Условно, все игры получили бы от нас от 1 до 9 баллов, а любимая, не 10, а скажем 1000000.</li></ul><ul><li>Как возможноое следствие, разница между доходами от игры от среднего игрока и от фаната — колоссальная. Это одна из причин существования модели условно-бесплатных игр. Несколько человек-фанатов могут принести дохода больше чем 1000000 человек, которым игра не понравилась.  </li></ul><p>Моя заметка про очень известное явление в геймдеве: <a href="/blog/1402387497/" title="Суперфанаты">Суперфанаты</a> — не называйте их китами!</p><blockquote><p>Отсюда следует одно важное правила гейм-дизайна: не ограничивайте сверху возможности потратить деньги в вашей игре, вы не знаете, как много игроки будут готовы вам заплатить, не надо запрещать им платить много</p></blockquote><ul><li>Но в то же время разница между хорошей игрой и средней по количеству потраченного труда небольшая. То есть, чтобы сделать игру, которая увлечёт в 1000000 раз сильнее (или в 1000000 раз больше игроков), не нужно в 1000000 раз больше усилий. Не нужно даже в 2 раза больше усилий. Возможно, достаточно всего несколько процентов. Важнее не количество усилий, а что-то другое — какие-то отдельные фичи или небольшие кусочки работы стоят в 1000000 раз больше других, именно от них может зависеть.</li></ul><p>Тайнан Сильвестр в статье <a href="https://tynansylvester.com/2013/12/email-dredging-cutting-polish-and-nonlinear-results/" target="_blank" rel="noopener">Email dredging: Cutting polish and nonlinear results</a> развёрнуто расписывает эту нелинейность между временем, потраченным на такие “золотые” фичи и тем, что они приносят в результате. Дальше я ещё буду ссылаться на эту статью и методы из неё.</p><ul><li>Суммарная разница в доходах между лучшими играми и хорошими тоже колоссально отличается — как от мультипликативности перечисленных выше факторов (лучшие игры притягивают в 1000 раз больше игроков И ОДНОВРЕМЕННО лучшие ещё и больше игроков конвертируют в суперфанатов), так и от положительной обратной связи — лучшие игры получают больше ресурсов для привлечения новых игроков, все хотят поиграть в лучшую игру.</li></ul><p>Я использовал разницу в 1000000 раз в примерах, но разница здесь может быть даже намного существеннее, причём настолько сильнее, что <strong>мы постоянно ошибаемся пытаясь её оценить</strong>. Главное — нельзя недооценивать её. Книга <code>Черный лебедь</code> Насима Талеба практически полностью о том, что мы плохо справляемся с прогнозами такого типа величин, из-за чего прогнозы часто бывают ошибочными. В совокупности с тем, насколько значима правильная оценка величины для нас, ошибки могут приводить к катастрофам (в узком смысле — будет ли наша компания продолжать делать игры или закроется).</p><p>Некоторые примеры разница нашего восприятия из книги приведены в статье <a href="https://ru.wikipedia.org/wiki/%D0%98%D0%B3%D1%80%D0%BE%D0%B2%D0%BE%D0%B5_%D0%B7%D0%B0%D0%B1%D0%BB%D1%83%D0%B6%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5" target="_blank" rel="noopener">Игровое заблуждение</a>.</p><p>Второй факт — <strong><code>мы всё ещё мало знаем о том, как именно сделать игру увлекательной, но знаем, что в процессе экспериментов можем обнаружить сверх-увлекательные идеи, которые мы затем сможем использовать в игре</code></strong>.</p><p>Случайная находка такого самородка в процессе экспериментов называется <code>серендипным открытием</code>. Самое известное такое открытие — случайное обнаружение механики <code>Тетриса</code>. Менее известные — небольшое изменение, превратившее прототип <code>Diablo</code> и пошаговой игры в ту, которую мы знаем. В статье <a href="/blog/2537188794/" title="Прототипирование в геймдеве">Прототипирование в геймдеве</a> я приводил ещё несколько известных примеров таких серьёзных трансформаций жанров игр (раздел <code>Путь от прототипа к результату</code>).</p><p>Несколько примеров занятий из мира компьютеров и разработки, связанных с исследованием неизвестного, которые требуют исключительной внимательности к каждой обнаруженной “необычной” мелочи:</p><ul><li>Тестирование и отладка програм. На этапе поиска причин возникновения очень редких ошибок. Часто первая зацепка, позволяющая обнаружить всю цепочку действий, приводящую к крешу, это случайное незапланированное наблюдение необычного поведения.</li><li>Реверс инжиниринг. Сама цель процесса — понять внутреннее устройство программы или данных, которые она интерпретирует, изначально не зная о нём ничего. Необходимо большое количество предположений и проверок, причём необходимо уметь отбрасывать варианты, которые “почти объясняют поведение”, но некоторые мелочи портят всё объяснение или меняют его смысл.</li><li>Аналитика. Наблюдение за поведением пользователей — процесс работы с очень “грязными” данными. Тенденции, видимые на графиках, сложно интерпретировать, и требуется умение не только придумать гипотезу и проверить её, но и достаточно быстро изменить и уточнить интерпретацию в случае расхождений с реальностью.</li><li>Плейтесты. Люди <a href="https://ru.wikipedia.org/wiki/%D0%A0%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F_(%D0%BF%D1%81%D0%B8%D1%85%D0%BE%D0%BB%D0%BE%D0%B3%D0%B8%D1%8F" target="_blank" rel="noopener">рационализируют</a> своё поведение, поэтому они не могут даже сказать вам, почему им понравилась или не понравилась игра — они будут неосознанно врать вам. Невозможно составить точный опросник, по которому игрок что-то расскажет вам, нужно отслеживать влияния изменений в игре на реальное, а не декларируемое поведение игроков.</li></ul><p>Однако, не смотря на возможности, экспериментирование не очень распространёно в реальных компаниях — зачем лезть в неизвестное (с неизвестными результатами!), если можно повторять “формулу успеха”? Делать игры дорого, и для инвесторов надёжнее вкладываться в то, что с большей вероятностью будет хорошо продаваться — проверенные жанры и франшизы.</p><p>Про элементы подхода с исследованиями в геймдеве я писал в статье — <a href="/blog/2486671624/" title="Метод Lean Startup">Метод Lean Startup</a>. Одна из основных идей — как можно раньше и дешевле собрать <code>Minimum Awesome Product</code>, игру, которая уже будет интересна игрокам, и начинать изучать свою аудиторию, выстроив процесс разработки так, чтобы данные экспериментов позволяли изменять дальнейшие планы разработки насколько это потребуется.</p><h2 id="Залежи-артефактов"><a href="#Залежи-артефактов" class="headerlink" title="Залежи артефактов"></a>Залежи артефактов</h2><p>Объединим эти два факта вместе — перед нами бесконечное поле неизвестных интересных механик для наших игр, <strong><code>&quot;зарытые в землю артефакты&quot;</code></strong>. Они очень сильно отличаются по характеристикам. Мы копаем наугад и рано или поздно откапываем часть артефакта — делаем прототип игры. Выкапывать весь артефакт дорого, поэтому для нас очень важно прикинуть стоимость как полную стоимость раскопок, так и то, за сколько мы сможем его продать. И всё это — только по торчащей из-под земли верхушке!</p><p>Часто хорошим решением является не копание артефакта сразу вглубь (фиксированное решение делать игру по плану несколько лет), а неглубокое копание окрестностей в <strong>разные</strong> стороны — создание ещё нескольких прототипов, проверяющих <strong>различные</strong> гипотезы. Потому что мы кое-что знаем про наше поле.</p><p>Например, артефакт может оказаться больше, чем кажется, и мы можем понять, в какую сторону лучше копать, чтобы быстрее его вытащить — обнаруженная нами неплохая механика для шутера может хорошо или плохо работать в паре с другими задуманными механиками. Или наоборот, артефакт мельче чем кажется, и развивать идею бесполезно, хотя они и выглядела интересно. Лучше не тратить время, и попробовать что-то другое.</p><p>Или же, редко, но бывает, что в окрестностях от того, что мы начали раскапывать, обнаруживается ещё множество артефактов. Мы просто не сможем выкопать и продать их все сами. К примеру мы обнаружили, что нашли механику для шутера, которая отлично работает с множеством различных других механик, и мы просто не можем взять их все в свою игру. Но мы можем поделиться находкой с игроками — пускай копают вместе с нами! Это и есть в терминологии автора — <strong><code>системы поиска сокровищ</code></strong>.</p><blockquote><p>Системы поиска сокровищ хорошо продаются</p></blockquote><p>Скрин из <a href="https://youtu.be/GxthbWfSak8?t=1275" target="_blank" rel="noopener">доклада</a> How Modding Made Bethesda Better, топовые игры в Steam по числу пользователей 2015 года, большинство игр в нём попадают в определение системы поиска сокровищ или даже просто сделаны в этих системах!<br><img src="/blog/3309518526/rate.png" alt="bench"></p><h2 id="Примеры-систем-поиска-сокровищ"><a href="#Примеры-систем-поиска-сокровищ" class="headerlink" title="Примеры систем поиска сокровищ"></a>Примеры систем поиска сокровищ</h2><p>Malte приводит три примера таких систем — моды к Warcraft 3, чехословацкое сообщество разработчиков игр 80х и Flash-игры, и сосредотачивается на общих характеристиках таких систем. Это интересный пример обобщения — рассматривать систему <code>игра + платформа + сообщество</code>, в которой границы между игрой и платформой сильно размыты (платформа может быть интегрирована в игру, быть “встроенным магазином” или внешним сайтом, а сама “игра” отсутствовать вообще, или быть условной, как например в RPG Maker), а сообщество геймеров иногда перерастает в субкультуру, представители которой не только играют в игру или занимаются её модификацией, но и воспринимает это как часть своего образа жизни (ролевики, проводящие LARP-ы по Fallout, или конвенты косплейеров — продолжение игры в реальной жизни).</p><p><strong><code>Сообщество-центричные системы</code></strong></p><p>Примеры сверхактивных сообществ моддеров различных периодов — пиратская сцена, в период, когда никто особо не заморачивался защитой игр, и копирование с изменениями часто были “фишками” команд, модифицирующих софт и игры.</p><p>Насколько я понял после пролистывания книжки про разработчивов Чехословакии, что-то подобное происходило и там. ZX-спектрум и кассеты в 80х, дискеты в 90х и CD в 2000х являлись платформой, новым способом передачи информации, вокруг которой объединялись геймеры, хакеры (переводчики, дизайнеры “оболочек”, читеры), коллекцинеры, продавцы, журналисты. Возможности для “креатива” здесь — открытые ресурсы для модификации и простота копирования, а также то, что в ходе распространения открывались возможность заработать немного денег и “очков престижа” — релиз группы соревновались и просто ради известности своей группировки внутри сообщества. Пример деятельности такого пиратского сообщества можно почитать и на русском в художественной форме — “Дневник тестировщика”/“Хроники тестировщика”, или посмотреть на английском — сериал “Сцена”.</p><p>Чехословацкая сцена выделилась тем, что в диком количестве насоздавала текстовых квестов. Похожий “взрыв” жанра игр произошёл с клонами <code>MUD</code>, его эволюция описана в книге Бартла <code>Designing Virtual Worlds</code>, средой распространения стал ранний интернет.</p><p>Нескольких “невзрывных” примеров хакерских сообществ (в СНГ было много модификаций игр/игры, но недостаточно для “критической массы” интересных модификаций, созданием занималось очень ограниченное количество людей) — <code>китайские клоны NES-картриджей</code>, в которых модифицировалась графика и отдельные элементы сюжета (видимо, было относительно просто хакать, но сложно тиражировать), и бесчисленные <code>модификации GTA 3/Vice City</code>, которые продавалась на отдельных компактах (к моменту пика популярности было относительно просто тиражировать CD-RW дома, но создание требовало как минимум навыков в 3D-моделировании, а как максимум — полноценного инструментария).</p><p>Своеобразным примером “взрыва” в прото-жанре игр песочниц может послужить <a href="https://www.youtube.com/watch?v=oKYiWb2W97k" target="_blank" rel="noopener">Infiminer</a>, исходники которого “утекли” в сеть. Модификаций было много, но из-за перекоса системы “игра-платформа-сообщество” в сторону хакерского сообщества, без общей игры и платформы оригинал умер, а мы все знаем одну из них на базе этих исходников, <code>Minecraft</code>, который уже и сам может служить примером системы поиска сокровищ с помощью внутриигровых модов.</p><p><strong><code>Игро-центричные системы</code></strong></p><p>Среди перечисленных автором примеров отсуствует возможно самый большой, который можно не заметить, так же как не можно не заметить изменения, которые принесли в геймдев социальные сети — мы просто живём в мире, где последствия этого “кембрийского взрыва”, повсюду и не задумываемся о том, что могло быть по другому. Это семейство игр и движков <code>Quake</code> от id software. Кроме крутости самих игр в техническом плане, авторы ещё и специально уделяли внимание ещё и тому, чтобы игры стали системой поиска сокровищ.</p><ul><li>Распространение. У id и до выхода Doom был опыт распространения игр по системе shareware, которая в тот момент была средством инди-разработчиков не зависеть от издателя. Можно было получить бесплатную демо-версию на дискетах, или скачать по сети.</li></ul><ul><li>Легкость в модификации. Кармак сознательно отделил ресурсы игры от приложения так, чтобы можно легче хакать игру. В дальнейшем, он принял революционное для того времени решение выложить в открытый доступ инструменты для модификации игры. Некоторые мультиплейерные режимы из современных шутеров родились из модов и тотальных коверсий Дума и Квейка. Один из примеров из книги “Властелины DOOM” — режимы “freeze tag” (салки) и “царь горы” из какого-то мода doom 2 по фильму “Aliens”.</li></ul><ul><li>Сама концепция движка как отделяемой от игры системы. Во-первых, возможность его лицензирования для сторонних разработчиков (Hexen и Eretic на движке Doom), и позже, взрыв игр и движков <a href="https://ru.wikipedia.org/wiki/Id_Tech_3" target="_blank" rel="noopener">на базе Quake 3</a>. Кроме игр, движок также прямо или косвенно повлиял на другие коммерческие движки — например, в книге “Архитектура игрового движка” есть схема происхождения движка <code>Medal of Honor</code> от этой “ветки эволюции”.</li></ul><ul><li>Отдельно от возможности лицензировать движок стоит выделить то, что исходники движков со временем традиционно выкладываются для свободного изучения и использования. Код Doom считают качественным (<a href="https://fabiensanglard.net/doom3/index.php" target="_blank" rel="noopener">1</a>, <a href="https://habr.com/ru/post/166113/" target="_blank" rel="noopener">2</a>, <a href="https://news.ycombinator.com/item?id=24921161" target="_blank" rel="noopener">3</a>). Часто он может служить не только историческим, но и образовательным целям.</li></ul><ul><li>Мультиплейер. Id уделили много внимания возможности и способам играть совместно, в разные периоды распространения сетевых технологий: по локально соединённым компьютерам, отдельным сереверам для клубов, игре через интернет. С их игр начался киберспорт и большие соревнования по играм.</li></ul><p>Другая система генерации сокровщ — движок и редактор <code>Warcraft</code> + матчи по Battle.net. Malte в своей статье рассуждает о том, чем Warcraft выделяется на основе других игр с мощными редакторами уровней. Основа здесь — гибкая базовая механика и возможность быстро попробовать и улучшить созданные карты. Можно выбросить/изменить/добавить некоторые механики (и редактор позволяет это делать!) и может получиться, что играть будет только интереснее. Дота — результат такого эксперимента, и постоянного тюнинга на основе тестов на игроках (описание <a href="https://dota2.fandom.com/ru/wiki/%D0%92%D0%B5%D1%80%D1%81%D0%B8%D0%B8_%D0%B8%D0%B3%D1%80%D1%8B" target="_blank" rel="noopener">327 патчей</a> карты).</p><p>Может быть, важным в случае Варкрафта является также хороший набор базовых элементов в песочнице редактора — можно посмотреть на реализацию карт из самой игры, и взять их них примеры расстановки “солдатиков” и “историй” про них.</p><p>Механики жанра стратегий позволяют много экспериментировать — <code>Civilization</code> также допускает создание карт-тотальных конверсий изначальной механики (некоторые из добавленных цивилизаций в последней части игры сами являются такими серьёзными экспериментами с переделками механик, ломающих правила).</p><p>Также хорошей платформой для экспериментов являются шутеры — <code>Counter-Strike</code>, <code>DayZ</code>, <code>PUBG</code> как примеры игр на движках шутеров с другими механиками, <code>Unreal Engine</code> как пример движка для шутера, выросшего в целую платформу.</p><p>На удивление, хуже работают модификации RPG, <code>Neverwinter Nights</code>, <code>The Elder Scrolls</code> предоставляют отличные редакторы, но они не породили новых жанров или серьёзно отличающихся механик. Автор связывает это с тем, что новые механики сложнее вписываются в существующие механики (и легче ломают баланс основной игры, если не являются изолированными модификациями), и часто требуют большего времени на плейтесты и получение обратной связи от игроков. Возможно, жанр ждёт своего взрыва.</p><blockquote><p>Если в редакторе уровней можно сделать только новые уровни для игры (неважно сколько) — это ещё не система генерации сокровищ. Сокровища появляются, когда редактор позволяет воплощать новые идеи</p></blockquote><p>Отдельное направление поиска — попытка создать игру, в которой сокровища будут генерировать пользователи внутри самой игры или встраивая контент прямо в игру (user-generated content). Примеры — творческие песочницы типа <code>Minecraft</code> или <code>Terraria</code>, в которых можно воссоздать известное здание или даже город, а также с помощью каких-нибудь простых логических триггеров выстроить несложную механику в рамках позволенного игрой (фабрики, механизмы, двигатели). Серьёзное ограничение при это — базовая механика и сеттинг игры.</p><p>Чем абстрактнее мир, тем проще воображению дорисовать что-то (хорошее объяснение эффекта можно найти в книге “Понимание комиксов”), и чем абстрактнее сеттинг, тем шире возможности того, что туда можно добавить, чтобы игроки посчитали это приемлемым в этом мире (виртуальный концерт рэпера в Fortnite будет нормально смотреться, но в World of Tanks будет неуместен, как и многое другое).</p><p><em>Свободное творчество игроков в виде возможности “построить что угодно”, часто требует цензуры со стороны разработчиков. Джесси Шел в книге по геймдизайну приводит пример “Disney Infinity”, в которой команда была вынуждена содержать отдел по борьбе с созданием в игре членов.</em></p><p>Самый удачный из существующих пример попыток создать такую систему — <code>Roblox</code>. Абстрактный мир, и “конструктор механик”, выданный игрокам в виде объектной модели, к которой можно получить доступ с помощью языка Lua. Наверное, где-то в этих серых горах тоже есть золото в виде новых механик и жанров. User-generated content системы не очень хорошо ложаться на экономику реального мира, поэтому вокруг вознаграждения за созданный контент витают идеи вроде NFT в блокчейнах.</p><p>Попытки создания мета-вселенных — это желание создать еще большую универсальную систему, в которую можно засунуть что угодно, однако часто разработчики не принимают во внимание идеи статьи. Они копают, но забывают, что поле мета-вселенных еще неизведано, и сколько там сокровищ еще предстоит узнать.</p><p><strong><code>Жанро-центричные системы</code></strong></p><p>По сути, это те же игроцентричные системы, только без самой игры. Есть платформы, направленные на создание игр строго определенного жанра. Кажется парадоксальным, что при таких ограничениях эти платформы также могут является системами генерации сокровищ в случаях, когда на них делают игры другого жанра, существующего или нового. Примеры таких платформ: <code>RpgMaker</code> для 2d-jrpg-style игр (самая известная игра на нём — To The Moon, в которой выброшены бои и оставлена только история). <code>Mugen</code> (2d-файтинги), <code>OpenBOR</code> (2d beat-them-up), <code>RenPy</code> (визуальные новеллы). Из-за серьёзных ограничений платформы, могут служить базой для экспериментов с механиками в самом жанре, но требуют out of the box мышления, чтобы делать с ними что-то отличное от задуманного, но сама лёгкость старта иногда позволяет проверить какую-нибудь небольшую идею быстрее, чем используя полноценную более универсальную платформу (особенно если доступны качественные строительные “кирпичики”, также как редакторе Warcraft доступны “солдатики” и “истории”).</p><p>Интересен пример с <code>Mario Maker</code>, как жанро-центричная система, оторванная от серии игр.</p><p><strong><code>Платформо-центричные системы</code></strong></p><p>Пример из оригинальной статьи — игры на <code>Flash</code>. Легко и быстро делать, просто выкладывать. Квинтэссенция подобных платформ, для которых главное, что “можно сделать игру быстро и с минимальными навыками программирования” (и бесплатно) — <code>Unity</code>. Unity хотела и стала системой, которую выбирают “по умолчанию”, когда ещё не знают, какие игры хотят делать и зачем. Кроме того, в Asset store можно дешево или бесплатно собрать пачку ассетов, эффектов или даже кусков кода, чтобы еще ускорить процесс, а также посмотреть, что сделали другие и показать, что сделал сам — это важные элементы для возможного “взрыва” творчества.</p><p>Контр-пример, когда для взрыва потенциально есть и платформа и жанры (навскидку — andry birds, cut the rope), но не хватает активного сообщества — <code>мобильные игры</code> в целом. Казуальные игроки менее склонны к исследованию и изменению игр (хотя, все любят кастомизацию), а владельцы апп-сторов блокируют возможность изучения и распостранения изменённых версий (нет своего аналога грин-лайта в steam для пк, или специальной поддержки начинающих разработчиков, строгая политика борьбы с нарушениями правил, высокий порог входа для запуска своей игры на телефоне). </p><blockquote><p>С этой точки зрения война за права распространять приложения и товары в приложениях через свои сторы и победа в ней, ДОЛЖНА БЫТЬ очень полезной в плане возможностй для разработчиков игр, в том числе и для создания систем поиска сокровищ</p></blockquote><h2 id="Свойства-систем-поиска-сокровищ"><a href="#Свойства-систем-поиска-сокровищ" class="headerlink" title="Свойства систем поиска сокровищ"></a>Свойства систем поиска сокровищ</h2><p>Что нужно, чтобы искать сокровища в таких системах, и какие у них отличия от менее удачных и популярных конкурентов?</p><ul><li>Легко начать и сделать что-то законченное:<ul><li>бесплатность</li><li>“батарейки” в комплекте (экосистема — набор библиотек, тулзов, и ассетов)</li><li>запуск одной кнопкой</li><li>возможность использования готовых компонентов</li><li>кросс-дисциплинарные возможности (если я программист — где взять ассеты? если я артист — как я буду писать код?).<br><em>(в презентации <a href="https://youtu.be/GxthbWfSak8?t=199" target="_blank" rel="noopener">How Modding Made Bethesda Better</a> Joel Burgess называет это эпифанией)</em></li></ul></li><li>Легко изменять сделанное:<ul><li>быстрый запуск</li><li>быстрое превью сделанного</li><li>как можно более быстрое внесение изменений, лучше всего вообще без перезапуска игры! — стимуляция к исследованию (тинкерингу)<br><em>(хех, про быстрые изменения, одна из причин, почему я слежу за <a href="https://spiiin.github.io/tags/dascript/">daScript</a> — это ключевая идея языка)</em></li></ul></li><li>Легко распространять сделанное:<ul><li>наличие среды распространения (игровые сервера, соцсети, спец. магазины, активное использование новых только появившихся медиа)</li><li>социальное доказательство в этой среде (система оценок игроками, простота выкладывания, наличие удобных фильтров для поиска, небольшой контроль за соблюдением правил — запреты на абьюз системы)</li><li>стимуляция возможностью заработать или стать популярным</li><li>доступность (не нужно регистрироваться или покупать что-то)</li><li>обратная совместимость (однажды сделанное должно продолжать работать всегда, без переделок)</li></ul></li><li>Легко получить обратную свзять:<ul><li>возможность эффективно получить оценки, критику и отзывы от игроков или других разработчиков</li></ul></li><li>Легко изучать и развиваться:<ul><li>наличие большого количества примеров</li><li>наличие ХОРОШИХ примеров</li><li>неограниченные возможности реализации сложных идей</li></ul></li></ul><h2 id="Ещё-несколько-около-игровых-систем"><a href="#Ещё-несколько-около-игровых-систем" class="headerlink" title="Ещё несколько около-игровых систем"></a>Ещё несколько около-игровых систем</h2><p> <strong><code>Креативы маркетинга</code></strong></p><p> Если отбросить лгбт-фанфики и прочий треш, то среди рекламных креативов от маркетологов, которые завлекают игроков в очередную казуалку, бывают и интересные идеи. По сложности реализации — примерно как флеш-игры, с требованием показать что-то игроку, быстрее чем за несколько десятков секунд, пока он пролистывает свои ленты новостей. Стимулирует к творчеству и необычным идеям здесь то, что ставки очень высоки — реклама стоит дорого, и если игроки не заинтересуются, то в рекламируемую игру просто никто не будет играть. </p><p> <strong><code>Хакатоны</code></strong></p><p> Искуственные ограничения, и необходимость слепить игру за ограниченное время стимулирует разработчиков искать необычные идеи там, где они не попробовали бы в обычных условиях. Изредка (очень изредка!) игры или идеи из хакатонов эволюционируют в полноценные игры.</p><p><strong><code>Генерация картинок</code></strong></p><p>Malte рассматривает уже мёртвый сайт picbreeder, позволяющий генерировать картинки эволюционным алгоритмом, как систему генерации сокровищ (в этом случае, интересных картинок, которые “вывели” пользователи). В <a href="https://youtu.be/dKazBM3b74I" target="_blank" rel="noopener">докладе</a>, выделена пара свойств этой системы:</p><ul><li>Лучший результат получается внезапно, а  не в результате итераций. Вывести случайными изменениями красивую картинку целенаправленно сложно (условный чайник получается не последовательным выведением носика или крышки, а из чего-то, похожего на яйцо в шляпе).</li><li>Картинки, полученные в результате голосований, хуже, чем в ходе индивидуального исследования системы (тинкеринга).</li></ul><p>Неизвестно, насколько выводы применимы к другим системам генерации сокровищ. Новая итерация “разведения картинок” — нейросеть <code>Dall-E</code>. Она умеет рисовать картинки по текстовому описанию, и также позволяет итеративные эксперименты — уточнение текста описания, перерисовка понравившейся пользователю картинки, с возможностью оставить нетронутой какую-то часть изображения. Где-то в её недрах определенно есть сокровища, которыми ещё предстоит научиться пользоваться.</p><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/84Wnp7lx3io" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div><p><em>сны нейросети о коммунизме, автора оригинала не смог найти</em></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;В эссе &lt;a href=&quot;https://probablydance.com/2019/06/08/treasure-hunting-systems-found-in-the-history-of-video-games/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Treasure Hunting Systems Found in the History of Video Games
&lt;/a&gt; Malte Skarupke рассуждает о том, что в истории игр было несколько примеров случаев, когда появлялась платформа, в итоге порождающая сразу несколько новых успешных жанров. Он пытается выделить характеристики и свойства, общие для таких платформ, которые он называет “Системы поиска сокровищ”. Я не согласен со всеми наблюдениями автора, но попробую немного расширить его эссе. Это не перевод, а дополнение к оригинальной статье.&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="dev_method" scheme="http://spiiin.github.io/tags/dev-method/"/>
    
      <category term="gamedesign" scheme="http://spiiin.github.io/tags/gamedesign/"/>
    
  </entry>
  
  <entry>
    <title>Карта блога</title>
    <link href="http://spiiin.github.io/blog/3774050611/"/>
    <id>http://spiiin.github.io/blog/3774050611/</id>
    <published>2022-08-06T13:50:31.000Z</published>
    <updated>2022-08-20T12:47:03.418Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Про что я пишу.</p><h2 id="Разработка"><a href="#Разработка" class="headerlink" title="Разработка"></a>Разработка</h2><p><a href="https://spiiin.github.io/tags/gamedev/">Gamedev</a> - разработка игр<br><a href="https://spiiin.github.io/tags/dev/">Dev</a> - общее<br><a href="https://spiiin.github.io/tags/dev-evolution/">Dev_evolution</a> - развитие в геймдеве<br><a href="https://spiiin.github.io/tags/dev-method/">Dev_method</a> - идеи, методы и подходы к разработке (в основном игр)<br><a href="https://spiiin.github.io/tags/gamedesign/">Gamedesign</a> - геймдизайн (больше лудология, чем практика)</p><h2 id="Программирование"><a href="#Программирование" class="headerlink" title="Программирование"></a>Программирование</h2><p><a href="https://spiiin.github.io/tags/dascript/">daScript</a><br><a href="https://spiiin.github.io/tags/cpp/">C++</a><br><a href="https://spiiin.github.io/tags/python/">Python</a><br><a href="https://spiiin.github.io/tags/asm/">Assembler</a> - ассемблер, в основном старых консолей</p><p>Много по мелочи в тегах — 3d, c#, nim, opengl, lua, squirell, scala, objc, codespell</p><h2 id="Ромхакинг"><a href="#Ромхакинг" class="headerlink" title="Ромхакинг"></a>Ромхакинг</h2><p><a href="https://spiiin.github.io/tags/hack">Hack</a> - ромхакинг, исследования игр, CadEditor, переделки игр</p><p>Отдельно по платформам — nes, sega, gba</p><h2 id="Личное"><a href="#Личное" class="headerlink" title="Личное"></a>Личное</h2><p><a href="https://spiiin.github.io/tags/log/">Log</a> - личные заметки<br><a href="https://spiiin.github.io/tags/%D0%BA%D0%BD%D0%B8%D0%B3%D0%B8/">Книги</a> - рецензии на книги<br><a href="https://spiiin.github.io/tags/games/">Игры</a> - про игры<br><a href="https://spiiin.github.io/tags/juggling/">Juggling</a> - жонглирование<br><a href="https://spiiin.github.io/tags/hardware/">Hardware</a> - баловство с электроникой<br><a href="https://spiiin.github.io/tags/fun/">Fun</a> - развлечения<br><a href="https://spiiin.github.io/tags/link/">Link</a> - ссылки<br><a href="https://spiiin.github.io/tags/%D0%BA%D1%80%D0%B8%D0%BF%D1%82%D0%BE/">Крипто</a> - блокчейны и криптовалюты<br><a href="https://spiiin.github.io/tags/%D0%BB%D1%8E%D0%B4%D0%B8/">Люди</a> - краткие биографии крутых чуваков</p><h2 id="Страница-всех-тегов"><a href="#Страница-всех-тегов" class="headerlink" title="Страница всех тегов"></a>Страница всех тегов</h2><p><a href="https://spiiin.github.io/tags/meta/">Meta</a> - все теги и мета-посты вроде этого</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;Про что я 
      
    
    </summary>
    
    
    
      <category term="meta" scheme="http://spiiin.github.io/tags/meta/"/>
    
  </entry>
  
  <entry>
    <title>Итераторы, колстеки, корутины</title>
    <link href="http://spiiin.github.io/blog/2550823652/"/>
    <id>http://spiiin.github.io/blog/2550823652/</id>
    <published>2022-08-01T18:39:01.000Z</published>
    <updated>2022-08-08T15:26:58.811Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Малость нырнул в кучу статей про асинхронность и корутины в различных языках. Напишу небольшую выдержку (с переводами примеров на <code>daScript</code> там, где актуально), о том, что корутины можно начинать рассматривать как расширение возможностей итераторов и колбеков (функторов), а не с более часто встречающихся генерации последовательностей или реализации паттерна “продюсер-консюмер”.</p><p>Ссылки<br> [1] <a href="http://journal.stuffwithstuff.com/2013/01/13/iteration-inside-and-out/" target="_blank" rel="noopener">Iterators Inside and Out</a> - обзор итераторов в различных языках, для каких задач удобны<br> [2] <a href="http://journal.stuffwithstuff.com/2013/02/24/iteration-inside-and-out-part-2/" target="_blank" rel="noopener">Iterators Inside and Out. Part 2</a> - подводка к тому, что абстракция итераторов требует примитивов работы с параллельным кодом<br> [3] <a href="http://journal.stuffwithstuff.com/2013/04/17/well-done/" target="_blank" rel="noopener">Well Done: A Sentinel Value</a> - каналы<br> [4] <a href="https://users.livejournal.com/-winnie/421941.html" target="_blank" rel="noopener">Итератор: внутрь и наружу</a> - совсем краткий вывод из статей [1] и [2], и дополнения в комментариях<br> [5] <a href="https://fprog.ru/lib/ferguson-dwight-call-cc-patterns/" target="_blank" rel="noopener">Паттерны использования «call with current continuation»</a> - перевод статьи про паттерны использования call with continuations в Lisp, среди которых — реализация корутин<br> [6] Журнал “Практика функционального программирования”. Статья “Продолжения на практике” - пример “выворачивания” внутреннего итератора во внешний<br> [7] <a href="https://yehudakatz.com/2010/02/07/the-building-blocks-of-ruby/" target="_blank" rel="noopener">The building blocks of Ruby</a> - особенности блоков в Ruby, нелокальные возвраты из итераторов<br> [8] <a href="https://okmij.org/ftp/Scheme/enumerators-callcc.html" target="_blank" rel="noopener">General ways to traverse collections</a> - обзоры способов обхода коллекций, примеры на Scheme. Итератор с памятью (стейт-машина) в функциональном стиле<br> [9] <a href="https://okmij.org/ftp/papers/LL3-collections-enumerators.txt" target="_blank" rel="noopener">Towards the best collection API</a> - пример “выворачивания” итераторов на Scheme<br> [10] <a href="https://legacy.cs.indiana.edu/~sabry/papers/yield.pdf" target="_blank" rel="noopener">Yield: Mainstream Delimited Continuations</a> - yield в разных языках. <a href="https://en.wikipedia.org/wiki/Delimited_continuation" target="_blank" rel="noopener">Delimited continuations</a><br> [11] <a href="http://pllab.is.ocha.ac.jp/~asai/cw2011tutorial/main-e.pdf" target="_blank" rel="noopener">Introduction to Programming with Shift and Reset</a> - операторы shift и reset<br> [12] <a href="https://probablydance.com/2015/01/11/ideas-for-a-programming-language-part-2-a-more-liberal-call-stack/" target="_blank" rel="noopener">Ideas for a Programming Language Part 2: A more liberal call stack</a> - про недостатки абстракции стека вызовов<br> [13] <a href="https://www.chiark.greenend.org.uk/~sgtatham/coroutines.html" target="_blank" rel="noopener">Coroutines in C</a> - классическая статья про проблемы реализации корутин в C. Трюк с реализацией корутин с помощью <a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%B5%D1%82%D0%BE%D0%B4_%D0%94%D0%B0%D1%84%D1%84%D0%B0" target="_blank" rel="noopener">метода Даффа</a><br> [14] <a href="https://probablydance.com/2021/10/31/c-coroutines-do-not-spark-joy" target="_blank" rel="noopener">C++ Coroutines Do Not Spark Joy</a> - обзор реализации корутин в стандарте C++<br> [15] <a href="https://www.scs.stanford.edu/~dm/blog/c++-coroutines.html#the-promise-object" target="_blank" rel="noopener">My tutorial and take on C++20 coroutines</a> - ещё одна статья про корутины в C++ 20, трюк с хранением результата корутины на стеке через Promise Object<br> [16] <a href="https://github.com/lewissbaker/cppcoro" target="_blank" rel="noopener">CppCoro - A coroutine library for C++</a> - библиотека обёрток над корутинами из стандарта C++<br> [17] <a href="https://www.youtube.com/watch?v=8C8NnE1Dg4A" target="_blank" rel="noopener">CppCon 2016: Gor Nishanov “C++ Coroutines: Under the covers”</a> - доклад про реализацию корутин в стандарте C++, особенности реализации генерируемого кода в LLVM, возможности по оптимизации кода на уровне LLVM. Хорошо для понимания того, когда возможна элиминация выделения памяти. <a href="https://llvm.org/docs/Coroutines.html" target="_blank" rel="noopener">LLVM coroutines</a> - интринсики для корутины в LLVM.<br> [18] <a href="https://probablydance.com/2013/02/20/handmade-coroutines-for-windows/" target="_blank" rel="noopener">Handmade Coroutines for Windows</a> - альтернативные реализации корутин для windows. Раз C++ не даёт прямого доступа к указателю на стек, можно подменить его на ассемблере<br> [19] <a href="https://probablydance.com/2012/11/18/implementing-coroutines-with-ucontext/" target="_blank" rel="noopener">Implementing coroutines with ucontext</a> - реализация корутин через posix ucontext<br> [20] <a href="https://www.boost.org/doc/libs/1_79_0/libs/context/doc/html/index.html" target="_blank" rel="noopener">Boost::Context</a> - реализации переключения контекста из boost. Используют обёртки над posix или платформенные заголовки для переключения контекста, или <a href="https://gcc.gnu.org/wiki/SplitStacks" target="_blank" rel="noopener">ассемблерный трюк</a> из gcc (<a href="https://gcc.gnu.org/legacy-ml/gcc-help/2012-03/msg00395.html" target="_blank" rel="noopener">особенности реализации</a>)<br> [21] <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0534r3.pdf" target="_blank" rel="noopener">call/cc (call-with-current-continuation): A low-level API for stackful context switching</a> - пропозал по добавлению в стандарт c++ функционала call/cc<br> [22] <a href="https://go.dev/doc/effective_go#goroutines" target="_blank" rel="noopener">Goroutines</a> - горутины из go, управляются рантаймом языка. <a href="https://go.dev/tour/concurrency/1" target="_blank" rel="noopener">Tour of Go. Goroutines</a>. Планировщик горутин кооперативный, но “ощущается”, как вытесняющий<br> [23] <a href="https://www.youtube.com/watch?v=YEKjSzIwAdA" target="_blank" rel="noopener">Concurrency Patterns In Go</a> - каналы, оператор select выбора из нескольких каналов<br> [24] <a href="https://www.raywenderlich.com/books/kotlin-coroutines-by-tutorials/v2.0/chapters/5-async-await" target="_blank" rel="noopener">Kotlin coroutines. async/await</a> - многопоточные async/await в Kotlin. Идиомы future/promise, async/await/deferred<br> [25] <a href="http://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/" target="_blank" rel="noopener">What Color is Your Function?</a> - проблемы с комбинированием синхронных и асинхронных функций<br> [26] <a href="https://kristoff.it/blog/zig-colorblind-async-await/" target="_blank" rel="noopener">What is Zig’s “Colorblind” Async/Await?</a> - необычный подход Zig, трансформация синхронных функций в асинхронные и наоборот<br> [27] <a href="https://ziglearn.org/chapter-5/" target="_blank" rel="noopener">Zyg’s Async</a> - Async в Zig (<a href="https://ziglang.org/documentation/master/#Async-Functions" target="_blank" rel="noopener">документация</a>)</p><h2 id="Внешние-итераторы"><a href="#Внешние-итераторы" class="headerlink" title="Внешние итераторы"></a>Внешние итераторы</h2><p>Внешний итератор — объект, реализующий некоторый интерфейс Iterator (<a href="http://msdn.microsoft.com/en-us/library/system.collections.ienumerable.aspx" target="_blank" rel="noopener">C#</a>, <a href="https://docs.python.org/2/library/stdtypes.html#iterator-types" target="_blank" rel="noopener">Python</a>), у которого есть методы получения первого элемента коллекции (метод у коллекции или свободная функция), перехода на следующий элемент, и проверки на то, есть ли ещё элементы. На шаблонах C++ — явного интерфейса нет, но есть протокол, декларирующий способы описания итератора для своих типов.</p><p>Рассматривается в книге Банды Четырёх. В [8] критикуется название за активный суффикс -or, хотя методы итератор зовёт внешний код, предлагается название iteratee. Итераторы в стиле C++ также называют курсорами.</p><p><a href="https://dascript.org/doc/reference/language/iterators.html?highlight=iterator" target="_blank" rel="noopener">Итераторы</a> в <code>daScript</code>:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var it &lt;- each ([[<span class="keyword">int</span> <span class="number">1</span>;<span class="number">2</span>;<span class="number">3</span>;<span class="number">4</span>;<span class="number">5</span>]]) <span class="comment">//создание итератора</span></span><br><span class="line">var x : <span class="keyword">int</span></span><br><span class="line"><span class="function"><span class="keyword">while</span> <span class="title">next</span><span class="params">(it, x)</span>      <span class="comment">// получение следующего значения</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"x = &#123;x&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">verify</span><span class="params">(empty(it))</span>      <span class="comment">// функция проверки проверки существования следующего значения</span></span></span><br></pre></td></tr></table></figure><p>Часто в языках есть синтаксический сахар для того, чтобы записывать выражение выше как <code>for-each</code> цикл:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var it &lt;- each ([[<span class="keyword">int</span> <span class="number">1</span>;<span class="number">2</span>;<span class="number">3</span>;<span class="number">4</span>;<span class="number">5</span>]])</span><br><span class="line"><span class="keyword">for</span> x in it</span><br><span class="line">  print(<span class="string">"x = &#123;x&#125;\n"</span>)</span><br></pre></td></tr></table></figure></p><p>Элегантно решаемая внешним итератором задача:</p><p><strong><code>Поиск элемента</code></strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//TT - generic-тип, TT-&amp; - "убрать из определения типа символ ссылки"</span></span><br><span class="line"><span class="function">def <span class="title">find</span><span class="params">(it: iterator&lt;<span class="keyword">auto</span>(TT)&gt;; value:TT-&amp;)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">for</span> x in it</span></span><br><span class="line"><span class="function">    <span class="keyword">if</span> x </span>== value &#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>Более неаккуратное решение</p><p><strong><code>Проверка двух коллекций на равенство</code></strong><br>(и эквивалентные задачи, требуюшие поочередного обращения к двум или более коллекциям — функция <code>zip</code>; итератор выдающий по очереди элементы каждой коллекции)</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">is_equal</span><span class="params">(it1, it2: iterator&lt;<span class="keyword">auto</span>(TT)&gt;)</span></span></span><br><span class="line">  var i2: TT-&amp;</span><br><span class="line">  var it2Ended: <span class="keyword">bool</span></span><br><span class="line">  <span class="keyword">for</span> i1 in it1               <span class="comment">//обращение к первому итератору</span></span><br><span class="line">    it2Ended = next(it2, i2)  <span class="comment">//обращение ко второму итератору</span></span><br><span class="line">    <span class="keyword">if</span> !it2Ended || (i1 != i2)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  <span class="keyword">return</span> !next(it2, i2)</span><br></pre></td></tr></table></figure><p>Неэлегантный пример</p><p><strong><code>Итератор в дереве</code></strong></p><p>Рекурсивная функция печати дерева на экран занимает 4 строки<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span></span></span><br><span class="line"><span class="class">  <span class="title">data</span>:</span> <span class="keyword">int</span></span><br><span class="line">  left, right: Tree?</span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">printTree</span><span class="params">(a: Tree?)</span></span></span><br><span class="line">  if a != null</span><br><span class="line">    printTree(a.left)</span><br><span class="line">    print(<span class="string">"&#123;a.data&#125;\n"</span>)</span><br><span class="line">    printTree(a.right)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">let tree = <span class="keyword">new</span> [[ Tree </span><br><span class="line">    data = <span class="number">5</span>,</span><br><span class="line">    left = <span class="keyword">new</span> [[Tree </span><br><span class="line">      data = <span class="number">1</span></span><br><span class="line">    ]],</span><br><span class="line">    right = <span class="keyword">new</span> [[Tree</span><br><span class="line">      data = <span class="number">7</span>,</span><br><span class="line">      right = <span class="keyword">new</span> [[Tree</span><br><span class="line">        data = <span class="number">10</span></span><br><span class="line">      ]]</span><br><span class="line">    ]]</span><br><span class="line">  ]] </span><br><span class="line">printTree(tree)</span><br></pre></td></tr></table></figure></p><p>Попробуем написать итератор для дерева. Строительным блоком для кастомных внешних итераторов в <code>daScript</code> служат <a href="https://dascript.org/doc/reference/language/lambdas.html?highlight=lambda#iterators" target="_blank" rel="noopener">лямбда-функции</a>.<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IterateState</span></span></span><br><span class="line"><span class="class">  <span class="title">tree</span>:</span> Tree?</span><br><span class="line">  step: <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">var <span class="built_in">stack</span>: <span class="built_in">array</span>&lt;IterateState?&gt;</span><br><span class="line"><span class="built_in">stack</span> |&gt; push(<span class="keyword">new</span> [[IterateState tree = tree]])</span><br><span class="line">unsafe</span><br><span class="line">  let treeIterator &lt;- @ &lt;| (var current: <span class="keyword">int</span>&amp;) : <span class="keyword">bool</span></span><br><span class="line">    var hasValue = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">while</span> !empty(<span class="built_in">stack</span>) &amp;&amp; !hasValue</span><br><span class="line">      var state = back(<span class="built_in">stack</span>)</span><br><span class="line">      <span class="keyword">if</span> state.step == <span class="number">0</span></span><br><span class="line">        state.step = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (state.tree.left != null)</span><br><span class="line">          push(<span class="built_in">stack</span>, <span class="keyword">new</span> [[IterateState tree = state.tree.left]])</span><br><span class="line">      elif state.step == <span class="number">1</span></span><br><span class="line">        state.step = <span class="number">2</span></span><br><span class="line">        current = state.tree.data</span><br><span class="line">        hasValue = <span class="literal">true</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        pop(<span class="built_in">stack</span>)</span><br><span class="line">        <span class="keyword">if</span> (state.tree.right != null)</span><br><span class="line">          push(<span class="built_in">stack</span>, <span class="keyword">new</span> [[IterateState tree = state.tree.right]])</span><br><span class="line">    <span class="keyword">return</span> hasValue</span><br><span class="line">  <span class="keyword">for</span> v in each(treeIterator)</span><br><span class="line">    print(<span class="string">"&#123;v&#125;\n"</span>)</span><br></pre></td></tr></table></figure></p><p>Можно также написать итератор в ООП стиле, определив класс в C++ и перегрузив функцию <a href="https://github.com/GaijinEntertainment/daScript/blob/6f0f1a7025f20cb5a0fc73838e97ba371eb5c263/include/daScript/ast/ast.h#L415" target="_blank" rel="noopener">isIterable</a>, но пример в ООП-стиле есть в [1], он там занимает также занимает 50 строк.</p><p>На <code>daScript</code> получилось 26, но всё равно, как, во имя Святой Матери Тьюринга, из четырёх-строчной рекурсивной функции получилась такая каша?</p><h2 id="Колстек"><a href="#Колстек" class="headerlink" title="Колстек"></a>Колстек</h2><p>Часть работы в функции <code>printTree</code> за нас выполнила скрытая структура данных, <strong><code>callstack</code></strong>. </p><p>Во время рекурсивного первого рекурсивного вызова программа кладёт в стек адрес возврата, и осуществляет вызов этой функции, затем проделывает работу по вызову “полезной нагрузки” (<code>print</code>). После чего в следует второй рекурсивный вызов.</p><blockquote><p>Если на собеседовании у вас спросят, какая у вас любимая структура данных, смело отвечайте “стек вызовов”, и рассказывайте про то, как было бы плохо писать программы без него</p></blockquote><p>Если внимательно посмотреть на структуру функции <code>treeIterator</code>, можно заметить, что она выполняет те же шаги, в той же последовательности!</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">printTree</span><span class="params">(a: Tree?)</span></span></span><br><span class="line"><span class="function">    <span class="comment">//step 0 - кладём в стек адрес возврата, и начинаем новую итерацию вызова функции</span></span></span><br><span class="line"><span class="function">    <span class="title">printTree</span><span class="params">(a.left)</span></span></span><br><span class="line"><span class="function">    <span class="comment">//step 1 - выполняем "полезную нагрузку"</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;a.data&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function">    <span class="comment">//step 2 - кладём в стек адрес возврата</span></span></span><br><span class="line"><span class="function">    <span class="title">printTree</span><span class="params">(a.right)</span></span></span><br><span class="line"><span class="function">    <span class="comment">//невидимый</span></span></span><br><span class="line"><span class="function">    <span class="comment">//step 3 - ..выходим из функции, удаляем из стека верхнее значение, возвращаемся выше по стеку</span></span></span><br></pre></td></tr></table></figure><p>Можно заметить небольшое различие на шаге 2 — в реализации <code>printTree</code> сначала происходит второй рекурсивный вызов, и затем возврат из основной функции, а в <code>treeIterator</code> значение сначала удаляется из стека, а затем в него кладётся новое. Это похоже на то, как происходит <a href="https://en.wikipedia.org/wiki/Tail_call" target="_blank" rel="noopener">tail call optimization</a> — вместо того, чтобы положить в стек второе значение, а потом удалить и два верхних значения, мы сразу же удаляем ненужный более адрес возврата, т.е. выполняем step3, еще до step2.</p><p>Также функция <code>printTree</code> приостанавливается в точках 0 и 2, на момент вызова подпрограммы, и продолжает выполнение после возврата из подпрограммы. Это вторая крутая возможность, которую предоставляет колстек, и о которой при программировании обычно даже не задумываются. Однако при кастомной реализации итератора мы сталкиваемся с тем, что без каких-либо особых трюков приостановить выполнение функции и продолжить его с того же места невозможно. Вместо этого приходится эмулировать паузы с помощью конечного автомата, реализуемого с помощью цикла и переключения пути выполнения изменением переменной <code>state</code>.</p><p>Собственно, большинство идей, связанных с сопрограммами (википедия <a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B0" target="_blank" rel="noopener">напоминает</a>, что ни в коем случае не следует путать их с копрограммами!), так или иначе связаны с тем, чтобы предоставить нам возможность приостанавливать выполнение функции и продолжать его.</p><p>Уже может стать понятно, что для этого язык должен каким-либо образом предоставить языковые конструкции, которые позволили бы нам не определять переменную <code>var stack: array&lt;IterateState?&gt;</code> явно, а “отдавать команду” положить туда что-то неявно, в идеале так же прозрачно, как это происходит в момент вызова функции.</p><p>Также стоит обратить внимание на то, где выделяется и хранится эта переменная. Здесь это просто локальная переменная, захваченная лямбда-функцией, но перед компилятором при реализации сопрограмм стоит серьёзная задача — где разместить этот “другой” стек. С одной стороны — его можно выделить в куче, чтобы он мог “пережить” область создания итератора, с другой — такая аллокация замедляет создание сопрограмм.</p><p>В общем-то, практически все отличия в реализации сопрограмм в разных языках сводятся к тому, чтобы различными способами решить эти вопросы — где и как будут выделяться <em>“другие стеки”</em>, и каким образом к ним можно обращаться из языка. Различных подходов много, и они имеют свои плюсы и минусы. Если с этого момента <em>прояснилось</em>, можно походить по ссылкам, заглянуть, кто что придумал в различных языках. Впрочем, можно снова зависнуть где-нибудь на Лиспе, или языках с ленивыми вычислениями.</p><p>Но пока вернёмся к колстеку — стоит ещё раз сравнить функции <code>printTree</code> и более общую <code>treeIterator</code>, и помедитировать на способ, которым сделано обобщение. Такое представление “невидимого” в коде колстека в явном виде называется <a href="https://en.wikipedia.org/wiki/Reification_(computer_science" target="_blank" rel="noopener">реификацией</a>.</p><h2 id="Внутренние-итераторы"><a href="#Внутренние-итераторы" class="headerlink" title="Внутренние итераторы"></a>Внутренние итераторы</h2><p>Внутренний итератор — функция-callback, которая передаётся в функцию обхода коллекции.</p><p>Итерация разделяет код на 2 части: (1) код ответственный за генерацию серии объектов, и  (2) код, который выполняет над переданным ему объектом некоторую операцию. Для внешних итераторов это (1) тип, который может реализовывать протокол итерации и (2) тело цикла обхода. В этом стиле (2) является главным, он решает, когда запросить следующее значение, или когда прекратить итерации. Внутренние итераторы выворачивают всё наизнанку. Код, который генерирует значения, решает, когда ему вызвать переданный ему колбек.</p><p>Внешние функции, перебирающие значения, могут быть реализованы как методы объекта (<a href="https://apidock.com/ruby/Array/each" target="_blank" rel="noopener">array.each</a> в Ruby), или generic-функции (<a href="https://en.cppreference.com/w/cpp/algorithm/ranges/find" target="_blank" rel="noopener">std::find_if</a> в C++)</p><p>Элегантно решаемые внутренними итераторами задачи:</p><p><strong><code>Итерация по дереву</code></strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">each</span><span class="params">(var tree:Tree?; blk:lambda&lt;(what: <span class="keyword">int</span>):<span class="keyword">void</span>&gt;)</span></span></span><br><span class="line"><span class="function">  <span class="title">if</span> <span class="params">(tree.left != null)</span>  </span>&#123; each(tree.left, blk); &#125;</span><br><span class="line">  invoke(blk, tree.data)</span><br><span class="line">  <span class="keyword">if</span> (tree.right != null) &#123; each(tree.right, blk); &#125;</span><br><span class="line"></span><br><span class="line">tree |&gt; each() &lt;| @(value: <span class="keyword">int</span>)</span><br><span class="line">  print(<span class="string">"&#123;value&#125;\n"</span>)</span><br></pre></td></tr></table></figure><p>Отлично, в 3 строчки.</p><p><strong><code>Поиск элемента</code></strong></p><p>Возьмём общий внутренний генератор <code>map</code> из стандартной-библиотеки <a href="https://github.com/GaijinEntertainment/daScript/blob/master/daslib/functional.das" target="_blank" rel="noopener">functional</a> функцию поиска индекса элемента в массиве по условию (это синтетический пример, в модуле <code>buildin</code> есть более эффективная реализация этой <a href="https://github.com/GaijinEntertainment/daScript/blob/a7c6565f652b56d0eee82b6e27974cdc09f06574/src/builtin/builtin.das#L701" target="_blank" rel="noopener">функции</a>)</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">my_find_index_if</span><span class="params">(var arr: iterator&lt;<span class="keyword">auto</span>(TT)&gt; <span class="keyword">explicit</span>; blk:lambda&lt;(what:TT -&amp;):<span class="keyword">auto</span>(QQ)&gt;)</span></span></span><br><span class="line">  for value, i in map(arr, blk), range(INT_MAX)</span><br><span class="line">    <span class="keyword">if</span> value</span><br><span class="line">      <span class="keyword">return</span> i</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//using</span></span><br><span class="line">var it &lt;- each ([[<span class="keyword">int</span> <span class="number">0</span>;<span class="number">1</span>;<span class="number">2</span>;<span class="number">3</span>;<span class="number">4</span>]])</span><br><span class="line">var answer = it |&gt; my_find_index_if &lt;| @(value: <span class="keyword">int</span>)</span><br><span class="line">  print(<span class="string">"check: &#123;value&#125;\n"</span>)</span><br><span class="line">  <span class="keyword">return</span> value &gt; <span class="number">1</span></span><br><span class="line">print(<span class="string">"&#123;answer&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">check: <span class="number">0</span></span><br><span class="line">check: <span class="number">1</span></span><br><span class="line">check: <span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>Здесь таится интересный момент, связанный с прерыванием итерации. Почему функция <code>map</code> не выполнила проверку 3 и 4 элемента массива? Каким именно образом функция <code>map</code> “узнала”, что нужно остановить итерацию?<br>Если вы попробуете реализовать функцию <code>find_index</code> с помощью <code>std::for_each</code> в C++, то стокнётесь в проблемой, что <code>return</code> не может остановить итерацию <code>for_each</code>.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_index</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; myvector, <span class="built_in">std</span>::function&lt;<span class="keyword">bool</span>(<span class="keyword">int</span>)&gt; checker)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> answer = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">bool</span> answerFound = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">auto</span> fn = <span class="built_in">std</span>::for_each(myvector.begin(), myvector.end(), [&amp;](<span class="keyword">int</span> i) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"check:"</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span> (!answerFound) &#123;</span><br><span class="line">            <span class="keyword">if</span>(checker(i)) &#123;</span><br><span class="line">                answer = i;</span><br><span class="line">                answerFound = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">//невозможно остановить выполнение for_each</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; find_index(myvector, [](<span class="keyword">int</span> i) &#123;</span><br><span class="line">      <span class="keyword">return</span> i &gt; <span class="number">1</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; find_index(myvector);</span><br><span class="line"><span class="comment">//Output</span></span><br><span class="line">check:<span class="number">0</span></span><br><span class="line">check:<span class="number">1</span></span><br><span class="line">check:<span class="number">2</span></span><br><span class="line">check:<span class="number">3</span></span><br><span class="line">check:<span class="number">4</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>Что именно мешает лямбда-функции, переданной в <code>for_each</code> прекратить итерацию? Ответ - колстек, а точнее стекфрейм функций. В момент вызова лямбда-функции внутри for_each он выглядит так:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main</span><br><span class="line">  find_index</span><br><span class="line">    for_each</span><br><span class="line">    стекфрейм for_each</span><br><span class="line">      for_each_lambda</span><br><span class="line">        checker_lambda</span><br></pre></td></tr></table></figure></p><p><code>for_each</code> как и любая функция, может выделить себе дополнительную память на стеке под свои нужны, и если <code>for_each_lambda</code> или <code>checker_lambda</code> захотят выйти на уровень выше <code>for_each</code>, им нужно уметь раскручивать стек (скорее всего, конкретно для for_each там ничего нет, но сама необходимость раскрутки всего, что находится между функциями разного уровня на стеке блокирует возможность выхода)</p><p>Конечно, раскручивать стек в C++ умеют исключения, но… просто посмотрите на этот код и никогда так не делайте:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_index</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; myvector, <span class="built_in">std</span>::function&lt;<span class="keyword">bool</span>(<span class="keyword">int</span>)&gt; checker)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">auto</span> fn = <span class="built_in">std</span>::for_each(myvector.begin(), myvector.end(), [&amp;](<span class="keyword">int</span> i) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"check:"</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">if</span>(checker(i)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> i; <span class="comment">//"выбрасываем" ответ из foreach</span></span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (<span class="keyword">int</span> throwedAnswer) &#123;</span><br><span class="line">        <span class="keyword">return</span> throwedAnswer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Возможность раскручивать стек называется <code>non-local returns</code> и присутствует в языках типа <code>Ruby</code> (пример в [1]) или <code>Kotlin</code> [24]:<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">val</span> value = <span class="number">3</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="string">""</span></span><br><span class="line">list.forEach &#123; </span><br><span class="line">  result += <span class="string">"<span class="variable">$it</span>"</span></span><br><span class="line">  <span class="keyword">if</span> (it == value)</span><br><span class="line">    <span class="keyword">return</span><span class="symbol">@forEach</span> <span class="comment">//выход из foreach</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//result="123"</span></span><br></pre></td></tr></table></figure></p><p>Другой более универсальный подход, реализованный в <code>daScript</code> и других языках с поддержкой генераторов — приостанавливать выполнение <code>map/for_each</code> и передавать промежуточные результаты “вовне”, с возможностью по желанию прекратить приостановленную итерацию на уровень выше (генераторы также известны как “елды” среди добравшихся до Unity артистов).</p><p>Совсем нехороший пример</p><p><strong><code>Проверка двух коллекций на равенство</code></strong></p><p>Без задействования генераторов, корутин, потоков или продолжений, или других способов приостановить функцию, не пишется. Мешают, как и в предыдущем примере, всё те же стекфреймы в колстеке. Но если в примере с ранним выходом из внутреннего итератора удавалось хотя бы выкрутиться хаком и “выпрыгнуть” с помощью исключений, необратимо раскрутив стек, то здесь для приостановки каждой из двух функций-колбеков нужно хранить оба состояния обеих функций.</p><h2 id="Генераторы"><a href="#Генераторы" class="headerlink" title="Генераторы"></a>Генераторы</h2><p>Генераторы — это возобновляемые функции. Возвращаемый тип генератора — итератор (гибрид между внутренним и внешним)</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">let gen &lt;- generator&lt;<span class="keyword">int</span>&gt;() &lt;| $()</span><br><span class="line">  <span class="function"><span class="keyword">for</span> t in <span class="title">range</span><span class="params">(<span class="number">0</span>,<span class="number">10</span>)</span></span></span><br><span class="line"><span class="function">    yield t</span></span><br><span class="line"><span class="function">  <span class="keyword">return</span> <span class="literal">false</span></span></span><br></pre></td></tr></table></figure><p><code>map</code>, как и большинство функций из модуля <code>functional</code> в <code>daScript</code>, возвращают генераторы, так что с помощью неё должно быть возможно (хотя и не нужно) реализовать проверку двух коллекций на равенство, недоступную для внутренних итераторов в языках без поддержки генераторов:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">is_equal</span><span class="params">(var it1, it2: iterator&lt;<span class="keyword">auto</span>(TT)&gt;)</span></span></span><br><span class="line"><span class="function">  unsafe</span></span><br><span class="line"><span class="function">    var equalResult </span>= <span class="literal">true</span></span><br><span class="line">    <span class="comment">//один из генераторов возвращает значения из коллекции</span></span><br><span class="line">    var aGenerator &lt;- it1 |&gt; <span class="built_in">map</span> &lt;| @(aValue:TT-&amp;)</span><br><span class="line">      <span class="keyword">return</span> aValue</span><br><span class="line">    //второй генератор берёт значение из второй коллекции и сравниваем со значением из другого генератора</span><br><span class="line">    //лямбда-функция захватывает первый генератор для получения значений из него</span><br><span class="line">    var bGenerator &lt;- it2 |&gt; <span class="built_in">map</span> &lt;| @ [[&amp;aGenerator]](bValue:TT-&amp;)</span><br><span class="line">      var aValue : TT-&amp;</span><br><span class="line">      <span class="keyword">if</span> !next(aGenerator, aValue)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      print("&#123;bValue&#125; &#123;aValue&#125;\n")</span><br><span class="line">      <span class="keyword">return</span> bValue == aValue</span><br><span class="line">    //продолжаем брать из генераторов значения, пока она эквивалентны</span><br><span class="line">    <span class="keyword">while</span> equalResult &amp;&amp; next(bGenerator, equalResult)</span><br><span class="line">      pass</span><br><span class="line">    //коллекции эквивалентны, если оба итератора обработали все значения</span><br><span class="line">    var aLast : <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">return</span> !next(aGenerator, aLast) &amp;&amp; empty(bGenerator)</span><br></pre></td></tr></table></figure><p><strong><code>Двунаправленные генераторы</code></strong></p><p><code>Python</code> поддерживает также <a href="https://docs.python.org/3/reference/expressions.html#generator.send" target="_blank" rel="noopener">отправку</a> данных генератору из вызывающего кода</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">double_inputs</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="meta">... </span>        x = <span class="keyword">yield</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">yield</span> x * <span class="number">2</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gen = double_inputs()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(gen)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gen.send(<span class="number">10</span>)</span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(gen)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gen.send(<span class="number">6</span>)</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure><h2 id="Разворачивание-итераторов"><a href="#Разворачивание-итераторов" class="headerlink" title="Разворачивание итераторов"></a>Разворачивание итераторов</h2><p>Теперь рассмотрим возможность “выворачивания” итераторов. К примеру, у нас есть “красивая” версия внутреннего итератора <code>each</code> для дерева, и функция сравнения, принимающая внешние итераторы, в которую хочется передать итератор обхода дерева.</p><p>Для начала посмотрим, как можно передать значения из лямбда функции “наружу”, с помощью захвата в замыкание (closure) лямбда-функции:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">to_array</span><span class="params">(var tree : Tree?)</span></span></span><br><span class="line"><span class="function">  unsafe</span></span><br><span class="line"><span class="function">    var arr: <span class="built_in">array</span>&lt;<span class="keyword">int</span>&gt;</span></span><br><span class="line"><span class="function">    <span class="comment">//захватываем arr в замыкание по ссылке</span></span></span><br><span class="line">    each(tree) &lt;| @[[&amp;arr]](value: int)</span><br><span class="line">      arr |&gt; push(value)</span><br><span class="line">    <span class="keyword">return</span> &lt;- arr</span><br></pre></td></tr></table></figure><p>Функция накапливает все значения в переменной <code>arr</code> и возвращает полностью собранный массив. Следующим шагом попробуем избавиться от этого накопления и вернуть управление вызывающему коду, как только будет получено следующее значение из <code>each</code>. Но тут возникает следующая проблема. Если <code>each</code> не задизайнена так, чтобы её можно было останавливать, то её и невозможно будет остановить из колбека. Т.е. нам нужна другая функция <code>each_async</code>, которая будет возвращать значение через генератор <code>yield</code>.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">each_async</span><span class="params">(tree:Tree?)</span> : iterator&lt;<span class="keyword">int</span>&gt;</span></span><br><span class="line">    return &lt;- generator&lt;int&gt;() &lt;| $ ()</span><br><span class="line">      <span class="keyword">if</span> tree.left != null</span><br><span class="line">        <span class="keyword">for</span> newVal in each_async(tree.left)</span><br><span class="line">          yield newVal</span><br><span class="line">      yield tree.data</span><br><span class="line">      <span class="keyword">if</span> tree.right != null</span><br><span class="line">        <span class="keyword">for</span> newVal in each_async(tree.right)</span><br><span class="line">          yield newVal</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">var eq = is_equal(each_async(tree1), each_async(tree2))</span><br></pre></td></tr></table></figure><p>Чуть менее компактно, чем первоначальная версия, за счёт того, что из вложенных генераторов приходится доставать данные с помощью дополнительных циклов обхода (<code>yield</code> должно возвращать <code>int</code>, а вложенный генератор возвращает <code>iterator&lt;int&gt;</code>, из которого нужно достать данные для выдачи внешнему генератору).</p><p><code>Python</code> и некоторые другие языки поддерживают <strong><code>делегацию генераторов</code></strong> — синтаксический сахар, который позволяет избежать написания таких циклов<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">concat</span><span class="params">(a, b)</span>:</span></span><br><span class="line">  <span class="comment">#for item in walkFirst(a): yield item</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">#"берём значение из генератора и передаём дальше</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="keyword">from</span> walkFirst(a)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">walkFirst</span><span class="params">(a)</span>:</span></span><br><span class="line">  <span class="keyword">for</span> item <span class="keyword">in</span> a: <span class="keyword">yield</span> item</span><br></pre></td></tr></table></figure></p><p><strong>update</strong><br>Аналогичный макрос <a href="https://github.com/GaijinEntertainment/daScript/commit/3acb98e7c13456f59c73f482ef4396481cf30293" target="_blank" rel="noopener">yield_from</a> для <code>daScript</code></p><p>Но тут есть важный момент, снова возвращающий нас к колстекам. Делегация генераторов — это просто синтаксический сахар, но мы не можем написать возврат значения из вложенных функций, не прокидывая эту делегацию через каждый уровень вложенности. Чтобы полноценно выйти на несколько уровней вверх, в затем вернуться, нам потребуется структура, которая реифицирует не один уровень стека, а весь стек. Следующий пример на <code>ruby</code> показывает такую структуру.</p><h2 id="Файберы"><a href="#Файберы" class="headerlink" title="Файберы"></a>Файберы</h2><p>В [2] есть пример разворачивания итераторов из <code>Ruby</code>:</p><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyEnumerator</span></span></span><br><span class="line">  <span class="keyword">include</span> Enumerable</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(obj)</span></span></span><br><span class="line">    @fiber = Fiber.new <span class="keyword">do</span>  <span class="comment"># Spin up a new fiber.</span></span><br><span class="line">      obj.each <span class="keyword">do</span> <span class="params">|value|</span>  <span class="comment"># Run the internal iterator on it.</span></span><br><span class="line">        Fiber.<span class="keyword">yield</span>(value) <span class="comment"># When it yields a value, suspend</span></span><br><span class="line">                          <span class="comment"># the fiber and emit the value.</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      raise StopIteration  <span class="comment"># Then signal that we're done.</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">next</span></span></span><br><span class="line">    @fiber.resume          <span class="comment"># When the next value is requested,</span></span><br><span class="line">                           <span class="comment"># resume the fiber.</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><code>Yield</code> происходит прямо из <code>each</code> во внешнюю функцию! Если обратиться к предыдущим замечаниям про колстеки, то здесь будет:</p><ul><li><code>each</code> для дерева создаёт стек, в котором хранит адреса возвратом рекурсивных вызовов</li><li>метод <code>next</code> полностью “замораживает” этот стек, и переключается на другой, в управляющем коде.</li></ul><p>Так что <code>Fiber</code> здесь — структура, которая реифицирует не только фрейм стека, как генераторы, но весь стек полностью.<br><code>Файберы</code> имеют свой стек и копии локальных переменных. Один выполняются в одном потоке, и передача управления между ними управляется кодом пользователя — пока один файбер не передаст управление следующему, переключения не будет.</p><p>Файберы — своеобразная “точка связи” итерации с параллелизмом.</p><h2 id="Функции-без-стекфрейма"><a href="#Функции-без-стекфрейма" class="headerlink" title="Функции без стекфрейма"></a>Функции без стекфрейма</h2><p>В [12] рассматриваются альтернативы хранению временных переменных функции в стеке. В качестве примера рассматривается создание языков для визуального программирования типа <code>Kismet</code>/<code>Blueprint</code> из Unreal. Каждая функция-строительный кирпич заранее выделяет необходимую ей память и просто использует её повторно, если вызывается вновь. Если нужно вызвать функцию дважды — выделяется два блока памяти. Преимущество такого подхода — можно легко связывать цепочки функций вида “пойти в точку А, подождать секунду, затем проиграть анимацию и звук одновременно”.</p><p>Чтобы создать код связи нод на C++, может потребоваться код вида:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> bMoved = <span class="literal">false</span>;</span><br><span class="line">CompareBoolNode * cmp = <span class="keyword">new</span> CompareBoolNode(bMoved);</span><br><span class="line">DelayNode * first_delay = <span class="keyword">new</span> DelayNode(some_hardcoded_number);</span><br><span class="line">DelayNode * second_delay = <span class="keyword">new</span> DelayNode(another_hardcoded_number);</span><br><span class="line">DelayNode * third_delay = <span class="keyword">new</span> DelayNode(a_third_hardcoded_number);</span><br><span class="line">MatineeNode * matinee = <span class="keyword">new</span> MatineeNode(Matinee_0, Interior_Elevator_3);</span><br><span class="line">BoolNode * set_moved = <span class="keyword">new</span> BoolNode(bMoved, <span class="literal">true</span>);</span><br><span class="line">BoolNode * clear_moved = <span class="keyword">new</span> BoolNode(bMoved, <span class="literal">false</span>);</span><br><span class="line">cmp-&gt;onFalse += &amp;first_delay-&gt;start</span><br><span class="line">first_delay-&gt;onFinished += &amp;matinee-&gt;play;</span><br><span class="line">matinee-&gt;onCompleted += &amp;second_delay-&gt;start;</span><br><span class="line">second_delay-&gt;onFinished += &amp;matinee-&gt;reverse;</span><br><span class="line">second_delay-&gt;onFinished += &amp;set_moved-&gt;in;</span><br><span class="line">set_moved-&gt;out += &amp;third_delay-&gt;start;</span><br><span class="line">third-&gt;delay-&gt;onFinished = &amp;clear_moved-&gt;in;</span><br><span class="line"> </span><br><span class="line">RTriggerVolume_0.onTouched += &amp;cmp-&gt;in;</span><br></pre></td></tr></table></figure></p><p> При этом, на самом деле программист хотел бы написать этот же код, в таком виде:</p> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> bMoved = <span class="literal">false</span>;</span><br><span class="line">RTriggerVolume_0.Touched = [bMoved]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (bMoved)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    Delay(some_hardcoded_delay);</span><br><span class="line">    Matinee_0.Play(Interior_Elevator_3);</span><br><span class="line">    Delay(another_hardcoded_delay);</span><br><span class="line">    bMoved = <span class="literal">true</span>;</span><br><span class="line">    Matinee_0.Reverse(Interior_Elevator_3);</span><br><span class="line">    Delay(a_third_hardcoded_delay);</span><br><span class="line">    bMoved = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> Проблема в том, что в C++ сложно нет функции <code>Delay</code>. Файберы могут помочь с её реализацией, но иметь отдельный стек для каждой мелкой сопрограммы может быть дорого. Вместо этого компиляторы визуальных языков могут подсчитать, сколько памяти потребуется для всего скрипта, и выделить ему это весь этот блок целиком. Таким образом, во время выполнения нет аллокаций. Это не особо влияет на скорость, но влияет на то, все функции такого языка могут быть в любой момент прерваны и возобновлены — функции без фреймов на стеке не страдают от того, что кто-то другой перехватывает управление.</p><h2 id="Корутины-в-C"><a href="#Корутины-в-C" class="headerlink" title="Корутины в C++"></a>Корутины в C++</h2><p><strong><code>Реализация замаскированным конечным автоматом</code></strong><br>В [13] приведён хак-пример с тем, чтобы реализовать корутины с ограничениями на макросах с помощью объединения цикла и <code>switch</code> (грязный трюк, названный метод Даффа).</p><p><strong><code>Реализации корутин в виде платформо-зависимых библиотек</code></strong><br>Серьёзные реализации, использующие трюки на ассемблере или ucontext — [18] и [19] от Malte Skarupke и [20] <code>Boost::Context</code> от Oliver Kowalke. От него же, <a href="https://www.boost.org/doc/libs/?view=category_concurrent" target="_blank" rel="noopener">реализации</a> <code>coroutine2</code>(с выделением стеков на хипе, и first-class продолжениями) и <code>fiber</code> (<a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4024.pdf" target="_blank" rel="noopener">отличия</a> между ними, файбер здесь — green thread, поток, управляемый диспетчером. Файберы “живут” в одном кернел-треде. Ключевое отличие - корутины передают управление друг другу, буст-файберы — планировщику).</p><p>Бекграунд для реализации буст библиотек — переключатели контекста (через примитив <code>call/cc</code> из <code>Boost::Context</code>).</p><ul><li>fcontext_t - переключение асм-кодом (самое быстрое)</li><li>ucontext_t и WinFiber - в <a href="https://www.boost.org/doc/libs/1_79_0/libs/fiber/doc/html/fiber/overview/implementations__fcontext_t__ucontext_t_and_winfiber.html" target="_blank" rel="noopener">10-100 раз</a> более медленное переключение с использованием функций ядра ОС</li></ul><blockquote><p>Хороший ответ на вопросы из собеседований вроде “зачем может потребоваться писать код на ассемблере в 20XX году?”</p></blockquote><p><strong><code>Корутины из стандарта C++20</code></strong></p><p>В стандарте C++ 20 года реализована минимальная поддержка корутин. Корутины из стандарта, в отличие от <code>boost:coroutine</code> не имеют своего стека (стандарт отделался тем, что заявил “если хотите возвращать управление из вложенных функций — вам нужны файберы, а не корутины”). Также не содержит в std готовых примитивов-паттернов для удобной работы, вариант их реализации можно посмотреть в библиотеке <code>cppcoro</code> [16].</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Visitor</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">f</span>(<span class="title">Visitor</span>&amp; <span class="title">v</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//stackfull-корутина с передачей управления, boost::context</span></span><br><span class="line">asymmetric_coroutine&lt;T&gt;::<span class="function">pull_type <span class="title">pull_from</span><span class="params">([](asymmetric_coroutine&lt;T&gt;::push_type&amp; yield) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    f(yield);</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//stackless-корутина, C++ 20</span></span><br><span class="line"><span class="function">generator&lt;T&gt; <span class="title">pull_from</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// yield может быть вызвана только отсюда</span></span><br><span class="line">    f(???);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Можно вернуться к примерам с разворачиванием итераторов на <code>daScript</code> и <code>ruby</code>, и попробовать “спроецировать” их на синтаксис stackful-корутин.</p><p>В <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3708.pdf" target="_blank" rel="noopener">пропозале</a> по добавлению <code>boost::coroutine</code> в стандарт <code>C++</code> приведён как раз аналогичный пример с деревом, с явным продолжением-аргументом он выглядит впечатляюще круто:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> ContPush = boost::coroutines::coroutine&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;::push_type;</span><br><span class="line"><span class="keyword">using</span> ContPull = boost::coroutines::coroutine&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;::pull_type;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(tree* n, ContPush&amp; out)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n-&gt;left) traverse(n-&gt;left, out);</span><br><span class="line">  out(n-&gt;value);</span><br><span class="line">  <span class="keyword">if</span>( n-&gt;right) traverse(n-&gt;right, out);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tree* tree1 = testCreateTree1(), tree2 = testCreateTree2();</span><br><span class="line"></span><br><span class="line"><span class="comment">//трансформация внутреннего итератора во внешний</span></span><br><span class="line"><span class="function">ContPull&amp; <span class="title">iterator1</span><span class="params">([&amp;](ContPush&amp; out) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  traverse(tree1, out);</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ContPull&amp; <span class="title">iterator2</span><span class="params">([&amp;](ContPush&amp; out) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  traverse(tree2, out);</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//у boost::coroutines::coroutine&lt;std::string&gt;::pull_type есть iterator</span></span><br><span class="line"><span class="keyword">bool</span> isEqual = <span class="built_in">std</span>::equal(<span class="built_in">std</span>::begin(iterator1), <span class="built_in">std</span>::end(iterator1), <span class="built_in">std</span>::begin(itertor2));</span><br></pre></td></tr></table></figure><p>Stackless-корутины не позволяют таких трюков, так как используют стек вызывающего их кода, но более эффективны.<br>Benchmark из либы <a href="https://github.com/jamboree/co2" target="_blank" rel="noopener">CO2</a>, эмулирующей stackless-корутины (цена вызова корутины):<br><img src="/blog/2550823652/co2_benchmark.png" alt="bench"></p><p>Кроме вызова важна также стоимость создания корутины. В случае с <code>CO2</code> корутина — это только синтаксический сахар, и код работает быстро (но в этой библиотеки и нельзя “захватить” переменные на стеке в корутину после восстановления). В корутинах из стандарта C++, генерируется код с аллокацией таких данных в куче, и затем компилятор <strong>может</strong> оптимизировать эти аллокации в случае, если код удастся трансформировать и инлайнить. Сделает он это или нет — неизвестно.</p><p>В [14] Malte Skarupke приводит примеры, когда это не работало даже в относительно простых случаях, когда должно быть возможно. Узнать, будет или нет выполнена оптимизация — сложно, а разница в скорости между двумя вариантами — на два порядка, так что часто создавать корутины, полагаясь на то, что будет быстро, без постоянных проверок сгенерированного кода невозможно. Как происходит трансформация кода в LLVM детально рассматривается в [17] (ещё один большой кусок информации, которую должен держать в голове хороший C++ программист). Вдобавок меня пугает то, что такая трансформация требует повторного прохода всех стадий оптимизации (если я правильно понял презентацию, 32:14), время сборки большой программы — больное место языка.</p><p>Кому хотелось конкурентности, много лет как запилили себе файберы (чаще всего пулом, чтобы без переаллокаций, и с явным или неявным разбросом по тредам):<br><a href="https://www.gdcvault.com/play/1022186/Parallelizing-the-Naughty-Dog-Engine" target="_blank" rel="noopener">Naughty Dog: Parallelizing the Naughty Dog Engine Using Fibers</a><br><a href="https://www.youtube.com/watch?v=v2Q_zHG3vqg" target="_blank" rel="noopener">Multithreading the Entire Destiny Engine</a></p><p>Где-то дочитав досюда можно почитать туториал [15] по корутинам в C++ 20 и посмотреть на libcoro [16].</p><h2 id="Различия-в-терминологии"><a href="#Различия-в-терминологии" class="headerlink" title="Различия в терминологии"></a>Различия в терминологии</h2><p>Стоит отметить различие в определении файберов в различных языках. В некоторых файберы отличаются от генераторов только тем, что имеют стек. Такую таксономию например предлагает стандарт <code>C++ 20</code>. В других языках файберы может отличать ещё и то, что они передают управление не другому файберу, а диспетчеру, который выбирает, кому передать управление дальше.</p><p>Например, <code>boost::coroutine</code> называет корутину со стеком не файбером а <code>stackful coroutine</code>, а <code>fiber</code> — это то же + управление через диспетчер. Я тут встану на сторону C++ 20, потому что для корутин со стеком (файберов), которые вдобавок ещё и управляемые диспетчером, и так придумана куча названий. Встречаются:</p><ul><li><a href="http://www.lua.org/pil/9.html" target="_blank" rel="noopener">просто корутины</a> (в <code>lua</code> для большей путаницы назвали это так)</li><li><a href="https://github.com/stackless-dev/stackless/wiki/" target="_blank" rel="noopener">тасклеты</a> (<code>Stackless Python</code>, вообще богат на термины)</li><li><a href="https://go.dev/doc/effective_go#goroutines" target="_blank" rel="noopener">горутины</a> из <code>golang</code> ([22], [23]), причисляемыми в статьях к файберам, отличаются по функционалу, и могут раскидываться по различным тредам планировщиком задач языка (а следовательно, требуют синхронизации доступа к общим ресурсам), так что должны рассматривать отдельно.</li><li>зелёные потоки, протопотоки, микропотоки</li></ul><p>На этом закончу первую половину статьи. Вторая будет про диспетчеры, способы блокирования и комбинирования различных корутин между собой.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;Малость ны
      
    
    </summary>
    
    
    
      <category term="dev" scheme="http://spiiin.github.io/tags/dev/"/>
    
      <category term="link" scheme="http://spiiin.github.io/tags/link/"/>
    
      <category term="dascript" scheme="http://spiiin.github.io/tags/dascript/"/>
    
      <category term="cpp" scheme="http://spiiin.github.io/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>daScript - скорость</title>
    <link href="http://spiiin.github.io/blog/1067581840/"/>
    <id>http://spiiin.github.io/blog/1067581840/</id>
    <published>2022-07-27T14:05:01.000Z</published>
    <updated>2022-10-01T16:37:18.122Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Рассказывал о <code>daScript</code> коллеге в отпуске, в ответ на то, почему он такой быстрый, задумался, что особо коротко и не ответишь, не влезая в детали реализации, проще замерить. Очень поверхностно:</p><h2 id="Заявленное-авторами"><a href="#Заявленное-авторами" class="headerlink" title="Заявленное авторами"></a>Заявленное авторами</h2><p>(<a href="https://dascript.org/doc/reference/introduction.html#performance" target="_blank" rel="noopener">Performance</a>, <a href="https://dascript.org/" target="_blank" rel="noopener">overview</a>, <a href="https://dascript.org/doc/reference/embedding/vm.html" target="_blank" rel="noopener">VM</a>):</p><ul><li>Быстрый интероп в C++ и обратно.</li><li>AoT, чтобы вообще убрать интероп, в случаях, когда можно транспилировать в C++ вместо интерпретации.</li><li>Кастомные аллокаторы для строк и хипа. Плюс политика для отдельных скриптов, в которых не нужно хранить выделенное — быстро перезапустить всю виртуальную машину, прибив всё аллоцированное без освобождения. Политика управления памятью или сохранения состояния может быть кастомизирована на стороне C++ — модель памяти daScript максимально простая и быстрая.</li><li>Использование hardware-friendly типов для нод, поддержка векторных типов в языке (в геймдеве повсюду встречаются vec4 и mat4 — многие алгоритмы просто векторизировать).</li></ul><h2 id="AoT"><a href="#AoT" class="headerlink" title="AoT"></a>AoT</h2><p>Код, скомпиленный из daScript в C++, может получиться быстрее среднего C++ кода, так же как компилятор может перевести C++ в более быстрый ассемблерный код, чем средний код, написанный на ассемблере. Причина в том, что при выборе вариантов реализации asm инструкций может быть много вариантов, из которых компилятор может выбрать более быстрый, чем рядовой программист. Т.е. если авторы языка хорошо представляют себе, во что скомпилиться сгенерированный C++ код, то теоретически, они могут сгенерировать код лучше, чем написанный средним программистом.</p><p>Кроме <code>daScript</code>, транспиляцию в C++ поддерживает <code>Nim</code>, который на тестах также выдаёт очень хорошие результаты. Скорее всего, генерировать LLVM код было бы эффективнее, что и планируют делать авторы языка в будущем, однако и генерация быстрого C++-кода делает эти языки очень быстрыми уже сейчас.</p><h2 id="Перестройка-кода"><a href="#Перестройка-кода" class="headerlink" title="Перестройка кода"></a>Перестройка кода</h2><p>Данные и код на daScript можно кастомизировать (<a href="/blog/1547564887/" title="макросы">макросы</a>, преобразовывающие AST, а также <a href="https://github.com/GaijinEntertainment/daScript/blob/250c5124dc1ce5e56933d42d15ef5e209d30dd20/include/daScript/ast/ast.h#L340" target="_blank" rel="noopener">перегрузка</a> simulate и visit, <a href="https://github.com/GaijinEntertainment/daScript/blob/985eaeda9ec6d4c594f9f9583ce3b14aed023d91/include/daScript/das_config.h#L74" target="_blank" rel="noopener">fusion engine</a> для паковки инструкций), это делать намного легче чем на C++. Пример из <a href="https://youtu.be/IvHGczF6Go0?t=2565" target="_blank" rel="noopener">доклада</a>, про разницу подходов при задаче раскладывания данных data-oriented для ECS фреймворка, на C++ и на daScript.</p><p>Наверное, чё-то ещё есть, лучше у авторов уточнить.</p><h2 id="Доверие-авторам"><a href="#Доверие-авторам" class="headerlink" title="Доверие авторам"></a>Доверие авторам</h2><p>Отдельный очевидный момент — быстрый код на языке следует из идеи языка. Если авторы всячески <a href="/blog/2630317622/" title="декларируют">декларируют</a> желание сделать быстрый язык и продолжать разгонять его — то они и будут делать именно это.</p><p>Косвенный признак возможности сделать что-то в языке быстро — наличие специализированных оптимизированных конструкций/структур/алгоритмов (block+lambda, string+das_string, array<T>+int[N] etc).</p><p>Почему я верю конкретно в этот язык — потому что давно видел изнутри движки <code>Gaijin</code>, их тулзы, и знаю качество их кода и используемые скриптовые языки. Ковырял все доступные материалы по скриптовым языкам <code>Naughty Dogs</code> (книга “Архитектура игровых движков”, доклады про использование Lisp-а как языка описания данных и скриптового языка в играх), некоторые идеи из которых, по интервью с автором, реализованны в <code>daScript</code>. Ну и сам Борис Баткин, небезызвестен в русском геймдев-комьюнити еще образца 2000х годов (<a href="https://web.archive.org/web/20071218053755/http://blog.gamedeff.com/?p=64" target="_blank" rel="noopener">интервью глазами пострадавшего</a>), да и просто <a href="https://www.mobygames.com/developer/sheet/view/developerId,53108/" target="_blank" rel="noopener">интересный человек</a>, скорее всего знает толк в быстром коде.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;Рассказыва
      
    
    </summary>
    
    
    
      <category term="dascript" scheme="http://spiiin.github.io/tags/dascript/"/>
    
  </entry>
  
  <entry>
    <title>Эволюция программиста в геймдеве</title>
    <link href="http://spiiin.github.io/blog/4256110900/"/>
    <id>http://spiiin.github.io/blog/4256110900/</id>
    <published>2022-07-27T09:50:03.000Z</published>
    <updated>2022-08-01T11:26:06.937Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Модели развития сотрудника в геймдеве.</p><h2 id="Т-модель-от-Valve"><a href="#Т-модель-от-Valve" class="headerlink" title="Т-модель от Valve"></a>Т-модель от Valve</h2><p><img src="/blog/4256110900/tmodel.png" alt="tmodel"><br>Из <a href="http://media.steampowered.com/apps/valve/hbook-RU.pdf" target="_blank" rel="noopener">руководства новых сотрудников Valve</a><br>Программист растёт не линейно, а в нескольких областях, и чтобы отразить это, в <code>Valve</code> придумали T-модель развития сотрудников:</p><p>На картинке Heavy - класс из Team Fortress 2. Он широко расставил руки, что показывает его атрибуты — Хэви понемногу разбирается в:</p><ul><li>Приготовлении бутербродов,</li><li>Убийстве людей</li><li>Русских народных танцах</li><li>Уберзарядах.<br>Он прокачивает широкий спектр навыков, чтобы уметь всего понемногу, но основная его компетенция - это Тяжёлое оружие (высокий скилл -&gt; рост персонажа)</li></ul><h2 id="Модель-костюмов-Марио-от-Betheda"><a href="#Модель-костюмов-Марио-от-Betheda" class="headerlink" title="Модель костюмов Марио от Betheda"></a>Модель костюмов Марио от Betheda</h2><p><img src="/blog/4256110900/mario_model.png" alt="mario_model"><br><a href="https://www.slideshare.net/JoelBurgess/3-10gdc2014-iterativeleveldesignprocess" target="_blank" rel="noopener">Отсюда</a><br><code>Betheda</code> практически не расширяет команды в ходе разработки проекта, поэтому  незанятые на текущем этапе отделы могут заняться чем-либо другим (переодеваются в другой костюм-профессию). В примере из доклада, на ранних стадиях левел-дизайнеры могут помогать в написании сюжета, геймдизайне механик (Layout, Gameplay, Markup, Scripting, Performance, Writing, Systems, Prototyping, Tools, more…), попутно прокачиваясь в том, что может быть полезно команде. Цель — создание небольших команд, состоящих из широкопрофильных специалистов.</p><h2 id="Модель-профессий-из-Final-Fantasy-Tactics"><a href="#Модель-профессий-из-Final-Fantasy-Tactics" class="headerlink" title="Модель профессий из Final Fantasy Tactics"></a>Модель профессий из Final Fantasy Tactics</h2><p>Если выбирать аналогии из игр, на мой взгляд профессии в геймдеве напоминают систему профессий из <code>Final Fintasy Tactics</code>.</p><p>Изначально специалисту доступны “примитивные” профессии, совершенствуясь в которых он осваивает некоторые навыки. После полноценного освоения нескольких навыков специалист может как оставаться в рамках этой же профессии и продолжать качаться в ней. Более продвинутые профессии имеют требования к наличию навыков в более низких.</p><p><img src="/blog/4256110900/viera_jobs.png" alt="viera_jobs"><br>(ветка профессий для одной из рас в FFTA)</p><p>Профессии 2го уровня требует всего нескольких очков навыков в простых профессиях (к примеру, чтобы стать <code>Sniper</code> достаточно набрать 2х очков в профессии <code>Archer</code>), но продвинутые профессии могут иметь намного более сложные требования (чтобы стать <code>Assasin</code>, нужно получить как минимум по 2 очка способностей из профессий <code>Archer</code>, <code>Elementalist</code> и 1 очку в <code>White Mage</code>, <code>Fencer</code> и <code>Sniper</code>).</p><p><img src="/blog/4256110900/fft_jobs.png" alt="fft_jobs"><br>(все профессии fft)</p><p>Возможна линейная прокачка профессий, без отхода от основной ветки (<code>Squire</code>-&gt;<code>Knight</code>-&gt;<code>Monk</code> в ветке воина). Например, рост программиста в направлении:<br><code>Джуниор программист</code>-&gt;<code>Мидл</code>-&gt;<code>Сениор</code>-&gt;<code>Суперсеньор 100500 ранга</code>.</p><p>Другой вариант — прокачка в целом дереве одной ветки, которая может дать более продвинутую профессию (<code>Knight+Monk+Lancer</code>-&gt;<code>Samurai</code>).<br>Пример:<br><code>Engine Programmer + Team Lead + Build pipeline tools programmer</code> -&gt; <code>CTO/VP of programming</code><br>Ну или, допустим<br><code>Джуниор + Математика + Понимание API и железок -&gt; Render программист</code></p><p>Это один за самых частых вариантов — в геймдеве встречаются очень разные задачи, от создания бекэнда и серверов для мультиплейерных игр до программирования графики, обычные гуи приложения (тулзы), скрипты автоматизации, оптимизации, архитектура движков. Так что несмотря на то, что есть специализации, за длительное время работы скорее всего окажется, что позанимаешься почти всем. Это и плюс - расширяет кругозор, и не возникнет ощущения, что постоянно занимаешься чем-то одним, и минус - нельзя просто выучить что-то одно и бездумно пользоваться этим много лет.</p><p>Возможны также “уходы от основной ветки” (был воином, ушёл в маги). Что-нибудь типа:<br><code>Джуниор программист -&gt; Графический программист -&gt; (бам) -&gt; техартист</code><br><code>Сениор -&gt; Тим Лид-&gt;(бам) -&gt; Проджект менеджер/Продюссер/Руководитель отдела</code><br><code>Технический геймдизайнер -&gt; (бам) -&gt; программист блюпринтов -&gt; (бам) -&gt; инди-одиночка, который и кодит, и дизайнит, и рисует</code><br>В таких случаях важно не забыть своевременно подкачать необходимые скиллы из ранних профессий другой ветки (программист, артист, геймдизайнер, менеджер команды)</p><p><img src="/blog/4256110900/dark_knight.png" alt="dark_knight"><br>Ну, или аналоги <code>Dark Knight</code>, которые кроме 1-2 сильных веток умеют делать по чуть-чуть практически что угодно (<code>Гейм-дизайнер/Артист/Программист + CEO</code>), и ухитряются понемногу заниматься обоими основными профессиями.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;Модели раз
      
    
    </summary>
    
    
    
      <category term="gamedev" scheme="http://spiiin.github.io/tags/gamedev/"/>
    
      <category term="dev_evolution" scheme="http://spiiin.github.io/tags/dev-evolution/"/>
    
  </entry>
  
  <entry>
    <title>Про увольнения</title>
    <link href="http://spiiin.github.io/blog/2316905704/"/>
    <id>http://spiiin.github.io/blog/2316905704/</id>
    <published>2022-07-09T09:54:41.000Z</published>
    <updated>2022-08-01T11:26:35.516Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Из-за чего увольняют с работы?</p><p>Три категории причин:</p><ul><li>Деньги</li><li>Софт скиллы</li><li>Хард скиллы</li></ul><h2 id="Деньги"><a href="#Деньги" class="headerlink" title="Деньги"></a>Деньги</h2><p>Когда у компаний много денег, она расширяется, набирают новых людей, стартуют новые проекты. В этот период и устроиться на работу легче (нужны работники, и побыстрее), получить повышение, закатываются праздники и корпоративы. Когда деньги кончаются, начинается обратный процесс — сокращения или закрытие проектов/подразделений/офисов, урезания бонусов и трат. Бывает, что меняются внешние условия — меньше продаж, конкуренты подоспели, правительство доигралось до санкций, ломающих бизнес, или весь рынок просел. Бывают внутренние — менеджмент или команда неадекватная, или инвесторы решили, что чё-то не то получается. Внутренние условия поменять сложно, внешние еще сложнее.</p><p>Если вовремя осознаёшь грядущие изменения сам — можно успеть уйти туда, где условия лучше, если такие места есть, если не осознаёшь — новости о сокращении становятся ВНЕЗАПНЫМИ. “Как же так — ведь мы суперкоманда, семья практически?”. В один момент работникам могут напомнить, что это вообще-то бизнес, и цель компании, деньги зарабатывать, а тебе именно за это и платили — делать что-то, что приносит в конечном итог принесёт денег больше, чем было потрачено (на твою зп в том числе). Если продукт еще не приносил денег — то твоя лояльность к нему и переработки ничего не принесли. Если уже сделал всё как надо, и работает само как часы — ты в принципе тоже может быть уже и не нужен, держать “суперзвезду на пенсии” может быть дорого. Получил деньги и ресурсы на свою игру мечты, реализовал, ушёл дальше в закат — вполне нормальный расклад для наёмного разработчика игр.</p><p>Топ-менеджмент часто также может быть наёмным, но может воспитываться и развиваться внутри компании. В этом случае рано или поздно необходимо стремиться к тому, чтобы тем или иным образом получать долю от дохода продукта компании. Где-то на этом уровне лояльность может конвертироваться в дивиденды, всё что ниже, просто социальная игра в то, что вы и компания любите друг друга и заботитесь (<em>пока всё хорошо</em>). В хорошем случае может получиться просто договориться о том уровне компенсации, который устраивает работника, в плохом “звиняйте, хлопцi, грошей нэма”.</p><h2 id="Софт-скиллы"><a href="#Софт-скиллы" class="headerlink" title="Софт-скиллы"></a>Софт-скиллы</h2><p>Если убрать кейсы, когда закрывается целое структурное подразделение, то происходит какая-либо оценка и отбор, кого уволить или оставить. Факторами могут быть софт и хард скиллы. Я попробую сконцентрироваться именно на отрицательных факторах, которые реже осознают, так как положительные чаще всего и так очевидны. Кроме очевидных кейсов, вроде “хамит, ругается со всеми, неадекватен к критике, уходит в запои”, бывает и менее явная отрицательная оценка людей (за что не уволят сразу, но могут принять во внимание при оценке). Из доклада Джесси Шелла <a href="https://youtu.be/-zRaFJHK0S4?t=3057" target="_blank" rel="noopener">Game Studio Management: Making It Great</a>, шесть типов мудаков. По его подходу, качество общения команды можно представить как граф распространения информации, и мудаки — люди которые так или иначе блокируют нормальное распространения информации или портят качество общения.</p><p><strong><code>- Недоступный мудак</code></strong><br>Невозможно получить от него никакой информации. Не оставляет нигде документации, не распространяет информации о принятым в узком кругу решениях. Пропадает в рабочее время, не отвечает ни по каким каналам связи. Запретно для оценки — пропажа по независящим от работника обстоятельствам, либо нежелание работать сверхурочно. Но в этом случае вполне можно оценивать то, что передаёт работник перед уходом — качество информации, которую он оставил, чтобы разобраться без него (кого предупредил, что пропадает, закончил ли задачи или рассказал о том, в каком состоянии эти задачи и план по тому, кто будет их доделывать).</p><p><strong><code>- Ненадёжный мудак</code></strong><br>Невозможно узнать, когда закончит задачу, не умеет и не стремится научиться планировать и оценивать сроки, в случае сдвига сроков не предупреждает вовремя. Не ищет причин несоответствия оценки и реального выполнения задачи. Не успевает выполнять задачи. Невозможно верить тому, насколько хорошо выполнена или проверена задача. Не оставляет информации о том, чтобы можно было отследить способ решения задачи до получения от него финального решения.</p><p><strong><code>- Упрямый мудак</code></strong><br>Невозможно переубедить его, что задачу нужно решать другим способом. “Нет, я буду делать это именно так”. Игнорирует информацию, которая ему не нравится. Отказывается от восприятия нестандартных для него идей, обсуждения способов его работы. Специально саботирует какие-либо методы работы. Неадекватно воспринимает критику, отказывается от переделок, готов тратить на споры слишком много времени. С приходом в новую команду может начать переделывать что-то по-своему без понимания причин решений, или требовать изменений. С технической стороны — неспособен увидеть плюсы различных подходов, кроме того, что использует сам. Тратит неадекватно много времени на отстаивание мнения даже в неважных вопросах. Неспособен видеть за технологиями идеи, которые можно воплотить с помощью технологий.</p><p><strong><code>- Токсичный мудак</code></strong><br><em>В оригинале “невежливый”. Токсичностью называют сейчас что угодно, что не нравится называющему. Я тут имею ввиду и перечисляю любые формы общения, которые со временем заражают коллектив, и через какое-то время все разговоры ведутся на ту тему, которой заразил всех мудак, а не о работе. Вторая форма заражения — часть людей перестаёт общаться с мудаком или в его присутствии между собой</em></p><p>Говорит только о деньгах, зарплате и должностях, публично сравнивает коллег по профессиональным качествам или уровню зарплаты.</p><p>Прикрывает сарказмом грубость, не может общаться без сарказма или подколов. Провести границу между общением в неформальном стиле с шутками, и некорректным, просто — если собеседник в ходе общения выводится на любую эмоциональную реакцию, то с вашем стилем общения точно что-то не то. Другой серьёзный маркер — кто-то начинает избегать общения с вами.</p><p><strong><code>- Склочный мудак</code></strong><br><em>Формы общения, которые каким-либо образом делят коллектив на группы, и настраивают их друг против друга (или против кого-нибудь одного), эксплуатируют закулисные приёмы и настроены на получение власти. Невозможно заставить общаться склочного мудака не “против кого-то”, или не демонстрировать паттерны поведения из книжек Маккиавели и Роберта Грина.</em></p><p>Пытается формировать “партии” людей, которые будут поддерживать его решения, независимо от их качества. Травит кого-то за спиной. Травит кого-то публично. Передаёт искаженную информацию о других в негативном свете. Самая жесть в плане разрушения коллектива, лицемерие — если при общении с кем-то понимаешь, что “всё сказанное и сделанное может и будет использовано против тебя” — это одновременно ещё и токсичная форма общения. Пытается диктовать мнения и позиции, в том числе по непрофессиональным вопросам, любит решать за всех (там где это не его профессиональная обязанность), чрезмерная общественная активность в ущерб профессиональной.</p><p><strong><code>- Мутный мудак</code></strong><br>Невозможно получить от него полезную информацию. Не знает, когда доделает что-то, не помнит, почему сделал что либо. После дискуссии с ним непонятна ни его позиция, ни понял ли он что-либо. Вместо ответа на вопрос выдаёт дикую ахинею, которую вообще сложно назвать информацией. “Я не сделал задачу XXX, потому что посоветовался с ZZZ (вообще без полномочий решать что-либо), и решил вместо этого сделать фичу YYY (с задачей не связанную) а задачу закрыл”. На объяснения хочется спросить “а нахрена вообще ты это сделал?”. Неорганизован, склонен максимально привлекать людей к ненужным обсуждениям и совещаниям, не отличает важных решений от неважных.</p><p>Регулярно попадает в истории в стиле “Мальчишник в Вегасе”, после которых ему нужны отгулы и больничные на то, чтобы экстренно восстановить паспорт, переделать диплом, забрать потерянные в другой стране вещи. Конечно же, обещает всё обязательно отработать, работая без выходных длительное время.</p><p>Добавлю ещё пару типажей от себя, связанных со скрытой враждой к любому начальству.</p><p><strong><code>- Мудак-саботёр</code></strong><br>Невозможно заставить выполнить работу, которая ему не нравится. Внешне может не показывать несогласия, но в совершенстве владеет методами увиливания от работы эпохи “развитого социализма” или итальянской забастовки, которые применяет как только ему что-то не нравится, или даже вместо дискуссии (ведь мудак не метит в начальники, зачем ему что-то предлагать, обсуждать или улучшать?).</p><p>Требует мельчайших разъяснений ему деталей при проектировании, максимально зафиксированных в документах, затягивая время. Может бездумно сделать что-либо по очевидно неправильному техзаданию (при том, только рад, если на это необходимо потратить много времени, даже если знает, что можно решить проще). Спихивает работу на других - “я сделал вам замечательную систему настроек вместо решения проблемы, всего за день, теперь вы с помощью моей замечательной системы наймите специального писателя настроек, который должен будет три недели решать в ней задачу, которую вы хотели на меня повесить, программисты таким не занимаются”. “Свою часть я сделал, как просили, дальше — не мои проблемы”. Меркантилен, эксплуатирует системы премий, бонусов и оплаты сверхурочных.</p><p><strong><code>- Мудак-наёмник</code></strong><br>Невозможно заставить выполнить работу без абсолютного контроля за выполнением. Если где-то на задание отведено 8 часов, а сделал за час, ни за что не признается в этом, потратит всё время в личных целях, хотя будет утверждать, что работал все 8. При самостоятельной оценке задач указывает заведомо большие сроки. Противится любым попыткам проконтролировать, чем именно он занимается в рабочее время. При отсутствии контроля сокращает своё рабочее время до минимума, не работает совсем, делает что-нибудь “для души”, или даже шабашит.</p><p>Отдельный случай, за который людей иногда увольняют без всякого мудачества — новички.</p><p><strong><code>- Новичок</code></strong><br>Если нужно сократить часть людей, то руководители часто приносят в жертву новичков. Новичок еще не успел ни с кем подружиться, чтобы его уход кого-то огорчил, в техническом плане он ещё не успел сделать что-то существенное, чтобы стать незаменимой частью команды. Различные системы оценки, используемые менеджерами, зачастую аккумулятивны, так что он просто не успел набрать столько условных очков, как его коллеги, у которых просто было больше времени для того, чтобы получать эти условные очки. По системам оценки, которые я встречал, работник остаётся новичком около года (если посмотреть на оценки примерно равных по профессиональным качествам людей, те, кто пришёл позже, всегда получаются ниже тех, кто работает дольше).</p><h2 id="Хард-скиллы"><a href="#Хард-скиллы" class="headerlink" title="Хард-скиллы"></a>Хард-скиллы</h2><p>Накосячить по хард-скиллам до увольнения сложно, но можно. Обычно всё-таки эти скиллы так или иначе проверяются на собеседованиях и испытательном сроке, так что представление об уровне работника у его менеджеров уже есть. Чаще встречается недовольство со стороны работника — уверенность в том, что его скиллы недооценены, или что для него нет подходящих задач. Серьёзные проблемы, которые могут быть отмечены как минусы, или привести к увольнениям:</p><p><strong><code>- Нерасширяемые решения</code></strong><br>Задача решена так, что любая просьба внести даже небольшие изменения потребует выбрасывания кода и написания нормального решения заново. Один из реальных экстремальных примеров — окно с тремя виджетами, в которое невозможно было добавить четвертый.</p><p><strong><code>- Неспособность дорешать задачу</code></strong><br>Реализация решения постоянно порождает баги. Изначальный код быстро покрывается заплатками настолько, что каждая следующая заплатка ломает что-нибудь исправленное ранее. Решение никогда “не сходится” к надежному, а в лучшем случае находится в неустойчивом равновесии</p><p><strong><code>- Невыполненные задачи</code></strong><br>Отдельная категория — человек читает условие задачи и пропадает. От него не поступает никаких вопросов, уточнений, предложений, вариантов кода. На уточняющие вопросы может ответить только, что все в процессе или даже почти готово. После дедлайна оказывается, что нет ВООБЩЕ никакого результата (возможно, из-за настигшей работника внезапной катастрофы). Кажется странным или редким, но периодически происходит вновь с другими людьми, как будто их похищают инопланетяне.</p><p><strong><code>- Решение меняет поведение половины кодовой базы</code></strong><br>Кроме непосредственного выполнения задачи, решение ломает или меняет поведение большой части кода. “Я тут делал мелкую фичу, и попутно переписал вашу функцию открытия файлов, у меня на машине она почему-то как-то непонятно работала”. “Чтобы мой код заработал, пришлось серьёзно изменить логику движка в 3х местах” (при этом код изначально кривой, при написании нормального изменения бы не потребовались).</p><p><strong><code>- Работа в полсилы</code></strong><br>Точнее, работу вполсилы бывает всё еще сложно заметить, но чаще всего дальше производительность падает до 20-30% (относительно результатов других членов команды или собственных в прошлом). Поскольку в этом случае есть некоторый “уровень нормы”, можно предпринять попытки к его возврату каким-либо способом (от отправки в отпуск, до смены способа контроля за дисциплиной или просто выяснения, что же такого произошло).</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;Из-за чего
      
    
    </summary>
    
    
    
      <category term="gamedev" scheme="http://spiiin.github.io/tags/gamedev/"/>
    
      <category term="dev_evolution" scheme="http://spiiin.github.io/tags/dev-evolution/"/>
    
  </entry>
  
  <entry>
    <title>daScript macro - 2</title>
    <link href="http://spiiin.github.io/blog/4046309382/"/>
    <id>http://spiiin.github.io/blog/4046309382/</id>
    <published>2022-07-02T14:11:26.000Z</published>
    <updated>2022-07-28T16:49:57.710Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Еще немного про способы кодогенерации в макросах.</p><p>В <a href="/blog/1547564887/" title="предыдущей заметке про макросы">предыдущей заметке про макросы</a> описывались способы сгенерировать код выражений на языке.</p><p>Можно строить выражения с помощью ручной генерации абстрактного синтаксического дерева. Например, код для генерации выражения <code>let a = 40 + 2</code>:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">var expr40 &lt;- <span class="keyword">new</span> [[ExprConstInt() value=<span class="number">40</span>]]                               <span class="comment">//40</span></span><br><span class="line">var expr2 &lt;- <span class="keyword">new</span> [[ExprConstInt() value=<span class="number">2</span>]]                                <span class="comment">//2</span></span><br><span class="line">var exprPlus &lt;- <span class="keyword">new</span> [[ExprOp2() op:=<span class="string">"+"</span>, left := expr40, right := expr2]]  <span class="comment">//40+2</span></span><br><span class="line"></span><br><span class="line">var exprLet &lt;- <span class="keyword">new</span> [[ExprLet()]]                                           <span class="comment">//let</span></span><br><span class="line">exprLet_aSize.variables |&gt; emplace_new() &lt;| <span class="keyword">new</span> [[Variable()    </span><br><span class="line">    name := <span class="string">"a"</span>,                                                            <span class="comment">//a</span></span><br><span class="line">    _type &lt;- <span class="keyword">new</span> [[TypeDecl() baseType=Type tInt]],</span><br><span class="line">    init &lt;- exprPlus                                                        <span class="comment">//=40+2</span></span><br><span class="line">]]</span><br></pre></td></tr></table></figure></p><p>Генерировать большие функции с использованием ExprXXX-кирпичиков утомительно, поэтому можно использовать макрос <code>quote</code>, который трансформирует переданное в него выражение в синтаксическое дерево этого выражения:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var exprLet &lt;- quote &lt;|</span><br><span class="line">    let a = <span class="number">40</span> + <span class="number">2</span></span><br><span class="line">print(describe(exprLet))</span><br><span class="line"><span class="comment">//output:</span></span><br><span class="line">let  <span class="comment">/*unused*/</span> a:<span class="keyword">auto</span> <span class="keyword">const</span> = (<span class="number">40</span> + <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>В случае, если какую-либо часть выражения нужно сделать изменяемой, можно воспользовать макросом <code>apply_template</code>:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">require daslib/templates</span><br><span class="line">require daslib/templates_boost</span><br><span class="line"></span><br><span class="line">var exprLet &lt;- quote &lt;|</span><br><span class="line">    let VARIABLE_NAME = OP1 + OP2                                         <span class="comment">//шаблон выражения</span></span><br><span class="line">var exprLet_rules : Template                                              <span class="comment">//правила переписывания выражения</span></span><br><span class="line">exprLet_rules |&gt; renameVariable(<span class="string">"VARIABLE_NAME"</span>, <span class="string">"a"</span>)                     <span class="comment">//замена одного имени на другое</span></span><br><span class="line">exprLet_rules |&gt; replaceVariable(<span class="string">"OP1"</span>, <span class="keyword">new</span> [[ExprConstInt() value=<span class="number">40</span>]])  <span class="comment">//замена одного выражения на другое</span></span><br><span class="line">exprLet_rules |&gt; replaceVariable(<span class="string">"OP2"</span>, <span class="keyword">new</span> [[ExprConstInt() value=<span class="number">2</span>]]) </span><br><span class="line">apply_template(exprLet_rules, exprLet.at, exprLet)</span><br></pre></td></tr></table></figure><p>Недавно в язык была добавлена фича по упрощению генерации правил переписываний выражений — <a href="https://dascript.org/doc/reference/language/reification.html?highlight=reification" target="_blank" rel="noopener">expression reification</a> (<a href="https://haxe.org/manual/macro-reification-expression.html" target="_blank" rel="noopener">аналогичная фича из haxe</a>).<br>Её можно описать как DSL для задания правил переписывания выражений в шаблонах. Теперь генерацию того же самого выражения можно описать так:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">let variableName = <span class="string">"a"</span></span><br><span class="line">let op1 = <span class="number">40</span></span><br><span class="line">let op2 = <span class="number">2</span></span><br><span class="line">var exprLet &lt;-qmacro &lt;|</span><br><span class="line">    let $i(variableName) = $v(op1) + $v(op2)</span><br></pre></td></tr></table></figure><br>В таком виде строчка шаблона всё ещё остаётся похожим на сам код, который будет сгенерирован этим шаблоном, а не на синтаксическое дерево или таблицу с описанием правил. Пример на все поддерживаемые правила реификации выражений - <a href="https://github.com/GaijinEntertainment/daScript/blob/fe8868308a44d7ad57d823205dc183993f428d40/examples/test/misc/reification.das" target="_blank" rel="noopener">reification.das</a>.</p><p>Переписанная кодо-генерированная функция инициализации структуры с использованием реификации получается где-то вдвое короче и проще:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">generateStructureInitFunction</span><span class="params">(var st:StructurePtr; ptrsTypeIndexes:<span class="built_in">array</span>&lt;<span class="keyword">int</span>&gt;&amp;)</span></span></span><br><span class="line"><span class="function">    let ptrFieldsLen </span>= ptrsTypeIndexes |&gt; length</span><br><span class="line">    var blk : <span class="built_in">array</span>&lt;ExpressionPtr&gt;; defer_delete(blk)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-------------------------</span></span><br><span class="line">    <span class="comment">//memblock.a`count = aCount</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">for</span> i in <span class="title">range</span><span class="params">(<span class="number">0</span>, ptrFieldsLen)</span></span></span><br><span class="line"><span class="function">        let argumentName </span>= <span class="string">"&#123;st.fields[ptrsTypeIndexes[i]].name&#125;`count"</span></span><br><span class="line">        blk |&gt; emplace_new &lt;| qmacro_expr(</span><br><span class="line">            $&#123;memblock.$f(argumentName) = $i(argumentName);&#125;</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-------------------------</span></span><br><span class="line">    <span class="comment">//let aSize = typeinfo(sizeof *memblock.a) * aCount</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">for</span> i in <span class="title">range</span><span class="params">(<span class="number">0</span>, ptrFieldsLen)</span></span></span><br><span class="line"><span class="function">        let argumentName </span>= <span class="string">"&#123;st.fields[ptrsTypeIndexes[i]].name&#125;"</span></span><br><span class="line">        let argumentNameSize = <span class="string">"&#123;argumentName&#125;Size"</span></span><br><span class="line">        let argumentNameCount = <span class="string">"&#123;argumentName&#125;`count"</span></span><br><span class="line">        blk |&gt; emplace_new &lt;| qmacro_expr(</span><br><span class="line">            $&#123;let $i(argumentNameSize) = typeinfo(<span class="keyword">sizeof</span> *memblock.$f(argumentName)) * $i(argumentNameCount);&#125;</span><br><span class="line">        )</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//-------------------------</span></span><br><span class="line">    <span class="comment">//memblock.mem |&gt; resize(aSize + bSize + cSize)</span></span><br><span class="line"></span><br><span class="line">    var sumArgumentsArray: <span class="built_in">array</span>&lt;ExpressionPtr&gt;</span><br><span class="line">    let zero = <span class="number">0</span>;</span><br><span class="line">    sumArgumentsArray |&gt; emplace&lt;| qmacro_expr($&#123;$v(zero);&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">for</span> i in <span class="title">range</span><span class="params">(<span class="number">0</span>, ptrFieldsLen)</span> </span></span><br><span class="line"><span class="function">        let argumentName </span>= <span class="string">"&#123;st.fields[ptrsTypeIndexes[i]].name&#125;"</span></span><br><span class="line">        let nameSize := <span class="string">"&#123;argumentName&#125;Size"</span></span><br><span class="line">        sumArgumentsArray |&gt; emplace &lt;| qmacro_expr($&#123;$i(nameSize);&#125;)</span><br><span class="line">    unsafe</span><br><span class="line">        var sumExpr &lt;- reduce(each(sumArgumentsArray), @@makeSumExpr)</span><br><span class="line">        blk |&gt; emplace_new &lt;| qmacro_expr(</span><br><span class="line">            $&#123;memblock.mem |&gt; resize($e(sumExpr));&#125;</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-------------------------</span></span><br><span class="line">    <span class="comment">//memblock.a = reinterpret&lt;int?&gt; addr(memblock.mem[0])</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i in range(<span class="number">0</span>, ptrFieldsLen)</span><br><span class="line">        let argumentName = <span class="string">"&#123;st.fields[ptrsTypeIndexes[i]].name&#125;"</span></span><br><span class="line">        unsafe</span><br><span class="line">            var exprStartAddress &lt;- reduce_while(each(sumArgumentsArray), @@makeSumExpr,  @(e:ExpressionPtr; counter:<span class="keyword">int</span>):<span class="keyword">bool</span> =&gt; counter &lt;= i)</span><br><span class="line">            var subtype := st.fields[ptrsTypeIndexes[i]]._type</span><br><span class="line">            var exprAssign &lt;- qmacro_expr &lt;|</span><br><span class="line">                unsafe&#123; memblock.$f(argumentName) = reinterpret&lt;$t(subtype)&gt; addr(memblock.mem[$e(exprStartAddress)]); &#125;</span><br><span class="line">            blk |&gt; emplace_new(exprAssign)</span><br><span class="line">    <span class="comment">//-------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//function signature</span></span><br><span class="line">    var fnArguments : <span class="built_in">array</span>&lt;VariablePtr&gt;;</span><br><span class="line">    unsafe</span><br><span class="line">        fnArguments |&gt; emplace_new &lt;| <span class="keyword">new</span> [[Variable() at=st.at, name:= <span class="string">"memblock"</span>, _type &lt;- <span class="keyword">new</span> [[TypeDecl() baseType=Type tStructure, structType=addr(*st)]]]]</span><br><span class="line">    var structT &lt;- typeinfo(ast_typedecl type&lt;<span class="keyword">int</span>&gt;)</span><br><span class="line">    <span class="keyword">for</span> i in range(<span class="number">0</span>, ptrFieldsLen)</span><br><span class="line">        let argumentName = <span class="string">"&#123;st.fields[ptrsTypeIndexes[i]].name&#125;`count"</span></span><br><span class="line">        fnArguments |&gt; emplace_new &lt;| <span class="keyword">new</span> [[Variable() at=st.at, name:= argumentName,  _type := intAstType]]</span><br><span class="line">    var fn &lt;- qmacro_function(<span class="string">"init`struct`&#123;st.name&#125;"</span>) &lt;| $ ($a(fnArguments))</span><br><span class="line">        $b(blk)</span><br><span class="line">    defer_delete(fn)</span><br><span class="line">    compiling_module() |&gt; add_function(fn)</span><br></pre></td></tr></table></figure><p>Макрос <code>qmacro_expr</code> позволяет вставить сгенерированное выражение в текущий блок, а не генерировать новый блок.<br><code>reduce</code> - функция из стандартной библиотеки <a href="https://github.com/GaijinEntertainment/daScript/blob/fdc48d4d4cfc46f08f0ca2fd8938a05896b973a6/daslib/functional.das" target="_blank" rel="noopener">functional</a>, позволяющая произвольным образом свернуть массив выражений с помощью функтора.<br><code>reduce_while</code> — её дописанная версия, позволяющая задать предикат остановки свёртки выражения по условию.<br><code>qmacro_function</code> — макрос для генерации сигнатуры функции и её определения</p><p>Получившаяся функция инициализации аналогична той, которая генерировалась в предыдущей заметке:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vec2</span></span></span><br><span class="line"><span class="class">    <span class="title">x</span>, <span class="title">y</span> :</span> <span class="keyword">float</span></span><br><span class="line"></span><br><span class="line">[memblock, dump_fields]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Memblock</span></span></span><br><span class="line"><span class="class">    <span class="title">a</span>:</span> <span class="keyword">int</span>?</span><br><span class="line">    b: <span class="keyword">float</span>?</span><br><span class="line">    c: <span class="keyword">int</span>?</span><br><span class="line">    d: Vec2?</span><br><span class="line"></span><br><span class="line"><span class="comment">//output:</span></span><br><span class="line">---gen_text--------------</span><br><span class="line"><span class="comment">// [modifyArgument]</span></span><br><span class="line">[privateFunction]def init`<span class="class"><span class="keyword">struct</span>`<span class="title">Memblock</span> ( <span class="title">var</span> <span class="title">memblock</span> :</span> Memblock; var a`count : <span class="keyword">int</span>; var b`count : <span class="keyword">int</span>; var c`count : <span class="keyword">int</span>; var d`count : <span class="keyword">int</span> )</span><br><span class="line">        memblock.a`count = a`count</span><br><span class="line">        memblock.b`count = b`count</span><br><span class="line">        memblock.c`count = c`count</span><br><span class="line">        memblock.d`count = d`count</span><br><span class="line">        var aSize : <span class="keyword">int</span> <span class="keyword">const</span> = (a`count * <span class="number">4</span>)</span><br><span class="line">        var bSize : <span class="keyword">int</span> <span class="keyword">const</span> = (b`count * <span class="number">4</span>)</span><br><span class="line">        var cSize : <span class="keyword">int</span> <span class="keyword">const</span> = (c`count * <span class="number">4</span>)</span><br><span class="line">        var dSize : <span class="keyword">int</span> <span class="keyword">const</span> = (d`count * <span class="number">8</span>)</span><br><span class="line">        __::builtin`resize(memblock.mem,((((aSize + <span class="number">0</span>) + bSize) + cSize) + dSize))</span><br><span class="line">        memblock.a = reinterpret&lt;<span class="keyword">int</span>?&gt; addr(memblock.mem[<span class="number">0</span>])</span><br><span class="line">        memblock.b = reinterpret&lt;<span class="keyword">float</span>?&gt; addr(memblock.mem[(aSize + <span class="number">0</span>)])</span><br><span class="line">        memblock.c = reinterpret&lt;<span class="keyword">int</span>?&gt; addr(memblock.mem[((aSize + <span class="number">0</span>) + bSize)])</span><br><span class="line">        memblock.d = reinterpret&lt;Vec2?&gt; addr(memblock.mem[(((aSize + <span class="number">0</span>) + bSize) + cSize)])</span><br></pre></td></tr></table></figure></p><p><a href="https://github.com/spiiin/dascript_macro_tutorial/tree/master/memblock_2" target="_blank" rel="noopener">Код примера</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;Еще немног
      
    
    </summary>
    
    
    
      <category term="dascript" scheme="http://spiiin.github.io/tags/dascript/"/>
    
  </entry>
  
  <entry>
    <title>daScript - как учить</title>
    <link href="http://spiiin.github.io/blog/2301621444/"/>
    <id>http://spiiin.github.io/blog/2301621444/</id>
    <published>2022-06-26T19:25:24.000Z</published>
    <updated>2022-06-26T20:50:29.658Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>На что в первую очередь посмотреть при изучении нового языка программирования, на примере daScript, но можно и применительно к другим языкам. Сырой список.</p><p><code>Обзор языка, мотивация</code></p><ul><li>Кто и зачем делает ещё один язык программирования, какие проблемы он решает</li><li>Какие возможности даёт язык, позволяет ли сочетание этих возможностей потеницально решить какие-либо ещё мои проблемы, кроме декларируемых авторами</li><li>Официальная документация, обзорные статьи, поиск существующих комьюнити</li><li>Лицензия, support</li><li>Планы, роадмап, периодичность обновлений, стабильность ядра языка</li><li>Поддерживаемые платформы и архитектуры, использование бекэндов/фронтэндов (llvm)</li></ul><p><code>Чтение кода</code></p><ul><li>Примеры от авторов, код тестов</li><li>Чтение кода стандартной библиотеки</li><li>Сторонние библиотеки</li></ul><p><code>Практика 1. Простые примеры</code></p><ul><li>Как хранятся в памяти типы<br>— работа со значениями/указателями/ссылками<br>— когда неожиданное дополнительное копирование, когда можно избежать, есть ли быстрые способы настройки/проверки<br>— особенности преобразования и приведения типов, что можно настроить для своих типов<br>— базовые типы<br>— особенности типизации<br>— настройки мутабельности/чистоты<br>— Глобальные/статические переменные</li><li>Конструкции управления</li><li>Часто используемые фичи языка (ленивость, аннотации, генераторы etc)</li><li>Строки<br>— какие есть типы для представления строк<br>— представление в памяти различных типов<br>— кодировки</li><li>Композия типов<br>— Классы, типы наследования, способы композиции данных<br>— модули</li><li>Стандартные контейнеры/коллекции/последовательности</li></ul><p><code>Практика 2</code></p><ul><li>Стандартная библиотека<br>— работы с вводом/выводом, файлами и путями, сетью<br>— асинхронность - потоки, файберы, примитива синхронизации, корутины, асинхронное выполнение кода. Jobque<br>— идиомы языка</li><li>приёмы обработки ошибок</li><li>generic-программирование</li><li>макросы, работа с AST языка</li><li>compile-time вычисления</li><li>способы генерации кода</li><li>rtti, рефлексия — возможности настройки</li></ul><p><code>DSL языка</code></p><ul><li>форматирование и способы вывода различных типов данных</li><li>json_boost, regexp_boost, decs_boost, opengl_boost</li><li>способы создания своих dsl</li></ul><p><code>Работа с памятью</code></p><ul><li>Способы аллокации и освобождения памяти</li><li>Принятые паттерны работы с выделением и освобождением памяти, время жизни объектов<br>— gc<br>— raii<br>— опции и настройки компилятора<br>— способа кастомизации объектов в памяти — кастомная аллокация, выравнивание, способы переопределить расположение данных в памяти<br>— способы реификации стандартных систем языка в памяти (для изучения стоимости этих фич) — способы наследования, корутины, генераторы, continuations, функторы, замыкания, внутренности контейнеров</li></ul><p><code>Работа с мультимедиа</code></p><ul><li>рендер, графика, анимация, звук, гуи, работа со стандартными форматами файлов, 3d-математика</li><li>шейдеры, системы материалов, способы реализации эффектов</li></ul><p><code>Отладка</code></p><ul><li>Особенности обнаружения и сигналов о различных типах ошибок компилятором</li><li>Отладочные контексты</li><li>Профайлер</li><li>Отладчик</li><li>Настройки компилятора для режимов отладки</li><li>Способы работы с тестами</li><li>Возможность настроить язык (уровень проверки ошибок, всякие прагмы -Wall, -pedantic) и расширять язык, диалекты</li></ul><p> <code>Среда разработки</code></p><ul><li>Поддержка интеграции в IDE (подсветка, автодополнение, подсказки, переходы по коду, апи связи с существующими тулзами, language server plugin etc)</li><li>Проверка наличия и качеств собственной среды разработки. Dasbox</li><li>Сочетаемость с инструментами (санитайзеры, профайлеры etc)</li><li>Особенности системы сборки</li><li>Способы сборки (интерпретация, компиляция, транспиляция, настройки vm, jit/aot)</li><li>Линтеры</li><li>Работа с документацией</li></ul><p><code>Встраивание, кросс-языковое взаимодействие</code></p><ul><li>FFI, вызовы кода на других языках</li><li>Модули расширения языка</li><li>Написание и генерация обёрток для своих и чужих классов и готовых библиотек</li><li>Передача управления между кодом на разных языках</li><li>Настройки встраивания языка в программу</li><li>Возможные архитектуры программы на C++ + daScript (настройка AoT, хот релоадинг, расширение классов C++ на daScript)</li><li>Способы работы со скриптовыми контекстами из C++</li><li>Способы межпроцессного/междуконтекстного взаимодействия</li></ul><p><code>Поддержка паттернов и парадигм программирования</code></p><ul><li>ECS</li><li>Функциональное программирование</li><li>Особенности ООП</li></ul><p><code>Оптимизация</code></p><ul><li>Настройки компилятора</li><li>Возможности по улучшению производительности существующего кода</li><li>Best practicies от авторов языка и библиотек</li><li>Возможности векторизации</li><li>Доступ к особенностям железа (интринсики, инлайн кода на ассемблере)</li><li>Бенчмарки с различными языками</li></ul><p><code>Особенности сборки под различные платформы</code></p><ul><li>win/mac/linux</li><li>мобильные платформы</li><li>консоли</li></ul><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;На что в п
      
    
    </summary>
    
    
    
      <category term="dascript" scheme="http://spiiin.github.io/tags/dascript/"/>
    
  </entry>
  
  <entry>
    <title>daScript in imaginery world</title>
    <link href="http://spiiin.github.io/blog/1160489034/"/>
    <id>http://spiiin.github.io/blog/1160489034/</id>
    <published>2022-06-19T07:48:24.000Z</published>
    <updated>2022-08-01T13:02:48.206Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Мой собственный способ измерить выразительность и скорость языка — решить на нём “задачу Джеймса Бонда младшего”, выдуманную головоломку из игры на NES <code>James Bond Jr</code> (<a href="https://youtu.be/Kzu_cGHFqM8?t=1290" target="_blank" rel="noopener">видео</a>). Несмотря на игрушечность задачи, кажется, это неплохой тест нового языка. Это веселее, чем реализовывать абстрактный поиск в ширину/глубину. Задачу решаю с небольшими алгоритмическими оптимизациями, но без оптимизаций по мелочам (скорее, наоборот, массив чисел специально копируется, как решена первая версия задачи на питоне, чтобы решения были сравнивыми, чтобы симулировать “код новичка” на языка и посмотреть, как язык справляется с этим копированием).</p><p>Сразу выводы про <code>daScript</code> для тех, кому не особенно интересны подробности реализации:</p><p>— Выразительность языка ОЧЕНЬ похожа на <code>Python</code>. Более того, я фактически просто переписал своё решение на <code>Python</code> 13-летней давности построчно, с парой изменений.<br>— <code>daScript</code> по скорости <strong>в режиме интерпретации</strong> находится в одной лиге с компилируемыми языками (!!!). Код по скорости сопоставим с версией на <code>Nim</code> (чуть быстрее “наивной” <strong>скомпилированной</strong> версии, и раза в 1.5-2 медленнее оптимизированной).<br>— В режиме <code>Ahead-of-Time</code> компиляции <code>daScript</code> обгоняет <code>nim</code> (который вообще показывает достаточно хорошие результаты в нормальных бенчмарках с другими языками).</p><a id="more"></a><p>Заметки<br>1 - <a href="/blog/28461/" title="(2009) Python in imaginary world">(2009) Python in imaginary world</a><br>2 - <a href="/blog/3351183716/" title="(2015) Scala in imaginary world">(2015) Scala in imaginary world</a><br>3 - <a href="/blog/1808122922/" title="(2021) Nim in imaginary world">(2021) Nim in imaginary world</a><br>Исходники<br><a href="https://github.com/spiiin/james_bond_jr_problem" target="_blank" rel="noopener">https://github.com/spiiin/james_bond_jr_problem</a></p><h2 id="Подготовка"><a href="#Подготовка" class="headerlink" title="Подготовка"></a>Подготовка</h2><p>Сборка автономного интерпретатора - проект <code>daScript</code> (можно в cmake поотключать дополнительные библиотеки типа <code>glfw</code>, ненужные для интерпретатора)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">option(DAS_XXX_MODULE_DISABLED &quot;Disable any unneeded modules&quot; OFF)</span><br></pre></td></tr></table></figure><br>Также не забывать собрать Release-версию. Теперь можно запускать скрипты из командной строки:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">daScript.exe james_bond_jr.das</span><br></pre></td></tr></table></figure></p><h2 id="Решение"><a href="#Решение" class="headerlink" title="Решение"></a>Решение</h2><div class='spoiler collapsed'>    <div class='spoiler-title'>        gist    </div>    <div class='spoiler-content'>        <script src="//gist.github.com/3bd63cd5271b277f5bc87f670b0ab967.js?file=james_bond_jr_dascript.das"></script>    </div></div><p>Отличия в синтаксис от <code>Python</code>:</p><p><strong><code>- Отсутствует присваивание кортежей</code></strong><br>Из-за чего нельзя написать сдвиг в массиве как в <code>python</code>:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n[0+plus],n[1+plus],n[2+plus],n[3+plus] &#x3D; n[3+plus],n[0+plus],n[1+plus],n[2+plus]</span><br></pre></td></tr></table></figure><br>и приходится писать отдельную функцию сдвига</p><p><strong><code>- Нельзя сравнить два массива с помощью оператора проверки равенства</code></strong><br>Что логично из-за неопределенности поведения такого оператора (сравнивать ли содержимое или указатели). Из-за этого используется самописная функция <code>same</code>:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">same</span><span class="params">(var a,b: int[<span class="number">16</span>])</span></span></span><br><span class="line">    for ai, bi in a, b</span><br><span class="line">        <span class="keyword">if</span> ai != bi</span><br><span class="line">            <span class="keyword">return</span> false</span><br><span class="line">    <span class="keyword">return</span> true</span><br></pre></td></tr></table></figure></p><p><strong><code>- Поддержка именованных именованных кортежей без необходимости использовать отдельный класс</code></strong><br><code>Python</code> позволяет использовать <a href="https://docs.python.org/3.6/library/collections.html?highlight=namedtuple#collections.namedtuple" target="_blank" rel="noopener">именованные кортежи</a> вместо обычных там, где не хочется заводить структуру. В <code>daScript</code> возможность именовать поля кортежа встроена в язык:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">typedef FieldPathInfo = tuple&lt;field:int[<span class="number">16</span>]; fieldFrom:int[<span class="number">16</span>];  rate:int&gt;</span><br><span class="line">var a = [[FieldPathInfo val, vert, rate(val)]]</span><br></pre></td></tr></table></figure></p><p><strong><code>- Ошибки вывода типа в генериках иногда напоминают вывод ошибок в шаблонов C++</code></strong><br><a href="https://github.com/GaijinEntertainment/daScript/issues/309" target="_blank" rel="noopener">https://github.com/GaijinEntertainment/daScript/issues/309</a></p><p><strong><code>- Нет встроенного аналога list из Python и DoubleLinkedList из Nim</code></strong><br>Вместо этого кортежи хранятся в классе <code>array</code>, представляющем собой динамический массив. Для того, чтобы избежать лишнего копирования данных при сортировке, память под кортежи выделяется на стеке:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">//медленный вариант</span><br><span class="line">var open: array&lt;FieldPathInfo&gt;</span><br><span class="line">open |&gt; push &lt;| [[FieldPathInfo source, rate(source), zeros]] //хранение в массиве объектов</span><br><span class="line">//более быстрый вариант</span><br><span class="line">var open: array&lt;FieldPathInfo?&gt;</span><br><span class="line">open |&gt; push &lt;| new [[FieldPathInfo source, zeros, rate(source)]] //хранение в массиве ссылок на объекта на хипе</span><br></pre></td></tr></table></figure></p><p>Также можно отметить, что объекты на хипе выделяются в соседних областях памяти, аллокатор контекста по умолчанию выделяет память из предвыделенного линейного блока:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">16</span>)</span><br><span class="line">    var xxx = new [[FieldPathInfo val, vert, rate(val)]]</span><br><span class="line">    unsafe</span><br><span class="line">        print(<span class="string">"addr=&#123;reinterpret&lt;void?&gt; xxx&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line">//output:</span><br><span class="line">addr=<span class="number">0x28b1bb582f0</span></span><br><span class="line">addr=<span class="number">0x28b1bb58380</span></span><br><span class="line">addr=<span class="number">0x28b1bb58410</span></span><br><span class="line">addr=<span class="number">0x28b1bb584a0</span></span><br><span class="line">addr=<span class="number">0x28b1bb58530</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>Так что, в теории, разница в скорости в выделении объектов на стеке и в куче для <code>daScript</code> должна быть небольшой, и хранение узлов в массиве должно дать даже небольшой прирост скорости из-за локальности хранения узлов в памяти, по отношению к способу хранения в списке.</p><p>За исключением перечисленных отличий, код “переведён” построчно с Python версии (с “бонусной” проверкой ошибок типизации интерпретатором). В такой форме при интерпретации он уже работает лишь чуть медленнее скомпилированной версии на <code>Nim</code>.</p><h2 id="Ahead-of-Time-компиляция"><a href="#Ahead-of-Time-компиляция" class="headerlink" title="Ahead-of-Time компиляция"></a>Ahead-of-Time компиляция</h2><p><code>daScript</code> можно настроить, чтобы вместо интерпретации он генерировал C++-код, выполняющий те же действия. В репозитория проекта есть <a href="https://github.com/GaijinEntertainment/daScript/blob/master/examples/tutorial/CMakeLists.txt#L36" target="_blank" rel="noopener">пример</a> настройки <code>cmake</code> для автоматической генерации AoT-версии кода.<br>Можно проделать этот этап вручную:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">daScript.exe -aot james_bond_jr.das james_bond_jr.das.cpp</span><br></pre></td></tr></table></figure></p><p>Полученный C++ файл можно скомпилировать (можно просто добавить его в один из туториалов), и теперь при выполнении скрипта <code>james_bond_jr.das</code>, вместо интерпретации, будут выполнены скомпилированные версии функций. В таком режиме скрипт обгоняет разогнанную <code>nim</code> версию решения. Выводы в начале.</p><p><img src="/blog/1160489034/jbjr.gif" alt="jbjr"></p><h2 id="Ещё-быстрее"><a href="#Ещё-быстрее" class="headerlink" title="Ещё быстрее!"></a>Ещё быстрее!</h2><p>Пара оптимизаций, чтобы сделать программу ешё быстрее.</p><p><strong><code>[[unsafe_deref]]</code></strong><br>аннотация для функций, которая “инлайнит” обращения по указателям.<br>Код из <a href="https://github.com/GaijinEntertainment/daScript/blob/a0fcdfdbf134d3dfb8055c9218c6e57ff4ae925b/src/ast/ast_simulate.cpp#L1023" target="_blank" rel="noopener">ast_simulate</a>:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">SimNode * <span class="title">ExprPtr2Ref::simulate</span> <span class="params">(Context &amp; context)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( unsafeDeref ) &#123;</span><br><span class="line">        <span class="comment">//симуляция выполнения ноды</span></span><br><span class="line">        <span class="keyword">return</span> subexpr-&gt;simulate(context);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//создание ноды для более поздней симуляции</span></span><br><span class="line">        <span class="keyword">return</span> context.code-&gt;makeNode&lt;SimNode_Ptr2Ref&gt;(at,subexpr-&gt;simulate(context));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong><code>Векторизация!</code></strong><br>В daScript есть встроенные векторные типы int4 и float4, и описание поля логичнее переделать на их использование:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;typedef Field &#x3D; int[16]</span><br><span class="line">typedef Field &#x3D; int4[4]</span><br></pre></td></tr></table></figure><br>Тогда горизонтальные сдвиги можно описать так:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def right(var v:Field; line: int)</span><br><span class="line">    var ans &#x3D; v</span><br><span class="line">    ans[line] &#x3D; ans[line].yzwx</span><br><span class="line">    return &lt;- ans</span><br><span class="line"></span><br><span class="line">def left(var v:Field; line: int)</span><br><span class="line">    var ans &#x3D; v</span><br><span class="line">    ans[line] &#x3D; ans[line].wxyz</span><br><span class="line">    return &lt;- ans</span><br></pre></td></tr></table></figure></p><p>Что 1) короче 2) очень быстро</p><p>Можно измерить скорость выполнения обычной и оптимизированной версии встроенным профайлером:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">profile(20, &quot;JamesBondUsual&quot;) &lt;|</span><br><span class="line">        for i in range(100)</span><br><span class="line">            var dif &lt;- extract(search())</span><br></pre></td></tr></table></figure></p><p>Получился прирост скорости ещё на 25% ( 0.4 -&gt; 0.3 миллисекунд за 100 запусков).<br>Код быстрой версии:</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        gist    </div>    <div class='spoiler-content'>        <script src="//gist.github.com/5aba216fdf4aa70984c112cd4c6496df.js?file=james_bond_jr_fast.das"></script>    </div></div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Мой собственный способ измерить выразительность и скорость языка — решить на нём “задачу Джеймса Бонда младшего”, выдуманную головоломку из игры на NES &lt;code&gt;James Bond Jr&lt;/code&gt; (&lt;a href=&quot;https://youtu.be/Kzu_cGHFqM8?t=1290&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;видео&lt;/a&gt;). Несмотря на игрушечность задачи, кажется, это неплохой тест нового языка. Это веселее, чем реализовывать абстрактный поиск в ширину/глубину. Задачу решаю с небольшими алгоритмическими оптимизациями, но без оптимизаций по мелочам (скорее, наоборот, массив чисел специально копируется, как решена первая версия задачи на питоне, чтобы решения были сравнивыми, чтобы симулировать “код новичка” на языка и посмотреть, как язык справляется с этим копированием).&lt;/p&gt;
&lt;p&gt;Сразу выводы про &lt;code&gt;daScript&lt;/code&gt; для тех, кому не особенно интересны подробности реализации:&lt;/p&gt;
&lt;p&gt;— Выразительность языка ОЧЕНЬ похожа на &lt;code&gt;Python&lt;/code&gt;. Более того, я фактически просто переписал своё решение на &lt;code&gt;Python&lt;/code&gt; 13-летней давности построчно, с парой изменений.&lt;br&gt;— &lt;code&gt;daScript&lt;/code&gt; по скорости &lt;strong&gt;в режиме интерпретации&lt;/strong&gt; находится в одной лиге с компилируемыми языками (!!!). Код по скорости сопоставим с версией на &lt;code&gt;Nim&lt;/code&gt; (чуть быстрее “наивной” &lt;strong&gt;скомпилированной&lt;/strong&gt; версии, и раза в 1.5-2 медленнее оптимизированной).&lt;br&gt;— В режиме &lt;code&gt;Ahead-of-Time&lt;/code&gt; компиляции &lt;code&gt;daScript&lt;/code&gt; обгоняет &lt;code&gt;nim&lt;/code&gt; (который вообще показывает достаточно хорошие результаты в нормальных бенчмарках с другими языками).&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="dascript" scheme="http://spiiin.github.io/tags/dascript/"/>
    
  </entry>
  
  <entry>
    <title>daScript - live-режим</title>
    <link href="http://spiiin.github.io/blog/3006126295/"/>
    <id>http://spiiin.github.io/blog/3006126295/</id>
    <published>2022-06-18T12:23:15.000Z</published>
    <updated>2022-08-01T13:02:57.136Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Попробую описать live-режим работы с приложением в <code>daScript</code> (aka <strong><code>Hot Reloading</code></strong>). Это режим работы программы, в котором можно обновлять данные и код без её перезапуска.</p><p>Интерпретируемые языки часто позволяют, с небольшими усилиями, настроить приложение так, чтобы можно было отследить изменения в каком-либо файле, и выполнить изменённую версию. При соблюдении определенных правил работы с данными также возможно обновить и уже созданные структуры данных — это требует немного больше усилий. С некоторыми заморочками и ограничениями подобное можно проделать и в компилируемых языках, к примеру, обновляя динамическую библиотеку и перезагружая её из основного приложения.</p><p>Обзоры подходов к организации hot reload на C++:<br><a href="https://fungos.github.io/cr-simple-c-hot-reload/" target="_blank" rel="noopener">cr.h: A Simple C Hot Reload Header-only Library</a><br><a href="https://ourmachinery.com/post/dll-hot-reloading-in-theory-and-practice/" target="_blank" rel="noopener">DLL Hot Reloading in Theory and Practice</a></p><p>Интерпретируемые языки требуют намного меньше “магии” для реализации и позволяют избавиться от этих ограничений, присутствующих при реализации через перезагружаемую библиотеку.</p><p>Пример того, что можно реализовать с помощью горячей перезагрузки:<br><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/a-OyoVcbwWE" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></p><p>Сочетание горячей перезагрузки кода, с data-oriented design и легкой сериализацией данных (для запоминания и восстанавления пачки состояний), с возможностью “докинуть” imgui-дебажное окно в приложение, позволяет получить близкий функционал к тому, что показано на видео, в реальной игре. Но даже возможность сократить промежуток между внесением изменений в код и проверкой его в игре, всё ещё кажется чудесной возможностью для большинства команд в геймдеве.</p><p><a href="https://youtu.be/inGb9R1NowY" target="_blank" rel="noopener">Live Stream Coding on daScript - Breakoid</a> - стрим с примером реализации арканоида, можно посмотреть на синтаксис системы ECS, реализованной с помощью макросов</p><p>В репозитории модуля <code>dasGlfw</code> есть <a href="https://github.com/borisbat/dasGlfw/blob/master/framework/main.das" target="_blank" rel="noopener">пример</a>, позволяющий работать с приложением в live-режиме.</p><h1 id="Сборка"><a href="#Сборка" class="headerlink" title="Сборка"></a>Сборка</h1><p>Выкачиваем <a href="https://github.com/GaijinEntertainment/daScript/tree/master/modules" target="_blank" rel="noopener">сабмодуль</a> <code>dasGlfw</code>. В папке с выкачанным daScript выполняем команду:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git submodule update --init --recursive</span><br></pre></td></tr></table></figure><br>Перегенерируем солюшн, чтобы добавить в него проект <code>daGlfw</code>:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;generate_msvc_2019.bat</span><br></pre></td></tr></table></figure><br>(ну или аналогичная команда для вашей любомый иде и платформы)</p><p>В тестовый пример приложения добавляем инклюды и модули daScript. Для модификации используем <a href="https://github.com/GaijinEntertainment/daScript/blob/master/examples/tutorial/tutorial01.cpp" target="_blank" rel="noopener">первый пример</a> на daScript:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"daScript/daScript.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../modules/dasGlfw/src/dasGLFW.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//dasGLFW тянет за собой зависимости от этих модулей:</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../modules/dasStbImage/src/dasStbImage.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../modules/dasStbTrueType/src/dasStbTrueType.h"</span></span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">//так как либы STB описаны в заголовочных файлах, в одну из единиц компиляции необходимо поместить код реализации этих библиотек</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STB_IMAGE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STB_IMAGE_WRITE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../modules/dasStbImage/src/stb_image.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../modules/dasStbImage/src/stb_image_write.h"</span></span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TUTORIAL_NAME   <span class="meta-string">"/modules/dasGlfw/framework/main.das"</span> <span class="comment">//основа live-приложения</span></span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span>, <span class="keyword">char</span> * [] )</span> </span>&#123;</span><br><span class="line">    NEED_ALL_DEFAULT_MODULES;</span><br><span class="line">    NEED_MODULE(Module_dasGLFW);</span><br><span class="line">    NEED_MODULE(Module_StbImage);</span><br><span class="line">    NEED_MODULE(Module_StbTrueType);</span><br><span class="line">    <span class="comment">//NEED_MODULE(Module_TestProfile); //отключаем, если не нужны</span></span><br><span class="line">    <span class="comment">//NEED_MODULE(Module_UnitTest);</span></span><br><span class="line">    Module::Initialize();</span><br><span class="line">    tutorial(); <span class="comment">//выполняем daScript</span></span><br><span class="line">    Module::Shutdown();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Также в команду линковки добавляем подключение собранных статических библиотек (в Visual Studio в свойствах проекта на вкладке свойств линкера):<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Debug\libDaScript.lib</span><br><span class="line">Debug\libDasModuleStbImage.lib</span><br><span class="line">Debug\libDasModuleStbTrueType.lib</span><br><span class="line">Debug\libDasModuleGlfw.lib</span><br><span class="line">..\..\modules\dasGlfw\libglfw\build\src\Debug\glfw3.lib</span><br></pre></td></tr></table></figure><br>(конечно, правильнее добавить зависимости в cmake-файл, чтобы не потерять настройки после перегенерации решения)</p><p>Получаем приложение, которое отслеживает изменения в файле <a href="https://github.com/borisbat/dasGlfw/blob/master/framework/example_app.das" target="_blank" rel="noopener">example_app.das</a> на лету:</p><p><img src="/blog/3006126295/das-live.png" alt="das-live"></p><p><em>с <a href="https://github.com/borisbat/dasGlfw/issues/2" target="_blank" rel="noopener">мааленьким</a> фиксом ассерта</em></p><h1 id="Архитектура-приложения"><a href="#Архитектура-приложения" class="headerlink" title="Архитектура приложения"></a>Архитектура приложения</h1><p>За счёт чего это работает? Нужно рассмотреть несколько концепций, чтобы разобраться.</p><h2 id="Контекст"><a href="#Контекст" class="headerlink" title="Контекст"></a>Контекст</h2><p>Контекст выполнения скрипта (<a href="https://github.com/GaijinEntertainment/daScript/blob/master/include/daScript/simulate/simulate.h#L246" target="_blank" rel="noopener">Context</a>) — окружение, в котором выполняется скрипт, стек и выделенные в куче переменные, а также некоторая дополнительная информация, описывающая то, как именно интерпретируется код. Контекст можно также воспринимать как экзампляр выполняющейся программы, или как результат её испполнения. В <a href="https://dascript.org/doc/reference/embedding/vm.html#execution-context" target="_blank" rel="noopener">документации</a> также указано, что контекст спроектирован для того, чтобы быть максимально легковесным, для того, чтобы сброс контекста можно было использовать как очень быстрый способ освободить всю память, которую использовал скрипт.</p><p>Хост-приложение может использовать один контекст для того, чтобы выполнять в нём различные скрипты, или же создать несколько контекстов, настроенных для различных целей. Например, можно разделить скрипты на те, которые имеют глобальное сохраняемое состояние (которые могут испольовать сборщик мусора), и скрипты без состояния, которые можно быстро освобождать после использования (например, каждый кадр), и использовать различные контексты для них.</p><p>daScript не предполагает работы с одним контекстом из различных потоков (модель многопоточности без разделяемой памяти) — в многопоточном приложении каждый поток может создать свой контекст выполнения, и использовать <a href="https://github.com/GaijinEntertainment/daScript/blob/master/include/daScript/simulate/aot_builtin_jobque.h#L21" target="_blank" rel="noopener">каналы</a> или другие самописные примитивы C++ для передачи данных/общения между потоками.</p><p>Для того, что можно было определить, безопасно ли освобождать контекст, можно заставить интерпретатор daScript проверять, что скрипт не использует глобальных переменных, которые обращающихся к хип-памяти. Один из способом сделать это — использовать настройки <code>Code of Policies</code></p><h2 id="Code-of-Policies"><a href="#Code-of-Policies" class="headerlink" title="Code of Policies"></a>Code of Policies</h2><p><a href="https://dascript.org/doc/stdlib/rtti.html?highlight=code%20policies#CodeOfPolicies" target="_blank" rel="noopener">Code of Policies</a> — настройки виртуальной машины daScript, позволяющие установить определенные правила интерпретации кода. Можно посмотреть на настройки для модуля <a href="https://github.com/GaijinEntertainment/daScript/blob/master/daslib/live.das" target="_blank" rel="noopener">live</a>, в котором определён базовый каркас для построения live-приложения.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">options no_unused_block_arguments &#x3D; false    &#x2F;&#x2F;подсказка не считать неиспользуемые аргументы ошибками компиляции</span><br><span class="line">options no_unused_function_arguments &#x3D; false </span><br><span class="line">options indenting &#x3D; 4                        &#x2F;&#x2F;настройки отступов</span><br><span class="line">&#x2F;&#x2F;!</span><br><span class="line">options multiple_contexts                    &#x2F;&#x2F;подсказка, что приложение будет иметь несколько контекстов выполнения (по коду вроде бы -- более часто вызываются колбеки &#96;reportAstChanged&#96;)</span><br></pre></td></tr></table></figure></p><h2 id="Debug-agents"><a href="#Debug-agents" class="headerlink" title="Debug agents"></a>Debug agents</h2><p>Отладочные агенты — это объекты, который задуманы для возможности отладки и профилирования выполнения контекстов, но также используются для того, чтобы клонировать контексты, с возможностью настраиваить поведение склонированного контекста.<br>Примеры использования можно найти в репозитории — <a href="https://github.com/GaijinEntertainment/daScript/search?q=fork_debug_agent_context" target="_blank" rel="noopener">fork_debug_agent_context</a>.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">forkDebugAgentContext</span> <span class="params">( Func exFn, Context * context, LineInfoArg * lineinfo )</span> </span>&#123;</span><br><span class="line">    g_isInDebugAgentCreation = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;Context&gt; forkContext;</span><br><span class="line">    <span class="keyword">bool</span> realPersistent = context-&gt;persistent;</span><br><span class="line">    context-&gt;persistent = <span class="literal">true</span>;  <span class="comment">//временно делаем контекст неудаляемым</span></span><br><span class="line">    forkContext.reset(get_clone_context(context, <span class="keyword">uint32_t</span>(ContextCategory::debug_context))); <span class="comment">//клонируем контекст</span></span><br><span class="line">    context-&gt;persistent = realPersistent;</span><br><span class="line">    g_isInDebugAgentCreation = <span class="literal">false</span>;</span><br><span class="line">    vec4f args[<span class="number">1</span>];</span><br><span class="line">    args[<span class="number">0</span>] = cast&lt;Context *&gt;::from(context);</span><br><span class="line">    SimFunction * fun = exFn.PTR;</span><br><span class="line">    forkContext-&gt;callOrFastcall(fun, args, lineinfo); <span class="comment">//выполняем функцию установки в склонированном контексте</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Примеры для изучения и понимания работы c клонированными контекстами:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">agent_fork_sample.das</span><br><span class="line">apply_in_context_example.das</span><br><span class="line">insturment_function.das</span><br><span class="line">шnstrument.das</span><br><span class="line">logger_and_logger_agent.das</span><br><span class="line">context_state_example.das</span><br></pre></td></tr></table></figure></p><h2 id="Получение-информации-из-другого-контекста"><a href="#Получение-информации-из-другого-контекста" class="headerlink" title="Получение информации из другого контекста"></a>Получение информации из другого контекста</h2><p>Нет каких-либо особенных сложностей в том, чтобы получить из одного контекста информацию из другого, как из С++, так и из daScript — можно как выполнить функцию в другом контексте (как в примерах выше), так и проверить её существование. Именно это и реализовано в модуле <a href="https://github.com/GaijinEntertainment/daScript/blob/master/daslib/live.das" target="_blank" rel="noopener">live</a>:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">var private appPtr : smart_ptr&lt;Context&gt; //указатель на пересоздаваемый живой контекст</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">private</span> <span class="title">live_lookup</span><span class="params">(fn)</span></span></span><br><span class="line">    if appPtr==null</span><br><span class="line">        <span class="keyword">return</span> false</span><br><span class="line">    <span class="keyword">if</span> !liveFunctionLookup |&gt; key_exists(fn)                 </span><br><span class="line">        liveFunctionLookup[fn] = *appPtr |&gt; has_function(fn) //если в обновляемом контексте существует функция, запоминаем указатель на неё</span><br><span class="line">    <span class="keyword">return</span> liveFunctionLookup[fn]                            </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">public</span> <span class="title">invoke_live</span> <span class="params">( fn:string )</span></span></span><br><span class="line"><span class="function">    <span class="title">if</span> <span class="title">live_lookup</span><span class="params">(fn)</span>  //если нашли указатель на функцию в <span class="title">live</span>-контексте</span></span><br><span class="line"><span class="function">        <span class="title">try</span></span></span><br><span class="line"><span class="function">            <span class="title">unsafe</span></span></span><br><span class="line"><span class="function">                <span class="title">invoke_in_context</span><span class="params">(appPtr, fn)</span> //вызываем функцию в <span class="title">live</span>-контексте</span></span><br><span class="line"><span class="function">        <span class="title">recover</span></span></span><br><span class="line"><span class="function">            <span class="title">to_log</span><span class="params">(LOG_ERROR, <span class="string">"exception during '&#123;fn&#125;'\n&#123;appPtr.last_exception&#125;\n&#123;describe(appPtr.exceptionAt)&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function">            <span class="title">appPtr</span> :</span>= null</span><br></pre></td></tr></table></figure><p>Также можно посмотреть на небольшую оптимизацию создания ресурсов в модуле <a href="https://github.com/GaijinEntertainment/daScript/blob/ecada8d34485fe32ae6e3c87b12033a00f7fe118/modules/dasOpenGL/opengl/opengl_cache.das" target="_blank" rel="noopener">opengl_cache</a> — ресурсы сохраняют в кеше, специальном контексте “opengl_cache”, за счёт чего отпадает необходимость загружать их каждый раз, когда пересоздаётся live-контекст.</p><h2 id="Восстановление-данных"><a href="#Восстановление-данных" class="headerlink" title="Восстановление данных"></a>Восстановление данных</h2><p>Организация перезагрузки функций должна стать примерно понятной, теперь надо разобраться, как пересоздаются данные, созданные в live контексте?</p><p>Приложение использует модуль <a href="https://github.com/GaijinEntertainment/daScript/blob/73b51defa5a0c66446d041743d60101fbd3e74e4/daslib/decs.das" target="_blank" rel="noopener">decs</a>, Entity-Component-System фреймворк.</p><p>Мои заметки-введение в ECS:<br><a href="/blog/381238762/" title="ECS. Ссылки">ECS. Ссылки</a><br><a href="/blog/1488389622/" title="ECS для казуальных игр">ECS для казуальных игр</a></p><p>Одна из фишек ECS — всё состояние игры описывается совокупностью из сущностей (Entity) и компонентов (Components) на них. Достаточно сохранить все сущности и компоненты, при их загрузке состояние будет полностью восстановлено.</p><p>Типы компонентов в decs задаются с помощью обычных структур, с применённым к ним атрибутом <code>[decs_template]</code>, который является макросом, регистрирующим функции <code>apply_decs_template</code> и <code>remove_decs_template</code>. Эти функции позволяют добавлять/удалять компнонент на сущностях.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">//компонент <span class="string">"пушка"</span></span><br><span class="line">[decs_template]</span><br><span class="line">struct Turret</span><br><span class="line">    base        : EntityId</span><br><span class="line">    last_target : float3</span><br><span class="line">    dir         : float</span><br><span class="line">    dir_vel     : float</span><br><span class="line">    rot_speed   : float</span><br><span class="line">    reload      : float</span><br><span class="line">    reload_time : float</span><br><span class="line">    health      : int</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_tank</span> <span class="params">( pos:float3 )</span></span></span><br><span class="line"><span class="function">    //создаём другие компоненты и сущности танка</span></span><br><span class="line"><span class="function">    ..</span></span><br><span class="line"><span class="function">    // создаём сущность "башня танка" и добавляем на неё компонент "пушка"</span></span><br><span class="line"><span class="function">    <span class="title">create_entity</span> &lt;| @ <span class="params">( eid, cmp )</span></span></span><br><span class="line"><span class="function">        <span class="title">cmp</span> |&gt; <span class="title">set</span> <span class="params">( <span class="string">"eid"</span>, eid )</span></span></span><br><span class="line"><span class="function">        <span class="title">cmp</span> |&gt; <span class="title">set</span> <span class="params">( <span class="string">"pos"</span>, float3<span class="params">(<span class="number">0.</span>)</span> )</span></span></span><br><span class="line"><span class="function">        <span class="title">cmp</span> |&gt; <span class="title">set</span> <span class="params">( <span class="string">"color"</span>, float3<span class="params">(<span class="number">.5</span>,<span class="number">.5</span>,<span class="number">0.1</span>)</span>)</span></span></span><br><span class="line"><span class="function">        <span class="title">cmp</span> |&gt; <span class="title">set</span> <span class="params">( <span class="string">"name"</span>, <span class="string">"TANK"</span> )</span></span></span><br><span class="line"><span class="function">        <span class="title">apply_decs_template</span><span class="params">(cmp, [[Turret</span></span></span><br><span class="line"><span class="function"><span class="params">            base=tank_id,</span></span></span><br><span class="line"><span class="function"><span class="params">            reload_time=TANK_TURRET_RELOAD_TIME,</span></span></span><br><span class="line"><span class="function"><span class="params">            health=TANK_HEALTH]])</span></span></span><br></pre></td></tr></table></figure><p>Компоненты в системе <code>decs</code> прозрачно для пользователя добавляются в “мир” (“пул”, “состояние”) — базу данных, описывающих состояние игровой сцены.<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">var public decsState : DecsState    //! Full state of the ESC system.</span><br></pre></td></tr></table></figure></p><p>Переключающий контекст получает эту переменную из предыдущего контекста и сериализует в память, а затем вызывает функцию десериализации в новом контексте:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">var private appPtr : smart_ptr&lt;Context&gt; //указатель на пересоздаваемый живой контекст</span><br><span class="line"></span><br><span class="line"> //сохранение ecs-состояния</span><br><span class="line"> var pvar = get_context_global_variable(appPtr, <span class="string">"decsState"</span>)</span><br><span class="line"> var pstate : array&lt;uint8&gt; ? = get_context_global_variable(appPtr, "decsLiveData")</span><br><span class="line"> var css &lt;- @ &lt;|                   //синтаксис лямбда-функции</span><br><span class="line">      saveLiveContext()</span><br><span class="line"> invoke_in_context(appPtr, css)</span><br><span class="line"></span><br><span class="line"> //смена контекста</span><br><span class="line"> appPtr := ptr</span><br><span class="line"></span><br><span class="line"> //восстановление ecs-состояния в новом контексте</span><br><span class="line">var pvar = get_context_global_variable(appPtr, <span class="string">"decsState"</span>)</span><br><span class="line">var css &lt;- @ &lt;| [[&amp;decsState,&amp;decsLiveData]] ( data : array&lt;uint8&gt;<span class="comment"># )</span></span><br><span class="line">    decsLiveData := data</span><br><span class="line">    restoreLiveContext()</span><br><span class="line">invoke_in_context(appPtr, css, decsLiveData)</span><br></pre></td></tr></table></figure></p><p>Функции <code>saveLiveContext</code> и <code>restoreLiveContext</code> выглядят тривиально, вызывают generic-функции сериализации из модуля <a href="https://github.com/GaijinEntertainment/daScript/blob/e7992b384dad13c1a201f9eee1c6a6ae1e0cf8b8/daslib/archive.das" target="_blank" rel="noopener">archive</a>:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def saveLiveContext</span><br><span class="line">    to_log(LOG_TRACE, &quot;LIVE: saveLiveContext\n&quot;);</span><br><span class="line">    decsLiveData &lt;- mem_archive_save(decsState)</span><br><span class="line"></span><br><span class="line">def restoreLiveContext</span><br><span class="line">    to_log(LOG_TRACE, &quot;LIVE: restoreLiveContext\n&quot;);</span><br><span class="line">        decsLiveData |&gt; mem_archive_load(decsState)</span><br></pre></td></tr></table></figure></p><p>При этом — если изменения не затрагивали названия полей в ECS-компонентах, то приложение может продолжить работать без переинициализации (можно, например, увеличить скорость снарядов танка прямо во время игры — уже выпущенные снаряды продолжат двигаться с той же скоростью, а новые станут быстрее).</p><p>Если же изменить название поля ECS-компонента (к примеру, автозаменой названия поля <code>reload_time</code> на <code>reload_time_11111</code>), десериализовать текущее состояние игры не выйдет , но приложение всё равно не нужно перезапускать, и оно не крешит, для продолжения работы можно просто нажать кнопку переинициализации уровня:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">public</span> <span class="title">live_keypressed</span> <span class="params">( keycode, scancode, action, mods : int )</span></span></span><br><span class="line"><span class="function">    <span class="title">invoke_live</span><span class="params">(<span class="string">"keypressed"</span>, keycode, scancode, action, mods )</span></span></span><br><span class="line"><span class="function">    <span class="title">if</span> <span class="title">is_live</span><span class="params">()</span></span></span><br><span class="line">        if scancode==19 &amp;&amp; action==1 &amp;&amp; mods==2 //нажать комбинацию клавиш "control + break"</span><br><span class="line">            recompile(true)</span><br></pre></td></tr></table></figure></p><p>При желании можно реализовать и десериализацию с возможностью переименования полей компонентов — для этого необходимо в ходе перезапуска контекста сохранить список названий всех полей компонентов в старом и новом контексте (его можно получить с помощью <code>rtti</code>) и передавать между контекстами таблицу переименований.</p><h2 id="Цикл-переключения-контекстов"><a href="#Цикл-переключения-контекстов" class="headerlink" title="Цикл переключения контекстов"></a>Цикл переключения контекстов</h2><p>Последний шаг, для связывания живого приложения с обновляемым контекстом — цикл переключения контекстов, который также тривиален (<a href="https://github.com/borisbat/dasGlfw/blob/master/dasglfw/glfw_live.das#L41" target="_blank" rel="noopener">glfw_live</a>):</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">public</span> <span class="title">glfw_live</span><span class="params">(title,appf,appd:string)</span></span></span><br><span class="line"><span class="function">    .. //различная инициализация и настройка <span class="title">glfw</span></span></span><br><span class="line"><span class="function">    <span class="title">go_live</span><span class="params">(appf, appd)</span></span></span><br><span class="line">    while glfwWindowShouldClose(glfw_live_window)==0</span><br><span class="line">        glfwPollEvents()</span><br><span class="line">        live_update(glfwGetTime())                                      //обновление live-контекста</span><br><span class="line">        invoke_live(<span class="string">"display"</span>, display_w, display_h)                    //вызов функции рисования экрана в live-контексте</span><br><span class="line">        glfwMakeContextCurrent(glfw_live_window)</span><br><span class="line">        glfwSwapBuffers(glfw_live_window)                               //отрисовка экрана</span><br><span class="line">        <span class="keyword">if</span> watch_files()                                                //если файл с исходником live-контекста изменился</span><br><span class="line">            recompile()                                                 //пересоздать live-контекст</span><br></pre></td></tr></table></figure><h1 id="Идеи"><a href="#Идеи" class="headerlink" title="Идеи"></a>Идеи</h1><ul><li>Live Creative &amp; Prototype Coding — всё из видео в начале заметки</li><li>Автозапись ECS-состояний для воспроизведения того, что делали с игрой тестировщики, с проигрыванием на любой скорости и обратной перемоткой</li><li>Hot-reload кода и данных на удалённом клиенте (мобильном телефоне, консоли)</li><li>Совместная работа над сценой на удалённом клиенте (или реализация AI Battles в песочнице)</li><li>Сериализация не только сущностей и компонентов, но и систем — песочница механик</li></ul><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;Попробую о
      
    
    </summary>
    
    
    
      <category term="opengl" scheme="http://spiiin.github.io/tags/opengl/"/>
    
      <category term="dascript" scheme="http://spiiin.github.io/tags/dascript/"/>
    
      <category term="ecs" scheme="http://spiiin.github.io/tags/ecs/"/>
    
  </entry>
  
  <entry>
    <title>Индустрия снова во мгле</title>
    <link href="http://spiiin.github.io/blog/2786387393/"/>
    <id>http://spiiin.github.io/blog/2786387393/</id>
    <published>2022-06-12T18:39:23.000Z</published>
    <updated>2022-10-08T09:36:18.624Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><h2 id="Давным-давно-в-далёкой-далёкой-галактике…"><a href="#Давным-давно-в-далёкой-далёкой-галактике…" class="headerlink" title="Давным-давно, в далёкой-далёкой галактике…"></a>Давным-давно, в далёкой-далёкой галактике…</h2><p>Давным-давно, в 2007 году, рынок разработки пк-игр в россии и снг внезапно накрылся (крякнул, сыграл в ящик, мы его потеряли). Состояние индустрии на тот момент описал в статье на dtf и в своём блоге в жж Петр “Amicus” Прохоренко. На сайте статьи уже нет, но <a href="https://web.archive.org/web/20071219121354/http://www.dtf.ru/blog/read.php?id=49254" target="_blank" rel="noopener">интернет всё помнит</a> (<a href="https://web.archive.org/web/20071220173806/http://amicus-hg.livejournal.com/85101.html" target="_blank" rel="noopener">всё-всё</a>).</p><p>Основные причины, по мнению автора:</p><ul><li>Неготовность индустрии к изменениям. Нет культуры разработки.<br>Компании клепали игры, и не задумывались о том, что происходит вокруг.</li></ul><blockquote><p>Опыт разработки игр не особенно передавался не то, что по индустрии, но и внутри компаний. Условия существования стали “вдруг” намного более жёсткими, а разработчики оказались к этому не готовы. При этом – повсеместно фантастическая безответственность в плане принятия решений и полное отсутствие гибкости и желания взглянуть в будущее.  Если судить цинично, то большинство «компаний одной игры», где нет своей развитой технологической базы и идущих внахлест друг за другом двух-трех проектов, были обречены изначально – любое изменение рынка убило бы их в первую очередь. Вопрос, почему значительная часть российских компаний, существующих не первый год, так и осталась сидеть на одном проекте, возвращает нас к началу этого абзаца.</p></blockquote><ul><li>Издатели не научились продюссировать и не умеют в маркетинг<br>В 2008 появился iPhone с магазином Appstore и появился инструментарий Steamworks в Steam, а пиратские игры на дисках продавались по цене диска.</li></ul><blockquote><p>Так у нас еще и не сформировались нормальные институты продюсирования, маркетинга и продвижения проектов. С продюсированием вообще швах полный – никакой системности, у каждого свои методы работы, и что самое главное такой уровень перегруженности самих продюсеров, что их присутствие «в проекте» в принципе сведено к минимуму. Маркетинг традиционно тыкает пальцем в небо и строит воздушные замки, хотя в этом направлении у некоторых издателей есть определенные позитивные подвижки.</p></blockquote><p>Итоги:</p><blockquote><p>Кризис – это что-то преходящее, после него должна наступить ремиссия и пережившим его участникам рынка станет лучше, а некоторым так и вообще сильно хорошо. У нас не кризис, у нас просто заканчивается целая эпоха, и развитие отечественной индустрии направляется в другую сторону.</p></blockquote><p>В комментариях — тонны ангста и отрицания, нет никакой “вомглы”.</p><p>Также виноваты по разным версиям:<br><a href="http://neolurk.org/wiki/%D0%92%D0%BE%D0%BC%D0%B3%D0%BB%D0%B0" target="_blank" rel="noopener">Вомгла</a></p><ul><li>Геймдизайнеры</li></ul><blockquote><p>В России много хороших программистов. Нередки даже талантливые. Есть художники, композиторы. А вот число Геймдизайнеров и креативных лидеров — константа, равная 3.5 Анонимусам.</p></blockquote><ul><li>Менталитет</li></ul><blockquote><p>Но тут вмешивается менталитет. Русскому разработчику необходимо, чтобы над ним кто-то постоянно нависал грозной тенью и тыкал носом в четко поставленную задачу, требуя отдачи. Совместные мозговые штурмы, энтузиазм, проявление инициативы, рассмотрение нескольких вариантов, трезвая оценка собственных сил — все это чуждо большинству из них.</p></blockquote><p><a href="https://boris-batkin.livejournal.com/11324.html" target="_blank" rel="noopener">ЖЖ</a> (хех, только заметил, что это автор <code>daScript</code>)</p><ul><li>Тотальный непрофессионализм</li></ul><blockquote><p>с точки зрения регистрации на ДТФ есть 367 работающих компаний разработчиков игр. есть мнение, что после того, как уляжется пыль, 367 профессионально-пригодных разработчиков можно и не найти.</p></blockquote><h2 id="Попытки-рефлексии"><a href="#Попытки-рефлексии" class="headerlink" title="Попытки рефлексии"></a>Попытки рефлексии</h2><p>Какие-то компании различными способами пережили мглу, потому что смогли делать научиться делать казуалки, портировать их на мобильные платформы, или же умели делать игры для консолей. Появлялись новые компании, приходили новые люди. Где-то в этот период попал в индустрию и я (угу, к “Гайдзинам”, которые умели в консоли, и начали учиться в iPhone). Кто-то пытается отрефлексировать то, что происходило тогда, до сих пор.</p><p><a href="https://web.archive.org/web/20180501041548/https://arcticengine.com/posts/vomgla_article/" target="_blank" rel="noopener">Заметки из 2018</a>, с несколькими интересными картинками.<br><a href="https://vk.com/@theworldissaved-russkie-igry-vo-mgle" target="_blank" rel="noopener">Статья</a>, собранная из пачки <a href="https://twitter.com/YarKravtsov/status/1357395078583566337" target="_blank" rel="noopener">твиттов</a>Ярослава Кравцова, рожденная срачем между какими-то <a href="https://youtu.be/50d6rqNjptM" target="_blank" rel="noopener">обзорщиками</a> с ютуба и <a href="https://youtu.be/zfAKuReIjF0" target="_blank" rel="noopener">подкастерами</a><br>Еще забавный <a href="https://youtu.be/Rvc5uiURLH0" target="_blank" rel="noopener">доклад</a> явно неотрефлексировшего ситуацию чувака.</p><blockquote><p>до 2007 типа российские компании делали по его мнению крутые и душевные игры, на которых мы все выросли, но “почему-то” в один момент развалилось всё (из крупных компаний, образованных до 2007 года, которые немобилками занимались, ща остались только гайдзины и wargaming - первые потому что под нексген консоли игры делали для sony и microsoft, вторые танки в 2009 выпустили), отчасти потому что в таком режиме делали фигню разную не задумываясь, и издатели в один момент забили на финансирование местных полностью и стали выпускать и локализовать иностранные игры, отчасти потому, что пропустили 2 новых аудитории - соц игры фейсбука и мобильные игры. Теперь говорит “а давайте как раньше делать, как будто ничего не изменилось, а мобилки эти ваши новомодные скоро умрут”, и реклама своей компании напоследок. В западной индустрии и инди-сцене году так в 2010 уже приняли, что есть кор игры и социальные (там против зинги вначале тоже выступали кор-разработчики), а в российской ещё местами есть люди, которые считают, что кроме кор-игр других нет, и должно быть стыдно тем, кто делает не игры “для души” (если точнее, то игры основных тем для аудитории мужчины 15-30, первые “большие продающиеся идеи” - sports, dragons, robots, guns, jumping &amp; climbing, and car) <a href="https://www.raphkoster.com/2010/03/18/what-core-gamers-should-know-about-social-games/" target="_blank" rel="noopener">https://www.raphkoster.com/2010/03/18/what-core-gamers-should-know-about-social-games/</a></p></blockquote><p>Зачем я собрал все эти срачи, обсуждения, тревоги и мнения в одну кучу? Хотел найти список компаний, перечисленных Ярославом, как спонсоров Девгамма по годам их открытия, чтобы посмотреть, какие выживут через несколько месяцев/лет.</p><h2 id="No-future"><a href="#No-future" class="headerlink" title="No future"></a>No future</h2><p>В 2022 году рынок разработки мобильных игр в россии внезапно накрылся (крякнул, сыграл в ящик, мы его потеряли). И вновь:</p><blockquote><p>У нас не кризис, у нас просто заканчивается целая эпоха, и развитие отечественной индустрии направляется в другую сторону.</p></blockquote><p><img src="/blog/2786387393/bk.png" alt="bk"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ZeptoLab - 2009</span><br><span class="line">Pixonic - 2009</span><br><span class="line">~~MyTona~~ - 2012 - https:&#x2F;&#x2F;yakutia.info&#x2F;article&#x2F;206258</span><br><span class="line">~~Game Insight~~ - 2009 - 2022 https:&#x2F;&#x2F;app2top.ru&#x2F;industry&#x2F;game-insight-ushla-na-samolikvidatsiyu-raboty-lishilis-do-600-spetsialistov-199488.html</span><br><span class="line">~~Playgendary~~ - 2016 - https:&#x2F;&#x2F;www.forbes.ru&#x2F;tekhnologii&#x2F;469235-deneg-net-delajte-cto-hotite-kak-gejmstudii-uhodat-iz-rossii-i-sokrasaut-personal</span><br><span class="line">KamaGames - 2010</span><br><span class="line">CrazyPanda - 2010</span><br><span class="line">Easybrain - 2016</span><br><span class="line">Owl Studio - 2015</span><br><span class="line">Social Quantum - 2010</span><br><span class="line">Playkot - 2009</span><br><span class="line">Belka Games - 2010</span><br><span class="line">Vizor Games - 2007</span><br><span class="line">Rocket Jump (RJ Games) - 2012</span><br><span class="line"></span><br><span class="line">~~Playrix~~ - 2004 - казуальные игры - https:&#x2F;&#x2F;dtf.ru&#x2F;gameindustry&#x2F;1384763-smi-playrix-reshila-zakryt-vse-svoi-ofisy-v-rossii-i-belarusi-sotrudnikov-relociruyut-v-drugie-strany</span><br><span class="line">G5 - 2001 - мобильные и казуальные игры</span><br><span class="line">Nekki - 2002 - браузерки</span><br><span class="line">Gaijin Entertainment - 2002 - релизы на консолях</span><br><span class="line">Wargaming - 1998 - выход World of Tanks в 2009</span><br></pre></td></tr></table></figure><p><em>update</em><br><a href="https://youtu.be/sFqbmVpGuUw?t=1348" target="_blank" rel="noopener">Тайминг</a> из интервью с Сергеем Орловским, про ситуацию на мобильном рынке </p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;h2 id=&quot;Давны
      
    
    </summary>
    
    
    
      <category term="gamedev" scheme="http://spiiin.github.io/tags/gamedev/"/>
    
  </entry>
  
  <entry>
    <title>daScript - перевод интервью с создателем языка</title>
    <link href="http://spiiin.github.io/blog/2630317622/"/>
    <id>http://spiiin.github.io/blog/2630317622/</id>
    <published>2022-06-12T14:13:37.000Z</published>
    <updated>2022-06-15T17:19:24.011Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Свободный перевод части <a href="https://80.lv/articles/a-look-at-the-current-state-of-independent-gamedev-software-production/" target="_blank" rel="noopener">статьи</a> <code>A Look At The Current State of Independent Gamedev Software Production</code>, интервью с автором языка daScript Борисом Баткиным. Курсивом — мои вставки. Иногда осознанно немного перефразирую или уточняю ответы.<br><a id="more"></a></p><p>Пост посвящен храбрым разработчикам и небольшим инди-командам, создающим собственные технологические решения для разработки игр.</p><p>Сегодня у нас есть множество мощных движков, доступных бесплатно: <code>Unreal, Unity, Lumberyard, CryEngine</code> и другие решения. Они содержат полный набор инструментов, позволяющий разработчикам экономить время на разработке собственных тулзов.</p><p><em>хм, ну не то, чтобы прямо совсем бесплатно доступны…</em></p><p>…</p><p>Но всё же некоторые разработчики продолжают находить причины, чтобы разрабатывать собственные движки. И мы говорим не только о гигантах вроде <code>Guirilla Games</code> или <code>Rockstar</code>. Одиночки или небольшие инди-команды предлагают свои решения, которые призваны справиться с недостатками существующих решений. Не слишком ли сложно это для маленькой команды? Мы связались с авторами нескольких таких технологий, чтобы узнать у них об их мотивах, проблемах, временных затратах и другом.</p><p><em>если говорить о daScript, то “Гайдзины” — не то, чтобы маленькая команда, и имеет свои наработки в области скриптовых языков, а также использования их в продакшене, где-то лет так 15 как минимум</em></p><p>…</p><h2 id="Разработка-daScript"><a href="#Разработка-daScript" class="headerlink" title="Разработка daScript"></a>Разработка daScript</h2><p>Мы связались с Борисом Баткиным, разработчиком <code>daScript</code>. Это высокоуровневый скриптовый язык с сильной статической типизацией. Цель разработки — создать быстрый язык для встраивания в качестве скриптового языка в C++ для критичных по производительности приложений, таких как игры. Посмотрим внимательнее на <code>daScript</code> и на то, как он может помочь улучшить производительность.</p><p><strong>Расскажи пожалуйста о daScript. Почему и когда ты начал над ним работать?</strong></p><p>С самого начала моей карьеры как программиста я хотел создать собственный язык. Фактически, первое, чем я занимался, работая в игровой индустрии в 2000х, было написание кросс-компилятора из <code>UnrealScript</code> в <code>C++</code>. С тех пор я думал о создании своего языка.</p><p>В 2005 я создал несколько черновиков и прототипов, когда я работал на <code>Naughty Dogs</code> и они экспериментировали со своим лиспо-подобным языком <code>Goal</code>, от которого им пришлось отказаться при переходе от PlayStation2 к PlayStation3. Тогда у нас было много продуктивных дискуссий, который натолкнули меня на некоторые идеи.</p><p><em>позволю себе втыкнуть сюда собственные размышления о языках программирования, применительно к геймдеву и не только</em><br><em><a href="/blog/3652741154/" title="10 лет в геймдеве">10 лет в геймдеве</a> — раздел языки программирования, про опыт использования разных языков<br><a href="/blog/1808122922/" title="Nim in imaginary world">Nim in imaginary world</a> — мои критерии выбора языка для хобби- и профессиональной разработки<br><a href="/blog/2297379949/" title="Заметки о языках программирования">Заметки о языках программирования</a> — сборник заметок про языки разного уровня и целей<br><a href="/blog/1728194429/" title="С++ в геймдеве">С++ в геймдеве</a> — почему C++ и всё ли с этим правильно</em></p><p>Уже тогда было до боли очевидно, что язык должен быть встраиваемым (<em>в С++</em>). Большинство компаний используют для создания игр подмножество <code>C++</code> (каждая — своё). Какой бы скриптовый язык мы ни придумали, он должен хорошо совмещаться с существующей кодовой базой. Можно думать о <code>C++</code> как платформе, тогда специализированный язык для игр должен работать на этой платформе. Подобные вещи происходили с другими платформами. <code>Java</code> получила <code>Scala</code>, а позже <code>Kotlin</code>, браузер в определенный момент стал платформой, и получил несколько языков, транслируемых в <code>JavaScript</code>, у <code>.Net</code> сначала был только <code>C#</code>, но позже получил жизнеспособный <code>F#</code>. <code>daScript</code> является чем-то подобным для <code>C++</code>.</p><p>Игровая индустрия давно нуждается в более практичном решении. C++ нельзя назвать идеальным языком программирования, если не сказать ещё хуже. Он многословен, он имеет очень крутую кривую обучения. Мультиплатформенное программирование на C++ напоминает обход минного поля. Вcё может внезапно взорваться. Но при этом, он позволяет создать надёжный код, поэтому мы его используем. Но желание иметь простое решение для быстрых итераций разработки — очень привлекательно.</p><p>Встроенные языки, которые обычно используются в индустрии игр, динамически типизируемые, с дорогостоящей передачей управления между C++ и скриптовым языком. <code>Lua (с LuaJIT), Squirrel, DukTape/QuickJS</code> - вот только некоторые из примеров. В большинстве из них лучшая производительность достигается за счёт just-in-time (JIT), но такая возможность вообще не доступна на большинстве закрытых платформ, таких как консоли или iOS. Маршаллинг данных между нативным и скриптовым кодом быстро становится серьёзной проблемой, даже при включенном JIT. Как правило, такая производительность приемлема только для event-driven приложений с отправкой сообщений, и на этом точка. Но такой подход не масштабируется для приложений типа игр. В результате большая часть “тяжёлого” кода либо сразу пишется на C++, либо же сначала пишется прототип на скриптовом языке, который затем переписывается на C++.</p><p><em>Антон Юдинцев в своём <a href="https://youtu.be/IvHGczF6Go0?t=1301" target="_blank" rel="noopener">докладе</a> про daScript ссылается в качестве примера на <a href="https://youtu.be/KHWquMYtji0" target="_blank" rel="noopener">доклады</a> про оптимизацию Fortnite на мобильные платформы — большая часть оптимизаций заключается в том, чтобы переписать код с блюпринтов на C++. Мой опыт использования Squirrel в продакшене для мобильных телефонов — ~20% работы состоит в переписывании со скриптов обратно на C++</em>.</p><p>Есть примеры статически типизированных скриптовых языков в геймдеве, <code>UnrealScript</code> — один из первых заметных успешных. Однако он показал проблемы с масштабируемостью. Рано или поздно наступает момент, когда “переписать медленную часть на C++” становится типичным решением проблем с производительностью в проекте. В конце концов, <code>Unreal</code> перешёл к <code>BluePrint</code>, у которого есть собственные минусы.</p><p>ООП в стиле C++ (<em>данные разбросаны на хипе</em>) - серьёзное препятствие для написания быстрого кода. Большинство языков предназначены в основном для поддержки той или иной модели программирования. Однако в разработке игр в наши дни часто необходим более ориентированный на данные подход (<em>data oriented design</em>). Многие переходят на ECS-фреймворки, которые сопровождаются какой-либо дополнительной инфраструктурой. <code>Unity</code> создала компилятор <code>Burst</code>, использующий подмножество C# для решения проблемы связи фреймворка с языком. Джонатан Блоу разрабатывает язык <code>Jai</code> для решения той же проблемы. Языки, которые изначально спроектированы с учётом возможности использования с data-oriented фреймворками, могут сделать взаимодействие с ними проше, и <code>daScript</code> делает шаг в этом направлении.</p><p>Когда в 2018 году Антон Юдинцев из <code>Gaijin Entertaiment</code> обратился ко мне с предложением создать собственный язык для их ECS-фреймворка, я “купился”. Запрос был достаточно конкретным, чтобы заинтересовать меня — язык общего назначения с “большой идеей” это не просто академическое упражнение, его очень трудно создать и еще труднее адаптировать к продакшену.</p><p><strong>Какие преимущества использования daScript? Как его можно использовать для разработки игр? Как это повлияет на производительность?</strong></p><p><code>daScript</code> работает быстро. Передача управления между C++ и daScript очень дешёвая. У него очень быстрый интерпретатор. Он выполняется с той же скоростью, что и нативный C++, если использует ahead-of-time компиляцию. По сути, вам никогда не придётся ничего переписывать с daScript на C++.</p><p><strong><em><code>(!) Это серьёзная заявка на киллер-фичу языка. Одну из. Вторая -- при небольшой настройке должно быть можно получить hot code reload, время перекомпиляции+перезапуска игры на мобилках, да и на ПК, критично</code></em></strong></p><p>daScript — безопасный, статически типизированный язык с сильной типизацией, с параноидальным уровней проверки ошибок. Однако у него очень надёжный механизм вывода типов, поэтому большая часть времени вам не нужно декорировать свой код информацией о типах. Безопасный код на языке обычно и выглядит просто, а небезопасный — должен быть явно помечен как таковой.</p><p>daScript — встраиваемый язык. Он хорошо сочетается с вашей кодовой базой на C++. Он сам компилируется тем же компилятором на тех же платформах. Нет проблемы с тем, что платформа не поддерживает JIT, потому что вы можете просто пред-компилировать все скрипты в C++ (aheod-of-time компиляция). При этом, вы можете “патчить” скопмилированные в C++-скрипты с помощью обновлённой интерпретируемой версии в реальном времени.</p><p><em>(Либо обновляя скрипты на девайсе на лету, либо присылая их “динамиками” с сервера)</em></p><p>Язык предоставляет очень глубокие механизмы интеграции, которые выходят далеко за рамки простого связывания методов, чтобы такие вещи, как ECS-фреймворк, могли получить всю необходимую им дополнительную информацию, как используются данные. Мы можем контроллировать, как именно интерпретируется daScript, и какой именно C++ код будет сгенерирован.</p><p><em>(Тут я чё-то не допонимаю, о чём именно говорит автор, не видел в репозитории примеров, возможно речь о <a href="/blog/1547564887/" title="синтаксических макросах">синтаксических макросах</a>)</em></p><p><strong>update</strong><br><em>Связался с Борисом лично для уточнения. Помимо макросов, для типов, описанных в C++, возможно также задавать кастомные simulate-функции и то, как они будут трансформироваться в C++ код (aot-компиляция). Т.е. фактически переопределить в типе любые синтаксические формы обращения с ним, как он ведёт себя на любой чих — сделать с помощью этого какой угодно DSL. В отличие от макросов, можно указывать, как генерируется AOT, и за счёт этого получать оптимальный код. Например, различные vector swizzle операции трансформировать в SIMD-инструкции.</em></p><p>daScript — язык для повышения продуктивности программистов. У него очень быстрое время компиляции. Он поддерживает горячую перезагрузку. Обычно изменения в коде отображаются в программе, как только они слетели с кончиков ваших пальцев. При правильной настройке вы можете запустить приложение и затем реализовать совершенно новую фичу, даже не перезапуская его.</p><p><strong><em><code>(!) а это -- заявка на киллер-фичу #2</code></em></strong></p><p><strong>Разработка собственного решения может показаться слишком сложной для большинства разработчиков, что же заставляет кого-то создавать что-то новое и сложное?</strong></p><p>Некоторые говорят, что необходимость — это мать изобретений. В какой-то момент становится совершенно очевидно, что никакие эволюционные улучшения не позволят сделать следующий шаг в качестве разработки. Наличие хорошего инструмента является признаком хорошего инженерного мышления. В случае с daScript было очевидно, что информацию, необходимую для среды ECS, очень сложно извлечь из кода на C++. Что программисту необходимо будет искуственно размечать код определенным образом, и этот процесс будет постоянно подвержен ошибкам в ходе написания и поддержки, и это просто чтобы предоставить информацию для эффективной работы фреймворка. Добавьте к сравнению разницу в скорости — даже прототип daScript был в 10-35 раз быстрее, чем LuaJit, и вдруг создание новый языка уже покажется очень хорошим вложением.</p><p><code>LuaJit</code> бьл хорошим источником вдохновения. Удивительно, как много можно сделать для языка, который не был спроектирован для достижения максимальной производительности. Если же сделать что-то подобное для языка, который изначально затачивался, чтобы быть производительным, должно быть возможно достичь поразительных результатов. При этом превзойти LuaJit — это непростой челлендж, он задаёт высокую планку, ни один интерпретируемый язык не может даже близко приблизиться к нему.</p><p>Когда дело доходит до фич самого языка, то идеи брались из самых различных источников: <code>Kotlin, Python, Ruby, Lisp, F#, HLSL</code> (!!!) — всего лишь некоторые из них. Одной из ключевых идея было “сделать что-то похожее, только работающее с сумасшедшей скоростью”.</p><p>Другая идея: “писать меньше лишнего”. Наличие в языке простых, но сильных генериков было обязательным с самого начала. Статически типизируемые языки без обобщений и вывода типов, как правило, очень многословны. С другой стороны, декларативное обобщенное программирование очень контр-интуитивно, поэтому мы пошли путём возможности проверки условий во время компиляции и при этом возможностью явно указать…, ну, вообще всё.</p><p><em>(? в оригинале: and explicit… well, explicit everything.)</em></p><p>Сосредоточение внимания на функциональном программировании и data-oriented design подходе, а не на классическом ООП, было еще одним сознательным решением. Язык должен был быть быстрым, а классическое ООП просто не позволило бы сделать его таким.</p><p><strong>Расскажи пожалуйста, о затратах времени. Сколько времени ушло на то, чтобы создать ядро языка? Какие дальнейшие планы?</strong></p><p>Потребовалось 3 месяца, чтобы создать прототип. С тех пор прошло около года, и язык сильно повзрослел. Теперь он работает у нас на клиенте и на сервере, и объём кода только растёт. Роадмап развития языка:</p><ul><li>Доработать язык до спецификации. Сейчас в нём не хватает нескольких важных задуманных вещей.<br>— Variant types.<br>— Мощный pattern-matching.<br>— Нативная поддержка генераторов (yield).<br>— Нативная поддержка регулярных выражений.</li><li>Переписать компилятор daScript и всё остальное (кроме рантайма) на нём самом.<br>— Это даст возможность представлять AST языка для чтения и записи на нём самом. Сейчас, сложные макросы и аннотации функция необходимо писать на нём самом.<br><em>(доступ к ast из daScript есть на момент перевода статьи, как и часть фич выше)</em></li><li>GPU бекэнд. Сейчас aot-компиляция доступна только в C++, но нет никакой фундаментальной причины для этого ограничения.</li><li>Стандартная библиотека и дополнительные модули.<br>— В стандартной библиотеке не хватает многих вещей, особенно для функционального программирования. Как только будут доделаны генераторы, следом нужно будет реализовать стандартные функции высшего порядка.<br><em>(вроде тоже есть уже)</em><br>— Существует несколько де-факто стандартных библиотек, для которых стоит сделать привязку “из коробки”. PugiXml, RapidJson, UriParser и другие.</li><li>Оптимизации, множество и множество оптимизаций.<br>— daScript уже оптимизирующий компилято с большими возможностями, которые будут только расти.<br>— daScript уже экстремально быстрый интерпретатор. И это лишь хорошая причина для того, чтобы сделать его еще быстрее.<br>— daScript при AoT-компиляции генерирует вполне читабельный C++-код. Однако мы хотели бы сделать, чтобы результирующий код на C++ был более надёжным.</li></ul><p>Несмотря на то, что еще слишком рано для standalone компилятора daScript, уже очевидно, что LLVM-бекэнд позволил бы генерировать значительно лучший код, чем AoT-бекэнд. Компилятор daScript знает некоторые факт о том, как используется код, такие как выравнивание, aliasing, зависимости и т.д., которые очень сложно передать компилятору C++. Так что в какой-то момент, вероятно, появится LLVM-бекэнд и возможность использовать daScript для полного цикла разработки, но я не думаю, что это произойдёт скоро.</p><p><a href="https://github.com/borisbat" target="_blank" rel="noopener">Борис Баткин</a>, разработчик языка <a href="https://dascript.org/" target="_blank" rel="noopener">daScript</a></p><p><em>От себя добавлю немного</em>:</p><ul><li>Скорость итераций разработки, который можно добиться с помощью скриптов — ключевой путь к качеству и выживанию игры-сервиса (а такие — почти все игры сейчас)</li><li>Скорость кода — важный параметр, чтобы у вас телефон с 4х-ядерным процессором, и вообщем-то неплохим GPU и кол-вом RAM не считался “тостером” (у конкурентов-то игра на нём отлично работать будет)</li><li>Отсутствие необходимости переписывать код с одного языка на другой ради ускорения просто экономит время, за которое можно сделать что-нибудь новое</li><li>До продакшена долетают типичные ошибки C++ (а это у всех бывает, в тексте ссылка на доклад Антона Юдинцева о статистике ошибок в Warthunder) — если станет меньше C++-кода (и меньше доступа к этому коду у неквалифицированных программистов) - станет и меньше таких ошибок</li><li>Высокая скорость разработки фич (hot-code reload об этом) — один из необходимых моментов для перехода к созданию более масштабных в плане количества кода игр (эх, ещё бы стоимость создания арта для более масштабных проектов как-нибудь сократить)</li></ul><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Свободный перевод части &lt;a href=&quot;https://80.lv/articles/a-look-at-the-current-state-of-independent-gamedev-software-production/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;статьи&lt;/a&gt; &lt;code&gt;A Look At The Current State of Independent Gamedev Software Production&lt;/code&gt;, интервью с автором языка daScript Борисом Баткиным. Курсивом — мои вставки. Иногда осознанно немного перефразирую или уточняю ответы.&lt;br&gt;
    
    </summary>
    
    
    
      <category term="dascript" scheme="http://spiiin.github.io/tags/dascript/"/>
    
  </entry>
  
  <entry>
    <title>daScript: C++ auto-bindings, assimp</title>
    <link href="http://spiiin.github.io/blog/500729544/"/>
    <id>http://spiiin.github.io/blog/500729544/</id>
    <published>2022-06-12T11:41:20.000Z</published>
    <updated>2022-08-01T13:03:34.379Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Продолжение предыдущего поста с генерацией модулей daScript к С++-библиотекам с помощью автоматического генератора <code>dasBind</code>.<br><a href="/blog/4090909622/" title="daScript: C++ auto-bindings, msgpack">daScript: C++ auto-bindings, msgpack</a></p><p>На этот раз чуть более сложный случай с библиотекой <a href="https://github.com/assimp/assimp" target="_blank" rel="noopener">assimp</a>, которая позволяет загружать 3d-модели в различных форматах. Для начала — собираем библиотеку из исходников. Я бы рекомендовал версию 4.1.0, как стабильную, в более новых сломаны некоторые настройки постпроцессинга загруженных мешей.</p><p>Привязки assimp к другим языкам в основном репозитории малость заброшены, так что попутно починим и их.</p><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p>Самый простой случай — достаточно поправить синтаксические отличия между Python 2 и 3. </p><h2 id="DotNet-open3mod"><a href="#DotNet-open3mod" class="headerlink" title="DotNet, open3mod"></a>DotNet, open3mod</h2><p>Живёт <a href="https://github.com/acgessler/open3mod" target="_blank" rel="noopener">тут</a>, необходимо:</p><ul><li>Собрать библиотеку assimp в DLL, переименовать в Assimp32.dll или Assimp64.dll.</li><li>Собрать библиотеку AssimNet.dll с классами обёртками.</li><li>Собрать проект <code>AssimpNet.Interop.Generator</code>, который нужен, чтобы <a href="https://github.com/acgessler/open3mod/blob/master/libs/assimp-net/AssimpNet.Interop.Generator/Program.cs#L34" target="_blank" rel="noopener">пропатчить</a> IL-код из AssimpNet размерами типов, полученных из PDB файла. Для этой техники используется библиотека <a href="https://www.mono-project.com/docs/tools+libraries/libraries/Mono.Cecil/" target="_blank" rel="noopener">Mono.Cecil</a>.</li><li>Пропатчить библиотеку (данный шаг прописан в PostBuild-степ в решении, но лучше убедиться, что он корректно отработал)</li><li>Собрать и запустить open3Mod - просмотрщик, в котором можно проверить работоспособность библиотеки.</li></ul><h2 id="daScript"><a href="#daScript" class="headerlink" title="daScript"></a>daScript</h2><p>Автоматический генератор привязок <code>dasBind</code> не работает с C++ template-кодом, но все заголовочные файлы <code>assimp</code> поддерживают также c-интерфейс. Однако без некоторой “доработки напильником” воспользоваться этим интерфейсом не удастся, так как, несмотря на то, что генератору привязок можно указать, чтобы он парсил заголовочные файлы как c-код, возникают ошибки двойного определения типов при использования этих же хидеров в C++ коде самого проекта, который будет использовать эти привязки. Причины такого поведения — попытка различать, какой из интерфейсов использовать с помощью макроса <code>__cplusplus</code>, который всегда определён в C++ коде (<code>exrern &quot;C&quot;</code> его не отключает).</p><p>Однако можно пойти на хитрость, и просто заменить во всех исходниках макрос <code>__cplusplus</code> на какой-нибудь кастомный, который не будет определен в коде, чтобы как <code>dasBind</code>, так и использующий сгенерированный C++-модуль <code>dasAssimp</code>, “увидели” именно сишный интерфейс к библиотеке.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#replace_cplusplus_to_custom.py</span></span><br><span class="line"><span class="comment">#Script for replace __cplusplus text to some other build directive (__CUSTOM_CPP_DEFINE)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">HEADERS_PATH = <span class="string">"."</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> fname <span class="keyword">in</span> os.listdir(HEADERS_PATH):</span><br><span class="line"><span class="keyword">if</span> os.path.isfile(os.path.join(HEADERS_PATH, fname)) <span class="keyword">and</span> os.path.splitext(fname)[<span class="number">1</span>] != <span class="string">".py"</span>:</span><br><span class="line">print(<span class="string">"Proccessing"</span>, fname)</span><br><span class="line"><span class="keyword">with</span> open(fname, <span class="string">"rt"</span>) <span class="keyword">as</span> f:</span><br><span class="line">lines = f.readlines()</span><br><span class="line">newlines = []</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">newlines.append(line.replace(<span class="string">"__cplusplus"</span>, <span class="string">"__CUSTOM_CPP_DEFINE"</span>))</span><br><span class="line"><span class="keyword">with</span> open(fname, <span class="string">"wt"</span>) <span class="keyword">as</span> f:</span><br><span class="line">f.writelines(newlines)</span><br></pre></td></tr></table></figure><p>Ну и дальше, аналогично инструкции в предыдущем посте:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AssimpGen</span> :</span> CppGenBind</span><br><span class="line">    override func_to_stdout = false</span><br><span class="line">    unique_functions : table&lt;string; bool&gt;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">AssimpGen</span></span></span><br><span class="line">        bind_root = "&#123;get_das_root()&#125;/modules/dasAssimp/src"</span><br><span class="line">        bind_module = <span class="string">"assimp"</span></span><br><span class="line">        bind_das_module = <span class="string">"assimp"</span></span><br><span class="line">        let pfn = <span class="string">"assimp/include_all_import.h"</span></span><br><span class="line">        //<span class="comment"># тут пользуемся сгенерированными сишными заголовочными файлами</span></span><br><span class="line">        let pfp = <span class="string">"&#123;get_das_root()&#125;/modules/dasAssimp/assimp/include_c/"</span> </span><br><span class="line"></span><br><span class="line">        let args &lt;- [&#123;string</span><br><span class="line">            <span class="string">"-xc++-header"</span>;</span><br><span class="line">            <span class="string">"-std=c++1z"</span>;</span><br><span class="line">            <span class="string">"-I&#123;get_full_file_name(pfp)&#125;"</span>;</span><br><span class="line">            <span class="string">"-DSWIG"</span></span><br><span class="line">        &#125;]</span><br></pre></td></tr></table></figure><p>и дописываем функцию преобразования <code>dasString</code> в <code>std::string</code>, чтобы генератор привязок мог понять, как с ней работать</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">das_aiString_to_string</span><span class="params">(aiString* <span class="built_in">string</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">string</span>-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Module_assimp::initMain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">addExtern&lt;DAS_BIND_FUN(das_aiString_to_string)&gt;(*<span class="keyword">this</span>, lib, <span class="string">"assimp_str"</span>,</span><br><span class="line">SideEffects::worstDefault, <span class="string">"das_aiString_to_string"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>После генерации модуля можно попробовать им воспользоваться (предварительно не забыть прилинковать к проекту lib файлы от библиотеки <code>assimp</code> и сделать доступным путь к собранный dll, если ассимп был собран как динамическая библиотека):</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">require assimp</span><br><span class="line">require strings</span><br><span class="line">require daslib/defer</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printNodesHierarchy</span><span class="params">(depth:int; var node:aiNode?&amp;)</span></span></span><br><span class="line"><span class="function">    <span class="title">unsafe</span></span></span><br><span class="line"><span class="function">        <span class="title">print</span><span class="params">(<span class="string">"&#123;repeat("</span>-<span class="string">",depth)&#125;&#123;assimp_str(addr(node.mName))&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function">        <span class="title">for</span> <span class="title">i</span> <span class="title">in</span> <span class="title">range</span><span class="params">(<span class="number">0</span>, int<span class="params">(node.mNumChildren)</span>)</span></span></span><br><span class="line"><span class="function">            <span class="title">printNodesHierarchy</span><span class="params">(depth+<span class="number">1</span>, node.mChildren[i])</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">[<span class="title">export</span>]</span></span><br><span class="line"><span class="function"><span class="title">def</span> <span class="title">main</span></span></span><br><span class="line"><span class="function">    <span class="title">unsafe</span></span></span><br><span class="line">        let path = "character.dae"</span><br><span class="line">        var scene = aiImportFile(path, <span class="number">8</span>u)</span><br><span class="line">        defer &lt;|</span><br><span class="line">            scene |&gt; aiReleaseImport</span><br><span class="line">        </span><br><span class="line">        var mesh = scene.mMeshes</span><br><span class="line">        print(<span class="string">"Meshes: &#123;int(scene.mNumMeshes)&#125;\n"</span>)</span><br><span class="line">        print(<span class="string">"Vertices:&#123;int(mesh[0].mNumVertices)&#125;\n"</span>)</span><br><span class="line">        print(<span class="string">"Faces:&#123;int(mesh[0].mNumFaces)&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line">        var rootNode = scene.mRootNode</span><br><span class="line">        print(<span class="string">"Node hierarchy:\n"</span>)</span><br><span class="line">        printNodesHierarchy(<span class="number">1</span>, rootNode)</span><br></pre></td></tr></table></figure><p>Данный код загружает модель из файла <code>character.dae</code>, и печатает иерархию костей скелета в этой модели:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Meshes: 1</span><br><span class="line">Vertices:14487</span><br><span class="line">Faces:4829</span><br><span class="line">Node hierarchy:</span><br><span class="line">-character.dae</span><br><span class="line">--root</span><br><span class="line">---M_spine_1_joint</span><br><span class="line">----M_spine_2_joint</span><br><span class="line">-----M_spine_3_joint</span><br><span class="line">------M_spine_4_joint</span><br><span class="line">------M_spine_5_joint</span><br><span class="line">-------L_shoulder_joint</span><br><span class="line">--------L_arm_1_joint</span><br><span class="line">---------L_arm_2_joint</span><br><span class="line">...</span><br><span class="line">-------R_leg_4_joint</span><br><span class="line">--------R_leg_5_joint</span><br><span class="line">------R_leg_2_twist_1_joint</span><br><span class="line">-------R_leg_2_twist_2_joint</span><br><span class="line">-----R_leg_1_twist_1_joint</span><br><span class="line">------R_leg_1_twist_2_joint</span><br><span class="line">--body_geo</span><br></pre></td></tr></table></figure></p><p><a href="https://github.com/spiiin/dasClangBind_modules/tree/main/dasAssimp" target="_blank" rel="noopener">Сырой код модуля</a>, когда-нибудь надо будет причесать</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;Продолжени
      
    
    </summary>
    
    
    
      <category term="3d" scheme="http://spiiin.github.io/tags/3d/"/>
    
      <category term="dascript" scheme="http://spiiin.github.io/tags/dascript/"/>
    
  </entry>
  
  <entry>
    <title>daScript: C++ auto-bindings, msgpack</title>
    <link href="http://spiiin.github.io/blog/4090909622/"/>
    <id>http://spiiin.github.io/blog/4090909622/</id>
    <published>2022-05-30T10:36:23.000Z</published>
    <updated>2022-08-01T13:03:26.852Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Ещё один “подход” к языку daScript от Gaijin. В последней заметке про использование <a href="/blog/4232971949/" title="байндингов к OpenGL">байндингов к OpenGL</a> в daScript, я упоминал про наличие скрипта <a href="https://github.com/GaijinEntertainment/daScript/issues/231" target="_blank" rel="noopener">dasClangBind</a>, позволяюшего генерировать байндинги к библиотекам на C и C++. Так как из документации к скрипту только совет автора <code>Use it, abuse it</code>, то неплохо попробовать его в деле, чтобы разобраться, что он умеет/не умеет.</p><p>С помощью этого генератора байндингов сделаны обёртки над: <a href="https://github.com/VasiliyRyabtsev/dasRequests" target="_blank" rel="noopener">dasRequests</a>, <a href="https://github.com/VasiliyRyabtsev/dasPhys2d" target="_blank" rel="noopener">dasPhys2d</a>, а также добавленные в основной репозиторий <strong><code>dasGLFW, dasBGFX, dasImgui, dasOpenGL, dasClangBind</code></strong> (привязки для генератора байндингов тоже сгенерированы им самим).</p><p><code>dasClangBind</code> не собирается с дефолтными настройками cmake, поэтому сначала необходимо включить его сборку. В файле <a href="https://github.com/GaijinEntertainment/daScript/blob/master/modules/dasClangBind/CMakeLists.txt" target="_blank" rel="noopener">CMakeLists.txt</a> видим настройку пути с <code>libclang</code>:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET(PATH_TO_LIBCLANG $&#123;PROJECT_SOURCE_DIR&#125;&#x2F;..&#x2F;libclang)</span><br></pre></td></tr></table></figure></p><p>Можно скачать скомпилированные библиотеки <a href="https://github.com/llvm/llvm-project/releases/tag/llvmorg-14.0.0" target="_blank" rel="noopener">LLVM</a> (yay, даже для windows!), и указать путь к скачанной библиотеке с cmake-файле. Дальше перегенерируем решение с помощью команды <code>generate_msvc_XXX.bat</code> и компилируем проект <code>libDasModuleClangBind</code>.</p><p>Получаем библиотеку <code>libDasModuleClangBind.lib</code>, которую можно подключить для статической линковки из проекта, который будет использовать этот модуль (командой <code>TARGET_LINK_LIBRARIES</code>). В сгенерированном решении убеждаемся в том, что линкер подключает библиотеки <code>libDasModuleClangBind.lib</code> и <code>libclang.lib</code>:<br><img src="/blog/4090909622/lib.png" alt="lib"></p><p>Далее в коде подключаем заголовочный файл и макрос добавления модуля в daScript:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../modules/dasClangBind/src/dasClangBind.h"</span></span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span>, <span class="keyword">char</span> * [] )</span> </span>&#123;</span><br><span class="line">    NEED_ALL_DEFAULT_MODULES;</span><br><span class="line">    NEED_MODULE(Module_dasClangBind); <span class="comment">//&lt;---</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Теперь в das-скрипте можно импортировать модуль <code>cbind</code>, который предоставляет функции-обёртки над библиотекой <code>clang</code>, а главное — <code>cbind_boost</code>, классы, с помощью которых можно настроить поведение генераторы, без низкоуровневого обращения к c-апи clang-а:<br><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">require</span> cbind</span><br><span class="line"><span class="keyword">require</span> cbind_boost</span><br></pre></td></tr></table></figure></p><h2 id="libclang"><a href="#libclang" class="headerlink" title="libclang"></a>libclang</h2><p>Для начала лучше бегло ознакомиться с тем, что умеет <code>libclang</code>:<br><a href="https://shaharmike.com/cpp/libclang/" target="_blank" rel="noopener">Using libclang to Parse C++</a><br><a href="https://habr.com/ru/post/439270/" target="_blank" rel="noopener">Пример разбора C++ кода с помощью libclang на Python</a><br><a href="https://clang.llvm.org/docs/Tooling.html" target="_blank" rel="noopener">Choosing the Right Interface for Your Application</a></p><h2 id="DasGenBind"><a href="#DasGenBind" class="headerlink" title="DasGenBind"></a>DasGenBind</h2><p>У генератор привязок <code>dasClangBind</code>, есть 2 режима: генерация обёрток над функциями в виде daScript (с помощью ffi-интерфейса <code>dasbind</code>) — <code>DasGenBind</code>, и более мощная генерация “обвязочного” c++-кода библиотеки — <code>CppGenBind</code>. С помощью <code>DasGenBind</code> <a href="https://github.com/GaijinEntertainment/daScript/blob/master/modules/dasClangBind/bind/bind_opengl.das" target="_blank" rel="noopener">сгенерированы</a> байндинги к <a href="https://github.com/GaijinEntertainment/daScript/blob/master/modules/dasOpenGL/opengl/opengl_func.das" target="_blank" rel="noopener">OpenGL</a>, так как сама библиотека language-agnostic, и её обвязки тривиальны — используются только функции и примитивные типы.</p><h2 id="CppGenBind"><a href="#CppGenBind" class="headerlink" title="CppGenBind"></a>CppGenBind</h2><p>Более интересно посмотреть на байндинги к <a href="https://github.com/GaijinEntertainment/daScript/blob/master/modules/dasClangBind/bind/bind_glfw.das" target="_blank" rel="noopener">glfw</a>, по которым можно приблизительно понять, что генерируется автоматически, а что необходимо добавлять в исключения и дописывать руками. <code>dasClangBind</code> в ходе своей работы пишет, какие объявляния функций он пропускает (<a href="https://github.com/GaijinEntertainment/daScript/blob/master/modules/dasClangBind/cbind/cbind_boost.das" target="_blank" rel="noopener">код</a> - поиск по ключевому слову <code>skip</code>):</p><ul><li>шаблоны</li><li>функции с аргументами-указателями на функции (к примеру, колбеки)</li><li>чисто виртуальные функции</li><li>глобальные операторы<br>Также генерируются, но вызывают последующие ошибки компиляции, функции (в лучших традициях текстов ошибок шаблонов C++), получающие аргументы POD-типов по значению.</li></ul><p>Для таких функций предполагается добавление их в список пропускаемых при автоматической генерации и последующее написания обработчика вручную:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//переопределение метода AnyGenBind</span></span><br><span class="line"> <span class="function">def <span class="keyword">override</span> <span class="title">skip_anyFunction</span> <span class="params">( var c : CXCursor; isMethod : <span class="keyword">bool</span> )</span></span></span><br><span class="line">        if AnyGenBind`skip_anyFunction(self, c, isMethod)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        <span class="comment">//свои проверки, нужно или нет генерировать обёртку для функции</span></span><br></pre></td></tr></table></figure></p><p>Для дописывания несгенерированных автоматически функций предусмотрен файл <code>MODULENAME.main.cpp</code>. На выходе генератор байндингов выдаёт <a href="https://github.com/borisbat/dasGlfw/tree/48f2715f0fe4cb8076866365a4bf0a29b7104765/src" target="_blank" rel="noopener">пачку</a> и кусок cmake-файла в stdout, с помощью которого можно собрать их в модуль. На практике почему-то у меня не создавались файлы <code>MODULE.func.reg.inc</code> и <code>MODULE.func.decl.,inc</code>, их для теста заполнил руками.</p><h2 id="CmakeList-txt"><a href="#CmakeList-txt" class="headerlink" title="CmakeList.txt"></a>CmakeList.txt</h2><p>В качестве шаблона cmake-файла можно взять готовый из других модулей, основная логика:</p><ul><li>собрать модуль из сгенерированных файлов (это за нас выводит сам <code>dasClangBind</code>)</li><li>подключить lib-файл самой C++ библиотеки, для которой делается обвязка</li><li>определить переменные сборки daScript, позволяющие отключить модуль по желанию пользователя</li></ul><h2 id="Генерация-байндингов-для-библиотеке-MessagePack"><a href="#Генерация-байндингов-для-библиотеке-MessagePack" class="headerlink" title="Генерация байндингов для библиотеке MessagePack"></a>Генерация байндингов для библиотеке MessagePack</h2><p>Исходя из ограничений генератора, для учебного примера проще всего выбрать для примера максимально простую библиотеку, имеющую C, а не С++-интерфейс. Например - <a href="https://github.com/msgpack/msgpack-c/tree/c_master" target="_blank" rel="noopener">MessagePack</a>.</p><p>Стартовый код генератора:</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">require cbind/cbind_boost</span><br><span class="line">require daslib/safe_addr</span><br><span class="line">require daslib/strings</span><br><span class="line">require daslib/defer</span><br><span class="line">require daslib/fio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MsgpackGen</span> :</span> CppGenBind</span><br><span class="line">    override func_to_stdout = false</span><br><span class="line">    unique_functions : table&lt;string; bool&gt;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">MsgpackGen</span></span></span><br><span class="line">        bind_root = "&#123;get_das_root()&#125;/modules/dasMsgpack/src"</span><br><span class="line">        bind_module = <span class="string">"msgpack"</span></span><br><span class="line">        bind_das_module = <span class="string">"msgpack"</span></span><br><span class="line">        let pfn = <span class="string">"msgpack.h"</span></span><br><span class="line">        let pfp = <span class="string">"&#123;get_das_root()&#125;/modules/dasMsgpack/msgpack-c/include/"</span></span><br><span class="line"></span><br><span class="line">        let args &lt;- [&#123;string</span><br><span class="line">            <span class="string">"-xc++-header"</span>;</span><br><span class="line">            <span class="string">"-std=c++1z"</span>;</span><br><span class="line">            <span class="string">"-I&#123;get_full_file_name(pfp)&#125;"</span></span><br><span class="line">        &#125;]</span><br><span class="line"></span><br><span class="line">        func_per_chunk = <span class="number">20</span></span><br><span class="line">        init_args(pfn,pfp,args)</span><br><span class="line">        setDefaultFiles()</span><br><span class="line">        //init_skip_func()</span><br><span class="line">        openAllFiles()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">override</span> <span class="title">namespace_name</span><span class="params">(name:string; dash:string=<span class="string">"::"</span>)</span> :</span> string</span><br><span class="line">        <span class="keyword">return</span> AnyGenBind`namespace_name(self, name, dash)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">override</span> <span class="title">skip_struct</span><span class="params">(name : string)</span></span></span><br><span class="line"><span class="function">        <span class="title">return</span> <span class="title">false</span></span></span><br><span class="line"><span class="function">        //<span class="title">return</span> <span class="title">AnyGenBind</span>`<span class="title">skip_struct</span><span class="params">(name)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">def</span> <span class="title">override</span> <span class="title">skip_anyFunction</span><span class="params">(var c : CXCursor; isMethod:bool)</span> :</span> bool</span><br><span class="line">        let funcname = string(clang_getCursorSpelling(c))</span><br><span class="line">        //не генерировать обвязку для повторно встречаемой функции (не совсем понимаю, почему встречаются повторы)</span><br><span class="line">        <span class="keyword">if</span> unique_functions |&gt; find(funcname) != null</span><br><span class="line">            <span class="keyword">return</span> true</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            unique_functions[funcname] = true</span><br><span class="line">            <span class="keyword">return</span> AnyGenBind`skip_anyFunction(self, c, isMethod)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //генерируем код для файлов, подходящих по шаблону msgpack/*.h</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">override</span> <span class="title">skip_file</span><span class="params">(fname:string)</span> :</span> bool</span><br><span class="line">        <span class="keyword">if</span> fname |&gt; find(<span class="string">"msgpack/"</span>) != <span class="number">-1</span></span><br><span class="line">            <span class="keyword">return</span> false</span><br><span class="line">        <span class="keyword">return</span> ! fname |&gt; ends_with(PARSE_FILE_NAME)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">override</span> <span class="title">generateModuleHPrefix</span></span></span><br><span class="line"><span class="function">        <span class="title">module_h_file</span> |&gt; <span class="title">fwrite</span><span class="params">(<span class="string">"#include \"need_msgpack.h\"\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">[<span class="title">export</span>]</span></span><br><span class="line"><span class="function"><span class="title">def</span> <span class="title">main</span></span></span><br><span class="line">    var cgb = new MsgpackGen()</span><br><span class="line">    defer &lt;|</span><br><span class="line">        unsafe</span><br><span class="line">            delete cgb</span><br><span class="line">    cgb-&gt;generate()</span><br><span class="line">    cgb-&gt;genCMakeDecl("DAS_MSGPACK_BIND")</span><br></pre></td></tr></table></figure><p>Такой скрипт генерирует привязки к библиотеке, однако при её компиляции возникают несколько ошибок вида:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">использование неопределенного типа &quot;das::cast&lt;TT&gt;&quot; libDasModuleMsgpack \daScript\include\daScript\simulate\simulate.h</span><br></pre></td></tr></table></figure></p><p>Необходимо добавить эти функции в список исключаемых из генерации:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;передача в качестве аргумента POD-объекта по значению</span><br><span class="line">msgpack_object_print</span><br><span class="line">msgpack_object_print_buffer</span><br><span class="line">msgpack_object_equal</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;какие-то непонятки с передачей некоторых из базовых типов из C++ в daScript?</span><br><span class="line">msgpack_pack_char</span><br><span class="line">msgpack_pack_long</span><br><span class="line">msgpack_pack_unsigned_long</span><br></pre></td></tr></table></figure></p><p>Убрав их из генерации, получаем компилирующийся модуль daScript <code>dasMsgpack</code>.</p><h2 id="Тестовый-скрипт"><a href="#Тестовый-скрипт" class="headerlink" title="Тестовый скрипт"></a>Тестовый скрипт</h2><p>Попытаемся портировать тестовый <a href="https://github.com/msgpack/msgpack-c/blob/c_master/example/simple_c.c" target="_blank" rel="noopener">пример</a> библиотеки с <code>MessagePack</code> с языка C на daScript:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">require msgpack</span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main</span><br><span class="line">    var sbuf : msgpack_sbuffer</span><br><span class="line">    var pk : msgpack_packer</span><br><span class="line">    var mempool: msgpack_zone</span><br><span class="line">    var deserialized: msgpack_object</span><br><span class="line"></span><br><span class="line">    unsafe</span><br><span class="line">        var ptrBuf = addr(sbuf)</span><br><span class="line">        var ptrPk = addr(pk)</span><br><span class="line">        var ptrMempool = addr(mempool)</span><br><span class="line">        var ptrDeserialized = addr(deserialized)</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* msgpack::sbuffer is a simple buffer implementation. */</span></span><br><span class="line">        msgpack_sbuffer_init(ptrBuf)</span><br><span class="line">        <span class="comment">/* serialize values into the buffer using msgpack_sbuffer_write callback function. */</span></span><br><span class="line">        msgpack_packer_init(ptrPk, ptrBuf)</span><br><span class="line"></span><br><span class="line">        msgpack_pack_array(ptrPk, <span class="number">4u</span>l)</span><br><span class="line">        msgpack_pack_int(ptrPk, <span class="number">1</span>)</span><br><span class="line">        msgpack_pack_true(ptrPk)</span><br><span class="line">        msgpack_pack_float(ptrPk, <span class="number">3.0</span>)</span><br><span class="line">        msgpack_pack_str(ptrPk, <span class="number">7u</span>l)</span><br><span class="line">        msgpack_pack_str_body(ptrPk, <span class="string">"example"</span>, <span class="number">7u</span>l);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//print("&#123;sbuf.data&#125;, &#123;sbuf.size&#125;")</span></span><br><span class="line"></span><br><span class="line">        msgpack_zone_init(ptrMempool, <span class="number">2048u</span>l)</span><br><span class="line"></span><br><span class="line">        var data = <span class="number">0u</span>l;</span><br><span class="line">        var ptrData = addr(data)</span><br><span class="line">        msgpack_unpack(sbuf.data, sbuf.<span class="built_in">size</span>, ptrData, ptrMempool, ptrDeserialized);</span><br><span class="line">        msgpack_object_print(ptrDeserialized);</span><br><span class="line"></span><br><span class="line">        msgpack_zone_destroy(ptrMempool);</span><br><span class="line">        msgpack_sbuffer_destroy(ptrBuf)</span><br></pre></td></tr></table></figure><p>Некоторые функции из примеры не попали в автоматическую обвязку, поэтому необходимо дописать обвязку для них вручную в файле <code>msgpack.main.cpp</code>:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//передаём 3-й параметр по умолчанию</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">das_msgpack_packer_init</span><span class="params">(msgpack_packer* pk, <span class="keyword">void</span>* data)</span> </span>&#123;</span><br><span class="line">msgpack_packer_init(pk, data, msgpack_sbuffer_write);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//передаём параметр по указателю, не по значению</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">das_msgpack_object_print</span><span class="params">(msgpack_object* o)</span> </span>&#123;</span><br><span class="line">msgpack_object_print(<span class="built_in">stdout</span>, *o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//меняем тип второго указателя на const char* вместо неизвестного генератору void *</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">das_msgpack_pack_str_body</span><span class="params">(msgpack_packer* pk, <span class="keyword">const</span> <span class="keyword">char</span>* b, <span class="keyword">size_t</span> l)</span> </span>&#123;</span><br><span class="line">msgpack_pack_str_body(pk, b, l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Module_msgpack::initMain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//добавляем функции в модуль</span></span><br><span class="line">addExtern&lt;DAS_BIND_FUN(das_msgpack_packer_init)&gt;(*<span class="keyword">this</span>,lib,<span class="string">"msgpack_packer_init"</span>,</span><br><span class="line">            SideEffects::worstDefault,<span class="string">"das_msgpack_packer_init"</span>);</span><br><span class="line">addExtern&lt;DAS_BIND_FUN(das_msgpack_object_print)&gt;(*<span class="keyword">this</span>, lib, <span class="string">"msgpack_object_print"</span>,</span><br><span class="line">SideEffects::worstDefault, <span class="string">"das_msgpack_object_print"</span>);</span><br><span class="line">addExtern&lt;DAS_BIND_FUN(das_msgpack_pack_str_body)&gt;(*<span class="keyword">this</span>, lib, <span class="string">"msgpack_pack_str_body"</span>,</span><br><span class="line">SideEffects::worstDefault, <span class="string">"das_msgpack_pack_str_body"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Теперь скрипт работает и выдаёт корректный результат десериализации объекта:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1, true, 3.000000, &quot;example&quot;]</span><br></pre></td></tr></table></figure></p><p>Дальнейшая работа над модулем может предполагать:</p><ul><li>возможность устанавливать daScript колбеки (<a href="https://github.com/borisbat/dasGlfw/blob/48f2715f0fe4cb8076866365a4bf0a29b7104765/src/cb_dasGLFW.h" target="_blank" rel="noopener">пример из dasGlfw</a>)</li><li>daScript-обвязка над POD-структурой msgpack_object и корректная передача исключенных типов(?)</li><li>написание “daScript-ивизирующей” обёртки msgpack_boost, для перехода от с-апи к более удобной работы с библиотекой</li></ul><p><a href="https://github.com/spiiin/dasClangBind_modules" target="_blank" rel="noopener">Репозиторий с примерами кода</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;Ещё один “
      
    
    </summary>
    
    
    
      <category term="dascript" scheme="http://spiiin.github.io/tags/dascript/"/>
    
  </entry>
  
  <entry>
    <title>Хорошие качества программистов</title>
    <link href="http://spiiin.github.io/blog/1257365288/"/>
    <id>http://spiiin.github.io/blog/1257365288/</id>
    <published>2022-05-23T12:00:48.000Z</published>
    <updated>2022-08-01T11:27:21.104Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Качества программистов, которые мне нравятся:</p><ul><li>умение держать в голове большое количество информации</li><li>понимание, как использовать язык программирования в своих целях</li><li>умение решать задачу минимальным количеством изменений в коде</li><li>умение искать причины трудновоспроизводимых багов</li><li>слежение за качеством кодовой базы</li><li>умение ставить эксперименты</li><li>любовь к “тинкерингу”</li><li>умение довести решение сложной задачи до конца</li></ul><a id="more"></a><h2 id="Умение-держать-в-голове-большое-количество-информации"><a href="#Умение-держать-в-голове-большое-количество-информации" class="headerlink" title="Умение держать в голове большое количество информации"></a>Умение держать в голове большое количество информации</h2><p><img src="/blog/1257365288/demoman.png" alt="demoman"><br>Часто в большом проекте приходится переключаться между разными контекстами (исправление багов в различных подсистемах на разных уровнях, участие в обсуждениях будущих фич, базовое слежение за тем, что вообще происходит во всём проекте). Также это умение связано с навыками пользоваться системами структурирования информации — за осознанием, как мало на самом деле можно удерживать информации в голове (по сравнению с потоком информации в проекте), следует желание найти и пользоваться удобной системой задач, организовывать и расшаривать информацию, оптимизировать потоки информации там, где ощущается бардак. То есть, вытащить контекст из головы, и создать “паутину” вспомогательной информации, в которой можно будет найти то, что забылось.</p><p>Также связано с умением распространять информацию — рассказывать о том, как пользоваться готовыми решениями, реагировать на то, как используют библиотеку, документировать код. Другой связанный навык — упрощение работы с большим количеством информации путём автоматизации каких-либо процессов (не нужно знать о том, что обязательно запустить скрипт, если он запускается по расписанию сам).</p><h2 id="Понимание-как-использовать-язык-программирования-в-своих-целях"><a href="#Понимание-как-использовать-язык-программирования-в-своих-целях" class="headerlink" title="Понимание, как использовать язык программирования в своих целях"></a>Понимание, как использовать язык программирования в своих целях</h2><p><img src="/blog/1257365288/soldier.png" alt="soldier"><br>Каждый язык программирования имеет свои плюсы и минусы. Часто о них не говорят, но принимают как должное вместе с языком (библиотекой, фреймворком, движком). Минусы языка могут быть не абсолютными, а проявляться только при использовании языка в определенной области — при решении определенного типа задач, для которых определенные свойства языка становятся критичными.</p><p>Например, требование к скорости выполнения программ при разработке игр. Вот <a href="https://aras-p.info/blog/2009/11/14/improving-cmono-for-games/" target="_blank" rel="noopener">рассуждения</a> о недостатках C# в качестве языка для описания игровой логики и способов борьбы с этими ограничениями — как обойти минусы языка и платформы, чтобы воспользоваться его преимуществами, что было сделано в <code>Unity</code>. Если оценивать язык и пользоваться им только “как принято” и “как пишут в книжках”, то можно просто пропустить то, что возможно сделать с его помощью.</p><p>Хорошее понимание особенностей предметной области позволяет формулировать цели, с которыми можно подходить к выбору языков. Часто целью самого языка или фреймворка является стать “дефолтным выбором” в определенной нише, для тех, кто не задумывается о своих целях. Это может стать опасным в случаях, когда от инструмента автоматически ожидают, что его использование приведёт к тому, что продукт автоматически будет обладать нужными свойствами. За тем, чтобы желаемое свойство не потерялось, нужно следить, никакой язык не будет делать это за вас. Возможность писать быстрый код обеспечивает не язык, а понимание, как писать быстрый код (возможно, отличающиеся для различных языков).</p><p>Чем осознанние цель, с которой выбираешь инструмент, тем проще его выбрать (или даже решиться допилить в своих нуждах), а также отбросить/исправить/запретить “мусорные” вещи, которые, мешают достижению поставленной цели, и не заниматься вещами, которые никак не относятся к поставленным целям.</p><p>Интересный ретроспективный <a href="https://youtu.be/KxQpDIKwGUw" target="_blank" rel="noopener">доклад</a> от <code>Wargaming</code> про выбор движка <code>BigWorld</code> для танков с рассуждениями о важности понимания целей выбора технологии (5-я минута, оценка качеств движка на рынке).</p><h2 id="Умение-решать-задачу-минимальным-количеством-изменений-в-коде"><a href="#Умение-решать-задачу-минимальным-количеством-изменений-в-коде" class="headerlink" title="Умение решать задачу минимальным количеством изменений в коде"></a>Умение решать задачу минимальным количеством изменений в коде</h2><p><img src="/blog/1257365288/spy.png" alt="spy"><br>Первый уровень данного качества — банальное понимание, что количество возможных багов пропорционально количеству измененных строк, больше шанс “зацепить” что-то не относящееся к решаемой задачи, сложнее процесс чтения кода. Во многих гайдах к написанию коду в существующие проекты одним из первых упоминается правило — “старайтесь писать код, используя тот стиль, который уже используется, даже если он противоречит другим правилам”.</p><p>Менее очевидна корреляция небольшого количества изменений с тем, насколько решение вписывается в общую архитектуру системы. Меньшее количество строк также связано с тем, что используется более высокий уровень абстракции, решение собрано из высокоуровневых примитивов, и не дублирует/переделывает существующий код.</p><p>Так что желание решать задачу теми средствами, которые уже есть, стимулирует искать и создавать такие инструменты, которые расширяются и комбинируются между собой. Это важнее на более высоких уровнях астракции — легко увидеть код, который дублирует функционал стандартной библиотеки или какую-нибудь мелкую функцию-хелпер, но сложнее заметить, что не нужно писать целый редактор с нуля там, где есть почти готовый, который можно допилить под себя.</p><h2 id="Умение-искать-причины-трудновоспроизводимых-багов"><a href="#Умение-искать-причины-трудновоспроизводимых-багов" class="headerlink" title="Умение искать причины трудновоспроизводимых багов"></a>Умение искать причины трудновоспроизводимых багов</h2><p><img src="/blog/1257365288/sniper.png" alt="sniper"><br>Под слоем логики современной игры лежит множество других, которые являются для неё чёрным ящиком — код движка, вызовы функций операционной системы, обращение с сервером, слой графического API, взаимодействие множества 3rdParty библиотек, код которых также может обновляться по сети через пакетные менеджеры, особенности компилятора и реализаций стандартной библиотеки, особенности железа. Связи в собственном коде отследить просто, но какое-нибудь хитрое взаимодействие API между собой, без возможности посмотреть, что под капотом у этого API (относительно простой <a href="https://aras-p.info/blog/2007/07/25/can-you-set-opengl-states-independently/" target="_blank" rel="noopener">пример</a> с opengl) — отдельное искусство, которое иногда основывающется на рассуждениях “как бы я реализовал это, будь я разработчиком библиотеки” или на информации о похожих ошибках, собранной по крупицам из разных мест (в хорошем случае — прямым вопросом авторам библиотеки, в плохом — “о, это уже ломалось у них 3 версии назад, снова сломали”).</p><p>Хорошо развитый навык поиска таких ошибок развивает умение писать самому максимально простой код, который с наименьшей вероятностью создаст ошибки, которые трудно обнаружить.<br><a href="/blog/1807815468/" title="Философия поиска ошибок">Философия поиска ошибок</a> — более развёрнутое описание этой связи.</p><p>Пример сложных в решении багов — исправление ANR для мобильных приложений, <a href="https://blog.embrace.io/solve-anrs-with-flame-graphs/" target="_blank" rel="noopener">заметка</a> о причинах сложностей, и описание альтернативного подхода к поиску.</p><h2 id="Слежение-за-качеством-кодовой-базы"><a href="#Слежение-за-качеством-кодовой-базы" class="headerlink" title="Слежение за качеством кодовой базы"></a>Слежение за качеством кодовой базы</h2><p><img src="/blog/1257365288/pyro.png" alt="pyro"><br><a href="https://cs8.pikabu.ru/images/big_size_comm_an/2016-04_4/146100495418031426.webm" target="_blank" rel="noopener">Пуш в мастер.gif</a><br>Качество, которое, кажется, практически невозможно привить, и сложно организовать через рабочие процессы и постановку задач. Либо человек проходит мимо “грязи” в кодовой базе спокойно, либо раздражается, до тех пор, пока не решит исправить. Ответственность за качество кода зависит а от желания работать в комфорте, а не от уровня отвественности или способностей программиста.<br><a href="/blog/1363625753/" title="Мотивация честного программиста">Мотивация честного программиста</a> — повышение качества кода связано с желанием работать в комфортных условиях.</p><h2 id="Умение-ставить-эксперименты"><a href="#Умение-ставить-эксперименты" class="headerlink" title="Умение ставить эксперименты"></a>Умение ставить эксперименты</h2><p><img src="/blog/1257365288/medic.png" alt="medic"><br>Сильно коррелирует с обязательно необходимыми для каждого программиста навыками — умением проверить, надёжно ли работает собственный код, выявить причину ошибки. Код, написанный для эксперимента, вполне может оставаться реюзабельным для регрессивных тестов, или упрощения проверки различных сценариев.</p><p>Особенно необходимо для реализации различных оптимизаций в коде — есть много теоретически работающих трюков, которые не работают на практике. Для отдельных замеров необходимо написание кода, который в несколько раз по объёму больше, чем сам проверяемый код, или написание отдельных программ, позволяющих изучить качества кода, не проверяемые стандартными средствами.<br><a href="/blog/854775037/" title="Расположение объектов C++ в памяти">Расположение объектов C++ в памяти</a> — способы увидеть расположение объектов C++ классов в памяти, с целью улучшения cache locality.</p><p>В более общем случае умение ставить эксперименты позволяет организовать проверки гипотез о продукте — элемент <a href="/blog/2486671624/" title="Lean Development">Lean Development</a>.</p><h2 id="Любовь-к-тинкерингу"><a href="#Любовь-к-тинкерингу" class="headerlink" title="Любовь к тинкерингу"></a>Любовь к тинкерингу</h2><p><img src="/blog/1257365288/engineer.png" alt="engineer"><br>“Тинкерить” — мастерить что-то, изучать, хакать, исследование без особой цели. Попробовать поиграться с новым движком, изучить новый алгоритм или библиотеку. Часто в таком случайном изобретении приобретается полезная экспертиза, на стыке дисциплин можно найти интересные и необычные идеи, нестандартные способы решения задач.</p><p><a href="/blog/2537188794/" title="Прототипирование в геймдеве">Прототипирование в геймдеве</a> — возможно, результат тинкеринга станет прототипом большого проекта. <a href="https://www.igromania.ru/article/31609/Istoriya_Minecraft_i_eyo_sozdatelya._Kto_i_kogda_sdelal_legendarnuyu_igru.html" target="_blank" rel="noopener">Майнкрафт</a> тоже начинался с тинкеринга с воксельной песочницей.</p><h2 id="Умение-довести-решение-сложной-задачи-до-конца"><a href="#Умение-довести-решение-сложной-задачи-до-конца" class="headerlink" title="Умение довести решение сложной задачи до конца"></a>Умение довести решение сложной задачи до конца</h2><p><img src="/blog/1257365288/scout.png" alt="scout"><br>Есть два типа программистов, которые не могут справиться с задачей — те, у которых код настолько плох, что его дольше исправлять, чем написать заново (чаще всего в попытках внести в него улучшения, ломают то, что уже “залатали” во время предыдущего этапа исправлений, исправления никогда не “сходятся” к нормальному решению) и те, которые вообще не понимают, что от них хотят. Никаких уточняющих вопросов или чернового варианта решения дождаться от них невозможно, а в перед дед-лайном наступает какая-нибудь катастрофа, которая уничтожает их решение, существующее только на их машине. Бывают ещё программисты, которые делают часть работы, но не заканчивают её по каким-либо причинам, не хватает фантазии, инициативы, желания связать созданные части в одно целое. В этом случае чаще всего их код не собирается и требует для проверки внесения в него изменений проверяющим.</p><p>В хороших случаях человек способен сам разобраться с тем, чтобы задать уточняющие вопросы и найти того, кто может помочь с решением. В особо хороших случаях — при невозможности  найти полноценное решение, может придумать и реализовать частичное, с пометками, что в нём можно улучшить. В самых хороших — проявить дальнейшую инициативу по поиску ресурсов для полноценного решения.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Качества программистов, которые мне нравятся:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;умение держать в голове большое количество информации&lt;/li&gt;
&lt;li&gt;понимание, как использовать язык программирования в своих целях&lt;/li&gt;
&lt;li&gt;умение решать задачу минимальным количеством изменений в коде&lt;/li&gt;
&lt;li&gt;умение искать причины трудновоспроизводимых багов&lt;/li&gt;
&lt;li&gt;слежение за качеством кодовой базы&lt;/li&gt;
&lt;li&gt;умение ставить эксперименты&lt;/li&gt;
&lt;li&gt;любовь к “тинкерингу”&lt;/li&gt;
&lt;li&gt;умение довести решение сложной задачи до конца&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="dev_evolution" scheme="http://spiiin.github.io/tags/dev-evolution/"/>
    
  </entry>
  
</feed>
