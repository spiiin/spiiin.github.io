<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Spiiin&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://spiiin.github.io/"/>
  <updated>2023-04-08T14:51:46.887Z</updated>
  <id>http://spiiin.github.io/</id>
  
  <author>
    <name>spiiin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>AI prompts</title>
    <link href="http://spiiin.github.io/blog/1596814086/"/>
    <id>http://spiiin.github.io/blog/1596814086/</id>
    <published>2023-04-08T13:02:32.000Z</published>
    <updated>2023-04-08T14:51:46.887Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Потестил немного, что умеют нейронки.</p><p><a href="https://github.com/f/awesome-chatgpt-prompts" target="_blank" rel="noopener">Awesome ChatGPT Prompts</a> - примеры запросов к <code>ChatGPT</code><br><a href="https://trello.com/b/4BPkSY1w/100-ai-prompts-resources-prompt-lovers" target="_blank" rel="noopener">100+ AI Prompts &amp; Resources</a> - еще один список чит-кодов</p><p>Можно попросить ChatGPT сгенерировать развёрнутое описание личности по простому описанию, которое которое можно применить к другому диалогу с ней же. <code>&quot;Act as English translator&quot;</code> — для корректирования своих же запросов на английском, <code>&quot;Act as photographer&quot;</code> — для более красивого описания сцены для генератора изображений. Можно попросить действовать в стиле “Акинатора” — задавать наводящие вопросы по тому, как должна выглядеть описываемая сцена.</p><p>Трюки для <code>Midjourney</code>:<br><a href="https://www.youtube.com/watch?v=NBT7hJEZw4k" target="_blank" rel="noopener">The Ultimate MidJourney Prompting Guide</a> — гайд по фичам midjourney<br><a href="https://medium.com/mlearning-ai/an-advanced-guide-to-writing-prompts-for-midjourney-text-to-image-aa12a1e33b6" target="_blank" rel="noopener">An advanced guide to writing prompts for Midjourney</a> - список стилей<br><a href="https://docs.midjourney.com/docs/explore-prompting" target="_blank" rel="noopener">Explore Prompting</a> — дока, тоже список стилей<br><a href="https://www.youtube.com/watch?v=Asg1e_IYzR8" target="_blank" rel="noopener">GPT-4 + Midjourney V5 = A New Era of Photography?</a> — chat-gpt4 для генерации запросов (act as photograph)<br><a href="https://www.youtube.com/watch?v=N90yjO0bm_w" target="_blank" rel="noopener">Midjourney AI Tutorial | Get AMAZING Midjourney Prompts</a> — генератор в виде опросника (free trial)<br><a href="https://www.youtube.com/watch?v=_7eH8ugjQtg" target="_blank" rel="noopener">I Found the Ultimate CHEAT CODE in Midjourney!</a> — чит с подготовкой фона, на котором будет нарисован следующий промт</p><p>Трюки — детальное описание сцены, подсказки по стилю, “улучшающие” слова вроде hires, best quality, попытки сохранения стиля с повторением сида, дорисовки по исходной картинке, смешивание картинок.</p><p>Одна из фич — позволяет получить несколько детальных описаний из загруженной картинки, чтобы поэкспериментировать с перегенерацией картинки по этому описанию.</p><p>Midjourney рисует лучше Dall-E и StableDiffussion, но платный. Лучше знает названия мест, животных и растений. Для примера сгенерил запросы по местам в Крыму, знает форму дворца Ласточкино Гнездо:<br><img src="/blog/1596814086/gnezdo_small.png" alt=""></p><p><code>StableDiffusion</code> — бесплатный, рисует хуже, обучен на открытых базах, существуют различные модели, заточенные под различные стили или задачи, а также множество инструментов под различные задачи. Можно поставить локально (нужна видеокарта с 6-8 гб памяти). Можно использовать как библиотеку, либо поставить webgui:<br><a href="https://github.com/artmamedov/artroom-stable-diffusion/releases" target="_blank" rel="noopener">Artroom</a><br><a href="https://github.com/AUTOMATIC1111/stable-diffusion-webui" target="_blank" rel="noopener">Stable Diffustion web UI</a><br><a href="https://huggingface.co/models?other=stable-diffusion" target="_blank" rel="noopener">Модели</a></p><p>Примеры работы:<br><a href="https://www.youtube.com/watch?v=PUFlt4JVlvI" target="_blank" rel="noopener">Гравировка за 10 минут в Stable Diffusion для любой 3D МОДЕЛИ</a> - генерация по маске<br><a href="https://www.youtube.com/watch?v=Ffl8b_GfJ-M" target="_blank" rel="noopener">Stable Diffusion Consistent Character Animation Technique - Tutorial</a> - дорисовка по маске позы<br><a href="https://huggingface.co/blog/controlnet" target="_blank" rel="noopener">Ultra fast ControlNet with Diffusers</a> - генерация по драфту, определение позы, <a href="https://huggingface.co/docs/diffusers/main/en/api/pipelines/stable_diffusion/controlnet" target="_blank" rel="noopener">ещё пример</a><br><a href="https://www.youtube.com/watch?v=FLaics4IT-w" target="_blank" rel="noopener">Interactive Map Generation using Stable Diffusion</a> - итеративная дорисовка (если использовать как библиотеку, а не webui, можно было бы вызывать повторения одной функцией)</p><p>Попробовал скормить midjourney скриншот из Botw-ы с узором на дереве, сгенерировал похожие текстуры:<br><img src="/blog/1596814086/wood1_small.png" alt=""></p><p>Так как и Midjourney и Stable Diffusion позволяют сгенерировать тайлящиеся текстуры, то можно пойти дальше и попросить CharGPT написать скрипт, разрезающий результат на части, и отобразить результат сшитой текстуры:<br><img src="/blog/1596814086/gpt1_small.png" alt=""></p><p><img src="/blog/1596814086/wood2_tiled.png" alt=""></p><p>(вместо общения через чат проще использовать <a href="https://github.com/openai/openai-python" target="_blank" rel="noopener">openai</a>)</p><p>Из полученной текстуры можно с помощью ещё одной модели нейронки <a href="https://github.com/HugoTini/DeepBump" target="_blank" rel="noopener">DeepBump</a> получить карту нормалей и высот. <code>DeepBump</code> можно использовать как плагин для Blender или из командной строки:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cli.py color.jpg normals.jpg color_to_normals</span><br><span class="line">cli.py normals.png height.png normals_to_height</span><br></pre></td></tr></table></figure><p>Чтобы посмотреть результат, можно снова попросить ChatGpt написать программу для отображения результата (проще всего выбрать <a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a>):</p><p><em>“Provide code to show plane with diffuse texture and normal map”</em> +<br><em>“provide minimal html page to show this example”</em> +<br><em>“how to run server in python to show this html page?”</em> +<br><em>“change example to rotate not a plane, but light source”</em> +<br><em>“change rotating light from timer to rotating by user with mouse”</em> =<br>Код примера, и напутствие:<br>And that’s it! With this code, you can display a plane with a diffuse texture and normal map. Keep in mind that this is just a simple example and there are many ways to improve and extend it.</p><p><img src="/blog/1596814086/ans2_small.png" alt=""><br><img src="/blog/1596814086/ans1_small.png" alt=""></p><p>Код нагенерированных примеров, 0 строк ручного кода (кроме тыкания параметров материала для бампа — roughness/metalness)<br><a href="https://github.com/spiiin/openai_threejs_bump" target="_blank" rel="noopener">https://github.com/spiiin/openai_threejs_bump</a></p><p>Местами уже может сильно упростить жизнь — собрать несколько простых примеров вместе, напрототипить, выполнить рутинную задачу (иногда с захватом корнер кейсов), получить саммари знаний по теме. С риском галлюцинаций и обмана, но быстрее, чем делать руками.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;Потестил н
      
    
    </summary>
    
    
    
      <category term="ai" scheme="http://spiiin.github.io/tags/ai/"/>
    
  </entry>
  
  <entry>
    <title>C++ Metaprogramming - ссылки</title>
    <link href="http://spiiin.github.io/blog/4174799834/"/>
    <id>http://spiiin.github.io/blog/4174799834/</id>
    <published>2023-03-19T00:30:26.000Z</published>
    <updated>2023-03-19T20:26:15.820Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Список книг и ресурсов по метапрограммированию в C++. Грубая карта небольшой части огромной территории.</p><p>Желание разобраться с очередным трюком с шаблонами в C++ приходит после обнаружения какой-либо библиотеки или кода, который непонятно как работает, но вроде что-то ловко делает. И заканчивается мыслью “это ж ебануться можно, так писать”.</p><a id="more"></a><p>Такие мысли приходят в голову всем практикующим и работающим в командах программистам. Пара примеров лютых исходников — <a href="https://github.com/lewissbaker/cppcoro" target="_blank" rel="noopener">cppcoro</a>, <a href="https://github.com/ericniebler/range-v3" target="_blank" rel="noopener">range-v3</a> (<a href="https://aras-p.info/blog/2018/12/28/Modern-C-Lamentations/" target="_blank" rel="noopener">“Modern” C++ Lamenations</a>).<br><img src="/blog/4174799834/spiderman.jpg" alt=""></p><p><a href="/blog/2297379949/" title="Заметки о языках программирования">Заметки о языках программирования</a> — про использование различных языков для решения задач различных уровней, а также подходы к борьбе с возрастающей сложностью при масштабируемости.<br><a href="/blog/1728194429/" title="С++ в геймдеве">С++ в геймдеве</a> — “высокоуровневый” С++ - часть задач решаемых метапрограммированием.</p><h2 id="Общий-обзор-возможностей-шаблонов-и-списки-примеров-использования"><a href="#Общий-обзор-возможностей-шаблонов-и-списки-примеров-использования" class="headerlink" title="Общий обзор возможностей шаблонов и списки примеров использования:"></a>Общий обзор возможностей шаблонов и списки примеров использования:</h2><p><strong><code>Vandervoorde D. Josuttis N. Gregor D. - C++ Templates: The Complete Guide</code></strong> - полный обзор возможностей языка, второе издание — по C++17<br><strong><code>Александреску А. - Современное проектирование на C++</code></strong> - pre-C++11, но классические идеи<br><strong><code>Di Genaro D. - Advanced Metaprogramming in Classic C++</code></strong> - много небольших примеров<br><a href="https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms" target="_blank" rel="noopener">More C++ idioms</a> - еще больше примеров, не только с шаблонами<br><a href="https://www.boost.org/" target="_blank" rel="noopener">Boost</a> - лучший учебник</p><h2 id="Generic-типы"><a href="#Generic-типы" class="headerlink" title="Generic-типы"></a>Generic-типы</h2><p>Часто первое столкновение с шаблонами — обобщенные контейнеры, итераторы и умные указатели из <code>stl</code><br>Более продвинутые примеры — стратегии Александреску, задание отношений между типами, CRTP, template template параметры</p><p><a href="https://github.com/skypjack/entt/blob/master/src/entt/container/dense_set.hpp" target="_blank" rel="noopener">EnTT dense set</a> - пример кода контейнера и итератора не из stl<br><a href="https://github.com/tamasmeszaros/libnest2d/blob/master/include/libnest2d/libnest2d.hpp" target="_blank" rel="noopener">libnest2d</a> - небольшая библиотека для паковки многоугольников, использующая стратегии для выбора вариантов оптимизации, паковки и математического бекэнда</p><h2 id="Задание-ограничений-и-свойств-для-типов"><a href="#Задание-ограничений-и-свойств-для-типов" class="headerlink" title="Задание ограничений и свойств для типов"></a>Задание ограничений и свойств для типов</h2><p>Контракты, распознавание свойств типов (<code>std::is_XXX</code>), частичная специализация</p><p><strong><code>Stepanov A. - Elements of programming</code></strong> - математическое описание типов и структур, контракты<br><a href="https://sean-parent.stlab.cc/papers-and-presentations/" target="_blank" rel="noopener">Lecture and presentation Sean Parent</a> - и другие лекции Шона Парента, про value-oriented programming</p><p><a href="https://github.com/GaijinEntertainment/daScript/pull/472/files#diff-2a42eb62b92995bc578cc927dc871b66a1a00f003c819a108abd291e23b33bb1R150" target="_blank" rel="noopener">Пример из daScript</a> — частичная специализация с захватом новых шаблонных параметров<br><a href="https://stackoverflow.com/questions/4189945/templated-class-specialization-where-template-argument-is-a-template" target="_blank" rel="noopener">Templated class specialization where template argument is a template</a> - описание возможных подходов к созданию связи между шаблонными параметрами</p><h2 id="Работа-с-типами-как-с-данными"><a href="#Работа-с-типами-как-с-данными" class="headerlink" title="Работа с типами как с данными"></a>Работа с типами как с данными</h2><p>Типы не являются объектами первого класса, поэтому работы с ними, поэтому все действия выполняются во время компиляции. Один из ключевых приёмов — выбор того, или иного типа в зависимости от статически известного условия. При этом не определяется новый тип, а создаётся псевдоним для существуюшего, “слот”, в который можно сохранить любой тип (<code>typedef</code>). Типы используются не для создания экземпляров, а для вообще чего угодно, от управляющих конструкций и отправки сигналов в рантайм, до операций группировки других типов.</p><p><strong><code>Abrahams D. Gurtovoy A. - C++ Template Metaprogramming</code></strong> - одна из наиболее замороченных книг, pre-C++11. Частично описывает <a href="https://www.boost.org/doc/libs/1_43_0/libs/mpl/doc/index.html" target="_blank" rel="noopener">Boost.MPL</a><br><a href="https://www.boost.org/doc/libs/master/libs/mp11/doc/html/mp11.html" target="_blank" rel="noopener">Boost.Mp11</a> - C++11-версия библиотеки для манипуляции с типами, несколько статей сравнения новых подходов со старыми</p><h2 id="Domain-Specific-Language"><a href="#Domain-Specific-Language" class="headerlink" title="Domain Specific Language"></a>Domain Specific Language</h2><p>Следующая идея — пойти еще дальше: построить на специальных типах свой язык, с управляющими конструкциями. Примеры задач — парсинг команд и создание деревьев выражений для последующего вычисления в рантайме.</p><p><a href="https://www.youtube.com/watch?v=r_ZASJFQGQI" target="_blank" rel="noopener">Hana Dusíková — A state of сompile time regular expressions</a> — регулярные выражения в compile-time (<a href="https://github.com/hanickadot/compile-time-regular-expressions" target="_blank" rel="noopener">compile-time.re</a>)<br><a href="https://www.youtube.com/watch?v=PJwd4JLYJJY" target="_blank" rel="noopener">Ben Deane &amp; Jason Turner “constexpr ALL the Things!”</a> — парсинг json в compile-time</p><p><a href="/blog/1552834708/" title="Runtime-полиморфизм в C++">Runtime-полиморфизм в C++</a> - пост со ссылками на серию видео про построение в compile-time кастомных версий динамического полиморфизма. <a href="https://github.com/ldionne/dyno" target="_blank" rel="noopener">dyno</a> - библиотека Louis Dionne, автора Boost.Hana</p><h2 id="Выполнение-кода-в-compile-time"><a href="#Выполнение-кода-в-compile-time" class="headerlink" title="Выполнение кода в compile-time"></a>Выполнение кода в compile-time</h2><p>Изначально возможность выполнения кода во время компиляции в С++ была артефактом шаблонов (первая “программа” - вывод простых чисел в сообщении об ошибке). Со временем добавляются более серьёзные возможности, однако код времени компиляции серьёзно ограничен и отличается от среды выполнения.</p><p>Примеры задач в compile-time:</p><ul><li>заранее предпосчитать значение выражение, все части которого известны на момент компиляции</li><li>построить таблицу значений чистой функции, которая долго вычисляется</li></ul><p>Основная возможность в pre-C++11 - SFINAE и рекурсивные+терминальные пары функций, и дополнительно const-expr/if/eval в более поздних стандартах.</p><p><a href="https://www.youtube.com/watch?v=NNU6cbG96M4" target="_blank" rel="noopener">Don’t constexpr All the Things - David Sankel CppNow 2021</a> - обзор ограничений подъязыка времени выполнения<br><a href="https://www.circle-lang.org/" target="_blank" rel="noopener">Circle</a> - wip компилятор C++ Шона Бакстера, с возможностью выполнение кода на этапе компиляции без ограничений<br><a href="https://probablydance.com/2015/02/16/ideas-for-a-programming-language-part-3-no-shadow-worlds/" target="_blank" rel="noopener">Ideas for a Programming Language Part 3: No Shadow Worlds</a> - похожие рассуждения на тему того, что не полностью интегрированные в основной язык подмножества создают “теневые миры”, в которых приходится переизобреть заново возможности основного языка</p><p><em>В Circle меня настораживает, что код, кажется, должен компилироваться дважды, особенно с учетом того, что скорее всего выполнение кода в compile-time будет медленнее, чем в рантайм. Для nim выполнение кода в compile-time — раз в 10 медленее</em></p><h2 id="Доступ-к-данным-о-типах-в-рантайм"><a href="#Доступ-к-данным-о-типах-в-рантайм" class="headerlink" title="Доступ к данным о типах в рантайм"></a>Доступ к данным о типах в рантайм</h2><p>Отсутствует в C, и не zero-cost абстракция, так что в стандарте языка отсутствует механизм неявной передачи информации о типах в рантайм (можно откопать <a href="https://youtu.be/NWIsRFDaHhs?t=847" target="_blank" rel="noopener">пачку</a> предложений для будущих улучшений).</p><p>Поэтому задачи типа <code>рефлексии/инстроспекции</code> решаются либо явной декларацией полей и методов класса (как при создании врапперов для других языков), либо предварительным внешним парсингом кода — либо кастомной метаинформации, которую пропускает компилятор C++ (в комментариях), либо полноценным разбором кода (<code>clang</code>), с последующей генерацией по этой информации кода.</p><p>Аналогично, без явной интроспекции и вещи вроде <code>сериализации</code> или описания RPC не могут быть неявными — необходимо явно аннотировать типы. </p><p><code>Кодогенерация</code> выражений на C++ в рантайме также отсутствует в стандарте, и заменяется генерации во время компиляции — текста, либо бинарного кода (или промежуточного кода, вроде IR для LLVM).</p><p><a href="/blog/315556844/" title="LLVM - обзор">LLVM - обзор</a> — обзор тулзов из набора LLVM, для парсинга и генерации кода, в настоящий момент state-of-art для генерации кода на C++<br><a href="https://www.youtube.com/watch?v=aPTyatTI42k" target="_blank" rel="noopener">Automatic C++ source code generation with clang - Sergei Sadovnikov ACCU 2017</a> - доклад с обзором подходов, и способа генерации с помощью clang<br><a href="https://www.youtube.com/watch?v=NWIsRFDaHhs" target="_blank" rel="noopener">Reflection in C++ Next - Anton Bikineev - Meeting C++ 2017</a> - обзор пропозалов в стандарт, связанных с рефлексией<br><a href="https://www.boost.org/doc/libs/1_79_0/libs/serialization/doc/tutorial.html" target="_blank" rel="noopener">Boost.Serialization</a> - сериализация в Boost</p><h2 id="Функциональное-программирование"><a href="#Функциональное-программирование" class="headerlink" title="Функциональное программирование"></a>Функциональное программирование</h2><p>Обширная тема. Элементы функционального стиля программирования — <code>комбинирование функций</code> (функции высшего порядка, частичное применение, отложенные вычисления) и их <code>чистота</code>. Часть перечисленных выше методов метапрограммирования направлена на борьбу со возрастающей при масштабировании программ сложностью путем создания новых абстракций. Функциональное программирование также работает с абстракциями, но выбирает их со стороны математики, ради того, чтобы использовать свойства уже изученных объектов (с поправкой на то, что в языках программирования реализуются приближения к математическим объектам).</p><p><strong><code>Чукич И. - Функциональное программирование на языке С++</code></strong> — книга о том, как использовать элементы функционального программирования на C++, ссылки на библиотеки буста, реализующие концепции<br><a href="https://github.com/hmemcpy/milewski-ctfp-pdf/" target="_blank" rel="noopener">Milewski B. - Category Theory For Programmers</a> - серия статей (собранная в книгу), по теории категорий для программистов, с примерами на C++ и хаскелл. <a href="https://www.youtube.com/watch?v=I8LbkfSSR58&amp;list=PLbgaMIhjbmEnaH_LTkxLI7FMa2HsnawM_" target="_blank" rel="noopener">Видеолекции</a> на ту же тему<br><a href="https://www.gamedeveloper.com/programming/in-depth-functional-programming-in-c-" target="_blank" rel="noopener">In-depth: Functional programming in C++</a> - статья Кармака про бонусы, которые можно получить, если использовать функциональный подход, в частности, бонусы от чистоты функций</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Список книг и ресурсов по метапрограммированию в C++. Грубая карта небольшой части огромной территории.&lt;/p&gt;
&lt;p&gt;Желание разобраться с очередным трюком с шаблонами в C++ приходит после обнаружения какой-либо библиотеки или кода, который непонятно как работает, но вроде что-то ловко делает. И заканчивается мыслью “это ж ебануться можно, так писать”.&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="книги" scheme="http://spiiin.github.io/tags/%D0%BA%D0%BD%D0%B8%D0%B3%D0%B8/"/>
    
      <category term="link" scheme="http://spiiin.github.io/tags/link/"/>
    
      <category term="cpp" scheme="http://spiiin.github.io/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>daScript - контексты</title>
    <link href="http://spiiin.github.io/blog/3298324261/"/>
    <id>http://spiiin.github.io/blog/3298324261/</id>
    <published>2023-03-08T11:57:37.000Z</published>
    <updated>2023-04-06T23:11:55.267Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>В заметке про <a href="/blog/3006126295/" title="live-режим">live-режим</a> для opengl-приложений в daScript я кратко описывал контексты (раздел <code>Архитектура приложения</code>). Здесь разберу их немного более подробно.</p><a id="more"></a><h2 id="Контекст"><a href="#Контекст" class="headerlink" title="Контекст"></a>Контекст</h2><p>Программы daScript выполняются в <a href="https://github.com/GaijinEntertainment/daScript/blob/master/include/daScript/simulate/simulate.h#L252" target="_blank" rel="noopener">контексте</a>, структуре, которая хранит окружение программы — выделенную память, в которой хранятся код и данные программы, загруженные модули, настройки виртуальной машины.</p><p><a href="https://github.com/GaijinEntertainment/daScript/blob/master/examples/tutorial/tutorial06.cpp" target="_blank" rel="noopener">tutorual06</a> показывает работу с контекстом в daScript:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//загружаем das-файл и компилируем его</span></span><br><span class="line"><span class="keyword">auto</span> program = compileDaScript(<span class="string">"dummy.das"</span>, fAccess, tout, dummyLibGroup);</span><br><span class="line"><span class="comment">//создаём контекст, в котором будет выполняться программа</span></span><br><span class="line">ContextPtr ctx = make_shared&lt;Context&gt;(program-&gt;getContextStackSize());</span><br><span class="line"><span class="comment">//симулируем выполнение программу (строит дерево симуляции для выполнения в виртуальной машине)</span></span><br><span class="line">program-&gt;simulate(*ctx, tout);</span><br><span class="line"><span class="comment">//находим в контексте скомпилированную функцию</span></span><br><span class="line">SimFunction *fni = ctx-&gt;findFunction(<span class="string">"test"</span>);</span><br><span class="line"><span class="comment">//тут могут быть опциональные стадии проверки сигнатуры функции</span></span><br><span class="line">verifyCall&lt;<span class="keyword">float</span>&gt;(fni-&gt;debugInfo, dummyLibGroup);</span><br><span class="line"><span class="comment">//выполняем функцию в контексте, тип результата -- 128-бит</span></span><br><span class="line">vec4f res = ctx-&gt;evalWithCatch(fni, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="comment">//приводим результат к C++-типу</span></span><br><span class="line"><span class="keyword">float</span> result = cast&lt;<span class="keyword">float</span>&gt;::to(res);</span><br></pre></td></tr></table></figure><p>(<a href="/blog/2115627465/" title="Устройство интерпретаторов lua-jit и daScript">Устройство интерпретаторов lua-jit и daScript</a> — немного более детально про симуляцию программы)</p><p>Создание и удаление контекстов в daScript дешёво, один из паттернов организации C++-приложения, использующего daScript — выделение нового контекста, выполнение в нём работы и уничтожение.</p><p>Контекст можно воспринимать как экземпляр выполняющейся программы. Программа на С++ может иметь несколько контекстов, каждый из которых может выполнять программу на daScript (как скомпилированную из различных das-файлов, так и из одного и того же).</p><h2 id="Создание-контекста-из-daScript"><a href="#Создание-контекста-из-daScript" class="headerlink" title="Создание контекста из daScript"></a>Создание контекста из daScript</h2><p>API для создания контекстов также доступно в самом daScript, так что скрипт сам может создавать новые контексты и выполнять в них программы.</p><p>Пример <a href="https://github.com/GaijinEntertainment/daScript/blob/master/examples/test/misc/eval_in_context.das" target="_blank" rel="noopener">eval_in_context</a>:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//создание текста программы</span></span><br><span class="line">let text = build_string &lt;| $(st)</span><br><span class="line">    st |&gt; write(<span class="string">"[export]\n"</span>)</span><br><span class="line">    st |&gt; write(<span class="string">"def eval(var res:int?)\n"</span>)</span><br><span class="line">    st |&gt; write(<span class="string">"\tunsafe\n"</span>)</span><br><span class="line">    st |&gt; write(<span class="string">"\t\t*res = 42\n"</span>)</span><br><span class="line">    st |&gt; write(<span class="string">"\n"</span>)</span><br><span class="line"><span class="comment">//def eval(var res:int?)</span></span><br><span class="line"><span class="comment">//  unsafe</span></span><br><span class="line"><span class="comment">//      *res = 42</span></span><br><span class="line"></span><br><span class="line">access |&gt; set_file_source(<span class="string">"__dummy_file_name"</span>, text)</span><br><span class="line">  <span class="keyword">using</span> &lt;| $(var mg:ModuleGroup)</span><br><span class="line">    <span class="keyword">using</span> &lt;| $(var cop:CodeOfPolicies)</span><br><span class="line">      <span class="comment">//компилируем строку с текстом программы</span></span><br><span class="line">      compile_file(<span class="string">"__dummy_file_name"</span>,access,unsafe(addr(mg)), cop) &lt;| $(ok,program,errors)</span><br><span class="line">        <span class="comment">//строим дерево симуляции</span></span><br><span class="line">        simulate(program) &lt;| $ (sok; context; serrors )</span><br><span class="line">          unsafe</span><br><span class="line">            var res:<span class="keyword">int</span></span><br><span class="line">            <span class="comment">//выполняем функцию eval в контексте скомпилированной программы</span></span><br><span class="line">            context |&gt; invoke_in_context(<span class="string">"eval"</span>, addr(res))</span><br><span class="line">            print(<span class="string">"&#123;res&#125;\n"</span>)</span><br></pre></td></tr></table></figure><p>В примере выше в скомплированные программу передаётся адрес из другого контекста. Это небезопасно, так как один контекст ничего не знает про время жизни переменных другом, поэтому операция отмечена как <code>unsafe</code>.</p><h2 id="Форк-контекста"><a href="#Форк-контекста" class="headerlink" title="Форк контекста"></a>Форк контекста</h2><p>Кроме возможности иметь раздельные контексты, daScript позволяет склонировать существующий контекст — <a href="https://github.com/GaijinEntertainment/daScript/blob/cd448fdbd4c6aa81897d2a8543943af112e2cbeb/src/simulate/simulate.cpp#L1659" target="_blank" rel="noopener">fork_debug_agent_context</a>. Функция создаёт клон контекста, и выставляет флаг контекста <code>persistent</code>, а затем в этом клонированном контексте выполняет функцию инициализации, переданную аргументом. Обычно в этой функции регистрируется новый <code>DebugAgent</code> — обёртка над контекстом, которая позволяет найти указатель на склонированный контекст по имени (и опционально, изменить поведение с помощью хуков). Склонированный контекст имеет доступ к тому же окружению, что и основной (модули, функции, копии переменных).</p><p><strong>Склонированный контекст не копирует состояние из основного!</strong></p><p>Пример <a href="https://github.com/GaijinEntertainment/daScript/blob/726d440be7618fb431815b18e6f785c37a335d5d/examples/test/misc/agent_fork_sample.das" target="_blank" rel="noopener">agent_fork_sample.das</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">require debugapi</span><br><span class="line"></span><br><span class="line">var test_value = <span class="string">"default"</span></span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>] def debug_context_set()</span><br><span class="line">    print(<span class="string">"&#123;this_context().name&#125;:&#123;test_value&#125;\n"</span>)</span><br><span class="line">    test_value = <span class="string">"debug_context"</span> <span class="comment">//изменить значение переменной в контексте debug_context</span></span><br><span class="line">    print(<span class="string">"&#123;this_context().name&#125;:&#123;test_value&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main</span><br><span class="line">    this_context().name := <span class="string">"my_context"</span></span><br><span class="line">    fork_debug_agent_context &lt;| @@(var new_context : Context)</span><br><span class="line">        <span class="comment">//вызывается в новом контексте, устанавливаем DebugAgent, который сохранит ссылку на новый контекст</span></span><br><span class="line">        install_new_debug_agent(<span class="keyword">new</span> DapiDebugAgent(), <span class="string">"debug_context"</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"&#123;this_context().name&#125;:&#123;test_value&#125;\n"</span>)</span><br><span class="line">    <span class="comment">//меняем значение глобальной переменной</span></span><br><span class="line">    test_value = <span class="string">"my_context"</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"&#123;this_context().name&#125;:&#123;test_value&#125;\n"</span>)</span><br><span class="line">    <span class="comment">//ждём создания контекста агента</span></span><br><span class="line">    <span class="keyword">while</span> !has_debug_agent_context(<span class="string">"debug_context"</span>)</span><br><span class="line">        pass</span><br><span class="line">    unsafe</span><br><span class="line">        <span class="comment">//изменяем значение переменной в контексте debug_context</span></span><br><span class="line">        get_debug_agent_context(<span class="string">"debug_context"</span>) |&gt; invoke_in_context(<span class="string">"debug_context_set"</span>)</span><br><span class="line">    </span><br><span class="line">    print(<span class="string">"&#123;this_context().name&#125;:&#123;test_value&#125;\n"</span>)</span><br></pre></td></tr></table></figure><p>Выведет:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">my_context:default                            &#x2F;&#x2F; в основном контексте test_value имеет значение по умолчанию</span><br><span class="line">my_context:my_context                         &#x2F;&#x2F; изменили значение в основном контексте</span><br><span class="line">debug agent debug_context:default             &#x2F;&#x2F; &lt;--в склонированном контексте test_value имеет значение по умолчанию</span><br><span class="line">debug agent debug_context:debug_context       &#x2F;&#x2F; изменили значение в склонированном контексте</span><br><span class="line">my_context:my_context                         &#x2F;&#x2F; в основном контексте значение test_value не изменилось</span><br></pre></td></tr></table></figure></p><p>Аннотация для функций <a href="https://github.com/GaijinEntertainment/daScript/blob/726d440be7618fb431815b18e6f785c37a335d5d/examples/test/misc/apply_in_context_example.das" target="_blank" rel="noopener">apply_in_context</a> позволяет вызывать функцию в другом контексте прозрачно для вызывающего кода. Пример выше можно переписать так:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">require daslib/apply_in_context</span><br><span class="line"></span><br><span class="line">[apply_in_context(debug_context)]</span><br><span class="line"><span class="function">def <span class="title">debug_context_set</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;this_context().name&#125;:&#123;test_value&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function">    test_value </span>= <span class="string">"debug_context"</span> <span class="comment">//изменить значение переменной в контексте debug_context</span></span><br><span class="line">    print(<span class="string">"&#123;this_context().name&#125;:&#123;test_value&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line">...<span class="comment">//тот же код создания агента</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> !has_debug_agent_context(<span class="string">"debug_context"</span>)</span><br><span class="line">    pass</span><br><span class="line">debug_context_set() <span class="comment">//функция будет вызвана в контексте debug_context</span></span><br></pre></td></tr></table></figure><p>Пример создания отдельного контекста — модуль <a href="https://github.com/GaijinEntertainment/daScript/blob/master/daslib/live.das#L189" target="_blank" rel="noopener">live</a>, пример клонирования — <a href="https://github.com/GaijinEntertainment/daScript/blob/5649b32e8b779ceb90b7eabd73f58b7d2077cff6/modules/dasOpenGL/opengl/opengl_cache.das#L56" target="_blank" rel="noopener">opengl_cache</a>.</p><h2 id="Переопределение-поведения-debug-агентов"><a href="#Переопределение-поведения-debug-агентов" class="headerlink" title="Переопределение поведения debug-агентов"></a>Переопределение поведения debug-агентов</h2><p>Можно вызвать функции, определённые в классе-наследнике debug-агента (<a href="https://github.com/GaijinEntertainment/daScript/blob/37b86881a8f4890913e2f80537708575c3441a3f/examples/test/misc/invoke_debug_agent_function.das" target="_blank" rel="noopener">invoke_debug_agent_function</a>), но намного более интересной возможностью является переопределения методов. Виртуальная машина daScript отслеживает наличие зарегистрированных отладочных агентов и передаёт им информацию в ходе выполнения программы — интерфейс <a href="https://github.com/GaijinEntertainment/daScript/blob/62f8b1b2ff4c873c9fc1b7ada61ed332fb349e4c/src/builtin/debugger.das#L10" target="_blank" rel="noopener">DapiDebugAgent</a>.</p><p>Простые примеры определения кастомных debug-агентов:<br><a href="https://github.com/GaijinEntertainment/daScript/blob/685f0415fc1cb2d52ae6c875f702eb7c09862e38/examples/test/misc/logger_and_logger_agent.das" target="_blank" rel="noopener">logger_agent</a> — добавление кастомного префикса при логгировании<br><a href="https://github.com/GaijinEntertainment/daScript/blob/eaa99142af33e7499137c4c7351d02075223cd5b/examples/test/misc/insturment_function.das" target="_blank" rel="noopener">insturment_function</a> — профилирование вызовов функций.<br><a href="https://github.com/GaijinEntertainment/daScript/blob/726d440be7618fb431815b18e6f785c37a335d5d/examples/test/misc/instrument.das" target="_blank" rel="noopener">instrument</a> — программный брейкпоинт и пошаговая трассировка</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">options debugger = <span class="literal">true</span>    <span class="comment">//настройка контекста для работы с хуками debug-агентов</span></span><br><span class="line">require debugapi           <span class="comment">//интерфейсы для кастомных debug-агентов</span></span><br><span class="line">require rtti               <span class="comment">//получение информации о контексте выполнения (доступные модули/функции/переменные/etc)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//программный брейкпоинт, вызывает хук onBreakpoint в debug-агенте</span></span><br><span class="line">breakpoint</span><br><span class="line"><span class="comment">//устанавливает номер строчки, для которой будет вызван хук onInstrument</span></span><br><span class="line">instrument_node </span><br><span class="line"><span class="comment">//устанавливает режим трассирования, хук onSingleStep будет вызван для каждой строчки выполнения до отключения</span></span><br><span class="line">set_single_step</span><br><span class="line"><span class="comment">//устанавливает фильтр на функции, для которых будет вызван хук onInstrumentFunction </span></span><br><span class="line">instrument_all_functions</span><br><span class="line"><span class="comment">//вызывает хук onLog</span></span><br><span class="line">to_log</span><br><span class="line"><span class="comment">//вызывает хук onCollect</span></span><br><span class="line">collect_debug_agent_state</span><br><span class="line"><span class="comment">//вызывает хук onVariable у установленного DapiStackWalker</span></span><br><span class="line">report_context_state</span><br></pre></td></tr></table></figure><p>Более сложные примеры:<br><a href="https://github.com/GaijinEntertainment/daScript/blob/726d440be7618fb431815b18e6f785c37a335d5d/examples/test/misc/stackwalk.das" target="_blank" rel="noopener">stackwalk</a> — более продвинутая версия <code>instrument</code>, устанавливает кастомный <code>DapiStackWalker</code> и <code>DapiDataWalker</code>, печатает значение локальных переменных на каждом шаге<br><a href="https://github.com/GaijinEntertainment/daScript/blob/66e627465d8aca7934c4b6a92f2fc0d16347c9f7/examples/test/misc/context_state_example.das" target="_blank" rel="noopener">context_state_example</a> — еще немного более полная версия информации о переменных, уже более похожая на информацию для отладчика<br><a href="https://github.com/GaijinEntertainment/daScript/blob/767ebf69143244c544dacdc2efed5a7410940ed5/modules/dasOpenGL/opengl/opengl_state.das" target="_blank" rel="noopener">opengl_state</a> — в хуке onCollect печатает информацию о состояниях OpenGL<br><a href="https://github.com/GaijinEntertainment/daScript/blob/62f8b1b2ff4c873c9fc1b7ada61ed332fb349e4c/daslib/decs_state.das" target="_blank" rel="noopener">decs_state</a> — собирает информацию из модуля <code>decs</code> (entity-component-system)<br><a href="https://github.com/GaijinEntertainment/daScript/blob/62f8b1b2ff4c873c9fc1b7ada61ed332fb349e4c/daslib/ast_debug.das" target="_blank" rel="noopener">ast_debug</a> — информация о состоянии expression tree, для отладки макросов</p><h2 id="Инструмнты-основе-debug-агентов"><a href="#Инструмнты-основе-debug-агентов" class="headerlink" title="Инструмнты  основе debug-агентов"></a>Инструмнты  основе debug-агентов</h2><p>Полноценный <strong><code>отладчик</code></strong> — <a href="https://github.com/GaijinEntertainment/daScript/blob/2695f756b17bc184016ea97973ef143a669a937e/daslib/debug.das" target="_blank" rel="noopener">debug</a> (debug-агент + сервер для связи с IDE) (<a href="https://marketplace.visualstudio.com/items?itemName=profelis.dascript-plugin" target="_blank" rel="noopener">плагин для vscode</a>):<br>(необходимо определить <code>#define DAS_DEBUGGER 1</code> если это по каким-то причинам не определилось в das_config.h автоматически)<br><img src="/blog/3298324261/debugger.png" alt=""></p><p>Более продвинутый <a href="https://borisbat.github.io/dascf-blog/2022/12/11/instruments/" target="_blank" rel="noopener">пример</a> <strong><code>instrument_function</code></strong> — обёртка, сохраняющая результат в файл, который можно посмотреть в виде флеймграфа.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;В заметке про &lt;a href=&quot;/blog/3006126295/&quot; title=&quot;live-режим&quot;&gt;live-режим&lt;/a&gt; для opengl-приложений в daScript я кратко описывал контексты (раздел &lt;code&gt;Архитектура приложения&lt;/code&gt;). Здесь разберу их немного более подробно.&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="dascript" scheme="http://spiiin.github.io/tags/dascript/"/>
    
  </entry>
  
  <entry>
    <title>daScript - мелочи</title>
    <link href="http://spiiin.github.io/blog/1728452067/"/>
    <id>http://spiiin.github.io/blog/1728452067/</id>
    <published>2023-03-05T18:25:54.000Z</published>
    <updated>2023-03-11T12:22:51.682Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Научился читать грамматику для bison, нашёл несколько новых для себя мелочей синтаксиса <a href="https://github.com/GaijinEntertainment/daScript/blob/master/src/parser/ds_parser.ypp" target="_blank" rel="noopener">daScript</a>.<br><a id="more"></a></p><p><strong><code>1. assume</code></strong><br>Аналог <code>#define</code> в си, текстовая подстановка выражений. Со всеми ее минусами.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var a = <span class="string">"global_string"</span></span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main</span><br><span class="line">    assume x = a <span class="comment">//not capture global var a, but only text name</span></span><br><span class="line">    var a = <span class="string">"local string"</span></span><br><span class="line">    x = <span class="string">"changed string"</span> <span class="comment">//change local, but not global a!</span></span><br><span class="line">    print(<span class="string">"&#123;a&#125;\n"</span>)</span><br><span class="line">    print(<span class="string">"&#123;::a&#125;\n"</span>)</span><br><span class="line"><span class="comment">//changed string</span></span><br><span class="line"><span class="comment">//global_string</span></span><br></pre></td></tr></table></figure><p><strong><code>2. =&gt;</code></strong></p><p>Символ стрелки используется для записи коротких блоков/лямбд/безымянных функций:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">radd</span><span class="params">(var ext:<span class="keyword">int</span>&amp;; b:block&lt;(var arg:<span class="keyword">int</span>&amp;):<span class="keyword">int</span>&gt;)</span>:<span class="keyword">int</span></span></span><br><span class="line"><span class="function">    <span class="keyword">return</span> <span class="title">invoke</span><span class="params">(b,ext)</span></span></span><br><span class="line"><span class="function">def <span class="title">radd</span><span class="params">(var ext:<span class="keyword">int</span>&amp;; b:lambda&lt;(var arg:<span class="keyword">int</span>&amp;):<span class="keyword">int</span>&gt;)</span>:<span class="keyword">int</span></span></span><br><span class="line"><span class="function">    <span class="keyword">return</span> <span class="title">invoke</span><span class="params">(b,ext)</span></span></span><br><span class="line"><span class="function">def <span class="title">radd</span><span class="params">(var ext:<span class="keyword">int</span>&amp;; b:function&lt;(var arg:<span class="keyword">int</span>&amp;):<span class="keyword">int</span>&gt;)</span>:<span class="keyword">int</span></span></span><br><span class="line"><span class="function">    <span class="keyword">return</span> <span class="title">invoke</span><span class="params">(b,ext)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">[export]</span><br><span class="line">def main</span><br><span class="line">    var x = <span class="number">0</span></span><br><span class="line">    radd(x, $(a) =&gt; a++) </span><br><span class="line">    radd(x, @(a) =&gt; a++)</span><br><span class="line">    radd(x, @@(a) =&gt; a++) </span><br><span class="line">    print(<span class="string">"&#123;x&#125;\n"</span>)</span><br><span class="line">    <span class="comment">//Output: 3</span></span><br></pre></td></tr></table></figure><p>А также для записи создания кортежей и таблиц:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var x &lt;- [[<span class="keyword">auto</span> <span class="number">1</span>=&gt;<span class="string">"one"</span>]] <span class="comment">//работает также в массивах [[auto 1=&gt;"one"; 2=&gt;"two"]]</span></span><br><span class="line">print(<span class="string">"&#123;x&#125; &#123;typeinfo(typename x)&#125;\n"</span>)</span><br><span class="line"><span class="comment">//[[ 1; one]] tuple&lt;int;string&gt; - кортеж</span></span><br><span class="line">var y &lt;- &#123;&#123; <span class="number">1</span>=&gt;<span class="string">"one"</span>&#125;&#125;</span><br><span class="line">print(<span class="string">"&#123;y&#125; &#123;typeinfo(typename y)&#125;\n"</span>)</span><br><span class="line"><span class="comment">//[[ 1 : one]] table&lt;int;string&gt; - таблица</span></span><br></pre></td></tr></table></figure><p><strong><code>3. auto для инициализации</code></strong></p><p>auto при инициализации может выводить тип массивов (статических и динамических) и кортежей. Для структур — не может</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">printType</span><span class="params">(a)</span> </span>&#123; print(<span class="string">"&#123;typeinfo(typename a)&#125;\n"</span>); &#125;</span><br><span class="line">printType([[<span class="keyword">auto</span> <span class="number">1</span>=&gt;<span class="number">2</span>]]) <span class="comment">//tuple&lt;int;int&gt; const</span></span><br><span class="line">printType([[<span class="keyword">auto</span> <span class="number">1</span>,<span class="number">2</span>]])  <span class="comment">//tuple&lt;int;int&gt; const</span></span><br><span class="line">printType([[<span class="keyword">auto</span> <span class="number">1</span>;<span class="number">2</span>]])  <span class="comment">//int const[2]</span></span><br><span class="line">printType([&#123;<span class="keyword">auto</span> <span class="number">1</span>;<span class="number">2</span>&#125;])  <span class="comment">//array&lt;int&gt; const</span></span><br></pre></td></tr></table></figure><p><strong><code>4. сокращенная запись при обьявлении переменных ссылочных типов</code></strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">let a = <span class="number">1</span></span><br><span class="line">let ar&amp; = a <span class="comment">//let ar: int&amp; = a</span></span><br></pre></td></tr></table></figure></p><p><strong><code>5. if после выражений</code></strong><br>Условие может стоять после определённых выражений (с опциональной веткой else):</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">def fun</span><br><span class="line">    print(<span class="string">"1"</span>) <span class="function"><span class="keyword">if</span> <span class="literal">true</span> <span class="keyword">else</span> <span class="title">print</span><span class="params">(<span class="string">"2"</span>)</span>  <span class="comment">//expr if</span></span></span><br><span class="line"><span class="function">    <span class="keyword">while</span> <span class="literal">true</span></span></span><br><span class="line"><span class="function">        <span class="keyword">break</span> <span class="keyword">if</span> <span class="literal">true</span> <span class="keyword">else</span> <span class="keyword">continue</span> <span class="comment">//break if</span></span></span><br><span class="line"><span class="function">        <span class="keyword">continue</span> <span class="keyword">if</span> <span class="literal">false</span> <span class="comment">//continue if</span></span></span><br><span class="line">    return &lt;- generator&lt;int&gt;() &lt;| $() </span><br><span class="line">        <span class="function"><span class="keyword">for</span> t in <span class="title">range</span><span class="params">(<span class="number">0</span>,<span class="number">10</span>)</span></span></span><br><span class="line"><span class="function">            yield t <span class="keyword">if</span> <span class="literal">true</span> <span class="comment">//yield if</span></span></span><br><span class="line"><span class="function">        <span class="keyword">return</span> <span class="literal">false</span> <span class="keyword">if</span> <span class="literal">true</span> <span class="comment">//return if</span></span></span><br></pre></td></tr></table></figure><p><strong><code>6. aka</code></strong><br>Синоним для имени переменной (как намного менее “злобный” вариант <code>assume</code>)<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var a aka b: <span class="keyword">int</span></span><br><span class="line">b = <span class="number">1</span></span><br><span class="line">print(<span class="string">"&#123;a&#125;\n"</span>) <span class="comment">//1</span></span><br></pre></td></tr></table></figure></p><p><strong><code>7. expect</code></strong></p><p>Ключевое слово для тестового фреймворка <a href="https://borisbat.github.io/dascf-blog/2023/02/25/wake-up-and-test-the-damn-thing/" target="_blank" rel="noopener">dasTest</a><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">expect <span class="number">10003</span>:<span class="number">1</span>, <span class="number">20000</span>:<span class="number">1</span></span><br><span class="line"><span class="comment">//ожидается по одной ошибке компилятора типа 10003 и 20000 (незакрытая кавычка и неожиданный конец файла)</span></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def test</span><br><span class="line">    print(<span class="string">"ok</span></span><br></pre></td></tr></table></figure><br>Для запуска теста нужно вызвать скрипт <a href="https://github.com/GaijinEntertainment/daScript/tree/master/dastest" target="_blank" rel="noopener">dastest</a> и передает в параметре <code>test</code> имя скрипт для тестирования (или директории с группой скриптов):<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">daScript dastest.das -- --test my_test.das</span><br></pre></td></tr></table></figure></p><p><strong><code>8. named arguments</code></strong></p><p>Функцию можно вызвать с <a href="https://dascript.org/doc/reference/language/functions.html?highlight=named#named-arguments-function-call" target="_blank" rel="noopener">явными именами</a> аргументов.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">foo</span><span class="params">(a:<span class="keyword">int</span>=<span class="number">13</span>; b: <span class="keyword">int</span>)</span></span></span><br><span class="line">    return a + b</span><br><span class="line">foo([b = <span class="number">2</span>])  <span class="comment">// same as foo(13, 2)</span></span><br></pre></td></tr></table></figure><p>Также можно скомбинировать первые неименованные аргументы, или вызов через пайп:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">func</span><span class="params">(a:<span class="keyword">int</span>; b=<span class="number">1</span>; c=<span class="number">2</span>)</span></span></span><br><span class="line"><span class="function">  pass</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span><span class="params">([a=<span class="number">0</span>, c=<span class="number">2</span>]    <span class="comment">//ok</span></span></span></span><br><span class="line"><span class="function"><span class="params">func(<span class="number">0</span>, [c=<span class="number">2</span>])   <span class="comment">//error</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="number">0</span> |&gt; func([c=<span class="number">2</span>]) <span class="comment">//error</span></span></span></span><br></pre></td></tr></table></figure><p><a href="https://github.com/GaijinEntertainment/daScript/blob/master/tests/language/named_call.das" target="_blank" rel="noopener">Больше примеров</a>. Логика выбора — именованные аргументы применяются после неименованных и могут “перекрывать” их.</p><p><strong><code>9. with</code></strong></p><p><a href="https://dascript.org/doc/reference/language/classes.html?highlight=class#implementation-details" target="_blank" rel="noopener">with</a> позволяет внутри блока обращаться к полям структуры без явного указания её имени:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span></span></span><br><span class="line"><span class="class">    <span class="title">a</span>, <span class="title">b</span>:</span> <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">var s = [[S a=<span class="number">1</span>, b=<span class="number">2</span>]]</span><br><span class="line">with s</span><br><span class="line">    print(<span class="string">"&#123;a&#125;, &#123;b&#125;\n"</span>) <span class="comment">//s.a, s.b</span></span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Научился читать грамматику для bison, нашёл несколько новых для себя мелочей синтаксиса &lt;a href=&quot;https://github.com/GaijinEntertainment/daScript/blob/master/src/parser/ds_parser.ypp&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;daScript&lt;/a&gt;.&lt;br&gt;
    
    </summary>
    
    
    
      <category term="dascript" scheme="http://spiiin.github.io/tags/dascript/"/>
    
  </entry>
  
  <entry>
    <title>Книги и курсы</title>
    <link href="http://spiiin.github.io/blog/1567638407/"/>
    <id>http://spiiin.github.io/blog/1567638407/</id>
    <published>2023-02-25T14:07:24.000Z</published>
    <updated>2023-03-04T18:25:31.727Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>В январе, перед переходом на новую работу, успел немного почитать. Ориентировался на список из старого <a href="https://dtf.ru/gamedev/470-gaijin-interview" target="_blank" rel="noopener">интервью</a> А. Юдинцева</p><p><strong><code>Пенроуз Р. &quot;Новый ум короля&quot;</code></strong><br>Взгляд физика и математика Пенроуза из 1989 на искусственный интеллект. Пролистал бегло часть про математику, физику почти пропустил. Основная идея начала — сознание неалгоритмично, и часто неформализуемо. Плюс гипотеза о том, что раз мы еще не нашли объяснения сознания там, где искали, оно может быть спрятано там, где еще искали плохо.<br>Кажется, в книге не рассматривается, а скорее и отрицается эмерджентность, свойство возникновения нового уровня организации из более примитивных элементов. Хотя Пенроуз подходит к этому феномену в описании существования кристаллов с непериодической решеткой, математически описанных им самим (<a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%BE%D0%B7%D0%B0%D0%B8%D0%BA%D0%B0_%D0%9F%D0%B5%D0%BD%D1%80%D0%BE%D1%83%D0%B7%D0%B0" target="_blank" rel="noopener">мозаика Пенроуза</a>), для построения которых необходимо “знать” о том, как будет организована далеко отстоящая часть структуры.</p><p>Наверное, интересно для любителей истории развития идей про искусственный интеллект. Когда-то также бегло просматривал книги Минского <code>&quot;Вычисления: конечные и бесконечные машины&quot;</code> и <code>&quot;Общество разума&quot;</code>, но не особо связаны с тем, чем я занимаюсь, поэтому не вникал в них детально.</p><p>Одна из глав посвящена также фракталам, но про них лучше почитать отдельно у Мандельброта в <code>&quot;Фракталы и хаос&quot;</code> (тоже просматривал бегло), до этой книги почему-то считал их скорее математической диковинкой, чем структурой для описания объектов природы.</p><p>Собственно, разобрал только <a href="https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D0%BE%D1%80%D0%B5%D0%BC%D0%B0_%D0%93%D1%83%D0%B4%D1%81%D1%82%D0%B5%D0%B9%D0%BD%D0%B0" target="_blank" rel="noopener">теорему Гудстейна</a>, так как она связана с теоремой Гёделя о неполноте, которую очень часто любят упоминать по поводу и без. Разбор теоремы:<br>ЖЖ avva:<br><a href="https://avva.livejournal.com/244874.html" target="_blank" rel="noopener">Геркулес и гидра</a><br><a href="https://avva.livejournal.com/245918.html" target="_blank" rel="noopener">Геркулес и гидра (решение)</a><br><a href="https://avva.livejournal.com/248899.html" target="_blank" rel="noopener">Геркулес и гидра (что такое ординалы)</a><br>Канал маткульт-привет:<br><a href="https://www.youtube.com/watch?v=IS_PazHA2_0" target="_blank" rel="noopener">Теорема Гудстейна. Введение</a><br><a href="https://www.youtube.com/watch?v=0WLmiejT9vM" target="_blank" rel="noopener">Теорема Гудстейна. Формулировка</a><br><a href="https://www.youtube.com/watch?v=0SoydsEr0OA" target="_blank" rel="noopener">Теорема Гудстейна. Введение в ординалы</a><br><a href="https://www.youtube.com/watch?v=dEx5xlB9PTc" target="_blank" rel="noopener">Теорема Гудстейна. Доказательство и заключение</a></p><p>Интересно скорее для математиков, на любительский взгляд выглядит просто как определение набора правил, как именно можно оперировать неизвестными заранее, но конечными числами</p><p><strong><code>Прайор К. &quot;Не рычите на собаку&quot;</code></strong><br>Книга о практических методах дрессировки животных и людей, не делающая значительных отличий между ними. Собственно, все методы практичны, из серии “бери и делай”.</p><p>Когда-то увлекался популярными книгами про языки животных — <a href="/blog/14110/" title="Джон Лилли. Человек и Дельфин.">Джон Лилли. Человек и Дельфин.</a>. Недавно читал также про язык муравьев в <code>&quot;Планете муравьев&quot;</code> и <code>&quot;Superorganism&quot;</code> Уилсона.<br><a href="https://galicarnax.livejournal.com/39260.html" target="_blank" rel="noopener">Биосемиотика: молекулярные коды как основа жизни</a> — наука о том, что жизнь основана на знаках и кодах, а эволюция связана с возникновением новых систем кодирования. Наверное, если бы не занимался геймдевом, занимался б биоинформатикой.</p><p><strong><code>Даймонд Дж. &quot;Ружья, микробы и сталь&quot;</code></strong><br><a href="https://kobak.livejournal.com/73007.html" target="_blank" rel="noopener">Краткий конспект</a> содержания книги. Автор связывает развитие цивилизаций с экологическими условиями, в которых они оказывались. Сложнопроверяемо, но много интересных фактов. Похожие книги, про политические системы — <code>&quot;Почему одни страны богатые, а другие бедные&quot;</code> и <code>&quot;Русская модель управления&quot;</code> (хотя тут больше притягиваний фактов).</p><p><strong><code>Чалдини Р. &quot;Психология влияния&quot;</code></strong><br>Как и Доккинза, читал раньше. Считаю методы из Чалдини, Ариели, Канемана и Талера необходимыми и обязательными во фреймворке гейм-дизайнера (особенно для free-to-play) — <a href="/blog/3649678047/" title="Путь гейм-дизайнера">Путь гейм-дизайнера</a></p><p><strong><code>Курс лекций: &quot;Наукоёмкий подход к кулинарии&quot;</code></strong> [<a href="https://www.youtube.com/playlist?list=PLXOrZPAO2Ui021R3sKD5z0n9Qzeix9Kbj" target="_blank" rel="noopener">ссылка</a>]<br>Колоссальное количество фактов о кулинарии и способах приготовления еды. Лекции не о том, как правильно готовить, а о том, что можно в принципе делать с едой. Хорошо идёт в дополнении с книгой <code>Вкус</code> Боба Холмса.</p><p><strong><code>Системное программирование. Лаборатория Tarantool</code></strong> [<a href="https://www.youtube.com/playlist?list=PLrCZzMib1e9pOdLmE2qtMgL3QMEIrxyu7" target="_blank" rel="noopener">ссылка</a>]<br>Введение в Linux, вместе с книгой Таненбаума <code>&quot;Современные операционные системы&quot;</code> позволяет понять ос настолько, чтобы разбираться в более продвинутых материалах.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;В январе, 
      
    
    </summary>
    
    
    
      <category term="книги" scheme="http://spiiin.github.io/tags/%D0%BA%D0%BD%D0%B8%D0%B3%D0%B8/"/>
    
      <category term="link" scheme="http://spiiin.github.io/tags/link/"/>
    
  </entry>
  
  <entry>
    <title>Немного о проектировании</title>
    <link href="http://spiiin.github.io/blog/1337028819/"/>
    <id>http://spiiin.github.io/blog/1337028819/</id>
    <published>2023-02-19T11:40:56.000Z</published>
    <updated>2023-04-04T20:59:17.300Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Дамп мыслей про проектирование систем, как обычно, с уклоном в геймдев.<br><a id="more"></a></p><h2 id="Cohesion-and-Coupling"><a href="#Cohesion-and-Coupling" class="headerlink" title="Cohesion and Coupling"></a>Cohesion and Coupling</h2><p><a href="https://en.wikipedia.org/wiki/Cohesion_(computer_science%29" target="_blank" rel="noopener">Cohesion</a> — степень смысловой связи между сгруппированными элементами (функциями в классе или модуле).<br><a href="https://en.wikipedia.org/wiki/Coupling_(computer_programming%29" target="_blank" rel="noopener">Coupling</a> — степень запутанности связи между модулями.</p><p><img src="/blog/1337028819/coupling_small.png" alt=""><br>Хороший вариант дизайна — высокая cohesion и низкая coupling.</p><p>Примеры модулей, в которых скорее всего окажется <code>низкий cohesion</code>:</p><ul><li>Utils - сгруппировано все небольшие функции</li><li>GameObject - в котором при ООП дизайне рано или поздно собирается весь функционал, который может потребоваться потомкам (анти-паттерны GodObject/Blob)</li></ul><p>Примеры модулей, которые скорее всего могут быть связаны с другими (<code>высокий coupling</code>) - системы логгирования, профилирования.<br>Подсистемы также связываются на уровне реализации игровой логики — звук шагов задействует подсистемы анимации, звука, физики. Сильно лучше, если подсистемы связаны не между собой, а на отдельном слое связывания.</p><h2 id="Компоненты"><a href="#Компоненты" class="headerlink" title="Компоненты"></a>Компоненты</h2><p>Для подсистем с высокой cohesion и низкой coupling встречается название <strong><code>компоненты</code></strong>, за счет того, что они изолированы друг от друга и могут переиспользоваться.<br>Один из приемов проектирования — строить программу из компонентов.</p><p>Между слоем компонентов и логики приложения могут лежать и промежуточные слои библиотек:</p><p><img src="/blog/1337028819/components_levels_small.png" alt=""><br><em>(картинка из книги John Lacos - Large-Scale C++ )</em></p><p>Однако при этом часто на среднем уровне библиотека не оформлена в виде компонентов или даже компоненты на спроектированы так, чтобы использоваться вне библиотеки очень высокого уровня.</p><p>Примеры библиотек:<br>В которых сложно “оторвать компоненты” для использования вне библиотеки (в плане coupling, иногда заниматься отрыванием может мешать и лицензия библиотеки): <code>Qt</code><br>Средний уровень сложности: <code>boost</code> (зависит от конкретной библиотеки, некоторые отрываются неплохо, некоторые тянут за собой в зависимостях половину библиотеки), <code>entt</code> (для примера — оторвать basic_sparse_set/basic_storage можно, но требует усилий)<br>Легко отделить компоненты: <a href="https://github.com/tamasmeszaros/libnest2d" target="_blank" rel="noopener">libnest2d</a> - надстроена над <code>clipper/nlopt/boost.geometry</code>, вполне позволяет подменить любую из этих библиотек</p><h2 id="Software-Capital"><a href="#Software-Capital" class="headerlink" title="Software Capital"></a>Software Capital</h2><p><a href="https://youtu.be/ta3S8CRN2TM?t=572" target="_blank" rel="noopener">CppCon 2016: David Sankel “Building Software Capital: How to write the highest quality code and why”</a> — software capital как противоположность техническому долгу.</p><p>Необходимые условия для создания software capital:</p><p><code>Code review</code></p><ul><li>позволяет получить не только собственную оценку качества кода</li><li>поиск багов</li><li>проверка соотвествия стандартам компании (взаимодействие позволяет создать стандарты!)</li><li>социализация -&gt; распространение знаний</li><li>отчётность качества кода - проверка наличия документации, юнит тестов, отвественность за код на двух людях</li></ul><p>О ревью кода часто говорят, но мало кто делает полноценно. У автора есть ещё несколько докладов на тему того, как бороться с менеджерами, которые запрещают не пропускать плохой код. Основной аргумент для менеджеров — “мы знаем, что данные правила позволяют уменьшить time to market в перспективе”. Не пропускать плохой код в мастер, иначе он там и останется (технический долг — антипод sofware capital). Каждый коммит должен проходить ревью.</p><p><em>Интересно проверить на практике, насколько эта идея работает</em></p><p><code>Стандарты</code><br>(форматирование, идиомы, организация компонентов, лучшие практики, требования к документации)</p><ul><li>уменьшение вариативности даёт увеличение продуктивности</li><li>профессионализм</li><li>чем более похожа структура, тем проще навигация</li><li>и обработки кода тулзами (clang-format, refactor, codegen)</li></ul><p><code>Unit testing</code></p><ul><li>безопасный рефакторинг</li><li>ранее вычищение некоторых багов</li><li>хинты: для gui — modularized gui, для io - dependency injections, против “i need ship” - код должен иметь тесты, чтобы пройти код-ревью!, против “я знаю что код работает” — нам нужно уметь поймать момент, когда из-за изменений в ходе добавления других фич он сломается. Требует CI.</li></ul><p><code>Контракты</code></p><ul><li>Спецификация ожидаемого поведения (in/out), не деталей реализации</li><li>Позволяет абстрагироваться от реализации, экономит время</li><li>Плохие интерфейсы видны по их контрактам</li><li>Подсказка для того, как написать unit-тесты</li></ul><p><em>Я не встречал, чтобы это применяли на практике</em></p><p><code>Хорошие интерфейсы</code></p><ul><li>форма искусства</li><li>простые контракты</li><li>управляемые части</li><li>организация кода: разделение на уровни “компонент/пакет/группа пакетов”. Функции класса, не требующие доступа к приватным членам отделяются в ClassUtil</li><li>не должно быть взаимных зависимостей между двумя компонентами</li></ul><p><code>Инновации</code></p><ul><li>инновации имеют стоимость - code rot (существующий код становится устравшим), добавление сложности</li><li>плата - освоение книг, курсов, конференции</li></ul><p><code>Инфраструктура</code></p><ul><li>vcs, ci, build system, core libraries, standards</li><li>кто-то должен отвечает за всю картину, эта задача требует высокой квалификации</li></ul><p><em>неочевидное свойство software capital — новые разработчики обязаны отказываться от своих привычек программирования и используемых инструментов, и переходить/изучать то, что использует и создала компания</em></p><h2 id="Зависимости-от-компонентов-и-свойства-API"><a href="#Зависимости-от-компонентов-и-свойства-API" class="headerlink" title="Зависимости от компонентов и свойства API"></a>Зависимости от компонентов и свойства API</h2><p>По субъективному опыту — для open-source библиотек можно найти качественные компоненты более “низкого” уровня (то, что можно забросить в 3rdPartyLibs), библиотеки среднего уровня чаще всего (если не считать движения свободного кода) — проприетарная собственность компаний (1stPartyLibs), так как требуют серьёзного уровня поддержки, который сложно поддерживать небольшой группе разработчиков, а также могут быть заточены под нужды конкретной компании. В Large-Scale C++ такие компоненты, накопленные компаниями, упоминаются, как <code>software capital</code>. Большие open-source библиотеки компонентов часто появляются как открытие накопленного корпорацией software capital (<code>abseil</code>, <code>folly</code>).</p><p>Еще одно интересное свойство компонент, которое влияет на простоту их использования — компактность их API. Так как библиотеки “среднего” уровня могут быть достаточно объёмными, Эрик Реймонд в книге “Искусство программирования для UNIX” вводит термин <code>полукомпактность</code> для систем, которые позволяет решать с их помощью большинство задач, используя только небольшую и наиболее используемую компактную часть их API. В качестве примеров полукомпактных систем он приводит <code>html</code> или язык <code>c</code> (не c++).</p><p><a href="https://www.youtube.com/watch?v=ZQ5_u8Lgvyk" target="_blank" rel="noopener">Designing and Evaluating Reusable Components - 2004</a> — доклад Casey Muratori (соавтор библиотек <a href="http://www.radgametools.com/granny.html" target="_blank" rel="noopener">Granny 3D</a>, которая изолирует нижний уровень компонет - “лист” на графе), про дизайн компонентов и виды зависимостей, которые они могут добавлять на уровне, который их использует. На скриншоте с графом уровней компонент выше рёбра — это абстрактное “использование” компонент, доклад разбирает виды и характеристики этих соединений.</p><p><img src="/blog/1337028819/reuse_small.png" alt=""></p><p>Свойства API:</p><p><code>Разделяемость (Granularity)</code><br>Возможность установить/изменить параметры за несколько вызовов — вставить действие между между ними.<br>Гибкость VS простота</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Orientation = GetOrientation(Object)</span><br><span class="line">Change = GetOrientationChange(Object)</span><br><span class="line">Change += <span class="number">3.14f</span>                <span class="comment">//</span></span><br><span class="line">RunSomeOtherUnrelatedTthing()  <span class="comment">// возможность поменять отложенно</span></span><br><span class="line">SetOrientation(Object, Orientation + Change)</span><br></pre></td></tr></table></figure><p><code>Избыточность (Redundancy)</code><br>Возможность выполнить действия несколькими способами<br>Удобство VS ортогональность</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//установка направления с помощью матрицы</span></span><br><span class="line">SetOrientation3x3(Object, Matrix)</span><br><span class="line"><span class="comment">//то же самое с помощью кватерниона</span></span><br><span class="line">SetOrientationQ(Object, Quat)</span><br><span class="line"><span class="comment">//то же самое с помощью заготовленных разработчиками методов/констант</span></span><br><span class="line">IdentityOrientation(Object)</span><br><span class="line">FaceForward(Object)</span><br></pre></td></tr></table></figure><p><code>Cвязанность (Coupling)</code><br>Зависимости между частями системы (почти всегда плохо, не часто неизбежно)<br>Несвязанность VS запутанность (<a href="https://www.youtube.com/watch?v=SxdOUGdseq4 -- более детально" target="_blank" rel="noopener">“Simple Made Easy” - Rich Hickey (2011)</a>)</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//неразделяемый апдейт всего (к примеру, физики)</span></span><br><span class="line">UpdateEverything(World)</span><br><span class="line"></span><br><span class="line"><span class="comment">//нужно установить состояние, прежде чем сделать что-то,</span></span><br><span class="line"><span class="comment">//  возможно скрыто</span></span><br><span class="line">SetTime(GlobalTime) </span><br><span class="line">UpdateObject(Object)</span><br><span class="line"></span><br><span class="line"><span class="comment">//возможность настройки только внутри пары вызовов</span></span><br><span class="line"><span class="comment">// часто подразумевает "не должно быть вложенности"</span></span><br><span class="line">BeginObjectSpecification()</span><br><span class="line">SetObjectState(Param1, Value1)</span><br><span class="line">Object = EndObjectSpecification()</span><br><span class="line"></span><br><span class="line"><span class="comment">//Использование скрытого общего буфера</span></span><br><span class="line"><span class="comment">// на который могут указывать String1 и String2</span></span><br><span class="line">String1 = GetMungedName(Name1)</span><br><span class="line">String2 = GetMungedName(Name2)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Нельзя сказать "у меня уже есть выделенная память, на которой нужно построить объект"</span></span><br><span class="line"><span class="comment">// или "выдели объект, но я инициализирую его, у меня кастомные инициализаторы из архивов"</span></span><br><span class="line">Object = AllocateAndInitialize()</span><br><span class="line"></span><br><span class="line"><span class="comment">//нужно обязательно создавать кастомный тип, хотя клиент может иметь тип для представления</span></span><br><span class="line"><span class="comment">// пример - QString для апи QT</span></span><br><span class="line">Matrix = MakeMatrixFrom(FloatPointer)</span><br><span class="line">SetOrientation(Object, Matrix)</span><br><span class="line"></span><br><span class="line"><span class="comment">//связь с форматом файла, нельзя создать самому,</span></span><br><span class="line"><span class="comment">//  зависимость от формата и I/O функций</span></span><br><span class="line">Object = ReadObject(filename)</span><br></pre></td></tr></table></figure><p><code>Запоминание (Retention)</code><br>Сохранение переданной ранее информации<br>Ведет к дублирование описания мира “внутри” библиотеки и в пользовательском коде<br>Сложность синхронизации состояний (комбинаторный рост от количества параметров) VS автоматизация работы после настройки</p><p>Immediate mode API (<a href="https://github.com/ocornut/imgui" target="_blank" rel="noopener">imgui</a> как пример) — одна из идея отказа от запоминания</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Настройка значений, которые повлияют на последующие вычисления</span></span><br><span class="line">SetTime(GlobalTime)</span><br><span class="line">SetPi(<span class="number">3.14f</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//изменение положение потомка также зависит от родителя</span></span><br><span class="line">SetParent(ChildObject, ParentObject)</span><br><span class="line">UpdateOrientation(ChildObject)</span><br></pre></td></tr></table></figure><p>Возможно, к “запоминанию” состояния можно отнести также некоторые идеи, которые предлагаются паттернами и парадигмами программирования:</p><ul><li>Асинхронное программирование с запоминанием точек продолжения программы (async/await)</li><li>Реактивное программирование, с запоминаем настроенных потоков данных</li><li>Декларативное программирование, с выполнением кода на какой-либо настроенной или заполненной ранее модели/системе</li></ul><p>В системах, в которых настройка может осуществляться гибко, императивное описание может быть лучше декларативного — явно указываем последовательность операций вместо того, чтобы извращаться с тем, чтобы оставалась возможность точно настроить декларативное описание.</p><p>Примеры:</p><ul><li>Декларативные системы сборки в Java Ant и Maven проиграли императивному способу gradle.</li><li><a href="https://github.com/spiiin/CadEditor/tree/master/CadEditor/settings_nes" target="_blank" rel="noopener">CadEditor</a> — мой редактор уровней для NES игр. “Стандартный” путь для редакторов уровней — декларативные конфигурационные файлы. Императивный — скриптовый язык, позволяющий описать, как загружать уровни, за счёт чего можно добавлять в редактор сотни игр, несильно отличающихся между собой, но всё же отличающихся настолько, что сложно предугадать в декларативной системе заранее.</li></ul><p><code>Порядок вызовов (Flow Control)</code><br>Вызывает ли библиотека колбеки приложения или приложение функции библиотеки (и зовут ли функции библиотеки колбеки из приложения). Чем чаще необходимо осуществлять передачу управления, тем сложнее отслеживать это пользователю библиотеки.<br>Контроль на стороне приложения (почти всегда лучше) VS на стороне библиотеки</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Для открытия файла будет вызван колбек Open</span></span><br><span class="line">SetFileCallbacks(Open, Read, Close)</span><br><span class="line">File = OpenFile(Filemame)</span><br><span class="line"></span><br><span class="line"><span class="comment">//То же самое, но спрятано за ООП,</span></span><br><span class="line"><span class="comment">// где-то скрыто сохранён указатель на функцию открытия</span></span><br><span class="line">class MyHandler: <span class="keyword">public</span> LibraryHandler &#123;</span><br><span class="line">  <span class="keyword">virtual</span> <span class="keyword">void</span> Open(<span class="keyword">char</span>* Filename)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Ещё про свойства библиотек — <a href="/blog/1152347544/" title="Хорошие библиотеки">Хорошие библиотеки</a></p><h2 id="Копирование-лучших"><a href="#Копирование-лучших" class="headerlink" title="Копирование лучших"></a>Копирование лучших</h2><p>Вместо написания чего-то с нуля нужно использовать или копировать лучших (смысл не пользоваться накоплненным software capital?).</p><ul><li>Черновая реализация на несколько оптимизаций отстает от оптимальной</li><li>Часто оптимальная может так сильно отличаться от наивной, что переделать станет сложно/невозможно</li><li>Для понимания оптимальной версии может потребоваться больше времени, и знаний для сравнения, чем для написания наивной</li></ul><p>Кроме оптимизаций, готовый код содержит фиксы множества ошибок, найденные за время его использования. Джоэл Спольски в эссе <a href="https://www.joelonsoftware.com/2000/04/06/things-you-should-never-do-part-i/" target="_blank" rel="noopener">Things You Should Never Do</a> расписывает печально известную проектировщикам истину — простой код, написанный с чистого листа, сильно отстаёт от давно написанного сложного, но отлаженного.</p><p>При этом копирование плохо работает в чём-то, отличном от кода. <a href="https://vadzimv.dev/2020/03/07/childs-illusions.html" target="_blank" rel="noopener">Книжки не заменяют опыта</a>, но обещают успех в случае повторения внешних признаков (чтобы понять границы применимости общих техник, необходимо колоссальное количество опыта).</p><p><code>Создание инструментов</code></p><p>Использование и создание лучших инструментов даёт <a href="https://borisbat.github.io/dascf-blog/2023/03/20/a-matter-of-multipliction/" target="_blank" rel="noopener">мультипликативный эффект</a>.</p><p>Раздел “Инструменты” — <a href="/blog/3652741154/" title="10 лет в геймдеве">10 лет в геймдеве</a></p><p><em>Примеры инструментов для профилирования программ на C++</em></p><p>Изучение memory layout для C++-структур — <a href="/blog/1170009669/" title="Расположение объектов C++ в памяти. Часть 2">Расположение объектов C++ в памяти. Часть 2</a><br>Отображение информации от профайлера xcode (cpu и memory) и xperf в виде флеймграфа — <a href="/blog/2526702897/" title="Flamegraph. Windows&#x2F;iOS&#x2F;Android">Flamegraph. Windows&#x2F;iOS&#x2F;Android</a></p><p>Новый инструмент для создания кода (и не только) сейчас — нейронные сети.</p><h2 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h2><p><strong><code>Data oriented</code></strong></p><ul><li>сначала кажется непривычным</li><li>так как (в случае, если мы думаем о локальности данных в памяти) подстраивается под данные, иногда требует дублирования кода под новые данные<br>(редко встречается достаточно генерик код, который может работать с кастомными структурами)</li><li>когда подстроишься под то, чтобы думать о расположении данных в памяти, становится сильно проще</li></ul><blockquote><p>Архитектура - это искусство проектировать и конструировать структуры</p><footer><strong>Sean Parent</strong></footer></blockquote><p>В геймдеве часто производительность имеет значение:</p><ul><li>там где ограниченные ресурсы - <a href="http://ru.esotericsoftware.com/" target="_blank" rel="noopener">Spine</a>-анимации для мобильных игр начинают тормозить уже на тех телефонах, но которых запускается Fortnite, при этом разработчиков не особо волнует эта проблема. <a href="https://youtu.be/rX0ItVEVjHc?t=4645" target="_blank" rel="noopener">Ответ</a> Mike Acton на позицию “We want not care about this stuff” - “из-за вас я должен ждать 2 минуты, пока открывается word”.</li><li>там где конкуренция, кто может выдать круче результат (точнее рассчёт физики, освещения, анимаций, ии)</li><li>там где платишь за сервера. <a href="https://youtu.be/KxQpDIKwGUw?t=2399" target="_blank" rel="noopener">Ответ</a> Максима Барышникова про то, зачем WoT сохраняется поддержка распределенных между серверами арен — на одном сервере помещается 3 арены, но за счёт того, что движок поддерживает разбиение, можно разместить 7 арен на 2х серверах (по 3.5 на сервер), а не на 3х, плюс можно динамически балансировать рассчёты, если все 4 арены одновременно становятся максимально нагруженными.</li></ul><p><strong><code>Performance if a feature</code></strong></p><ul><li>там где количество может переходить в качество, давать новые фичи. Например, без оптимизаций можем сделать RTS, в которых у игрока будет только 100 юнитов, а оптимизациями - как 100, так и 10000 - геймдизайнеры могут сделать фичей огромные армии, или более быстрая обработка позволяет “запихнуть” в освободившееся время ещё что-нибудь интересное.</li></ul><p>Кроме производительности конечной программы, немаловажно <strong><code>время сборки/пересборки и производительность дебажного билда</code></strong> (отлаживать не небажный билд добровольно — не очень весело).</p><p><a href="https://aras-p.info/blog/2018/12/28/Modern-C-Lamentations/" target="_blank" rel="noopener">“Modern” C++ Lamentations</a> — важная и большая статья о состоянии этого в современном C++ с большим количеством ссылок и сравнениями (<em>серьёзно, тот случай, когда стоит изучить каждую ссылку из статьи</em>). Кто-то пишет на ограниченном С++ (<code>Orthodox C++</code>), переучивая коллег и новичков, кто-то выбирает и создаёт альтернативные библиотеки (<code>EASTL</code>), кто-то переходит на другие языки (<code>Rust, Jai, Burst C#, daScript</code>).</p><ul><li><a href="/blog/1728194429/" title="С++ в геймдеве">С++ в геймдеве</a> — мой обзор применения C++ для разработки игр</li></ul><p><a href="https://www.youtube.com/watch?v=NAVbI1HIzCE" target="_blank" rel="noopener">Practical Optimizations</a> — доклад Jason Booth c измерениями производительности DoD кода. Важный тезис — <strong><code>optimization is a DESIGN time problem</code></strong>. Если не организовать данные в памяти сразу, переделать будет сложно. В докладе есть нестандартные примеры оптимизаций.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Дамп мыслей про проектирование систем, как обычно, с уклоном в геймдев.&lt;br&gt;
    
    </summary>
    
    
    
      <category term="dev_evolution" scheme="http://spiiin.github.io/tags/dev-evolution/"/>
    
      <category term="dev_method" scheme="http://spiiin.github.io/tags/dev-method/"/>
    
  </entry>
  
  <entry>
    <title>Иерархические компании vs плоские</title>
    <link href="http://spiiin.github.io/blog/3914071471/"/>
    <id>http://spiiin.github.io/blog/3914071471/</id>
    <published>2023-02-12T15:21:34.000Z</published>
    <updated>2023-02-12T23:05:17.776Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Несколько дней назад “уволенный сотрудник Mytona опубликовал открытое письмо” (на самом деле, <a href="https://www.youtube.com/watch?v=lYvNWf4Q2xE" target="_blank" rel="noopener">видео</a> на 2 часа). Я проработал в Майтоне 3.5 года, прошёл там путь от обычного программиста, “второго лида”, лида-проекта, программиста движка и технического продюссера, плюс долгое время занимался собеседованиями (провел штук 100 интервью), так что знаю там устройство компании на различных уровнях. Устройство не сильно отличается от типовой корпорации, так что и проблемы, озвученные в видео, типичны скорее для каждой компании, чем для конкретной.</p><p>В первую очередь, немного по сути видео — автор достаточно склочен, и по большей части озвученных ситуаций раздувает из мухи слона. На мой взгляд, выбрасывать подобное в паблик очень неэтично (а то и подсудно, особенно клевета на CEO fntastic, с учётом того, что они разрабатывают свои игры никак не связано с издателем), так как журналисты из мутного обезличенного рассказа сделают “жёлтый” пересказ. Первый же пересказы в гугле красуются фразами — “лид держит их в страхе: Mytona трещит по швам?” и “многие люди просто попали в депрессию и начали жрать таблетки”. При этом, сам автор вначале делает 20-минутный дисклеймер, что в целом работалось неплохо.</p><p>Но хотел написать небольшую заметку о том, чем отличаются большие компании от небольших, без отсылок на конкретные компании. Конечно, структура компаний может сильно отличаться, как и внутренняя культура, так что рассуждения дальше — это сферический конь в вакууме.</p><p>Критический размер для маленьких компаний, которые стремятся к плоской организации — число Данбара (100-230 человек), встречается в докладах про структуру Unity - <a href="https://aras-p.info/texts/files/201312-BuildStuffLightweightChaos.pdf" target="_blank" rel="noopener">Lightweight Chaos For Distributed Teams</a>, Github - <a href="https://zachholman.com/talk/how-github-no-longer-works/" target="_blank" rel="noopener">How GitHub (no longer) Works</a> или в докладах Джесси Шелла - <a href="https://www.youtube.com/watch?v=-zRaFJHK0S4" target="_blank" rel="noopener">Game Studio Management: Making It Great</a> и <a href="https://www.youtube.com/watch?v=O1zP6yJjc1o" target="_blank" rel="noopener">Game Studio Leadership: You Can Do It</a>.</p><p>С таким размером компании можно обходиться <em>почти</em> без менеджеров, с чем и связы основные отличия от “больших” корпораций (естественно, маленький размер не гарантирует того, что компания не будет организована как корпоративный ад). Число данбара говорит скорее о том, чем у компании с &gt;230 человек практические неизбежно будут наблюдаться все признаки “большой”. Так что более удачные термины вместо “больших” и “маленьких” —  иерархические и плоские.</p><p><strong><code>Распространение новостей в компании</code></strong></p><p>В иерархических компаниях часто встречается “испорченный телефон”. На высоком “уровне” условный продюссер проекта общается как с издателем/топ-менеджментом, так и с лидами направлений своего проекта (программисты, арт, геймдизайнеры) и общих отделов всей компании. Невозможно передать всю важную информацию по проекту “вниз по иерархии” исполнителям. Также практически необходимы каналы с освещением жизни компании и других отделов, если она хочет существовать как единое целое. Бонусом — всякие корпоративы, тимбилдинги и ивенты для организации дополнительных неформальных связей. При этом всём по прежнему самый надёжный способ узнать что-то достоверно — иметь знакомого, которые откуда-то умудряется знать всё и со всеми дружит.</p><p><strong><code>Разрешение конфликтов</code></strong></p><p>На кого-то ложится обязанность знать об атмосфере в коллективе, разруливать конфликты делегируется кому-нибудь типа специально обученных эйчаров. Причём задача сложная, отсюда неизбежны отзывы типа “меня уволили из-за конфликта с одним человеком” — это стандартный способ решения конфликта, который не могут уладить сами сотрудники, в случае, если невозможно перевести их подальше друг от друга. В плоской компании необходимо вписываться в коллектив, в иерархической — наверное можно попасть в другой проект, не пересекаясь больше ни с кем из предыдущего. Вообще найти себе команду и место, где применить свои навыки в плоской компании — задача самого сотрудника.</p><p><strong><code>Скорость реагирования</code></strong></p><p>Передача информации по уровням иерархии — очень медленный процесс, особенно если выполняется через какие-нибудь метрики или отчеты. Поэтому для задач, которые вроде требуют оперативного реагирования, могут происходить какие-то чудовищные ынтырпрайз истории (<a href="https://vas3k.club/post/5070/" target="_blank" rel="noopener">пример подборки</a>). Вполне могут существовать никому не нужные отделы, не выгоняться по году неработающие раздолбаи. Ну, и скорость реакции на меняющийся рынок — тоже не лучшие сторона иерархических компаний. Книга “Дилемма инноватора” рассматривает это подробно.</p><p><strong><code>Ценности</code></strong></p><p>Ценности в плоской компании — это или очевидные вещи, или негласные правила. Но! Если они таки есть, то сотрудники “впитывают” их естественным образом, просто продолжая работать в компании. Скорее всего плоская компания и занимается исключительно тем, что считает ценным. В иерархических компаниях ценности более абстрактны, и причастность к ним — скорее способ мотивации и повышения лояльности работников, а не способ выбора варианта действий в непонятных случаях. Вместо ценностей работают инструкции, что можно, нужно или нельзя делать.</p><p><strong><code>Найм</code></strong></p><p>Иерархические компании стремятся быть похожими друг на другу, и в теории иметь возможность заменить хоть всех сотрудников. Из-за этого вполне способны впитывать больше новичков. В плоских — процессы найма отличаются, но часто новый сотрудник должен приносить что-то новое. Недавняя истории с увольнениями десятков тысяч сотрудников тажке показывает, что иерархические компании могут расширяться просто чтобы расширяться (“наймём, чтобы другие не наняли”).</p><p><strong><code>Свобода действий</code></strong></p><p>Иерархическая компания как структура стремится воспроизводить сама себя, поэтому новые проекты делаются как старые, даже если декларируется свобода организации внутри проекта. В отдельных случаях иерархические компании стремятся изображать плоские, что выглядит как “менеджерам была поставлена задачи организовать команду без менеджеров”. Также очень нерационально для общих отделов иерархической компании работать с каждой командой по разному, так что рано или поздно кто-нибудь выступит с инициативой стандартизации.</p><p>Плоские команды изначально работают как в стиле “управляемый хаос”, в котором приживаются те практики, которые полезны в настоящий момент.</p><p><strong><code>Количество менеджеров</code></strong></p><p>В иерархических компаниях часто встречается случай, когда у тебя 2 менеджера — руководитель проекта и руководитель направления. На мой взгляд это основная причина фрустрации автора видео, как руководитель нарративных дизайнеров он не очень хотел вникать в проблемы руководителей частного проекта, который противоречат его видению. Такая система доставляет больше сложностей самим менеджерам, чем работникам, потому что требует хорошей координации и способности договариваться между самими менеджерами.</p><p>Иерархическая компания требует большого количества менеджеров, которых проще вырастить, чем нанять внешних, в связи с чем способный работник с большой долей вероятности станет менеджером.</p><p>В плоских компаниях организацией занимается неформальный лидер. Но при этом в иерархических компаниях также скорее всего тоже есть ещё и неформальные лидеры.</p><p><strong><code>Инертность к изменениям</code></strong></p><p>В иерархических компаниях сложно передать изменения в другую часть системы — несмотря на унификацию частей, изменения нужно отдельно внедрить в каждой подсистемы, причем так, чтобы внедряли их именно менеджеры этих подсистем, которые могут исказить смысл или даже осознанно противиться изменениям. Так что — сложнее обучать людей, менять или внедрять правила, пробовать новое, и сложнее прекратить порочные устоявшиеся практики.</p><p>Плоские компании могут быть как инертными, так и гибкими. Готовность к изменением “копится” до тех пор, пока или проблема станет мешать всем настолько, что найдётся желающий её поправить, или кто-то узнает про то, как можно серьёзно что-то улучшить. Активный поиск информации и исследование — кажется, одна из отличительных черт плоских компаний, которую редко подчёркивают.</p><p><strong><code>Доступ к ресурсам</code></strong></p><p>Содержать иерархическую компанию дороже (кроме специалистов нужны доп. менеджеры, а то и “менеджеры менеджеров”, корпоративы и тимбилдинг также стоят денег), так что такие компании должны располагать достаточными ресурсами, там где плоские могут быть экономнее. Хотя слышал и обратное мнение — из-за того, что плоские компании не хотят тратиться на менеджеров или содержать отдельные отделы, чтобы не расширяться, им приходится аутсорить часть работы, что выходит дороже, если делать это регулярно.</p><p>Доступ к ресурсам также определяет степень риска, на который готовы пойти. Содержание бОльших команд (а иерархические часто больше) стоит дороже, но при этом появляется стремление уменьшить риски. Маленькие команды готовы к большему риску ради того, чтобы получить больший выигрыш (а он также нужен, чтобы иметь больше возможности конкурировать с компаниями бОльших размеров). При этом скорость реализации проектов иерархическими и плоскими командами может быть примерно сопоставима. Если команда из 10 человек делает за одно и то же время то же, что и команда из 100, то это можно было бы объяснить тем, что все 10 — гении, но если команда из 200 человек делает столько же, сколько команда из 1000, скорее всего разница объясняется эффективностью организации.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;Несколько 
      
    
    </summary>
    
    
    
      <category term="log" scheme="http://spiiin.github.io/tags/log/"/>
    
      <category term="gamedev" scheme="http://spiiin.github.io/tags/gamedev/"/>
    
  </entry>
  
  <entry>
    <title>daScript: обобщенное программирование</title>
    <link href="http://spiiin.github.io/blog/2629978232/"/>
    <id>http://spiiin.github.io/blog/2629978232/</id>
    <published>2023-01-21T21:33:14.000Z</published>
    <updated>2023-03-04T18:28:28.613Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Обобщенное программирование — одна из серых, но важных и интересных сторон daScript. “Серость” темы связана с тем, что, во-первых, система типов не очень детально описана в документации, во-вторых — в рассуждениях о типизации можно от практики быстро уйти в дебри академических терминов, в-третьих, тема плохо укладывается в голову C++-программисту.</p><p>Поддержка обобщенного программирования в языке, если “на пальцах” — совокупность способов вызывать одну функцию для разных типов.</p><h2 id="Перегрузка-функций"><a href="#Перегрузка-функций" class="headerlink" title="Перегрузка функций"></a>Перегрузка функций</h2><p>Перегруженные функции (ad-hoc полиморфизм) — простейший способ определить функцию для двух различных типов</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">func</span><span class="params">(a : <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;a&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function">def <span class="title">func</span><span class="params">(a : <span class="keyword">float</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;a&#125;\n"</span>)</span></span></span><br><span class="line">[export]</span><br><span class="line">def main</span><br><span class="line">    func(<span class="number">1</span>)</span><br><span class="line">    func(<span class="number">1.0f</span>)</span><br></pre></td></tr></table></figure><p><strong><code>Константность</code></strong></p><p>Напечатаем тип параметра-аргумента:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">func</span><span class="params">(a : <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;typeinfo(typename a)&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"><span class="comment">//Output:</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="keyword">const</span></span></span><br></pre></td></tr></table></figure></p><p>По умолчанию к типу был добавлен спецификатор <code>const</code>, который не позволяет поменять значение аргумента. Его можно убрать, добавив ключевое слово <code>var</code>:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">func</span><span class="params">(var a: <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;typeinfo(typename a)&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"><span class="comment">//Output</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br></pre></td></tr></table></figure></p><p>При выборе перегрузки, константная и неконстантная версия, в отличие от C++, не имеют приоритета друг перед другом и при нахождении двух вариантов функции <code>daScript</code> выдаст ошибку (<a href="https://dascript.org/doc/reference/language/functions.html#function-overloading" target="_blank" rel="noopener">Правила выбора функции</a>).<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var a: <span class="keyword">int</span></span><br><span class="line">func(a)</span><br><span class="line"><span class="comment">//Output</span></span><br><span class="line"><span class="number">30304</span>: too many matching functions <span class="keyword">or</span> generics func</span><br><span class="line">candidates:</span><br><span class="line">        func ( a : <span class="keyword">int</span> <span class="keyword">const</span> ) : <span class="keyword">void</span> at generics.das:<span class="number">3</span>:<span class="number">4</span> <span class="comment">//принимает int и int const</span></span><br><span class="line">        func ( a : <span class="keyword">int</span> -<span class="keyword">const</span> ) : <span class="keyword">void</span> at generics.das:<span class="number">9</span>:<span class="number">4</span> <span class="comment">//-const читается как "удалить у типа спецификатор const"</span></span><br></pre></td></tr></table></figure></p><p>Для того, чтобы daScript различил функции, можно добавить <a href="https://dascript.org/doc/reference/language/generic_programming.html#type-contracts-and-type-operations" target="_blank" rel="noopener">спецификатор типа</a> <code>== const</code> (“константность аргумента должна совпадать).<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">func</span><span class="params">(a : <span class="keyword">int</span> ==<span class="keyword">const</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;typeinfo(typename a)&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">def <span class="title">func</span><span class="params">(var a : <span class="keyword">int</span> ==<span class="keyword">const</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;typeinfo(typename a)&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">[export]</span><br><span class="line">def main</span><br><span class="line">    var a: <span class="keyword">int</span></span><br><span class="line">    func(a)</span><br><span class="line">    func(<span class="number">1</span>)</span><br><span class="line"><span class="comment">//Output:</span></span><br><span class="line"><span class="keyword">int</span> ==<span class="keyword">const</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> ==<span class="keyword">const</span></span><br></pre></td></tr></table></figure></p><p><strong><code>Ссылки</code></strong></p><p>В предыдущем примере аргумент передавался по значению, поэтому даже <code>var int</code> не позволяет изменить переданную переменную (меняется <strong>значение аргумента</strong>, а не оригинальная переменная). Возможно передать аргумент по ссылке:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">func</span><span class="params">(var a : <span class="keyword">int</span>&amp;)</span></span></span><br><span class="line"><span class="function">    a </span>= <span class="number">42</span></span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main</span><br><span class="line">    var a: <span class="keyword">int</span></span><br><span class="line">    func(a)</span><br><span class="line">    print(<span class="string">"&#123;a&#125;\n"</span>)</span><br><span class="line"><span class="comment">//Output: 42</span></span><br></pre></td></tr></table></figure></p><p><strong> Все непримитивные типы передаются по ссылке, независимо от того, был ли описан аргумент со спецификатором <code>&amp;</code> или без него. </strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">    <span class="title">a</span> :</span> <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">func</span><span class="params">(var arg : A)</span></span></span><br><span class="line">    arg.a = 42</span><br><span class="line">    print(<span class="string">"&#123;typeinfo(typename arg)&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main</span><br><span class="line">    var a : A</span><br><span class="line">    func(a)</span><br><span class="line">    print(<span class="string">"&#123;a&#125;\n"</span>)</span><br><span class="line"><span class="comment">//Output</span></span><br><span class="line">A</span><br><span class="line">[[ <span class="number">42</span>]]</span><br></pre></td></tr></table></figure><p><em>(причём можно описать 2 перегруженные функции с аргуметами типа A и A&amp;, несмотря на то, что для структур семантически это будет идентичная запись)</em></p><p>При этом, как и с константностью, компилятор не различает приоритета перегрузки функций с аргументом-ссылкой и значением, и выдаёт ошибку неоднозначности разрешения перегрузки.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">func</span><span class="params">(var a: <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">    pass</span></span><br><span class="line"><span class="function">def <span class="title">func</span><span class="params">(var a : <span class="keyword">int</span>&amp;)</span></span></span><br><span class="line"><span class="function">    pass</span></span><br><span class="line"><span class="function"></span></span><br><span class="line">[export]</span><br><span class="line">def main</span><br><span class="line">    func(<span class="number">1</span>) <span class="comment">//ok</span></span><br><span class="line">    var a: <span class="keyword">int</span></span><br><span class="line">    func(a) <span class="comment">//30304: too many matching functions or generics func</span></span><br><span class="line">            <span class="comment">//candidates:</span></span><br><span class="line">            <span class="comment">//func ( a : int -const ) : void at generics.das:1:4</span></span><br><span class="line">            <span class="comment">//func ( a : int&amp; -const ) : void at generics.das:3:4</span></span><br></pre></td></tr></table></figure><p><strong><code>Контракты</code></strong></p><p>Макросы работают раньше разрешения перегрузки, что позволяет реализовать паттерн <a href="https://github.com/GaijinEntertainment/daScript/blob/e7992b384dad13c1a201f9eee1c6a6ae1e0cf8b8/daslib/contracts.das" target="_blank" rel="noopener">contracts</a> — произвольную функцию, которая предварительно проверяет тип аргументов:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">require daslib/contracts</span><br><span class="line"></span><br><span class="line">[!expect_ref(arg)]</span><br><span class="line"><span class="function">def <span class="title">func</span><span class="params">(var arg : <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;typeinfo(typename arg)&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">[expect_ref(arg)]</span><br><span class="line"><span class="function">def <span class="title">func</span><span class="params">(var arg : <span class="keyword">int</span>&amp;)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;typeinfo(typename arg)&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">[export]</span><br><span class="line">def main</span><br><span class="line">    var a: <span class="keyword">int</span></span><br><span class="line">    func(a)</span><br><span class="line">    func(<span class="number">1</span>)</span><br><span class="line"><span class="comment">//Output:</span></span><br><span class="line"><span class="keyword">int</span> <span class="comment">//must be int&amp;</span></span><br><span class="line"><span class="keyword">int</span></span><br></pre></td></tr></table></figure><p><a href="https://github.com/GaijinEntertainment/daScript/blob/master/examples/test/misc/contracts_example.das" target="_blank" rel="noopener">https://github.com/GaijinEntertainment/daScript/blob/master/examples/test/misc/contracts_example.das</a><br><em>вывод typeinfo, кажется, содержит <a href="https://github.com/GaijinEntertainment/daScript/issues/393" target="_blank" rel="noopener">баг</a></em></p><p><strong><code>Временные ссылки</code></strong></p><p>Кроме обычных ссылок в daScript есть временные ссылки, которые позволяют работать с объектами из C++-кода внутри блоков. Временная ссылка доступна только внутри блока, и не может быть сохранена вне его (но может быть передана в другую функцию, принимающую временные объекты).</p><p>Рассмотрим для примера C++ тип <code>Color</code> из <a href="https://github.com/GaijinEntertainment/daScript/blob/master/examples/tutorial/tutorial03.cpp#L15" target="_blank" rel="noopener">туториала к daScript</a>. Для него создаётся daScript-обёртка, в которую можно добавить декларацию конструктора и инициализатора с помощью паттерна <code>using</code> — в этом случае можно создать временную ссылку на тип, которая будет доступна только внутри блока: </p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//cpp</span></span><br><span class="line">Module_Tutorial03() : Module(<span class="string">"tutorial_03"</span>) &#123;   <span class="comment">// module name, when used from das file</span></span><br><span class="line">    ModuleLibrary lib;</span><br><span class="line">    ...</span><br><span class="line">    addCtorAndUsing&lt;Color&gt;(*<span class="keyword">this</span>, lib, <span class="string">"Color"</span>, <span class="string">"Color"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//das</span></span><br><span class="line"></span><br><span class="line">require tutorial_03</span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">printColor</span><span class="params">(c : Color)</span> <span class="comment">//same as Color&amp; as c is struct</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;typeinfo(typename c)&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">def <span class="title">printColor</span><span class="params">(c : Color#)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;typeinfo(typename c)&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">[export]</span><br><span class="line">def test</span><br><span class="line">    let c = [[Color]]</span><br><span class="line">    printColor(c)</span><br><span class="line">    <span class="keyword">using</span>() &lt;| $(var c_temp : Color#)</span><br><span class="line">        printColor(c_temp)</span><br><span class="line"><span class="comment">//Output</span></span><br><span class="line">tutorial_03::Color <span class="keyword">const</span></span><br><span class="line">tutorial_03::Color <span class="keyword">const</span>#</span><br></pre></td></tr></table></figure><p><strong>Если тип нельзя <a href="https://github.com/GaijinEntertainment/daScript/commit/9521fdba38c4f5ea422450c6b4979cc2808f58ef" target="_blank" rel="noopener">скопировать или переместить</a>, то <code>using</code> не будет не будет создавать временный тип — аргумент и так не сможет покинуть блок</strong></p><p>Чаще всего нет необходимости в раздельной обработке обычных и временных ссылок, в этом случае можно добавить к типу аргумента спецификатор <code>implicit</code>:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">printColor</span><span class="params">(c:Color implicit)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;typeinfo(typename c)&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"><span class="comment">//Output</span></span></span><br><span class="line"><span class="function">tutorial_03::Color <span class="keyword">const</span> implicit</span></span><br><span class="line"><span class="function">tutorial_03::Color <span class="keyword">const</span> implicit</span></span><br></pre></td></tr></table></figure><p>Небольшое отличие в том, как будет трактоваться аргумент:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">printColor</span><span class="params">(c:Color implicit)</span>    <span class="comment">// accepts Color and Color#, a will be treated as Color</span></span></span><br><span class="line"><span class="function">def <span class="title">printColor</span><span class="params">(c:Color# implicit)</span>   <span class="comment">// accepts Color and Color#, a will be treated as Color#</span></span></span><br></pre></td></tr></table></figure></p><p><strong><code>Указатели</code></strong></p><p>Как и в C++, указатели — это ссылки, которые могут указывать на <code>null</code>, также имеют чуть другую семантику, что позволяет уже без шаманства иметь перегрузки для значения и указателя.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">require daslib/safe_addr</span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">func</span><span class="params">(var a: <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;typeinfo(typename a)&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">def <span class="title">func</span><span class="params">(var a: <span class="keyword">int</span>?)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;typeinfo(typename a)&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">[export]</span><br><span class="line">def main</span><br><span class="line">    var a: <span class="keyword">int</span></span><br><span class="line">    var a_ptr: <span class="keyword">int</span>? = safe_addr(a)</span><br><span class="line">    func(a)</span><br><span class="line">    func(a_ptr)</span><br><span class="line"><span class="comment">//Output</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line"><span class="keyword">int</span>?</span><br></pre></td></tr></table></figure><p><strong><code>Приведение базовых типов</code></strong></p><p>Базовые типы не приводятся друг другу неявно, требуется явный вызов конструктора типа (<em>Explicit is better than implicit</em>).</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">func</span><span class="params">(a : <span class="keyword">int</span>)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function">def <span class="title">func</span><span class="params">(a : <span class="keyword">float</span>)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function">def <span class="title">func</span><span class="params">(a : int4)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function">def <span class="title">func</span><span class="params">(a : <span class="keyword">bool</span>)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function">def <span class="title">func</span><span class="params">(a : uint)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function">def <span class="title">func</span><span class="params">(a : int64)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main</span><br><span class="line">    func(<span class="number">1</span>) <span class="comment">//int</span></span><br><span class="line">    func(<span class="keyword">float</span>(<span class="number">1</span>)); func(<span class="number">1.0f</span>) <span class="comment">//float</span></span><br><span class="line">    func(int4(<span class="number">1</span>)) <span class="comment">//int4</span></span><br><span class="line">    func(<span class="literal">true</span>) <span class="comment">//bool</span></span><br><span class="line">    func(uint(<span class="number">1</span>)); func(<span class="number">1u</span>); func(<span class="number">0x1</span>) <span class="comment">//uint</span></span><br><span class="line">    func(int64(<span class="number">1</span>)); func(<span class="number">1l</span>) <span class="comment">//int64</span></span><br></pre></td></tr></table></figure><p><strong><code>Приведение классов/структур</code></strong></p><p>Для типов, поддерживающих наследование, неявно выполняется приведение указателей и ссылок от дочернего к родительскомму типу (<a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle" target="_blank" rel="noopener">LSP</a>).</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> </span></span><br><span class="line"><span class="class">    <span class="title">a</span> :</span> <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> :</span> A</span><br><span class="line">    b : <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">func</span><span class="params">(a : A)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;typeinfo(typename a)&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">[export]</span><br><span class="line">def main</span><br><span class="line">    var a : A</span><br><span class="line">    var b : B</span><br><span class="line">    func(a)</span><br><span class="line">    func(b)</span><br><span class="line"><span class="comment">//Output:</span></span><br><span class="line">A <span class="keyword">const</span></span><br><span class="line">A <span class="keyword">const</span></span><br></pre></td></tr></table></figure><p>Приведение типов структур (<code>cast/upcast/reinterpret</code>):<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var a : A</span><br><span class="line">var b : B</span><br><span class="line"></span><br><span class="line">var refA : A&amp; = a</span><br><span class="line">var refB : B&amp; = b</span><br><span class="line"></span><br><span class="line"><span class="comment">//downcast, safe</span></span><br><span class="line">refA = cast&lt;A&amp;&gt; refB </span><br><span class="line"><span class="comment">//upcase, unsafe</span></span><br><span class="line">unsafe</span><br><span class="line">    refB = upcast&lt;B&amp;&gt; refA</span><br><span class="line"><span class="comment">//reinterpret cast, VERY unsafe, can cast any</span></span><br><span class="line">unsafe</span><br><span class="line">    refA = reinterpret&lt;A&amp;&gt;(<span class="number">1</span>) <span class="comment">//will crash</span></span><br></pre></td></tr></table></figure></p><p><strong>При выборе перегрузки функции выбирается та, для которой нужно выполнить наименьшее количество преобразований (при равном количестве daScript выдаст ошибку неоднозначности выбора)</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> </span></span><br><span class="line"><span class="class">    <span class="title">a</span> :</span> <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> :</span> A</span><br><span class="line">    b: <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">func</span><span class="params">(var a : A?)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"a: &#123;typeinfo(typename a)&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">def <span class="title">func</span><span class="params">(var b : B?)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"b: &#123;typeinfo(typename b)&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">def <span class="title">func4</span><span class="params">(var a,b,c,d: A?)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"AAAA\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">def <span class="title">func4</span><span class="params">(var a,b,c: A?; var d: B?)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"AAAB\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">def <span class="title">func4</span><span class="params">(var a,b : A?; var c: B?; var d: A?)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"AABA\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">def <span class="title">func4</span><span class="params">(var a,b,c,d: B?)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"BBBB\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">[export]</span><br><span class="line">def main</span><br><span class="line">    <span class="comment">//simple cases</span></span><br><span class="line">    var refA = <span class="keyword">new</span> A()</span><br><span class="line">    func(refA) <span class="comment">//a: A?</span></span><br><span class="line">    var refB = <span class="keyword">new</span> B()</span><br><span class="line">    func(refB) <span class="comment">//b: B?</span></span><br><span class="line">    var refAB = cast&lt;A?&gt; <span class="keyword">new</span> B()</span><br><span class="line">    func(refAB) <span class="comment">//a: A?</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//advanced cases</span></span><br><span class="line">    func4(refA, refA, refA, refA) <span class="comment">//shortest LSP to AAAA = 0</span></span><br><span class="line">    func4(refA, refA, refA, refB) <span class="comment">//shortest LSP to AAAB = 0</span></span><br><span class="line">    <span class="comment">//func4(refA, refA, refB, refB) //shortest LSP to AAAB/AABA = 1, conflict error</span></span><br><span class="line">    func4(refA, refB, refB, refA) <span class="comment">//shortest LSP to AABA = 1</span></span><br><span class="line">    func4(refB, refB, refB, refB) <span class="comment">//shortest LSP to BBBB = 0</span></span><br></pre></td></tr></table></figure><p><strong><code>explicit</code></strong></p><p>Для того, чтобы отключить LSP приведение типа аргумента, можно добавить ключевое слово <code>explicit</code>. Так </p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> </span></span><br><span class="line"><span class="class">    <span class="title">a</span> :</span> <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> :</span> A</span><br><span class="line">    b : <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">func</span><span class="params">(var a : A <span class="keyword">explicit</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;typeinfo(typename a)&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">[export]</span><br><span class="line">def main</span><br><span class="line">    var a : A</span><br><span class="line">    var b : B</span><br><span class="line">    func(a)   <span class="comment">//A</span></span><br><span class="line">    <span class="comment">//func(b) //invalid argument a (0). expecting A explicit -const, passing B&amp; -const</span></span><br></pre></td></tr></table></figure><p><strong><code>Приведение generic-типов</code></strong></p><p>В документации не описана работа с generic-типами (и не дано общее определение для них, также пока отсутствует возможность создания своих типов), но поиском по коду находятся такие встроенные типы (исключая те, которые связаны с оператором typeinfo и кастами):</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Функциональные объекты:</span><br><span class="line">block</span><br><span class="line">function</span><br><span class="line">lambda</span><br><span class="line"></span><br><span class="line">Коллекции:</span><br><span class="line">array</span><br><span class="line">table&lt;key&gt;</span><br><span class="line">table&lt;key, value&gt;</span><br><span class="line"></span><br><span class="line">iterator</span><br><span class="line">generator</span><br><span class="line">smart_ptr</span><br><span class="line">tuple</span><br><span class="line">variant</span><br></pre></td></tr></table></figure><p>Для таких типов, возможно явное LSP-приведение для типов их аргументов (<code>ковариантность</code>). Пример для функций:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> </span></span><br><span class="line"><span class="class">    <span class="title">a</span> :</span> <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> :</span> A</span><br><span class="line">    b : <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">func1</span><span class="params">(var a : A)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"a\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">def <span class="title">func2</span><span class="params">(var b : B)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"b\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">def <span class="title">highOrder</span><span class="params">(func: function&lt;(var a:A):<span class="keyword">void</span>&gt;)</span></span></span><br><span class="line"><span class="function">    <span class="title">invoke</span><span class="params">(func, [[B]])</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">[export]</span><br><span class="line">def main</span><br><span class="line">    highOrder(@@func1)</span><br><span class="line">    highOrder(cast&lt;function&lt;(var a:A):<span class="keyword">void</span>&gt;&gt; @@func2) <span class="comment">//возможно привести тип function&lt;(var b:B):void&gt; к function&lt;(var a:A):void&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Generic-функции"><a href="#Generic-функции" class="headerlink" title="Generic-функции"></a>Generic-функции</h2><p>Вернёмся к самому первому примеру — если мы хотим написать функцию, семантически одинаково обрабатывающую различные типы (например, выводящую значение типа с помощью функции <code>print</code>) для типов. Чтобы не реализовывать её для каждого нового типа, в языках программирования используется понятие generic-функций, которые могут производить конкретные функции для новых типов автоматически.</p><p><a href="https://habr.com/ru/company/piter/blog/656377/" target="_blank" rel="noopener">Обзор реализаций в языках</a>.</p><p>Шаблонные функции в C++ производят код конкретных функций на уровне текста, который отдаётся компилятору (если не ошибаюсь, компилятор visual studio в этом плане действительно генерирует полные копии, не остлеживаю возможных повторов, чтобы иметь больше простора для частных оптимизаций функции под конкретные типы, а clang чуть раньше начинает отслеживать потенциально идентичные реализации для экономии памяти).</p><p>Другой возможный вариант реализации в Java — “изображать” generic на высоком уровне для контроля типов, но оставлять одну реализацию (все объекты передаются по ссылке, добавляется overhead при работе с value-типами по боксингу/анбоксингу в обёртку).</p><p>Третий путь из C# — добавить поддержку generic-функций в виртуальную машину, в этом случае возможна комбинированная реализация — value-типы получают свои сгенерированные копии функций, а reference-типы — общую функцию. Также возможно инстанцировать новые версии функций в runtime. daScript близок к такому типу реализации generic-функций.</p><p><strong><code>Автоматический вывод типов</code></strong></p><p>Если не указан тип аргумента функции, daScript выводит его автоматически, пример функции id принимающей аргумент любого типа и возвращающий его:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">options <span class="built_in">log</span>=<span class="literal">true</span>, optimize=<span class="literal">false</span></span><br><span class="line"></span><br><span class="line">struct S1</span><br><span class="line">    a: <span class="keyword">int</span></span><br><span class="line">struct S2</span><br><span class="line">    a: <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">def id(T)</span><br><span class="line">    <span class="keyword">return</span> T</span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main</span><br><span class="line">    let a = id(<span class="number">1</span>)</span><br><span class="line">    let b = id(<span class="number">1.0f</span>)</span><br><span class="line">    let c = id([[S1]])</span><br><span class="line">    let d = id([[S2]])</span><br><span class="line"><span class="comment">//Output</span></span><br><span class="line"></span><br><span class="line">def `id ( T:<span class="keyword">int</span> <span class="keyword">const</span> <span class="keyword">explicit</span> ) : <span class="keyword">int</span> <span class="keyword">const</span></span><br><span class="line">        <span class="keyword">return</span> T</span><br><span class="line"></span><br><span class="line">def `id ( T:<span class="keyword">float</span> <span class="keyword">const</span> <span class="keyword">explicit</span> ) : <span class="keyword">float</span> <span class="keyword">const</span></span><br><span class="line">        <span class="keyword">return</span> T</span><br><span class="line"></span><br><span class="line">def `id ( T:S1 <span class="keyword">const</span> <span class="keyword">explicit</span> ) : S1 <span class="keyword">const</span></span><br><span class="line">        <span class="keyword">return</span> T</span><br><span class="line"></span><br><span class="line">def `id ( T:S2 <span class="keyword">const</span> <span class="keyword">explicit</span> ) : S2 <span class="keyword">const</span></span><br><span class="line">        <span class="keyword">return</span> T</span><br><span class="line"></span><br><span class="line">def <span class="keyword">public</span> main</span><br><span class="line">        let a:<span class="keyword">int</span> <span class="keyword">const</span> = __::`id(<span class="number">1</span>)</span><br><span class="line">        let b:<span class="keyword">float</span> <span class="keyword">const</span> = __::`id(<span class="number">1f</span>)</span><br><span class="line">        let c:S1 <span class="keyword">const</span> = __::`id([[S1 ]])</span><br><span class="line">        let d:S2 <span class="keyword">const</span> = __::`id([[S2 ]])</span><br></pre></td></tr></table></figure><p>По выводу текста сгенерированной программы понятна реализация. Символы подчёркивания перед именем функции <code>__::id</code> означают “взять реализацию функции только из текущего модуля” (<a href="https://dascript.org/doc/reference/language/modules.html#module-function-visibility" target="_blank" rel="noopener">линк</a>), идея будет рассмотрена далее.</p><p>Большая часть фич, связанных с generic-функциями, связана с тем, чтобы так или иначе задать или использовать информацию о типах.</p><p><strong><code>auto</code></strong></p><p>Определение для id более развернуто выглядит так:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">id</span><span class="params">(a:<span class="keyword">auto</span>)</span>: <span class="keyword">auto</span></span></span><br><span class="line"><span class="function">    <span class="keyword">return</span> a</span></span><br></pre></td></tr></table></figure></p><p>Такая форма синтаксиса позволяет задать для каждого из выводимых типов псевдоним, который можно использовать для сравнения типа или получения rtti информации. Несколько примеров:</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">//print typename</span></span><br><span class="line"><span class="function">def <span class="title">func</span><span class="params">(a : <span class="keyword">auto</span>(T))</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;typeinfo(typename type&lt;T&gt;)&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//generic sum, a and b must be same type</span></span></span><br><span class="line"><span class="function">def <span class="title">sum</span><span class="params">(a, b : <span class="keyword">auto</span>(T))</span></span></span><br><span class="line">    return a + b</span><br></pre></td></tr></table></figure><p><strong><code>Использование типа в качестве аргумента</code></strong></p><p>Можно передать информацию о типе в качестве аргумента шаблона, как обычный <code>auto</code> аргумент.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//generic linear interpolation between int types via cast to float type</span></span><br><span class="line"><span class="function">def <span class="title">lerpi</span><span class="params">(a, b : <span class="keyword">auto</span>(IntType); part : <span class="keyword">float</span>; tempCastType : <span class="keyword">auto</span>(CastType))</span></span></span><br><span class="line"><span class="function">    <span class="keyword">return</span> <span class="title">IntType</span><span class="params">(CastType(a) + CastType(b - a) * part)</span></span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">"&#123;lerpi(int2(0, 0), int2(4, 4), 0.5f, type&lt;float2&gt;)&#125;\n"</span>)</span> <span class="comment">// (2,2)</span></span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">"&#123;lerpi(int3(1, 2, 3), int3(2, 4, 7), 0.5f, type&lt;float3&gt;)&#125;\n"</span>)</span> <span class="comment">// (1,3,5)</span></span></span><br></pre></td></tr></table></figure><p>Для того, чтобы тип не передавался в runtime, существует макрос <a href="https://github.com/GaijinEntertainment/daScript/blob/master/daslib/templates.das#L41" target="_blank" rel="noopener">template</a>, который в compile-time убирает такие аргументы.</p><p><strong><code>Шаблоны для auto</code></strong></p><p>Различные формы <a href="https://dascript.org/doc/reference/language/generic_programming.html#type-contracts-and-type-operations" target="_blank" rel="noopener">ограчений</a> для типов аргументов auto. Примеры из доки</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">foo</span><span class="params">( a : <span class="keyword">auto</span>&amp;)</span>           <span class="comment">// accepts any type, passed by reference</span></span></span><br><span class="line"><span class="function">def <span class="title">foo</span><span class="params">( a : <span class="keyword">auto</span>[])</span>          <span class="comment">// accepts static array of any type of any size</span></span></span><br><span class="line"><span class="function">def <span class="title">foo</span><span class="params">( a : <span class="built_in">array</span>&lt;<span class="keyword">auto</span> -<span class="keyword">const</span>&gt;)</span>  <span class="comment">// matches any array, with non-const elements</span></span></span><br><span class="line"><span class="function"><span class="comment">//some tests</span></span></span><br><span class="line"><span class="function">def <span class="title">foo</span><span class="params">(a: tuple&lt;<span class="keyword">auto</span>; <span class="keyword">auto</span>; <span class="keyword">auto</span>&gt;)</span> <span class="comment">//tuple of 3 elements, any type</span></span></span><br><span class="line"><span class="function">def <span class="title">foo</span><span class="params">(a: function&lt;(a : <span class="keyword">auto</span>) : <span class="keyword">auto</span>&gt;)</span> <span class="comment">//any function with 1 argument</span></span></span><br><span class="line"><span class="function">def <span class="title">foo</span><span class="params">(a: table&lt;<span class="keyword">int</span>; <span class="keyword">auto</span>&gt;)</span> <span class="comment">//any tables with int keys</span></span></span><br></pre></td></tr></table></figure><p>Еще раз приведу <a href="https://dascript.org/doc/reference/language/functions.html#function-overloading" target="_blank" rel="noopener">ссылку</a> на правила выбора функций при наличии нескольких специализаций и перегрузок.</p><p><strong><code>Контракты</code></strong></p><p>Так же, как и к аргументам обычным функциям, к аргументам generic-функциям могут быть применены контракты, позволяющие в более общем виде описать ограничения для типа аргумента. Именно c generic-функциями видна вся мощь контрактов.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">require daslib/contracts</span><br><span class="line"></span><br><span class="line"><span class="comment">//accept any functions</span></span><br><span class="line">[expect_any_function(a)]</span><br><span class="line"><span class="function">def <span class="title">foo</span><span class="params">(a: <span class="keyword">auto</span>(T))</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;typeinfo(typename type&lt;T&gt;)&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//accept any tuples</span></span></span><br><span class="line">[expect_any_tuple(a)]</span><br><span class="line"><span class="function">def <span class="title">bar</span><span class="params">(a:<span class="keyword">auto</span>(T))</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;typeinfo(typename type&lt;T&gt;)&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">[export]</span><br><span class="line">def main</span><br><span class="line">    foo(@@(a : <span class="keyword">int</span>) =&gt; a)                       <span class="comment">//function&lt;(a:int const):int const&gt; const</span></span><br><span class="line">    foo(@@(a : <span class="keyword">int</span>; b: <span class="keyword">float</span>) =&gt; <span class="string">"hello world"</span>) <span class="comment">//function&lt;(a:int const;b:float const):string const&gt; const</span></span><br><span class="line">    bar([[<span class="keyword">auto</span> <span class="number">1</span> ,<span class="number">2.0f</span>, <span class="string">"test"</span>]])               <span class="comment">//tuple&lt;int;float;string&gt; const</span></span><br><span class="line">    bar([[<span class="keyword">auto</span> <span class="number">1</span>, <span class="number">1</span>]])                          <span class="comment">//tuple&lt;int;int&gt; const</span></span><br></pre></td></tr></table></figure><p>Контракты для одного аргумента могут комбинироваться с помощью операторов !, &amp;&amp;, || и ^^</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">require daslib/contracts</span><br><span class="line"></span><br><span class="line">[expect_any_function(arg) || expect_any_tuple(arg)]</span><br><span class="line"><span class="function">def <span class="title">func_or_tuple</span><span class="params">(var arg : <span class="keyword">auto</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;typeinfo(typename arg)&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//expect_any_array разрешает любые массивы, expect_dim - статические массивы</span></span></span><br><span class="line">[expect_any_array(arg) &amp;&amp; !expect_dim(arg)]</span><br><span class="line"><span class="function">def <span class="title">array_and_notdim</span><span class="params">(var arg : <span class="keyword">auto</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;typeinfo(typename arg)&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">[export]</span><br><span class="line">def main</span><br><span class="line">    func_or_tuple(@@(a : <span class="keyword">int</span>) =&gt; a)</span><br><span class="line">    func_or_tuple([[<span class="keyword">auto</span> <span class="number">1</span>, <span class="number">2.0</span>, <span class="string">"3"</span>]])</span><br><span class="line"></span><br><span class="line">    array_and_notdim([&#123; <span class="keyword">int</span>[] <span class="number">1</span>;<span class="number">2</span>;<span class="number">3</span> &#125;]) <span class="comment">//array&lt;int&gt; allowed</span></span><br><span class="line">    <span class="comment">//array_and_notdim([[ int[] 1;2;3 ]]) //int4[2] not allowed</span></span><br></pre></td></tr></table></figure><p><strong><code>Сумма типов</code></strong></p><p>Еще один способ задать ограничения для типа — перечислить разрешенные типы через символ <code>|</code> (<a href="https://dascript.org/doc/reference/language/generic_programming.html#options" target="_blank" rel="noopener">options</a> в доках):</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">foo</span><span class="params">(var a : <span class="keyword">int</span> | <span class="keyword">float</span> | <span class="built_in">string</span>)</span> <span class="comment">//accept int or float or string</span></span></span><br><span class="line"><span class="function">def <span class="title">foo</span><span class="params">(var a : <span class="built_in">array</span>&lt;<span class="keyword">int</span> | <span class="keyword">float</span>&gt;)</span> <span class="comment">//array of int of array of float</span></span></span><br><span class="line"><span class="function">def <span class="title">foo</span><span class="params">(a : function&lt;(a : <span class="keyword">auto</span>) : <span class="keyword">auto</span>&gt; | function&lt;(a, b : <span class="keyword">auto</span>) : <span class="keyword">auto</span>&gt;)</span> <span class="comment">//accept any function with 1 or 2 arguments</span></span></span><br><span class="line"><span class="function">def <span class="title">foo</span> <span class="params">(a : Bar <span class="keyword">explicit</span> | Foo)</span>   <span class="comment">// accept exactly Bar or anything inherited from Foo</span></span></span><br><span class="line"><span class="function">def <span class="title">foo</span> <span class="params">(a : Foo | #)</span> <span class="comment">//accept Foo and Foo#, looks like this short syntax only works with #</span></span></span><br></pre></td></tr></table></figure><p>Порядок проверки соответствия опций — слева направо:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">foo</span><span class="params">(var a : <span class="keyword">auto</span> | <span class="keyword">int</span>&amp;)</span> </span>&#123; a = <span class="number">84</span>; &#125;</span><br><span class="line"><span class="function">def <span class="title">bar</span><span class="params">(var a : <span class="keyword">int</span>&amp; | <span class="keyword">auto</span>)</span> </span>&#123; a = <span class="number">42</span>; &#125;</span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main</span><br><span class="line">    var a: <span class="keyword">int</span></span><br><span class="line">    foo(a) <span class="comment">// match foo(auto)</span></span><br><span class="line">    print(<span class="string">"&#123;a&#125;\n"</span>) <span class="comment">// a == 0</span></span><br><span class="line">    bar(a) <span class="comment">// match bar(int&amp;)</span></span><br><span class="line">    print(<span class="string">"&#123;a&#125;\n"</span>) <span class="comment">// a == 42</span></span><br></pre></td></tr></table></figure><p><strong><code>static_if</code></strong></p><p>Проверка наличия методов или полей структуры выполняется в момент инстанцирования generic-функции</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span></span></span><br><span class="line"><span class="class">    <span class="title">a</span> :</span> <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">foo</span><span class="params">(var s)</span></span></span><br><span class="line">    s.a = 42 //not check if s has field</span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main</span><br><span class="line">    var s : S</span><br><span class="line">    foo(s) <span class="comment">//ok</span></span><br></pre></td></tr></table></figure><p>Ошибка возникнет только в момент инстанциирования <code>foo</code> со структурой, не имеющей поля <code>a</code>. Проверить наличие полей или другую информацию о типе в время компиляции можно с помощью оператора <code>static_if</code>:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span></span></span><br><span class="line"><span class="class">    <span class="title">a</span> :</span> <span class="keyword">int</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">T</span></span></span><br><span class="line"><span class="class">    <span class="title">a</span> :</span> float4</span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">foo</span><span class="params">(var s)</span></span></span><br><span class="line"><span class="function">    static_if <span class="title">typeinfo</span><span class="params">(has_field&lt;a&gt; s)</span> &amp;&amp; <span class="params">(typeinfo(<span class="keyword">typename</span> s.a) == typeinfo(<span class="keyword">typename</span> type&lt;<span class="keyword">int</span> -<span class="keyword">const</span>&gt;))</span></span></span><br><span class="line">        s.a = 42</span><br><span class="line"></span><br><span class="line">var s : S</span><br><span class="line">foo(s) <span class="comment">//ok</span></span><br><span class="line">var t: T</span><br><span class="line">foo(t) <span class="comment">//also ok, but do nothing</span></span><br></pre></td></tr></table></figure><p><strong><code>Вызываемые макросы</code></strong></p><p>Более сложные конструкции вроде “вызвать конструктор того же типа, что и поле структуры <code>s.a</code> можно выразить с помощью макросов</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//generics macro</span></span><br><span class="line"><span class="keyword">module</span> generics_macro shared <span class="keyword">private</span></span><br><span class="line"></span><br><span class="line">[call_macro(name=<span class="string">"convert_to"</span>)]  <span class="comment">// convert_to(convertType, arg)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApplyMacro</span> :</span> AstCallMacro</span><br><span class="line">    <span class="comment">//! convert_to("float4", 42) -&gt; float4(42)</span></span><br><span class="line">    <span class="function">def <span class="keyword">override</span> <span class="title">visit</span> <span class="params">( prog:ProgramPtr; mod:Module?; var expr:smart_ptr&lt;ExprCallMacro&gt; )</span> : ExpressionPtr</span></span><br><span class="line">        var exprConstStr &lt;- unsafe(reinterpret&lt; smart_ptr&lt;ast::ExprConstString&gt;&amp;&gt; expr.arguments[0])</span><br><span class="line">        var call &lt;- <span class="keyword">new</span> [[ExprCall() name:=exprConstStr.value, at=expr.at]]</span><br><span class="line">        emplace_new(call.arguments, clone_expression(expr.arguments[<span class="number">1</span>]))</span><br><span class="line">        <span class="keyword">return</span> &lt;- call</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">require generics_macro</span><br><span class="line"></span><br><span class="line">def foo(var s)</span><br><span class="line">    static_if typeinfo(has_field&lt;a&gt; s)</span><br><span class="line">        static_if typeinfo(has_field&lt;a&gt; s)</span><br><span class="line">            static_if typeinfo(<span class="keyword">typename</span> s.a) == typeinfo(<span class="keyword">typename</span> type&lt;<span class="keyword">int</span> -<span class="keyword">const</span>&gt;)</span><br><span class="line">                s.a = <span class="number">42</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                s.a = convert_to(typeinfo(<span class="keyword">typename</span> s.a), <span class="number">42</span>) <span class="comment">// --&gt; s.a = float4(42)</span></span><br><span class="line"></span><br><span class="line">var t : T</span><br><span class="line">foo(t)</span><br><span class="line">print(<span class="string">"&#123;t&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Output:</span></span><br><span class="line">[[ <span class="number">42</span>,<span class="number">42</span>,<span class="number">42</span>,<span class="number">42</span>]]</span><br></pre></td></tr></table></figure><p><strong><code>[generic]</code></strong></p><p>daScript распознаёт обычные или generic-функции по синтаксису, но можно также явно обозначить функцию как generic:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">options <span class="built_in">log</span>=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">[generic]</span><br><span class="line">def func()</span><br><span class="line">    print(<span class="string">"hello"</span>)</span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main</span><br><span class="line">    func()</span><br><span class="line"></span><br><span class="line"><span class="comment">//Output:</span></span><br><span class="line"></span><br><span class="line">def <span class="keyword">private</span> `func</span><br><span class="line">        print(<span class="string">"hello"</span>,__context__)</span><br><span class="line"></span><br><span class="line"><span class="comment">// [modify_external]</span></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def <span class="keyword">public</span> main</span><br><span class="line">        __::`func()</span><br></pre></td></tr></table></figure><p>В таком случае вызов <code>func</code> будет преобразован в <code>__::</code>func` - вызов версии функции только из текущего модуля. Это используется в <a href="https://github.com/GaijinEntertainment/daScript/blob/87ab585fc3704896bff3eea71ab87e29f772be94/src/builtin/fio.das#L10" target="_blank" rel="noopener">некоторых функциях</a> стандартной библиотеки daslib, потому что если компилятор знает, что функция находится в том же модуле, что и вызывающий код, то может её оптимизировать — при AoT-компиляции генериуется не полноценный вызов через ABI (который может вести в другой не-AoT daScript модуль), а прямой вызов, что быстрее.</p><p><strong><code>[instance_function]</code></strong></p><p>С помощью макроса <code>[instance_function]</code> можно попросить явно специализировать generic-функцию с определенными типами:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">require daslib/instance_function</span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">func</span><span class="params">(a : <span class="keyword">auto</span>(TT))</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;typeinfo(typename a )&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">[instance_function(func, TT = "int const")]</span><br><span class="line"><span class="function">def <span class="title">print_int</span><span class="params">(a)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main</span><br><span class="line">    print_int(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><strong><code>Видимость модулей</code></strong></p><p>Для generic функций, которые подразумевают переопределение для новых кастомных типов в других модулях, необходимо добавлять префикс <code>_::</code> или <code>__::</code>, чтобы обозначить, что функций должна искаться в том модуле, который её вызывает.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//module1.das</span></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line"><span class="function">def <span class="title">call_func</span><span class="params">(a)</span></span></span><br><span class="line"><span class="function">    <span class="title">_::func</span><span class="params">(a)</span> <span class="comment">//func will be declared somewhere later</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//main.das</span></span></span><br><span class="line"><span class="function">require module1</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">struct S</span></span><br><span class="line"><span class="function">    a: <span class="keyword">int</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">def <span class="title">func</span><span class="params">(s: S)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;s&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">call_func</span><span class="params">(s)</span> <span class="comment">//module1::call_func will see and call main::func()</span></span></span><br></pre></td></tr></table></figure><p><code>__::</code> — подразумевает возможность определения функции только в том же модуле, что и вызывающий код (main)<br><code>_::</code> — допускает определение как в том же модуле, что и вызывающий код, так и в других модулях (main, module1 или другие модули)</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;Обобщенное
      
    
    </summary>
    
    
    
      <category term="dascript" scheme="http://spiiin.github.io/tags/dascript/"/>
    
  </entry>
  
  <entry>
    <title>daScript: ООП и всякое</title>
    <link href="http://spiiin.github.io/blog/1023396573/"/>
    <id>http://spiiin.github.io/blog/1023396573/</id>
    <published>2023-01-12T17:20:25.000Z</published>
    <updated>2023-01-21T12:26:52.990Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><h1 id="Структуры"><a href="#Структуры" class="headerlink" title="Структуры"></a>Структуры</h1><h2 id="Структуры-daScript-наследование"><a href="#Структуры-daScript-наследование" class="headerlink" title="Структуры daScript, наследование"></a>Структуры daScript, наследование</h2><p><a href="https://dascript.org/doc/reference/language/structs.html#struct-declaration" target="_blank" rel="noopener">https://dascript.org/doc/reference/language/structs.html#struct-declaration</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">V2</span></span></span><br><span class="line"><span class="class">    <span class="title">x</span> :</span> <span class="keyword">float</span> = <span class="number">-1.0f</span></span><br><span class="line">    y : <span class="keyword">float</span></span><br><span class="line"></span><br><span class="line">struct V3: V2</span><br><span class="line">    z = <span class="number">3.0f</span></span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main</span><br><span class="line">    let a : V3</span><br><span class="line">    print(<span class="string">"a = &#123;a&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line">    let b = V3()</span><br><span class="line">    print(<span class="string">"b = &#123;b&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line">    let c = [[V3 y = <span class="number">2.0f</span>]]</span><br><span class="line">    print(<span class="string">"c = &#123;c&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line">    let d = [[V3() y = <span class="number">2.0f</span>]]</span><br><span class="line">    print(<span class="string">"d = &#123;d&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line">    let e = [[V3() y = <span class="number">2.0f</span>, x = <span class="number">1.0f</span>]]</span><br><span class="line">    print(<span class="string">"e = &#123;e&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    let pd = <span class="keyword">new</span> [[V3() y = <span class="number">2.0f</span>]]</span><br><span class="line">    print(<span class="string">"pd = &#123;pd&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Output:</span></span><br><span class="line">a = [[ <span class="number">0.000000000</span>; <span class="number">0.000000000</span>; <span class="number">0.000000000</span>]]</span><br><span class="line">b = [[ <span class="number">-1.000000000</span>; <span class="number">0.000000000</span>; <span class="number">3.000000000</span>]]</span><br><span class="line">c = [[ <span class="number">0.000000000</span>; <span class="number">2.000000000</span>; <span class="number">0.000000000</span>]]</span><br><span class="line">d = [[ <span class="number">-1.000000000</span>; <span class="number">2.000000000</span>; <span class="number">3.000000000</span>]]</span><br><span class="line">e = [[ <span class="number">1.000000000</span>; <span class="number">2.000000000</span>; <span class="number">3.000000000</span>]]</span><br><span class="line">pd = [[ <span class="number">-1.000000000</span>; <span class="number">2.000000000</span>; <span class="number">3.000000000</span>]]</span><br></pre></td></tr></table></figure><p>a,b,c,d,e - структуры, размещенные на стеке. В зависимости от способа объявления можно пропускать инициализацию полей по умолчанию — круглые скобки в объявлении добавляют код инициализации (в порядке от родительской структуры к дочерним). Синтаксис с квадратными скобками позволяет изменить значения отдельных полей. Неинициализированные явно или по умолчанию поля инициализируются нулями — получить в качестве значений неинициализированный мусор нельзя.</p><p>Ещё несколько примеров комбинаций синтаксиса инициализации, в первом случае создаётся структура, во втором — массив структур, в третьем — итератор<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//where clause: post init function</span></span><br><span class="line">let f = [[V3 where $(var self) &#123;</span><br><span class="line">    self.x = <span class="number">11.0f</span>;</span><br><span class="line">    self.y = <span class="number">11.0f</span>;</span><br><span class="line">    self.z = <span class="number">11.0f</span>;</span><br><span class="line">&#125;]]</span><br><span class="line"></span><br><span class="line"><span class="comment">//array initialization, g_arr: V3[2]</span></span><br><span class="line">let g_arr = [[V3 </span><br><span class="line">    x=<span class="number">1.0f</span>, y=<span class="number">1.0f</span>, z=<span class="number">1.0f</span>;</span><br><span class="line">    x=<span class="number">2.0f</span>, y=<span class="number">2.0f</span>, z=<span class="number">2.0f</span></span><br><span class="line">]]</span><br><span class="line"></span><br><span class="line"><span class="comment">//array comprehesion, h_arr : iterator&lt;V3&gt;</span></span><br><span class="line">let h_iter &lt;- [[ <span class="keyword">for</span> i in range(<span class="number">0</span>, <span class="number">10</span>); [[V3 x=<span class="keyword">float</span>(i), y=<span class="keyword">float</span>(i), z=<span class="keyword">float</span>(i)]]; where (i&amp;<span class="number">1</span>)==<span class="number">1</span> ]]</span><br><span class="line">let g_iter &lt;- [[ <span class="keyword">for</span> i in range(<span class="number">0</span>, <span class="number">10</span>); invoke(&#123; let fi = <span class="keyword">float</span>(i); <span class="keyword">return</span> [[V3 x=fi, y=fi, z=fi]]; &#125;); where (i&amp;<span class="number">1</span>)==<span class="number">1</span> ]] <span class="comment">// same</span></span><br></pre></td></tr></table></figure></p><p>pd - указатель на структуру, размещенную в куче. Сама структура может быть инициализирована любым из перечисленных выше способов.</p><h2 id="Финализаторы"><a href="#Финализаторы" class="headerlink" title="Финализаторы"></a>Финализаторы</h2><p><a href="https://dascript.org/doc/reference/language/finalizers.html#finalizers" target="_blank" rel="noopener">https://dascript.org/doc/reference/language/finalizers.html#finalizers</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var d = [[V3() y = <span class="number">2.0f</span>]]</span><br><span class="line">print(<span class="string">"d = &#123;d&#125;\n"</span>)</span><br><span class="line"><span class="keyword">delete</span> d</span><br><span class="line">print(<span class="string">"d = &#123;d&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line">var pd = <span class="keyword">new</span> [[V3() y = <span class="number">2.0f</span>]]</span><br><span class="line">print(<span class="string">"pd = &#123;pd&#125;\n"</span>)</span><br><span class="line">unsafe &#123; <span class="keyword">delete</span> pd; &#125;</span><br><span class="line">print(<span class="string">"pd = &#123;pd&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Output</span></span><br><span class="line">d = [[ <span class="number">-1.000000000</span>; <span class="number">2.000000000</span>; <span class="number">3.000000000</span>]]</span><br><span class="line">d = [[ <span class="number">0.000000000</span>; <span class="number">0.000000000</span>; <span class="number">0.000000000</span>]]</span><br><span class="line">pd = [[ <span class="number">-1.000000000</span>; <span class="number">2.000000000</span>; <span class="number">3.000000000</span>]]</span><br><span class="line">pd = null</span><br></pre></td></tr></table></figure><p>Финализатор по умолчанию для структуры зануляет память (в порядке от потомков к родителям, при необходимости зовёт финализаторы для членов структуры в порядке объявления). Для указателей — после зануления полей структуры дополнительно меняет адрес указателя на null. Финализаторы для структур и классов зовутся вручную. Финализаторы не освобождают память, на которую указывает объект.</p><h2 id="Освобождение-памяти"><a href="#Освобождение-памяти" class="headerlink" title="Освобождение памяти"></a>Освобождение памяти</h2><p>Модель памяти по умолчанию в daScript не подразумевает очистки памяти в ходе выполнения скрипта, за очистку отвечает хост-приложение, которое может просто освободить всю память контекста целиком — пересоздание контекстов by design быстро и эффективно, так что такой способ предпочтительный.</p><p>Но можно настроить поведение контекста опцией <code>persistent_heap</code>:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">options persistent_heap = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">var pd = <span class="keyword">new</span> [[V3() y = <span class="number">2.0f</span>]]</span><br><span class="line">var pd2 = pd</span><br><span class="line">unsafe</span><br><span class="line">    print(<span class="string">"addr(pd) = &#123;reinterpret&lt;uint&gt;(pd)&#125;\n"</span>)</span><br><span class="line">    print(<span class="string">"addr(pd2) = &#123;reinterpret&lt;uint&gt;(pd2)&#125;\n"</span>)</span><br><span class="line">    <span class="keyword">delete</span> pd</span><br><span class="line">pd2.x = <span class="number">33.0f</span></span><br><span class="line">print(<span class="string">"pd2 = &#123;pd2&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Output</span></span><br><span class="line">addr(pd) = <span class="number">0xf1909e10</span></span><br><span class="line">addr(pd2) = <span class="number">0xf1909e10</span></span><br><span class="line">pd2 = [[ <span class="number">33.000000000</span>; <span class="number">-431602080.000000000</span>; <span class="number">-431602080.000000000</span>]] <span class="comment">//мусор</span></span><br></pre></td></tr></table></figure><p>Я включил опцию <code>DAS_SANITIZER</code> при сборке daScript, чтобы после освобождения объектов в случае с persistent_heap память перезаписывалась мусорными значениями (0xCD, -431602080 если интерпретировать 0xCDCDCDCD как float-значение). В данном случае программа по счастливому стечению обстоятельств не упала, но благодаря санитайзеру видно, что указатель pd2 после удаления pd стал висячим — указывает на свободную память, которая могла бы быть выделена другому объекту (объекту daScript того же контекста в случае <code>persistent_heap=false</code>, или любому другому объекту хост-приложения с <code>persistent_heap=true</code>).</p><p>Более “злобный” вариант примера:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var pd = <span class="keyword">new</span> [[V3() y = <span class="number">2.0f</span>]]</span><br><span class="line">var pd2 = pd</span><br><span class="line">unsafe &#123; <span class="keyword">delete</span> pd; &#125;</span><br><span class="line">var pd3 = <span class="keyword">new</span> [[V3() x = <span class="number">33.0f</span>, y = <span class="number">33.0f</span>, z = <span class="number">33.0f</span>]]</span><br><span class="line">pd2.x = <span class="number">-100.0f</span> <span class="comment">// &lt;----- kaboom!</span></span><br><span class="line">print(<span class="string">"pd2 = &#123;pd2&#125;\n"</span>)</span><br><span class="line">print(<span class="string">"pd3 = &#123;pd3&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Output</span></span><br><span class="line">pd2 = [[ <span class="number">-100.000000000</span>; <span class="number">33.000000000</span>; <span class="number">33.000000000</span>]]</span><br><span class="line">pd3 = [[ <span class="number">-100.000000000</span>; <span class="number">33.000000000</span>; <span class="number">33.000000000</span>]]</span><br></pre></td></tr></table></figure><br>После освобождения память на которую указывали pd и pd2 была повторно отдана новому объекту, на который указывает pd3. Этот объект теперь может поменяться через указатель pd2. Должно быть понятно, насколько unsafe операция удаления — код стал насколько же опасным (но и настолько же быстрым), как и код на языке си.</p><h2 id="Кастомные-финализаторы"><a href="#Кастомные-финализаторы" class="headerlink" title="Кастомные финализаторы"></a>Кастомные финализаторы</h2><p>Финализатор можно переопределить, пример: финализатор для структуры V2</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">finalize</span><span class="params">(var v : V2)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"kill V2 &#123;v&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">var d </span>= [[ V3 x = <span class="number">11.0f</span>, y = <span class="number">22.0f</span>, z = <span class="number">33.0f</span>]]</span><br><span class="line"><span class="keyword">delete</span> d</span><br><span class="line">print(<span class="string">"d = &#123;d&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Output</span></span><br><span class="line">kill V2 [[ <span class="number">11.000000000</span>; <span class="number">22.000000000</span>]]</span><br><span class="line">d = [[ <span class="number">11.000000000</span>; <span class="number">22.000000000</span>; <span class="number">33.000000000</span>]]</span><br></pre></td></tr></table></figure><p>Вместо финализатора зануления по умолчанию вызывается функция, логгирующая поле. Также можно заметить неочевидную вещь (если думать о финализаторах как о деструкторах, но лучше не думать) — финализаторы не зовутся в порядке от потомков к предкам, а как работают как обычные функции, daScript нашёл подходящую функцию, принимающую тип V2, и не вызвал зануления также и у поля z - т.е. финализатор родительской структуры “подошёл” к дочерней.</p><p>Более похожий на порядок вызова деструкторов в C/C++ код<br><blockquote><p>(<strong>ещё раз, финализаторы — это не деструкторы, они вызываются только при явном вызове оператора delete!</strong>)</p></blockquote></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">finalize</span><span class="params">(var v : V2 <span class="keyword">explicit</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"kill V2 &#123;v&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">def <span class="title">finalize</span><span class="params">(var v : V3 <span class="keyword">explicit</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">finalize</span><span class="params">(cast&lt;V2&gt; v)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"kill V3 &#123;v&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">[export]</span><br><span class="line">def main</span><br><span class="line">    var d = [[ V3 x = <span class="number">11.0f</span>, y = <span class="number">22.0f</span>, z = <span class="number">33.0f</span>]]</span><br><span class="line">    <span class="keyword">delete</span> d</span><br><span class="line">    print(<span class="string">"d = &#123;d&#125;\n"</span>)</span><br><span class="line"><span class="comment">//Output</span></span><br><span class="line">kill V2 [[ <span class="number">11.000000000</span>; <span class="number">22.000000000</span>]]</span><br><span class="line">kill V3 [[ <span class="number">11.000000000</span>; <span class="number">22.000000000</span>; <span class="number">33.000000000</span>]]</span><br><span class="line">d = [[ <span class="number">11.000000000</span>; <span class="number">22.000000000</span>; <span class="number">33.000000000</span>]]</span><br></pre></td></tr></table></figure><p>daScript не позволяет каст к дочерним типам <code>explicit</code>-аргументов.</p><p>Вместо перегрузки <code>finalize</code> можно перегрузить <code>def operator delete(var v : V2 explicit)</code> — семантически более точно описывает, что для структур код финализатора будет вызван только в момент явного вызова оператора <code>delete</code>.</p><h2 id="Методы"><a href="#Методы" class="headerlink" title="Методы"></a>Методы</h2><p>Методы не могут быть объявлены при объявлении структур, но структуры могут хранить указатели на функции</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">V2</span></span></span><br><span class="line"><span class="class">    <span class="title">x</span> :</span> <span class="keyword">float</span></span><br><span class="line">    y : <span class="keyword">float</span></span><br><span class="line">    <span class="built_in">set</span> = @@<span class="built_in">set</span></span><br><span class="line"></span><br><span class="line">var a = V2()</span><br><span class="line">a |&gt; <span class="built_in">set</span>(<span class="number">1.0f</span>, <span class="number">2.0f</span>) <span class="comment">//call function via pipe syntax</span></span><br><span class="line">invoke(a.<span class="built_in">set</span>, a, <span class="number">1.0f</span>, <span class="number">2.0f</span>)  <span class="comment">// exactly same thing as above</span></span><br><span class="line">a-&gt;<span class="built_in">set</span>(<span class="number">1.0f</span>, <span class="number">2.0f</span>)  <span class="comment">// this one can call something else, if overridden in derived class.</span></span><br></pre></td></tr></table></figure><p>Потомок может переопределить функцию</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">V2</span></span></span><br><span class="line"><span class="class">    <span class="title">x</span> :</span> <span class="keyword">float</span></span><br><span class="line">    y : <span class="keyword">float</span></span><br><span class="line">    <span class="built_in">set</span> = @@<span class="built_in">set</span></span><br><span class="line">struct V3: V2</span><br><span class="line">    z : <span class="keyword">float</span></span><br><span class="line">    <span class="keyword">override</span> <span class="built_in">set</span> = cast&lt;<span class="keyword">auto</span>&gt; @@set_v3</span><br><span class="line">    </span><br><span class="line">def <span class="built_in">set</span>(var thisV: V2; X, Y: <span class="keyword">float</span>)</span><br><span class="line">    with thisV</span><br><span class="line">        x = X</span><br><span class="line">        y = Y</span><br><span class="line"></span><br><span class="line">def set_v3(var thisV: V3; X, Y: <span class="keyword">float</span>)</span><br><span class="line">    <span class="built_in">set</span>(cast&lt;V2&gt; thisV, X, Y)</span><br><span class="line">    with thisV</span><br><span class="line">        z = <span class="number">3.0f</span></span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main</span><br><span class="line">    var a = V3()</span><br><span class="line">    a |&gt; set_v3(<span class="number">1.0f</span>, <span class="number">2.0f</span>) <span class="comment">//non virtual call</span></span><br><span class="line">    invoke(a.<span class="built_in">set</span>, a, <span class="number">1.0f</span>, <span class="number">2.0f</span>)  <span class="comment">// exactly same thing as above</span></span><br><span class="line">    a-&gt;<span class="built_in">set</span>(<span class="number">1.0f</span>, <span class="number">2.0f</span>)  <span class="comment">// this one can call something else, if overridden in derived class.</span></span><br></pre></td></tr></table></figure><p>(<a href="https://github.com/GaijinEntertainment/daScript/blob/master/examples/test/unit_tests/override.das" target="_blank" rel="noopener">https://github.com/GaijinEntertainment/daScript/blob/master/examples/test/unit_tests/override.das</a>)</p><p>daScript позволяет создать две перегрузки функции set (а не определять дополнительное имя <code>set_v3</code>), принимающие V2 и V3, тогда можно переписать пример без использования дополнительного имени, с уточнением типа функции set перед кастом и последующим автоматическим приведением этого указателя к правильному типу, определённому в V2:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">V2</span></span></span><br><span class="line"><span class="class">    <span class="title">x</span> :</span> <span class="keyword">float</span></span><br><span class="line">    y : <span class="keyword">float</span></span><br><span class="line">    <span class="built_in">set</span> = @@&lt;(var thisV: V2; X, Y: <span class="keyword">float</span>):<span class="keyword">void</span>&gt; <span class="built_in">set</span></span><br><span class="line">struct V3: V2</span><br><span class="line">    z : <span class="keyword">float</span></span><br><span class="line">    <span class="keyword">override</span> <span class="built_in">set</span> = cast&lt;<span class="keyword">auto</span>&gt; @@&lt;(var thisV: V3; X, Y: <span class="keyword">float</span>):<span class="keyword">void</span>&gt; <span class="built_in">set</span> <span class="comment">//&lt;------ cast</span></span><br><span class="line">    </span><br><span class="line">def <span class="built_in">set</span>(var thisV: V2 <span class="keyword">explicit</span>; X, Y: <span class="keyword">float</span>)</span><br><span class="line">    with thisV</span><br><span class="line">        x = X</span><br><span class="line">        y = Y</span><br><span class="line"></span><br><span class="line">def <span class="built_in">set</span>(var thisV: V3; X, Y: <span class="keyword">float</span>)</span><br><span class="line">    <span class="built_in">set</span>(cast&lt;V2&gt; thisV, X, Y)</span><br><span class="line">    with thisV</span><br><span class="line">        z = <span class="number">3.0f</span></span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main</span><br><span class="line">    var a = V3()</span><br><span class="line">    a |&gt; <span class="built_in">set</span>(<span class="number">1.0f</span>, <span class="number">2.0f</span>) <span class="comment">//virtual call</span></span><br><span class="line">    invoke(a.<span class="built_in">set</span>, a, <span class="number">1.0f</span>, <span class="number">2.0f</span>)  <span class="comment">// exactly same thing as above</span></span><br><span class="line">    a-&gt;<span class="built_in">set</span>(<span class="number">1.0f</span>, <span class="number">2.0f</span>)</span><br><span class="line">    print(<span class="string">"&#123;a&#125;\n"</span>)</span><br></pre></td></tr></table></figure><p>Здесь <code>explicit</code> в первом объявлении свободной функции <code>set</code> позволяет сделать некоторую магию — несмотря на то, что эта функция “пропускает” только указатели на V2, это позволяет однозначно выделить эту функцию в приведении <code>set = @@&lt;(var thisV: V2; X, Y: float):void&gt; set</code> среди двух прегруженных (иначе возникла бы неоднозначность — обе приводились бы с одинаковым приоритетом, и daScript выдавал бы ошибку). Но при этом сигнатура функции <code>V2&#39;set</code> уже не содержит этого <code>explicit</code> (её тип выводится автоматически по правой части выражения, где явно указана сигнатура без <code>explicit</code>). Таким образом <code>V2&#39;set</code> работает как виртуальная функция — может принимать первым аргументом как <code>V2</code>, так и её потомков, которые не переопределили функцию.</p><h1 id="Классы"><a href="#Классы" class="headerlink" title="Классы"></a>Классы</h1><p><a href="https://dascript.org/doc/reference/language/classes.html#classes" target="_blank" rel="noopener">https://dascript.org/doc/reference/language/classes.html#classes</a></p><p>Классы в daScript — это структуры “на стероидах”. Немного отличий:</p><ul><li>Класс может быть отнаследован от структуры, но структура не может быть унаследована от класса (связано с тем, что классы могут иметь инициализаторы)</li><li>Объявление локального класса на стеке небезопасно (требует явного unsafe)</li></ul><p>Методы <a href="https://dascript.org/doc/reference/language/structs.html#structure-function-members" target="_blank" rel="noopener">реализованы</a> как указатели на функции, но с возможностью объявлять их в теле класса и переопределять с помощью ключевого слова <code>override</code> без явного каста типа метода, как было со структурами</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">V2</span></span></span><br><span class="line"><span class="class">    <span class="title">x</span> :</span> <span class="keyword">float</span></span><br><span class="line">    y : <span class="keyword">float</span></span><br><span class="line">    <span class="function">def <span class="title">set</span><span class="params">(X, Y: <span class="keyword">float</span>)</span></span></span><br><span class="line"><span class="function">        x </span>= X</span><br><span class="line">        y = Y</span><br><span class="line">class V3: V2</span><br><span class="line">    z : <span class="keyword">float</span></span><br><span class="line">    def <span class="keyword">override</span> <span class="built_in">set</span>(X, Y: <span class="keyword">float</span>)</span><br><span class="line">        V2`<span class="built_in">set</span>(self, X, Y)</span><br><span class="line">        z = <span class="number">3.0f</span></span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main</span><br><span class="line">    var a = <span class="keyword">new</span> V3()</span><br><span class="line">    a-&gt;<span class="built_in">set</span>(<span class="number">1.0f</span>, <span class="number">2.0f</span>) <span class="comment">//V3`set(*a, 1.0f, 2.0f)</span></span><br><span class="line">    print(<span class="string">"a = &#123;a&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Output</span></span><br><span class="line">a = [[ <span class="number">0x29990d19b90</span>; V3<span class="number">'</span>__finalize<span class="comment">/*V3'__finalize S&lt;::V3&gt;*/</span>; <span class="number">1.000000000</span>; <span class="number">2.000000000</span>; V3`<span class="built_in">set</span><span class="comment">/*V3`set S&lt;::V3&gt; Cf Cf*/</span>; <span class="number">3.000000000</span>]]</span><br></pre></td></tr></table></figure><p>Можно заметить, что имя объявленной внутри класса-функции манглится с помощью префикса-имени класса (<code>set -&gt; V2&#39;set</code>). Также внутри метода доступен указатель <code>self</code>, неявно передаваемый первым аргументов в методы класса.</p><p>Стоит более детально рассмотреть вывод результата.</p><h2 id="Порядок-полей-объекта-в-памяти"><a href="#Порядок-полей-объекта-в-памяти" class="headerlink" title="Порядок полей объекта в памяти"></a>Порядок полей объекта в памяти</h2><p><a href="https://dascript.org/doc/reference/language/classes.html#implementation-details" target="_blank" rel="noopener">https://dascript.org/doc/reference/language/classes.html#implementation-details</a></p><p>Содержимое <code>a</code>:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; [[</span><br><span class="line">    0x29990d19b90; &#x2F;&#x2F;указатель на rtti информацию</span><br><span class="line">    V3&#39;__finalize&#x2F;*V3&#39;__finalize S&lt;::V3&gt;*&#x2F;;  &#x2F;&#x2F;указатель на функцию-финализатор</span><br><span class="line">    1.000000000; &#x2F;&#x2F;x</span><br><span class="line">    2.000000000; &#x2F;&#x2F;y</span><br><span class="line">    V3&#96;set&#x2F;*V3&#96;set S&lt;::V3&gt; Cf Cf*&#x2F;; &#x2F;&#x2F;указатель на виртуальную функцию set</span><br><span class="line">    3.000000000 &#x2F;&#x2F;z</span><br><span class="line">]]</span><br></pre></td></tr></table></figure></p><p>Комментарии после имён функций — замангленное имя функции и её сигнатуры (аргументы и результаты). </p><blockquote><p>Расположение в памяти серьёзно отличается от C++ — указатели на виртуальные функции хранятся не в отдельной таблице (vtable), а в каждом объекте класса в том порядке, в котором были объявлены функции. Это позволяет убрать один уровень индирекции при вызове функций (не нужно идти за адресом в виртуальную таблицу) и изменять адреса функций динамически для каждого отдельного объекта, но увеличивает расходы памяти на хранение указателей, и также может повлиять на выравнивание и padding между полями.</p></blockquote><p>Тем не менее, для модификации порядка данных структур возможно написать собственный макрос, который будет хранить функции в самостоятельно сгенерированной таблице или выносить указатели на функции в конец структуры.<br><a href="/blog/1547564887/" title="daScript macro">daScript macro</a> — пример макроса перестановки порядка полей при определении структур</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">    unsafe</span><br><span class="line">        print(</span><br><span class="line"><span class="string">"\nsizeof(a) = &#123;typeinfo(sizeof type&lt;V3&gt;)&#125;\n</span></span><br><span class="line"><span class="string">offset __rtti      = &#123;typeinfo(offsetof&lt;__rtti&gt; type&lt;V3&gt;)&#125; &#123;reinterpret&lt;uint&gt;  addr(a.__rtti)&#125; </span></span><br><span class="line"><span class="string">offset __finalize  = &#123;typeinfo(offsetof&lt;__finalize &gt; type&lt;V3&gt;)&#125; &#123;reinterpret&lt;uint&gt;  addr(a.__finalize )&#125; </span></span><br><span class="line"><span class="string">offset x           = &#123;typeinfo(offsetof&lt;x&gt; type&lt;V3&gt;)&#125; &#123;reinterpret&lt;uint&gt;  addr(a.x)&#125;</span></span><br><span class="line"><span class="string">offset y           = &#123;typeinfo(offsetof&lt;y&gt; type&lt;V3&gt;)&#125; &#123;reinterpret&lt;uint&gt; addr(a.y)&#125;</span></span><br><span class="line"><span class="string">offset set         = &#123;typeinfo(offsetof&lt;set&gt; type&lt;V3&gt;)&#125; &#123;reinterpret&lt;uint&gt; addr(a.set)&#125;</span></span><br><span class="line"><span class="string">offset z           = &#123;typeinfo(offsetof&lt;z&gt; type&lt;V3&gt;)&#125; &#123;reinterpret&lt;uint&gt; addr(a.z)&#125;\n"</span></span><br><span class="line">        )</span><br><span class="line">Output:</span><br><span class="line"><span class="keyword">sizeof</span>(a) = <span class="number">40</span></span><br><span class="line">offset __rtti      = <span class="number">0</span>  <span class="number">0x4adb5f80</span></span><br><span class="line">offset __finalize  = <span class="number">8</span>  <span class="number">0x4adb5f88</span></span><br><span class="line">offset x           = <span class="number">16</span> <span class="number">0x4adb5f90</span></span><br><span class="line">offset y           = <span class="number">20</span> <span class="number">0x4adb5f94</span></span><br><span class="line">offset set1        = <span class="number">24</span> <span class="number">0x4adb5f98</span></span><br><span class="line">offset z           = <span class="number">32</span> <span class="number">0x4adb5fa0</span></span><br></pre></td></tr></table></figure><p>Существует также макрос <code>[cpp_layout]</code>, который не меняет порядок членов класса/структуры, но добавляет дополнительное правило выравнивания, как делают С/C++ — в конце родительской структуры будет оставлено пространство для её выравнивания по максимальному выравниванию членов структуры — например, если добавить в конце V2 поле на 4 байта <code>padding: uint8[4]</code>, то из-за выравнивания структуры в 8 байт (из-за указателей на 64-битной платформе), поле z, будет добавлено с отступом в 8 байт (без макроса daScript без проблем “встраивает” это поле сразу за 4-байтным отступом).</p><h2 id="Переопределение-метода-в-экземпляре-класса"><a href="#Переопределение-метода-в-экземпляре-класса" class="headerlink" title="Переопределение метода в экземпляре класса"></a>Переопределение метода в экземпляре класса</h2><p>Как было замеченно выше, каждый экземпляр класса/структуры хранит собственные копии указателей на функции, так что можно переопределить метод не на уровне класса-потомка, а в экземпляре класса (в пост-инициализаторе, или в любой момент после создания):<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">V2</span></span></span><br><span class="line"><span class="class">    <span class="title">x</span> :</span> <span class="keyword">float</span></span><br><span class="line">    y : <span class="keyword">float</span></span><br><span class="line">    <span class="function">def <span class="title">set</span><span class="params">(X, Y: <span class="keyword">float</span>)</span></span></span><br><span class="line"><span class="function">        x </span>= X</span><br><span class="line">        y = Y</span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main</span><br><span class="line">    let fn &lt;- @@ &lt;| ( a : <span class="keyword">int</span> )</span><br><span class="line">        <span class="keyword">return</span> a </span><br><span class="line"></span><br><span class="line">    unsafe</span><br><span class="line">        <span class="comment">//inplace init syntax</span></span><br><span class="line">        var v_customset = [[ V2() </span><br><span class="line">            <span class="built_in">set</span> &lt;- @@ (var self : V2; X,Y : <span class="keyword">float</span>) &#123;</span><br><span class="line">                self.x = X * <span class="number">100.0f</span>;</span><br><span class="line">                self.y = Y * <span class="number">100.0f</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        ]]</span><br><span class="line">        v_customset-&gt;<span class="built_in">set</span>(<span class="number">1.0f</span>, <span class="number">2.0f</span>)</span><br><span class="line">        print(<span class="string">"&#123;v_customset.x&#125;, &#123;v_customset.y&#125;\n"</span>)</span><br><span class="line">        <span class="comment">//Output: 100.000000000, 200.000000000</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//reset after construction, pipe + block syntax</span></span><br><span class="line">        v_customset.<span class="built_in">set</span> = @@ &lt;| (var self : V2; X,Y : <span class="keyword">float</span>)</span><br><span class="line">            self.x = X * <span class="number">200.0f</span></span><br><span class="line">            self.y = Y * <span class="number">200.0f</span></span><br><span class="line">        print(<span class="string">"&#123;v_customset.x&#125;, &#123;v_customset.y&#125;\n"</span>)</span><br><span class="line">        <span class="comment">//Output: 200.000000000, 400.000000000</span></span><br></pre></td></tr></table></figure><br><em>(более практичное применение этого — паттерны типа event/callback)</em></p><h2 id="RTTI"><a href="#RTTI" class="headerlink" title="RTTI"></a>RTTI</h2><p><a href="https://github.com/GaijinEntertainment/daScript/blob/f050f7f9a4aaaac75e454834663389c9d8ebd343/examples/test/unit_tests/reflection.das#L110" target="_blank" rel="noopener">https://github.com/GaijinEntertainment/daScript/blob/f050f7f9a4aaaac75e454834663389c9d8ebd343/examples/test/unit_tests/reflection.das#L110</a></p><p>Пример вывода на экран информации о типе в runtime:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">require rtti</span><br><span class="line">...</span><br><span class="line">var a = <span class="keyword">new</span> V3()</span><br><span class="line">print(<span class="string">"class_info(a): &#123;class_info(a)&#125;\n"</span>) </span><br><span class="line">describeStructure(*class_info(a))</span><br><span class="line"><span class="comment">//Output:</span></span><br><span class="line"><span class="comment">//https://dascript.org/doc/stdlib/rtti.html?highlight=rtti#StructInfo</span></span><br><span class="line">class_info(a): [[ <span class="number">0x6</span>; V3; ; (_class|heapGC); <span class="number">0x28</span>; <span class="number">0x93b8d07b5cc8cee</span>; <span class="number">0xcf51414d2d20b41e</span>]]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">V3</span></span></span><br><span class="line"><span class="class">    __<span class="title">rtti</span> :</span> <span class="keyword">void</span>?</span><br><span class="line">    __finalize : function&lt;(V2):<span class="keyword">void</span>&gt;</span><br><span class="line">    x : <span class="keyword">float</span></span><br><span class="line">    y : <span class="keyword">float</span></span><br><span class="line">    set1 : function&lt;(V2;<span class="keyword">float</span> <span class="keyword">const</span>;<span class="keyword">float</span> <span class="keyword">const</span>):<span class="keyword">void</span>&gt;</span><br><span class="line">    z : <span class="keyword">float</span></span><br></pre></td></tr></table></figure><p>Доступна информация о названиях и типах полей, а также мета-информация (<a href="https://dascript.org/doc/stdlib/rtti.html?highlight=rtti#alias-structinfoflags" target="_blank" rel="noopener">флаги</a> класс/структура, выделена на стеке/хипе, аннотации и т.п.).</p><p>Для того, чтобы передать и распознать аннотации, необходимо включить опцию <code>options rtti=true</code> (в противном случае, метаинформация о произвольных аннотациях выбрасывается после симуляции, <a href="https://github.com/GaijinEntertainment/daScript/wiki/options" target="_blank" rel="noopener">линк</a>). Пример:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">options rtti=<span class="literal">true</span></span><br><span class="line">...</span><br><span class="line">class V3: V2</span><br><span class="line">    [[test]] z : <span class="keyword">float</span></span><br><span class="line">...</span><br><span class="line">def describeStructure(sinfo)</span><br><span class="line">    var anyAnn = <span class="literal">false</span></span><br><span class="line">    structure_for_each_annotation(sinfo) &lt;| $(ann; annArgs)</span><br><span class="line">        let argT = join([&#123;<span class="keyword">for</span> arg in annArgs; <span class="string">"&#123;arg.name&#125;&#123;describeValue(get_annotation_argument_value(arg))&#125;"</span>&#125;],<span class="string">","</span>)</span><br><span class="line">        print(<span class="string">"[&#123;ann.name&#125;(&#123;argT&#125;)]\n"</span>)</span><br><span class="line">    print(<span class="string">"struct &#123;sinfo.name&#125;\n"</span>)</span><br><span class="line">    <span class="keyword">for</span> sfield in sinfo</span><br><span class="line">        <span class="keyword">if</span> sfield.annotation_arguments != null</span><br><span class="line">            <span class="keyword">for</span> arg in deref(sfield.annotation_arguments)</span><br><span class="line">                print(<span class="string">"\t[[&#123;arg.name&#125;]] "</span>)</span><br><span class="line">        describeVariable(sfield,<span class="string">"\t"</span>)</span><br><span class="line">...</span><br><span class="line">var a = <span class="keyword">new</span> V3()</span><br><span class="line">print(<span class="string">"class_info(a): &#123;class_info(a)&#125;\n"</span>)</span><br><span class="line">describeStructure(*class_info(a))</span><br><span class="line"></span><br><span class="line"><span class="comment">//Output:</span></span><br><span class="line">struct V3</span><br><span class="line">    __rtti : <span class="keyword">void</span>?</span><br><span class="line">    __finalize : function&lt;(V2):<span class="keyword">void</span>&gt;</span><br><span class="line">    x : <span class="keyword">float</span></span><br><span class="line">    y : <span class="keyword">float</span></span><br><span class="line">    set1 : function&lt;(V2;<span class="keyword">float</span> <span class="keyword">const</span>;<span class="keyword">float</span> <span class="keyword">const</span>):<span class="keyword">void</span>&gt;</span><br><span class="line">    [[test]] z : <span class="keyword">float</span> <span class="comment">//&lt;-- аннотация test</span></span><br></pre></td></tr></table></figure><p><a href="https://gist.github.com/spiiin/961974938919cc9233bacf0bb5c71cd1" target="_blank" rel="noopener">Полный пример</a></p><h2 id="Abstract-и-sealed-методы"><a href="#Abstract-и-sealed-методы" class="headerlink" title="Abstract и sealed-методы"></a>Abstract и sealed-методы</h2><p>Методы можно сделать абстрактыми, или закрытыми для переопределения</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">    <span class="title">def</span> <span class="title">abstract</span> <span class="title">setX</span>(<span class="title">X</span>:</span> <span class="keyword">int</span>): <span class="keyword">void</span> <span class="comment">//необходимо явно определить сигнатуру метода -- тип аргументов и результата</span></span><br><span class="line">    <span class="function">def sealed <span class="title">setY</span><span class="params">(Y: <span class="keyword">int</span>)</span>         <span class="comment">//метод нельзя переопределить в потомках</span></span></span><br><span class="line"><span class="function">        pass</span></span><br></pre></td></tr></table></figure><h2 id="Видимость"><a href="#Видимость" class="headerlink" title="Видимость"></a>Видимость</h2><ul><li>Из модуля экспортируются функции с аннотацией [export]</li></ul><p><code>options always_export_initializer=true</code> позволяет проставить аннотацию для всех инициализаторов на уровне модуля</p><ul><li><code>private</code> для переменных и типов ограничивает их доступность из других модулей</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//module1.das</span></span><br><span class="line"><span class="keyword">module</span> module1</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">private</span> <span class="title">V1</span></span></span><br><span class="line"><span class="class">    <span class="title">w</span> :</span> <span class="keyword">float</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">private</span> <span class="title">V2</span></span></span><br><span class="line"><span class="class">    <span class="title">x</span> :</span> <span class="keyword">float</span></span><br><span class="line">    y : <span class="keyword">float</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">public</span> <span class="title">V3</span>:</span> V2</span><br><span class="line">    v1 : V1</span><br><span class="line">    z : <span class="keyword">float</span> = <span class="number">3.0</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">//main.das</span></span><br><span class="line">require module1</span><br><span class="line"><span class="comment">//можно звать инициализацию полей, и пост-инициализацию для V3 (также открываются поля V2), но нельзя инициализировать явно поле приватного класса V1</span></span><br><span class="line">var a = <span class="keyword">new</span> [[V3() x=<span class="number">1.0f</span>, y=<span class="number">2.0f</span>, z=<span class="number">3.0f</span>]]</span><br></pre></td></tr></table></figure><p>Приватными могут быть также поля и функции структур/классов</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">    <span class="title">private</span> <span class="title">a</span> :</span> <span class="keyword">int</span></span><br><span class="line">    <span class="function">def <span class="keyword">private</span> <span class="title">set_a</span><span class="params">(val:<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">        a </span>= val</span><br><span class="line">    def get_a</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    def MyClass()</span><br><span class="line">        self-&gt;set_a(<span class="number">42</span>)</span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main</span><br><span class="line">    var f = <span class="keyword">new</span> MyClass()</span><br><span class="line">    print(<span class="string">"f.a = &#123;f-&gt;get_a()&#125;\n"</span>)</span><br></pre></td></tr></table></figure><h2 id="Инициализаторы"><a href="#Инициализаторы" class="headerlink" title="Инициализаторы"></a>Инициализаторы</h2><p>Инициализатор для класса — это функция, у которой имя совпадает с именем класса. Так как классы — надстройки над структурами, и все варианты синтаксиса иницилизации действуют и для них, то нет никакой гарантии того, что инициализатор класса будет вызван.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">    <span class="title">i</span> :</span> <span class="keyword">float</span></span><br><span class="line">    <span class="function">def <span class="title">Test</span><span class="params">(I : <span class="keyword">float</span>)</span></span></span><br><span class="line"><span class="function">        i </span>= I</span><br><span class="line"></span><br><span class="line">def main</span><br><span class="line">    var a &lt;- <span class="keyword">new</span> Test(<span class="number">33.0f</span>)         <span class="comment">//initializer called</span></span><br><span class="line">    var b &lt;- <span class="keyword">new</span> Test()              <span class="comment">//initializer dont called</span></span><br><span class="line">    var c &lt;- <span class="keyword">new</span> [[Test() i = <span class="number">2.0f</span>]] <span class="comment">//initializer dont called</span></span><br></pre></td></tr></table></figure><h2 id="Интерфейсы"><a href="#Интерфейсы" class="headerlink" title="Интерфейсы"></a>Интерфейсы</h2><p><a href="https://github.com/GaijinEntertainment/daScript/blob/eaecd72d6d44b46f5566dc4a0ce3956d5488672c/daslib/interfaces.das" target="_blank" rel="noopener">https://github.com/GaijinEntertainment/daScript/blob/eaecd72d6d44b46f5566dc4a0ce3956d5488672c/daslib/interfaces.das</a></p><p>Библиотека <code>interfaces</code> с помощью пары макросов позволяет реализовать паттерн интерфейса — классы, который содержит только абстрактные методы. Макрос <code>implements</code> позволяет изобразить множественное наследование от интерфейсов.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[interface]</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ITick</span></span></span><br><span class="line"><span class="class">    <span class="title">def</span> <span class="title">abstract</span> <span class="title">tick</span> (<span class="title">dt</span>:</span><span class="keyword">float</span>) : <span class="keyword">void</span></span><br><span class="line"></span><br><span class="line">[interface]</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ILogger</span></span></span><br><span class="line"><span class="class">    <span class="title">def</span> <span class="title">abstract</span> <span class="title">log</span> (<span class="title">message</span> :</span> <span class="built_in">string</span>) : <span class="keyword">void</span></span><br><span class="line"></span><br><span class="line">[implements(ITick), implements(ILogger)]</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">    ...</span></span><br></pre></td></tr></table></figure><h1 id="Связь-с-C-типами"><a href="#Связь-с-C-типами" class="headerlink" title="Связь с C++ типами"></a>Связь с C++ типами</h1><p><a href="https://github.com/GaijinEntertainment/daScript/blob/master/examples/tutorial/tutorial03.cpp#L15" target="_blank" rel="noopener">https://github.com/GaijinEntertainment/daScript/blob/master/examples/tutorial/tutorial03.cpp#L15</a><br>Базовый пример прокидывания C++ класса в daScript. Похоже на другие скриптовые языки, создаётся класс-обёртка (<code>ManagedStructureAnnotation</code>) над типом, которая позволяет привязать и настроить отображение полей и методов структуры на тип в daScript, а также переопределить группу методов, определяющих свойства этого типа в daScript.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Color</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> r, g, b, a;</span><br><span class="line">&#125;;</span><br><span class="line">MAKE_TYPE_FACTORY(Color, Color);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ColorAnnotation</span> :</span> <span class="keyword">public</span> ManagedStructureAnnotation&lt;Color,<span class="literal">true</span>,<span class="literal">true</span>&gt; &#123;</span><br><span class="line">    ColorAnnotation(ModuleLibrary &amp; ml) : ManagedStructureAnnotation (<span class="string">"Color"</span>, ml) &#123;</span><br><span class="line">        <span class="comment">//type fields</span></span><br><span class="line">        addField&lt;DAS_BIND_MANAGED_FIELD(r)&gt;(<span class="string">"r"</span>);</span><br><span class="line">        addField&lt;DAS_BIND_MANAGED_FIELD(g)&gt;(<span class="string">"g"</span>);</span><br><span class="line">        addField&lt;DAS_BIND_MANAGED_FIELD(b)&gt;(<span class="string">"b"</span>);</span><br><span class="line">        addField&lt;DAS_BIND_MANAGED_FIELD(a)&gt;(<span class="string">"a"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//type behaviour</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">isLocal</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">canCopy</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125; </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">canMove</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Module_Tutorial03</span> :</span> <span class="keyword">public</span> Module &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Module_Tutorial03() : Module(<span class="string">"tutorial_03"</span>) &#123;</span><br><span class="line">        ModuleLibrary lib;</span><br><span class="line">        lib.addModule(<span class="keyword">this</span>);</span><br><span class="line">        addAnnotation(make_smart&lt;ColorAnnotation&gt;(lib));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">REGISTER_MODULE(Module_Tutorial03);</span><br></pre></td></tr></table></figure><p>Более продвинутые <a href="https://github.com/GaijinEntertainment/daScript/blob/master/examples/test/test_handles.cpp" target="_blank" rel="noopener">примеры</a>, также можно смотреть код <a href="https://github.com/GaijinEntertainment/daScript/tree/master/modules" target="_blank" rel="noopener">модулей</a>.</p><h2 id="Наследование"><a href="#Наследование" class="headerlink" title="Наследование"></a>Наследование</h2><p>Отнаследоваться от C++ типа нельзя (<em>ну, или я не нашёл способа сделать такой тип</em>).</p><p>Существует возможность передать в daScript связь родитель-потомок между C++-типами (<a href="https://github.com/borisbat/dasSFML/blob/4501a9167692180d138da4a487a42375a377db68/src/dasSFML.struct.add.inc#L134" target="_blank" rel="noopener">пример</a>), для upcast-приведения типов аргументов функций.</p><p>Пример организации связи между С++ и daScript-классами - <a href="https://github.com/GaijinEntertainment/daScript/blob/master/examples/tutorial/tutorial04.cpp#L45" target="_blank" rel="noopener">tutorial04</a>.</p><img style="background-color:white;" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjk3IiBoZWlnaHQ9IjE5OSIgdmVyc2lvbj0iMS4xIiBiYXNlUHJvZmlsZT0iZnVsbCIgdmlld2JveD0iMCAwIDY5NyAxOTkiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHhtbG5zOmV2PSJodHRwOi8vd3d3LnczLm9yZy8yMDAxL3htbC1ldmVudHMiIHN0eWxlPSJmb250LXdlaWdodDpib2xkOyBmb250LXNpemU6MTJwdDsgZm9udC1mYW1pbHk6J0NhbGlicmknLCBIZWx2ZXRpY2EsIHNhbnMtc2VyaWY7O3N0cm9rZS13aWR0aDozO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbGluZWNhcDpyb3VuZCI+PHBhdGggZD0iTTE4NC4xIDQ0LjUgTDExMiA2NC41IEwxMTIgODQuNSBMMTEyIDg0LjUgIiBzdHlsZT0ic3Ryb2tlOiMzMzMyMkU7ZmlsbDpub25lO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTsiPjwvcGF0aD4KPHBhdGggZD0iTTEwNi43IDcxLjIgTDExMiA3Ny44IEwxMTcuMyA3MS4yIEwxMTIgODQuNSBaIiBzdHlsZT0ic3Ryb2tlOiMzMzMyMkU7ZmlsbDojMzMzMjJFO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTsiPjwvcGF0aD4KPHBhdGggZD0iTTI5NS45IDQ0LjUgTDM2OCA2NC41IEwzNjggODQuNSBMMzY4IDg0LjUgIiBzdHlsZT0ic3Ryb2tlOiMzMzMyMkU7ZmlsbDpub25lO3N0cm9rZS1kYXNoYXJyYXk6NiA2OyI+PC9wYXRoPgo8cGF0aCBkPSJNMzYyLjcgNzEuMiBMMzY4IDc3LjggTDM3My4zIDcxLjIgTDM2OCA4NC41IFoiIHN0eWxlPSJzdHJva2U6IzMzMzIyRTtmaWxsOiMzMzMyMkU7c3Ryb2tlLWRhc2hhcnJheTpub25lOyI+PC9wYXRoPgo8cGF0aCBkPSJNNjA1IDExNS41IEw2MDUgMTM1LjUgTDUzOC4yIDE1NS41IEw1MzguMiAxNTUuNSAiIHN0eWxlPSJzdHJva2U6IzMzMzIyRTtmaWxsOm5vbmU7c3Ryb2tlLWRhc2hhcnJheTpub25lOyI+PC9wYXRoPgo8cGF0aCBkPSJNNTQ5LjUgMTQ2LjYgTDU0NC42IDE1My42IEw1NTIuNSAxNTYuOCBMNTM4LjIgMTU1LjUgWiIgc3R5bGU9InN0cm9rZTojMzMzMjJFO2ZpbGw6IzMzMzIyRTtzdHJva2UtZGFzaGFycmF5Om5vbmU7Ij48L3BhdGg+CjxwYXRoIGQ9Ik0zNjggMTE1LjUgTDM2OCAxMzUuNSBMNDM0LjggMTU1LjUgTDQzNC44IDE1NS41ICIgc3R5bGU9InN0cm9rZTojMzMzMjJFO2ZpbGw6bm9uZTtzdHJva2UtZGFzaGFycmF5Om5vbmU7Ij48L3BhdGg+CjxwYXRoIGQ9Ik00MjAuNSAxNTYuOCBMNDI4LjQgMTUzLjYgTDQyMy41IDE0Ni42IEw0MzQuOCAxNTUuNSBaIiBzdHlsZT0ic3Ryb2tlOiMzMzMyMkU7ZmlsbDojMzMzMjJFO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTsiPjwvcGF0aD4KPHJlY3QgeD0iMTIyLjUiIHk9IjEzLjUiIGhlaWdodD0iMzEiIHdpZHRoPSIyMzUiIHN0eWxlPSJzdHJva2U6IzMzMzIyRTtmaWxsOnBpbms7c3Ryb2tlLWRhc2hhcnJheTpub25lOyI+PC9yZWN0Pgo8dGV4dCB4PSIxMzAuOCIgeT0iMzUiIHN0eWxlPSIiPlR1dG9yaWFsQmFzZUNsYXNzIChkYXMpPC90ZXh0Pgo8cmVjdCB4PSIxMy41IiB5PSI4NC41IiBoZWlnaHQ9IjMxIiB3aWR0aD0iMTk3IiBzdHlsZT0ic3Ryb2tlOiMzMzMyMkU7ZmlsbDpwaW5rO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTsiPjwvcmVjdD4KPHRleHQgeD0iMjEuOCIgeT0iMTA2IiBzdHlsZT0iIj5FeGFtcGxlT2JqZWN0IChkYXMpPC90ZXh0Pgo8cmVjdCB4PSIyNTAuNSIgeT0iODQuNSIgaGVpZ2h0PSIzMSIgd2lkdGg9IjIzNSIgc3R5bGU9InN0cm9rZTojMzMzMjJFO2ZpbGw6I2VlZThkNTtzdHJva2UtZGFzaGFycmF5Om5vbmU7Ij48L3JlY3Q+Cjx0ZXh0IHg9IjI1OC44IiB5PSIxMDYiIHN0eWxlPSIiPlR1dG9yaWFsQmFzZUNsYXNzIChjcHApPC90ZXh0Pgo8cmVjdCB4PSI1MjUuNSIgeT0iODQuNSIgaGVpZ2h0PSIzMSIgd2lkdGg9IjE1OSIgc3R5bGU9InN0cm9rZTojMzMzMjJFO2ZpbGw6I2VlZThkNTtzdHJva2UtZGFzaGFycmF5Om5vbmU7Ij48L3JlY3Q+Cjx0ZXh0IHg9IjUzMy44IiB5PSIxMDYiIHN0eWxlPSIiPkJhc2VDbGFzcyAoY3BwKTwvdGV4dD4KPHJlY3QgeD0iMzc0LjUiIHk9IjE1NS41IiBoZWlnaHQ9IjMxIiB3aWR0aD0iMjI1IiBzdHlsZT0ic3Ryb2tlOiMzMzMyMkU7ZmlsbDojZWVlOGQ1O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTsiPjwvcmVjdD4KPHRleHQgeD0iMzgyLjUiIHk9IjE3NyIgc3R5bGU9IiI+QmFzZUNsYXNzQWRhcHRlciAoY3BwKTwvdGV4dD48L3N2Zz4=" /><p>В примере связь организуется через класс <code>BaseClassAdapter</code>, который наследуется одновременно от базового C++-класса и сгенерированного по das-коду C++-классу-адаптеру</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">options remove_unused_symbols = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//interface C++/daScript</span></span><br><span class="line">class TutorialBaseClass</span><br><span class="line">    def abstract update ( dt : <span class="keyword">float</span> ) : <span class="keyword">void</span></span><br><span class="line">    def abstract get_position : float3</span><br><span class="line"></span><br><span class="line"><span class="comment">// uncomment the section to generate C++ bindings for the TutorialBaseClass</span></span><br><span class="line"><span class="comment">// this code will generate tutorial04_gen.inc which contains C++ bindings</span></span><br><span class="line"></span><br><span class="line">require fio</span><br><span class="line">require ast</span><br><span class="line">require daslib/cpp_bind</span><br><span class="line">[init]</span><br><span class="line">def generate_cpp_bindings</span><br><span class="line">    let root = get_das_root() + <span class="string">"/examples/tutorial/"</span></span><br><span class="line">    fopen(root + <span class="string">"tutorial04_gen.inc"</span>,<span class="string">"wb"</span>) &lt;| $ ( cpp_file )</span><br><span class="line">        <span class="comment">//generate c++ code from dascript rtti class information</span></span><br><span class="line">        log_cpp_class_adapter(cpp_file, <span class="string">"TutorialBaseClass"</span>, typeinfo(ast_typedecl type&lt;TutorialBaseClass&gt;))</span><br></pre></td></tr></table></figure><p><code>TutorialBaseClass</code> - интерфейс между C++/daScript, который используется генератором C++-обёрток <code>log_cpp_class_adapter</code>, на выходе получается примерно такой C++-код:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TutorialBaseClass</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">enum</span> &#123;</span><br><span class="line">    __fn_update = <span class="number">0</span>,</span><br><span class="line">    __fn_get_position = <span class="number">1</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> _das_class_method_offset[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  TutorialBaseClass ( <span class="keyword">const</span> StructInfo * info ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( _das_class_method_offset[<span class="number">0</span>]==<span class="number">0</span> ) &#123;</span><br><span class="line">      _das_class_method_offset[__fn_update] = adapt_field_offset(<span class="string">"update"</span>,info);</span><br><span class="line">      _das_class_method_offset[__fn_get_position] = adapt_field_offset(<span class="string">"get_position"</span>,info);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">static</span> __forceinline Func <span class="title">get_get_position</span> <span class="params">( <span class="keyword">void</span> * self )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getDasClassMethod(self,_das_class_method_offset[__fn_get_position]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> __forceinline float3 <span class="title">invoke_get_position</span> <span class="params">( Context * __context__, Func __funcCall__, <span class="keyword">void</span> * self )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> das_invoke_function&lt;float3&gt;::invoke</span><br><span class="line">      &lt;<span class="keyword">void</span> *&gt;</span><br><span class="line">        (__context__,<span class="literal">nullptr</span>,__funcCall__,</span><br><span class="line">          self);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> TutorialBaseClass::_das_class_method_offset[<span class="number">2</span>];</span><br></pre></td></tr></table></figure><p>Вызов:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseClassAdapter</span> :</span> <span class="keyword">public</span> BaseClass, <span class="keyword">public</span> TutorialBaseClass &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// in the constructor we store pointer to the original class and context</span></span><br><span class="line">    <span class="comment">// we also pass StructInfo of the daScript class to the generated class</span></span><br><span class="line">    BaseClassAdapter ( <span class="keyword">char</span> * pClass, <span class="keyword">const</span> StructInfo * info, Context * ctx )</span><br><span class="line">        : TutorialBaseClass(info), classPtr(pClass), context(ctx) &#123; &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> float3 <span class="title">getPosition</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// we check if daScript class has 'get_position'</span></span><br><span class="line">        <span class="keyword">if</span> ( <span class="keyword">auto</span> fn = get_get_position(classPtr) ) &#123;</span><br><span class="line">            <span class="comment">// we invoke it, and return it's result</span></span><br><span class="line">            <span class="keyword">return</span> invoke_get_position(context, fn, classPtr);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> float3(<span class="number">0.0f</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">void</span> *      classPtr;   <span class="comment">// stored pointer to the daScript class</span></span><br></pre></td></tr></table></figure></p><p>Класс не содержит особой магии, а просто хранит адреса daScript-функций и позволяет прозрачно для вызывающего C++-кода их вызывать и изменять.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;h1 id=&quot;Струк
      
    
    </summary>
    
    
    
      <category term="dascript" scheme="http://spiiin.github.io/tags/dascript/"/>
    
  </entry>
  
  <entry>
    <title>daScript -&gt; dasLang?</title>
    <link href="http://spiiin.github.io/blog/2975166623/"/>
    <id>http://spiiin.github.io/blog/2975166623/</id>
    <published>2023-01-01T20:44:11.000Z</published>
    <updated>2023-01-02T01:41:46.880Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Год назад в первых же заметках про <code>daScript</code>:<br><a href="/blog/1728194429/" title="С++ в геймдеве">С++ в геймдеве</a><br><a href="/blog/1547564887/" title="daScript macro">daScript macro</a><br>я отметил для себя такой парадокс - <strong><code>Гайдзины делают не замену Lua, они делают замену C++!</code></strong>, т.е. дизайн языка — это совсем не про скрипты, это generic язык, удобный, чтобы делать с его помощью игры.</p><a id="more"></a><p>Сам Борис, видимо, устал отвечать на вопросы новичков в стиле “это такая альтернатива lua?” и написал <a href="https://borisbat.github.io/dascf-blog/2022/12/31/its-not-a-script/" target="_blank" rel="noopener">заметку</a> про то, что название сильно сбивает с толку.</p><h2 id="Слои-языка"><a href="#Слои-языка" class="headerlink" title="Слои языка"></a>Слои языка</h2><p><strong><code>Разделение по уровню понимания языка</code></strong></p><p><code>daScript</code> — это айсберг, в котором новичкам видно его верхушку — скриптовый слой, на котором можно описывать логику и дёргать API движка, например, <a href="https://github.com/imp5imp5/dasbox/blob/main/doc/api.txt" target="_blank" rel="noopener">dasbox api</a>. Это первый слой — glue-язык, на котором можно писать семантически сжатый компактный код как на каком-нибудь python/lua/javascript.<br>Но при синтаксической похожести уже явно будут видны отличия:</p><ul><li>язык типизированный — при изучении приходится потратить некоторое время на то, чтобы научиться правильно работать с его типами. В этом он местами сложнее не только луа, но и на C, скорее похож на языки из ml-семейства. Это сделано by-design, ради того, чтобы компилятор ловил больше ошибок, и легче было рефакторить код.<br><em>Некоторые простые для lua паттерны мета-программирования, в котором rtti-информация о типе — это просто таблица, к которой можно получить доступ, необходимо переделывать с помощью магических макросов, что требует намного более глубокого понимания языка</em></li><li>язык позволяет работать на низком уровне — на котором можно делать практически то же, что и C. Местами про lifetime объектов нужно думать больше, а не меньше, чем в C++, и уж точно не на уровне “включил GC и выключил голову”.</li><li>язык быстрый — наивный код получается +/- таким же производительным, как и наивный С++, а gamedev-specific код (много работы с векторами/матрицами) — часто и сильно быстрее. Сам код возможно оптимизировать на самом daScript, без подхода “перепишем то, что тормозит на C”.</li><li>виртуальную машину языка можно рассматривать не как абстрактную машину, а как AoT-компилятор в C++, который используется как <a href="https://www.youtube.com/watch?v=8SoJR3sCaR4" target="_blank" rel="noopener">платформа</a>.</li></ul><p>Т.е. уже на этом уровне свойства языка существенно отличаются от того, что обычно понимают под скриптовым языком в геймдеве. Что представляет проблему, так как с позиции изучающего язык новичка “с высоты птичьего полёта” язык кажется не тем, чем он есть на самом деле.</p><p><img src="/blog/2975166623/iceberg_small.png" alt=""><br>При этом сам айсберг — это генерики и макросы, с помощью которых можно создавать edsl, изменять синтаксис: от добавления привычных для ООП вещей, которых нет в ядре языка, вроде <a href="https://raw.githubusercontent.com/GaijinEntertainment/daScript/master/daslib/interfaces.das" target="_blank" rel="noopener">интерфейсов</a>, или привычных для асинхронного программирования <a href="https://github.com/GaijinEntertainment/daScript/blob/138f625c7f95943341a5e96cca114ae7d0772ba6/daslib/coroutines.das" target="_blank" rel="noopener">корутин</a>, до dsl: языки-обёртки над <a href="https://github.com/GaijinEntertainment/daScript/blob/master/modules/dasOpenGL/glsl/glsl_opengl.das" target="_blank" rel="noopener">шейдерными языками</a>, и чёрной магии reader macro, позволяющей встраивать альтернативные синтаксисы вроде <a href="https://github.com/GaijinEntertainment/daScript/blob/master/daslib/regex_boost.das" target="_blank" rel="noopener">регулярных выражений</a>, а также модифицировать AST-языка.</p><p>Парсинг и модификация/генерация AST также упрощает создание инструментов для работы с кодом:</p><ul><li><a href="https://marketplace.visualstudio.com/items?itemName=profelis.dascript-plugin" target="_blank" rel="noopener">daScript language support for vs code</a> — отладчик, подсветка кода и вывод типов, помощь с выводом выражений</li><li><a href="https://borisbat.github.io/dascf-blog/2022/12/11/instruments/" target="_blank" rel="noopener">профайлер</a></li><li>генерация <a href="https://github.com/GaijinEntertainment/daScript/tree/master/modules/dasClangBind/bind" target="_blank" rel="noopener">привязок</a> к C/C++ библиотекам (можно смотреть, к примеру, <code>bind_opengl</code> — генерится daScript код, для других может генериться и c++-код привязки)</li><li><a href="https://github.com/GaijinEntertainment/daScript/blob/073bc29145207b39180069ae60f00ed43fad6ea7/examples/test/misc/ast_print.das" target="_blank" rel="noopener">описание выражений</a> в runtime</li><li><a href="https://github.com/GaijinEntertainment/daScript/blob/9e217204864177cf6886c7d8ecc86be1d47dbfca/daslib/lint.das" target="_blank" rel="noopener">линтеры</a></li><li>hot code reload — <a href="/blog/3006126295/" title="daScript - live-режим">daScript - live-режим</a><br>и многое другое.</li></ul><p>Такое разделения по испольуемым фичам похоже на то, чем отличается код приложения от кода библиотек на C++ — прикладной уровень требует знания только основ языка, тогда как написание библиотеки может требовать умений использовать наиболее мощные фичи.</p><p><strong><code>Разделение по архитектуре языка</code></strong></p><p>В заметке Борис выделяет такие уровни языка (явного название уровней у него нет, поэтому придумал я):</p><ul><li>Lowest level. Низкоуровневое ядро языка, на этом уровне язык можно представить себе как альтернативу C, с фичами вроде арифметики указателей, копирования областей памяти, pod-структур с возможностью настройки размещения в памяти.</li><li>Syntax-sugar level. Уровень синтаксического сахара, абстракции уровня языков Ruby или Python — блоки, замыкания, таблицы, классы, генераторы и итераторы. Чаще всего реализованы в виде библиотек на самом daScript.</li><li>Macro level. Фичи работы с AST языка, похожие на то, что можно делать в Lisp или Haxe — “bring your own language”, пишем код, который говорит компилятору, как именно интерпретировать другой код.</li></ul><p><img src="/blog/2975166623/onion_small.png" alt=""></p><p>Ни один из уровней не предназначен для решения проблем, которыми обычно занимаются скриптовые языки — <code>daScript</code> не для написания игровой логики, а для написания <em>всего</em> для игры, от логики, до движка — рендера, шейдеров и физики, и до тулзов - редактора игры, компилятора данных, сервера, скриптов сборки и прочей инфраструктуры вокруг, и соединения всего этого вместе.</p><h2 id="Проблема-названия"><a href="#Проблема-названия" class="headerlink" title="Проблема названия"></a>Проблема названия</h2><p>Вывод заметки — если <em>script</em> в названии не соответствует тому, что представляет собой язык, и только отвлекает от того, на что он потенциально способен (да и <em>da</em> - в названии, отсылка к названию движка Gaijin — <strong>Da</strong>gor Engine, язык начинался как попытка сделать замену предыдущим скриптовым языкам для движка, но уже может использовать и без него), то этого достаточно для того, чтобы переименовать язык во что-то типа <strong><code>dasLang</code></strong>, так как <strong>das</strong>-часть уже закрепилась в качестве расширения файлов для языка.</p><p>Как по мне — прикольный ход, новое название сохраняет узнаваемость для знакомых со старым, и перестаёт исправляться “умным” поиском на что-то другое и выдавать нерелевантные результаты, хотя и читается по немецки как “так долго”.</p><p>Побалуюсь немного на тему того, сокращением от чего могло бы быть это название, по аналогии, как <code>Nimrod</code>, сократилось до <a href="https://nim-lang.org/" target="_blank" rel="noopener">nim-lang</a> для nim. Случайные свойства и идеи языка, которые первыми пришли мне на ум после изучения <code>daScript</code>:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- скорость цикла разработки</span><br><span class="line">- выразительность</span><br><span class="line">- экономность ресурсов</span><br><span class="line">- создание абстракций</span><br><span class="line">- чистота (stateless)</span><br><span class="line">- контроль ошибок</span><br><span class="line">- встраиваемость (комбинируемость с другими)</span><br><span class="line">- типизация</span><br><span class="line">- быстрая интерпретация</span><br><span class="line">- дружественность к особенностям железа (hardware-friendly)</span><br><span class="line">- открытость</span><br><span class="line">- бесплатность</span><br><span class="line">- быстрые контексты (fast context reset)</span><br></pre></td></tr></table></figure><p>Если попробовать аппроксимировать слова вместе, максимально абстрактно склеивая их друг с другом, можно получить что-то такое:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">скорость (4) &lt;- скорость разработки + быстрая интерпретация + hardware friendly + fast context reset</span><br><span class="line">низкоуровневость (2) &lt;- экономность + hardware friendly</span><br><span class="line">защита (3) &lt;- контроль + типизация + чистота</span><br><span class="line">свобода (4) &lt;- выразительность + комбинируемость + бесплатность + открытость</span><br><span class="line">виртуальность (2) &lt;- выразительность + создание абстракций</span><br></pre></td></tr></table></figure><p>И еще разок:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">производительность&#x2F;performance (6) &lt;- низкоуровневость + скорость</span><br><span class="line">свобода&#x2F;freedom (4)</span><br><span class="line">безопасность&#x2F;safety (5) &lt;- защита + виртуальность</span><br></pre></td></tr></table></figure><p>Уже похоже на motto:</p><blockquote><p>“Performance &amp; creative freedom in safety environment”</p></blockquote><p>Производительный код и свобода творчества в безопасном скриптовом окружении? Кажется безумной, но заманчивой затеей? — но отчаянный <strong><code>dAsperado language (dasLang)</code></strong> позволяет именно это.<br><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/zVMObSx3E1M?start=26" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Год назад в первых же заметках про &lt;code&gt;daScript&lt;/code&gt;:&lt;br&gt;&lt;a href=&quot;/blog/1728194429/&quot; title=&quot;С++ в геймдеве&quot;&gt;С++ в геймдеве&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;/blog/1547564887/&quot; title=&quot;daScript macro&quot;&gt;daScript macro&lt;/a&gt;&lt;br&gt;я отметил для себя такой парадокс - &lt;strong&gt;&lt;code&gt;Гайдзины делают не замену Lua, они делают замену C++!&lt;/code&gt;&lt;/strong&gt;, т.е. дизайн языка — это совсем не про скрипты, это generic язык, удобный, чтобы делать с его помощью игры.&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="gamedev" scheme="http://spiiin.github.io/tags/gamedev/"/>
    
      <category term="dascript" scheme="http://spiiin.github.io/tags/dascript/"/>
    
      <category term="dev_method" scheme="http://spiiin.github.io/tags/dev-method/"/>
    
  </entry>
  
  <entry>
    <title>Хеш-таблицы. Шпаргалка</title>
    <link href="http://spiiin.github.io/blog/847579411/"/>
    <id>http://spiiin.github.io/blog/847579411/</id>
    <published>2022-12-25T20:09:16.000Z</published>
    <updated>2022-12-26T13:30:22.109Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Небольшой обзор типов хеш-таблиц, которые чаще всего встречаются в языках программирования.</p><a id="more"></a><p>Материалы:<br>[1] - <a href="https://youtu.be/ncHmEUmJZf4" target="_blank" rel="noopener">Matt Kulukundis “Designing a Fast, Efficient, Cache-friendly Hash Table, Step by Step”</a><br>[2] - <a href="http://bannalia.blogspot.com/2022/06/advancing-state-of-art-for.html" target="_blank" rel="noopener">Advancing the state of the art for std::unordered_map implementations</a><br>[3] - <a href="http://craftinginterpreters.com/hash-tables.html" target="_blank" rel="noopener">Crafting Interpreters</a>. Глава “Hash tables”<br>[4] - <a href="https://www.sebastiansylvan.com/post/robin-hood-hashing-should-be-your-default-hash-table-implementation/" target="_blank" rel="noopener">Robin Hood Hashing should be your default Hash Table implementation</a><br>[5] - <a href="https://www.youtube.com/watch?v=M2fKMP47slQ" target="_blank" rel="noopener">You Can Do Better than std::unordered_map: New Improvements to Hash Table Performance</a> - доклад автора ska::flat_hash_map<br>[6] - <a href="https://pdimov.github.io/articles/unordered_dev_plan.html" target="_blank" rel="noopener">Development Plan for Boost.Unordered</a></p><p>Хеш-таблицы (наряду с массивами) — одна из основных структур данных стандартной библиотеки практически каждого языка программирования. Базовые понятия можно изучить из любой книги по алгоритмам и структурам данных, например, <code>Седжвик - Фундаментальные алгоритмы на C++</code>.</p><p>Теоретически, хеш-таблица (ассоциативный массив) — это контейнер, который хранит пары [ключ, значение] с быстрым доступом (амортизированно, O(1)). Практически, есть много интересных нюансов организации хранения.<br>Хеш-таблица логически организована как несколько корзин (bucket/slot), которые хранят данные (пары, значения, указатели на них). Место хранения (конкретная корзина) определяется с помощью хеш-функции, которая отображает ключ на номер корзины.</p><h2 id="Размер-таблицы"><a href="#Размер-таблицы" class="headerlink" title="Размер таблицы"></a>Размер таблицы</h2><p>Память компьютера не бесконечна, так что количество корзин очевидно должно быть меньше, чем все количество всех возможных значений ключей. Так как хеш-таблицы — очень общая структура данных, то баланс между размером таблицы и скоростью доступа является сложной задачей. Разные типы хеш-таблиц начинают просаживаться по скорости начиная с различной степени заполненности, так что оптимальный размер таблицы зависит от её внутреннего устройства. Бывают типы таблиц, которые “расширяются” начиная от 50%, 75% или даже 90-95%</p><h2 id="Хеш-функции"><a href="#Хеш-функции" class="headerlink" title="Хеш-функции"></a>Хеш-функции</h2><p>Идеальный случай — если каждый ключ отображается на уникальную корзину. Но когда хеш-функция для двух ключей возвращает одно и то же значение, происходит коллизия. Одно из фундаментальных различий организации хеш-таблиц — способ работы с коллизиями. От него же зависит от отклонение между теоретическим и практическим временем поиска элемента в таблице.</p><p>Тем не менее, перед рассмотрением способов работы с коллизиями, стоит сказать пару слов о хеш-функциях. Чем более равномерно будут “размазаны” входные значения по корзинам хеш-таблицы, тем лучше. Если входные данные неизвестны заранее, то хорошим способом будет максимально рандомизировать хеш-функцию. Огромная часть производительности хеш-таблиц зависит от того, насколько равномерно входные данные попадают в различные корзины, так что первый шаг в проверке производительности — проверить используемую функцию ([1], <a href="https://youtu.be/ncHmEUmJZf4?t=170" target="_blank" rel="noopener">тайминг</a>)</p><h2 id="Идеальное-хеширование"><a href="#Идеальное-хеширование" class="headerlink" title="Идеальное хеширование"></a>Идеальное хеширование</h2><p>В случае, если входные данные известны заранее и можно построить по ним таблицу до начала её использования, можно попробовать перебором подобрать такую хеш-функцию, которая вообще не вызовет коллизий на входных данных (<code>идеальное хеширование</code>). Отчасти расширением этого подхода можно назвать <a href="https://www.geeksforgeeks.org/cuckoo-hashing/" target="_blank" rel="noopener">хеширование кукушки</a>. В этом случае есть две отдельных хеш таблицы с разными хеш-функциями, и элемент может храниться в любой из двух таблиц. Если слот в одной из корзин занят, можно попробовать положить один из элементов в другую таблицу, и циклически переместить другие занятые в одной из таблиц слоты с другую. Если же найден цикл — можно попробовать или сменить пару хеш-функций и переложить все элементы в другую таблицу, или добавить третью таблицу с еще одной хеш-функцией.</p><h2 id="Separate-chaining"><a href="#Separate-chaining" class="headerlink" title="Separate chaining"></a>Separate chaining</h2><p>Один из простых случаев разрешения коллизий — хранить в корзинах не значения, а односвязный список, в который добавляются значения с одинаковым ключом. Такой подход могут называть раздельное хеширование или закрытая адресация (closed addressing, в значении “возможность положить значение не в свою корзину закрыта”). Минусы такого способа, как и самого связанного списка — необходимость динамического выделения памяти и дополнительный прыжок в памяти по указателю на элемент.</p><p>Тем не менее, практически в чистом виде встречается в C++ (<code>stl::unordered_map</code>), в <a href="https://github.com/mono/mono/blob/mono-3.0.3/mcs/class/corlib/System.Collections.Generic/Dictionary.cs#L66" target="_blank" rel="noopener">C#</a>, Java, <a href="https://medium.com/kalamsilicon/hash-tables-implementation-in-go-48c165c54553" target="_blank" rel="noopener">Go</a>.</p><p>Для C++, вдобавок, в стандарте прописана необходимость реализации API в виде связанного списка (<a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1456.html" target="_blank" rel="noopener">N1456</a>, комментарий в [1], <a href="https://youtu.be/ncHmEUmJZf4?t=549" target="_blank" rel="noopener">тайминг</a> — <em>when stl is starting to make sense, and that is never a good sign</em>).</p><p><code>boost::unordered_map</code><br>В [2] приводятся примеры нескольких реализаций такого API и возможных оптимизаций по производительности (<em>Time and memory performance of Boost 1.80 boost::unordered_map</em>).<br><img src="/blog/847579411/fca_small.png" alt=""></p><ul><li>bucket groups - бит-маска занятых элементов вместо указателей из одного слота в другой (на скрине выше), за счет экономии памяти лучше влезает в кеш</li><li>количество корзин при максимально допустимой загруженности таблицы растет не в 2 раза, а как последовательность простых чисел — способствует более равномерному распределению при плохом (non-uniform) выборе хеш-функции<br>(<a href="https://www.boost.org/doc/libs/develop/libs/unordered/doc/html/unordered.html#compliance" target="_blank" rel="noopener">бенчмарк</a>)<br>[6] - обзор альтернативных типов таблиц</li></ul><p>Одна из нераспространенных на практике идей из классических книг — сохранять упорядоченность списков для небольшого ускорения проверки наличия элемента в списке (<em>скорее всего, из-за потери возможности хранить указатели на элементы корзины</em>)</p><h2 id="Open-addressing"><a href="#Open-addressing" class="headerlink" title="Open addressing"></a>Open addressing</h2><p>Варианты названия:<br><code>Open addressing</code> (открытая адресация, в смысле, что возможность попадания элемента не свою корзину отрыта)<br><code>Closed hashing</code> (<a href="http://craftinginterpreters.com/hash-tables.html#open-addressing" target="_blank" rel="noopener">3</a>, закрытое хеширование в смысле что возможность элемента оказаться вне корзин закрыта)<br><code>Probing table</code>(<a href="https://youtu.be/ncHmEUmJZf4?t=943" target="_blank" rel="noopener">1</a>, для случая, если в корзинах хранятся не указатели, а значения)<br><code>Scatter tables</code>(<a href="https://book.huihoo.com/data-structures-and-algorithms-with-object-oriented-design-patterns-in-java/html/page231.html" target="_blank" rel="noopener">Data Structures and Algorithms with Object-Oriented Design Patterns in Java</a>, аналогично)<br><code>Flat map</code> (аналогично)</p><p>Зачем хранить элементы с повторяющимся хешем ключа в связанном списке, если можно положить их в другие корзины? Это сложнее в организации, возникает серия вопросов — как именно выбрать альтернативную корзину, как узнать, что в корзине находится “не родное” значение, как удалять элементы? Дальнейшую таксономию таблиц с открытой адресацией можно выстроить в зависимости от ответов на эти вопросы.</p><p>Варианты ответов:</p><p><strong><code>Как выбрать альтернативную корзину</code></strong></p><ul><li>Попробовать следующую (после последней заново проверить первую) — линейное пробирование.<br>Распространенный метод из-за того, что дружественный к кешу, элементы хранятся в памяти близко друг к другу.<br>Может вызывать проблемы при большой загруженности таблицы, но это можно решать различными способами — пересортировать элементы хранящиеся рядом, позаботиться о более качественном “размазывании”, см. раздел “Хеш-функции”), уменьшить коэффициент заполненности, при котором будет увеличено количество корзин. Эти решения проблем будут более детально рассмотрено далее</li><li>Увеличивать шаг не на 1, а по более сложным правилам — квадрат от номера попытки, другая хеш-функция от значения элемента, etc. Требует хорошего понимания вероятности, насколько выбор шага может действительно улучшить распределение ключей по корзинам (может зависеть от размера таблицы и хеш-функции).</li></ul><p>Встречаются экзотические комбинации стратегий - <a href="https://github.com/ktprime/emhash" target="_blank" rel="noopener">emhash</a> в режиме 3-way combined сначала делает несколько линейных проб, затем квадратичные, и дальше пробует втиснуть элемент поочередно в начало/конец таблицы.</p><p><strong><code>Удаление значений</code></strong></p><ul><li>Вместо удаления значений, заменить реальное значение в корзине на “надгробие” (tombstone), чтобы при поиске элемента по списку рассматривать его “за этим значением есть другие для проверки”, а при вставке нового элемента рассматривать надгробие как пустую корзину для вставки</li><li>В случае линейной вставки элементов в первую попавшуюся пустую корзину можно переместить последний элемент списка на освободившееся пустое место. Несмотря на кажущуюся тривиальность алгоритма, требует аккуратности в реализации (как пример, в книге Кнута алгоритм содержал ошибки)</li></ul><p><strong><code>Как отличить неродное значение</code></strong></p><ul><li>В случае линейного пробирования, проверять все соседние занятые элементы до нахождения пустого значения<br>В случае сильно заполненной корзины, даже без наличия коллизий, может оказаться для что вставки нового значения потребуется проверить по порядку множество уже занятых значений (кластеры из занятых корзин). Аналогичная проблема при поиске несуществующего элемента.</li></ul><p>Тривиальный подход слежения за тем, чтобы не образовывались кластеры — хорошая хеш-функция и низкие значение коеффициенты заполненности (~0.5-0.6) для того, чтобы таблица разрослась раньше, чем в ней образовались большие кластеры из заполненных корзин. Более сложный — переставлять элементы внутри кластеров так, чтобы уменьшить количество необходимых поисков (алгориты <code>Брента</code>, <code>Робин Гуда</code>, детальнее ниже)</p><h2 id="Линейное-пробирование-без-перестановок"><a href="#Линейное-пробирование-без-перестановок" class="headerlink" title="Линейное пробирование без перестановок"></a>Линейное пробирование без перестановок</h2><p>Почти чистый вариант линейного пробирования без дополнительных хитростей с перестановками элементов приведен в [3].</p><p>Вариант из <code>daScript</code>:</p><ul><li>Рост таблицы при кластеризации в 2 раза. Чем больше таблица, тем меньше <a href="https://github.com/GaijinEntertainment/daScript/blob/a0fcdfdbf134d3dfb8055c9218c6e57ff4ae925b/include/daScript/simulate/runtime_table.h#L61" target="_blank" rel="noopener">коеффициент заполненности</a> (при увеличение таблицы в 2 раза разрешаем в 6 раз больше промахов)</li><li>Раздельное хранение хешей, хеширование <a href="https://github.com/GaijinEntertainment/daScript/blob/master/include/daScript/misc/fnv.h" target="_blank" rel="noopener">fnv</a></li><li>Tombstone при удалении</li></ul><p><a href="https://abseil.io/docs/cpp/guides/container" target="_blank" rel="noopener">absl::flat_hash_map</a> + <a href="https://abseil.io/about/design/swisstables" target="_blank" rel="noopener">Swiss Tables Design Notes</a><br>[1] - доклад с пошаговым описанием идей дизайна flat_hash_map + <a href="https://www.youtube.com/watch?v=JZE3_0qvrMg" target="_blank" rel="noopener">дополнение</a></p><ul><li>Раздельное хранение метаинформации + simd инструкции для ускорения проверок</li></ul><p>Пример возможной проблемы с кластеризацией значений:<br><img src="/blog/847579411/cluster_small.png" alt=""></p><p>Даже если все элементы отмеченные красным, стояли на своих местах, может получиться, что новый элемент (зеленый), будет вставлен далеко от своего потенциального места (первая стрелка).</p><p>Одна из неочевидных проблем линейного пробирования — про последовательном обходе элементов из хеш-таблицы (неявно отсортированы по возрастанию хешей) и перекладывании их в другую таблицу они попадут туда в очень плохом порядке (при добавлении второй половины таблицы до роста хеши элементов по модулю будут совпадать с хешами из первой половины, которая будет уже плотно заполнена — зона заполненности “от 0.5 до коэффициент роста” будет содержать большое количество коллизий) — пример багов в <a href="https://habr.com/ru/post/282902/" target="_blank" rel="noopener">Delphi</a>, <a href="http://lemire.me/blog/2017/01/30/maps-and-sets-can-have-quadratic-time-performance/" target="_blank" rel="noopener">Swift</a>, <a href="https://accidentallyquadratic.tumblr.com/post/153545455987/rust-hash-iteration-reinsertion" target="_blank" rel="noopener">Rust</a>. Возможное решение — использовать хеш-функцию с возможностью задать стартовый сид и менять его для каждой новой таблицы. Или попробовать предсказать размер заполняемой таблицы заранее.</p><h2 id="Линейное-хеширование-с-перестановкой-Брента"><a href="#Линейное-хеширование-с-перестановкой-Брента" class="headerlink" title="Линейное хеширование с перестановкой Брента"></a>Линейное хеширование с перестановкой Брента</h2><p>На скриншоте выше все элементы представленные красным стоят на своих местах, и могут быть найдены за 1 запрос к таблице. Но при поиске красного элемента нужно будет проверить 9 элементов. При этом, если все красные элементы кластера сдвинуть на 1 вправо, то для поиска каждого из них потребовалось бы всего 2 запроса — среднее время поиска осталось бы таким же, но максимальное время поиска уменьшилось бы с 9 до 2, в 4.5 раза. Метод Брента — перед вставкой проверить сколько запросов будет при такой перестановке и выбрать самый оптимальный вариант (<a href="https://www.cs.umd.edu/class/fall2018/cmsc420-0301/lecnotes/Hashing-spring17.pdf" target="_blank" rel="noopener">описание и пример</a>, а также какое-то расширение метода в поиск по дереву Gonnet-Munro, <a href="https://github.com/ncilengir/brent-hashing" target="_blank" rel="noopener">другое описание</a> и <a href="http://www.minkhollow.ca/Courses/461/Notes/Hashing/HashBrentex1.html" target="_blank" rel="noopener">другой пример</a>).</p><p>Реализация метода Брента в таблицах <a href="https://www.lua.org/source/5.4/ltable.c.html" target="_blank" rel="noopener">lua</a> и <a href="https://poga.github.io/lua53-notes/table.html" target="_blank" rel="noopener">описание</a></p><h2 id="Линейное-хеширование-с-перестановкой-Робин-Гуда"><a href="#Линейное-хеширование-с-перестановкой-Робин-Гуда" class="headerlink" title="Линейное хеширование с перестановкой Робин Гуда"></a>Линейное хеширование с перестановкой Робин Гуда</h2><p><a href="https://cs.uwaterloo.ca/research/tr/1986/CS-86-14.pdf" target="_blank" rel="noopener">Пейпер</a> с описанием метода, там же есть сравнение с методом Брента (стр 51-53) — чуть более быстрая вставка, за счет немного медленного среднего времени поиска, но более быстрая проверка несуществующего элемента. Позволяет заполнять таблицы на 90% перед тем, как увеличивать объём.</p><p>Логика вставки — если для уже сохраненного в слоте элемента расстояние до его идеальной позиции меньше, чем для нового, то “выселяем” элемент из слота, и проверяем дальше, с кем можно переставить его (“забираем позицию у богатого элемента и отдаём бедному”). <a href="http://web.stanford.edu/class/archive/cs/cs166/cs166.1196/lectures/13/Slides13.pdf" target="_blank" rel="noopener">Пример вставки</a></p><p>Описание в <a href="https://cglab.ca/~abeinges/blah/robinhood-part-1/" target="_blank" rel="noopener">Rust</a>:</p><ul><li>Линейное хеширование с перестановкой Робин Гуда</li><li>Рост таблицы после заполненности 0.9 в 2 раза</li><li>Хеш-функция с уникальным сидом для каждой таблицы для защиты от неудачной вставки ключей в порядке увеличения хеш-значений</li></ul><p><a href="https://github.com/skarupke/flat_hash_map" target="_blank" rel="noopener">ska::flat_hash_map</a>:</p><ul><li>Линейное хеширование с перестановкой Робин Гуда</li><li>Рост таблицы при первом длинном неудачном пробировании, до следующего prime number</li></ul><p><a href="https://probablydance.com/2017/02/26/i-wrote-the-fastest-hashtable/" target="_blank" rel="noopener">I Wrote The Fastest Hashtable</a> - описание<br>Используются для внутренних структур данных в <a href="https://github.com/GaijinEntertainment/daScript/blob/dcecc6f126843fc0914b0be314542caa658fc8d6/include/daScript/das_config.h#L34" target="_blank" rel="noopener">daScript</a><br>[5] - доклад автора о влиянии отдельных приёмов оптимизации (крутое объяснение форм графиков, можно прикинуть свои паттерны и размеры таблиц), сравнение с различными реализациями хеш карт и хинты реализации</p><h2 id="Бенчмарки"><a href="#Бенчмарки" class="headerlink" title="Бенчмарки"></a>Бенчмарки</h2><p>Несколько бенчмарков различных C++ реализаций, с описанием типов таблиц:<br><a href="https://martin.ankerl.com/2016/09/15/very-fast-hashmap-in-c-part-1/" target="_blank" rel="noopener">https://martin.ankerl.com/2016/09/15/very-fast-hashmap-in-c-part-1/</a><br><a href="https://martin.ankerl.com/2019/04/01/hashmap-benchmarks-01-overview/" target="_blank" rel="noopener">https://martin.ankerl.com/2019/04/01/hashmap-benchmarks-01-overview/</a><br><a href="https://martin.ankerl.com/2022/08/27/hashmap-bench-01/" target="_blank" rel="noopener">https://martin.ankerl.com/2022/08/27/hashmap-bench-01/</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Небольшой обзор типов хеш-таблиц, которые чаще всего встречаются в языках программирования.&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="dev" scheme="http://spiiin.github.io/tags/dev/"/>
    
  </entry>
  
  <entry>
    <title>Making tools for big games</title>
    <link href="http://spiiin.github.io/blog/2767873544/"/>
    <id>http://spiiin.github.io/blog/2767873544/</id>
    <published>2022-12-25T14:57:07.000Z</published>
    <updated>2022-12-25T17:51:51.467Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Тезисы из доклада технического директора <code>Guerilla</code> Michiel van der Leeuw <a href="https://www.guerrilla-games.com/read/making-tools-for-big-games" target="_blank" rel="noopener">Making tools for big games</a></p><a id="more"></a><p><strong><code>Вступление</code></strong></p><ul><li>Технология в геймдеве перестала определять игру и её геймдизайн, а является одной из фич игры</li><li>Технология сейчас — это не только движок игры, а её тулсет</li><li>Тулсет позволяет поддерживать масштабирование количества контента игр, а также следить за качеством и процессом производства</li><li>Респект автора доклада <code>Naughty Dog</code>, часть идей оттуда</li></ul><p><strong><code>Идея 1. Сокращение &quot;зоны сумерек&quot;, когда QA находятся между игрой, таск-трекером, браузером, vcs, мессенджером и почтовым клиентом</code></strong></p><ul><li>Кастомный интерфейс к vcs, шаблоны для заполнения полей близкие к стандартам компании</li><li>Соединение перед пуллом с билд сервером для сверки, в порядке ли ревизия, которую собираешься получить</li><li>In-game gui для оформления задач в Jira — запись видео, логгирование игровых ресурсов в кадре</li><li>Редактор видео, в котором можно отметить тайминг бага/задачи, связанные ассеты, разметить зоны и отрезать лишнее. Ссылки на фрейм видео можно добавлять в задачи</li><li>Ассеты хранятся в базе данных с метаинформацией. Среди прочего, хранят обратные ссылки на баги, ссылающиеся на эти ассеты.</li></ul><p>Выявить точки, из которых удобнее всего совершать действия, и из этих точек с помощью api к другим приложениям дать возможность работать с этими приложениями без переключения контекста. Убрать рутину.<br>Пара бонусных идей не из доклада:</p><ul><li>В code-review вычислять, какие из прошлых коммитов/мердж реквестов затрагивает диф кода и выводить список этих коммитов (“чей код ты потенциально мог сломать”).</li><li>Подтягивать к багу в Jira данные из всех систем аналатики (доступ ко всей полезной инфе на одной страничке)</li></ul><p><strong><code>Идея 2. Слежение за здоровьем билда позволяет увеличить количество итераций</code></strong></p><ul><li>Бот-фермы из девкитов, которые выполняют скрипты телепортации по миру и сохраняют профилирование, телеметрию и игровую информацию в виде карты мира, отдельный редактор для визуализации и изучения этой карты</li><li>Примеры применения — визуализатор информации для гейм-дизайнеров и непосредственно отладка геометрических данных (карты рек, эрозии, нормалей, карты видимости неба), heat-map тормозящих мест, визуализация мест багов в jira. Всю информацию можно посмотреть в других местах, но такое картографирование позволяет оценить общую картину</li><li>Запросы к данным для отображения на карте исторических данных (диффы, графики, экспорт в json/csv)</li><li>Вьюер карты тесно связан с игрой (можно получать графики производительности с девайсов и кол-во потребляемой памяти, а также делать отметки на графиках и ссылаться на них)</li><li>Метрика — количество изменений, которое команда может позволить себе без страха делать в последние дни/недели перед релизом</li></ul><p><a href="/blog/1687824628/" title="Паттерны организации разработки уровней игр">Паттерны организации разработки уровней игр</a> - итерации делают игру лучше, упрощая процесс разработки<br><a href="/blog/3309518526/" title="Системы поиска сокровищ">Системы поиска сокровищ</a> - итерации кроме полировки могут позволить найти новые уникальные решения</p><p>Глобальная карта для отображения оверлеями различной информации — отличный инструмент, кажется, впервые видел идею с тепловой картой производительности еще в докладе про <code>starcraft 2</code>. Я такое тоже делал, чтобы отслеживать ассеты, которые артисты/геймдизайнеры забыли правильно разметить.</p><p><strong><code>Идея 3. Работу с ассетами всегда можно улучшить</code></strong></p><ul><li>Всё висит на сервере в памяти и стримится на девелоперские машины (10 Gb сеть в локалке)</li><li>Позволило серьёзно уменьшить размер дубликатов ресурсов</li><li>Можно сгенерить строковый айдишник, по которому другой человек может запустить в точности такую же версию игры</li><li>Самописный сервер на 650 строк, БД с парами ключ значение, быстрее шеринг через SMB, NFS, файловый сервер Apache, etc</li><li>Виртуальная файловая система, ОС не видит изменений</li><li>18 core cpu, 768 Gb ram, 80 Gb network, 16 tb ssd на 300 человек</li></ul><p>Наиболее радикальная идея, работать локально с исходными версиями ассетов, и стримить ресурсы через глобальный общий сервер. Доклад 2019 года, когда все сидели в одном офисе, но в <a href="https://twitter.com/MvdLeeuwGG/status/1606268200143970304" target="_blank" rel="noopener">твиттере</a> автор упоминает, что адаптировали и для домашней работы. Кроме блоба ассета хранится также метаинформация (например, ссылки, в каких тасках он задействован).</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Тезисы из доклада технического директора &lt;code&gt;Guerilla&lt;/code&gt; Michiel van der Leeuw &lt;a href=&quot;https://www.guerrilla-games.com/read/making-tools-for-big-games&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Making tools for big games&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="link" scheme="http://spiiin.github.io/tags/link/"/>
    
      <category term="dev_method" scheme="http://spiiin.github.io/tags/dev-method/"/>
    
  </entry>
  
  <entry>
    <title>daScript tiny renderer port</title>
    <link href="http://spiiin.github.io/blog/3563373441/"/>
    <id>http://spiiin.github.io/blog/3563373441/</id>
    <published>2022-12-25T14:02:28.000Z</published>
    <updated>2022-12-25T14:31:25.242Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Портировал первые несколько примеров <a href="https://github.com/ssloy/tinyrenderer/wiki" target="_blank" rel="noopener">Tiny renderer or how OpenGL works: software rendering in 500 lines of code</a> софт-рендера с C++ на daScript. Механически и неоптимально, но близко к коду оригинального туториала, для желающих потренироваться в базовых алгоритмах растеризации на daScript.<br><a href="https://github.com/spiiin/dascript_soft_render" target="_blank" rel="noopener">https://github.com/spiiin/dascript_soft_render</a></p><p>Растеризация отрезков, wireframe<br><img src="/blog/3563373441/1.png" alt=""><br>Растеризация треугольников line sweeping, flat shading, отсечение задних граней<br><img src="/blog/3563373441/2.png" alt=""><br>Z-буфер, наложение текстурных координат<br><img src="/blog/3563373441/3.png" alt=""><br>Перспективная проекция<br><img src="/blog/3563373441/4.png" alt=""><br>Камера, Gouraud shading<br><img src="/blog/3563373441/5.png" alt=""><br>Коррекция перспективных искажений текстурных координат, растеризация треугольника проверкой барицентрических координат точки, пиксельный и вершинный шейдеры<br><img src="/blog/3563373441/6.png" alt=""></p><p>В оригинале есть ещё детальный разбор матриц (model, view, projection), наложение карты нормалей, тени и ambient occlusion. Но, мне кажется где-то с этого уровня можно продолжать разбираться с графикой уже с помощью графического API.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;Портировал
      
    
    </summary>
    
    
    
      <category term="opengl" scheme="http://spiiin.github.io/tags/opengl/"/>
    
      <category term="3d" scheme="http://spiiin.github.io/tags/3d/"/>
    
      <category term="dascript" scheme="http://spiiin.github.io/tags/dascript/"/>
    
  </entry>
  
  <entry>
    <title>Итоги 2021-2022</title>
    <link href="http://spiiin.github.io/blog/2738337723/"/>
    <id>http://spiiin.github.io/blog/2738337723/</id>
    <published>2022-11-28T11:59:06.000Z</published>
    <updated>2022-12-16T18:39:17.161Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Сумбурная попытка собрать в кучу события в жизни за 2 года. В конце 2021 не успел, в начале 2022 уже как-то не до того было. Допишу понемногу как раз к новому году.</p><a id="more"></a><p>Предыдущая - <a href="/blog/307513906/" title="Итоги 2020">Итоги 2020</a></p><p><strong><code>Дисклеймер</code></strong></p><p>Очень не хочется писать про войну, слишком сложно и больно написать что-то коротко. Поэтому, в основном, просто списки из нескольких запомнившихся книг/игр/посещенных стран etc с небольшими заметками</p><p><strong><code>Личное/путешествия</code></strong></p><p>В начале 2021 года накрыло выгоранием от работы, одновременно с ощущением, “надо развиваться, иначе пиздец” и питерской простудой (это которая потом может привести к больному зубу и гаймариту). Ушёл в длинный отпуск, лечиться, читать книжки и медитировать над тем, где пропустил важный поворот. Попутно женился (снова с поездкой в Крым и отдыхом в Многоречье, Евпатории и Балаклаве), наконец продал старый дом в Бахчисарае, доставшийся в наследство много лет назад, и слетал отдохнуть в Калинград с коллегами.<br><img src="/blog/2738337723/photo1.png" alt=""></p><p>Охта-парк в последние выходные в Питере<br><img src="/blog/2738337723/ohta.png" alt=""></p><p>2022-й год — внезапный “развесёлый” трип (безвозвратная релокация) Самарканд-Стамбул-Ереван.<br><img src="/blog/2738337723/photo2.png" alt=""></p><p>Армения очень гостеприимная страна, с множеством как официальных достопримечательностей, так и <a href="https://www.wirade.ru/cgi-bin/wirade/YaBB.pl?board=stories;action=display;num=1086946148" target="_blank" rel="noopener">маленьких</a> мест и историй. Особенно порадовал Дилижан и окрестности. Успел слетать в Анталию в отпуск и в Дубаи и Пхукет в командировку. Так что год выдался богатым на поездки и ощущения.<br><img src="/blog/2738337723/photo3.png" alt=""></p><p>В конце года оказался в Израиле. Если Армения почти не отличалась по флоре и фауне от Украины и России, то тут на деревьях можно увидеть попугаев, ночью — больших летающих мышей (точнее, даже летающих лисиц), и кабанов, разгуливающих по городу. Бросаются в глаза и отличия в ценах и порядках. Другой мир со своими правилами.<br><img src="/blog/2738337723/photo4.png" alt=""></p><p><strong><code>Работа</code></strong></p><p>За пару лет побыл тим-лидом, разработчиком движка и техническим продюсером. Кроме плюсов в виде большого количества контактов и понимания процессов работы компании, существуют и минусы такого движения — “шлейф” переходов излишне расширяет зоны ответственности, необходимо явно “отвязываться” от прошлых обязанностей.</p><p>Снова запустили софт-ланч матч-3 игры - <a href="https://mytona.com/game/15" target="_blank" rel="noopener">Tasty Makeover</a><br><img src="/blog/2738337723/tmo.png" alt=""></p><p>Получил на память серебрянный значок<br><img src="/blog/2738337723/mytona.png" alt=""></p><p><strong><code>Музыка</code></strong><br><code>Piazzolla - Libertango</code><br><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/elYSQkTWfTw" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div><br>Пьяццолла удивительным образом стимулирует творческое настроение, подсмотрел у авторов “Worlds of Goo”</p><p><code>Dave Stewart, Boris Grebenshikov &amp; Serhii Babkin - Face to Face (feat. Stevie Nicks)</code><br><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/dRFIoyeU_bg" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div><br>Сергей Бабкин — это гитарно-дворовое регги из детства, а у Бориса Гребенщикова, кроме музыки, попадалась еще хорошая инструкция по медитации.</p><p><code>The Death Set - They Come to Get Us</code><br><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/dleV9-9xXsw" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div><br>Немного драйва десятилетней давности.</p><p><code>DakhaBrakha - Carpathian rap</code><br><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/OKhV3kLTTv8" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div><br>Видеоряд и мистика.</p><p><code>Selena Gomez, Rauw Alejandro - Baila Conmigo</code><br><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/h5WN3pkxPF0" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></p><p><strong><code>Игры</code></strong></p><p><code>- Divinity Original Sin 2 (Switch)</code><br>Красивая и интересная тактика, в которой можно позалипать в дизайн локаций. Очень много часов геймплея, хорошая адаптация управления под консоль. Рассчитана явно на пару прохождений (физическая и магическая партия). Много подготовки — обновление ассортимента оружия на каждый уровень партии, необходимость “пылесосить” локации, с возможностью полной зачистки лагерей или даже деревень.<br><code>- Monster Hunter: Rise (Switch)</code><br>Необычная смесь RPG с элементами файтинга (различные комбо для различного оружия), крутое взаимодействие с окружением (набор бустов перед боем, изучение фишек локаций). Не очень понравился переход из сингл-плейера в мульти-плейер — одиночный сюжет просто обрывается, без возможности посмотреть и победить самых сильных боссов.<br><code>- Civilization 6 (Switch/PC)</code><br>Эмерджентные механики, которые расширяют возможности геймплея в дополнительных правилах и нациях. Геймплей с дополнениями и без сильно отличается. Хорошая кривая обучения игре — интересно играть как в первый раз, так и в сотый, обучаясь нюансам механик.<br><code>- C&amp;C Rivals (iOS/Android)</code><br>Игра в жанре Clash Royale, тактическая RTS с элементами карточной игры. Юниты более-менее сбалансированы, большинство из них требует микроконтроля для полноценной реализации их в бою. Вызвала хейт фанатов серии из-за забивания на лор, но тем не менее, необычный и самобытный проект.<br><code>- Risen 3 (PC)</code><br>Моё первое знакомство с играми Pyranha Bytes и их подходу к разработке игр. Ну и пиратский сеттинг всегда приятно увидеть.<br><code>- Axie Infinity (PC/Android/iOS)</code><br>NFT-игра, притом не pay-to-win, скорее похожая по стратегии игры на покер (а вообще — безумная смесь тактики, кки и покемонов). Заодно и понятны опасности экономик подобного типа игр — баловство разработчиков с балансом, от нерфа карт в середине сезона, до выпуска новых типов предметов, или вообще выпуска альтернативной игры со сменой всех механик; взломы кошельков с хранилищем крипты, возможность общего обрушения игры; часть экономики, зависимая от привлечения новых игроков в игру. Тем не менее, в предыдущей версии — могла затянуть на несколько ночей в построение идеальных команд с тетрадкой, ручкой и экселем. Заслуживает отдельной статьи.<br><img src="/blog/2738337723/axie.png" alt=""><br><code>- Valheim</code><br>Хардкорная выживалка-песочница про викингов, с необычной графикой. Простые и низкодетализированные текстуры (если верить книге “Понимание комиксов” — менее детализированное окружение = меньшая враждебность в восприятии игрока) и прикольные эффекты и звук создают интересное восприятия локаций.<br><code>-TMNT: Shredder’s Revenge (PC/Switch)</code><br>Идеальный beat-them-up для игры на двоих и более черепашек.<br><code>- Candy Crush/Homescapes/Royal Match (iOS/Android)</code><br>Профессиональное изучение жанра<br><code>- Disco Elisium (PC)</code><br>Классный русский перевод и одна из лучших РПГ, в которых можно действительно отыграть поведение<br><code>- Hades (PC)</code><br>Отличный пример дизайна — встраивание механики развития и сюжета в рогалик, эмерджентные механики комбинаций оружия и бонусов, нарративная связь кор-геймплея и меты, сюжетный путь героя<br><code>- Witcher 1-2 (PC)</code><br>По прежнему крутые для фанатов, особенно в сочетании с книгами и третьей частью. В том числе и основной линией сюжета, которая продолжает историю из книг и дает возможность повлиять на судьбу персонажей.<br><img src="/blog/2738337723/witcher1.png" alt=""><br><img src="/blog/2738337723/witcher2.png" alt=""><br><a href="https://www.dropbox.com/sh/kwgasmi89f4su3q/AABinxk2WKfun6rNulXrX6Tka?dl=0" target="_blank" rel="noopener">Больше моих скриншотов</a> из всех трёх “ведьмаков”.</p><p>Традиционно заканчиваю год просмотром треда со скриншотами из игр на neogaf, <a href="https://www.neogaf.com/threads/2022-pc-screenshot-thread-of-no-compromises.1626951/" target="_blank" rel="noopener">2022 год</a> (и <a href="/blog/2486469456/" title="прошлые">прошлые</a>). Лучше всего характеризует этот год:<br><a href="https://live.staticflickr.com/65535/52090974365_3ec1d1b1db_o.jpg" target="_blank" rel="noopener"><img src="/blog/2738337723/jump.png" alt=""></a></p><p><strong><code>Книги</code></strong></p><p>Из нетехнического:</p><p><code>- Никулин Н., &quot;Воспоминания о войне&quot;</code><br>Реальность и ужасы войны.<br><code>- Нил Шубин, &quot;Внутренняя рыба&quot;</code><br>Про то, как млекопитающие выходили на сушу. И про то, что человек — перестроенная рыба, что до сих пор прослеживается в особенностях строения, и иногда в болезнях.<br><code>- Уилсон Э., &quot;Планета муравьев&quot;</code><br>Особенности муравьиного общества<br><code>- Даррелл Дж., &quot;Гончие Бафута&quot;, &quot;Под пологом пьяного леса&quot;</code><br><a href="https://vas3k.club/post/9639/" target="_blank" rel="noopener">Даррелл</a> — человек, который занимался своим делом, несмотря на происходящие в мире события — войны, революции. Что бы ни происходило вокруг, он собирал животных во всех уголках земли.<br><code>- Кристофер Александер, &quot;Язык шаблонов&quot;, &quot;Timeless way to building&quot;</code><br>Интересно было изучить как минимум потому, что на книги Александера часто ссылается в книге и докладах Джесси Шелл. Ну и как сам способ выделения паттернов из общего, что можно использовать не только в архитектуре, но в и программировании.</p><p>Из технического:</p><p><a href="/blog/37481721/" title="О книгах и самообразовании">О книгах и самообразовании</a> — много всякого. Старые книги о программировании, новых языках программирования, книги и доклады за последние годы по геймдеву, всё до чего удалось дотянуться по геймдизайну, немного о продюссировании игр и психологии.</p><p><strong><code>Фильмы</code></strong></p><p><code>- Эдди &quot;Орёл&quot;</code><br>Рассказ про отбитого прыгуна с трамплина на лыжах, который нашёл баг в правилах, и выступил на олимпиаде, не заморачиваясь общественным мнением. <a href="https://ru.wikipedia.org/wiki/%D0%AD%D0%B4%D0%B2%D0%B0%D1%80%D0%B4%D1%81,_%D0%AD%D0%B4%D0%B4%D0%B8" target="_blank" rel="noopener">Эдди Эдвардс</a>, много интересных фактов из биографии.<br><code>- Серьёзный человек</code><br>Черная комедия, нарушаюшая закон кино о том, что у совпадений должно быть какое-нибудь объяснение<br><code>- Душа</code><br>Мультик о поиске смысла и цели в жизни<br><code>- Терминал</code><br>Искренне сочувствуешь персонажу только в случае, когда понимаешь, что оказаться в подобной ситуации вполне реально<br><code>- Курс лекций Tymoty Snider по истории Украины</code><br>Бесплатные <a href="https://www.youtube.com/playlist?list=PLh9mgdi4rNewfxO7LhBoz_1Mx1MaO6sw_" target="_blank" rel="noopener">лекции</a> Йельского университета 2022 года. Интересно сравнить с российским и украинским видением истории страны.</p><p><strong><code>Приобретения</code></strong><br>iPad чтобы смотреть фильмы и читать комиксы и пачка low-end телефонов на андроиде для исследований багов и оптимизаций игр. Но в основном вспоминаются потери оставленного при переезде =\</p><p><strong><code>Развитие</code></strong><br>Изучил <code>историю C++</code> и <code>подхода ООП (в smalltalk)</code>, немного глубже вник в <code>STL</code> и библиотек <code>boost</code>, наконец посмотрел на относительно новые языки (<code>nim</code>, <code>go</code>, <code>racket</code>, <code>daScript</code>). Особенно заинтересовал <a href="https://spiiin.github.io/tags/dascript/">daScript</a> огромным потенциалом и заложенными в него идеями.</p><p>Прокачал немножко экспертизу в геймдеве в общем, занялся английским (с мотивацией делать это сильно проще, чем просто ради изучения), и прочитал несколько книг по истории.</p><p>Немного практиковался в жонглировании на скорость, получилось придумать, как прокачать каскад до <a href="https://youtu.be/VoyR2o0W5T8" target="_blank" rel="noopener">402 бросков в минуту</a> — не <a href="https://youtu.be/MDnMhMTekI0?t=128" target="_blank" rel="noopener">мировой рекорд</a>, но уже <a href="https://www.youtube.com/watch?v=Hd6Du2bYcRo" target="_blank" rel="noopener">быстрее всех</a> в России. Обнаружил у себя <a href="https://vas3k.club/post/1412/" target="_blank" rel="noopener">афантазию</a> (на самом деле, правильнее называть это “а-визуализацией”, с фантазией всё в порядке) — невозможность видеть образы с закрытыми глазами. Очень необычно осознать себя ощущающим мир не так, как большинство людей.</p><p><img src="/blog/2738337723/kfox.png" alt=""><br><em>Нейронные сети изображают играющих лис</em></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Сумбурная попытка собрать в кучу события в жизни за 2 года. В конце 2021 не успел, в начале 2022 уже как-то не до того было. Допишу понемногу как раз к новому году.&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="log" scheme="http://spiiin.github.io/tags/log/"/>
    
  </entry>
  
  <entry>
    <title>Уровень программирования: Senior++</title>
    <link href="http://spiiin.github.io/blog/1976052536/"/>
    <id>http://spiiin.github.io/blog/1976052536/</id>
    <published>2022-11-21T09:16:32.000Z</published>
    <updated>2022-12-21T13:26:37.211Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Предыдущая пачка:<br><a href="/blog/1048/" title="Как устроиться на работу программистом">Как устроиться на работу программистом</a><br><a href="/blog/15798/" title="Уровень программирования: Middle">Уровень программирования: Middle</a><br><a href="/blog/3652741154/" title="10 лет в геймдеве">10 лет в геймдеве</a><br><a href="/blog/258274191/" title="Уровень программирования: Senior">Уровень программирования: Senior</a></p><p>Качается всё то же, что и на предыдущем “уровне” — накопление критической массы знаний, и попытки их систематизировать.</p><p><img src="/blog/1976052536/fin.png" alt=""></p><h2 id="Миф"><a href="#Миф" class="headerlink" title="Миф"></a>Миф</h2><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/6_OUwXl8T_Y?start=981%2C" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div><p>Misha Nestor - Антропологический менеджмент и лидерство</p><p>Миф — не о поиске магии или мистике, а о совпадении ценностей и поиске смыслов.</p><img style="background-color:white;text-align:center;" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTg5IiBoZWlnaHQ9IjM0MSIgdmVyc2lvbj0iMS4xIiBiYXNlUHJvZmlsZT0iZnVsbCIgdmlld2JveD0iMCAwIDE4OSAzNDEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHhtbG5zOmV2PSJodHRwOi8vd3d3LnczLm9yZy8yMDAxL3htbC1ldmVudHMiIHN0eWxlPSJmb250LXdlaWdodDpib2xkOyBmb250LXNpemU6MTJwdDsgZm9udC1mYW1pbHk6J0NhbGlicmknLCBIZWx2ZXRpY2EsIHNhbnMtc2VyaWY7O3N0cm9rZS13aWR0aDozO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbGluZWNhcDpyb3VuZCI+PHBhdGggZD0iTTk1IDQ0LjUgTDk1IDY0LjUgTDk1IDg0LjUgTDk1IDg0LjUgIiBzdHlsZT0ic3Ryb2tlOiMzMzMyMkU7ZmlsbDpub25lO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTsiPjwvcGF0aD4KPHBhdGggZD0iTTg5LjcgNzEuMiBMOTUgNzcuOCBMMTAwLjMgNzEuMiBMOTUgODQuNSBaIiBzdHlsZT0ic3Ryb2tlOiMzMzMyMkU7ZmlsbDojMzMzMjJFO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTsiPjwvcGF0aD4KPHBhdGggZD0iTTk1IDExNS41IEw5NSAxMzUuNSBMOTUgMTU1LjUgTDk1IDE1NS41ICIgc3R5bGU9InN0cm9rZTojMzMzMjJFO2ZpbGw6bm9uZTtzdHJva2UtZGFzaGFycmF5Om5vbmU7Ij48L3BhdGg+CjxwYXRoIGQ9Ik04OS43IDE0Mi4yIEw5NSAxNDguOCBMMTAwLjMgMTQyLjIgTDk1IDE1NS41IFoiIHN0eWxlPSJzdHJva2U6IzMzMzIyRTtmaWxsOiMzMzMyMkU7c3Ryb2tlLWRhc2hhcnJheTpub25lOyI+PC9wYXRoPgo8cGF0aCBkPSJNOTUgMTg2LjUgTDk1IDIwNi41IEw5NSAyMjYuNSBMOTUgMjI2LjUgIiBzdHlsZT0ic3Ryb2tlOiMzMzMyMkU7ZmlsbDpub25lO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTsiPjwvcGF0aD4KPHBhdGggZD0iTTg5LjcgMjEzLjIgTDk1IDIxOS44IEwxMDAuMyAyMTMuMiBMOTUgMjI2LjUgWiIgc3R5bGU9InN0cm9rZTojMzMzMjJFO2ZpbGw6IzMzMzIyRTtzdHJva2UtZGFzaGFycmF5Om5vbmU7Ij48L3BhdGg+CjxwYXRoIGQ9Ik05NSAyNTcuNSBMOTUgMjc3LjUgTDk1IDI5Ny41IEw5NSAyOTcuNSAiIHN0eWxlPSJzdHJva2U6IzMzMzIyRTtmaWxsOm5vbmU7c3Ryb2tlLWRhc2hhcnJheTpub25lOyI+PC9wYXRoPgo8cGF0aCBkPSJNODkuNyAyODQuMiBMOTUgMjkwLjggTDEwMC4zIDI4NC4yIEw5NSAyOTcuNSBaIiBzdHlsZT0ic3Ryb2tlOiMzMzMyMkU7ZmlsbDojMzMzMjJFO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTsiPjwvcGF0aD4KPHJlY3QgeD0iMTMuNSIgeT0iMTMuNSIgaGVpZ2h0PSIzMSIgd2lkdGg9IjE2MyIgc3R5bGU9InN0cm9rZTojMzMzMjJFO2ZpbGw6I2VlZThkNTtzdHJva2UtZGFzaGFycmF5Om5vbmU7Ij48L3JlY3Q+Cjx0ZXh0IHg9IjIxLjUiIHk9IjM1IiBzdHlsZT0iIj7QvNC40YQg0L4g0YHQtdCx0LU8L3RleHQ+CjxyZWN0IHg9IjE1LjUiIHk9Ijg0LjUiIGhlaWdodD0iMzEiIHdpZHRoPSIxNjAiIHN0eWxlPSJzdHJva2U6IzMzMzIyRTtmaWxsOiNlZWU4ZDU7c3Ryb2tlLWRhc2hhcnJheTpub25lOyI+PC9yZWN0Pgo8dGV4dCB4PSIyMy41IiB5PSIxMDYiIHN0eWxlPSIiPtC+0LrRgNGD0LbQtdC90LjQuDwvdGV4dD4KPHJlY3QgeD0iMjMuNSIgeT0iMTU1LjUiIGhlaWdodD0iMzEiIHdpZHRoPSIxNDQiIHN0eWxlPSJzdHJva2U6IzMzMzIyRTtmaWxsOiNlZWU4ZDU7c3Ryb2tlLWRhc2hhcnJheTpub25lOyI+PC9yZWN0Pgo8dGV4dCB4PSIzMS41IiB5PSIxNzciIHN0eWxlPSIiPtC60L7QvNC/0LDQvdC40Lg8L3RleHQ+CjxyZWN0IHg9IjIzLjUiIHk9IjIyNi41IiBoZWlnaHQ9IjMxIiB3aWR0aD0iMTQ0IiBzdHlsZT0ic3Ryb2tlOiMzMzMyMkU7ZmlsbDojZWVlOGQ1O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTsiPjwvcmVjdD4KPHRleHQgeD0iMzEuNSIgeT0iMjQ4IiBzdHlsZT0iIj7QvtCx0YnQtdGB0YLQstC1PC90ZXh0Pgo8cmVjdCB4PSI1NS41IiB5PSIyOTcuNSIgaGVpZ2h0PSIzMSIgd2lkdGg9IjgwIiBzdHlsZT0ic3Ryb2tlOiMzMzMyMkU7ZmlsbDojZWVlOGQ1O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTsiPjwvcmVjdD4KPHRleHQgeD0iNjMuNSIgeT0iMzE5IiBzdHlsZT0iIj7QvNC40YDQtTwvdGV4dD48L3N2Zz4=" /><p><a href="/blog/1363625753/" title="Мотивация &quot;честного&quot; программиста">Мотивация &quot;честного&quot; программиста</a> — мои поиски профессионального личного мифа.</p><p>Основная идея — современное общество вокруг дисциплинарное, и “миф по умолчанию” для компаний — фабрика, серийное производство, в котором люди становятся похожи на механизмы. В таких условиях многим становится некомфортно, что не способствует ни творческой работе, ни выкладыванию на творческий максимум (в понятиях фабрики более ценится “средняя”, но предсказуемая работа). Один из способов работать в таких условиях — осознанное слежение за уровнем комфорта вокруг рабочих процессов.</p><p><a href="/blog/1152742413/" title="Города, которые мы выбираем">Города, которые мы выбираем</a> — миф о компании и обществе.<br>На нас сильно влияет среда вокруг — пространство и информационный фон. Люди с общей идеей собираются в определенных местах, и в таких местах возможна передача знаний и идей. Чтобы “загореться” разумом, необходимо чтобы кто-то из других людей вокруг уже горел. Ребёнок, воспитанный животными, после определенного возраста, не сможет интегрироваться в общество людей. Также и с более продвинутыми знаниями — не получив культурный импринт, невозможно рассуждать о сложных вещах, хотя возможно пытаться повторить их с помощью карго-ритуалов.</p><p>При повышении роли в компании часто отсутствует схема ритуала/инициации/личного кризиса, сопутствующего “переходу”. Из-за этого человек либо проходит это сам, либо за ним тянется “шлейф” предыдущих обязанностей/форм работы.</p><p><em>Материалы — Джесси Шелл, Кристофер Александер, Джозеф Кэмпбелл, Алан Кэй, Рич Хики, Пол Грем</em></p><h2 id="Карты-знаний"><a href="#Карты-знаний" class="headerlink" title="Карты знаний"></a>Карты знаний</h2><p>Прежде чем накапливать и систематизировать знания, можно “осмотреться”, как рассуждают о знаниях/скиллах другие.</p><p><strong>Примеры матрицы/графа/списка материалов и компетенций</strong><br><a href="https://github.com/miloyip/game-programmer" target="_blank" rel="noopener">A study path for game programmer</a> — материалы из нескольких областей для геймдев-программиста, разделены на основные и дополнительные.<br><a href="https://tlroadmap.io/guide.html" target="_blank" rel="noopener">Teamlead Roadmap</a> — роадпам тимлида. Сумма компетенций тимлида по опросам российских IT-компаний. Обязанностей где-то на 2-3 людей, упор на скиллы лида, менеджера, cto (как “директора программистов”), а не технические скиллы<br><a href="https://sijinjoseph.netlify.app/programmer-competency-matrix/" target="_blank" rel="noopener">Programmer Competency Matrix</a> — схема оценки навыков программиста. Очень странный выбор примеров знаний, но иллюстрирует экпоненциальный рост знаний с переходом на каждый новый уровень</p><p><strong>Списки книг</strong><br><a href="https://30minbooks.livejournal.com/11011.html" target="_blank" rel="noopener">Список книг от Алана Кея</a> — список рекомандаций для студентов CS. Часто, если смотреть выступления Кея, можно понять, что он рекомендует не книгу, а какую-то конкретную идею в ней.<br>Другие варианты — разобрать список интересной рекомендуемой литературы в любой серьёзной книге (одной-двух) — в качестве примеров: <strong><code>&quot;Книга линз&quot; Джесси Шелла</code></strong> и <strong><code>&quot;Архитектура Игрового движка&quot; Джейсона Грегори</code></strong>.<br><a href="/blog/3649678047/" title="Путь гейм-дизайнера">Путь гейм-дизайнера</a> — мой граф по Джесси Шеллу.</p><p><strong>Примеры вопросов на собеседованиях в геймдев-компании</strong><br><a href="https://web.archive.org/web/20191006063124/http://blog.gamedeff.com/?p=64" target="_blank" rel="noopener">Интервью глазами пострадавшего</a> — образец интервью из 2007, Midway Home Entertaiment<br><a href="Interviewing for Game Programming">Interviewing for Game Programming</a> — более свежий образец, примерно такого же уровня</p><p><strong>Варианты того, что можно и нужно изучать</strong><br>(список направлений для геймдева, навскидку)</p><ul><li>render</li><li>железо, особенности архитектуры, проц/память/видео</li><li>популярные движки unity/unreal/godot</li><li>dod/ecs</li><li>llvm/libclang и инфраструктура</li><li>multithreading/async программирование</li><li>unreal blueprints, визуальное программирование</li><li>скриптовые языки daScript/lua-jit</li><li>идеи в языках go/rust/closure/scala/nim/zig/racket</li><li>внутренности библиотек stl/boost, структуры данных</li><li>gamedev-specific математика и алгоритмы</li><li>тулзы git/серверы сборки/системы задач/cd-ci и прочее</li><li>пайплайны работы, устройство организаций, agile/lean/scrum</li><li>способы генерации арта</li><li>сеть, звук, системы анимаций, ии в играх, компрессия, форматы данных etc etc etc</li></ul><p><strong>Примеры видения сотрудников от компаний</strong><br><a href="http://media.steampowered.com/apps/valve/hbook-RU.pdf" target="_blank" rel="noopener">Valve</a>, <a href="https://www.dropbox.com/s/0z2p0qokdmm6eaw/Roblox%20Rendering%20-%20Career%20Guide%20v1.1public.pdf?dl=0" target="_blank" rel="noopener">Roblox</a>, <a href="https://www.gameenginebook.com/resources/SINFO.pdf" target="_blank" rel="noopener">Naughty Dog</a>, <a href="https://aras-p.info/texts/files/201410-TUM-HobbyEngineToGameEngine.pdf" target="_blank" rel="noopener">Unity</a>, разделение программистов в <a href="https://youtu.be/9nB_8LDaEVE?t=705" target="_blank" rel="noopener">IO Inreractive/Square Enix</a> от Bobby Anguelov.</p><p>Можно использовать для обнаружения пробелов в знаниях для того, чтобы их заполнять в свободное время, карьерного планирования, а также для обнаружения интересных “зацепок” в культуре других компаний.</p><h2 id="Как-и-зачем-заниматься-самообразованием"><a href="#Как-и-зачем-заниматься-самообразованием" class="headerlink" title="Как и зачем заниматься самообразованием"></a>Как и зачем заниматься самообразованием</h2><p><a href="/blog/37481721/" title="О книгах и самообразовании">О книгах и самообразовании</a> - про свой способ чтения книг, а также развернуто зачем заниматься самообразованием.</p><p>Соберу и дополню список возможных ответов “зачем”:</p><ul><li>несмотря на то, что на работе знания могут не понадобится сейчас или в ближайшем будущем, они попадут в список скиллов (“тебя не будут просить делать то, что ты умеешь плохо”)</li><li>над тобой всегда есть несколько уровней развития, которых ты не видишь с текущего (парадокс блаба)</li><li>шанс найти инсайты в соседних областях, которые не изучены в твоей области (либо получить синергию знаний от двух направлений)</li><li>возможность оценить компетенции коллег и руководства (или кандидатов при подборе команды), а также улучшить возможности профессионального взаимодействия</li><li>возможность делать новые для себя или более крутые вещи, которые не умел делать раньше</li><li>знание и понимание rocket-science решений</li><li>обнаружение готовых решений, умение их оценить, видеть весь спектр возможных решений (антибиблиотека Умберто Эко)</li><li>возможность учиться идеям у лучших (“поджечь свой факел разума от уже горящих”)</li><li>обойти грабли, на которые уже наступили десятки людей, понимание открытых проблем</li><li>обновление знаний и подходов (иначе когда случится очередная <a href="/blog/2786387393/" title="вомгла">вомгла</a>, работу сложно будет найти)</li><li>систематизация, даже неуклюжая, неплохо прокачивает понимание</li><li>шанс понять свои сильные и слабые стороны (а также, возможно, <a href="/blog/4256110900/" title="&quot;эволюционировать&quot;">&quot;эволюционировать&quot;</a> в другую геймдев-профессию)</li></ul><p><strong><code>&quot;Как заниматься&quot;</code></strong>.</p><p>“Традиционный путь в программисты” — это прочитать пару книг по языку и перейти от теории к практике (попутно нафаршировав голову в универе всяким computer scienсe, engeneering, math или еще чем-нибудь). Дальше обычно с некоторой периодичностью изучаются мануалы или best practices, но чаще всего ведущим способом изучения является практика. В такой схеме сильно страдают еще два способа набора знаний:</p><p><strong>Наблюдение</strong><br> Что делают другие и с какими целями:</p><ul><li>изучение докладов с профильных конференций</li><li>профессиональное общение</li><li>изучение open-source кода</li><li>использование различных middleware-инструментов</li><li>играть в игры конкурентов<br>Примеры задачек на наблюдение:</li><li>найти 10 субъективно наиболее интересных библиотек из boost (abseil/folly/eastl или еще какой-нибудь base library) и разобраться, с какой целью они сделаны и как устроены</li><li>найти 10 устаревших <a href="https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms" target="_blank" rel="noopener">идиом</a> C++ и посмотреть, почему они устарели, и что предлагает язык сейчас</li><li>изучить <a href="/blog/2826376146/" title="примитивы">примитивы</a> асинхронного программирования в 5-10 языках программирования (варианты — реализации хеш-таблиц/сборщиков мусора/конкретные оптимизации компилятора)</li><li>выбрать какую-нибудь популярную open-source библиотеку (например, <a href="https://github.com/bkaradzic/bgfx#who-is-using-it-madewithbgfx" target="_blank" rel="noopener">bgfx</a>) и пройтись по 5-10 примерам сделанным с её помощью проектам, изучить их фичи, а также изучить все 3rdParty библиотеки, которые используют эти проекты (или пройтись по уже собранным коллекциям, <a href="https://github.com/floooh/bookmarks" target="_blank" rel="noopener">пример</a>)</li><li>выбрать какую-нибудь фичу популярного движка, которую можно отделить, и попробовать реализовать её самому from scratch быстрее/удобнее/лучше чем то, что уже существует (например, реализация <a href="https://github.com/BobbyAnguelov/Esoterica" target="_blank" rel="noopener">системы анимаций</a> “как в трипл-эй движках” от Bobby Anguelov)<br><em>тут у него скорее наблюдение + тинкеринг + мышление</em></li><li>попробовать откопать максимум информации про устройство какой-нибудь фичи, которая понравилась в игре (к примеру, кастомизация персонажей в Sims)</li></ul><p><strong>Мышление</strong></p><ul><li>систематизация</li><li>придумывание</li><li>выводы</li><li>улучшение лучших решений</li></ul><p>Кажется, именно из-за пробелов в этих направлениях и возникает необходимость периодического заныривания в тонны материалов (в дальнейшем, систематизация позволяет значительно сократить время, просеивая эти объёмы). Так что, логично было бы более равномерно заниматься каждым из 4х способов прокачки:</p><p><img src="/blog/1976052536/scheme.png" alt=""></p><p><em>тинкеринг — то же, что и практика, свободные эксперименты с кодом</em></p><h2 id="Общение"><a href="#Общение" class="headerlink" title="Общение"></a>Общение</h2><p>От управления командой развитие общения идёт по пути расширения круга профессиональных знакомств, чтобы начинала работать “магия нетворкинга”, что в теории, иногда позволяет эффективно решать задачи типа таких:</p><ul><li>Нужен классный профильный специалист, разобраться с пачкой проблем, которые мы толком не понимаем как решить - затюнить андроид-порт движка, или выловить пачку мутных крешей где-то на границе мутных 3rdParty сдк и NDK (андроидщики в геймдеве, впрочем, кажется, всем нужны)<br>Или возможно, и в обратную сторону:</li><li>Фанатею от игр компании XXX и горю желанием там работать (или же “мечтаю сделать более крутую версию игры YYY, ищу единомышленников”)</li></ul><p>Примеры способов заявлять о себе</p><ul><li>совместная работа в прошлом</li><li>тематические онлайн или оффлайн тусовки (как участие, так и организация)</li><li>случайные знакомства (хех, в “правильных” городах шанс такого больше)</li><li>курсы/стажировки/лекции/конкурсы как платформа для общения и знакомств</li><li>медиа - подкасты, блоги</li></ul><p>Нетворкинг и взаимодействие с людьми разных скиллов также позволяет оценить важность diversity — группа людей с разным бекграундом и навыками может эффективнее решать сложные задачи.</p><p>Также, с какого-то момента приходит понимание, какие типы людей не могут нормально работать в командах — <a href="/blog/2316905704/" title="Про увольнения">Про увольнения</a><br></p><p>Отдельная, скорее субкультурная, тема — выстраивание “моста между поколениями”, изучение истории игр, а также эволюции компаний и методов разработки (<a href="https://app2top.ru/industry/10-knig-ob-istorii-igrovoj-industrii-126776.html" target="_blank" rel="noopener">пример подборки</a>). Не могу утверждать о конкретной пользе, но, кажется, это имеет и элементы медиа, и элементы объединяющего индустрию мифа.</p><p>Еще один способ взаимодействовать с командой — пропускать всё общение и код коллег через призму, “а возможно ли было бы переиспользовать решение в других местах/хотел бы я работать с этим человеком, если бы было нужно начинать новый проект и было необходимо собрать команду из тех, кто есть сейчас”.</p><p>Развитие себя при работе в команде — не личная, а общекомандная задача, можно вырасти выше команды на одну голову, но невозможно на три. Необходимо или тянуть команду вверх, или менять, или работать отдельно от группы.</p><h2 id="Жизненный-план"><a href="#Жизненный-план" class="headerlink" title="Жизненный план"></a>Жизненный план</h2><p>Обозначить цели и сроки, что хочется сделать и когда. Точно стоит обратить внимание на то, чтобы не терять здоровье и близких людей, а также на изучение языков. Полезно (и невероятно сложно!) попробовать обозначить собственные личные/профессиональные недостатки, и попробовать исправить один из них — хороший повод задуматься о себе.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;Предыдущая
      
    
    </summary>
    
    
    
      <category term="dev_evolution" scheme="http://spiiin.github.io/tags/dev-evolution/"/>
    
  </entry>
  
  <entry>
    <title>daScript. Brainfuck и оптимизации</title>
    <link href="http://spiiin.github.io/blog/621874082/"/>
    <id>http://spiiin.github.io/blog/621874082/</id>
    <published>2022-11-11T15:42:54.000Z</published>
    <updated>2023-01-14T14:30:04.951Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Попробовал портировать с <code>nim</code> на <code>daScript</code> <a href="https://howistart.org/posts/nim/1/" target="_blank" rel="noopener">интерпретатор</a> <code>brainfuck</code> кода. Брейфак предельно простой язык, и базовая реализация интерпретатора занимает полчаса, но на нём можно потренироваться в ускорении кода и продемонстрировать возможности daScript в оптимизации.</p><a id="more"></a><p>Самая первая, максимально наивная, построчно скопированная реализация:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">require strings</span><br><span class="line">require fio</span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">run</span><span class="params">(code: <span class="built_in">string</span>; var tape: <span class="built_in">array</span>&lt;uint8&gt;; var codePos, tapePos: <span class="keyword">int</span>&amp;; skip: <span class="keyword">bool</span>)</span>: <span class="keyword">bool</span></span></span><br><span class="line"><span class="function"><span class="keyword">while</span> tapePos &gt;</span>= <span class="number">0</span> &amp;&amp; codePos &lt; length(code)</span><br><span class="line"><span class="keyword">if</span> tapePos &gt;= length(tape) &#123; tape |&gt; push(uint8(<span class="number">0</span>)); &#125;</span><br><span class="line"></span><br><span class="line">let sym1  = code |&gt; character_at(codePos)</span><br><span class="line"><span class="keyword">if</span> sym1 == <span class="string">'['</span></span><br><span class="line">++codePos</span><br><span class="line">let oldPos = codePos</span><br><span class="line"><span class="keyword">while</span> run(code, tape, codePos, tapePos, tape[tapePos] == uint8(<span class="number">0</span>))</span><br><span class="line">codePos = oldPos</span><br><span class="line">elif sym1 == <span class="string">']'</span></span><br><span class="line"><span class="keyword">return</span> tape[tapePos] != uint8(<span class="number">0</span>)</span><br><span class="line">elif !skip</span><br><span class="line">let sym  = code |&gt; character_at(codePos)</span><br><span class="line"><span class="keyword">if</span> sym == <span class="string">'+'</span> &#123; tape[tapePos] = uint8(<span class="keyword">int</span>(tape[tapePos]) + <span class="number">1</span>); &#125;</span><br><span class="line">elif sym == <span class="string">'-'</span> &#123; tape[tapePos] = uint8(<span class="keyword">int</span>(tape[tapePos]) - <span class="number">1</span>); &#125;</span><br><span class="line">elif sym == <span class="string">'&gt;'</span> &#123; ++tapePos; &#125;</span><br><span class="line">elif sym == <span class="string">'&lt;'</span> &#123; --tapePos; &#125;</span><br><span class="line">elif sym == <span class="string">'.'</span> &#123; print(<span class="string">"&#123;int(tape[tapePos]) |&gt; to_char&#125;"</span>); &#125;</span><br><span class="line">elif sym == <span class="string">','</span> &#123; tape[tapePos] = uint8(getchar()); &#125;</span><br><span class="line"><span class="keyword">else</span> &#123; &#125;</span><br><span class="line">++codePos</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">def interpret(code: <span class="built_in">string</span>)</span><br><span class="line">let totalTime = ref_time_ticks()</span><br><span class="line">var tape: <span class="built_in">array</span>&lt;uint8&gt;</span><br><span class="line">var codePos, tapePos : <span class="keyword">int</span></span><br><span class="line">run(code, tape, codePos, tapePos, <span class="literal">false</span>)</span><br><span class="line">let totalDt = <span class="keyword">double</span>(get_time_usec(totalTime)) /<span class="number">1000000.0l</span>f</span><br><span class="line">to_log(LOG_INFO, <span class="string">"total &#123;totalDt&#125; sec\n"</span>)</span><br></pre></td></tr></table></figure><p>Если попытаться протестировать его на генераторе <a href="https://github.com/def-/nim-brainfuck/blob/master/examples/mandelbrot.b" target="_blank" rel="noopener">множества Мандельброта</a>, можно заметить серьёзные проблемы со скоростью, вычисления занимают около 5 часов. Стоит попробовать его разогнать!</p><h2 id="Отключение-проверок-границ-и-указателей"><a href="#Отключение-проверок-границ-и-указателей" class="headerlink" title="Отключение проверок границ и указателей"></a>Отключение проверок границ и указателей</h2><p>Код на brainfuck - это простая числодробилка, ускорить которую можно, отключив все дополнительные проверки обращений к памяти.</p><p><em>Как отключать проверки, мне рассказал <a href="https://github.com/borisbat" target="_blank" rel="noopener">Борис Баткин</a> (так как интерпретатор nim делал один основных контрибьютеров языка, то его подсказки не отменяют честности сравнения — авторы находятся в одной “весовой категории” знания своего языка).</em></p><p>В первую очередь, можно заменить функцию <code>charcter_at</code>, которая <a href="https://github.com/GaijinEntertainment/daScript/blob/e9f4c486848a8985e4126e0fc2d04afbc6abd883/src/builtin/module_builtin_string.cpp#L26" target="_blank" rel="noopener">проверяет</a>,что индекс меньше длины строки, на <code>character_uat</code>, которая не делает этой проверки.</p><p>Также отключается проверка ссылок на null макросом <code>[unsafe_deref]</code>.</p><p>Наконец, обращение к массиву можно выполнять не через разыменование ссылки, а через обращение по указателю:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">tape: <span class="built_in">array</span>&lt;uint8&gt;</span><br><span class="line">tape[index] <span class="comment">// tape[check_range(index)] //медленно</span></span><br><span class="line"></span><br><span class="line">var ptape: uint8? = addr(tape[<span class="number">0</span>])</span><br><span class="line">ptape[index] <span class="comment">//check_not_null(ptape)[index] //быстрее, обращение без проверок</span></span><br><span class="line"></span><br><span class="line">[unsafe_deref]</span><br><span class="line">ptape[index] <span class="comment">//ptape[index] //еще быстрее, обращение без перепроверок указателя на nullptr</span></span><br></pre></td></tr></table></figure><p>Переписанная версия кода:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[unsafe_deref]</span><br><span class="line"><span class="function">def <span class="title">run</span><span class="params">(code: uint8?; lengthOfCode:<span class="keyword">int</span>; var tape: uint8?; var codePos, tapePos: <span class="keyword">int</span>&amp;; skip: <span class="keyword">bool</span>)</span>: <span class="keyword">bool</span></span></span><br><span class="line"><span class="function">unsafe</span></span><br><span class="line"><span class="function"><span class="keyword">while</span> tapePos &gt;</span>= <span class="number">0</span> &amp;&amp; codePos &lt; lengthOfCode</span><br><span class="line">let sym1  = <span class="keyword">int</span>(code[codePos])</span><br><span class="line"><span class="keyword">if</span> sym1 == <span class="string">'['</span></span><br><span class="line">++codePos</span><br><span class="line">let oldPos = codePos</span><br><span class="line"><span class="keyword">while</span> run(code, lengthOfCode, tape, codePos, tapePos, tape[tapePos] == uint8(<span class="number">0</span>))</span><br><span class="line">codePos = oldPos</span><br><span class="line">elif sym1 == <span class="string">']'</span></span><br><span class="line"><span class="keyword">return</span> tape[tapePos] != uint8(<span class="number">0</span>)</span><br><span class="line">elif !skip</span><br><span class="line">let sym  = <span class="keyword">int</span>(code[codePos])</span><br><span class="line"><span class="keyword">if</span> sym == <span class="string">'+'</span> &#123; tape[tapePos] = uint8(<span class="keyword">int</span>(tape[tapePos]) + <span class="number">1</span>); &#125;</span><br><span class="line">elif sym == <span class="string">'-'</span> &#123; tape[tapePos] = uint8(<span class="keyword">int</span>(tape[tapePos]) - <span class="number">1</span>); &#125;</span><br><span class="line">elif sym == <span class="string">'&gt;'</span> &#123; ++tapePos; &#125;</span><br><span class="line">elif sym == <span class="string">'&lt;'</span> &#123; --tapePos; &#125;</span><br><span class="line">elif sym == <span class="string">'.'</span> &#123; print(<span class="keyword">int</span>(tape[tapePos]) |&gt; to_char); &#125;</span><br><span class="line">elif sym == <span class="string">','</span> &#123; tape[tapePos] = uint8(getchar()); &#125;</span><br><span class="line"><span class="keyword">else</span> &#123; &#125;</span><br><span class="line">++codePos</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">def interpret(code: <span class="built_in">string</span>)</span><br><span class="line">let totalTime = ref_time_ticks()</span><br><span class="line">var tape: <span class="built_in">array</span>&lt;uint8&gt;</span><br><span class="line">var codePos, tapePos : <span class="keyword">int</span></span><br><span class="line">tape |&gt; resize(<span class="number">1000000</span>)</span><br><span class="line">unsafe</span><br><span class="line">run(reinterpret&lt;uint8?&gt; code, length(code), addr(tape[<span class="number">0</span>]), codePos, tapePos, <span class="literal">false</span>)</span><br><span class="line">let totalDt = <span class="keyword">double</span>(get_time_usec(totalTime)) /<span class="number">1000000.0l</span>f</span><br><span class="line">to_log(LOG_INFO, <span class="string">"total &#123;totalDt&#125; sec\n"</span>)</span><br></pre></td></tr></table></figure><p>Такая версия интерпретатора всё ещё тормозная, но уже позволяет дождаться завершения выполнения кода:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">e:\src\daScript\bin\Release&gt;daScript.exe brainfuck_00.das</span><br><span class="line">AAAAAAAAAAAAAAAABBBBBBBBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDEGFFEEEEDDDDDDCCCCCCCCCBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB</span><br><span class="line">AAAAAAAAAAAAAAABBBBBBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDEEEFGIIGFFEEEDDDDDDDDCCCCCCCCCBBBBBBBBBBBBBBBBBBBBBBBBBB</span><br><span class="line">AAAAAAAAAAAAABBBBBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDEEEEFFFI KHGGGHGEDDDDDDDDDCCCCCCCCCBBBBBBBBBBBBBBBBBBBBBBB</span><br><span class="line">AAAAAAAAAAAABBBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDEEEEEFFGHIMTKLZOGFEEDDDDDDDDDCCCCCCCCCBBBBBBBBBBBBBBBBBBBBB</span><br><span class="line">AAAAAAAAAAABBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDEEEEEEFGGHHIKPPKIHGFFEEEDDDDDDDDDCCCCCCCCCCBBBBBBBBBBBBBBBBBB</span><br><span class="line">AAAAAAAAAABBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDEEEEEEFFGHIJKS  X KHHGFEEEEEDDDDDDDDDCCCCCCCCCCBBBBBBBBBBBBBBBB</span><br><span class="line">AAAAAAAAABBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDEEEEEEFFGQPUVOTY   ZQL[MHFEEEEEEEDDDDDDDCCCCCCCCCCCBBBBBBBBBBBBBB</span><br><span class="line">AAAAAAAABBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDEEEEEFFFFFGGHJLZ         UKHGFFEEEEEEEEDDDDDCCCCCCCCCCCCBBBBBBBBBBBB</span><br><span class="line">AAAAAAABBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDEEEEFFFFFFGGGGHIKP           KHHGGFFFFEEEEEEDDDDDCCCCCCCCCCCBBBBBBBBBBB</span><br><span class="line">AAAAAAABBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDEEEEEFGGHIIHHHHHIIIJKMR        VMKJIHHHGFFFFFFGSGEDDDDCCCCCCCCCCCCBBBBBBBBB</span><br><span class="line">AAAAAABBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDEEEEEEFFGHK   MKJIJO  N R  X      YUSR PLV LHHHGGHIOJGFEDDDCCCCCCCCCCCCBBBBBBBB</span><br><span class="line">AAAAABBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDEEEEEEEEEFFFFGH O    TN S                       NKJKR LLQMNHEEDDDCCCCCCCCCCCCBBBBBBB</span><br><span class="line">AAAAABBCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDEEEEEEEEEEEEFFFFFGHHIN                                 Q     UMWGEEEDDDCCCCCCCCCCCCBBBBBB</span><br><span class="line">AAAABBCCCCCCCCCCCCCCCCCCCCCCCCCDDDDEEEEEEEEEEEEEEEFFFFFFGHIJKLOT                                     [JGFFEEEDDCCCCCCCCCCCCCBBBBB</span><br><span class="line">AAAABCCCCCCCCCCCCCCCCCCCCCCDDDDEEEEEEEEEEEEEEEEFFFFFFGGHYV RQU                                     QMJHGGFEEEDDDCCCCCCCCCCCCCBBBB</span><br><span class="line">AAABCCCCCCCCCCCCCCCCCDDDDDDDEEFJIHFFFFFFFFFFFFFFGGGGGGHIJN                                            JHHGFEEDDDDCCCCCCCCCCCCCBBB</span><br><span class="line">AAABCCCCCCCCCCCDDDDDDDDDDEEEEFFHLKHHGGGGHHMJHGGGGGGHHHIKRR                                           UQ L HFEDDDDCCCCCCCCCCCCCCBB</span><br><span class="line">AABCCCCCCCCDDDDDDDDDDDEEEEEEFFFHKQMRKNJIJLVS JJKIIIIIIJLR                                               YNHFEDDDDDCCCCCCCCCCCCCBB</span><br><span class="line">AABCCCCCDDDDDDDDDDDDEEEEEEEFFGGHIJKOU  O O   PR LLJJJKL                                                OIHFFEDDDDDCCCCCCCCCCCCCCB</span><br><span class="line">AACCCDDDDDDDDDDDDDEEEEEEEEEFGGGHIJMR              RMLMN                                                 NTFEEDDDDDDCCCCCCCCCCCCCB</span><br><span class="line">AACCDDDDDDDDDDDDEEEEEEEEEFGGGHHKONSZ                QPR                                                NJGFEEDDDDDDCCCCCCCCCCCCCC</span><br><span class="line">ABCDDDDDDDDDDDEEEEEFFFFFGIPJIIJKMQ                   VX                                                 HFFEEDDDDDDCCCCCCCCCCCCCC</span><br><span class="line">ACDDDDDDDDDDEFFFFFFFGGGGHIKZOOPPS                                                                      HGFEEEDDDDDDCCCCCCCCCCCCCC</span><br><span class="line">ADEEEEFFFGHIGGGGGGHHHHIJJLNY                                                                        TJHGFFEEEDDDDDDDCCCCCCCCCCCCC</span><br><span class="line">A                                                                                                 PLJHGGFFEEEDDDDDDDCCCCCCCCCCCCC</span><br><span class="line">ADEEEEFFFGHIGGGGGGHHHHIJJLNY                                                                        TJHGFFEEEDDDDDDDCCCCCCCCCCCCC</span><br><span class="line">ACDDDDDDDDDDEFFFFFFFGGGGHIKZOOPPS                                                                      HGFEEEDDDDDDCCCCCCCCCCCCCC</span><br><span class="line">ABCDDDDDDDDDDDEEEEEFFFFFGIPJIIJKMQ                   VX                                                 HFFEEDDDDDDCCCCCCCCCCCCCC</span><br><span class="line">AACCDDDDDDDDDDDDEEEEEEEEEFGGGHHKONSZ                QPR                                                NJGFEEDDDDDDCCCCCCCCCCCCCC</span><br><span class="line">AACCCDDDDDDDDDDDDDEEEEEEEEEFGGGHIJMR              RMLMN                                                 NTFEEDDDDDDCCCCCCCCCCCCCB</span><br><span class="line">AABCCCCCDDDDDDDDDDDDEEEEEEEFFGGHIJKOU  O O   PR LLJJJKL                                                OIHFFEDDDDDCCCCCCCCCCCCCCB</span><br><span class="line">AABCCCCCCCCDDDDDDDDDDDEEEEEEFFFHKQMRKNJIJLVS JJKIIIIIIJLR                                               YNHFEDDDDDCCCCCCCCCCCCCBB</span><br><span class="line">AAABCCCCCCCCCCCDDDDDDDDDDEEEEFFHLKHHGGGGHHMJHGGGGGGHHHIKRR                                           UQ L HFEDDDDCCCCCCCCCCCCCCBB</span><br><span class="line">AAABCCCCCCCCCCCCCCCCCDDDDDDDEEFJIHFFFFFFFFFFFFFFGGGGGGHIJN                                            JHHGFEEDDDDCCCCCCCCCCCCCBBB</span><br><span class="line">AAAABCCCCCCCCCCCCCCCCCCCCCCDDDDEEEEEEEEEEEEEEEEFFFFFFGGHYV RQU                                     QMJHGGFEEEDDDCCCCCCCCCCCCCBBBB</span><br><span class="line">AAAABBCCCCCCCCCCCCCCCCCCCCCCCCCDDDDEEEEEEEEEEEEEEEFFFFFFGHIJKLOT                                     [JGFFEEEDDCCCCCCCCCCCCCBBBBB</span><br><span class="line">AAAAABBCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDEEEEEEEEEEEEFFFFFGHHIN                                 Q     UMWGEEEDDDCCCCCCCCCCCCBBBBBB</span><br><span class="line">AAAAABBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDEEEEEEEEEFFFFGH O    TN S                       NKJKR LLQMNHEEDDDCCCCCCCCCCCCBBBBBBB</span><br><span class="line">AAAAAABBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDEEEEEEFFGHK   MKJIJO  N R  X      YUSR PLV LHHHGGHIOJGFEDDDCCCCCCCCCCCCBBBBBBBB</span><br><span class="line">AAAAAAABBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDEEEEEFGGHIIHHHHHIIIJKMR        VMKJIHHHGFFFFFFGSGEDDDDCCCCCCCCCCCCBBBBBBBBB</span><br><span class="line">AAAAAAABBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDEEEEFFFFFFGGGGHIKP           KHHGGFFFFEEEEEEDDDDDCCCCCCCCCCCBBBBBBBBBBB</span><br><span class="line">AAAAAAAABBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDEEEEEFFFFFGGHJLZ         UKHGFFEEEEEEEEDDDDDCCCCCCCCCCCCBBBBBBBBBBBB</span><br><span class="line">AAAAAAAAABBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDEEEEEEFFGQPUVOTY   ZQL[MHFEEEEEEEDDDDDDDCCCCCCCCCCCBBBBBBBBBBBBBB</span><br><span class="line">AAAAAAAAAABBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDEEEEEEFFGHIJKS  X KHHGFEEEEEDDDDDDDDDCCCCCCCCCCBBBBBBBBBBBBBBBB</span><br><span class="line">AAAAAAAAAAABBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDEEEEEEFGGHHIKPPKIHGFFEEEDDDDDDDDDCCCCCCCCCCBBBBBBBBBBBBBBBBBB</span><br><span class="line">AAAAAAAAAAAABBBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDEEEEEFFGHIMTKLZOGFEEDDDDDDDDDCCCCCCCCCBBBBBBBBBBBBBBBBBBBBB</span><br><span class="line">AAAAAAAAAAAAABBBBBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDEEEEFFFI KHGGGHGEDDDDDDDDDCCCCCCCCCBBBBBBBBBBBBBBBBBBBBBBB</span><br><span class="line">AAAAAAAAAAAAAAABBBBBBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDEEEFGIIGFFEEEDDDDDDDDCCCCCCCCCBBBBBBBBBBBBBBBBBBBBBBBBBB</span><br><span class="line">[I] total 564.99929999999994834 sec</span><br></pre></td></tr></table></figure><p>564 секунды — в 30 раз быстрее первой версии, но всё ещё сильно медленнее интерпретатора на <code>nim</code>, который в релизной версии выполняется за 40 секунд.</p><h2 id="Ahead-of-Time"><a href="#Ahead-of-Time" class="headerlink" title="Ahead-of-Time"></a>Ahead-of-Time</h2><p>daScript умеет транспилироваться в C++ код, для сравнения с nim попробуем скомпилировать интерпретатор, без внесения каких-либо изменений в код.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">daScript.exe -aot brainfuck.das brainfuck.das.cpp</span><br></pre></td></tr></table></figure><p>Полученный C++-файл проще всего подсунуть в пример <a href="https://github.com/GaijinEntertainment/daScript/blob/master/examples/tutorial/tutorial02aot.cpp" target="_blank" rel="noopener">tutorial02aot</a>, который настроен на использование AoT варианта кода. Скомпилированный файл можно запустить:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">e:\src\daScript\bin\Release&gt;tutorial02aot.exe</span><br><span class="line">[I] total <span class="number">34.27342399999999856</span> sec</span><br></pre></td></tr></table></figure><p>34 секунды — уже быстрее, чем nim, который сам по себе достаточно быстрый!</p><h2 id="Just-in-Time"><a href="#Just-in-Time" class="headerlink" title="Just-in-Time"></a>Just-in-Time</h2><p>Можно попробовать двигаться дальше, подключив экспериментальный модуль <a href="https://github.com/borisbat/dasLLVM" target="_blank" rel="noopener">dasLLVM</a>. Чтобы собрать его, необходимо:</p><ul><li>включить сборку модуля в cmake:</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">option(DAS_LLVM_DISABLED &quot;Disable dasLLVM (llvm bindings)&quot; OFF)</span><br></pre></td></tr></table></figure><ul><li>собрать проект llvm, или скачать собранный (например, от <a href="https://download.qt.io/development_releases/prebuilt/libclang/" target="_blank" rel="noopener">qt</a>) и положить на уровень выше корневой директории проекта daScript, напрммер:</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:&#x2F;dascript</span><br><span class="line">C:&#x2F;libclang</span><br></pre></td></tr></table></figure><ul><li>сгенерировать решение и пересобрать dascript:</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">generate_msvc_2019.bat</span><br></pre></td></tr></table></figure><p>Теперь можно воспользоваться аннотацией <code>[jit]</code>, чтобы код функциии интерпретатора без AoT-компиляции перед первым выполнением компилировался с помощью <code>llvm-c</code>.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[jit,unsafe_deref]</span><br><span class="line"><span class="function">def <span class="title">run</span><span class="params">(code: uint8?; lengthOfCode:<span class="keyword">int</span>; var tape: uint8?; var codePos, tapePos: <span class="keyword">int</span>&amp;; skip: <span class="keyword">bool</span>)</span>: <span class="keyword">bool</span></span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">e:\src\daScript_my\bin\Release&gt;daScript.exe brainfuck_2_jit.das</span><br><span class="line">[I] total 22.66654300000000077 sec</span><br></pre></td></tr></table></figure><p>22.6 секунды, еще лучше! Генерация daScript-кода в llvm-ассемблер быстрее, чем в C++ — генератор передаёт больше полезной для оптимизации о кода, а также, возможно, задействуется сила оптимизаций LLVM.</p><h2 id="Метапрограммирование"><a href="#Метапрограммирование" class="headerlink" title="Метапрограммирование"></a>Метапрограммирование</h2><p>Можно двигаться дальше. Вместо того, чтобы писать функцию, которая интерпретирует любой код на brainfuck, можно написать макрос, который сгенерирует код конкретной функции в compile-time, и измерить время выполнения этой функции.</p><p>Можно использовать <a href="https://dascript.org/doc/reference/language/macros.html#astreadermacro" target="_blank" rel="noopener">AstReaderMacro</a> — тип макроса, который обрабатывает отдельные символы. Синтаксис вызова такого макроса:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">% READER_MACRO_NAME ~ character_sequence %% &#x2F;&#x2F;character_sequence будет передана на вход макросу</span><br></pre></td></tr></table></figure><p>Шаблоны таких макросов можно посмотреть в модулях <code>json_boost</code> и <code>regex_boost</code></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> brainfuck_macro shared <span class="keyword">public</span></span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">generateFunction</span><span class="params">(uniqueName, code)</span></span></span><br><span class="line"><span class="function">    let seqStr </span>= <span class="built_in">string</span>(code)</span><br><span class="line"></span><br><span class="line">    var blkArr : <span class="built_in">array</span>&lt;<span class="built_in">array</span>&lt;ExpressionPtr&gt;&gt;; defer_delete(blkArr)</span><br><span class="line"></span><br><span class="line">    var blk : <span class="built_in">array</span>&lt;ExpressionPtr&gt;; defer_delete(blk)</span><br><span class="line">    blkArr |&gt; emplace(blk)</span><br><span class="line"></span><br><span class="line">    blkArr[<span class="number">0</span>] |&gt; emplace_new &lt;| qmacro_expr( $&#123; var tape: <span class="built_in">array</span>&lt;uint8&gt;; &#125;)</span><br><span class="line">    blkArr[<span class="number">0</span>] |&gt; emplace_new &lt;| qmacro_expr( $&#123; var tapePos : <span class="keyword">int</span>; &#125;)</span><br><span class="line">    blkArr[<span class="number">0</span>] |&gt; emplace_new &lt;| qmacro_expr( $&#123; tape |&gt; resize(<span class="number">1000000</span>); &#125;)</span><br><span class="line">    blkArr[<span class="number">0</span>] |&gt; emplace_new &lt;| qmacro_expr( $&#123; var ptape = addr(tape[<span class="number">0</span>]); &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> sym in seqStr</span><br><span class="line">        <span class="keyword">if</span> sym == <span class="string">'+'</span>   &#123; back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( $&#123; ptape[tapePos] = uint8(<span class="keyword">int</span>(ptape[tapePos]) + <span class="number">1</span>); &#125;); &#125;</span><br><span class="line">        elif sym == <span class="string">'-'</span> &#123; back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( $&#123; ptape[tapePos] = uint8(<span class="keyword">int</span>(ptape[tapePos]) - <span class="number">1</span>); &#125;); &#125;</span><br><span class="line">        elif sym == <span class="string">'&gt;'</span> &#123; back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( $&#123; ++tapePos; &#125;); &#125; </span><br><span class="line">        elif sym == <span class="string">'&lt;'</span> &#123; back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( $&#123; --tapePos; &#125;); &#125;</span><br><span class="line">        elif sym == <span class="string">'.'</span> &#123; back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( $&#123; print(<span class="keyword">int</span>(ptape[tapePos]) |&gt; to_char); &#125;); &#125;</span><br><span class="line">        elif sym == <span class="string">','</span> &#123; back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( $&#123; ptape[tapePos] = uint8(getchar()); &#125;); &#125;</span><br><span class="line">        elif sym == <span class="string">'['</span></span><br><span class="line">            var blk1 : <span class="built_in">array</span>&lt;ExpressionPtr&gt;; defer_delete(blk1)</span><br><span class="line">            blkArr |&gt; emplace(blk1)</span><br><span class="line">        elif sym == <span class="string">']'</span></span><br><span class="line">            var last &lt;- back(blkArr)</span><br><span class="line">            blkArr |&gt; pop()</span><br><span class="line">            var whileExpr &lt;- qmacro_expr &lt;|</span><br><span class="line">                <span class="keyword">while</span> ptape[tapePos] != uint8(<span class="number">0</span>)</span><br><span class="line">                    $b(last)</span><br><span class="line">            back(blkArr) |&gt; emplace_new &lt;| whileExpr</span><br><span class="line">        <span class="keyword">else</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    var fnArguments : <span class="built_in">array</span>&lt;VariablePtr&gt;;</span><br><span class="line">    var fn &lt;- qmacro_function(uniqueName) &lt;| $ ($a(fnArguments))</span><br><span class="line">        unsafe</span><br><span class="line">            $b(blkArr[<span class="number">0</span>])</span><br><span class="line">    defer_delete(fn)</span><br><span class="line"></span><br><span class="line">    var args:<span class="built_in">array</span>&lt; tuple&lt;argname:<span class="built_in">string</span>;argvalue:RttiValue&gt; &gt;</span><br><span class="line">    fn |&gt; append_annotation(<span class="string">"$"</span>, <span class="string">"unsafe_deref"</span>, args)</span><br><span class="line">    <span class="comment">//print(describe(fn))</span></span><br><span class="line">    compiling_module() |&gt; add_function(fn)</span><br><span class="line"></span><br><span class="line">[reader_macro(name=<span class="string">"bf"</span>)]</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">private</span> <span class="title">BrainfuckReader</span> :</span> AstReaderMacro</span><br><span class="line">    <span class="function">def <span class="keyword">override</span> <span class="title">accept</span><span class="params">( prog:ProgramPtr; mod:Module?; var expr:ExprReader?; ch:<span class="keyword">int</span>; info:LineInfo)</span> : <span class="keyword">bool</span></span></span><br><span class="line"><span class="function">        <span class="title">append</span><span class="params">(expr.sequence, ch)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">if</span> <span class="title">ends_with</span><span class="params">(expr.sequence,<span class="string">"%%"</span>)</span></span></span><br><span class="line"><span class="function">            let len </span>= length(expr.sequence)</span><br><span class="line">            resize(expr.sequence,len<span class="number">-2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    def <span class="keyword">override</span> visit( prog:ProgramPtr; mod:Module?; expr:smart_ptr&lt;ExprReader&gt;) : ExpressionPtr</span><br><span class="line">        let str &lt;- make_unique_private_name(<span class="string">"bf`exec"</span>, expr.at)</span><br><span class="line">        generateFunction(str, expr.sequence)</span><br><span class="line"></span><br><span class="line">        var ftype &lt;- <span class="keyword">new</span> [[TypeDecl() at=expr.at, baseType=Type tFunction ]]</span><br><span class="line">        ftype.firstType &lt;- <span class="keyword">new</span> [[TypeDecl() at=expr.at, baseType=Type tVoid]]</span><br><span class="line">        var funcPtr &lt;- <span class="keyword">new</span> [[ExprAddr() at=expr.at, target:=str, funcType &lt;- ftype]]</span><br><span class="line">        <span class="keyword">return</span> funcPtr</span><br></pre></td></tr></table></figure><p>Тогда вызвать такой макрос можно так:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">require brainfuck_macro</span><br><span class="line"><span class="comment">//генерируем функцию</span></span><br><span class="line">let func = %bf~++++++++[&gt;++++[&gt;++&gt;+++&gt;+++&gt;+&lt;&lt;&lt;&lt;-]&gt;+&gt;+&gt;-&gt;&gt;+[&lt;]&lt;-]&gt;&gt;.&gt;---.+++++++..+++.&gt;&gt;.&lt;-.&lt;.+++.------.--------.&gt;&gt;+.&gt;++.%%</span><br><span class="line"><span class="comment">//вызываем сгенерированную функцию</span></span><br><span class="line">invoke(func)</span><br></pre></td></tr></table></figure><p>Если раскомментировать строчку <code>print(describe(fn))</code> можно посмотреть на сгенерированное тело функции.</p><p>Например:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">let func = %bf~[-&gt;+&lt;]%%</span><br><span class="line"><span class="comment">//сгенерированный код</span></span><br><span class="line"></span><br><span class="line">[unsafe_deref]</span><br><span class="line">def <span class="keyword">public</span> bf`exec_0xd_0xc</span><br><span class="line">    unsafe</span><br><span class="line">        var tape:<span class="built_in">array</span>&lt;uint8&gt; -<span class="keyword">const</span>                          <span class="comment">//declare variables</span></span><br><span class="line">        var tapePos:<span class="keyword">int</span> -<span class="keyword">const</span></span><br><span class="line">        resize(tape,<span class="number">1000000</span>)</span><br><span class="line">        var ptape:<span class="keyword">auto</span> -<span class="keyword">const</span> = addr(tape[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ptape[tapePos] != uint8(<span class="number">0</span>)                      <span class="comment">//[</span></span><br><span class="line">            ptape[tapePos] = uint8(<span class="keyword">int</span>(ptape[tapePos]) - <span class="number">1</span>)   <span class="comment">//-</span></span><br><span class="line">            ++tapePos                                         <span class="comment">//&gt;</span></span><br><span class="line">            ptape[tapePos] = uint8(<span class="keyword">int</span>(ptape[tapePos]) + <span class="number">1</span>)   <span class="comment">//+</span></span><br><span class="line">            --tapePos                                         <span class="comment">//&lt;]</span></span><br><span class="line">let func = @@bf`exec_0xd_0xc <span class="comment">//указатель на функцию</span></span><br></pre></td></tr></table></figure><p>Для каждой функции генерируется уникальное имя, чтобы можно было создать несколько отдельных интерпретатов, и своя “лента” памяти. В дальнейшем, каждый отдельный символ brainfuck компилируется в одну или несколько ast-нод daScript, который затем могут быть просимулированы.</p><p>(Раздел <code>daScript</code> про симуляцию и устройство виртуальной машины daScript)<br><a href="/blog/2115627465/" title="Устройство интерпретаторов lua-jit и daScript">Устройство интерпретаторов lua-jit и daScript</a> </p><p>(Генерация кода с помощью <a href="https://dascript.org/doc/reference/language/reification.html" target="_blank" rel="noopener">реификации выражений</a>)<br><a href="/blog/4046309382/" title="daScript macro - 2">daScript macro - 2</a></p><p>Если говорить о терминологии, то brainfuck можно рассматривать как <code>предметно-ориентированный язык (DSL)</code>. Переменные состояния tape и tapePos вместе составляют <code>семантическую модель</code> этого языка, которая настраивается с помощью DSL, а затем транслируется в синтаксическое дерево на <code>daScript</code> (в терминах Мартина Фаулера из книги “Предметно-ориентированные языки программирования”).</p><p>Время выполнения такой скомпилированной функции <strong>в режиме интерпретации</strong>:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">e:\src\daScript_my\bin\Release&gt;daScript.exe brainfuck.das</span><br><span class="line">[I] total 29.28014399999999995 sec</span><br></pre></td></tr></table></figure><p>Это немного медленнее скомпилированной JiT-версии, но уже быстрее AoT версии интерпретатора.</p><h2 id="Macro-JiT"><a href="#Macro-JiT" class="headerlink" title="Macro + JiT"></a>Macro + JiT</h2><p>Дальше будет интереснее. Наша скомпилированная версия функции представляет собой по сути развёрнутую трассированную версию исполнения кода (и занимающую больше памяти). Попробуем применить к ней макрос [jit]:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">fn |&gt; append_annotation(<span class="string">"$"</span>, <span class="string">"unsafe_deref"</span>, args)</span><br><span class="line">fn |&gt; append_annotation(<span class="string">"$"</span>, <span class="string">"jit"</span>, args)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">e:\src\daScript_my\bin\Release&gt;daScript.exe brainfuck.das</span><br><span class="line">[I] total 0.85775599999999996 sec</span><br></pre></td></tr></table></figure><p>0.85 секунды! (плюс около секунды на само время компиляции функции). llvm jit умеет сворачивать идущие подряд повторяющиеся операторы инкремента и декремента, за счёт чего получилось ускорение в 30 раз (и соотвествующее уменьшение размера функции).</p><p>Для сравнения — compile-time версия на nim работает ~3 секунды и тратит ~20 секунд на компиляцию (nim работает медленно в compile-time режиме).</p><h2 id="Оптимизации-Brainfuck-gt-daScript-AST"><a href="#Оптимизации-Brainfuck-gt-daScript-AST" class="headerlink" title="Оптимизации Brainfuck -&gt; daScript AST"></a>Оптимизации Brainfuck -&gt; daScript AST</h2><p>Получается интересная цепочка преобразования кода:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bf --&gt; (bf macro) --&gt; dascript ast --&gt; (dascript simulate - unsafe deref macro + optimizations) --&gt; dascript ast optimized --&gt; (llvm macro) --&gt; llvm native optimized code --&gt; (execute)</span><br></pre></td></tr></table></figure><p>На каждом из шагов происходят серьёзные трансформации кода, которые могут включать оптимизации. Можно рассмотреть оптимизации в обратном порядке:</p><ul><li>llvm — бекэнд генерации кода оптимизирует байт-код, на этом этапе заметен эффект от сворачивания идущих подряд операций</li><li>dascript simulate — при симуляции ast-дерева выбираются оптимизированные частные версии нод, мелкие ноды могут “сплавляться” в более крупные, применяются кастомные макросы, трансформирующие дерево по различным правилам</li><li>bf macro — на данном уровне производится трансляция команд brainfuck в ноды dascript, пока без оптимизаций</li></ul><p>Оптимизации на стадиях трансформаций llvm были сделаны библиотекой из “комплекта” языка, на стадиях преобразования daScript — как встроенными в язык оптимизациями, так и добавленными для своего кода вручную. Можно теперь попробовать добавить пару оптимизаций на “стороне DSL”, т.е. в макрос трансформации <code>brainfuck-&gt;daScript</code>.</p><p>На данном этапе первую тупую и наивную реализацию уже получилось разогнать где-то в 20000 раз, и это отличный повод разогнать ещё немного :)</p><p>Можно выбрать несколько простых паттернов brainfuck кода и попробовать распознавать их и генерить более оптимальный код для этих частных случаев:</p><ul><li>цепочка повторяющихся операций. Например, “+++++” можно интерпретировать не как 5 отдельных инкрементов, а как одну операцию увеличения на 5. Эту свёртку делает llvm для версии <code>Macro+JiT</code>, но если сделать её в своём макросе, то она также ускорит и обычный режим интерпретации</li><li>паттерн [-] можно интерпретировать как очистку ячейки памяти одной операцией</li><li>[-&gt;+&lt;] - чуть более сложный паттерн, который часто встречается в примерах на brainfuck, “сложение двух ячеек с очисткой исходной”, может быть интерпретирован как 2 команды вместо цикла</li><li>можно продолжать обнаруживать и добавлять всё более сложные паттерны</li></ul><p>(Приём с отслеживанием паттернов подходит, естественно, не только для brainfuck-кода, но и для любых DSL)</p><p>“Продвинутая” версия макроса, отслеживающая перечисленные паттерны</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">seachRepeats</span><span class="params">(symIt; var sym:<span class="keyword">int</span>&amp;; symbolToCheck)</span></span></span><br><span class="line"><span class="function">    var count </span>= <span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">while</span> <span class="title">next</span><span class="params">(symIt, sym)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">if</span> sym </span>== symbolToCheck</span><br><span class="line">            ++count</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> count</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line">def match_reset(data: <span class="built_in">array</span>&lt;<span class="keyword">int</span>&gt;)</span><br><span class="line">    <span class="keyword">return</span> length(data) == <span class="number">3</span> &amp;&amp; data[<span class="number">0</span>] == <span class="string">'['</span> &amp;&amp; data[<span class="number">1</span>] == <span class="string">'-'</span> &amp;&amp; data[<span class="number">2</span>] == <span class="string">']'</span></span><br><span class="line"></span><br><span class="line">def match_add_right_reset(data: <span class="built_in">array</span>&lt;<span class="keyword">int</span>&gt;)</span><br><span class="line">    <span class="keyword">return</span> length(data) == <span class="number">6</span> &amp;&amp; data[<span class="number">0</span>] == <span class="string">'['</span> &amp;&amp; data[<span class="number">1</span>] == <span class="string">'-'</span> &amp;&amp; data[<span class="number">2</span>] == <span class="string">'&gt;'</span> &amp;&amp; data[<span class="number">3</span>] == <span class="string">'+'</span> &amp;&amp; data[<span class="number">4</span>] == <span class="string">'&lt;'</span> &amp;&amp; data[<span class="number">5</span>] == <span class="string">']'</span></span><br><span class="line"></span><br><span class="line">def generateFunction(uniqueName, code)</span><br><span class="line">    let seqStr = <span class="built_in">string</span>(code)</span><br><span class="line"></span><br><span class="line">    var blkArr : <span class="built_in">array</span>&lt;<span class="built_in">array</span>&lt;ExpressionPtr&gt;&gt;; defer_delete(blkArr)</span><br><span class="line"></span><br><span class="line">    var blk : <span class="built_in">array</span>&lt;ExpressionPtr&gt;; defer_delete(blk)</span><br><span class="line">    blkArr |&gt; emplace(blk)</span><br><span class="line"></span><br><span class="line">    var cyclePatternChecker:<span class="built_in">array</span>&lt;<span class="keyword">int</span>&gt;</span><br><span class="line"></span><br><span class="line">    var initBlock &lt;- quote() &lt;|</span><br><span class="line">        var tape: <span class="built_in">array</span>&lt;uint8&gt;</span><br><span class="line">        var tapePos : <span class="keyword">int</span></span><br><span class="line">        tape |&gt; resize(<span class="number">1000000</span>)</span><br><span class="line">        var ptape = addr(tape[<span class="number">0</span>])</span><br><span class="line">    <span class="comment">//blkArr[0] |&gt; emplace_new &lt;| initBlock</span></span><br><span class="line">    unsafe</span><br><span class="line">        var _block &lt;- reinterpret&lt;smart_ptr&lt;ExprBlock&gt;&gt;(reinterpret&lt;smart_ptr&lt;ExprMakeBlock&gt;&gt; initBlock)._block</span><br><span class="line">        <span class="keyword">for</span> blockItem in _block.<span class="built_in">list</span></span><br><span class="line">            blkArr[<span class="number">0</span>] |&gt; emplace_new &lt;| blockItem</span><br><span class="line">    var symIt &lt;- unsafe(each(seqStr))</span><br><span class="line">    var sym : <span class="keyword">int</span></span><br><span class="line">    var repeat = <span class="literal">false</span></span><br><span class="line">    var count : <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> repeat || next(symIt, sym)</span><br><span class="line">        repeat = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">if</span> sym == <span class="string">'+'</span></span><br><span class="line">            cyclePatternChecker |&gt; push(sym)</span><br><span class="line">            repeat = <span class="literal">true</span></span><br><span class="line">            count = seachRepeats(symIt, sym, <span class="string">'+'</span>)</span><br><span class="line">            back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( $&#123; ptape[tapePos] = uint8(<span class="keyword">int</span>(ptape[tapePos]) + $v(count)); &#125;)</span><br><span class="line">        elif sym == <span class="string">'-'</span></span><br><span class="line">            cyclePatternChecker |&gt; push(sym)</span><br><span class="line">            repeat = <span class="literal">true</span></span><br><span class="line">            count = seachRepeats(symIt, sym, <span class="string">'-'</span>)</span><br><span class="line">            back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( $&#123; ptape[tapePos] = uint8(<span class="keyword">int</span>(ptape[tapePos]) - $v(count)); &#125;)</span><br><span class="line">        elif sym == <span class="string">'&gt;'</span></span><br><span class="line">            cyclePatternChecker |&gt; push(sym)</span><br><span class="line">            repeat = <span class="literal">true</span></span><br><span class="line">            count = seachRepeats(symIt, sym, <span class="string">'&gt;'</span>)</span><br><span class="line">            back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( $&#123; tapePos +=  $v(count); &#125;)</span><br><span class="line">        elif sym == <span class="string">'&lt;'</span></span><br><span class="line">            cyclePatternChecker |&gt; push(sym)</span><br><span class="line">            repeat = <span class="literal">true</span></span><br><span class="line">            count = seachRepeats(symIt, sym, <span class="string">'&lt;'</span>)</span><br><span class="line">            back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( $&#123; tapePos -= $v(count); &#125;)</span><br><span class="line"></span><br><span class="line">        elif sym == <span class="string">'.'</span> &#123; back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( $&#123; print(<span class="keyword">int</span>(ptape[tapePos]) |&gt; to_char); &#125;); &#125;</span><br><span class="line">        elif sym == <span class="string">','</span> &#123; back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( $&#123; ptape[tapePos] = uint8(getchar()); &#125;); &#125;</span><br><span class="line">        elif sym == <span class="string">'['</span></span><br><span class="line">            cyclePatternChecker |&gt; clear</span><br><span class="line">            cyclePatternChecker |&gt; push(sym)</span><br><span class="line">            var blk1 : <span class="built_in">array</span>&lt;ExpressionPtr&gt;; defer_delete(blk1)</span><br><span class="line">            blkArr |&gt; emplace(blk1)</span><br><span class="line">        elif sym == <span class="string">']'</span></span><br><span class="line">            cyclePatternChecker |&gt; push(sym)</span><br><span class="line">            <span class="keyword">if</span> match_reset(cyclePatternChecker)</span><br><span class="line">                <span class="comment">//match [-]</span></span><br><span class="line">                blkArr |&gt; pop()</span><br><span class="line">                back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( $&#123; ptape[tapePos] = uint8(<span class="number">0</span>); &#125;)</span><br><span class="line">            elif match_add_right_reset(cyclePatternChecker)</span><br><span class="line">                <span class="comment">//match [-&gt;+&lt;]</span></span><br><span class="line">                blkArr |&gt; pop()</span><br><span class="line">                back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( $&#123; ptape[tapePos+$v(count)] = uint8(<span class="keyword">int</span>(ptape[tapePos+$v(count)]) + <span class="keyword">int</span>(ptape[tapePos])); &#125;)</span><br><span class="line">                back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( $&#123; ptape[tapePos] = uint8(<span class="number">0</span>); &#125;)</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">//usual cycle</span></span><br><span class="line">                var last &lt;- back(blkArr)</span><br><span class="line">                blkArr |&gt; pop()</span><br><span class="line">                var whileExpr &lt;- qmacro_expr &lt;|</span><br><span class="line">                    <span class="keyword">while</span> ptape[tapePos] != uint8(<span class="number">0</span>)</span><br><span class="line">                        $b(last)</span><br><span class="line">                back(blkArr) |&gt; emplace_new &lt;| whileExpr</span><br><span class="line"></span><br><span class="line">            cyclePatternChecker |&gt; clear</span><br><span class="line">        <span class="keyword">else</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    var fnArguments : <span class="built_in">array</span>&lt;VariablePtr&gt;;</span><br><span class="line">    var fn &lt;- qmacro_function(uniqueName) &lt;| $ ($a(fnArguments))</span><br><span class="line">        unsafe</span><br><span class="line">            $b(blkArr[<span class="number">0</span>])</span><br><span class="line">    defer_delete(fn)</span><br><span class="line"></span><br><span class="line">    var args:<span class="built_in">array</span>&lt; tuple&lt;argname:<span class="built_in">string</span>;argvalue:RttiValue&gt; &gt;</span><br><span class="line">    fn |&gt; append_annotation(<span class="string">"$"</span>, <span class="string">"jit"</span>, args)</span><br><span class="line">    fn |&gt; append_annotation(<span class="string">"$"</span>, <span class="string">"unsafe_deref"</span>, args)</span><br><span class="line">    <span class="comment">//print(describe(fn))</span></span><br><span class="line">    compiling_module() |&gt; add_function(fn)</span><br></pre></td></tr></table></figure><p>Результат:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">e:\src\daScript_my\bin\Release&gt;daScript.exe brainfuck.das</span><br><span class="line">[I] total 0.70142899999999999 sec</span><br></pre></td></tr></table></figure><p>Еще на 17% быстрее<br><em>Из замеров явно стоило бы еще вынести print</em></p><h2 id="Немного-выводов"><a href="#Немного-выводов" class="headerlink" title="Немного выводов"></a>Немного выводов</h2><ul><li>Основа оптимизации — написание грамотного кода на основном языке.</li><li>Техники JiT-компиляции (особенно в сочетании с кодогенерацией или замерами hot участков) могут давать крутые результаты, в том числе превосходящие статическую компиляцию</li><li>Организация цепочки преобразований кода в одной среде НАМНОГО удобнее, чем в разных (какой-нибудь вариант “кодоген на python” + макросы/шаблоны + код на C++” - мрак с отладкой). Особенно для более длинных цепочек.</li><li>Нормальные макросы = нормальная отладка и скорость компиляции DSL.</li></ul><p><a href="https://github.com/spiiin/dascript_brainfuck" target="_blank" rel="noopener">Код примеров</a></p><p><em>update от 14.01.2023</em><br><em><a href="https://tratt.net/laurie/blog/2023/compiled_and_interpreted_languages_two_ways_of_saying_tomato.html" target="_blank" rel="noopener">Compiled and Interpreted Languages: Two Ways of Saying Tomato</a> - похожие замеры на rust</em></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Попробовал портировать с &lt;code&gt;nim&lt;/code&gt; на &lt;code&gt;daScript&lt;/code&gt; &lt;a href=&quot;https://howistart.org/posts/nim/1/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;интерпретатор&lt;/a&gt; &lt;code&gt;brainfuck&lt;/code&gt; кода. Брейфак предельно простой язык, и базовая реализация интерпретатора занимает полчаса, но на нём можно потренироваться в ускорении кода и продемонстрировать возможности daScript в оптимизации.&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="dascript" scheme="http://spiiin.github.io/tags/dascript/"/>
    
      <category term="llvm" scheme="http://spiiin.github.io/tags/llvm/"/>
    
  </entry>
  
  <entry>
    <title>ECS - типы и проблемы</title>
    <link href="http://spiiin.github.io/blog/1601029690/"/>
    <id>http://spiiin.github.io/blog/1601029690/</id>
    <published>2022-11-05T22:13:02.000Z</published>
    <updated>2022-11-06T09:38:35.748Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><h2 id="Where-is-my-components"><a href="#Where-is-my-components" class="headerlink" title="Where is my components"></a>Where is my components</h2><p>Одна из идей <code>ecs</code> — держать компоненты рядом в памяти и обходить в порядке хранения в памяти. По способу организации хранения <a href="https://github.com/SanderMertens/ecs-faq#what-are-the-different-ways-to-implement-an-ecs" target="_blank" rel="noopener">ECS FAQ</a> выделяет такие группы:</p><ul><li>Реактивные ECS</li></ul><p><a href="https://github.com/sschmid/Entitas/blob/main/src/Entitas/src/Entity/Entity.cs#L96" target="_blank" rel="noopener">Entitas</a> - компоненты валяются где-то на хипе, entity хранит указатели на компоненты. Добавление и удаление компонентов с помощью событий уведомляет системы, чтобы они обновили свои списки. О хранении рядом речи не идёт. На самом деле, по типу хранения тут скорее “Entity based”. Идея с тем, чтобы уведомлять системы при изменении списка компонента на сущности реализована и в других типах ECS</p><ul><li>Bitset based</li></ul><p><a href="hhttps://github.com/alecthomas/entityx/blob/82ab2d304ef5e6933cf6622721f086a1f4731e80/entityx/Entity.h#L641">EntityX</a> - компоненты хранятcя в отдельных пулах, entity хранит битовую маску, присутствует ли компонент в конкретной entity. Быстро, но очень расточительно в плане количества потребляемой памяти.</p><ul><li>Sparse set</li></ul><p><a href="https://github.com/skypjack/entt" target="_blank" rel="noopener">EnTT</a> - компоненты хранятся в системах, в структурах под названием <a href="https://github.com/skypjack/entt/blob/master/src/entt/entity/sparse_set.hpp#L151" target="_blank" rel="noopener">sparse_set</a>. Бывают структуры, владеющие компонентами, и хранящие индексы компонентов (дополнительный уровень индирекции), а также совмещенные варианты (владеет частью компонентов, но обращается к другим по индексам). Способ хранения компонент задаёт пользователь библиотеки, что позволяет выбирать наиболее быстрые способы, но взамен требуется хорошее понимание того, как правильно его выбрать.</p><p><a href="http://bitsquid.blogspot.com/2011/09/managing-decoupling-part-4-id-lookup.html" target="_blank" rel="noopener">Managing Decoupling Part 4 — The ID Lookup Table</a> - простое объяснение.<br><a href="https://skypjack.github.io/2019-03-07-ecs-baf-part-2/" target="_blank" rel="noopener">ECS back and forth Part 2 - Where are my entities?</a> - объяснение использования в EnTT.<br><a href="https://github.com/skypjack/entt/wiki/Crash-Course:-entity-component-system#groups" target="_blank" rel="noopener">Groups</a> - более детальное объяснения того, как ускорить доступ к паре компонентов, которыми владеет одна система. Совсем кратко — если система владеет компонентами A и B, то она может хранить их так, чтобы при обращении за сущностями с обоими компонентами компоненты этих сущностей всегда лежали в начале массивов.<br><a href="https://skypjack.github.io/2019-03-21-ecs-baf-part-2-insights/" target="_blank" rel="noopener">Part 2, insights - Sparse sets and grouping functionalities</a> - еще раз подробно о способе сортировки групп.</p><ul><li>Archetypes (aka “Dense ECS” or “Table based ECS”)<br><a href="https://github.com/SanderMertens/flecs" target="_blank" rel="noopener">flecs</a> - компоненты хранятся в архетипах. Архетип — сочетание уникального множества компонентов. Для каждого архетипа существует отдельный массив. Компонент хранит список архетипов, которые его включают. Сущность хранит указатель на массив архетипов, и индекс внутри этого массива (по которому получает сразу все свои компоненты).</li></ul><p>Таким образом, легко получить сразу все компоненты сущности, но при удалении/добавлении компонента необходимо “перекладывание” всей пачки компонентов из одного массива архетипов в другой. Также, если существует множество различных архетипов (сочетаний компонентов), и существует несколько систем, выбирающих одиночные компоненты, то расстояние в памяти между различными архетипами будет большим (как и если архетип достаточно большой - шаг между отдельными компонентами может быть большим)</p><p><a href="https://ajmmertens.medium.com/building-an-ecs-1-where-are-my-entities-and-components-63d07c7da742" target="_blank" rel="noopener">Building an ECS #1: Where are my Entities and Components</a> и<br><a href="https://ajmmertens.medium.com/building-an-ecs-2-archetypes-and-vectorization-fe21690805f9" target="_blank" rel="noopener">Building an ECS #2: Archetypes and Vectorization</a> - идея расскладыванием на архетипы</p><p><a href="https://github.com/GaijinEntertainment/daScript/blob/master/daslib/decs.das#L323" target="_blank" rel="noopener">decs</a> - библиотека ecs в <code>daScript</code> на архетипах<br><a href="https://github.com/GaijinEntertainment/daScript/blob/master/daslib/decs_boost.das" target="_blank" rel="noopener">decs_boost</a> - набор макросов, с помощью которых обращение с архетипами синтаксически похоже на обычный императивный код</p><p>Идеальным сочетанием для скорости выглядит использование <code>архетипов</code> в тех системах, где 1) не происходит постоянного добавления/удаления компонентов и 2) компонент используются только небольшим количеством систем (в примеры приводят низкоуровневые физические и графические подсистемы) + использование <code>sparse sets</code> там где существует большое количество типов компонент, которые постоянно добавляются/удаляются и систем, использующих разные сочетания компонентов (игровая логика).</p><h2 id="Проблемы-с-ECS"><a href="#Проблемы-с-ECS" class="headerlink" title="Проблемы с ECS"></a>Проблемы с ECS</h2><p>На чистом ECS сложно выразить некоторые распространённые в геймдеве задачи:</p><ul><li>Иерархии</li><li>Конечные автоматы</li><li>Декларативный GUI</li><li>Порядок работы систем (и повторный запуск)</li><li>Расширение/наследование компонентов</li><li>Контракты компонентов (взаимоисключающие сочетания, неудаляемые и т.п.)</li><li>Отображение объекта из нескольких сущностей как целого</li></ul><p>И более редкие</p><ul><li>Общее использование компонента сущностями</li><li>Несколько компонентов одного типа на сущности</li></ul><p><a href="https://ajmmertens.medium.com/ecs-from-tool-to-paradigm-350587cdf216" target="_blank" rel="noopener">ECS: From Tool to Paradigm</a> - список проблем<br><a href="https://takinginitiative.wordpress.com/2019/09/30/ecs-questions/" target="_blank" rel="noopener">ECS Questions</a> + <a href="https://takinginitiative.wordpress.com/2019/11/09/more-ecs-questions/" target="_blank" rel="noopener">More ECS Questions</a> - еще пара разборов ситуаций в игровом коде и способов их решения — порядок вызова систем в иерархических структурах, применительно к подсистеме анимации.</p><h2 id="Kruger-Engine-Entity-Model"><a href="#Kruger-Engine-Entity-Model" class="headerlink" title="Kruger Engine Entity Model"></a>Kruger Engine Entity Model</h2><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/jjEsB611kxs" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div><p><code>Game Engine Entity/Object Models</code> — большой обзор ECS подхода от Bobby Anguelov, с предложением гибридного подхода.<br><a href="https://takinginitiative.files.wordpress.com/2019/11/krgentitymodel.pdf" target="_blank" rel="noopener">Kruger Engine Entity Model</a> — презентация про демо-движок с подходом из видео-доклада.<br><a href="https://github.com/BobbyAnguelov/Esoterica" target="_blank" rel="noopener">Esoterica</a> - более позднее название демо-движка</p><p>Системы делятся на глобальные и локальные.</p><ul><li>Глобальные</li></ul><p>Чтобы передавать информацию между сущностями, и обновлять состояние мира</p><ul><li>Локальные<br>Чтобы передавать информацию между компонентами одной сущности (сущность не может получить доступ к компонентам напрямую, не через локальную систему, компоненты не могут ссылаться друг на друга или обновляться сами)<br>Чтобы гарантированно обновлять все компоненты родителя раньше дочерних, для систем, которым необходим порядок обновления</li></ul><p><img src="/blog/1601029690/slide_1_small.png" alt=""></p><p>Разрешено добавление нескольких компонентов одного типа на сущность, чтобы упростить построение иерархий (меш + сабмеши).<br>Разрешено явное задание пространственной иерархии между сущностями (с помощью <code>Spatial Component</code>, который имеет список дочерних Spatial Component и хранит пространственные матрицы)</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;h2 id=&quot;Where
      
    
    </summary>
    
    
    
      <category term="link" scheme="http://spiiin.github.io/tags/link/"/>
    
      <category term="ecs" scheme="http://spiiin.github.io/tags/ecs/"/>
    
  </entry>
  
  <entry>
    <title>daScript. SFML, dasBox и спайны</title>
    <link href="http://spiiin.github.io/blog/887709799/"/>
    <id>http://spiiin.github.io/blog/887709799/</id>
    <published>2022-11-05T16:42:25.000Z</published>
    <updated>2022-11-05T18:49:02.297Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Вкрутил в <a href="https://github.com/spiiin/dasbox_sfml" target="_blank" rel="noopener">dasbox_sfml</a> поддержку <a href="http://ru.esotericsoftware.com/" target="_blank" rel="noopener">spine-runtime</a>.</p><p>Добавлена минимальная поддержка — <a href="https://github.com/spiiin/dasbox_sfml/blob/main/src/sfmlSpine.cpp" target="_blank" rel="noopener">модуль</a> с кастомной обёрткой над типом и несколькими функциями настройки.</p><p>Сделан для того, чтобы детальнее разобраться с байндингом (проверить, как работает вручную, в отличие от автоматической генерации)<br><a href="/blog/500729544/" title="daScript: C++ auto-bindings, assimp">daScript: C++ auto-bindings, assimp</a><br>И чтобы улучшить визуал примеров<br><a href="/blog/4060902549/" title="daScript. SFML, dasBox и semi-transparent render target">daScript. SFML, dasBox и semi-transparent render target</a></p><p>Примеры:</p><h2 id="Рендер-спайна-в-текстуру"><a href="#Рендер-спайна-в-текстуру" class="headerlink" title="Рендер спайна в текстуру"></a>Рендер спайна в текстуру</h2><p><img src="/blog/887709799/spine_sfml_1_small.png" alt=""><br><a href="https://github.com/spiiin/dasbox_sfml/blob/main/samples/sfml_spines/demo_spines_2_rt.das" target="_blank" rel="noopener">https://github.com/spiiin/dasbox_sfml/blob/main/samples/sfml_spines/demo_spines_2_rt.das</a></p><p>Способ отрендерить полупрозрачный объект в рендер-таргет текстуру детально описан в первой части статьи (<code>source-over</code> и <code>premultiply alpha</code>). Также для сравнения выведена текстура с обычным режимом блендинга (посередине) — полупрозрачный шлем излишне чёрный.</p><h2 id="Shader"><a href="#Shader" class="headerlink" title="Shader"></a>Shader</h2><p><img src="/blog/887709799/spine_sfml_2_small.png" alt=""><br><a href="https://github.com/spiiin/dasbox_sfml/blob/main/samples/sfml_spines/demo_spines_3_shader.das" target="_blank" rel="noopener">https://github.com/spiiin/dasbox_sfml/blob/main/samples/sfml_spines/demo_spines_3_shader.das</a></p><p>Спайны чаще всего состоят из большого количества аттачментов (чаще всего 2d-меши), которые рендерятся послойно, так что для наложения некоторых эффектов, влияющих на изображение целиком (outline, различные виды distortion, motion-эффекты, glow), необходимо также предварительно отрендерить спайн целиком в текстуру. Отдельное приключение — получить размеры render-target текстуры, в которые поместиться спайн во время анимации. Чаще всего эти сведения можно получить только от артиста, либо просчитать в real-time/compile-time (анимации могут накладываться друг на друга различными способами).</p><p>В live-режиме удобно, что нет особой необходимости писать gui для настройки параметров шейдера, можно играться с ними, мгновенно получая фидбек на экране.</p><h2 id="Реверс-блендинг"><a href="#Реверс-блендинг" class="headerlink" title="Реверс-блендинг"></a>Реверс-блендинг</h2><p><img src="/blog/887709799/spine_sfml_3_small.png" alt=""><br><a href="https://github.com/spiiin/dasbox_sfml/blob/main/samples/sfml_spines/demo_spines_4_reverse_blending.das" target="_blank" rel="noopener">https://github.com/spiiin/dasbox_sfml/blob/main/samples/sfml_spines/demo_spines_4_reverse_blending.das</a></p><p>Напоследок — интересный и сложный в реализации через sfml и spine-runtime эффект, описанный в статье <a href="https://habr.com/ru/company/playrix/blog/487250/" target="_blank" rel="noopener">Отложенный Alpha blending</a>. Способ позволяет отрендерить “дырки” в спайнах любой формы за один проход, без использования предзаготовленных масок и рендер-таргет текстур. На скриншоте — анимированный спайн лианы, через которую сквозь основной спайн видно фоновый спрайт.</p><p>Реализация требует обратного порядка отрисовки и специальных формул блендинга. Порядок отрисовки:</p><ul><li>экран очищается цветом [0,255,0,0] - в альфа-компоненте должен быть 0, а не 255!</li><li>передний спайн с обычным режимом блендинга</li><li>спайн-“дырка”, с режимом блендинга “вычитание” - glBlendFunc(GL_ZERO, GL_ONE_MINUS_SRC_ALPHA)</li><li>фон, который “просвечивает” через основной спрайт только там, где была нарисована дырка - glBlendFuncSeparate(GL_SRC_ALPHA_SATURATE, GL_ONEU, GL_ONEU, GL_ONE_MINUS_SRC_ALPHA)</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">def initialize</span><br><span class="line">    ...</span><br><span class="line">    spine = <span class="keyword">new</span> SpineWrapper(<span class="string">"spineboy-pro.skel"</span>,  <span class="string">"spineboy-pma.atlas"</span>)</span><br><span class="line">    spine |&gt; set_position(<span class="number">320.0</span>, <span class="number">590.0</span>)</span><br><span class="line">    spine |&gt; set_animation(<span class="number">0</span>, <span class="string">"walk"</span>, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">    spineHole = <span class="keyword">new</span> SpineWrapper(<span class="string">"vine-pro.skel"</span>,  <span class="string">"vine-pma.atlas"</span>)</span><br><span class="line">    spineHole |&gt; set_premultiply_alpha(<span class="literal">false</span>) <span class="comment">//отключаем режим premultiply</span></span><br><span class="line">    spineHole |&gt; set_position(<span class="number">320.0</span>, <span class="number">640.0</span>)</span><br><span class="line">    spineHole |&gt; set_animation(<span class="number">0</span>, <span class="string">"grow"</span>, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">def draw</span><br><span class="line">    withRenderTarget &lt;| $(var rt: RenderTarget&amp;)</span><br><span class="line">        rt |&gt; clear(Color(<span class="number">0u</span>,<span class="number">255u</span>,<span class="number">0u</span>,<span class="number">0u</span>))</span><br><span class="line">        <span class="comment">//draw base spine</span></span><br><span class="line">        rt |&gt; draw(spine, RenderStates_Default())</span><br><span class="line"></span><br><span class="line">        <span class="comment">//draw hole spine</span></span><br><span class="line">        <span class="keyword">using</span>(Factor Zero, Factor OneMinusSrcAlpha, Equation Add) &lt;| $(var blendMode: BlendMode#)</span><br><span class="line">            <span class="keyword">using</span>(blendMode) &lt;| $(var renderState: RenderStates#)</span><br><span class="line">                rt |&gt; draw(spineHole, renderState)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//draw triangle, special render mode</span></span><br><span class="line">        <span class="comment">//raw opengl</span></span><br><span class="line">        glBlendFuncSeparate(GL_SRC_ALPHA_SATURATE, GL_ONEU, GL_ONEU, GL_ONE_MINUS_SRC_ALPHA)</span><br><span class="line">        glUseProgram(program)</span><br><span class="line">        vs_main_bind_uniform(program)</span><br><span class="line">        fs_main_bind_uniform(program)</span><br><span class="line">        glBindVertexArray(vao)</span><br><span class="line">        glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">6</span>)</span><br><span class="line">        glBindVertexArray(<span class="number">0u</span>)</span><br><span class="line">        glUseProgram(<span class="number">0u</span>)</span><br></pre></td></tr></table></figure><ul><li>spine-runtime позволяет аниматорам выставлять и переключать режимы блендинга самостоятельно, поэтому чтобы спайн был отрисован с кастомным режимом блендинга, необходимо использовать не “нормальный” блендинг, а <a href="https://github.com/spiiin/spine_cpp_sfml/blob/main/spine-sfml/spine-sfml.cpp#L171" target="_blank" rel="noopener">тот</a>, который был выставлен в sfml. Также спайн-“дырка” не должен использовать каких-либо дополнительный режимов блендинга в ходе анимации.</li><li>режим блендинга GL_SRC_ALPHA_SATURATE почему-то вообще не прокинут в <a href="https://www.sfml-dev.org/documentation/2.5.1/structsf_1_1BlendMode.php" target="_blank" rel="noopener">SFML</a>, поэтому фон отрисован с помощью функций opengl (<a href="https://www.sfml-dev.org/tutorials/2.5/window-opengl.php" target="_blank" rel="noopener">sfml+opengl</a> без проблем уживаются вместе).</li></ul><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;Вкрутил в 
      
    
    </summary>
    
    
    
      <category term="opengl" scheme="http://spiiin.github.io/tags/opengl/"/>
    
      <category term="dascript" scheme="http://spiiin.github.io/tags/dascript/"/>
    
  </entry>
  
  <entry>
    <title>daScript. SFML, dasBox и semi-transparent render target</title>
    <link href="http://spiiin.github.io/blog/4060902549/"/>
    <id>http://spiiin.github.io/blog/4060902549/</id>
    <published>2022-10-22T12:29:18.000Z</published>
    <updated>2022-10-23T17:36:01.564Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Пример работы с SFML в dasBox — рендер полупрозрачных объектов в рендер-таргет. Тривиальная задача для графического программиста, но почему-то многие разработчики игр не знают, как это корректно сделать.</p><h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>Изначальная задумка поста — собрать небольшой пример, показывающий алгоритм рендеринга полупрозрачных объектов в текстуру, с последующим корректным отображением этой текстуры, как если бы объекты рендерились на экран напрямую, без использования этой текстуры. Но попутно оказалось, что можно запилить фреймворк для таких демок, с возможноостью в live-режиме поиграться с параметрами и посмотреть результат.</p><h2 id="dasSFML"><a href="#dasSFML" class="headerlink" title="dasSFML"></a>dasSFML</h2><p>Примеры на <code>Opengl+GLFW</code>:<br><a href="/blog/4232971949/" title="daScript OpenGL">daScript OpenGL</a><br><a href="/blog/3006126295/" title="daScript - live-режим">daScript - live-режим</a></p><p>В отличие от GLFW, <code>SFML</code> представляет простые объекты-обёртки над функциями OpenGL для работы с текстурами, шейдерами, рендер-таргетами, и прочими примитивами библиотеки рендера, в то же время представляя для кастомизации практически все параметры рендера (во всяком случае необходимые для задуманного примера), для того, чтобы можно было писать небольшие примеры алгоритмов рендера на OpenGL.</p><p>Для начала, можно “завести” простейший <a href="https://github.com/borisbat/dasSFML/blob/main/examples/graphics.das" target="_blank" rel="noopener">пример</a> из комплекта привязки <code>SFML</code> к <code>daScript</code>.</p><p>Для его сборки выкачиваем сабмодули <code>daScript</code>:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git submodule update --init --recursive</span><br></pre></td></tr></table></figure></p><p>Затем включаем сборку этого модуля в CmakeLists.txt и добавляем линковку статической библиотеки с модулем libDasSFML и самих библиотек SFML:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">option(DAS_SFML_DISABLED &quot;Disable dasSFML (SFML multimedia library)&quot; OFF)</span><br><span class="line">...</span><br><span class="line">target_link_libraries(sfmlApp</span><br><span class="line">  libDasModuleSFML</span><br><span class="line">  sfml-graphics</span><br><span class="line">  sfml-network</span><br><span class="line">  sfml-system</span><br><span class="line">  sfml-window</span><br><span class="line">  #для windows также:</span><br><span class="line">  legacy_stdio_definitions</span><br><span class="line">  winmm</span><br><span class="line">  Opengl32</span><br><span class="line">  sfml-main</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>и перегененируем проект<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;generate_msvc_2019.bat</span><br></pre></td></tr></table></figure></p><p>Затем в хост-приложении на C++:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//подключение заголовка с определением модуля</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dasSFML/src/dasSFML.h&gt;</span></span></span><br><span class="line">...</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span>, <span class="keyword">char</span> * [] )</span> </span>&#123;</span><br><span class="line">    NEED_ALL_DEFAULT_MODULES;</span><br><span class="line">    NEED_MODULE(Module_dasSFML); <span class="comment">//&lt;---создаём модуль sfml</span></span><br><span class="line">    Module::Initialize();</span><br><span class="line">    run_script();</span><br><span class="line">    Module::Shutdown();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>run_script</code> вызывает метод <code>main</code> из примера, который создаёт SFML-окно и запускает цикл обработки сообщений в нём.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main</span><br><span class="line">    <span class="keyword">using</span>(VideoMode(<span class="number">640u</span>,<span class="number">480u</span>), <span class="string">"SFML window"</span>, uint(WindowStyle Default), ContextSettings()) &lt;| $ ( var window : RenderWindow# )</span><br><span class="line">        <span class="keyword">while</span> window |&gt; isOpen()</span><br><span class="line">            var event : Event</span><br><span class="line">            <span class="keyword">while</span> window |&gt; pollEvent(event)</span><br><span class="line">                <span class="keyword">if</span> event._type == EventType Closed</span><br><span class="line">                    window |&gt; close()</span><br><span class="line">            interface(window) &lt;| $ ( var rt : RenderTarget )</span><br><span class="line">                rt |&gt; clear( Color(<span class="number">64u</span>,<span class="number">0u</span>,<span class="number">0u</span>,<span class="number">255u</span>) )</span><br><span class="line">                <span class="keyword">using</span>(<span class="number">50.0f</span>,<span class="number">0x1e</span>ul) &lt;| $ ( var shape : CircleShape# )</span><br><span class="line">                    interface(shape) &lt;| $ ( var tr : Transformable )</span><br><span class="line">                        tr |&gt; move(<span class="number">20.</span>,<span class="number">30.</span>)</span><br><span class="line">                    shape |&gt; setFillColor(Color(<span class="number">150u</span>,<span class="number">50u</span>,<span class="number">250u</span>,<span class="number">255u</span>))</span><br><span class="line">                    shape |&gt; setOutlineThickness(<span class="number">10.f</span>)</span><br><span class="line">                    shape |&gt; setOutlineColor(Color(<span class="number">250u</span>,<span class="number">150u</span>,<span class="number">100u</span>,<span class="number">255u</span>))</span><br><span class="line">                    rt |&gt; draw(shape, RenderStates_Default())</span><br><span class="line">            window |&gt; display()</span><br></pre></td></tr></table></figure><p>В качестве фреймворка для создания окна используется имеющийся в SFML класс <code>Window</code>. Однако проще воспользоваться другим фреймворком, в который уже внедрены возможности daScript-а по перезагрузке кода.</p><h2 id="dasbox"><a href="#dasbox" class="headerlink" title="dasbox"></a>dasbox</h2><p><a href="https://github.com/imp5imp5/dasbox" target="_blank" rel="noopener">dasbox</a> — примитивный движок для 2d-игр, который Gaijin-ы использовали для проведения конкурса <a href="https://gaijinjam.net/ru" target="_blank" rel="noopener">Gaijin Jam</a> (<a href="https://github.com/AlexLemminG/TheFarmers" target="_blank" rel="noopener">игра-победитель</a>). Движок имеет простую <a href="https://github.com/imp5imp5/dasbox/blob/main/doc/api.txt" target="_blank" rel="noopener">апишку</a>, на которой можно потренироваться использованию языка на уровне “как будто типизированная lua”, а также настроен для подключения отладчика языка, веб-инспектора для отображения состояния ecs-модуля и горячей перезагрузке кода.</p><p>Но для меня интереснее другое — <code>dasbox</code> использует в качестве бекэнда <code>SFML</code>. И хотя это осознанно скрыто от пользователей для того, чтобы можно было сменить бекэнд, можно немного “поломать инкапсуляцию”, для того, чтобы воспользоваться в нём модулем <code>dasSFML</code>, и получить доступ к более богатому API, получив от самого dasbox-а фичи и инструменты по работе с кодом.</p><p><a href="https://github.com/spiiin/dasbox_sfml" target="_blank" rel="noopener">dasbox_sfml</a> — порт дасбокса с включенным модулем dasSFML.</p><p>Базовый пример на нём выглядит так:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">require daslib/media</span><br><span class="line">require sfml</span><br><span class="line">require dasbox_sfml</span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def initialize</span><br><span class="line">    set_window_title(<span class="string">"sfml"</span>)</span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line"><span class="function">def <span class="title">act</span><span class="params">(dt: <span class="keyword">float</span>)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">if</span> <span class="title">get_key</span><span class="params">(VK_ESCAPE)</span></span></span><br><span class="line"><span class="function">        <span class="title">schedule_quit_game</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">[export]</span><br><span class="line">def draw</span><br><span class="line">    withRenderTarget &lt;| $(var rt: RenderTarget&amp;)</span><br><span class="line">        rt |&gt; clear(Color(<span class="number">0u</span>,<span class="number">255u</span>,<span class="number">0u</span>,<span class="number">255u</span>))</span><br><span class="line">        <span class="keyword">using</span>(<span class="number">50.0f</span>,<span class="number">0x1e</span>ul) &lt;| $(var shape: CircleShape#)</span><br><span class="line">            interface(shape) &lt;| $(var tr: Transformable)</span><br><span class="line">                tr |&gt; move(<span class="number">20.</span>,<span class="number">30.</span>)</span><br><span class="line">            shape |&gt; setFillColor(Color(<span class="number">150u</span>,<span class="number">50u</span>,<span class="number">250u</span>,<span class="number">255u</span>))</span><br><span class="line">            shape |&gt; setOutlineThickness(<span class="number">10.f</span>)</span><br><span class="line">            shape |&gt; setOutlineColor(Color(<span class="number">250u</span>,<span class="number">150u</span>,<span class="number">100u</span>,<span class="number">255u</span>))</span><br><span class="line">            rt |&gt; draw(shape, RenderStates_Default())</span><br></pre></td></tr></table></figure><br><img src="/blog/4060902549/screen1_small.png" alt=""></p><p><code>dasBox_sfml</code> подхватывает изменения в файле с кодом, а также отображает в своей консоли ошибки в этом файле.</p><p>Идиомы <code>daScript</code> в примере:</p><ul><li><code>using()</code> - создание переменной <a href="https://dascript.org/doc/reference/language/temporary.html" target="_blank" rel="noopener">временного типа</a>, который существует только в пределах блока using</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span>() &lt;| $(var fs: das_string#)</span><br><span class="line">    fs := <span class="string">"hello world"</span></span><br><span class="line">    <span class="comment">//тут можно использовать переменную, в том числе передавать в другие функции</span></span><br><span class="line">    some_func(fs)</span><br><span class="line">    <span class="comment">//но нельзя как-либо сохранить указатель на эту переменную</span></span><br><span class="line">    <span class="comment">//var s = fs //ошибка, нельзя копировать временный тип</span></span><br></pre></td></tr></table></figure><ul><li><code>interface</code> - приведение к базовому типу</li></ul><p>Генератор привязок на C++ позволяет передать отношение наследования двух C++ типов в daScript так:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">addExtern&lt; <span class="keyword">decltype</span>(&amp;with_interface&lt;sf::Sprite,sf::Transformable&gt;), with_interface&lt;sf::Sprite,sf::Transformable&gt; &gt;(*<span class="keyword">this</span>,lib,<span class="string">"interface"</span>,SideEffects::invoke,<span class="string">"with_interface&lt;sf::Sprite,sf::Transformable&gt;"</span>);</span><br></pre></td></tr></table></figure></p><p><code>daScript</code> заставляет думать о типах и их времени жизни немного больше, чем C++, но и позволяет выразить больше таких утверждений, которые сможет проверить компилятор, чтобы уберечься от ошибок.</p><h2 id="RenderTarget"><a href="#RenderTarget" class="headerlink" title="RenderTarget"></a>RenderTarget</h2><p>Следующий пример — рендер в текстуру и отображение её на экране. В SFML для этого можно использовать класс <a href="https://www.sfml-dev.org/documentation/2.5.1/classsf_1_1RenderTexture.php" target="_blank" rel="noopener">RenderTexture</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">def draw</span><br><span class="line">    withRenderTarget &lt;| $(var rt: RenderTarget&amp;)</span><br><span class="line">        clear(rt, Color(<span class="number">0u</span>,<span class="number">255u</span>,<span class="number">0u</span>,<span class="number">255u</span>))</span><br><span class="line">        <span class="keyword">using</span>() &lt;| $(var rtTex: RenderTexture#)</span><br><span class="line">            rtTex |&gt; create(<span class="number">300u</span>, <span class="number">300u</span>, <span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">using</span>(<span class="number">50.0f</span>,<span class="number">0x1e</span>ul) &lt;| $(var shape: CircleShape#)</span><br><span class="line">                interface(shape) &lt;| $(var tr: Transformable)</span><br><span class="line">                    tr |&gt; move(<span class="number">20.</span>,<span class="number">30.</span>)</span><br><span class="line">                shape |&gt; setFillColor(Color(<span class="number">150u</span>,<span class="number">50u</span>,<span class="number">250u</span>,<span class="number">255u</span>))</span><br><span class="line">                shape |&gt; setOutlineThickness(<span class="number">10.f</span>)</span><br><span class="line">                shape |&gt; setOutlineColor(Color(<span class="number">250u</span>,<span class="number">150u</span>,<span class="number">100u</span>,<span class="number">255u</span>))</span><br><span class="line">                rtTex |&gt; draw(shape, RenderStates_Default())</span><br><span class="line">            <span class="keyword">using</span>(rtTex |&gt; getTexture()) &lt;| $(var sprite: Sprite#)</span><br><span class="line">                rt |&gt; draw(sprite, RenderStates_Default())</span><br></pre></td></tr></table></figure><p>Пока всё хорошо, и круг отрендеренный в текстуру выглядит также, как если бы был выведен на экран напрямую</p><h2 id="Полупрозрачные-объекты-в-RenderTarget"><a href="#Полупрозрачные-объекты-в-RenderTarget" class="headerlink" title="Полупрозрачные объекты в RenderTarget"></a>Полупрозрачные объекты в RenderTarget</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//рендер двух полупрозрачных кругов</span></span><br><span class="line"><span class="function">def <span class="title">drawCircles</span><span class="params">(var rt: RenderTarget&amp;)</span></span></span><br><span class="line">    using(125.0f, 128ul) &lt;| $(var shape: CircleShape#)</span><br><span class="line">        shape |&gt; setFillColor(Color(<span class="number">0u</span>,<span class="number">255u</span>,<span class="number">0u</span>,<span class="number">128u</span>))</span><br><span class="line">        rt |&gt; draw(shape, RenderStates_Default())</span><br><span class="line">    <span class="keyword">using</span>(<span class="number">125.0f</span>, <span class="number">128u</span>l) &lt;| $(var shape: CircleShape#)</span><br><span class="line">        interface(shape) &lt;| $(var tr: Transformable) &#123; tr |&gt; move(<span class="number">125.0f</span>, <span class="number">0.0f</span>); &#125;</span><br><span class="line">        shape |&gt; setFillColor(Color(<span class="number">255u</span>,<span class="number">05u</span>,<span class="number">0u</span>,<span class="number">128u</span>))</span><br><span class="line">        rt |&gt; draw(shape, RenderStates_Default())</span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def draw</span><br><span class="line">    withRenderTarget &lt;| $(var rt: RenderTarget&amp;)</span><br><span class="line">        rt |&gt; clear(Color(<span class="number">255u</span>,<span class="number">255u</span>,<span class="number">255u</span>,<span class="number">255u</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment">//простой рендер</span></span><br><span class="line">        text_out(<span class="number">0</span>, <span class="number">0</span>, <span class="string">"Simple"</span>, <span class="number">0xFF000000</span>)</span><br><span class="line">        drawCircles(rt)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//рендер в текстуру</span></span><br><span class="line">        text_out(<span class="number">0</span>, <span class="number">300</span>, <span class="string">"Texture"</span>, <span class="number">0xFF000000</span>)</span><br><span class="line">        <span class="keyword">using</span>() &lt;| $(var rtTex: RenderTexture#)</span><br><span class="line">            rtTex |&gt; create(<span class="number">250u</span> + <span class="number">125u</span>, <span class="number">250u</span>, <span class="literal">false</span>)</span><br><span class="line">            rtTex |&gt; clear(Color(<span class="number">0u</span>, <span class="number">0u</span>, <span class="number">0u</span>, <span class="number">0u</span>))</span><br><span class="line">            drawCircles(rtTex)</span><br><span class="line">            <span class="keyword">using</span>(rtTex |&gt; getTexture()) &lt;| $(var sprite: Sprite#)</span><br><span class="line">                interface(sprite) &lt;| $(var tr: Transformable)</span><br><span class="line">                    tr |&gt; move(<span class="number">0.0f</span>, <span class="number">300.0f</span>)</span><br><span class="line">                rt |&gt; draw(sprite, RenderStates_Default())</span><br></pre></td></tr></table></figure><p><img src="/blog/4060902549/screen2_small.png" alt=""></p><p>Полупрозрачные круги, отрендеренные в текстуру, выглядят темнее, чем отрисованные на экране напрямую. С реальными текстурами (или отрендеренными в текстуру шрифтами), проблема обычно выглядит как темная рамка на краях объекта (там где края ради сглаживания плавно “уходят” в прозрачность).</p><p>Из-за чего это возникает?</p><p>Цвет пиксела отрисованного объекта смешивается в пикселем, уже находящимся в буфере цвете по настраиваемым формулам. При прямой отрисовке порядок рендера получается таким:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">рисуется пиксел красного круга -&gt; смешивается с цветом dst1 фона (белое изображение) &#x3D; получаем цвет dst2</span><br><span class="line">рисуется пиксел зеленого круга -&gt; смешивается с цветом dst2 (фон + красный круг)</span><br></pre></td></tr></table></figure></p><p>Тогда как в случае рендера в текстуру происходит:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">рисуется пиксел красного круга -&gt; смешивается с фоновым цветом рендер таргет текстуры dst_rt1 (&quot;пустой&quot; rgba цвет, rgb каналы по умолчанию чёрные) &#x3D; получаем dst_rt2</span><br><span class="line">рисуется пиксел зелёного круга -&gt; смешивается с цветом dst_rt2 (пустой цвет текстуры + красный круг)</span><br><span class="line">текстура выводится на экран -&gt; смешивается цвет фона dst1 с цветом рендер таргет текстуры (пустой цвет текстуры + красный круг + зелёный круг)</span><br></pre></td></tr></table></figure></p><p>Видно, что в итоговом цвете на экрана присутствует влияние цвета render-target текстуры — прозрачного по альфа каналу, но в итоговой формуле кроме альфа канала влияение оказывают также и RGB каналы цвета (чёрного или любого другого — неважно, но избавиться от влияния этого фонового цвета без изменения формулы смешивания невозможно, “невидимый” цвет начинает быть видимым).</p><h2 id="Настройка-режимов-смешивания"><a href="#Настройка-режимов-смешивания" class="headerlink" title="Настройка режимов смешивания"></a>Настройка режимов смешивания</h2><p><code>OpenGL</code> (и <code>SFML</code> над ней) дают возможность переключать формулы режимов смешивания. Важно отойти от представления “определенная формула магическим образом включает полупрозрачность” к тому, что графический API просто даёт возможность изменить уравнение смешивание, а вывод конкретных формул ложится на плечи программиста.</p><p>Стандартное уравнение смешивания для полупрозрачности смешивает цвета в пропорции:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); </span><br><span class="line">GL_SRC_ALPHA - коэффициент смешивания рисуемого цвета - чем прозрачнее рисуемая фигура, тем меньше видно её цвет</span><br><span class="line">GL_ONE_MINUS_SRC_ALPHA - коэффициент смешивания фонового цвета - обратный, чем прозрачнее рисуемая фигура, тем больше видно цвет за ней</span><br><span class="line"></span><br><span class="line">r1 - цвет фона</span><br><span class="line">r2 - цвет 1-го круга</span><br><span class="line">r3 - цвет 2-го круга</span><br><span class="line">после отрисовки фона m1 &#x3D; (a1 * r1)</span><br><span class="line">смешанный цвет после отрисовки первого круга m2 &#x3D; (a2 * r2 + (1.0 - a2) * a1 * r1)</span><br><span class="line">смешанный цвет после отрисовки второго круга m3 &#x3D; (a3 * r3 + (1.0 - a3) * (a2 * r2 + (1.0 - a2) * a1 * r1)) &#x3D; </span><br><span class="line"> &#x3D; (a3 * r3 + (1.0 - a3) * a2 * r2 + (1.0 - a3) * (1.0 - a2) * a1 * r1)</span><br></pre></td></tr></table></figure></p><p>При рендере в текстуру по умолчанию используется другая формула, которая разделяет рассчёты для RGB-каналов цвета и для A-канала.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ONE_MINUS_SRC_ALPHA);</span><br><span class="line">для RGB-каналов - аналогично предыдущей формуле</span><br><span class="line">для A-канала:</span><br><span class="line">  Asrc + Adst * (1-Asrc) - альфа значение рисуемого цвета берётся &quot;как есть&quot; и складывается с уменьшенным фоновым значением </span><br><span class="line"></span><br><span class="line">Цвет и альфа для рендер-таргет текстуры - glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ONE_MINUS_SRC_ALPHA);</span><br><span class="line">цвет в рендер-таргет текстуре rt1 &#x3D; r1 * a1 (берём черный прозрачный цвет r1&#x3D;(0,0,0), a1&#x3D;0 - четвёртый компонент важен)</span><br><span class="line">цвет после добавления круга rt2 &#x3D; (a2 * r2 + (1.0 - a2) * a1 * r1) &#x3D; a2 * r2     &#x2F;&#x2F;premultiply alpha</span><br><span class="line">альфа после добавления круга rta2 &#x3D; a2 + a1 * (1-a2) &#x3D; a2</span><br><span class="line">цвет после добавления второго круга rt3 &#x3D; (a3 * r3 + (1.0 - a3) * a2 * r2)</span><br><span class="line">альфа после добавления второго круга rta3 &#x3D; a3 + a2 * (1 - a3)</span><br></pre></td></tr></table></figure><p>Эта формула годится только для рендера полностью непрозрачных объектов. Если какие-то части объекта прозрачные, необходимо использовать другую пару формул (для рендера в текстуру + для рендера полученной текстуры на экране). Для рендера в текстуру при этом можно даже получать “неправильные” цвета, которые можно потом смешать с изображением на экране так, чтобы смешанный итоговый цвет стал корректным.</p><p>Хороший разбор проблемы на <a href="https://stackoverflow.com/questions/24346585/opengl-render-to-texture-with-partial-transparancy-translucency-and-then-rende" target="_blank" rel="noopener">stackoverflow</a><br>Формулы смешивания также разжеваны в статье <a href="https://habr.com/ru/post/468067/" target="_blank" rel="noopener">Как работает альфа-композитинг</a></p><h2 id="Source-Over"><a href="#Source-Over" class="headerlink" title="Source-Over"></a>Source-Over</h2><p>Одно из возможных решений — смешать цвет полученной render target текстуры в режиме <code>Source-Over</code> (термин из статьи выше, из списка операторов смешивания Портера-Даффа):<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA)</span><br><span class="line">итоговый цвет m3 &#x3D; rt3 + m1 * (1.0 - rta3)</span><br><span class="line"></span><br><span class="line">подставим сюда значения значения из предудыщей формулы для рендерт-таргет цвета и текстуры:</span><br><span class="line">m3 &#x3D; (a3 * r3 + (1.0 - a3) * a2 * r2) + (a1 * r1) * (1.0 - a3 - a2 * (1 - a3))</span><br><span class="line"></span><br><span class="line">Теперь можно сравнить полученные значения итогового цвета m3 из формулы прямого рендера и этой формулы:</span><br><span class="line">m3_direct &#x3D;&#x3D; m3_sourceover</span><br><span class="line">(a3 * r3 + (1.0 - a3) * a2 * r2 + (1.0 - a3) * (1.0 - a2) * a1 * r1) &#x3D;&#x3D; (a3 * r3 + (1.0 - a3) * a2 * r2) + (a1 * r1) * (1.0 - a3 - a2 * (1 - a3))</span><br><span class="line">(1.0 - a3) * (1.0 - a2) &#x3D;&#x3D; (1.0 - a3 - a2 * (1 - a3)</span><br><span class="line">1.0 - a3 - a2 + a2*a3 &#x3D;&#x3D; 1.0 - a3 - a2 + a2*a3</span><br><span class="line"></span><br><span class="line">Тада! убедились в равенстве</span><br></pre></td></tr></table></figure></p><p>Код смешивания в режиме <code>Source-Over</code>, правильный результат:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">def draw</span><br><span class="line">    withRenderTarget &lt;| $(var rt: RenderTarget&amp;)</span><br><span class="line">        rt |&gt; clear(Color(<span class="number">255u</span>,<span class="number">255u</span>,<span class="number">255u</span>,<span class="number">255u</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment">//simple draw</span></span><br><span class="line">        text_out(<span class="number">0</span>, <span class="number">0</span>, <span class="string">"Simple"</span>, <span class="number">0xFF000000</span>)</span><br><span class="line">        drawCircles(rt)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//render texture draw</span></span><br><span class="line">        text_out(<span class="number">0</span>, <span class="number">300</span>, <span class="string">"Texture: Satsub"</span>, <span class="number">0xFF000000</span>)</span><br><span class="line">        <span class="keyword">using</span>() &lt;| $(var rtTex: RenderTexture#)</span><br><span class="line">            rtTex |&gt; create(<span class="number">250u</span> + <span class="number">125u</span>, <span class="number">250u</span>, <span class="literal">false</span>)</span><br><span class="line">            rtTex |&gt; clear(Color(<span class="number">0u</span>, <span class="number">0u</span>, <span class="number">0u</span>, <span class="number">0u</span>))</span><br><span class="line">            drawCircles(rtTex)</span><br><span class="line">            <span class="keyword">using</span>(rtTex |&gt; getTexture()) &lt;| $(var sprite: Sprite#)</span><br><span class="line">                interface(sprite) &lt;| $(var tr: Transformable)</span><br><span class="line">                    tr |&gt; move(<span class="number">0.0f</span>, <span class="number">300.0f</span>)</span><br><span class="line">                <span class="keyword">using</span>(Factor One, Factor OneMinusSrcAlpha, Equation Add) &lt;| $(var blendMode: BlendMode#)</span><br><span class="line">                    <span class="keyword">using</span>(blendMode) &lt;| $(var renderState: RenderStates#)</span><br><span class="line">                        rt |&gt; draw(sprite, renderState)</span><br></pre></td></tr></table></figure><br><img src="/blog/4060902549/screen3_small.png" alt=""></p><h2 id="Premultiply-alpha"><a href="#Premultiply-alpha" class="headerlink" title="Premultiply alpha"></a>Premultiply alpha</h2><p>Если посмотреть на коэффициенты смешивания в “неправильном” блендинге, и в <code>Sourse-Over</code>, можно прийти к более правильному интуитивному пониманию лишнего влияния цвета в неправильной версии. В неё не “вмешан” лишний чёрный цвет, а добавлено лишнее умножение цвета на альфа канал, которое “гасит” этот цвет больше, чем необходимо при корректном смешивании.</p><p>Можно пойти другим путём — убрать умножение цвета на альфу при смешивании совсем, но производить его 1 раз в шейдере — тогда не нужно переключать режим прозрачности, но нужно переключать шейдер, с которым отрисован объект. Преимуществом такого способами может быть то, что исходное изображение часто можно домножить на альфа-канал еще до запуска приложения (в демо-примере изображение генерится динамически, поэтому умножение сделано в шейдере).</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var fragmentShaderTex = (</span><br><span class="line"><span class="string">"uniform sampler2D texture;</span></span><br><span class="line"><span class="string">void main()</span></span><br><span class="line"><span class="string">\&#123;</span></span><br><span class="line"><span class="string">    gl_FragColor = texture2D(texture, gl_TexCoord[0].st);</span></span><br><span class="line"><span class="string">\&#125;"</span>)</span><br><span class="line"></span><br><span class="line">var fragmentShaderPremultiply = (</span><br><span class="line"><span class="string">"void main()</span></span><br><span class="line"><span class="string">\&#123;</span></span><br><span class="line"><span class="string">    //gl_FragColor = gl_Color;  //for testing no premultiply</span></span><br><span class="line"><span class="string">    gl_FragColor = vec4(gl_Color.rgb * gl_Color.a, gl_Color.a);</span></span><br><span class="line"><span class="string">\&#125;"</span>)</span><br><span class="line"></span><br><span class="line">var rsPremultiplySatSub, rsSatSub : RenderStates?</span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def initialize</span><br><span class="line">    set_window_title(<span class="string">"sfml"</span>) </span><br><span class="line"></span><br><span class="line">    var shaderPremult = <span class="keyword">new</span> Shader()</span><br><span class="line">    shaderPremult |&gt; load_fragment_shader_from_string(fragmentShaderPremultiply)</span><br><span class="line"></span><br><span class="line">    var shaderTex = <span class="keyword">new</span> Shader()</span><br><span class="line">    shaderTex |&gt; load_fragment_shader_from_string(fragmentShaderTex)    </span><br><span class="line">    shaderTex |&gt; bind_current_texture_to_uniform(<span class="string">"texture"</span>)</span><br><span class="line">    </span><br><span class="line">    var blendModeSatSubSeparate = <span class="keyword">new</span> BlendMode(Factor One, Factor OneMinusSrcAlpha, Equation Add, Factor OneMinusDstAlpha, Factor One, Equation Add)</span><br><span class="line"></span><br><span class="line">    rsPremultiplySatSub = makeRenderTarget(shaderPremult, blendModeSatSubSeparate)</span><br><span class="line">    rsSatSub = makeRenderTarget(shaderTex, blendModeSatSubSeparate)</span><br><span class="line"></span><br><span class="line">def drawCircles(var rt: RenderTarget&amp;; rs: RenderStates&amp; implicit)</span><br><span class="line">    <span class="keyword">using</span>(<span class="number">125.0f</span>, <span class="number">128u</span>l) &lt;| $(var shape: CircleShape#)</span><br><span class="line">        shape |&gt; setFillColor(Color(<span class="number">0u</span>,<span class="number">255u</span>,<span class="number">0u</span>,<span class="number">128u</span>))</span><br><span class="line">        rt |&gt; draw(shape, rs)</span><br><span class="line">    <span class="keyword">using</span>(<span class="number">125.0f</span>, <span class="number">128u</span>l) &lt;| $(var shape: CircleShape#)</span><br><span class="line">        interface(shape) &lt;| $(var tr: Transformable) &#123; tr |&gt; move(<span class="number">125.0f</span>, <span class="number">0.0f</span>); &#125;</span><br><span class="line">        shape |&gt; setFillColor(Color(<span class="number">255u</span>,<span class="number">05u</span>,<span class="number">0u</span>,<span class="number">128u</span>))</span><br><span class="line">        rt |&gt; draw(shape, rs)</span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">render_with_blend_and_premultiply</span><span class="params">(var rt: RenderTarget&amp;)</span></span></span><br><span class="line"><span class="function">    <span class="title">drawCircles</span><span class="params">(rt, *rsPremultiplySatSub)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">def <span class="title">render_sprite_with_blend</span><span class="params">(var rt: RenderTarget&amp;; var sprite: Sprite&amp; implicit)</span></span></span><br><span class="line">    rt |&gt; draw(sprite, *rsSatSub)</span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def draw</span><br><span class="line">    withRenderTarget &lt;| $(var rt: RenderTarget&amp;)</span><br><span class="line">        rt |&gt; clear(Color(<span class="number">255u</span>,<span class="number">255u</span>,<span class="number">255u</span>,<span class="number">255u</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment">//simple draw</span></span><br><span class="line">        text_out(<span class="number">0</span>, <span class="number">0</span>, <span class="string">"Simple"</span>, <span class="number">0xFF000000</span>)</span><br><span class="line">        drawCircles(rt, RenderStates_Default())</span><br><span class="line"></span><br><span class="line">        <span class="comment">//render texture draw</span></span><br><span class="line">        text_out(<span class="number">0</span>, <span class="number">300</span>, <span class="string">"Texture: Premult"</span>, <span class="number">0xFF000000</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">using</span>() &lt;| $(var rtTex: RenderTexture#)</span><br><span class="line">            rtTex |&gt; create(<span class="number">250u</span> + <span class="number">125u</span>, <span class="number">250u</span>, <span class="literal">false</span>)</span><br><span class="line">            rtTex |&gt; clear(Color(<span class="number">0u</span>, <span class="number">0u</span>, <span class="number">0u</span>, <span class="number">0u</span>))</span><br><span class="line">            render_with_blend_and_premultiply(rtTex)</span><br><span class="line">            <span class="keyword">using</span>(rtTex |&gt; getTexture()) &lt;| $(var sprite: Sprite#)</span><br><span class="line">                interface(sprite) &lt;| $(var tr: Transformable)</span><br><span class="line">                    tr |&gt; move(<span class="number">0.0f</span>, <span class="number">300.0f</span>)</span><br><span class="line">                render_sprite_with_blend(rt, sprite)</span><br></pre></td></tr></table></figure><p><img src="/blog/4060902549/screen4_small.png" alt=""></p><p>Универсальный режим смешивания для premultiply изображений:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">glBlendFuncSeparate(GL_ONE, GL_ONE_MINUS_SRC_ALPHA, GL_ONE_MINUS_DST_ALPHA, GL_ONE);</span><br><span class="line"></span><br><span class="line">Порядок рендера:</span><br><span class="line">1. Вывод в изображения в рендер-таргет текстуру с premultiply-шейдером (или же вывод подготовленного заранее изображения с обычным шейдером)</span><br><span class="line">2. Вывод рендер-таргет текстуры на экран с обычным шейдером (чтобы избежать лишнего умножения)</span><br><span class="line"></span><br><span class="line">математика (скопипащена с stackoverflow ответа):</span><br><span class="line">after layer 2: (a2 * r2, a2)</span><br><span class="line">after layer 3: (a3 * r3 + (1.0 - a3) * a2 * r2, (1.0 - a2) * a3 + a2)</span><br><span class="line"></span><br><span class="line">srcR &#x3D; a3 * r3 + (1.0 - a3) * a2 * r2</span><br><span class="line">srcA &#x3D; (1.0 - a2) * a3 + a2</span><br><span class="line">dstR &#x3D; a1 * r1</span><br><span class="line">ONE * srcR + ONE_MINUS_SRC_ALPHA * dstR</span><br><span class="line">    &#x3D; srcR + (1.0 - srcA) * dstR</span><br><span class="line">    &#x3D; a3 * r3 + (1.0 - a3) * a2 * r2 + (1.0 - ((1.0 - a2) * a3 + a2)) * a1 * r1</span><br><span class="line">    &#x3D; a3 * r3 + (1.0 - a3) * a2 * r2 + (1.0 - a3 + a2 * a3 - a2) * a1 * r1</span><br><span class="line">    &#x3D; a3 * r3 + (1.0 - a3) * a2 * r2 + (1.0 - a3) * (1.0 - a2) * a1 * r1</span><br></pre></td></tr></table></figure></p><p>Заметки по daScript:</p><ul><li>Вывод объекта с изменённым режимом блендинга и шейдером в <code>SFML</code> инкапуслирован в объекте <code>RenderStates</code></li><li>Вместо создания временных типов в этом примере используются “обычные” для <code>daScript</code> указатели:</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var shaderPremult : Shader? = <span class="keyword">new</span> Shader()</span><br></pre></td></tr></table></figure><p>Такие <a href="https://dascript.org/doc/reference/language/datatypes.html#pointers" target="_blank" rel="noopener">указатели</a> хранят объект в куче и владеют им, по семантике близко к <code>std::unique_ptr</code>. При желании можно освободить объект вручную, присвоив указателю <code>nullptr</code>.</p><ul><li>ключевое слово implicit после имени типа в аргументах функции позволяет функции работать с обычными типами, так и с временными.</li></ul><p>Код примеров - <a href="https://github.com/spiiin/dasbox_sfml/tree/main/samples/sfml_blending" target="_blank" rel="noopener">https://github.com/spiiin/dasbox_sfml/tree/main/samples/sfml_blending</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;Пример раб
      
    
    </summary>
    
    
    
      <category term="opengl" scheme="http://spiiin.github.io/tags/opengl/"/>
    
      <category term="dascript" scheme="http://spiiin.github.io/tags/dascript/"/>
    
  </entry>
  
  <entry>
    <title>daScript - решение задачек</title>
    <link href="http://spiiin.github.io/blog/2385889062/"/>
    <id>http://spiiin.github.io/blog/2385889062/</id>
    <published>2022-10-16T13:00:11.000Z</published>
    <updated>2022-10-16T13:55:33.792Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Решение нескольких алгоритмических задачек на <code>daScript</code>.<br><a id="more"></a></p><p>Задачки со старого собеса Nokia на C++ программиста (уже закрыли офис в России), <a href="https://twitter.com/st_1ena/status/1419689924505260032" target="_blank" rel="noopener">разбор</a></p><h2 id="Вычислить-первые-N-простых-чисел"><a href="#Вычислить-первые-N-простых-чисел" class="headerlink" title="Вычислить первые N простых чисел"></a>Вычислить первые N простых чисел</h2><p>.. и вернуть результат в качестве массива.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">calc_primes</span><span class="params">(n: <span class="keyword">int</span>; var a:<span class="built_in">array</span>&lt;<span class="keyword">int</span>&gt;)</span></span></span><br><span class="line">    a |&gt; clear</span><br><span class="line">    a |&gt; reserve(n)</span><br><span class="line"></span><br><span class="line">    a |&gt; push(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    a |&gt; push(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    let gen &lt;- generator&lt;<span class="keyword">int</span>&gt;() &lt;| $()</span><br><span class="line">        var t = <span class="number">6</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">true</span></span><br><span class="line">            yield t<span class="number">-1</span></span><br><span class="line">            yield t+<span class="number">1</span></span><br><span class="line">            t += <span class="number">6</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    var iterVal: <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">while</span> length(a) &lt; n</span><br><span class="line">        next(gen, iterVal)</span><br><span class="line">        var simple = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">for</span> prim in a</span><br><span class="line">            <span class="keyword">if</span> iterVal % prim == <span class="number">0</span></span><br><span class="line">                simple = <span class="literal">false</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> prim * prim &gt; iterVal</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> simple</span><br><span class="line">            a |&gt; push(iterVal)</span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main</span><br><span class="line">    var a: <span class="built_in">array</span>&lt;<span class="keyword">int</span>&gt;</span><br><span class="line">    calc_primes(<span class="number">1000000</span>, a)</span><br><span class="line">    print(<span class="string">"&#123;a[length(a)-1]&#125;\n"</span>)</span><br></pre></td></tr></table></figure><p><a href="https://github.com/spiiin/dascript_trivial_examples/blob/main/primes/primes.das" target="_blank" rel="noopener">https://github.com/spiiin/dascript_trivial_examples/blob/main/primes/primes.das</a></p><p>Тривиальная версия:</p><ul><li>чуть более улучшенная формула перебора чисел-кандидатов (вместо всех нечётных — t*6+/-1) + проверка границы не корнем, а квадратом.</li><li>не совсем понял, как хочет применить решето Эратосфена в варианте на C++ сама st_1ena, если нужны первые N простых чисел, а не “все числа меньшие N”, то возникает подзадача оценить минимальное натуральное число, меньше которого точно окажутся N простых чисел, что также нетривиально, или построить ленивых фильтров, что совсем нетривиально на C++, и требует оценки памяти под эти фильтры.</li><li>вместо этого, версия решения, которая может вычислить первые N чисел в compile-time — в предположении, что у нас есть некоторое количество памяти, для сохранения решета эратосфена, эффективнее тогда потратить всю эту память на хранение предпросчитанных первых значений, и начинать рассчёт только сверх этих предпросчитанных чисел. На языках с макросами — предпросчёт в compile-time выполняется той же функцией, что в run-time, т.е. не требует написания дополнительного кода.<br><a href="https://github.com/spiiin/dascript_trivial_examples/blob/main/primes/primes_mix_compile_runtime.das" target="_blank" rel="noopener">Версия</a>, которая сохраняет первый числа в кеш (макрос [cached_primes (count=200)] - с параметром, сколько чисел будет предпросчитано заранее)</li></ul><h2 id="Посчитать-статистику-слов-в-тексте-по-длине-слова"><a href="#Посчитать-статистику-слов-в-тексте-по-длине-слова" class="headerlink" title="Посчитать статистику слов в тексте по длине слова"></a>Посчитать статистику слов в тексте по длине слова</h2><p>Задача на то, чтобы найти в стандартной библиотеке языка нужные функциии</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">require fio</span><br><span class="line">require strings</span><br><span class="line">require daslib/strings_boost</span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line"><span class="function">def <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    var strings : <span class="built_in">array</span>&lt;<span class="built_in">string</span>&gt;</span></span><br><span class="line">    fopen("eng_to_rus.txt","rt") &lt;| $(f)</span><br><span class="line">        <span class="keyword">if</span> f != null</span><br><span class="line">            <span class="keyword">while</span> !feof(f)</span><br><span class="line">                strings |&gt; push &lt;| fgets(f)</span><br><span class="line"></span><br><span class="line">    var counter : table&lt;<span class="keyword">int</span>; <span class="keyword">int</span>&gt;</span><br><span class="line">    <span class="keyword">for</span> str in strings</span><br><span class="line">        var words &lt;- str |&gt; split_by_chars(<span class="string">" .,:-\n\t()%\"'"</span>)</span><br><span class="line">        <span class="keyword">for</span> word in words</span><br><span class="line">            <span class="keyword">if</span> word != <span class="string">""</span></span><br><span class="line">                counter[length(word)] += <span class="number">1</span>   <span class="comment">//word length</span></span><br><span class="line">                <span class="comment">//counter[word] += 1         //word</span></span><br><span class="line">    </span><br><span class="line">    var freq_pairs : <span class="built_in">array</span>&lt;tuple&lt;<span class="keyword">int</span>;<span class="keyword">int</span>&gt;&gt;</span><br><span class="line">    for k, v in keys(counter), values(counter)</span><br><span class="line">        freq_pairs |&gt; push &lt;| [[ tuple&lt;<span class="keyword">int</span>;<span class="keyword">int</span>&gt; k, v]]</span><br><span class="line">    freq_pairs |&gt; sort($(a,b) =&gt; !(a._1 &lt; b._1))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> pair in freq_pairs</span><br><span class="line">        print(<span class="string">"&#123;pair._0&#125; : &#123;pair._1&#125;\n"</span>)</span><br></pre></td></tr></table></figure><p><a href="https://github.com/spiiin/dascript_trivial_examples/blob/main/sort_words_stat_by_word_len/sort_words_stat_by_word_len.das" target="_blank" rel="noopener">https://github.com/spiiin/dascript_trivial_examples/blob/main/sort_words_stat_by_word_len/sort_words_stat_by_word_len.das</a></p><p>Решение в лоб - прочитать файл построчно, разбить на символы <code>split_by_chars</code>, обновляя в словаре значения количество слов. Дальше переложить значение в список пар, который отсортировать по первому элементу, и вывести на экран.</p><ul><li>Можно упороться по тому, чтобы выяснять у интервьюера, какие допустимы кодировки, разделители или что есть слова, как кажется подразумевали авторы задачи, которые потом расстроились, что ни один кандидат не учёл все возможные кейсы.</li><li>Можно сохранять данные не в словаре, а сразу в списке пар <code>(длина слова, частота)</code>, не так то и много возможных длин слов. Сортировка такого списка пар в daScript - либо с помощью явной передачи функции сортировки, либо определением <a href="https://github.com/GaijinEntertainment/daScript/blob/17941ef0b0199dff0db27a2bee603db1a45b69b3/examples/test/unit_tests/sort.das#L20" target="_blank" rel="noopener">оператора &lt;</a> для своего типа.</li></ul><h2 id="Удалить-из-односвязного-списка-каждый-пятый-элемент"><a href="#Удалить-из-односвязного-списка-каждый-пятый-элемент" class="headerlink" title="Удалить из односвязного списка каждый пятый элемент"></a>Удалить из односвязного списка каждый пятый элемент</h2><p>Интересно посмотреть на разницу в работе с памятью между C++ и daScript</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListItem</span></span></span><br><span class="line"><span class="class">    <span class="title">value</span>:</span> <span class="keyword">int</span></span><br><span class="line">    [[do_not_delete]] next: ListItem?</span><br><span class="line"></span><br><span class="line">def makeDemoList</span><br><span class="line">    var head =  <span class="keyword">new</span> [[ListItem value=<span class="number">1</span>]]</span><br><span class="line">    var current = head</span><br><span class="line">    <span class="keyword">for</span> i in range(<span class="number">2</span>, <span class="number">21</span>)</span><br><span class="line">        current.next = <span class="keyword">new</span> [[ListItem value=i]]</span><br><span class="line">        current = current.next</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">[sideeffects]</span><br><span class="line">def deleteEveryFifth(lst: ListItem?)</span><br><span class="line">    var counter = <span class="number">1</span></span><br><span class="line">    var current = lst</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> current != null</span><br><span class="line">        <span class="keyword">if</span> counter++ % <span class="number">4</span> == <span class="number">0</span></span><br><span class="line">            var toDelete = current.next</span><br><span class="line">            current.next = current.next?.next</span><br><span class="line">            unsafe &#123; <span class="keyword">delete</span> toDelete; &#125;</span><br><span class="line">        current = current.next</span><br><span class="line"></span><br><span class="line">def printList(lst: ListItem?)</span><br><span class="line">    <span class="keyword">if</span> lst != null</span><br><span class="line">        print(<span class="string">"&#123;lst.value&#125; "</span>)</span><br><span class="line">        printList(lst.next)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        print(<span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main</span><br><span class="line">    var <span class="built_in">list</span> = makeDemoList()</span><br><span class="line">    printList(<span class="built_in">list</span>)</span><br><span class="line">    deleteEveryFifth(<span class="built_in">list</span>)</span><br><span class="line">    printList(<span class="built_in">list</span>)</span><br><span class="line">    <span class="comment">//freeList //or just kill context</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Output:</span></span><br><span class="line"><span class="comment">// 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20</span></span><br><span class="line"><span class="comment">// 1 2 3 4 6 7 8 9 11 12 13 14 16 17 18 19</span></span><br></pre></td></tr></table></figure><p><a href="https://github.com/spiiin/dascript_trivial_examples/blob/main/delete_list_every_5/delete_every_fifth.das" target="_blank" rel="noopener">https://github.com/spiiin/dascript_trivial_examples/blob/main/delete_list_every_5/delete_every_fifth.das</a></p><ul><li>Раз мы “играем в C++”, то попробуем при удалении элемента из списка сразу же звать <a href="https://dascript.org/doc/reference/language/finalizers.html?highlight=finalizer" target="_blank" rel="noopener">финализатор</a> для него. Финализатор по умолчанию рекурсивно зовёт финализаторы для всех полей структуры. Это поведение можно изменить, если переопределить функцию <code>finalize</code>, или если пометить поле атрибутом <code>[[do_not_delete]]</code> (так как мы вручную измененяем указатели при удалении элемента, то элемент списка не отвечает за удаление следующего элемента по ссылке next).</li><li>С помощью <code>options persistent_heap = true</code>, можно настроить также освобождение памяти после вызова финализатора (иначе за освобождение памяти отвечает хост-программа, один из паттернов быстрой работы с памятью — грохнуть всю выделенную в цикле работы скрипта память разом).</li></ul><h2 id="Вывести-максимальное-число-составленное-из-единиц-двоичного-представления-заданного-числа"><a href="#Вывести-максимальное-число-составленное-из-единиц-двоичного-представления-заданного-числа" class="headerlink" title="Вывести максимальное число, составленное из единиц двоичного представления заданного числа"></a>Вывести максимальное число, составленное из единиц двоичного представления заданного числа</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">popcount</span><span class="params">(x)</span></span></span><br><span class="line"><span class="function">    var temp </span>= x</span><br><span class="line">    var count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> temp != <span class="number">0</span></span><br><span class="line">        temp &amp;= temp - <span class="number">1</span></span><br><span class="line">        count++</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line">def maxFrom1s(x)</span><br><span class="line">    let count1s = popcount(x)</span><br><span class="line">    var res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i in range(count1s)</span><br><span class="line">        res++</span><br><span class="line">        res&lt;&lt;=<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i in range(<span class="number">31</span> - count1s) <span class="comment">//assume 32 bits</span></span><br><span class="line">        res&lt;&lt;=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res </span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main</span><br><span class="line">    print(<span class="string">"&#123;uint(maxFrom1s(256-1))&#125;\n"</span>)  <span class="comment">//'0xff000000'</span></span><br></pre></td></tr></table></figure><p><a href="https://github.com/spiiin/dascript_trivial_examples/blob/main/max_value_from_1s/max_value_from_1s.das" target="_blank" rel="noopener">https://github.com/spiiin/dascript_trivial_examples/blob/main/max_value_from_1s/max_value_from_1s.das</a></p><p>Тоже без заморочек, в лоб.</p><p>В продакшен-варианте, если нужно действительно быстро, решение прокидывается в C++, где задействуются всевозможные интринсики компилятора для того, чтобы получать кол-во битов так, как умеет процессор, или другие трюки для минимизации количества инструкций (развернуть циклы, и наложить кучу масок — <a href="https://en.wikipedia.org/wiki/Hamming_weight" target="_blank" rel="noopener">Hamming weight</a>).</p><h2 id="Вывести-список-всех-самых-длинных-путей-в-дереве"><a href="#Вывести-список-всех-самых-длинных-путей-в-дереве" class="headerlink" title="Вывести список всех самых длинных путей в дереве"></a>Вывести список всех самых длинных путей в дереве</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">require daslib/functional</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span></span></span><br><span class="line"><span class="class">    <span class="title">data</span> :</span> <span class="keyword">int</span></span><br><span class="line">    left, right : Tree?</span><br><span class="line"></span><br><span class="line">var tree = <span class="keyword">new</span> [[ Tree data = <span class="number">5</span>,</span><br><span class="line">    left = <span class="keyword">new</span> [[Tree data = <span class="number">1</span>, </span><br><span class="line">        right = <span class="keyword">new</span> [[Tree data = <span class="number">2</span>]]</span><br><span class="line">    ]],</span><br><span class="line">    right = <span class="keyword">new</span> [[Tree data = <span class="number">7</span>,</span><br><span class="line">        right = <span class="keyword">new</span> [[Tree data = <span class="number">10</span>]]</span><br><span class="line">    ]]</span><br><span class="line">]]</span><br><span class="line"></span><br><span class="line"><span class="comment">//<span class="doctag">TODO:</span> optimize</span></span><br><span class="line">def clone_array(a: <span class="built_in">array</span>&lt;<span class="keyword">int</span>&gt;; newData:<span class="keyword">int</span>)</span><br><span class="line">    unsafe</span><br><span class="line">        var newArr &lt;- to_array(each(a))</span><br><span class="line">        newArr |&gt; push &lt;| newData</span><br><span class="line">        <span class="keyword">return</span> &lt;- newArr</span><br><span class="line"></span><br><span class="line">def each_element(var tree:Tree?; path: <span class="built_in">array</span>&lt;<span class="keyword">int</span>&gt;; depth:<span class="keyword">int</span>; blk:lambda&lt;(what: <span class="keyword">int</span>; path: <span class="built_in">array</span>&lt;<span class="keyword">int</span>&gt;; depth: <span class="keyword">int</span>):<span class="keyword">void</span>&gt;)</span><br><span class="line">    <span class="keyword">if</span> tree.left != null</span><br><span class="line">        each_element(tree.left, clone_array(path, tree.data), depth+<span class="number">1</span>, blk)</span><br><span class="line">    invoke(blk, tree.data, path, depth)</span><br><span class="line">    <span class="keyword">if</span> tree.right != null</span><br><span class="line">        each_element(tree.right, clone_array(path, tree.data), depth+<span class="number">1</span>, blk)</span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main</span><br><span class="line">    let startPath: <span class="built_in">array</span>&lt;<span class="keyword">int</span>&gt;</span><br><span class="line">    var globalResult : table&lt;<span class="keyword">int</span>; <span class="built_in">array</span>&lt;<span class="built_in">array</span>&lt;<span class="keyword">int</span>&gt;&gt;&gt;</span><br><span class="line">    unsafe</span><br><span class="line">        tree |&gt; each_element(startPath, <span class="number">0</span>) &lt;| @[[&amp;globalResult]](value: <span class="keyword">int</span>; path: <span class="built_in">array</span>&lt;<span class="keyword">int</span>&gt;; depth: <span class="keyword">int</span>)</span><br><span class="line">            globalResult[depth] |&gt; push_clone &lt;| clone_array(path, value)</span><br><span class="line">    <span class="comment">//find max depth</span></span><br><span class="line">    let maxDepth = reduce(keys(globalResult)) &lt;| $(left, right : <span class="keyword">int</span>)</span><br><span class="line">        <span class="keyword">return</span> left &gt; right ? left : right</span><br><span class="line">    <span class="comment">//print all pathes</span></span><br><span class="line">    print(<span class="string">"All pathes with longest depth:\n"</span>)</span><br><span class="line">    <span class="keyword">for</span> path in globalResult[maxDepth]</span><br><span class="line">        print(<span class="string">"&#123;path&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//All pathes with longest depth:</span></span><br><span class="line"><span class="comment">//[[ 5; 1; 2]]</span></span><br><span class="line"><span class="comment">//[[ 5; 7; 10]]</span></span><br></pre></td></tr></table></figure><p><a href="https://github.com/spiiin/dascript_trivial_examples/blob/main/all_pathes_max_depth/all_pathes_max_depth.das" target="_blank" rel="noopener">https://github.com/spiiin/dascript_trivial_examples/blob/main/all_pathes_max_depth/all_pathes_max_depth.das</a></p><p>Туповатое решение, с кучей лишних копирований путей.</p><p>Можно оптимайзить. Либо по памяти, разделив обход на 2 — сначала найти максимальную глубину, затем собрать только самые длинные пути. Либо в один проход, но сохраняя не полные копии путей, а альтернативное дерево с записью глубины каждой ветви рядом с указателем на оригинальные ноды left и right, по которому можно будет восстановить пути + обновляя максимальное значение глубины каждую итерацию.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Решение нескольких алгоритмических задачек на &lt;code&gt;daScript&lt;/code&gt;.&lt;br&gt;
    
    </summary>
    
    
    
      <category term="dascript" scheme="http://spiiin.github.io/tags/dascript/"/>
    
  </entry>
  
</feed>
