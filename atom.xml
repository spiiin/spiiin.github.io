<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Spiiin&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://spiiin.github.io/"/>
  <updated>2022-08-20T19:33:55.779Z</updated>
  <id>http://spiiin.github.io/</id>
  
  <author>
    <name>spiiin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Системы поиска сокровищ</title>
    <link href="http://spiiin.github.io/blog/3309518526/"/>
    <id>http://spiiin.github.io/blog/3309518526/</id>
    <published>2022-08-09T18:08:42.000Z</published>
    <updated>2022-08-20T19:33:55.779Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>В эссе <a href="https://probablydance.com/2019/06/08/treasure-hunting-systems-found-in-the-history-of-video-games/" target="_blank" rel="noopener">Treasure Hunting Systems Found in the History of Video Games</a> Malte Skarupke рассуждает о том, что в истории игр было несколько примеров случаев, когда появлялась платформа, в итоге порождающая сразу несколько новых успешных жанров. Он пытается выделить характеристики и свойства, общие для таких платформ, которые он называет “Системы поиска сокровищ”. Я не согласен со всеми наблюдениями автора, но попробую немного расширить его эссе. Это не перевод, а дополнение к оригинальной статье.</p><a id="more"></a><h2 id="Неравномерность-распределения-неизвестных-нам-величин"><a href="#Неравномерность-распределения-неизвестных-нам-величин" class="headerlink" title="Неравномерность распределения неизвестных нам величин"></a>Неравномерность распределения неизвестных нам величин</h2><p>Почему вообще на мой взгляд могут возникать такие системы?</p><p>Для начала два факта. Первый — в <strong><code>геймдеве очень много ОЧЕНЬ неравномерно распределённых величин</code></strong>. Главная из этих величин — количество фана от игры. Несколько примеров других:</p><ul><li>Большинство игр скучные, но есть очень небольшое количество очень весёлых и увлекательных. Они настолько лучше для нас, что затягивают невероятно сильнее — мы можем забывать про сон или важные дела, и возвращаемся к таким играм годами. У нас нет численной оценки удовольствия от игры, но вероятно, что эта разница этой нашей субъективной оценки между любимыми играми и просто хорошими была бы колоссально больше, чем между хорошими и плохими. Условно, все игры получили бы от нас от 1 до 9 баллов, а любимая, не 10, а скажем 1000000.</li></ul><ul><li>Как возможноое следствие, разница между доходами от игры от среднего игрока и от фаната — колоссальная. Это одна из причин существования модели условно-бесплатных игр. Несколько человек-фанатов могут принести дохода больше чем 1000000 человек, которым игра не понравилась.  </li></ul><p>Моя заметка про очень известное явление в геймдеве: <a href="/blog/1402387497/" title="Суперфанаты">Суперфанаты</a> — не называйте их китами!</p><blockquote><p>Отсюда следует одно важное правила гейм-дизайна: не ограничивайте сверху возможности потратить деньги в вашей игре, вы не знаете, как много игроки будут готовы вам заплатить, не надо запрещать им платить много</p></blockquote><ul><li>Но в то же время разница между хорошей игрой и средней по количеству потраченного труда небольшая. То есть, чтобы сделать игру, которая увлечёт в 1000000 раз сильнее (или в 1000000 раз больше игроков), не нужно в 1000000 раз больше усилий. Не нужно даже в 2 раза больше усилий. Возможно, достаточно всего несколько процентов. Важнее не количество усилий, а что-то другое — какие-то отдельные фичи или небольшие кусочки работы стоят в 1000000 раз больше других, именно от них может зависеть.</li></ul><p>Тайнан Сильвестр в статье <a href="https://tynansylvester.com/2013/12/email-dredging-cutting-polish-and-nonlinear-results/" target="_blank" rel="noopener">Email dredging: Cutting polish and nonlinear results</a> развёрнуто расписывает эту нелинейность между временем, потраченным на такие “золотые” фичи и тем, что они приносят в результате. Дальше я ещё буду ссылаться на эту статью и методы из неё.</p><ul><li>Суммарная разница в доходах между лучшими играми и хорошими тоже колоссально отличается — как от мультипликативности перечисленных выше факторов (лучшие игры притягивают в 1000 раз больше игроков И ОДНОВРЕМЕННО лучшие ещё и больше игроков конвертируют в суперфанатов), так и от положительной обратной связи — лучшие игры получают больше ресурсов для привлечения новых игроков, все хотят поиграть в лучшую игру.</li></ul><p>Я использовал разницу в 1000000 раз в примерах, но разница здесь может быть даже намного существеннее, причём настолько сильнее, что <strong>мы постоянно ошибаемся пытаясь её оценить</strong>. Главное — нельзя недооценивать её. Книга <code>Черный лебедь</code> Насима Талеба практически полностью о том, что мы плохо справляемся с прогнозами такого типа величин, из-за чего прогнозы часто бывают ошибочными. В совокупности с тем, насколько значима правильная оценка величины для нас, ошибки могут приводить к катастрофам (в узком смысле — будет ли наша компания продолжать делать игры или закроется).</p><p>Некоторые примеры разница нашего восприятия из книги приведены в статье <a href="https://ru.wikipedia.org/wiki/%D0%98%D0%B3%D1%80%D0%BE%D0%B2%D0%BE%D0%B5_%D0%B7%D0%B0%D0%B1%D0%BB%D1%83%D0%B6%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5" target="_blank" rel="noopener">Игровое заблуждение</a>.</p><p>Второй факт — <strong><code>мы всё ещё мало знаем о том, как именно сделать игру увлекательной, но знаем, что в процессе экспериментов можем обнаружить сверх-увлекательные идеи, которые мы затем сможем использовать в игре</code></strong>.</p><p>Случайная находка такого самородка в процессе экспериментов называется <code>серендипным открытием</code>. Самое известное такое открытие — случайное обнаружение механики <code>Тетриса</code>. Менее известные — небольшое изменение, превратившее прототип <code>Diablo</code> и пошаговой игры в ту, которую мы знаем. В статье <a href="/blog/2537188794/" title="Прототипирование в геймдеве">Прототипирование в геймдеве</a> я приводил ещё несколько известных примеров таких серьёзных трансформаций жанров игр (раздел <code>Путь от прототипа к результату</code>).</p><p>Несколько примеров занятий из мира компьютеров и разработки, связанных с исследованием неизвестного, которые требуют исключительной внимательности к каждой обнаруженной “необычной” мелочи:</p><ul><li>Тестирование и отладка програм. На этапе поиска причин возникновения очень редких ошибок. Часто первая зацепка, позволяющая обнаружить всю цепочку действий, приводящую к крешу, это случайное незапланированное наблюдение необычного поведения.</li><li>Реверс инжиниринг. Сама цель процесса — понять внутреннее устройство программы или данных, которые она интерпретирует, изначально не зная о нём ничего. Необходимо большое количество предположений и проверок, причём необходимо уметь отбрасывать варианты, которые “почти объясняют поведение”, но некоторые мелочи портят всё объяснение или меняют его смысл.</li><li>Аналитика. Наблюдение за поведением пользователей — процесс работы с очень “грязными” данными. Тенденции, видимые на графиках, сложно интерпретировать, и требуется умение не только придумать гипотезу и проверить её, но и достаточно быстро изменить и уточнить интерпретацию в случае расхождений с реальностью.</li><li>Плейтесты. Люди <a href="https://ru.wikipedia.org/wiki/%D0%A0%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F_(%D0%BF%D1%81%D0%B8%D1%85%D0%BE%D0%BB%D0%BE%D0%B3%D0%B8%D1%8F" target="_blank" rel="noopener">рационализируют</a> своё поведение, поэтому они не могут даже сказать вам, почему им понравилась или не понравилась игра — они будут неосознанно врать вам. Невозможно составить точный опросник, по которому игрок что-то расскажет вам, нужно отслеживать влияния изменений в игре на реальное, а не декларируемое поведение игроков.</li></ul><p>Однако, не смотря на возможности, экспериментирование не очень распространёно в реальных компаниях — зачем лезть в неизвестное (с неизвестными результатами!), если можно повторять “формулу успеха”? Делать игры дорого, и для инвесторов надёжнее вкладываться в то, что с большей вероятностью будет хорошо продаваться — проверенные жанры и франшизы.</p><p>Про элементы подхода с исследованиями в геймдеве я писал в статье — <a href="/blog/2486671624/" title="Метод Lean Startup">Метод Lean Startup</a>. Одна из основных идей — как можно раньше и дешевле собрать <code>Minimum Awesome Product</code>, игру, которая уже будет интересна игрокам, и начинать изучать свою аудиторию, выстроив процесс разработки так, чтобы данные экспериментов позволяли изменять дальнейшие планы разработки насколько это потребуется.</p><h2 id="Залежи-артефактов"><a href="#Залежи-артефактов" class="headerlink" title="Залежи артефактов"></a>Залежи артефактов</h2><p>Объединим эти два факта вместе — перед нами бесконечное поле неизвестных интересных механик для наших игр, <strong><code>&quot;зарытые в землю артефакты&quot;</code></strong>. Они очень сильно отличаются по характеристикам. Мы копаем наугад и рано или поздно откапываем часть артефакта — делаем прототип игры. Выкапывать весь артефакт дорого, поэтому для нас очень важно прикинуть стоимость как полную стоимость раскопок, так и то, за сколько мы сможем его продать. И всё это — только по торчащей из-под земли верхушке!</p><p>Часто хорошим решением является не копание артефакта сразу вглубь (фиксированное решение делать игру по плану несколько лет), а неглубокое копание окрестностей в <strong>разные</strong> стороны — создание ещё нескольких прототипов, проверяющих <strong>различные</strong> гипотезы. Потому что мы кое-что знаем про наше поле.</p><p>Например, артефакт может оказаться больше, чем кажется, и мы можем понять, в какую сторону лучше копать, чтобы быстрее его вытащить — обнаруженная нами неплохая механика для шутера может хорошо или плохо работать в паре с другими задуманными механиками. Или наоборот, артефакт мельче чем кажется, и развивать идею бесполезно, хотя они и выглядела интересно. Лучше не тратить время, и попробовать что-то другое.</p><p>Или же, редко, но бывает, что в окрестностях от того, что мы начали раскапывать, обнаруживается ещё множество артефактов. Мы просто не сможем выкопать и продать их все сами. К примеру мы обнаружили, что нашли механику для шутера, которая отлично работает с множеством различных других механик, и мы просто не можем взять их все в свою игру. Но мы можем поделиться находкой с игроками — пускай копают вместе с нами! Это и есть в терминологии автора — <strong><code>системы поиска сокровищ</code></strong>.</p><blockquote><p>Системы поиска сокровищ хорошо продаются</p></blockquote><p>Скрин из <a href="https://youtu.be/GxthbWfSak8?t=1275" target="_blank" rel="noopener">доклада</a> How Modding Made Bethesda Better, топовые игры в Steam по числу пользователей 2015 года, большинство игр в нём попадают в определение системы поиска сокровищ или даже просто сделаны в этих системах!<br><img src="/blog/3309518526/rate.png" alt="bench"></p><h2 id="Примеры-систем-поиска-сокровищ"><a href="#Примеры-систем-поиска-сокровищ" class="headerlink" title="Примеры систем поиска сокровищ"></a>Примеры систем поиска сокровищ</h2><p>Malte приводит три примера таких систем — моды к Warcraft 3, чехословацкое сообщество разработчиков игр 80х и Flash-игры, и сосредотачивается на общих характеристиках таких систем. Это интересный пример обобщения — рассматривать систему <code>игра + платформа + сообщество</code>, в которой границы между игрой и платформой сильно размыты (платформа может быть интегрирована в игру, быть “встроенным магазином” или внешним сайтом, а сама “игра” отсутствовать вообще, или быть условной, как например в RPG Maker), а сообщество геймеров иногда перерастает в субкультуру, представители которой не только играют в игру или занимаются её модификацией, но и воспринимает это как часть своего образа жизни (ролевики, проводящие LARP-ы по Fallout, или конвенты косплейеров — продолжение игры в реальной жизни).</p><p><strong><code>Сообщество-центричные системы</code></strong></p><p>Примеры сверхактивных сообществ моддеров различных периодов — пиратская сцена, в период, когда никто особо не заморачивался защитой игр, и копирование с изменениями часто были “фишками” команд, модифицирующих софт и игры.</p><p>Насколько я понял после пролистывания книжки про разработчивов Чехословакии, что-то подобное происходило и там. ZX-спектрум и кассеты в 80х, дискеты в 90х и CD в 2000х являлись платформой, новым способом передачи информации, вокруг которой объединялись геймеры, хакеры (переводчики, дизайнеры “оболочек”, читеры), коллекцинеры, продавцы, журналисты. Возможности для “креатива” здесь — открытые ресурсы для модификации и простота копирования, а также то, что в ходе распространения открывались возможность заработать немного денег и “очков престижа” — релиз группы соревновались и просто ради известности своей группировки внутри сообщества. Пример деятельности такого пиратского сообщества можно почитать и на русском в художественной форме — “Дневник тестировщика”/“Хроники тестировщика”, или посмотреть на английском — сериал “Сцена”.</p><p>Чехословацкая сцена выделилась тем, что в диком количестве насоздавала текстовых квестов. Похожий “взрыв” жанра игр произошёл с клонами <code>MUD</code>, его эволюция описана в книге Бартла <code>Designing Virtual Worlds</code>, средой распространения стал ранний интернет.</p><p>Нескольких “невзрывных” примеров хакерских сообществ (в СНГ было много модификаций игр/игры, но недостаточно для “критической массы” интересных модификаций, созданием занималось очень ограниченное количество людей) — <code>китайские клоны NES-картриджей</code>, в которых модифицировалась графика и отдельные элементы сюжета (видимо, было относительно просто хакать, но сложно тиражировать), и бесчисленные <code>модификации GTA 3/Vice City</code>, которые продавалась на отдельных компактах (к моменту пика популярности было относительно просто тиражировать CD-RW дома, но создание требовало как минимум навыков в 3D-моделировании, а как максимум — полноценного инструментария).</p><p>Своеобразным примером “взрыва” в прото-жанре игр песочниц может послужить <a href="https://www.youtube.com/watch?v=oKYiWb2W97k" target="_blank" rel="noopener">Infiminer</a>, исходники которого “утекли” в сеть. Модификаций было много, но из-за перекоса системы “игра-платформа-сообщество” в сторону хакерского сообщества, без общей игры и платформы оригинал умер, а мы все знаем одну из них на базе этих исходников, <code>Minecraft</code>, который уже и сам может служить примером системы поиска сокровищ с помощью внутриигровых модов.</p><p><strong><code>Игро-центричные системы</code></strong></p><p>Среди перечисленных автором примеров отсуствует возможно самый большой, который можно не заметить, так же как не можно не заметить изменения, которые принесли в геймдев социальные сети — мы просто живём в мире, где последствия этого “кембрийского взрыва”, повсюду и не задумываемся о том, что могло быть по другому. Это семейство игр и движков <code>Quake</code> от id software. Кроме крутости самих игр в техническом плане, авторы ещё и специально уделяли внимание ещё и тому, чтобы игры стали системой поиска сокровищ.</p><ul><li>Распространение. У id и до выхода Doom был опыт распространения игр по системе shareware, которая в тот момент была средством инди-разработчиков не зависеть от издателя. Можно было получить бесплатную демо-версию на дискетах, или скачать по сети.</li></ul><ul><li>Легкость в модификации. Кармак сознательно отделил ресурсы игры от приложения так, чтобы можно легче хакать игру. В дальнейшем, он принял революционное для того времени решение выложить в открытый доступ инструменты для модификации игры. Некоторые мультиплейерные режимы из современных шутеров родились из модов и тотальных коверсий Дума и Квейка. Один из примеров из книги “Властелины DOOM” — режимы “freeze tag” (салки) и “царь горы” из какого-то мода doom 2 по фильму “Aliens”.</li></ul><ul><li>Сама концепция движка как отделяемой от игры системы. Во-первых, возможность его лицензирования для сторонних разработчиков (Hexen и Eretic на движке Doom), и позже, взрыв игр и движков <a href="https://ru.wikipedia.org/wiki/Id_Tech_3" target="_blank" rel="noopener">на базе Quake 3</a>. Кроме игр, движок также прямо или косвенно повлиял на другие коммерческие движки — например, в книге “Архитектура игрового движка” есть схема происхождения движка <code>Medal of Honor</code> от этой “ветки эволюции”.</li></ul><ul><li>Отдельно от возможности лицензировать движок стоит выделить то, что исходники движков со временем традиционно выкладываются для свободного изучения и использования. Код Doom считают качественным (<a href="https://fabiensanglard.net/doom3/index.php" target="_blank" rel="noopener">1</a>, <a href="https://habr.com/ru/post/166113/" target="_blank" rel="noopener">2</a>, <a href="https://news.ycombinator.com/item?id=24921161" target="_blank" rel="noopener">3</a>). Часто он может служить не только историческим, но и образовательным целям.</li></ul><ul><li>Мультиплейер. Id уделили много внимания возможности и способам играть совместно, в разные периоды распространения сетевых технологий: по локально соединённым компьютерам, отдельным сереверам для клубов, игре через интернет. С их игр начался киберспорт и большие соревнования по играм.</li></ul><p>Другая система генерации сокровщ — движок и редактор <code>Warcraft</code> + матчи по Battle.net. Malte в своей статье рассуждает о том, чем Warcraft выделяется на основе других игр с мощными редакторами уровней. Основа здесь — гибкая базовая механика и возможность быстро попробовать и улучшить созданные карты. Можно выбросить/изменить/добавить некоторые механики (и редактор позволяет это делать!) и может получиться, что играть будет только интереснее. Дота — результат такого эксперимента, и постоянного тюнинга на основе тестов на игроках (описание <a href="https://dota2.fandom.com/ru/wiki/%D0%92%D0%B5%D1%80%D1%81%D0%B8%D0%B8_%D0%B8%D0%B3%D1%80%D1%8B" target="_blank" rel="noopener">327 патчей</a> карты).</p><p>Может быть, важным в случае Варкрафта является также хороший набор базовых элементов в песочнице редактора — можно посмотреть на реализацию карт из самой игры, и взять их них примеры расстановки “солдатиков” и “историй” про них.</p><p>Механики жанра стратегий позволяют много экспериментировать — <code>Civilization</code> также допускает создание карт-тотальных конверсий изначальной механики (некоторые из добавленных цивилизаций в последней части игры сами являются такими серьёзными экспериментами с переделками механик, ломающих правила).</p><p>Также хорошей платформой для экспериментов являются шутеры — <code>Counter-Strike</code>, <code>DayZ</code>, <code>PUBG</code> как примеры игр на движках шутеров с другими механиками, <code>Unreal Engine</code> как пример движка для шутера, выросшего в целую платформу.</p><p>На удивление, хуже работают модификации RPG, <code>Neverwinter Nights</code>, <code>The Elder Scrolls</code> предоставляют отличные редакторы, но они не породили новых жанров или серьёзно отличающихся механик. Автор связывает это с тем, что новые механики сложнее вписываются в существующие механики (и легче ломают баланс основной игры, если не являются изолированными модификациями), и часто требуют большего времени на плейтесты и получение обратной связи от игроков. Возможно, жанр ждёт своего взрыва.</p><blockquote><p>Если в редакторе уровней можно сделать только новые уровни для игры (неважно сколько) — это ещё не система генерации сокровищ. Сокровища появляются, когда редактор позволяет воплощать новые идеи</p></blockquote><p>Отдельное направление поиска — попытка создать игру, в которой сокровища будут генерировать пользователи внутри самой игры или встраивая контент прямо в игру (user-generated content). Примеры — творческие песочницы типа <code>Minecraft</code> или <code>Terraria</code>, в которых можно воссоздать известное здание или даже город, а также с помощью каких-нибудь простых логических триггеров выстроить несложную механику в рамках позволенного игрой (фабрики, механизмы, двигатели). Серьёзное ограничение при это — базовая механика и сеттинг игры.</p><p>Чем абстрактнее мир, тем проще воображению дорисовать что-то (хорошее объяснение эффекта можно найти в книге “Понимание комиксов”), и чем абстрактнее сеттинг, тем шире возможности того, что туда можно добавить, чтобы игроки посчитали это приемлемым в этом мире (виртуальный концерт рэпера в Fortnite будет нормально смотреться, но в World of Tanks будет неуместен, как и многое другое).</p><p><em>Свободное творчество игроков в виде возможности “построить что угодно”, часто требует цензуры со стороны разработчиков. Джесси Шел в книге по геймдизайну приводит пример “Disney Infinity”, в которой команда была вынуждена содержать отдел по борьбе с созданием в игре членов.</em></p><p>Самый удачный из существующих пример попыток создать такую систему — <code>Roblox</code>. Абстрактный мир, и “конструктор механик”, выданный игрокам в виде объектной модели, к которой можно получить доступ с помощью языка Lua. Наверное, где-то в этих серых горах тоже есть золото в виде новых механик и жанров. User-generated content системы не очень хорошо ложаться на экономику реального мира, поэтому вокруг вознаграждения за созданный контент витают идеи вроде NFT в блокчейнах.</p><p>Попытки создания мета-вселенных — это желание создать еще большую универсальную систему, в которую можно засунуть что угодно, однако часто разработчики не принимают во внимание идеи статьи. Они копают, но забывают, что поле мета-вселенных еще неизведано, и сколько там сокровищ еще предстоит узнать.</p><p><strong><code>Жанро-центричные системы</code></strong></p><p>По сути, это те же игроцентричные системы, только без самой игры. Есть платформы, направленные на создание игр строго определенного жанра. Кажется парадоксальным, что при таких ограничениях эти платформы также могут является системами генерации сокровищ в случаях, когда на них делают игры другого жанра, существующего или нового. Примеры таких платформ: <code>RpgMaker</code> для 2d-jrpg-style игр (самая известная игра на нём — To The Moon, в которой выброшены бои и оставлена только история). <code>Mugen</code> (2d-файтинги), <code>OpenBOR</code> (2d beat-them-up), <code>RenPy</code> (визуальные новеллы). Из-за серьёзных ограничений платформы, могут служить базой для экспериментов с механиками в самом жанре, но требуют out of the box мышления, чтобы делать с ними что-то отличное от задуманного, но сама лёгкость старта иногда позволяет проверить какую-нибудь небольшую идею быстрее, чем используя полноценную более универсальную платформу (особенно если доступны качественные строительные “кирпичики”, также как редакторе Warcraft доступны “солдатики” и “истории”).</p><p>Интересен пример с <code>Mario Maker</code>, как жанро-центричная система, оторванная от серии игр.</p><p><strong><code>Платформо-центричные системы</code></strong></p><p>Пример из оригинальной статьи — игры на <code>Flash</code>. Легко и быстро делать, просто выкладывать. Квинтэссенция подобных платформ, для которых главное, что “можно сделать игру быстро и с минимальными навыками программирования” (и бесплатно) — <code>Unity</code>. Unity хотела и стала системой, которую выбирают “по умолчанию”, когда ещё не знают, какие игры хотят делать и зачем. Кроме того, в Asset store можно дешево или бесплатно собрать пачку ассетов, эффектов или даже кусков кода, чтобы еще ускорить процесс, а также посмотреть, что сделали другие и показать, что сделал сам — это важные элементы для возможного “взрыва” творчества.</p><p>Контр-пример, когда для взрыва потенциально есть и платформа и жанры (навскидку — andry birds, cut the rope), но не хватает активного сообщества — <code>мобильные игры</code> в целом. Казуальные игроки менее склонны к исследованию и изменению игр (хотя, все любят кастомизацию), а владельцы апп-сторов блокируют возможность изучения и распостранения изменённых версий (нет своего аналога грин-лайта в steam для пк, или специальной поддержки начинающих разработчиков, строгая политика борьбы с нарушениями правил, высокий порог входа для запуска своей игры на телефоне). </p><blockquote><p>С этой точки зрения война за права распространять приложения и товары в приложениях через свои сторы и победа в ней, ДОЛЖНА БЫТЬ очень полезной в плане возможностй для разработчиков игр, в том числе и для создания систем поиска сокровищ</p></blockquote><h2 id="Свойства-систем-поиска-сокровищ"><a href="#Свойства-систем-поиска-сокровищ" class="headerlink" title="Свойства систем поиска сокровищ"></a>Свойства систем поиска сокровищ</h2><p>Что нужно, чтобы искать сокровища в таких системах, и какие у них отличия от менее удачных и популярных конкурентов?</p><ul><li>Легко начать и сделать что-то законченное:<ul><li>бесплатность</li><li>“батарейки” в комплекте (экосистема — набор библиотек, тулзов, и ассетов)</li><li>запуск одной кнопкой</li><li>возможность использования готовых компонентов</li><li>кросс-дисциплинарные возможности (если я программист — где взять ассеты? если я артист — как я буду писать код?).<br><em>(в презентации <a href="https://youtu.be/GxthbWfSak8?t=199" target="_blank" rel="noopener">How Modding Made Bethesda Better</a> Joel Burgess называет это эпифанией)</em></li></ul></li><li>Легко изменять сделанное:<ul><li>быстрый запуск</li><li>быстрое превью сделанного</li><li>как можно более быстрое внесение изменений, лучше всего вообще без перезапуска игры! — стимуляция к исследованию (тинкерингу)<br><em>(хех, про быстрые изменения, одна из причин, почему я слежу за <a href="https://spiiin.github.io/tags/dascript/">daScript</a> — это ключевая идея языка)</em></li></ul></li><li>Легко распространять сделанное:<ul><li>наличие среды распространения (игровые сервера, соцсети, спец. магазины, активное использование новых только появившихся медиа)</li><li>социальное доказательство в этой среде (система оценок игроками, простота выкладывания, наличие удобных фильтров для поиска, небольшой контроль за соблюдением правил — запреты на абьюз системы)</li><li>стимуляция возможностью заработать или стать популярным</li><li>доступность (не нужно регистрироваться или покупать что-то)</li><li>обратная совместимость (однажды сделанное должно продолжать работать всегда, без переделок)</li></ul></li><li>Легко получить обратную свзять:<ul><li>возможность эффективно получить оценки, критику и отзывы от игроков или других разработчиков</li></ul></li><li>Легко изучать и развиваться:<ul><li>наличие большого количества примеров</li><li>наличие ХОРОШИХ примеров</li><li>неограниченные возможности реализации сложных идей</li></ul></li></ul><h2 id="Ещё-несколько-около-игровых-систем"><a href="#Ещё-несколько-около-игровых-систем" class="headerlink" title="Ещё несколько около-игровых систем"></a>Ещё несколько около-игровых систем</h2><p> <strong><code>Креативы маркетинга</code></strong></p><p> Если отбросить лгбт-фанфики и прочий треш, то среди рекламных креативов от маркетологов, которые завлекают игроков в очередную казуалку, бывают и интересные идеи. По сложности реализации — примерно как флеш-игры, с требованием показать что-то игроку, быстрее чем за несколько десятков секунд, пока он пролистывает свои ленты новостей. Стимулирует к творчеству и необычным идеям здесь то, что ставки очень высоки — реклама стоит дорого, и если игроки не заинтересуются, то в рекламируемую игру просто никто не будет играть. </p><p> <strong><code>Хакатоны</code></strong></p><p> Искуственные ограничения, и необходимость слепить игру за ограниченное время стимулирует разработчиков искать необычные идеи там, где они не попробовали бы в обычных условиях. Изредка (очень изредка!) игры или идеи из хакатонов эволюционируют в полноценные игры.</p><p><strong><code>Генерация картинок</code></strong></p><p>Malte рассматривает уже мёртвый сайт picbreeder, позволяющий генерировать картинки эволюционным алгоритмом, как систему генерации сокровищ (в этом случае, интересных картинок, которые “вывели” пользователи). В <a href="https://youtu.be/dKazBM3b74I" target="_blank" rel="noopener">докладе</a>, выделена пара свойств этой системы:</p><ul><li>Лучший результат получается внезапно, а  не в результате итераций. Вывести случайными изменениями красивую картинку целенаправленно сложно (условный чайник получается не последовательным выведением носика или крышки, а из чего-то, похожего на яйцо в шляпе).</li><li>Картинки, полученные в результате голосований, хуже, чем в ходе индивидуального исследования системы (тинкеринга).</li></ul><p>Неизвестно, насколько выводы применимы к другим системам генерации сокровищ. Новая итерация “разведения картинок” — нейросеть <code>Dall-E</code>. Она умеет рисовать картинки по текстовому описанию, и также позволяет итеративные эксперименты — уточнение текста описания, перерисовка понравившейся пользователю картинки, с возможностью оставить нетронутой какую-то часть изображения. Где-то в её недрах определенно есть сокровища, которыми ещё предстоит научиться пользоваться.</p><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/84Wnp7lx3io" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div><p><em>сны нейросети о коммунизме, автора оригинала не смог найти</em></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;В эссе &lt;a href=&quot;https://probablydance.com/2019/06/08/treasure-hunting-systems-found-in-the-history-of-video-games/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Treasure Hunting Systems Found in the History of Video Games
&lt;/a&gt; Malte Skarupke рассуждает о том, что в истории игр было несколько примеров случаев, когда появлялась платформа, в итоге порождающая сразу несколько новых успешных жанров. Он пытается выделить характеристики и свойства, общие для таких платформ, которые он называет “Системы поиска сокровищ”. Я не согласен со всеми наблюдениями автора, но попробую немного расширить его эссе. Это не перевод, а дополнение к оригинальной статье.&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="dev_method" scheme="http://spiiin.github.io/tags/dev-method/"/>
    
      <category term="gamedesign" scheme="http://spiiin.github.io/tags/gamedesign/"/>
    
  </entry>
  
  <entry>
    <title>Карта блога</title>
    <link href="http://spiiin.github.io/blog/3774050611/"/>
    <id>http://spiiin.github.io/blog/3774050611/</id>
    <published>2022-08-06T13:50:31.000Z</published>
    <updated>2022-08-20T12:47:03.418Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Про что я пишу.</p><h2 id="Разработка"><a href="#Разработка" class="headerlink" title="Разработка"></a>Разработка</h2><p><a href="https://spiiin.github.io/tags/gamedev/">Gamedev</a> - разработка игр<br><a href="https://spiiin.github.io/tags/dev/">Dev</a> - общее<br><a href="https://spiiin.github.io/tags/dev-evolution/">Dev_evolution</a> - развитие в геймдеве<br><a href="https://spiiin.github.io/tags/dev-method/">Dev_method</a> - идеи, методы и подходы к разработке (в основном игр)<br><a href="https://spiiin.github.io/tags/gamedesign/">Gamedesign</a> - геймдизайн (больше лудология, чем практика)</p><h2 id="Программирование"><a href="#Программирование" class="headerlink" title="Программирование"></a>Программирование</h2><p><a href="https://spiiin.github.io/tags/dascript/">daScript</a><br><a href="https://spiiin.github.io/tags/cpp/">C++</a><br><a href="https://spiiin.github.io/tags/python/">Python</a><br><a href="https://spiiin.github.io/tags/asm/">Assembler</a> - ассемблер, в основном старых консолей</p><p>Много по мелочи в тегах — 3d, c#, nim, opengl, lua, squirell, scala, objc, codespell</p><h2 id="Ромхакинг"><a href="#Ромхакинг" class="headerlink" title="Ромхакинг"></a>Ромхакинг</h2><p><a href="https://spiiin.github.io/tags/hack">Hack</a> - ромхакинг, исследования игр, CadEditor, переделки игр</p><p>Отдельно по платформам — nes, sega, gba</p><h2 id="Личное"><a href="#Личное" class="headerlink" title="Личное"></a>Личное</h2><p><a href="https://spiiin.github.io/tags/log/">Log</a> - личные заметки<br><a href="https://spiiin.github.io/tags/%D0%BA%D0%BD%D0%B8%D0%B3%D0%B8/">Книги</a> - рецензии на книги<br><a href="https://spiiin.github.io/tags/games/">Игры</a> - про игры<br><a href="https://spiiin.github.io/tags/juggling/">Juggling</a> - жонглирование<br><a href="https://spiiin.github.io/tags/hardware/">Hardware</a> - баловство с электроникой<br><a href="https://spiiin.github.io/tags/fun/">Fun</a> - развлечения<br><a href="https://spiiin.github.io/tags/link/">Link</a> - ссылки<br><a href="https://spiiin.github.io/tags/%D0%BA%D1%80%D0%B8%D0%BF%D1%82%D0%BE/">Крипто</a> - блокчейны и криптовалюты<br><a href="https://spiiin.github.io/tags/%D0%BB%D1%8E%D0%B4%D0%B8/">Люди</a> - краткие биографии крутых чуваков</p><h2 id="Страница-всех-тегов"><a href="#Страница-всех-тегов" class="headerlink" title="Страница всех тегов"></a>Страница всех тегов</h2><p><a href="https://spiiin.github.io/tags/meta/">Meta</a> - все теги и мета-посты вроде этого</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;Про что я 
      
    
    </summary>
    
    
    
      <category term="meta" scheme="http://spiiin.github.io/tags/meta/"/>
    
  </entry>
  
  <entry>
    <title>Итераторы, колстеки, корутины</title>
    <link href="http://spiiin.github.io/blog/2550823652/"/>
    <id>http://spiiin.github.io/blog/2550823652/</id>
    <published>2022-08-01T18:39:01.000Z</published>
    <updated>2022-08-08T15:26:58.811Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Малость нырнул в кучу статей про асинхронность и корутины в различных языках. Напишу небольшую выдержку (с переводами примеров на <code>daScript</code> там, где актуально), о том, что корутины можно начинать рассматривать как расширение возможностей итераторов и колбеков (функторов), а не с более часто встречающихся генерации последовательностей или реализации паттерна “продюсер-консюмер”.</p><p>Ссылки<br> [1] <a href="http://journal.stuffwithstuff.com/2013/01/13/iteration-inside-and-out/" target="_blank" rel="noopener">Iterators Inside and Out</a> - обзор итераторов в различных языках, для каких задач удобны<br> [2] <a href="http://journal.stuffwithstuff.com/2013/02/24/iteration-inside-and-out-part-2/" target="_blank" rel="noopener">Iterators Inside and Out. Part 2</a> - подводка к тому, что абстракция итераторов требует примитивов работы с параллельным кодом<br> [3] <a href="http://journal.stuffwithstuff.com/2013/04/17/well-done/" target="_blank" rel="noopener">Well Done: A Sentinel Value</a> - каналы<br> [4] <a href="https://users.livejournal.com/-winnie/421941.html" target="_blank" rel="noopener">Итератор: внутрь и наружу</a> - совсем краткий вывод из статей [1] и [2], и дополнения в комментариях<br> [5] <a href="https://fprog.ru/lib/ferguson-dwight-call-cc-patterns/" target="_blank" rel="noopener">Паттерны использования «call with current continuation»</a> - перевод статьи про паттерны использования call with continuations в Lisp, среди которых — реализация корутин<br> [6] Журнал “Практика функционального программирования”. Статья “Продолжения на практике” - пример “выворачивания” внутреннего итератора во внешний<br> [7] <a href="https://yehudakatz.com/2010/02/07/the-building-blocks-of-ruby/" target="_blank" rel="noopener">The building blocks of Ruby</a> - особенности блоков в Ruby, нелокальные возвраты из итераторов<br> [8] <a href="https://okmij.org/ftp/Scheme/enumerators-callcc.html" target="_blank" rel="noopener">General ways to traverse collections</a> - обзоры способов обхода коллекций, примеры на Scheme. Итератор с памятью (стейт-машина) в функциональном стиле<br> [9] <a href="https://okmij.org/ftp/papers/LL3-collections-enumerators.txt" target="_blank" rel="noopener">Towards the best collection API</a> - пример “выворачивания” итераторов на Scheme<br> [10] <a href="https://legacy.cs.indiana.edu/~sabry/papers/yield.pdf" target="_blank" rel="noopener">Yield: Mainstream Delimited Continuations</a> - yield в разных языках. <a href="https://en.wikipedia.org/wiki/Delimited_continuation" target="_blank" rel="noopener">Delimited continuations</a><br> [11] <a href="http://pllab.is.ocha.ac.jp/~asai/cw2011tutorial/main-e.pdf" target="_blank" rel="noopener">Introduction to Programming with Shift and Reset</a> - операторы shift и reset<br> [12] <a href="https://probablydance.com/2015/01/11/ideas-for-a-programming-language-part-2-a-more-liberal-call-stack/" target="_blank" rel="noopener">Ideas for a Programming Language Part 2: A more liberal call stack</a> - про недостатки абстракции стека вызовов<br> [13] <a href="https://www.chiark.greenend.org.uk/~sgtatham/coroutines.html" target="_blank" rel="noopener">Coroutines in C</a> - классическая статья про проблемы реализации корутин в C. Трюк с реализацией корутин с помощью <a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%B5%D1%82%D0%BE%D0%B4_%D0%94%D0%B0%D1%84%D1%84%D0%B0" target="_blank" rel="noopener">метода Даффа</a><br> [14] <a href="https://probablydance.com/2021/10/31/c-coroutines-do-not-spark-joy" target="_blank" rel="noopener">C++ Coroutines Do Not Spark Joy</a> - обзор реализации корутин в стандарте C++<br> [15] <a href="https://www.scs.stanford.edu/~dm/blog/c++-coroutines.html#the-promise-object" target="_blank" rel="noopener">My tutorial and take on C++20 coroutines</a> - ещё одна статья про корутины в C++ 20, трюк с хранением результата корутины на стеке через Promise Object<br> [16] <a href="https://github.com/lewissbaker/cppcoro" target="_blank" rel="noopener">CppCoro - A coroutine library for C++</a> - библиотека обёрток над корутинами из стандарта C++<br> [17] <a href="https://www.youtube.com/watch?v=8C8NnE1Dg4A" target="_blank" rel="noopener">CppCon 2016: Gor Nishanov “C++ Coroutines: Under the covers”</a> - доклад про реализацию корутин в стандарте C++, особенности реализации генерируемого кода в LLVM, возможности по оптимизации кода на уровне LLVM. Хорошо для понимания того, когда возможна элиминация выделения памяти. <a href="https://llvm.org/docs/Coroutines.html" target="_blank" rel="noopener">LLVM coroutines</a> - интринсики для корутины в LLVM.<br> [18] <a href="https://probablydance.com/2013/02/20/handmade-coroutines-for-windows/" target="_blank" rel="noopener">Handmade Coroutines for Windows</a> - альтернативные реализации корутин для windows. Раз C++ не даёт прямого доступа к указателю на стек, можно подменить его на ассемблере<br> [19] <a href="https://probablydance.com/2012/11/18/implementing-coroutines-with-ucontext/" target="_blank" rel="noopener">Implementing coroutines with ucontext</a> - реализация корутин через posix ucontext<br> [20] <a href="https://www.boost.org/doc/libs/1_79_0/libs/context/doc/html/index.html" target="_blank" rel="noopener">Boost::Context</a> - реализации переключения контекста из boost. Используют обёртки над posix или платформенные заголовки для переключения контекста, или <a href="https://gcc.gnu.org/wiki/SplitStacks" target="_blank" rel="noopener">ассемблерный трюк</a> из gcc (<a href="https://gcc.gnu.org/legacy-ml/gcc-help/2012-03/msg00395.html" target="_blank" rel="noopener">особенности реализации</a>)<br> [21] <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0534r3.pdf" target="_blank" rel="noopener">call/cc (call-with-current-continuation): A low-level API for stackful context switching</a> - пропозал по добавлению в стандарт c++ функционала call/cc<br> [22] <a href="https://go.dev/doc/effective_go#goroutines" target="_blank" rel="noopener">Goroutines</a> - горутины из go, управляются рантаймом языка. <a href="https://go.dev/tour/concurrency/1" target="_blank" rel="noopener">Tour of Go. Goroutines</a>. Планировщик горутин кооперативный, но “ощущается”, как вытесняющий<br> [23] <a href="https://www.youtube.com/watch?v=YEKjSzIwAdA" target="_blank" rel="noopener">Concurrency Patterns In Go</a> - каналы, оператор select выбора из нескольких каналов<br> [24] <a href="https://www.raywenderlich.com/books/kotlin-coroutines-by-tutorials/v2.0/chapters/5-async-await" target="_blank" rel="noopener">Kotlin coroutines. async/await</a> - многопоточные async/await в Kotlin. Идиомы future/promise, async/await/deferred<br> [25] <a href="http://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/" target="_blank" rel="noopener">What Color is Your Function?</a> - проблемы с комбинированием синхронных и асинхронных функций<br> [26] <a href="https://kristoff.it/blog/zig-colorblind-async-await/" target="_blank" rel="noopener">What is Zig’s “Colorblind” Async/Await?</a> - необычный подход Zig, трансформация синхронных функций в асинхронные и наоборот<br> [27] <a href="https://ziglearn.org/chapter-5/" target="_blank" rel="noopener">Zyg’s Async</a> - Async в Zig (<a href="https://ziglang.org/documentation/master/#Async-Functions" target="_blank" rel="noopener">документация</a>)</p><h2 id="Внешние-итераторы"><a href="#Внешние-итераторы" class="headerlink" title="Внешние итераторы"></a>Внешние итераторы</h2><p>Внешний итератор — объект, реализующий некоторый интерфейс Iterator (<a href="http://msdn.microsoft.com/en-us/library/system.collections.ienumerable.aspx" target="_blank" rel="noopener">C#</a>, <a href="https://docs.python.org/2/library/stdtypes.html#iterator-types" target="_blank" rel="noopener">Python</a>), у которого есть методы получения первого элемента коллекции (метод у коллекции или свободная функция), перехода на следующий элемент, и проверки на то, есть ли ещё элементы. На шаблонах C++ — явного интерфейса нет, но есть протокол, декларирующий способы описания итератора для своих типов.</p><p>Рассматривается в книге Банды Четырёх. В [8] критикуется название за активный суффикс -or, хотя методы итератор зовёт внешний код, предлагается название iteratee. Итераторы в стиле C++ также называют курсорами.</p><p><a href="https://dascript.org/doc/reference/language/iterators.html?highlight=iterator" target="_blank" rel="noopener">Итераторы</a> в <code>daScript</code>:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var it &lt;- each ([[<span class="keyword">int</span> <span class="number">1</span>;<span class="number">2</span>;<span class="number">3</span>;<span class="number">4</span>;<span class="number">5</span>]]) <span class="comment">//создание итератора</span></span><br><span class="line">var x : <span class="keyword">int</span></span><br><span class="line"><span class="function"><span class="keyword">while</span> <span class="title">next</span><span class="params">(it, x)</span>      <span class="comment">// получение следующего значения</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"x = &#123;x&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">verify</span><span class="params">(empty(it))</span>      <span class="comment">// функция проверки проверки существования следующего значения</span></span></span><br></pre></td></tr></table></figure><p>Часто в языках есть синтаксический сахар для того, чтобы записывать выражение выше как <code>for-each</code> цикл:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var it &lt;- each ([[<span class="keyword">int</span> <span class="number">1</span>;<span class="number">2</span>;<span class="number">3</span>;<span class="number">4</span>;<span class="number">5</span>]])</span><br><span class="line"><span class="keyword">for</span> x in it</span><br><span class="line">  print(<span class="string">"x = &#123;x&#125;\n"</span>)</span><br></pre></td></tr></table></figure></p><p>Элегантно решаемая внешним итератором задача:</p><p><strong><code>Поиск элемента</code></strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//TT - generic-тип, TT-&amp; - "убрать из определения типа символ ссылки"</span></span><br><span class="line"><span class="function">def <span class="title">find</span><span class="params">(it: iterator&lt;<span class="keyword">auto</span>(TT)&gt;; value:TT-&amp;)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">for</span> x in it</span></span><br><span class="line"><span class="function">    <span class="keyword">if</span> x </span>== value &#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>Более неаккуратное решение</p><p><strong><code>Проверка двух коллекций на равенство</code></strong><br>(и эквивалентные задачи, требуюшие поочередного обращения к двум или более коллекциям — функция <code>zip</code>; итератор выдающий по очереди элементы каждой коллекции)</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">is_equal</span><span class="params">(it1, it2: iterator&lt;<span class="keyword">auto</span>(TT)&gt;)</span></span></span><br><span class="line">  var i2: TT-&amp;</span><br><span class="line">  var it2Ended: <span class="keyword">bool</span></span><br><span class="line">  <span class="keyword">for</span> i1 in it1               <span class="comment">//обращение к первому итератору</span></span><br><span class="line">    it2Ended = next(it2, i2)  <span class="comment">//обращение ко второму итератору</span></span><br><span class="line">    <span class="keyword">if</span> !it2Ended || (i1 != i2)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  <span class="keyword">return</span> !next(it2, i2)</span><br></pre></td></tr></table></figure><p>Неэлегантный пример</p><p><strong><code>Итератор в дереве</code></strong></p><p>Рекурсивная функция печати дерева на экран занимает 4 строки<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span></span></span><br><span class="line"><span class="class">  <span class="title">data</span>:</span> <span class="keyword">int</span></span><br><span class="line">  left, right: Tree?</span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">printTree</span><span class="params">(a: Tree?)</span></span></span><br><span class="line">  if a != null</span><br><span class="line">    printTree(a.left)</span><br><span class="line">    print(<span class="string">"&#123;a.data&#125;\n"</span>)</span><br><span class="line">    printTree(a.right)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">let tree = <span class="keyword">new</span> [[ Tree </span><br><span class="line">    data = <span class="number">5</span>,</span><br><span class="line">    left = <span class="keyword">new</span> [[Tree </span><br><span class="line">      data = <span class="number">1</span></span><br><span class="line">    ]],</span><br><span class="line">    right = <span class="keyword">new</span> [[Tree</span><br><span class="line">      data = <span class="number">7</span>,</span><br><span class="line">      right = <span class="keyword">new</span> [[Tree</span><br><span class="line">        data = <span class="number">10</span></span><br><span class="line">      ]]</span><br><span class="line">    ]]</span><br><span class="line">  ]] </span><br><span class="line">printTree(tree)</span><br></pre></td></tr></table></figure></p><p>Попробуем написать итератор для дерева. Строительным блоком для кастомных внешних итераторов в <code>daScript</code> служат <a href="https://dascript.org/doc/reference/language/lambdas.html?highlight=lambda#iterators" target="_blank" rel="noopener">лямбда-функции</a>.<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IterateState</span></span></span><br><span class="line"><span class="class">  <span class="title">tree</span>:</span> Tree?</span><br><span class="line">  step: <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">var <span class="built_in">stack</span>: <span class="built_in">array</span>&lt;IterateState?&gt;</span><br><span class="line"><span class="built_in">stack</span> |&gt; push(<span class="keyword">new</span> [[IterateState tree = tree]])</span><br><span class="line">unsafe</span><br><span class="line">  let treeIterator &lt;- @ &lt;| (var current: <span class="keyword">int</span>&amp;) : <span class="keyword">bool</span></span><br><span class="line">    var hasValue = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">while</span> !empty(<span class="built_in">stack</span>) &amp;&amp; !hasValue</span><br><span class="line">      var state = back(<span class="built_in">stack</span>)</span><br><span class="line">      <span class="keyword">if</span> state.step == <span class="number">0</span></span><br><span class="line">        state.step = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (state.tree.left != null)</span><br><span class="line">          push(<span class="built_in">stack</span>, <span class="keyword">new</span> [[IterateState tree = state.tree.left]])</span><br><span class="line">      elif state.step == <span class="number">1</span></span><br><span class="line">        state.step = <span class="number">2</span></span><br><span class="line">        current = state.tree.data</span><br><span class="line">        hasValue = <span class="literal">true</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        pop(<span class="built_in">stack</span>)</span><br><span class="line">        <span class="keyword">if</span> (state.tree.right != null)</span><br><span class="line">          push(<span class="built_in">stack</span>, <span class="keyword">new</span> [[IterateState tree = state.tree.right]])</span><br><span class="line">    <span class="keyword">return</span> hasValue</span><br><span class="line">  <span class="keyword">for</span> v in each(treeIterator)</span><br><span class="line">    print(<span class="string">"&#123;v&#125;\n"</span>)</span><br></pre></td></tr></table></figure></p><p>Можно также написать итератор в ООП стиле, определив класс в C++ и перегрузив функцию <a href="https://github.com/GaijinEntertainment/daScript/blob/6f0f1a7025f20cb5a0fc73838e97ba371eb5c263/include/daScript/ast/ast.h#L415" target="_blank" rel="noopener">isIterable</a>, но пример в ООП-стиле есть в [1], он там занимает также занимает 50 строк.</p><p>На <code>daScript</code> получилось 26, но всё равно, как, во имя Святой Матери Тьюринга, из четырёх-строчной рекурсивной функции получилась такая каша?</p><h2 id="Колстек"><a href="#Колстек" class="headerlink" title="Колстек"></a>Колстек</h2><p>Часть работы в функции <code>printTree</code> за нас выполнила скрытая структура данных, <strong><code>callstack</code></strong>. </p><p>Во время рекурсивного первого рекурсивного вызова программа кладёт в стек адрес возврата, и осуществляет вызов этой функции, затем проделывает работу по вызову “полезной нагрузки” (<code>print</code>). После чего в следует второй рекурсивный вызов.</p><blockquote><p>Если на собеседовании у вас спросят, какая у вас любимая структура данных, смело отвечайте “стек вызовов”, и рассказывайте про то, как было бы плохо писать программы без него</p></blockquote><p>Если внимательно посмотреть на структуру функции <code>treeIterator</code>, можно заметить, что она выполняет те же шаги, в той же последовательности!</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">printTree</span><span class="params">(a: Tree?)</span></span></span><br><span class="line"><span class="function">    <span class="comment">//step 0 - кладём в стек адрес возврата, и начинаем новую итерацию вызова функции</span></span></span><br><span class="line"><span class="function">    <span class="title">printTree</span><span class="params">(a.left)</span></span></span><br><span class="line"><span class="function">    <span class="comment">//step 1 - выполняем "полезную нагрузку"</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;a.data&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function">    <span class="comment">//step 2 - кладём в стек адрес возврата</span></span></span><br><span class="line"><span class="function">    <span class="title">printTree</span><span class="params">(a.right)</span></span></span><br><span class="line"><span class="function">    <span class="comment">//невидимый</span></span></span><br><span class="line"><span class="function">    <span class="comment">//step 3 - ..выходим из функции, удаляем из стека верхнее значение, возвращаемся выше по стеку</span></span></span><br></pre></td></tr></table></figure><p>Можно заметить небольшое различие на шаге 2 — в реализации <code>printTree</code> сначала происходит второй рекурсивный вызов, и затем возврат из основной функции, а в <code>treeIterator</code> значение сначала удаляется из стека, а затем в него кладётся новое. Это похоже на то, как происходит <a href="https://en.wikipedia.org/wiki/Tail_call" target="_blank" rel="noopener">tail call optimization</a> — вместо того, чтобы положить в стек второе значение, а потом удалить и два верхних значения, мы сразу же удаляем ненужный более адрес возврата, т.е. выполняем step3, еще до step2.</p><p>Также функция <code>printTree</code> приостанавливается в точках 0 и 2, на момент вызова подпрограммы, и продолжает выполнение после возврата из подпрограммы. Это вторая крутая возможность, которую предоставляет колстек, и о которой при программировании обычно даже не задумываются. Однако при кастомной реализации итератора мы сталкиваемся с тем, что без каких-либо особых трюков приостановить выполнение функции и продолжить его с того же места невозможно. Вместо этого приходится эмулировать паузы с помощью конечного автомата, реализуемого с помощью цикла и переключения пути выполнения изменением переменной <code>state</code>.</p><p>Собственно, большинство идей, связанных с сопрограммами (википедия <a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B0" target="_blank" rel="noopener">напоминает</a>, что ни в коем случае не следует путать их с копрограммами!), так или иначе связаны с тем, чтобы предоставить нам возможность приостанавливать выполнение функции и продолжать его.</p><p>Уже может стать понятно, что для этого язык должен каким-либо образом предоставить языковые конструкции, которые позволили бы нам не определять переменную <code>var stack: array&lt;IterateState?&gt;</code> явно, а “отдавать команду” положить туда что-то неявно, в идеале так же прозрачно, как это происходит в момент вызова функции.</p><p>Также стоит обратить внимание на то, где выделяется и хранится эта переменная. Здесь это просто локальная переменная, захваченная лямбда-функцией, но перед компилятором при реализации сопрограмм стоит серьёзная задача — где разместить этот “другой” стек. С одной стороны — его можно выделить в куче, чтобы он мог “пережить” область создания итератора, с другой — такая аллокация замедляет создание сопрограмм.</p><p>В общем-то, практически все отличия в реализации сопрограмм в разных языках сводятся к тому, чтобы различными способами решить эти вопросы — где и как будут выделяться <em>“другие стеки”</em>, и каким образом к ним можно обращаться из языка. Различных подходов много, и они имеют свои плюсы и минусы. Если с этого момента <em>прояснилось</em>, можно походить по ссылкам, заглянуть, кто что придумал в различных языках. Впрочем, можно снова зависнуть где-нибудь на Лиспе, или языках с ленивыми вычислениями.</p><p>Но пока вернёмся к колстеку — стоит ещё раз сравнить функции <code>printTree</code> и более общую <code>treeIterator</code>, и помедитировать на способ, которым сделано обобщение. Такое представление “невидимого” в коде колстека в явном виде называется <a href="https://en.wikipedia.org/wiki/Reification_(computer_science" target="_blank" rel="noopener">реификацией</a>.</p><h2 id="Внутренние-итераторы"><a href="#Внутренние-итераторы" class="headerlink" title="Внутренние итераторы"></a>Внутренние итераторы</h2><p>Внутренний итератор — функция-callback, которая передаётся в функцию обхода коллекции.</p><p>Итерация разделяет код на 2 части: (1) код ответственный за генерацию серии объектов, и  (2) код, который выполняет над переданным ему объектом некоторую операцию. Для внешних итераторов это (1) тип, который может реализовывать протокол итерации и (2) тело цикла обхода. В этом стиле (2) является главным, он решает, когда запросить следующее значение, или когда прекратить итерации. Внутренние итераторы выворачивают всё наизнанку. Код, который генерирует значения, решает, когда ему вызвать переданный ему колбек.</p><p>Внешние функции, перебирающие значения, могут быть реализованы как методы объекта (<a href="https://apidock.com/ruby/Array/each" target="_blank" rel="noopener">array.each</a> в Ruby), или generic-функции (<a href="https://en.cppreference.com/w/cpp/algorithm/ranges/find" target="_blank" rel="noopener">std::find_if</a> в C++)</p><p>Элегантно решаемые внутренними итераторами задачи:</p><p><strong><code>Итерация по дереву</code></strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">each</span><span class="params">(var tree:Tree?; blk:lambda&lt;(what: <span class="keyword">int</span>):<span class="keyword">void</span>&gt;)</span></span></span><br><span class="line"><span class="function">  <span class="title">if</span> <span class="params">(tree.left != null)</span>  </span>&#123; each(tree.left, blk); &#125;</span><br><span class="line">  invoke(blk, tree.data)</span><br><span class="line">  <span class="keyword">if</span> (tree.right != null) &#123; each(tree.right, blk); &#125;</span><br><span class="line"></span><br><span class="line">tree |&gt; each() &lt;| @(value: <span class="keyword">int</span>)</span><br><span class="line">  print(<span class="string">"&#123;value&#125;\n"</span>)</span><br></pre></td></tr></table></figure><p>Отлично, в 3 строчки.</p><p><strong><code>Поиск элемента</code></strong></p><p>Возьмём общий внутренний генератор <code>map</code> из стандартной-библиотеки <a href="https://github.com/GaijinEntertainment/daScript/blob/master/daslib/functional.das" target="_blank" rel="noopener">functional</a> функцию поиска индекса элемента в массиве по условию (это синтетический пример, в модуле <code>buildin</code> есть более эффективная реализация этой <a href="https://github.com/GaijinEntertainment/daScript/blob/a7c6565f652b56d0eee82b6e27974cdc09f06574/src/builtin/builtin.das#L701" target="_blank" rel="noopener">функции</a>)</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">my_find_index_if</span><span class="params">(var arr: iterator&lt;<span class="keyword">auto</span>(TT)&gt; <span class="keyword">explicit</span>; blk:lambda&lt;(what:TT -&amp;):<span class="keyword">auto</span>(QQ)&gt;)</span></span></span><br><span class="line">  for value, i in map(arr, blk), range(INT_MAX)</span><br><span class="line">    <span class="keyword">if</span> value</span><br><span class="line">      <span class="keyword">return</span> i</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//using</span></span><br><span class="line">var it &lt;- each ([[<span class="keyword">int</span> <span class="number">0</span>;<span class="number">1</span>;<span class="number">2</span>;<span class="number">3</span>;<span class="number">4</span>]])</span><br><span class="line">var answer = it |&gt; my_find_index_if &lt;| @(value: <span class="keyword">int</span>)</span><br><span class="line">  print(<span class="string">"check: &#123;value&#125;\n"</span>)</span><br><span class="line">  <span class="keyword">return</span> value &gt; <span class="number">1</span></span><br><span class="line">print(<span class="string">"&#123;answer&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">check: <span class="number">0</span></span><br><span class="line">check: <span class="number">1</span></span><br><span class="line">check: <span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>Здесь таится интересный момент, связанный с прерыванием итерации. Почему функция <code>map</code> не выполнила проверку 3 и 4 элемента массива? Каким именно образом функция <code>map</code> “узнала”, что нужно остановить итерацию?<br>Если вы попробуете реализовать функцию <code>find_index</code> с помощью <code>std::for_each</code> в C++, то стокнётесь в проблемой, что <code>return</code> не может остановить итерацию <code>for_each</code>.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_index</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; myvector, <span class="built_in">std</span>::function&lt;<span class="keyword">bool</span>(<span class="keyword">int</span>)&gt; checker)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> answer = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">bool</span> answerFound = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">auto</span> fn = <span class="built_in">std</span>::for_each(myvector.begin(), myvector.end(), [&amp;](<span class="keyword">int</span> i) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"check:"</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span> (!answerFound) &#123;</span><br><span class="line">            <span class="keyword">if</span>(checker(i)) &#123;</span><br><span class="line">                answer = i;</span><br><span class="line">                answerFound = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">//невозможно остановить выполнение for_each</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; find_index(myvector, [](<span class="keyword">int</span> i) &#123;</span><br><span class="line">      <span class="keyword">return</span> i &gt; <span class="number">1</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; find_index(myvector);</span><br><span class="line"><span class="comment">//Output</span></span><br><span class="line">check:<span class="number">0</span></span><br><span class="line">check:<span class="number">1</span></span><br><span class="line">check:<span class="number">2</span></span><br><span class="line">check:<span class="number">3</span></span><br><span class="line">check:<span class="number">4</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>Что именно мешает лямбда-функции, переданной в <code>for_each</code> прекратить итерацию? Ответ - колстек, а точнее стекфрейм функций. В момент вызова лямбда-функции внутри for_each он выглядит так:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main</span><br><span class="line">  find_index</span><br><span class="line">    for_each</span><br><span class="line">    стекфрейм for_each</span><br><span class="line">      for_each_lambda</span><br><span class="line">        checker_lambda</span><br></pre></td></tr></table></figure></p><p><code>for_each</code> как и любая функция, может выделить себе дополнительную память на стеке под свои нужны, и если <code>for_each_lambda</code> или <code>checker_lambda</code> захотят выйти на уровень выше <code>for_each</code>, им нужно уметь раскручивать стек (скорее всего, конкретно для for_each там ничего нет, но сама необходимость раскрутки всего, что находится между функциями разного уровня на стеке блокирует возможность выхода)</p><p>Конечно, раскручивать стек в C++ умеют исключения, но… просто посмотрите на этот код и никогда так не делайте:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_index</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; myvector, <span class="built_in">std</span>::function&lt;<span class="keyword">bool</span>(<span class="keyword">int</span>)&gt; checker)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">auto</span> fn = <span class="built_in">std</span>::for_each(myvector.begin(), myvector.end(), [&amp;](<span class="keyword">int</span> i) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"check:"</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">if</span>(checker(i)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> i; <span class="comment">//"выбрасываем" ответ из foreach</span></span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (<span class="keyword">int</span> throwedAnswer) &#123;</span><br><span class="line">        <span class="keyword">return</span> throwedAnswer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Возможность раскручивать стек называется <code>non-local returns</code> и присутствует в языках типа <code>Ruby</code> (пример в [1]) или <code>Kotlin</code> [24]:<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">val</span> value = <span class="number">3</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="string">""</span></span><br><span class="line">list.forEach &#123; </span><br><span class="line">  result += <span class="string">"<span class="variable">$it</span>"</span></span><br><span class="line">  <span class="keyword">if</span> (it == value)</span><br><span class="line">    <span class="keyword">return</span><span class="symbol">@forEach</span> <span class="comment">//выход из foreach</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//result="123"</span></span><br></pre></td></tr></table></figure></p><p>Другой более универсальный подход, реализованный в <code>daScript</code> и других языках с поддержкой генераторов — приостанавливать выполнение <code>map/for_each</code> и передавать промежуточные результаты “вовне”, с возможностью по желанию прекратить приостановленную итерацию на уровень выше (генераторы также известны как “елды” среди добравшихся до Unity артистов).</p><p>Совсем нехороший пример</p><p><strong><code>Проверка двух коллекций на равенство</code></strong></p><p>Без задействования генераторов, корутин, потоков или продолжений, или других способов приостановить функцию, не пишется. Мешают, как и в предыдущем примере, всё те же стекфреймы в колстеке. Но если в примере с ранним выходом из внутреннего итератора удавалось хотя бы выкрутиться хаком и “выпрыгнуть” с помощью исключений, необратимо раскрутив стек, то здесь для приостановки каждой из двух функций-колбеков нужно хранить оба состояния обеих функций.</p><h2 id="Генераторы"><a href="#Генераторы" class="headerlink" title="Генераторы"></a>Генераторы</h2><p>Генераторы — это возобновляемые функции. Возвращаемый тип генератора — итератор (гибрид между внутренним и внешним)</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">let gen &lt;- generator&lt;<span class="keyword">int</span>&gt;() &lt;| $()</span><br><span class="line">  <span class="function"><span class="keyword">for</span> t in <span class="title">range</span><span class="params">(<span class="number">0</span>,<span class="number">10</span>)</span></span></span><br><span class="line"><span class="function">    yield t</span></span><br><span class="line"><span class="function">  <span class="keyword">return</span> <span class="literal">false</span></span></span><br></pre></td></tr></table></figure><p><code>map</code>, как и большинство функций из модуля <code>functional</code> в <code>daScript</code>, возвращают генераторы, так что с помощью неё должно быть возможно (хотя и не нужно) реализовать проверку двух коллекций на равенство, недоступную для внутренних итераторов в языках без поддержки генераторов:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">is_equal</span><span class="params">(var it1, it2: iterator&lt;<span class="keyword">auto</span>(TT)&gt;)</span></span></span><br><span class="line"><span class="function">  unsafe</span></span><br><span class="line"><span class="function">    var equalResult </span>= <span class="literal">true</span></span><br><span class="line">    <span class="comment">//один из генераторов возвращает значения из коллекции</span></span><br><span class="line">    var aGenerator &lt;- it1 |&gt; <span class="built_in">map</span> &lt;| @(aValue:TT-&amp;)</span><br><span class="line">      <span class="keyword">return</span> aValue</span><br><span class="line">    //второй генератор берёт значение из второй коллекции и сравниваем со значением из другого генератора</span><br><span class="line">    //лямбда-функция захватывает первый генератор для получения значений из него</span><br><span class="line">    var bGenerator &lt;- it2 |&gt; <span class="built_in">map</span> &lt;| @ [[&amp;aGenerator]](bValue:TT-&amp;)</span><br><span class="line">      var aValue : TT-&amp;</span><br><span class="line">      <span class="keyword">if</span> !next(aGenerator, aValue)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      print("&#123;bValue&#125; &#123;aValue&#125;\n")</span><br><span class="line">      <span class="keyword">return</span> bValue == aValue</span><br><span class="line">    //продолжаем брать из генераторов значения, пока она эквивалентны</span><br><span class="line">    <span class="keyword">while</span> equalResult &amp;&amp; next(bGenerator, equalResult)</span><br><span class="line">      pass</span><br><span class="line">    //коллекции эквивалентны, если оба итератора обработали все значения</span><br><span class="line">    var aLast : <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">return</span> !next(aGenerator, aLast) &amp;&amp; empty(bGenerator)</span><br></pre></td></tr></table></figure><p><strong><code>Двунаправленные генераторы</code></strong></p><p><code>Python</code> поддерживает также <a href="https://docs.python.org/3/reference/expressions.html#generator.send" target="_blank" rel="noopener">отправку</a> данных генератору из вызывающего кода</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">double_inputs</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="meta">... </span>        x = <span class="keyword">yield</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">yield</span> x * <span class="number">2</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gen = double_inputs()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(gen)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gen.send(<span class="number">10</span>)</span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(gen)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gen.send(<span class="number">6</span>)</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure><h2 id="Разворачивание-итераторов"><a href="#Разворачивание-итераторов" class="headerlink" title="Разворачивание итераторов"></a>Разворачивание итераторов</h2><p>Теперь рассмотрим возможность “выворачивания” итераторов. К примеру, у нас есть “красивая” версия внутреннего итератора <code>each</code> для дерева, и функция сравнения, принимающая внешние итераторы, в которую хочется передать итератор обхода дерева.</p><p>Для начала посмотрим, как можно передать значения из лямбда функции “наружу”, с помощью захвата в замыкание (closure) лямбда-функции:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">to_array</span><span class="params">(var tree : Tree?)</span></span></span><br><span class="line"><span class="function">  unsafe</span></span><br><span class="line"><span class="function">    var arr: <span class="built_in">array</span>&lt;<span class="keyword">int</span>&gt;</span></span><br><span class="line"><span class="function">    <span class="comment">//захватываем arr в замыкание по ссылке</span></span></span><br><span class="line">    each(tree) &lt;| @[[&amp;arr]](value: int)</span><br><span class="line">      arr |&gt; push(value)</span><br><span class="line">    <span class="keyword">return</span> &lt;- arr</span><br></pre></td></tr></table></figure><p>Функция накапливает все значения в переменной <code>arr</code> и возвращает полностью собранный массив. Следующим шагом попробуем избавиться от этого накопления и вернуть управление вызывающему коду, как только будет получено следующее значение из <code>each</code>. Но тут возникает следующая проблема. Если <code>each</code> не задизайнена так, чтобы её можно было останавливать, то её и невозможно будет остановить из колбека. Т.е. нам нужна другая функция <code>each_async</code>, которая будет возвращать значение через генератор <code>yield</code>.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">each_async</span><span class="params">(tree:Tree?)</span> : iterator&lt;<span class="keyword">int</span>&gt;</span></span><br><span class="line">    return &lt;- generator&lt;int&gt;() &lt;| $ ()</span><br><span class="line">      <span class="keyword">if</span> tree.left != null</span><br><span class="line">        <span class="keyword">for</span> newVal in each_async(tree.left)</span><br><span class="line">          yield newVal</span><br><span class="line">      yield tree.data</span><br><span class="line">      <span class="keyword">if</span> tree.right != null</span><br><span class="line">        <span class="keyword">for</span> newVal in each_async(tree.right)</span><br><span class="line">          yield newVal</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">var eq = is_equal(each_async(tree1), each_async(tree2))</span><br></pre></td></tr></table></figure><p>Чуть менее компактно, чем первоначальная версия, за счёт того, что из вложенных генераторов приходится доставать данные с помощью дополнительных циклов обхода (<code>yield</code> должно возвращать <code>int</code>, а вложенный генератор возвращает <code>iterator&lt;int&gt;</code>, из которого нужно достать данные для выдачи внешнему генератору).</p><p><code>Python</code> и некоторые другие языки поддерживают <strong><code>делегацию генераторов</code></strong> — синтаксический сахар, который позволяет избежать написания таких циклов<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">concat</span><span class="params">(a, b)</span>:</span></span><br><span class="line">  <span class="comment">#for item in walkFirst(a): yield item</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">#"берём значение из генератора и передаём дальше</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="keyword">from</span> walkFirst(a)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">walkFirst</span><span class="params">(a)</span>:</span></span><br><span class="line">  <span class="keyword">for</span> item <span class="keyword">in</span> a: <span class="keyword">yield</span> item</span><br></pre></td></tr></table></figure></p><p><strong>update</strong><br>Аналогичный макрос <a href="https://github.com/GaijinEntertainment/daScript/commit/3acb98e7c13456f59c73f482ef4396481cf30293" target="_blank" rel="noopener">yield_from</a> для <code>daScript</code></p><p>Но тут есть важный момент, снова возвращающий нас к колстекам. Делегация генераторов — это просто синтаксический сахар, но мы не можем написать возврат значения из вложенных функций, не прокидывая эту делегацию через каждый уровень вложенности. Чтобы полноценно выйти на несколько уровней вверх, в затем вернуться, нам потребуется структура, которая реифицирует не один уровень стека, а весь стек. Следующий пример на <code>ruby</code> показывает такую структуру.</p><h2 id="Файберы"><a href="#Файберы" class="headerlink" title="Файберы"></a>Файберы</h2><p>В [2] есть пример разворачивания итераторов из <code>Ruby</code>:</p><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyEnumerator</span></span></span><br><span class="line">  <span class="keyword">include</span> Enumerable</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(obj)</span></span></span><br><span class="line">    @fiber = Fiber.new <span class="keyword">do</span>  <span class="comment"># Spin up a new fiber.</span></span><br><span class="line">      obj.each <span class="keyword">do</span> <span class="params">|value|</span>  <span class="comment"># Run the internal iterator on it.</span></span><br><span class="line">        Fiber.<span class="keyword">yield</span>(value) <span class="comment"># When it yields a value, suspend</span></span><br><span class="line">                          <span class="comment"># the fiber and emit the value.</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      raise StopIteration  <span class="comment"># Then signal that we're done.</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">next</span></span></span><br><span class="line">    @fiber.resume          <span class="comment"># When the next value is requested,</span></span><br><span class="line">                           <span class="comment"># resume the fiber.</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><code>Yield</code> происходит прямо из <code>each</code> во внешнюю функцию! Если обратиться к предыдущим замечаниям про колстеки, то здесь будет:</p><ul><li><code>each</code> для дерева создаёт стек, в котором хранит адреса возвратом рекурсивных вызовов</li><li>метод <code>next</code> полностью “замораживает” этот стек, и переключается на другой, в управляющем коде.</li></ul><p>Так что <code>Fiber</code> здесь — структура, которая реифицирует не только фрейм стека, как генераторы, но весь стек полностью.<br><code>Файберы</code> имеют свой стек и копии локальных переменных. Один выполняются в одном потоке, и передача управления между ними управляется кодом пользователя — пока один файбер не передаст управление следующему, переключения не будет.</p><p>Файберы — своеобразная “точка связи” итерации с параллелизмом.</p><h2 id="Функции-без-стекфрейма"><a href="#Функции-без-стекфрейма" class="headerlink" title="Функции без стекфрейма"></a>Функции без стекфрейма</h2><p>В [12] рассматриваются альтернативы хранению временных переменных функции в стеке. В качестве примера рассматривается создание языков для визуального программирования типа <code>Kismet</code>/<code>Blueprint</code> из Unreal. Каждая функция-строительный кирпич заранее выделяет необходимую ей память и просто использует её повторно, если вызывается вновь. Если нужно вызвать функцию дважды — выделяется два блока памяти. Преимущество такого подхода — можно легко связывать цепочки функций вида “пойти в точку А, подождать секунду, затем проиграть анимацию и звук одновременно”.</p><p>Чтобы создать код связи нод на C++, может потребоваться код вида:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> bMoved = <span class="literal">false</span>;</span><br><span class="line">CompareBoolNode * cmp = <span class="keyword">new</span> CompareBoolNode(bMoved);</span><br><span class="line">DelayNode * first_delay = <span class="keyword">new</span> DelayNode(some_hardcoded_number);</span><br><span class="line">DelayNode * second_delay = <span class="keyword">new</span> DelayNode(another_hardcoded_number);</span><br><span class="line">DelayNode * third_delay = <span class="keyword">new</span> DelayNode(a_third_hardcoded_number);</span><br><span class="line">MatineeNode * matinee = <span class="keyword">new</span> MatineeNode(Matinee_0, Interior_Elevator_3);</span><br><span class="line">BoolNode * set_moved = <span class="keyword">new</span> BoolNode(bMoved, <span class="literal">true</span>);</span><br><span class="line">BoolNode * clear_moved = <span class="keyword">new</span> BoolNode(bMoved, <span class="literal">false</span>);</span><br><span class="line">cmp-&gt;onFalse += &amp;first_delay-&gt;start</span><br><span class="line">first_delay-&gt;onFinished += &amp;matinee-&gt;play;</span><br><span class="line">matinee-&gt;onCompleted += &amp;second_delay-&gt;start;</span><br><span class="line">second_delay-&gt;onFinished += &amp;matinee-&gt;reverse;</span><br><span class="line">second_delay-&gt;onFinished += &amp;set_moved-&gt;in;</span><br><span class="line">set_moved-&gt;out += &amp;third_delay-&gt;start;</span><br><span class="line">third-&gt;delay-&gt;onFinished = &amp;clear_moved-&gt;in;</span><br><span class="line"> </span><br><span class="line">RTriggerVolume_0.onTouched += &amp;cmp-&gt;in;</span><br></pre></td></tr></table></figure></p><p> При этом, на самом деле программист хотел бы написать этот же код, в таком виде:</p> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> bMoved = <span class="literal">false</span>;</span><br><span class="line">RTriggerVolume_0.Touched = [bMoved]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (bMoved)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    Delay(some_hardcoded_delay);</span><br><span class="line">    Matinee_0.Play(Interior_Elevator_3);</span><br><span class="line">    Delay(another_hardcoded_delay);</span><br><span class="line">    bMoved = <span class="literal">true</span>;</span><br><span class="line">    Matinee_0.Reverse(Interior_Elevator_3);</span><br><span class="line">    Delay(a_third_hardcoded_delay);</span><br><span class="line">    bMoved = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> Проблема в том, что в C++ сложно нет функции <code>Delay</code>. Файберы могут помочь с её реализацией, но иметь отдельный стек для каждой мелкой сопрограммы может быть дорого. Вместо этого компиляторы визуальных языков могут подсчитать, сколько памяти потребуется для всего скрипта, и выделить ему это весь этот блок целиком. Таким образом, во время выполнения нет аллокаций. Это не особо влияет на скорость, но влияет на то, все функции такого языка могут быть в любой момент прерваны и возобновлены — функции без фреймов на стеке не страдают от того, что кто-то другой перехватывает управление.</p><h2 id="Корутины-в-C"><a href="#Корутины-в-C" class="headerlink" title="Корутины в C++"></a>Корутины в C++</h2><p><strong><code>Реализация замаскированным конечным автоматом</code></strong><br>В [13] приведён хак-пример с тем, чтобы реализовать корутины с ограничениями на макросах с помощью объединения цикла и <code>switch</code> (грязный трюк, названный метод Даффа).</p><p><strong><code>Реализации корутин в виде платформо-зависимых библиотек</code></strong><br>Серьёзные реализации, использующие трюки на ассемблере или ucontext — [18] и [19] от Malte Skarupke и [20] <code>Boost::Context</code> от Oliver Kowalke. От него же, <a href="https://www.boost.org/doc/libs/?view=category_concurrent" target="_blank" rel="noopener">реализации</a> <code>coroutine2</code>(с выделением стеков на хипе, и first-class продолжениями) и <code>fiber</code> (<a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4024.pdf" target="_blank" rel="noopener">отличия</a> между ними, файбер здесь — green thread, поток, управляемый диспетчером. Файберы “живут” в одном кернел-треде. Ключевое отличие - корутины передают управление друг другу, буст-файберы — планировщику).</p><p>Бекграунд для реализации буст библиотек — переключатели контекста (через примитив <code>call/cc</code> из <code>Boost::Context</code>).</p><ul><li>fcontext_t - переключение асм-кодом (самое быстрое)</li><li>ucontext_t и WinFiber - в <a href="https://www.boost.org/doc/libs/1_79_0/libs/fiber/doc/html/fiber/overview/implementations__fcontext_t__ucontext_t_and_winfiber.html" target="_blank" rel="noopener">10-100 раз</a> более медленное переключение с использованием функций ядра ОС</li></ul><blockquote><p>Хороший ответ на вопросы из собеседований вроде “зачем может потребоваться писать код на ассемблере в 20XX году?”</p></blockquote><p><strong><code>Корутины из стандарта C++20</code></strong></p><p>В стандарте C++ 20 года реализована минимальная поддержка корутин. Корутины из стандарта, в отличие от <code>boost:coroutine</code> не имеют своего стека (стандарт отделался тем, что заявил “если хотите возвращать управление из вложенных функций — вам нужны файберы, а не корутины”). Также не содержит в std готовых примитивов-паттернов для удобной работы, вариант их реализации можно посмотреть в библиотеке <code>cppcoro</code> [16].</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Visitor</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">f</span>(<span class="title">Visitor</span>&amp; <span class="title">v</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//stackfull-корутина с передачей управления, boost::context</span></span><br><span class="line">asymmetric_coroutine&lt;T&gt;::<span class="function">pull_type <span class="title">pull_from</span><span class="params">([](asymmetric_coroutine&lt;T&gt;::push_type&amp; yield) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    f(yield);</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//stackless-корутина, C++ 20</span></span><br><span class="line"><span class="function">generator&lt;T&gt; <span class="title">pull_from</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// yield может быть вызвана только отсюда</span></span><br><span class="line">    f(???);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Можно вернуться к примерам с разворачиванием итераторов на <code>daScript</code> и <code>ruby</code>, и попробовать “спроецировать” их на синтаксис stackful-корутин.</p><p>В <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3708.pdf" target="_blank" rel="noopener">пропозале</a> по добавлению <code>boost::coroutine</code> в стандарт <code>C++</code> приведён как раз аналогичный пример с деревом, с явным продолжением-аргументом он выглядит впечатляюще круто:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> ContPush = boost::coroutines::coroutine&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;::push_type;</span><br><span class="line"><span class="keyword">using</span> ContPull = boost::coroutines::coroutine&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;::pull_type;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(tree* n, ContPush&amp; out)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n-&gt;left) traverse(n-&gt;left, out);</span><br><span class="line">  out(n-&gt;value);</span><br><span class="line">  <span class="keyword">if</span>( n-&gt;right) traverse(n-&gt;right, out);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tree* tree1 = testCreateTree1(), tree2 = testCreateTree2();</span><br><span class="line"></span><br><span class="line"><span class="comment">//трансформация внутреннего итератора во внешний</span></span><br><span class="line"><span class="function">ContPull&amp; <span class="title">iterator1</span><span class="params">([&amp;](ContPush&amp; out) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  traverse(tree1, out);</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ContPull&amp; <span class="title">iterator2</span><span class="params">([&amp;](ContPush&amp; out) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  traverse(tree2, out);</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//у boost::coroutines::coroutine&lt;std::string&gt;::pull_type есть iterator</span></span><br><span class="line"><span class="keyword">bool</span> isEqual = <span class="built_in">std</span>::equal(<span class="built_in">std</span>::begin(iterator1), <span class="built_in">std</span>::end(iterator1), <span class="built_in">std</span>::begin(itertor2));</span><br></pre></td></tr></table></figure><p>Stackless-корутины не позволяют таких трюков, так как используют стек вызывающего их кода, но более эффективны.<br>Benchmark из либы <a href="https://github.com/jamboree/co2" target="_blank" rel="noopener">CO2</a>, эмулирующей stackless-корутины (цена вызова корутины):<br><img src="/blog/2550823652/co2_benchmark.png" alt="bench"></p><p>Кроме вызова важна также стоимость создания корутины. В случае с <code>CO2</code> корутина — это только синтаксический сахар, и код работает быстро (но в этой библиотеки и нельзя “захватить” переменные на стеке в корутину после восстановления). В корутинах из стандарта C++, генерируется код с аллокацией таких данных в куче, и затем компилятор <strong>может</strong> оптимизировать эти аллокации в случае, если код удастся трансформировать и инлайнить. Сделает он это или нет — неизвестно.</p><p>В [14] Malte Skarupke приводит примеры, когда это не работало даже в относительно простых случаях, когда должно быть возможно. Узнать, будет или нет выполнена оптимизация — сложно, а разница в скорости между двумя вариантами — на два порядка, так что часто создавать корутины, полагаясь на то, что будет быстро, без постоянных проверок сгенерированного кода невозможно. Как происходит трансформация кода в LLVM детально рассматривается в [17] (ещё один большой кусок информации, которую должен держать в голове хороший C++ программист). Вдобавок меня пугает то, что такая трансформация требует повторного прохода всех стадий оптимизации (если я правильно понял презентацию, 32:14), время сборки большой программы — больное место языка.</p><p>Кому хотелось конкурентности, много лет как запилили себе файберы (чаще всего пулом, чтобы без переаллокаций, и с явным или неявным разбросом по тредам):<br><a href="https://www.gdcvault.com/play/1022186/Parallelizing-the-Naughty-Dog-Engine" target="_blank" rel="noopener">Naughty Dog: Parallelizing the Naughty Dog Engine Using Fibers</a><br><a href="https://www.youtube.com/watch?v=v2Q_zHG3vqg" target="_blank" rel="noopener">Multithreading the Entire Destiny Engine</a></p><p>Где-то дочитав досюда можно почитать туториал [15] по корутинам в C++ 20 и посмотреть на libcoro [16].</p><h2 id="Различия-в-терминологии"><a href="#Различия-в-терминологии" class="headerlink" title="Различия в терминологии"></a>Различия в терминологии</h2><p>Стоит отметить различие в определении файберов в различных языках. В некоторых файберы отличаются от генераторов только тем, что имеют стек. Такую таксономию например предлагает стандарт <code>C++ 20</code>. В других языках файберы может отличать ещё и то, что они передают управление не другому файберу, а диспетчеру, который выбирает, кому передать управление дальше.</p><p>Например, <code>boost::coroutine</code> называет корутину со стеком не файбером а <code>stackful coroutine</code>, а <code>fiber</code> — это то же + управление через диспетчер. Я тут встану на сторону C++ 20, потому что для корутин со стеком (файберов), которые вдобавок ещё и управляемые диспетчером, и так придумана куча названий. Встречаются:</p><ul><li><a href="http://www.lua.org/pil/9.html" target="_blank" rel="noopener">просто корутины</a> (в <code>lua</code> для большей путаницы назвали это так)</li><li><a href="https://github.com/stackless-dev/stackless/wiki/" target="_blank" rel="noopener">тасклеты</a> (<code>Stackless Python</code>, вообще богат на термины)</li><li><a href="https://go.dev/doc/effective_go#goroutines" target="_blank" rel="noopener">горутины</a> из <code>golang</code> ([22], [23]), причисляемыми в статьях к файберам, отличаются по функционалу, и могут раскидываться по различным тредам планировщиком задач языка (а следовательно, требуют синхронизации доступа к общим ресурсам), так что должны рассматривать отдельно.</li><li>зелёные потоки, протопотоки, микропотоки</li></ul><p>На этом закончу первую половину статьи. Вторая будет про диспетчеры, способы блокирования и комбинирования различных корутин между собой.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;Малость ны
      
    
    </summary>
    
    
    
      <category term="dev" scheme="http://spiiin.github.io/tags/dev/"/>
    
      <category term="link" scheme="http://spiiin.github.io/tags/link/"/>
    
      <category term="dascript" scheme="http://spiiin.github.io/tags/dascript/"/>
    
      <category term="cpp" scheme="http://spiiin.github.io/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>daScript - скорость</title>
    <link href="http://spiiin.github.io/blog/1067581840/"/>
    <id>http://spiiin.github.io/blog/1067581840/</id>
    <published>2022-07-27T14:05:01.000Z</published>
    <updated>2022-08-01T16:59:05.358Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Рассказывал о <code>daScript</code> коллеге в отпуске, в ответ на то, почему он такой быстрый, задумался, что особо коротко и не ответишь, не влезая в детали реализации, проще замерить. Очень поверхностно:</p><h2 id="Заявленное-авторами"><a href="#Заявленное-авторами" class="headerlink" title="Заявленное авторами"></a>Заявленное авторами</h2><p>(<a href="https://dascript.org/doc/reference/introduction.html#performance" target="_blank" rel="noopener">Performance</a>, <a href="https://dascript.org/" target="_blank" rel="noopener">overview</a>, <a href="https://dascript.org/doc/reference/embedding/vm.html" target="_blank" rel="noopener">VM</a>):</p><ul><li>Быстрый интероп в C++ и обратно.</li><li>AoT, чтобы вообще убрать интероп, в случаях, когда можно транспилировать в C++ вместо интерпретации.</li><li>Кастомные аллокаторы для строк и хипа. Плюс политика для отдельных скриптов, в которых не нужно хранить выделенное — быстро перезапустить всю виртуальную машину, прибив всё аллоцированное без освобождения. Политика управления памятью или сохранения состояния может быть кастомизирована на стороне C++ — модель памяти daScript максимально простая и быстрая.</li><li>Использование hardware-friendly типов для нод, поддержка векторных типов в языке (в геймдеве повсюду встречаются vec4 и mat4 — многие алгоритмы просто векторизировать).</li></ul><h2 id="AoT"><a href="#AoT" class="headerlink" title="AoT"></a>AoT</h2><p>Код, скомпиленный из daScript в C++, может получиться быстрее среднего C++ кода, так же как компилятор может перевести C++ в более быстрый ассемблерный код, чем средний код, написанный на ассемблере. Причина в том, что при выборе вариантов реализации asm инструкций может быть много вариантов, из которых компилятор может выбрать более быстрый, чем рядовой программист. Т.е. если авторы языка хорошо представляют себе, во что скомпилиться сгенерированный C++ код, то теоретически, они могут сгенерировать код лучше, чем написанный средним программистом.</p><p>Кроме <code>daScript</code>, транспиляцию в C++ поддерживает <code>Nim</code>, который на тестах также выдаёт очень хорошие результаты. Скорее всего, генерировать LLVM код было бы эффективнее, что и планируют делать авторы языка в будущем, однако и генерация быстрого C++-кода делает эти языки очень быстрыми уже сейчас.</p><h2 id="Перестройка-кода"><a href="#Перестройка-кода" class="headerlink" title="Перестройка кода"></a>Перестройка кода</h2><p>Данные и код на daScript можно кастомизировать (<a href="/blog/1547564887/" title="макросы">макросы</a>, преобразовывающие AST, а также <a href="https://github.com/GaijinEntertainment/daScript/blob/250c5124dc1ce5e56933d42d15ef5e209d30dd20/include/daScript/ast/ast.h#L340" target="_blank" rel="noopener">перегрузка</a> simulate и visit, <a href="https://github.com/GaijinEntertainment/daScript/blob/985eaeda9ec6d4c594f9f9583ce3b14aed023d91/include/daScript/das_config.h#L74" target="_blank" rel="noopener">fusion engine</a> для паковки инструкций), это делать намного легче чем на C++. Пример из <a href="https://youtu.be/IvHGczF6Go0?t=2565" target="_blank" rel="noopener">доклада</a>, про разницу подходов при задаче раскладывания данных data-oriented для ECS фреймворка, на C++ и на daScript.</p><p>Наверное, чё-то ещё есть, лучше у авторов уточнить.</p><h2 id="Доверие-авторам"><a href="#Доверие-авторам" class="headerlink" title="Доверие авторам"></a>Доверие авторам</h2><p>Отдельный очевидный момент — быстрый код на языке следует из идеи языка. Если авторы всячески <a href="/blog/2630317622/" title="декларируют">декларируют</a> желание сделать быстрый язык и продолжать разгонять его — то они и будут делать именно это.</p><p>Почему я верю конкретно в этот язык — потому что давно видел изнутри движки <code>Gaijin</code>, их тулзы, и знаю качество их кода и используемые скриптовые языки. Ковырял все доступные материалы по скриптовым языкам <code>Naughty Dogs</code> (книга “Архитектура игровых движков”, доклады про использование Lisp-а как языка описания данных и скриптового языка в играх), некоторые идеи из которых, по интервью с автором, реализованны в <code>daScript</code>. Ну и сам Борис Баткин, небезызвестен в русском геймдев-комьюнити еще образца 2000х годов (<a href="https://web.archive.org/web/20071218053755/http://blog.gamedeff.com/?p=64" target="_blank" rel="noopener">интервью глазами пострадавшего</a>), да и просто <a href="https://www.mobygames.com/developer/sheet/view/developerId,53108/" target="_blank" rel="noopener">интересный человек</a>, скорее всего знает толк в быстром коде.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;Рассказыва
      
    
    </summary>
    
    
    
      <category term="dascript" scheme="http://spiiin.github.io/tags/dascript/"/>
    
  </entry>
  
  <entry>
    <title>Эволюция программиста в геймдеве</title>
    <link href="http://spiiin.github.io/blog/4256110900/"/>
    <id>http://spiiin.github.io/blog/4256110900/</id>
    <published>2022-07-27T09:50:03.000Z</published>
    <updated>2022-08-01T11:26:06.937Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Модели развития сотрудника в геймдеве.</p><h2 id="Т-модель-от-Valve"><a href="#Т-модель-от-Valve" class="headerlink" title="Т-модель от Valve"></a>Т-модель от Valve</h2><p><img src="/blog/4256110900/tmodel.png" alt="tmodel"><br>Из <a href="http://media.steampowered.com/apps/valve/hbook-RU.pdf" target="_blank" rel="noopener">руководства новых сотрудников Valve</a><br>Программист растёт не линейно, а в нескольких областях, и чтобы отразить это, в <code>Valve</code> придумали T-модель развития сотрудников:</p><p>На картинке Heavy - класс из Team Fortress 2. Он широко расставил руки, что показывает его атрибуты — Хэви понемногу разбирается в:</p><ul><li>Приготовлении бутербродов,</li><li>Убийстве людей</li><li>Русских народных танцах</li><li>Уберзарядах.<br>Он прокачивает широкий спектр навыков, чтобы уметь всего понемногу, но основная его компетенция - это Тяжёлое оружие (высокий скилл -&gt; рост персонажа)</li></ul><h2 id="Модель-костюмов-Марио-от-Betheda"><a href="#Модель-костюмов-Марио-от-Betheda" class="headerlink" title="Модель костюмов Марио от Betheda"></a>Модель костюмов Марио от Betheda</h2><p><img src="/blog/4256110900/mario_model.png" alt="mario_model"><br><a href="https://www.slideshare.net/JoelBurgess/3-10gdc2014-iterativeleveldesignprocess" target="_blank" rel="noopener">Отсюда</a><br><code>Betheda</code> практически не расширяет команды в ходе разработки проекта, поэтому  незанятые на текущем этапе отделы могут заняться чем-либо другим (переодеваются в другой костюм-профессию). В примере из доклада, на ранних стадиях левел-дизайнеры могут помогать в написании сюжета, геймдизайне механик (Layout, Gameplay, Markup, Scripting, Performance, Writing, Systems, Prototyping, Tools, more…), попутно прокачиваясь в том, что может быть полезно команде. Цель — создание небольших команд, состоящих из широкопрофильных специалистов.</p><h2 id="Модель-профессий-из-Final-Fantasy-Tactics"><a href="#Модель-профессий-из-Final-Fantasy-Tactics" class="headerlink" title="Модель профессий из Final Fantasy Tactics"></a>Модель профессий из Final Fantasy Tactics</h2><p>Если выбирать аналогии из игр, на мой взгляд профессии в геймдеве напоминают систему профессий из <code>Final Fintasy Tactics</code>.</p><p>Изначально специалисту доступны “примитивные” профессии, совершенствуясь в которых он осваивает некоторые навыки. После полноценного освоения нескольких навыков специалист может как оставаться в рамках этой же профессии и продолжать качаться в ней. Более продвинутые профессии имеют требования к наличию навыков в более низких.</p><p><img src="/blog/4256110900/viera_jobs.png" alt="viera_jobs"><br>(ветка профессий для одной из рас в FFTA)</p><p>Профессии 2го уровня требует всего нескольких очков навыков в простых профессиях (к примеру, чтобы стать <code>Sniper</code> достаточно набрать 2х очков в профессии <code>Archer</code>), но продвинутые профессии могут иметь намного более сложные требования (чтобы стать <code>Assasin</code>, нужно получить как минимум по 2 очка способностей из профессий <code>Archer</code>, <code>Elementalist</code> и 1 очку в <code>White Mage</code>, <code>Fencer</code> и <code>Sniper</code>).</p><p><img src="/blog/4256110900/fft_jobs.png" alt="fft_jobs"><br>(все профессии fft)</p><p>Возможна линейная прокачка профессий, без отхода от основной ветки (<code>Squire</code>-&gt;<code>Knight</code>-&gt;<code>Monk</code> в ветке воина). Например, рост программиста в направлении:<br><code>Джуниор программист</code>-&gt;<code>Мидл</code>-&gt;<code>Сениор</code>-&gt;<code>Суперсеньор 100500 ранга</code>.</p><p>Другой вариант — прокачка в целом дереве одной ветки, которая может дать более продвинутую профессию (<code>Knight+Monk+Lancer</code>-&gt;<code>Samurai</code>).<br>Пример:<br><code>Engine Programmer + Team Lead + Build pipeline tools programmer</code> -&gt; <code>CTO/VP of programming</code><br>Ну или, допустим<br><code>Джуниор + Математика + Понимание API и железок -&gt; Render программист</code></p><p>Это один за самых частых вариантов — в геймдеве встречаются очень разные задачи, от создания бекэнда и серверов для мультиплейерных игр до программирования графики, обычные гуи приложения (тулзы), скрипты автоматизации, оптимизации, архитектура движков. Так что несмотря на то, что есть специализации, за длительное время работы скорее всего окажется, что позанимаешься почти всем. Это и плюс - расширяет кругозор, и не возникнет ощущения, что постоянно занимаешься чем-то одним, и минус - нельзя просто выучить что-то одно и бездумно пользоваться этим много лет.</p><p>Возможны также “уходы от основной ветки” (был воином, ушёл в маги). Что-нибудь типа:<br><code>Джуниор программист -&gt; Графический программист -&gt; (бам) -&gt; техартист</code><br><code>Сениор -&gt; Тим Лид-&gt;(бам) -&gt; Проджект менеджер/Продюссер/Руководитель отдела</code><br><code>Технический геймдизайнер -&gt; (бам) -&gt; программист блюпринтов -&gt; (бам) -&gt; инди-одиночка, который и кодит, и дизайнит, и рисует</code><br>В таких случаях важно не забыть своевременно подкачать необходимые скиллы из ранних профессий другой ветки (программист, артист, геймдизайнер, менеджер команды)</p><p><img src="/blog/4256110900/dark_knight.png" alt="dark_knight"><br>Ну, или аналоги <code>Dark Knight</code>, которые кроме 1-2 сильных веток умеют делать по чуть-чуть практически что угодно (<code>Гейм-дизайнер/Артист/Программист + CEO</code>), и ухитряются понемногу заниматься обоими основными профессиями.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;Модели раз
      
    
    </summary>
    
    
    
      <category term="gamedev" scheme="http://spiiin.github.io/tags/gamedev/"/>
    
      <category term="dev_evolution" scheme="http://spiiin.github.io/tags/dev-evolution/"/>
    
  </entry>
  
  <entry>
    <title>Про увольнения</title>
    <link href="http://spiiin.github.io/blog/2316905704/"/>
    <id>http://spiiin.github.io/blog/2316905704/</id>
    <published>2022-07-09T09:54:41.000Z</published>
    <updated>2022-08-01T11:26:35.516Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Из-за чего увольняют с работы?</p><p>Три категории причин:</p><ul><li>Деньги</li><li>Софт скиллы</li><li>Хард скиллы</li></ul><h2 id="Деньги"><a href="#Деньги" class="headerlink" title="Деньги"></a>Деньги</h2><p>Когда у компаний много денег, она расширяется, набирают новых людей, стартуют новые проекты. В этот период и устроиться на работу легче (нужны работники, и побыстрее), получить повышение, закатываются праздники и корпоративы. Когда деньги кончаются, начинается обратный процесс — сокращения или закрытие проектов/подразделений/офисов, урезания бонусов и трат. Бывает, что меняются внешние условия — меньше продаж, конкуренты подоспели, правительство доигралось до санкций, ломающих бизнес, или весь рынок просел. Бывают внутренние — менеджмент или команда неадекватная, или инвесторы решили, что чё-то не то получается. Внутренние условия поменять сложно, внешние еще сложнее.</p><p>Если вовремя осознаёшь грядущие изменения сам — можно успеть уйти туда, где условия лучше, если такие места есть, если не осознаёшь — новости о сокращении становятся ВНЕЗАПНЫМИ. “Как же так — ведь мы суперкоманда, семья практически?”. В один момент работникам могут напомнить, что это вообще-то бизнес, и цель компании, деньги зарабатывать, а тебе именно за это и платили — делать что-то, что приносит в конечном итог принесёт денег больше, чем было потрачено (на твою зп в том числе). Если продукт еще не приносил денег — то твоя лояльность к нему и переработки ничего не принесли. Если уже сделал всё как надо, и работает само как часы — ты в принципе тоже может быть уже и не нужен, держать “суперзвезду на пенсии” может быть дорого. Получил деньги и ресурсы на свою игру мечты, реализовал, ушёл дальше в закат — вполне нормальный расклад для наёмного разработчика игр.</p><p>Топ-менеджмент часто также может быть наёмным, но может воспитываться и развиваться внутри компании. В этом случае рано или поздно необходимо стремиться к тому, чтобы тем или иным образом получать долю от дохода продукта компании. Где-то на этом уровне лояльность может конвертироваться в дивиденды, всё что ниже, просто социальная игра в то, что вы и компания любите друг друга и заботитесь (<em>пока всё хорошо</em>). В хорошем случае может получиться просто договориться о том уровне компенсации, который устраивает работника, в плохом “звиняйте, хлопцi, грошей нэма”.</p><h2 id="Софт-скиллы"><a href="#Софт-скиллы" class="headerlink" title="Софт-скиллы"></a>Софт-скиллы</h2><p>Если убрать кейсы, когда закрывается целое структурное подразделение, то происходит какая-либо оценка и отбор, кого уволить или оставить. Факторами могут быть софт и хард скиллы. Я попробую сконцентрироваться именно на отрицательных факторах, которые реже осознают, так как положительные чаще всего и так очевидны. Кроме очевидных кейсов, вроде “хамит, ругается со всеми, неадекватен к критике, уходит в запои”, бывает и менее явная отрицательная оценка людей (за что не уволят сразу, но могут принять во внимание при оценке). Из доклада Джесси Шелла <a href="https://youtu.be/-zRaFJHK0S4?t=3057" target="_blank" rel="noopener">Game Studio Management: Making It Great</a>, шесть типов мудаков. По его подходу, качество общения команды можно представить как граф распространения информации, и мудаки — люди которые так или иначе блокируют нормальное распространения информации или портят качество общения.</p><p><strong><code>- Недоступный мудак</code></strong><br>Невозможно получить от него никакой информации. Не оставляет нигде документации, не распространяет информации о принятым в узком кругу решениях. Пропадает в рабочее время, не отвечает ни по каким каналам связи. Запретно для оценки — пропажа по независящим от работника обстоятельствам, либо нежелание работать сверхурочно. Но в этом случае вполне можно оценивать то, что передаёт работник перед уходом — качество информации, которую он оставил, чтобы разобраться без него (кого предупредил, что пропадает, закончил ли задачи или рассказал о том, в каком состоянии эти задачи и план по тому, кто будет их доделывать).</p><p><strong><code>- Ненадёжный мудак</code></strong><br>Невозможно узнать, когда закончит задачу, не умеет и не стремится научиться планировать и оценивать сроки, в случае сдвига сроков не предупреждает вовремя. Не ищет причин несоответствия оценки и реального выполнения задачи. Не успевает выполнять задачи. Невозможно верить тому, насколько хорошо выполнена или проверена задача. Не оставляет информации о том, чтобы можно было отследить способ решения задачи до получения от него финального решения.</p><p><strong><code>- Упрямый мудак</code></strong><br>Невозможно переубедить его, что задачу нужно решать другим способом. “Нет, я буду делать это именно так”. Игнорирует информацию, которая ему не нравится. Отказывается от восприятия нестандартных для него идей, обсуждения способов его работы. Специально саботирует какие-либо методы работы. Неадекватно воспринимает критику, отказывается от переделок, готов тратить на споры слишком много времени. С приходом в новую команду может начать переделывать что-то по-своему без понимания причин решений, или требовать изменений. С технической стороны — неспособен увидеть плюсы различных подходов, кроме того, что использует сам. Тратит неадекватно много времени на отстаивание мнения даже в неважных вопросах. Неспособен видеть за технологиями идеи, которые можно воплотить с помощью технологий.</p><p><strong><code>- Токсичный мудак</code></strong><br><em>В оригинале “невежливый”. Токсичностью называют сейчас что угодно, что не нравится называющему. Я тут имею ввиду и перечисляю любые формы общения, которые со временем заражают коллектив, и через какое-то время все разговоры ведутся на ту тему, которой заразил всех мудак, а не о работе. Вторая форма заражения — часть людей перестаёт общаться с мудаком или в его присутствии между собой</em></p><p>Говорит только о деньгах, зарплате и должностях, публично сравнивает коллег по профессиональным качествам или уровню зарплаты.</p><p>Прикрывает сарказмом грубость, не может общаться без сарказма или подколов. Провести границу между общением в неформальном стиле с шутками, и некорректным, просто — если собеседник в ходе общения выводится на любую эмоциональную реакцию, то с вашем стилем общения точно что-то не то. Другой серьёзный маркер — кто-то начинает избегать общения с вами.</p><p><strong><code>- Склочный мудак</code></strong><br><em>Формы общения, которые каким-либо образом делят коллектив на группы, и настраивают их друг против друга (или против кого-нибудь одного), эксплуатируют закулисные приёмы и настроены на получение власти. Невозможно заставить общаться склочного мудака не “против кого-то”, или не демонстрировать паттерны поведения из книжек Маккиавели и Роберта Грина.</em></p><p>Пытается формировать “партии” людей, которые будут поддерживать его решения, независимо от их качества. Травит кого-то за спиной. Травит кого-то публично. Передаёт искаженную информацию о других в негативном свете. Самая жесть в плане разрушения коллектива, лицемерие — если при общении с кем-то понимаешь, что “всё сказанное и сделанное может и будет использовано против тебя” — это одновременно ещё и токсичная форма общения. Пытается диктовать мнения и позиции, в том числе по непрофессиональным вопросам, любит решать за всех (там где это не его профессиональная обязанность), чрезмерная общественная активность в ущерб профессиональной.</p><p><strong><code>- Мутный мудак</code></strong><br>Невозможно получить от него полезную информацию. Не знает, когда доделает что-то, не помнит, почему сделал что либо. После дискуссии с ним непонятна ни его позиция, ни понял ли он что-либо. Вместо ответа на вопрос выдаёт дикую ахинею, которую вообще сложно назвать информацией. “Я не сделал задачу XXX, потому что посоветовался с ZZZ (вообще без полномочий решать что-либо), и решил вместо этого сделать фичу YYY (с задачей не связанную) а задачу закрыл”. На объяснения хочется спросить “а нахрена вообще ты это сделал?”. Неорганизован, склонен максимально привлекать людей к ненужным обсуждениям и совещаниям, не отличает важных решений от неважных.</p><p>Регулярно попадает в истории в стиле “Мальчишник в Вегасе”, после которых ему нужны отгулы и больничные на то, чтобы экстренно восстановить паспорт, переделать диплом, забрать потерянные в другой стране вещи. Конечно же, обещает всё обязательно отработать, работая без выходных длительное время.</p><p>Добавлю ещё пару типажей от себя, связанных со скрытой враждой к любому начальству.</p><p><strong><code>- Мудак-саботёр</code></strong><br>Невозможно заставить выполнить работу, которая ему не нравится. Внешне может не показывать несогласия, но в совершенстве владеет методами увиливания от работы эпохи “развитого социализма” или итальянской забастовки, которые применяет как только ему что-то не нравится, или даже вместо дискуссии (ведь мудак не метит в начальники, зачем ему что-то предлагать, обсуждать или улучшать?).</p><p>Требует мельчайших разъяснений ему деталей при проектировании, максимально зафиксированных в документах, затягивая время. Может бездумно сделать что-либо по очевидно неправильному техзаданию (при том, только рад, если на это необходимо потратить много времени, даже если знает, что можно решить проще). Спихивает работу на других - “я сделал вам замечательную систему настроек вместо решения проблемы, всего за день, теперь вы с помощью моей замечательной системы наймите специального писателя настроек, который должен будет три недели решать в ней задачу, которую вы хотели на меня повесить, программисты таким не занимаются”. “Свою часть я сделал, как просили, дальше — не мои проблемы”. Меркантилен, эксплуатирует системы премий, бонусов и оплаты сверхурочных.</p><p><strong><code>- Мудак-наёмник</code></strong><br>Невозможно заставить выполнить работу без абсолютного контроля за выполнением. Если где-то на задание отведено 8 часов, а сделал за час, ни за что не признается в этом, потратит всё время в личных целях, хотя будет утверждать, что работал все 8. При самостоятельной оценке задач указывает заведомо большие сроки. Противится любым попыткам проконтролировать, чем именно он занимается в рабочее время. При отсутствии контроля сокращает своё рабочее время до минимума, не работает совсем, делает что-нибудь “для души”, или даже шабашит.</p><p>Отдельный случай, за который людей иногда увольняют без всякого мудачества — новички.</p><p><strong><code>- Новичок</code></strong><br>Если нужно сократить часть людей, то руководители часто приносят в жертву новичков. Новичок еще не успел ни с кем подружиться, чтобы его уход кого-то огорчил, в техническом плане он ещё не успел сделать что-то существенное, чтобы стать незаменимой частью команды. Различные системы оценки, используемые менеджерами, зачастую аккумулятивны, так что он просто не успел набрать столько условных очков, как его коллеги, у которых просто было больше времени для того, чтобы получать эти условные очки. По системам оценки, которые я встречал, работник остаётся новичком около года (если посмотреть на оценки примерно равных по профессиональным качествам людей, те, кто пришёл позже, всегда получаются ниже тех, кто работает дольше).</p><h2 id="Хард-скиллы"><a href="#Хард-скиллы" class="headerlink" title="Хард-скиллы"></a>Хард-скиллы</h2><p>Накосячить по хард-скиллам до увольнения сложно, но можно. Обычно всё-таки эти скиллы так или иначе проверяются на собеседованиях и испытательном сроке, так что представление об уровне работника у его менеджеров уже есть. Чаще встречается недовольство со стороны работника — уверенность в том, что его скиллы недооценены, или что для него нет подходящих задач. Серьёзные проблемы, которые могут быть отмечены как минусы, или привести к увольнениям:</p><p><strong><code>- Нерасширяемые решения</code></strong><br>Задача решена так, что любая просьба внести даже небольшие изменения потребует выбрасывания кода и написания нормального решения заново. Один из реальных экстремальных примеров — окно с тремя виджетами, в которое невозможно было добавить четвертый.</p><p><strong><code>- Неспособность дорешать задачу</code></strong><br>Реализация решения постоянно порождает баги. Изначальный код быстро покрывается заплатками настолько, что каждая следующая заплатка ломает что-нибудь исправленное ранее. Решение никогда “не сходится” к надежному, а в лучшем случае находится в неустойчивом равновесии</p><p><strong><code>- Невыполненные задачи</code></strong><br>Отдельная категория — человек читает условие задачи и пропадает. От него не поступает никаких вопросов, уточнений, предложений, вариантов кода. На уточняющие вопросы может ответить только, что все в процессе или даже почти готово. После дедлайна оказывается, что нет ВООБЩЕ никакого результата (возможно, из-за настигшей работника внезапной катастрофы). Кажется странным или редким, но периодически происходит вновь с другими людьми, как будто их похищают инопланетяне.</p><p><strong><code>- Решение меняет поведение половины кодовой базы</code></strong><br>Кроме непосредственного выполнения задачи, решение ломает или меняет поведение большой части кода. “Я тут делал мелкую фичу, и попутно переписал вашу функцию открытия файлов, у меня на машине она почему-то как-то непонятно работала”. “Чтобы мой код заработал, пришлось серьёзно изменить логику движка в 3х местах” (при этом код изначально кривой, при написании нормального изменения бы не потребовались).</p><p><strong><code>- Работа в полсилы</code></strong><br>Точнее, работу вполсилы бывает всё еще сложно заметить, но чаще всего дальше производительность падает до 20-30% (относительно результатов других членов команды или собственных в прошлом). Поскольку в этом случае есть некоторый “уровень нормы”, можно предпринять попытки к его возврату каким-либо способом (от отправки в отпуск, до смены способа контроля за дисциплиной или просто выяснения, что же такого произошло).</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;Из-за чего
      
    
    </summary>
    
    
    
      <category term="gamedev" scheme="http://spiiin.github.io/tags/gamedev/"/>
    
      <category term="dev_evolution" scheme="http://spiiin.github.io/tags/dev-evolution/"/>
    
  </entry>
  
  <entry>
    <title>daScript macro - 2</title>
    <link href="http://spiiin.github.io/blog/4046309382/"/>
    <id>http://spiiin.github.io/blog/4046309382/</id>
    <published>2022-07-02T14:11:26.000Z</published>
    <updated>2022-07-28T16:49:57.710Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Еще немного про способы кодогенерации в макросах.</p><p>В <a href="/blog/1547564887/" title="предыдущей заметке про макросы">предыдущей заметке про макросы</a> описывались способы сгенерировать код выражений на языке.</p><p>Можно строить выражения с помощью ручной генерации абстрактного синтаксического дерева. Например, код для генерации выражения <code>let a = 40 + 2</code>:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">var expr40 &lt;- <span class="keyword">new</span> [[ExprConstInt() value=<span class="number">40</span>]]                               <span class="comment">//40</span></span><br><span class="line">var expr2 &lt;- <span class="keyword">new</span> [[ExprConstInt() value=<span class="number">2</span>]]                                <span class="comment">//2</span></span><br><span class="line">var exprPlus &lt;- <span class="keyword">new</span> [[ExprOp2() op:=<span class="string">"+"</span>, left := expr40, right := expr2]]  <span class="comment">//40+2</span></span><br><span class="line"></span><br><span class="line">var exprLet &lt;- <span class="keyword">new</span> [[ExprLet()]]                                           <span class="comment">//let</span></span><br><span class="line">exprLet_aSize.variables |&gt; emplace_new() &lt;| <span class="keyword">new</span> [[Variable()    </span><br><span class="line">    name := <span class="string">"a"</span>,                                                            <span class="comment">//a</span></span><br><span class="line">    _type &lt;- <span class="keyword">new</span> [[TypeDecl() baseType=Type tInt]],</span><br><span class="line">    init &lt;- exprPlus                                                        <span class="comment">//=40+2</span></span><br><span class="line">]]</span><br></pre></td></tr></table></figure></p><p>Генерировать большие функции с использованием ExprXXX-кирпичиков утомительно, поэтому можно использовать макрос <code>quote</code>, который трансформирует переданное в него выражение в синтаксическое дерево этого выражения:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var exprLet &lt;- quote &lt;|</span><br><span class="line">    let a = <span class="number">40</span> + <span class="number">2</span></span><br><span class="line">print(describe(exprLet))</span><br><span class="line"><span class="comment">//output:</span></span><br><span class="line">let  <span class="comment">/*unused*/</span> a:<span class="keyword">auto</span> <span class="keyword">const</span> = (<span class="number">40</span> + <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>В случае, если какую-либо часть выражения нужно сделать изменяемой, можно воспользовать макросом <code>apply_template</code>:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">require daslib/templates</span><br><span class="line">require daslib/templates_boost</span><br><span class="line"></span><br><span class="line">var exprLet &lt;- quote &lt;|</span><br><span class="line">    let VARIABLE_NAME = OP1 + OP2                                         <span class="comment">//шаблон выражения</span></span><br><span class="line">var exprLet_rules : Template                                              <span class="comment">//правила переписывания выражения</span></span><br><span class="line">exprLet_rules |&gt; renameVariable(<span class="string">"VARIABLE_NAME"</span>, <span class="string">"a"</span>)                     <span class="comment">//замена одного имени на другое</span></span><br><span class="line">exprLet_rules |&gt; replaceVariable(<span class="string">"OP1"</span>, <span class="keyword">new</span> [[ExprConstInt() value=<span class="number">40</span>]])  <span class="comment">//замена одного выражения на другое</span></span><br><span class="line">exprLet_rules |&gt; replaceVariable(<span class="string">"OP2"</span>, <span class="keyword">new</span> [[ExprConstInt() value=<span class="number">2</span>]]) </span><br><span class="line">apply_template(exprLet_rules, exprLet.at, exprLet)</span><br></pre></td></tr></table></figure><p>Недавно в язык была добавлена фича по упрощению генерации правил переписываний выражений — <a href="https://dascript.org/doc/reference/language/reification.html?highlight=reification" target="_blank" rel="noopener">expression reification</a> (<a href="https://haxe.org/manual/macro-reification-expression.html" target="_blank" rel="noopener">аналогичная фича из haxe</a>).<br>Её можно описать как DSL для задания правил переписывания выражений в шаблонах. Теперь генерацию того же самого выражения можно описать так:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">let variableName = <span class="string">"a"</span></span><br><span class="line">let op1 = <span class="number">40</span></span><br><span class="line">let op2 = <span class="number">2</span></span><br><span class="line">var exprLet &lt;-qmacro &lt;|</span><br><span class="line">    let $i(variableName) = $v(op1) + $v(op2)</span><br></pre></td></tr></table></figure><br>В таком виде строчка шаблона всё ещё остаётся похожим на сам код, который будет сгенерирован этим шаблоном, а не на синтаксическое дерево или таблицу с описанием правил. Пример на все поддерживаемые правила реификации выражений - <a href="https://github.com/GaijinEntertainment/daScript/blob/fe8868308a44d7ad57d823205dc183993f428d40/examples/test/misc/reification.das" target="_blank" rel="noopener">reification.das</a>.</p><p>Переписанная кодо-генерированная функция инициализации структуры с использованием реификации получается где-то вдвое короче и проще:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">generateStructureInitFunction</span><span class="params">(var st:StructurePtr; ptrsTypeIndexes:<span class="built_in">array</span>&lt;<span class="keyword">int</span>&gt;&amp;)</span></span></span><br><span class="line"><span class="function">    let ptrFieldsLen </span>= ptrsTypeIndexes |&gt; length</span><br><span class="line">    var blk : <span class="built_in">array</span>&lt;ExpressionPtr&gt;; defer_delete(blk)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-------------------------</span></span><br><span class="line">    <span class="comment">//memblock.a`count = aCount</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">for</span> i in <span class="title">range</span><span class="params">(<span class="number">0</span>, ptrFieldsLen)</span></span></span><br><span class="line"><span class="function">        let argumentName </span>= <span class="string">"&#123;st.fields[ptrsTypeIndexes[i]].name&#125;`count"</span></span><br><span class="line">        blk |&gt; emplace_new &lt;| qmacro_expr(</span><br><span class="line">            $&#123;memblock.$f(argumentName) = $i(argumentName);&#125;</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-------------------------</span></span><br><span class="line">    <span class="comment">//let aSize = typeinfo(sizeof *memblock.a) * aCount</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">for</span> i in <span class="title">range</span><span class="params">(<span class="number">0</span>, ptrFieldsLen)</span></span></span><br><span class="line"><span class="function">        let argumentName </span>= <span class="string">"&#123;st.fields[ptrsTypeIndexes[i]].name&#125;"</span></span><br><span class="line">        let argumentNameSize = <span class="string">"&#123;argumentName&#125;Size"</span></span><br><span class="line">        let argumentNameCount = <span class="string">"&#123;argumentName&#125;`count"</span></span><br><span class="line">        blk |&gt; emplace_new &lt;| qmacro_expr(</span><br><span class="line">            $&#123;let $i(argumentNameSize) = typeinfo(<span class="keyword">sizeof</span> *memblock.$f(argumentName)) * $i(argumentNameCount);&#125;</span><br><span class="line">        )</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//-------------------------</span></span><br><span class="line">    <span class="comment">//memblock.mem |&gt; resize(aSize + bSize + cSize)</span></span><br><span class="line"></span><br><span class="line">    var sumArgumentsArray: <span class="built_in">array</span>&lt;ExpressionPtr&gt;</span><br><span class="line">    let zero = <span class="number">0</span>;</span><br><span class="line">    sumArgumentsArray |&gt; emplace&lt;| qmacro_expr($&#123;$v(zero);&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">for</span> i in <span class="title">range</span><span class="params">(<span class="number">0</span>, ptrFieldsLen)</span> </span></span><br><span class="line"><span class="function">        let argumentName </span>= <span class="string">"&#123;st.fields[ptrsTypeIndexes[i]].name&#125;"</span></span><br><span class="line">        let nameSize := <span class="string">"&#123;argumentName&#125;Size"</span></span><br><span class="line">        sumArgumentsArray |&gt; emplace &lt;| qmacro_expr($&#123;$i(nameSize);&#125;)</span><br><span class="line">    unsafe</span><br><span class="line">        var sumExpr &lt;- reduce(each(sumArgumentsArray), @@makeSumExpr)</span><br><span class="line">        blk |&gt; emplace_new &lt;| qmacro_expr(</span><br><span class="line">            $&#123;memblock.mem |&gt; resize($e(sumExpr));&#125;</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-------------------------</span></span><br><span class="line">    <span class="comment">//memblock.a = reinterpret&lt;int?&gt; addr(memblock.mem[0])</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i in range(<span class="number">0</span>, ptrFieldsLen)</span><br><span class="line">        let argumentName = <span class="string">"&#123;st.fields[ptrsTypeIndexes[i]].name&#125;"</span></span><br><span class="line">        unsafe</span><br><span class="line">            var exprStartAddress &lt;- reduce_while(each(sumArgumentsArray), @@makeSumExpr,  @(e:ExpressionPtr; counter:<span class="keyword">int</span>):<span class="keyword">bool</span> =&gt; counter &lt;= i)</span><br><span class="line">            var subtype := st.fields[ptrsTypeIndexes[i]]._type</span><br><span class="line">            var exprAssign &lt;- qmacro_expr &lt;|</span><br><span class="line">                unsafe&#123; memblock.$f(argumentName) = reinterpret&lt;$t(subtype)&gt; addr(memblock.mem[$e(exprStartAddress)]); &#125;</span><br><span class="line">            blk |&gt; emplace_new(exprAssign)</span><br><span class="line">    <span class="comment">//-------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//function signature</span></span><br><span class="line">    var fnArguments : <span class="built_in">array</span>&lt;VariablePtr&gt;;</span><br><span class="line">    unsafe</span><br><span class="line">        fnArguments |&gt; emplace_new &lt;| <span class="keyword">new</span> [[Variable() at=st.at, name:= <span class="string">"memblock"</span>, _type &lt;- <span class="keyword">new</span> [[TypeDecl() baseType=Type tStructure, structType=addr(*st)]]]]</span><br><span class="line">    var structT &lt;- typeinfo(ast_typedecl type&lt;<span class="keyword">int</span>&gt;)</span><br><span class="line">    <span class="keyword">for</span> i in range(<span class="number">0</span>, ptrFieldsLen)</span><br><span class="line">        let argumentName = <span class="string">"&#123;st.fields[ptrsTypeIndexes[i]].name&#125;`count"</span></span><br><span class="line">        fnArguments |&gt; emplace_new &lt;| <span class="keyword">new</span> [[Variable() at=st.at, name:= argumentName,  _type := intAstType]]</span><br><span class="line">    var fn &lt;- qmacro_function(<span class="string">"init`struct`&#123;st.name&#125;"</span>) &lt;| $ ($a(fnArguments))</span><br><span class="line">        $b(blk)</span><br><span class="line">    defer_delete(fn)</span><br><span class="line">    compiling_module() |&gt; add_function(fn)</span><br></pre></td></tr></table></figure><p>Макрос <code>qmacro_expr</code> позволяет вставить сгенерированное выражение в текущий блок, а не генерировать новый блок.<br><code>reduce</code> - функция из стандартной библиотеки <a href="https://github.com/GaijinEntertainment/daScript/blob/fdc48d4d4cfc46f08f0ca2fd8938a05896b973a6/daslib/functional.das" target="_blank" rel="noopener">functional</a>, позволяющая произвольным образом свернуть массив выражений с помощью функтора.<br><code>reduce_while</code> — её дописанная версия, позволяющая задать предикат остановки свёртки выражения по условию.<br><code>qmacro_function</code> — макрос для генерации сигнатуры функции и её определения</p><p>Получившаяся функция инициализации аналогична той, которая генерировалась в предыдущей заметке:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vec2</span></span></span><br><span class="line"><span class="class">    <span class="title">x</span>, <span class="title">y</span> :</span> <span class="keyword">float</span></span><br><span class="line"></span><br><span class="line">[memblock, dump_fields]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Memblock</span></span></span><br><span class="line"><span class="class">    <span class="title">a</span>:</span> <span class="keyword">int</span>?</span><br><span class="line">    b: <span class="keyword">float</span>?</span><br><span class="line">    c: <span class="keyword">int</span>?</span><br><span class="line">    d: Vec2?</span><br><span class="line"></span><br><span class="line"><span class="comment">//output:</span></span><br><span class="line">---gen_text--------------</span><br><span class="line"><span class="comment">// [modifyArgument]</span></span><br><span class="line">[privateFunction]def init`<span class="class"><span class="keyword">struct</span>`<span class="title">Memblock</span> ( <span class="title">var</span> <span class="title">memblock</span> :</span> Memblock; var a`count : <span class="keyword">int</span>; var b`count : <span class="keyword">int</span>; var c`count : <span class="keyword">int</span>; var d`count : <span class="keyword">int</span> )</span><br><span class="line">        memblock.a`count = a`count</span><br><span class="line">        memblock.b`count = b`count</span><br><span class="line">        memblock.c`count = c`count</span><br><span class="line">        memblock.d`count = d`count</span><br><span class="line">        var aSize : <span class="keyword">int</span> <span class="keyword">const</span> = (a`count * <span class="number">4</span>)</span><br><span class="line">        var bSize : <span class="keyword">int</span> <span class="keyword">const</span> = (b`count * <span class="number">4</span>)</span><br><span class="line">        var cSize : <span class="keyword">int</span> <span class="keyword">const</span> = (c`count * <span class="number">4</span>)</span><br><span class="line">        var dSize : <span class="keyword">int</span> <span class="keyword">const</span> = (d`count * <span class="number">8</span>)</span><br><span class="line">        __::builtin`resize(memblock.mem,((((aSize + <span class="number">0</span>) + bSize) + cSize) + dSize))</span><br><span class="line">        memblock.a = reinterpret&lt;<span class="keyword">int</span>?&gt; addr(memblock.mem[<span class="number">0</span>])</span><br><span class="line">        memblock.b = reinterpret&lt;<span class="keyword">float</span>?&gt; addr(memblock.mem[(aSize + <span class="number">0</span>)])</span><br><span class="line">        memblock.c = reinterpret&lt;<span class="keyword">int</span>?&gt; addr(memblock.mem[((aSize + <span class="number">0</span>) + bSize)])</span><br><span class="line">        memblock.d = reinterpret&lt;Vec2?&gt; addr(memblock.mem[(((aSize + <span class="number">0</span>) + bSize) + cSize)])</span><br></pre></td></tr></table></figure></p><p><a href="https://github.com/spiiin/dascript_macro_tutorial/tree/master/memblock_2" target="_blank" rel="noopener">Код примера</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;Еще немног
      
    
    </summary>
    
    
    
      <category term="dascript" scheme="http://spiiin.github.io/tags/dascript/"/>
    
  </entry>
  
  <entry>
    <title>daScript - как учить</title>
    <link href="http://spiiin.github.io/blog/2301621444/"/>
    <id>http://spiiin.github.io/blog/2301621444/</id>
    <published>2022-06-26T19:25:24.000Z</published>
    <updated>2022-06-26T20:50:29.658Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>На что в первую очередь посмотреть при изучении нового языка программирования, на примере daScript, но можно и применительно к другим языкам. Сырой список.</p><p><code>Обзор языка, мотивация</code></p><ul><li>Кто и зачем делает ещё один язык программирования, какие проблемы он решает</li><li>Какие возможности даёт язык, позволяет ли сочетание этих возможностей потеницально решить какие-либо ещё мои проблемы, кроме декларируемых авторами</li><li>Официальная документация, обзорные статьи, поиск существующих комьюнити</li><li>Лицензия, support</li><li>Планы, роадмап, периодичность обновлений, стабильность ядра языка</li><li>Поддерживаемые платформы и архитектуры, использование бекэндов/фронтэндов (llvm)</li></ul><p><code>Чтение кода</code></p><ul><li>Примеры от авторов, код тестов</li><li>Чтение кода стандартной библиотеки</li><li>Сторонние библиотеки</li></ul><p><code>Практика 1. Простые примеры</code></p><ul><li>Как хранятся в памяти типы<br>— работа со значениями/указателями/ссылками<br>— когда неожиданное дополнительное копирование, когда можно избежать, есть ли быстрые способы настройки/проверки<br>— особенности преобразования и приведения типов, что можно настроить для своих типов<br>— базовые типы<br>— особенности типизации<br>— настройки мутабельности/чистоты<br>— Глобальные/статические переменные</li><li>Конструкции управления</li><li>Часто используемые фичи языка (ленивость, аннотации, генераторы etc)</li><li>Строки<br>— какие есть типы для представления строк<br>— представление в памяти различных типов<br>— кодировки</li><li>Композия типов<br>— Классы, типы наследования, способы композиции данных<br>— модули</li><li>Стандартные контейнеры/коллекции/последовательности</li></ul><p><code>Практика 2</code></p><ul><li>Стандартная библиотека<br>— работы с вводом/выводом, файлами и путями, сетью<br>— асинхронность - потоки, файберы, примитива синхронизации, корутины, асинхронное выполнение кода. Jobque<br>— идиомы языка</li><li>приёмы обработки ошибок</li><li>generic-программирование</li><li>макросы, работа с AST языка</li><li>compile-time вычисления</li><li>способы генерации кода</li><li>rtti, рефлексия — возможности настройки</li></ul><p><code>DSL языка</code></p><ul><li>форматирование и способы вывода различных типов данных</li><li>json_boost, regexp_boost, decs_boost, opengl_boost</li><li>способы создания своих dsl</li></ul><p><code>Работа с памятью</code></p><ul><li>Способы аллокации и освобождения памяти</li><li>Принятые паттерны работы с выделением и освобождением памяти, время жизни объектов<br>— gc<br>— raii<br>— опции и настройки компилятора<br>— способа кастомизации объектов в памяти — кастомная аллокация, выравнивание, способы переопределить расположение данных в памяти<br>— способы реификации стандартных систем языка в памяти (для изучения стоимости этих фич) — способы наследования, корутины, генераторы, continuations, функторы, замыкания, внутренности контейнеров</li></ul><p><code>Работа с мультимедиа</code></p><ul><li>рендер, графика, анимация, звук, гуи, работа со стандартными форматами файлов, 3d-математика</li><li>шейдеры, системы материалов, способы реализации эффектов</li></ul><p><code>Отладка</code></p><ul><li>Особенности обнаружения и сигналов о различных типах ошибок компилятором</li><li>Отладочные контексты</li><li>Профайлер</li><li>Отладчик</li><li>Настройки компилятора для режимов отладки</li><li>Способы работы с тестами</li><li>Возможность настроить язык (уровень проверки ошибок, всякие прагмы -Wall, -pedantic) и расширять язык, диалекты</li></ul><p> <code>Среда разработки</code></p><ul><li>Поддержка интеграции в IDE (подсветка, автодополнение, подсказки, переходы по коду, апи связи с существующими тулзами, language server plugin etc)</li><li>Проверка наличия и качеств собственной среды разработки. Dasbox</li><li>Сочетаемость с инструментами (санитайзеры, профайлеры etc)</li><li>Особенности системы сборки</li><li>Способы сборки (интерпретация, компиляция, транспиляция, настройки vm, jit/aot)</li><li>Линтеры</li><li>Работа с документацией</li></ul><p><code>Встраивание, кросс-языковое взаимодействие</code></p><ul><li>FFI, вызовы кода на других языках</li><li>Модули расширения языка</li><li>Написание и генерация обёрток для своих и чужих классов и готовых библиотек</li><li>Передача управления между кодом на разных языках</li><li>Настройки встраивания языка в программу</li><li>Возможные архитектуры программы на C++ + daScript (настройка AoT, хот релоадинг, расширение классов C++ на daScript)</li><li>Способы работы со скриптовыми контекстами из C++</li><li>Способы межпроцессного/междуконтекстного взаимодействия</li></ul><p><code>Поддержка паттернов и парадигм программирования</code></p><ul><li>ECS</li><li>Функциональное программирование</li><li>Особенности ООП</li></ul><p><code>Оптимизация</code></p><ul><li>Настройки компилятора</li><li>Возможности по улучшению производительности существующего кода</li><li>Best practicies от авторов языка и библиотек</li><li>Возможности векторизации</li><li>Доступ к особенностям железа (интринсики, инлайн кода на ассемблере)</li><li>Бенчмарки с различными языками</li></ul><p><code>Особенности сборки под различные платформы</code></p><ul><li>win/mac/linux</li><li>мобильные платформы</li><li>консоли</li></ul><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;На что в п
      
    
    </summary>
    
    
    
      <category term="dascript" scheme="http://spiiin.github.io/tags/dascript/"/>
    
  </entry>
  
  <entry>
    <title>daScript in imaginery world</title>
    <link href="http://spiiin.github.io/blog/1160489034/"/>
    <id>http://spiiin.github.io/blog/1160489034/</id>
    <published>2022-06-19T07:48:24.000Z</published>
    <updated>2022-08-01T13:02:48.206Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Мой собственный способ измерить выразительность и скорость языка — решить на нём “задачу Джеймса Бонда младшего”, выдуманную головоломку из игры на NES <code>James Bond Jr</code> (<a href="https://youtu.be/Kzu_cGHFqM8?t=1290" target="_blank" rel="noopener">видео</a>). Несмотря на игрушечность задачи, кажется, это неплохой тест нового языка. Это веселее, чем реализовывать абстрактный поиск в ширину/глубину. Задачу решаю с небольшими алгоритмическими оптимизациями, но без оптимизаций по мелочам (скорее, наоборот, массив чисел специально копируется, как решена первая версия задачи на питоне, чтобы решения были сравнивыми, чтобы симулировать “код новичка” на языка и посмотреть, как язык справляется с этим копированием).</p><p>Сразу выводы про <code>daScript</code> для тех, кому не особенно интересны подробности реализации:</p><p>— Выразительность языка ОЧЕНЬ похожа на <code>Python</code>. Более того, я фактически просто переписал своё решение на <code>Python</code> 13-летней давности построчно, с парой изменений.<br>— <code>daScript</code> по скорости <strong>в режиме интерпретации</strong> находится в одной лиге с компилируемыми языками (!!!). Код по скорости сопоставим с версией на <code>Nim</code> (чуть быстрее “наивной” <strong>скомпилированной</strong> версии, и раза в 1.5-2 медленнее оптимизированной).<br>— В режиме <code>Ahead-of-Time</code> компиляции <code>daScript</code> обгоняет <code>nim</code> (который вообще показывает достаточно хорошие результаты в нормальных бенчмарках с другими языками).</p><a id="more"></a><p>Заметки<br>1 - <a href="/blog/28461/" title="(2009) Python in imaginary world">(2009) Python in imaginary world</a><br>2 - <a href="/blog/3351183716/" title="(2015) Scala in imaginary world">(2015) Scala in imaginary world</a><br>3 - <a href="/blog/1808122922/" title="(2021) Nim in imaginary world">(2021) Nim in imaginary world</a><br>Исходники<br><a href="https://github.com/spiiin/james_bond_jr_problem" target="_blank" rel="noopener">https://github.com/spiiin/james_bond_jr_problem</a></p><h2 id="Подготовка"><a href="#Подготовка" class="headerlink" title="Подготовка"></a>Подготовка</h2><p>Сборка автономного интерпретатора - проект <code>daScript</code> (можно в cmake поотключать дополнительные библиотеки типа <code>glfw</code>, ненужные для интерпретатора)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">option(DAS_XXX_MODULE_DISABLED &quot;Disable any unneeded modules&quot; OFF)</span><br></pre></td></tr></table></figure><br>Также не забывать собрать Release-версию. Теперь можно запускать скрипты из командной строки:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">daScript.exe james_bond_jr.das</span><br></pre></td></tr></table></figure></p><h2 id="Решение"><a href="#Решение" class="headerlink" title="Решение"></a>Решение</h2><div class='spoiler collapsed'>    <div class='spoiler-title'>        gist    </div>    <div class='spoiler-content'>        <script src="//gist.github.com/3bd63cd5271b277f5bc87f670b0ab967.js?file=james_bond_jr_dascript.das"></script>    </div></div><p>Отличия в синтаксис от <code>Python</code>:</p><p><strong><code>- Отсутствует присваивание кортежей</code></strong><br>Из-за чего нельзя написать сдвиг в массиве как в <code>python</code>:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n[0+plus],n[1+plus],n[2+plus],n[3+plus] &#x3D; n[3+plus],n[0+plus],n[1+plus],n[2+plus]</span><br></pre></td></tr></table></figure><br>и приходится писать отдельную функцию сдвига</p><p><strong><code>- Нельзя сравнить два массива с помощью оператора проверки равенства</code></strong><br>Что логично из-за неопределенности поведения такого оператора (сравнивать ли содержимое или указатели). Из-за этого используется самописная функция <code>same</code>:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">same</span><span class="params">(var a,b: int[<span class="number">16</span>])</span></span></span><br><span class="line">    for ai, bi in a, b</span><br><span class="line">        <span class="keyword">if</span> ai != bi</span><br><span class="line">            <span class="keyword">return</span> false</span><br><span class="line">    <span class="keyword">return</span> true</span><br></pre></td></tr></table></figure></p><p><strong><code>- Поддержка именованных именованных кортежей без необходимости использовать отдельный класс</code></strong><br><code>Python</code> позволяет использовать <a href="https://docs.python.org/3.6/library/collections.html?highlight=namedtuple#collections.namedtuple" target="_blank" rel="noopener">именованные кортежи</a> вместо обычных там, где не хочется заводить структуру. В <code>daScript</code> возможность именовать поля кортежа встроена в язык:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">typedef FieldPathInfo = tuple&lt;field:int[<span class="number">16</span>]; fieldFrom:int[<span class="number">16</span>];  rate:int&gt;</span><br><span class="line">var a = [[FieldPathInfo val, vert, rate(val)]]</span><br></pre></td></tr></table></figure></p><p><strong><code>- Ошибки вывода типа в генериках иногда напоминают вывод ошибок в шаблонов C++</code></strong><br><a href="https://github.com/GaijinEntertainment/daScript/issues/309" target="_blank" rel="noopener">https://github.com/GaijinEntertainment/daScript/issues/309</a></p><p><strong><code>- Нет встроенного аналога list из Python и DoubleLinkedList из Nim</code></strong><br>Вместо этого кортежи хранятся в классе <code>array</code>, представляющем собой динамический массив. Для того, чтобы избежать лишнего копирования данных при сортировке, память под кортежи выделяется на стеке:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">//медленный вариант</span><br><span class="line">var open: array&lt;FieldPathInfo&gt;</span><br><span class="line">open |&gt; push &lt;| [[FieldPathInfo source, rate(source), zeros]] //хранение в массиве объектов</span><br><span class="line">//более быстрый вариант</span><br><span class="line">var open: array&lt;FieldPathInfo?&gt;</span><br><span class="line">open |&gt; push &lt;| new [[FieldPathInfo source, zeros, rate(source)]] //хранение в массиве ссылок на объекта на хипе</span><br></pre></td></tr></table></figure></p><p>Также можно отметить, что объекты на хипе выделяются в соседних областях памяти, аллокатор контекста по умолчанию выделяет память из предвыделенного линейного блока:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">16</span>)</span><br><span class="line">    var xxx = new [[FieldPathInfo val, vert, rate(val)]]</span><br><span class="line">    unsafe</span><br><span class="line">        print(<span class="string">"addr=&#123;reinterpret&lt;void?&gt; xxx&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line">//output:</span><br><span class="line">addr=<span class="number">0x28b1bb582f0</span></span><br><span class="line">addr=<span class="number">0x28b1bb58380</span></span><br><span class="line">addr=<span class="number">0x28b1bb58410</span></span><br><span class="line">addr=<span class="number">0x28b1bb584a0</span></span><br><span class="line">addr=<span class="number">0x28b1bb58530</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>Так что, в теории, разница в скорости в выделении объектов на стеке и в куче для <code>daScript</code> должна быть небольшой, и хранение узлов в массиве должно дать даже небольшой прирост скорости из-за локальности хранения узлов в памяти, по отношению к способу хранения в списке.</p><p>За исключением перечисленных отличий, код “переведён” построчно с Python версии (с “бонусной” проверкой ошибок типизации интерпретатором). В такой форме при интерпретации он уже работает лишь чуть медленнее скомпилированной версии на <code>Nim</code>.</p><h2 id="Ahead-of-Time-компиляция"><a href="#Ahead-of-Time-компиляция" class="headerlink" title="Ahead-of-Time компиляция"></a>Ahead-of-Time компиляция</h2><p><code>daScript</code> можно настроить, чтобы вместо интерпретации он генерировал C++-код, выполняющий те же действия. В репозитория проекта есть <a href="https://github.com/GaijinEntertainment/daScript/blob/master/examples/tutorial/CMakeLists.txt#L36" target="_blank" rel="noopener">пример</a> настройки <code>cmake</code> для автоматической генерации AoT-версии кода.<br>Можно проделать этот этап вручную:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">daScript.exe -aot james_bond_jr.das james_bond_jr.das.cpp</span><br></pre></td></tr></table></figure></p><p>Полученный C++ файл можно скомпилировать (можно просто добавить его в один из туториалов), и теперь при выполнении скрипта <code>james_bond_jr.das</code>, вместо интерпретации, будут выполнены скомпилированные версии функций. В таком режиме скрипт обгоняет разогнанную <code>nim</code> версию решения. Выводы в начале.</p><p><img src="/blog/1160489034/jbjr.gif" alt="jbjr"></p><h2 id="Ещё-быстрее"><a href="#Ещё-быстрее" class="headerlink" title="Ещё быстрее!"></a>Ещё быстрее!</h2><p>Пара оптимизаций, чтобы сделать программу ешё быстрее.</p><p><strong><code>[[unsafe_deref]]</code></strong><br>аннотация для функций, которая “инлайнит” обращения по указателям.<br>Код из <a href="https://github.com/GaijinEntertainment/daScript/blob/a0fcdfdbf134d3dfb8055c9218c6e57ff4ae925b/src/ast/ast_simulate.cpp#L1023" target="_blank" rel="noopener">ast_simulate</a>:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">SimNode * <span class="title">ExprPtr2Ref::simulate</span> <span class="params">(Context &amp; context)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( unsafeDeref ) &#123;</span><br><span class="line">        <span class="comment">//симуляция выполнения ноды</span></span><br><span class="line">        <span class="keyword">return</span> subexpr-&gt;simulate(context);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//создание ноды для более поздней симуляции</span></span><br><span class="line">        <span class="keyword">return</span> context.code-&gt;makeNode&lt;SimNode_Ptr2Ref&gt;(at,subexpr-&gt;simulate(context));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong><code>Векторизация!</code></strong><br>В daScript есть встроенные векторные типы int4 и float4, и описание поля логичнее переделать на их использование:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;typedef Field &#x3D; int[16]</span><br><span class="line">typedef Field &#x3D; int4[4]</span><br></pre></td></tr></table></figure><br>Тогда горизонтальные сдвиги можно описать так:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def right(var v:Field; line: int)</span><br><span class="line">    var ans &#x3D; v</span><br><span class="line">    ans[line] &#x3D; ans[line].yzwx</span><br><span class="line">    return &lt;- ans</span><br><span class="line"></span><br><span class="line">def left(var v:Field; line: int)</span><br><span class="line">    var ans &#x3D; v</span><br><span class="line">    ans[line] &#x3D; ans[line].wxyz</span><br><span class="line">    return &lt;- ans</span><br></pre></td></tr></table></figure></p><p>Что 1) короче 2) очень быстро</p><p>Можно измерить скорость выполнения обычной и оптимизированной версии встроенным профайлером:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">profile(20, &quot;JamesBondUsual&quot;) &lt;|</span><br><span class="line">        for i in range(100)</span><br><span class="line">            var dif &lt;- extract(search())</span><br></pre></td></tr></table></figure></p><p>Получился прирост скорости ещё на 25% ( 0.4 -&gt; 0.3 миллисекунд за 100 запусков).<br>Код быстрой версии:</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        gist    </div>    <div class='spoiler-content'>        <script src="//gist.github.com/5aba216fdf4aa70984c112cd4c6496df.js?file=james_bond_jr_fast.das"></script>    </div></div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Мой собственный способ измерить выразительность и скорость языка — решить на нём “задачу Джеймса Бонда младшего”, выдуманную головоломку из игры на NES &lt;code&gt;James Bond Jr&lt;/code&gt; (&lt;a href=&quot;https://youtu.be/Kzu_cGHFqM8?t=1290&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;видео&lt;/a&gt;). Несмотря на игрушечность задачи, кажется, это неплохой тест нового языка. Это веселее, чем реализовывать абстрактный поиск в ширину/глубину. Задачу решаю с небольшими алгоритмическими оптимизациями, но без оптимизаций по мелочам (скорее, наоборот, массив чисел специально копируется, как решена первая версия задачи на питоне, чтобы решения были сравнивыми, чтобы симулировать “код новичка” на языка и посмотреть, как язык справляется с этим копированием).&lt;/p&gt;
&lt;p&gt;Сразу выводы про &lt;code&gt;daScript&lt;/code&gt; для тех, кому не особенно интересны подробности реализации:&lt;/p&gt;
&lt;p&gt;— Выразительность языка ОЧЕНЬ похожа на &lt;code&gt;Python&lt;/code&gt;. Более того, я фактически просто переписал своё решение на &lt;code&gt;Python&lt;/code&gt; 13-летней давности построчно, с парой изменений.&lt;br&gt;— &lt;code&gt;daScript&lt;/code&gt; по скорости &lt;strong&gt;в режиме интерпретации&lt;/strong&gt; находится в одной лиге с компилируемыми языками (!!!). Код по скорости сопоставим с версией на &lt;code&gt;Nim&lt;/code&gt; (чуть быстрее “наивной” &lt;strong&gt;скомпилированной&lt;/strong&gt; версии, и раза в 1.5-2 медленнее оптимизированной).&lt;br&gt;— В режиме &lt;code&gt;Ahead-of-Time&lt;/code&gt; компиляции &lt;code&gt;daScript&lt;/code&gt; обгоняет &lt;code&gt;nim&lt;/code&gt; (который вообще показывает достаточно хорошие результаты в нормальных бенчмарках с другими языками).&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="dascript" scheme="http://spiiin.github.io/tags/dascript/"/>
    
  </entry>
  
  <entry>
    <title>daScript - live-режим</title>
    <link href="http://spiiin.github.io/blog/3006126295/"/>
    <id>http://spiiin.github.io/blog/3006126295/</id>
    <published>2022-06-18T12:23:15.000Z</published>
    <updated>2022-08-01T13:02:57.136Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Попробую описать live-режим работы с приложением в <code>daScript</code> (aka <strong><code>Hot Reloading</code></strong>). Это режим работы программы, в котором можно обновлять данные и код без её перезапуска.</p><p>Интерпретируемые языки часто позволяют, с небольшими усилиями, настроить приложение так, чтобы можно было отследить изменения в каком-либо файле, и выполнить изменённую версию. При соблюдении определенных правил работы с данными также возможно обновить и уже созданные структуры данных — это требует немного больше усилий. С некоторыми заморочками и ограничениями подобное можно проделать и в компилируемых языках, к примеру, обновляя динамическую библиотеку и перезагружая её из основного приложения.</p><p>Обзоры подходов к организации hot reload на C++:<br><a href="https://fungos.github.io/cr-simple-c-hot-reload/" target="_blank" rel="noopener">cr.h: A Simple C Hot Reload Header-only Library</a><br><a href="https://ourmachinery.com/post/dll-hot-reloading-in-theory-and-practice/" target="_blank" rel="noopener">DLL Hot Reloading in Theory and Practice</a></p><p>Интерпретируемые языки требуют намного меньше “магии” для реализации и позволяют избавиться от этих ограничений, присутствующих при реализации через перезагружаемую библиотеку.</p><p>Пример того, что можно реализовать с помощью горячей перезагрузки:<br><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/a-OyoVcbwWE" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></p><p>Сочетание горячей перезагрузки кода, с data-oriented design и легкой сериализацией данных (для запоминания и восстанавления пачки состояний), с возможностью “докинуть” imgui-дебажное окно в приложение, позволяет получить близкий функционал к тому, что показано на видео, в реальной игре. Но даже возможность сократить промежуток между внесением изменений в код и проверкой его в игре, всё ещё кажется чудесной возможностью для большинства команд в геймдеве.</p><p><a href="https://youtu.be/inGb9R1NowY" target="_blank" rel="noopener">Live Stream Coding on daScript - Breakoid</a> - стрим с примером реализации арканоида, можно посмотреть на синтаксис системы ECS, реализованной с помощью макросов</p><p>В репозитории модуля <code>dasGlfw</code> есть <a href="https://github.com/borisbat/dasGlfw/blob/master/framework/main.das" target="_blank" rel="noopener">пример</a>, позволяющий работать с приложением в live-режиме.</p><h1 id="Сборка"><a href="#Сборка" class="headerlink" title="Сборка"></a>Сборка</h1><p>Выкачиваем <a href="https://github.com/GaijinEntertainment/daScript/tree/master/modules" target="_blank" rel="noopener">сабмодуль</a> <code>dasGlfw</code>. В папке с выкачанным daScript выполняем команду:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git submodule update --init --recursive</span><br></pre></td></tr></table></figure><br>Перегенерируем солюшн, чтобы добавить в него проект <code>daGlfw</code>:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;generate_msvc_2019.bat</span><br></pre></td></tr></table></figure><br>(ну или аналогичная команда для вашей любомый иде и платформы)</p><p>В тестовый пример приложения добавляем инклюды и модули daScript. Для модификации используем <a href="https://github.com/GaijinEntertainment/daScript/blob/master/examples/tutorial/tutorial01.cpp" target="_blank" rel="noopener">первый пример</a> на daScript:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"daScript/daScript.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../modules/dasGlfw/src/dasGLFW.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//dasGLFW тянет за собой зависимости от этих модулей:</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../modules/dasStbImage/src/dasStbImage.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../modules/dasStbTrueType/src/dasStbTrueType.h"</span></span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">//так как либы STB описаны в заголовочных файлах, в одну из единиц компиляции необходимо поместить код реализации этих библиотек</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STB_IMAGE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STB_IMAGE_WRITE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../modules/dasStbImage/src/stb_image.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../modules/dasStbImage/src/stb_image_write.h"</span></span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TUTORIAL_NAME   <span class="meta-string">"/modules/dasGlfw/framework/main.das"</span> <span class="comment">//основа live-приложения</span></span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span>, <span class="keyword">char</span> * [] )</span> </span>&#123;</span><br><span class="line">    NEED_ALL_DEFAULT_MODULES;</span><br><span class="line">    NEED_MODULE(Module_dasGLFW);</span><br><span class="line">    NEED_MODULE(Module_StbImage);</span><br><span class="line">    NEED_MODULE(Module_StbTrueType);</span><br><span class="line">    <span class="comment">//NEED_MODULE(Module_TestProfile); //отключаем, если не нужны</span></span><br><span class="line">    <span class="comment">//NEED_MODULE(Module_UnitTest);</span></span><br><span class="line">    Module::Initialize();</span><br><span class="line">    tutorial(); <span class="comment">//выполняем daScript</span></span><br><span class="line">    Module::Shutdown();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Также в команду линковки добавляем подключение собранных статических библиотек (в Visual Studio в свойствах проекта на вкладке свойств линкера):<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Debug\libDaScript.lib</span><br><span class="line">Debug\libDasModuleStbImage.lib</span><br><span class="line">Debug\libDasModuleStbTrueType.lib</span><br><span class="line">Debug\libDasModuleGlfw.lib</span><br><span class="line">..\..\modules\dasGlfw\libglfw\build\src\Debug\glfw3.lib</span><br></pre></td></tr></table></figure><br>(конечно, правильнее добавить зависимости в cmake-файл, чтобы не потерять настройки после перегенерации решения)</p><p>Получаем приложение, которое отслеживает изменения в файле <a href="https://github.com/borisbat/dasGlfw/blob/master/framework/example_app.das" target="_blank" rel="noopener">example_app.das</a> на лету:</p><p><img src="/blog/3006126295/das-live.png" alt="das-live"></p><p><em>с <a href="https://github.com/borisbat/dasGlfw/issues/2" target="_blank" rel="noopener">мааленьким</a> фиксом ассерта</em></p><h1 id="Архитектура-приложения"><a href="#Архитектура-приложения" class="headerlink" title="Архитектура приложения"></a>Архитектура приложения</h1><p>За счёт чего это работает? Нужно рассмотреть несколько концепций, чтобы разобраться.</p><h2 id="Контекст"><a href="#Контекст" class="headerlink" title="Контекст"></a>Контекст</h2><p>Контекст выполнения скрипта (<a href="https://github.com/GaijinEntertainment/daScript/blob/master/include/daScript/simulate/simulate.h#L246" target="_blank" rel="noopener">Context</a>) — окружение, в котором выполняется скрипт, стек и выделенные в куче переменные, а также некоторая дополнительная информация, описывающая то, как именно интерпретируется код. Контекст можно также воспринимать как экзампляр выполняющейся программы, или как результат её испполнения. В <a href="https://dascript.org/doc/reference/embedding/vm.html#execution-context" target="_blank" rel="noopener">документации</a> также указано, что контекст спроектирован для того, чтобы быть максимально легковесным, для того, чтобы сброс контекста можно было использовать как очень быстрый способ освободить всю память, которую использовал скрипт.</p><p>Хост-приложение может использовать один контекст для того, чтобы выполнять в нём различные скрипты, или же создать несколько контекстов, настроенных для различных целей. Например, можно разделить скрипты на те, которые имеют глобальное сохраняемое состояние (которые могут испольовать сборщик мусора), и скрипты без состояния, которые можно быстро освобождать после использования (например, каждый кадр), и использовать различные контексты для них.</p><p>daScript не предполагает работы с одним контекстом из различных потоков (модель многопоточности без разделяемой памяти) — в многопоточном приложении каждый поток может создать свой контекст выполнения, и использовать <a href="https://github.com/GaijinEntertainment/daScript/blob/master/include/daScript/simulate/aot_builtin_jobque.h#L21" target="_blank" rel="noopener">каналы</a> или другие самописные примитивы C++ для передачи данных/общения между потоками.</p><p>Для того, что можно было определить, безопасно ли освобождать контекст, можно заставить интерпретатор daScript проверять, что скрипт не использует глобальных переменных, которые обращающихся к хип-памяти. Один из способом сделать это — использовать настройки <code>Code of Policies</code></p><h2 id="Code-of-Policies"><a href="#Code-of-Policies" class="headerlink" title="Code of Policies"></a>Code of Policies</h2><p><a href="https://dascript.org/doc/stdlib/rtti.html?highlight=code%20policies#CodeOfPolicies" target="_blank" rel="noopener">Code of Policies</a> — настройки виртуальной машины daScript, позволяющие установить определенные правила интерпретации кода. Можно посмотреть на настройки для модуля <a href="https://github.com/GaijinEntertainment/daScript/blob/master/daslib/live.das" target="_blank" rel="noopener">live</a>, в котором определён базовый каркас для построения live-приложения.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">options no_unused_block_arguments &#x3D; false    &#x2F;&#x2F;подсказка не считать неиспользуемые аргументы ошибками компиляции</span><br><span class="line">options no_unused_function_arguments &#x3D; false </span><br><span class="line">options indenting &#x3D; 4                        &#x2F;&#x2F;настройки отступов</span><br><span class="line">&#x2F;&#x2F;!</span><br><span class="line">options multiple_contexts                    &#x2F;&#x2F;подсказка, что приложение будет иметь несколько контекстов выполнения (по коду вроде бы -- более часто вызываются колбеки &#96;reportAstChanged&#96;)</span><br></pre></td></tr></table></figure></p><h2 id="Debug-agents"><a href="#Debug-agents" class="headerlink" title="Debug agents"></a>Debug agents</h2><p>Отладочные агенты — это объекты, который задуманы для возможности отладки и профилирования выполнения контекстов, но также используются для того, чтобы клонировать контексты, с возможностью настраиваить поведение склонированного контекста.<br>Примеры использования можно найти в репозитории — <a href="https://github.com/GaijinEntertainment/daScript/search?q=fork_debug_agent_context" target="_blank" rel="noopener">fork_debug_agent_context</a>.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">forkDebugAgentContext</span> <span class="params">( Func exFn, Context * context, LineInfoArg * lineinfo )</span> </span>&#123;</span><br><span class="line">    g_isInDebugAgentCreation = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;Context&gt; forkContext;</span><br><span class="line">    <span class="keyword">bool</span> realPersistent = context-&gt;persistent;</span><br><span class="line">    context-&gt;persistent = <span class="literal">true</span>;  <span class="comment">//временно делаем контекст неудаляемым</span></span><br><span class="line">    forkContext.reset(get_clone_context(context, <span class="keyword">uint32_t</span>(ContextCategory::debug_context))); <span class="comment">//клонируем контекст</span></span><br><span class="line">    context-&gt;persistent = realPersistent;</span><br><span class="line">    g_isInDebugAgentCreation = <span class="literal">false</span>;</span><br><span class="line">    vec4f args[<span class="number">1</span>];</span><br><span class="line">    args[<span class="number">0</span>] = cast&lt;Context *&gt;::from(context);</span><br><span class="line">    SimFunction * fun = exFn.PTR;</span><br><span class="line">    forkContext-&gt;callOrFastcall(fun, args, lineinfo); <span class="comment">//выполняем функцию установки в склонированном контексте</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Примеры для изучения и понимания работы c клонированными контекстами:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">agent_fork_sample.das</span><br><span class="line">apply_in_context_example.das</span><br><span class="line">insturment_function.das</span><br><span class="line">шnstrument.das</span><br><span class="line">logger_and_logger_agent.das</span><br><span class="line">context_state_example.das</span><br></pre></td></tr></table></figure></p><h2 id="Получение-информации-из-другого-контекста"><a href="#Получение-информации-из-другого-контекста" class="headerlink" title="Получение информации из другого контекста"></a>Получение информации из другого контекста</h2><p>Нет каких-либо особенных сложностей в том, чтобы получить из одного контекста информацию из другого, как из С++, так и из daScript — можно как выполнить функцию в другом контексте (как в примерах выше), так и проверить её существование. Именно это и реализовано в модуле <a href="https://github.com/GaijinEntertainment/daScript/blob/master/daslib/live.das" target="_blank" rel="noopener">live</a>:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">var private appPtr : smart_ptr&lt;Context&gt; //указатель на пересоздаваемый живой контекст</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">private</span> <span class="title">live_lookup</span><span class="params">(fn)</span></span></span><br><span class="line">    if appPtr==null</span><br><span class="line">        <span class="keyword">return</span> false</span><br><span class="line">    <span class="keyword">if</span> !liveFunctionLookup |&gt; key_exists(fn)                 </span><br><span class="line">        liveFunctionLookup[fn] = *appPtr |&gt; has_function(fn) //если в обновляемом контексте существует функция, запоминаем указатель на неё</span><br><span class="line">    <span class="keyword">return</span> liveFunctionLookup[fn]                            </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">public</span> <span class="title">invoke_live</span> <span class="params">( fn:string )</span></span></span><br><span class="line"><span class="function">    <span class="title">if</span> <span class="title">live_lookup</span><span class="params">(fn)</span>  //если нашли указатель на функцию в <span class="title">live</span>-контексте</span></span><br><span class="line"><span class="function">        <span class="title">try</span></span></span><br><span class="line"><span class="function">            <span class="title">unsafe</span></span></span><br><span class="line"><span class="function">                <span class="title">invoke_in_context</span><span class="params">(appPtr, fn)</span> //вызываем функцию в <span class="title">live</span>-контексте</span></span><br><span class="line"><span class="function">        <span class="title">recover</span></span></span><br><span class="line"><span class="function">            <span class="title">to_log</span><span class="params">(LOG_ERROR, <span class="string">"exception during '&#123;fn&#125;'\n&#123;appPtr.last_exception&#125;\n&#123;describe(appPtr.exceptionAt)&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function">            <span class="title">appPtr</span> :</span>= null</span><br></pre></td></tr></table></figure><p>Также можно посмотреть на небольшую оптимизацию создания ресурсов в модуле <a href="https://github.com/GaijinEntertainment/daScript/blob/ecada8d34485fe32ae6e3c87b12033a00f7fe118/modules/dasOpenGL/opengl/opengl_cache.das" target="_blank" rel="noopener">opengl_cache</a> — ресурсы сохраняют в кеше, специальном контексте “opengl_cache”, за счёт чего отпадает необходимость загружать их каждый раз, когда пересоздаётся live-контекст.</p><h2 id="Восстановление-данных"><a href="#Восстановление-данных" class="headerlink" title="Восстановление данных"></a>Восстановление данных</h2><p>Организация перезагрузки функций должна стать примерно понятной, теперь надо разобраться, как пересоздаются данные, созданные в live контексте?</p><p>Приложение использует модуль <a href="https://github.com/GaijinEntertainment/daScript/blob/73b51defa5a0c66446d041743d60101fbd3e74e4/daslib/decs.das" target="_blank" rel="noopener">decs</a>, Entity-Component-System фреймворк.</p><p>Мои заметки-введение в ECS:<br><a href="/blog/381238762/" title="ECS. Ссылки">ECS. Ссылки</a><br><a href="/blog/1488389622/" title="ECS для казуальных игр">ECS для казуальных игр</a></p><p>Одна из фишек ECS — всё состояние игры описывается совокупностью из сущностей (Entity) и компонентов (Components) на них. Достаточно сохранить все сущности и компоненты, при их загрузке состояние будет полностью восстановлено.</p><p>Типы компонентов в decs задаются с помощью обычных структур, с применённым к ним атрибутом <code>[decs_template]</code>, который является макросом, регистрирующим функции <code>apply_decs_template</code> и <code>remove_decs_template</code>. Эти функции позволяют добавлять/удалять компнонент на сущностях.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">//компонент <span class="string">"пушка"</span></span><br><span class="line">[decs_template]</span><br><span class="line">struct Turret</span><br><span class="line">    base        : EntityId</span><br><span class="line">    last_target : float3</span><br><span class="line">    dir         : float</span><br><span class="line">    dir_vel     : float</span><br><span class="line">    rot_speed   : float</span><br><span class="line">    reload      : float</span><br><span class="line">    reload_time : float</span><br><span class="line">    health      : int</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_tank</span> <span class="params">( pos:float3 )</span></span></span><br><span class="line"><span class="function">    //создаём другие компоненты и сущности танка</span></span><br><span class="line"><span class="function">    ..</span></span><br><span class="line"><span class="function">    // создаём сущность "башня танка" и добавляем на неё компонент "пушка"</span></span><br><span class="line"><span class="function">    <span class="title">create_entity</span> &lt;| @ <span class="params">( eid, cmp )</span></span></span><br><span class="line"><span class="function">        <span class="title">cmp</span> |&gt; <span class="title">set</span> <span class="params">( <span class="string">"eid"</span>, eid )</span></span></span><br><span class="line"><span class="function">        <span class="title">cmp</span> |&gt; <span class="title">set</span> <span class="params">( <span class="string">"pos"</span>, float3<span class="params">(<span class="number">0.</span>)</span> )</span></span></span><br><span class="line"><span class="function">        <span class="title">cmp</span> |&gt; <span class="title">set</span> <span class="params">( <span class="string">"color"</span>, float3<span class="params">(<span class="number">.5</span>,<span class="number">.5</span>,<span class="number">0.1</span>)</span>)</span></span></span><br><span class="line"><span class="function">        <span class="title">cmp</span> |&gt; <span class="title">set</span> <span class="params">( <span class="string">"name"</span>, <span class="string">"TANK"</span> )</span></span></span><br><span class="line"><span class="function">        <span class="title">apply_decs_template</span><span class="params">(cmp, [[Turret</span></span></span><br><span class="line"><span class="function"><span class="params">            base=tank_id,</span></span></span><br><span class="line"><span class="function"><span class="params">            reload_time=TANK_TURRET_RELOAD_TIME,</span></span></span><br><span class="line"><span class="function"><span class="params">            health=TANK_HEALTH]])</span></span></span><br></pre></td></tr></table></figure><p>Компоненты в системе <code>decs</code> прозрачно для пользователя добавляются в “мир” (“пул”, “состояние”) — базу данных, описывающих состояние игровой сцены.<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">var public decsState : DecsState    //! Full state of the ESC system.</span><br></pre></td></tr></table></figure></p><p>Переключающий контекст получает эту переменную из предыдущего контекста и сериализует в память, а затем вызывает функцию десериализации в новом контексте:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">var private appPtr : smart_ptr&lt;Context&gt; //указатель на пересоздаваемый живой контекст</span><br><span class="line"></span><br><span class="line"> //сохранение ecs-состояния</span><br><span class="line"> var pvar = get_context_global_variable(appPtr, <span class="string">"decsState"</span>)</span><br><span class="line"> var pstate : array&lt;uint8&gt; ? = get_context_global_variable(appPtr, "decsLiveData")</span><br><span class="line"> var css &lt;- @ &lt;|                   //синтаксис лямбда-функции</span><br><span class="line">      saveLiveContext()</span><br><span class="line"> invoke_in_context(appPtr, css)</span><br><span class="line"></span><br><span class="line"> //смена контекста</span><br><span class="line"> appPtr := ptr</span><br><span class="line"></span><br><span class="line"> //восстановление ecs-состояния в новом контексте</span><br><span class="line">var pvar = get_context_global_variable(appPtr, <span class="string">"decsState"</span>)</span><br><span class="line">var css &lt;- @ &lt;| [[&amp;decsState,&amp;decsLiveData]] ( data : array&lt;uint8&gt;<span class="comment"># )</span></span><br><span class="line">    decsLiveData := data</span><br><span class="line">    restoreLiveContext()</span><br><span class="line">invoke_in_context(appPtr, css, decsLiveData)</span><br></pre></td></tr></table></figure></p><p>Функции <code>saveLiveContext</code> и <code>restoreLiveContext</code> выглядят тривиально, вызывают generic-функции сериализации из модуля <a href="https://github.com/GaijinEntertainment/daScript/blob/e7992b384dad13c1a201f9eee1c6a6ae1e0cf8b8/daslib/archive.das" target="_blank" rel="noopener">archive</a>:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def saveLiveContext</span><br><span class="line">    to_log(LOG_TRACE, &quot;LIVE: saveLiveContext\n&quot;);</span><br><span class="line">    decsLiveData &lt;- mem_archive_save(decsState)</span><br><span class="line"></span><br><span class="line">def restoreLiveContext</span><br><span class="line">    to_log(LOG_TRACE, &quot;LIVE: restoreLiveContext\n&quot;);</span><br><span class="line">        decsLiveData |&gt; mem_archive_load(decsState)</span><br></pre></td></tr></table></figure></p><p>При этом — если изменения не затрагивали названия полей в ECS-компонентах, то приложение может продолжить работать без переинициализации (можно, например, увеличить скорость снарядов танка прямо во время игры — уже выпущенные снаряды продолжат двигаться с той же скоростью, а новые станут быстрее).</p><p>Если же изменить название поля ECS-компонента (к примеру, автозаменой названия поля <code>reload_time</code> на <code>reload_time_11111</code>), десериализовать текущее состояние игры не выйдет , но приложение всё равно не нужно перезапускать, и оно не крешит, для продолжения работы можно просто нажать кнопку переинициализации уровня:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">public</span> <span class="title">live_keypressed</span> <span class="params">( keycode, scancode, action, mods : int )</span></span></span><br><span class="line"><span class="function">    <span class="title">invoke_live</span><span class="params">(<span class="string">"keypressed"</span>, keycode, scancode, action, mods )</span></span></span><br><span class="line"><span class="function">    <span class="title">if</span> <span class="title">is_live</span><span class="params">()</span></span></span><br><span class="line">        if scancode==19 &amp;&amp; action==1 &amp;&amp; mods==2 //нажать комбинацию клавиш "control + break"</span><br><span class="line">            recompile(true)</span><br></pre></td></tr></table></figure></p><p>При желании можно реализовать и десериализацию с возможностью переименования полей компонентов — для этого необходимо в ходе перезапуска контекста сохранить список названий всех полей компонентов в старом и новом контексте (его можно получить с помощью <code>rtti</code>) и передавать между контекстами таблицу переименований.</p><h2 id="Цикл-переключения-контекстов"><a href="#Цикл-переключения-контекстов" class="headerlink" title="Цикл переключения контекстов"></a>Цикл переключения контекстов</h2><p>Последний шаг, для связывания живого приложения с обновляемым контекстом — цикл переключения контекстов, который также тривиален (<a href="https://github.com/borisbat/dasGlfw/blob/master/dasglfw/glfw_live.das#L41" target="_blank" rel="noopener">glfw_live</a>):</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">public</span> <span class="title">glfw_live</span><span class="params">(title,appf,appd:string)</span></span></span><br><span class="line"><span class="function">    .. //различная инициализация и настройка <span class="title">glfw</span></span></span><br><span class="line"><span class="function">    <span class="title">go_live</span><span class="params">(appf, appd)</span></span></span><br><span class="line">    while glfwWindowShouldClose(glfw_live_window)==0</span><br><span class="line">        glfwPollEvents()</span><br><span class="line">        live_update(glfwGetTime())                                      //обновление live-контекста</span><br><span class="line">        invoke_live(<span class="string">"display"</span>, display_w, display_h)                    //вызов функции рисования экрана в live-контексте</span><br><span class="line">        glfwMakeContextCurrent(glfw_live_window)</span><br><span class="line">        glfwSwapBuffers(glfw_live_window)                               //отрисовка экрана</span><br><span class="line">        <span class="keyword">if</span> watch_files()                                                //если файл с исходником live-контекста изменился</span><br><span class="line">            recompile()                                                 //пересоздать live-контекст</span><br></pre></td></tr></table></figure><h1 id="Идеи"><a href="#Идеи" class="headerlink" title="Идеи"></a>Идеи</h1><ul><li>Live Creative &amp; Prototype Coding — всё из видео в начале заметки</li><li>Автозапись ECS-состояний для воспроизведения того, что делали с игрой тестировщики, с проигрыванием на любой скорости и обратной перемоткой</li><li>Hot-reload кода и данных на удалённом клиенте (мобильном телефоне, консоли)</li><li>Совместная работа над сценой на удалённом клиенте (или реализация AI Battles в песочнице)</li><li>Сериализация не только сущностей и компонентов, но и систем — песочница механик</li></ul><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;Попробую о
      
    
    </summary>
    
    
    
      <category term="opengl" scheme="http://spiiin.github.io/tags/opengl/"/>
    
      <category term="dascript" scheme="http://spiiin.github.io/tags/dascript/"/>
    
      <category term="ecs" scheme="http://spiiin.github.io/tags/ecs/"/>
    
  </entry>
  
  <entry>
    <title>Индустрия снова во мгле</title>
    <link href="http://spiiin.github.io/blog/2786387393/"/>
    <id>http://spiiin.github.io/blog/2786387393/</id>
    <published>2022-06-12T18:39:23.000Z</published>
    <updated>2022-07-02T15:29:00.293Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><h2 id="Давным-давно-в-далёкой-далёкой-галактике…"><a href="#Давным-давно-в-далёкой-далёкой-галактике…" class="headerlink" title="Давным-давно, в далёкой-далёкой галактике…"></a>Давным-давно, в далёкой-далёкой галактике…</h2><p>Давным-давно, в 2007 году, рынок разработки пк-игр в россии и снг внезапно накрылся (крякнул, сыграл в ящик, мы его потеряли). Состояние индустрии на тот момент описал в статье на dtf и в своём блоге в жж Петр “Amicus” Прохоренко. На сайте статьи уже нет, но <a href="https://web.archive.org/web/20071219121354/http://www.dtf.ru/blog/read.php?id=49254" target="_blank" rel="noopener">интернет всё помнит</a> (<a href="https://web.archive.org/web/20071220173806/http://amicus-hg.livejournal.com/85101.html" target="_blank" rel="noopener">всё-всё</a>).</p><p>Основные причины, по мнению автора:</p><ul><li>Неготовность индустрии к изменениям. Нет культуры разработки.<br>Компании клепали игры, и не задумывались о том, что происходит вокруг.</li></ul><blockquote><p>Опыт разработки игр не особенно передавался не то, что по индустрии, но и внутри компаний. Условия существования стали “вдруг” намного более жёсткими, а разработчики оказались к этому не готовы. При этом – повсеместно фантастическая безответственность в плане принятия решений и полное отсутствие гибкости и желания взглянуть в будущее.  Если судить цинично, то большинство «компаний одной игры», где нет своей развитой технологической базы и идущих внахлест друг за другом двух-трех проектов, были обречены изначально – любое изменение рынка убило бы их в первую очередь. Вопрос, почему значительная часть российских компаний, существующих не первый год, так и осталась сидеть на одном проекте, возвращает нас к началу этого абзаца.</p></blockquote><ul><li>Издатели не научились продюссировать и не умеют в маркетинг<br>В 2008 появился iPhone с магазином Appstore и появился инструментарий Steamworks в Steam, а пиратские игры на дисках продавались по цене диска.</li></ul><blockquote><p>Так у нас еще и не сформировались нормальные институты продюсирования, маркетинга и продвижения проектов. С продюсированием вообще швах полный – никакой системности, у каждого свои методы работы, и что самое главное такой уровень перегруженности самих продюсеров, что их присутствие «в проекте» в принципе сведено к минимуму. Маркетинг традиционно тыкает пальцем в небо и строит воздушные замки, хотя в этом направлении у некоторых издателей есть определенные позитивные подвижки.</p></blockquote><p>Итоги:</p><blockquote><p>Кризис – это что-то преходящее, после него должна наступить ремиссия и пережившим его участникам рынка станет лучше, а некоторым так и вообще сильно хорошо. У нас не кризис, у нас просто заканчивается целая эпоха, и развитие отечественной индустрии направляется в другую сторону.</p></blockquote><p>В комментариях — тонны ангста и отрицания, нет никакой “вомглы”.</p><p>Также виноваты по разным версиям:<br><a href="http://neolurk.org/wiki/%D0%92%D0%BE%D0%BC%D0%B3%D0%BB%D0%B0" target="_blank" rel="noopener">Вомгла</a></p><ul><li>Геймдизайнеры</li></ul><blockquote><p>В России много хороших программистов. Нередки даже талантливые. Есть художники, композиторы. А вот число Геймдизайнеров и креативных лидеров — константа, равная 3.5 Анонимусам.</p></blockquote><ul><li>Менталитет</li></ul><blockquote><p>Но тут вмешивается менталитет. Русскому разработчику необходимо, чтобы над ним кто-то постоянно нависал грозной тенью и тыкал носом в четко поставленную задачу, требуя отдачи. Совместные мозговые штурмы, энтузиазм, проявление инициативы, рассмотрение нескольких вариантов, трезвая оценка собственных сил — все это чуждо большинству из них.</p></blockquote><p><a href="https://boris-batkin.livejournal.com/11324.html" target="_blank" rel="noopener">ЖЖ</a> (хех, только заметил, что это автор <code>daScript</code>)</p><ul><li>Тотальный непрофессионализм</li></ul><blockquote><p>с точки зрения регистрации на ДТФ есть 367 работающих компаний разработчиков игр. есть мнение, что после того, как уляжется пыль, 367 профессионально-пригодных разработчиков можно и не найти.</p></blockquote><h2 id="Попытки-рефлексии"><a href="#Попытки-рефлексии" class="headerlink" title="Попытки рефлексии"></a>Попытки рефлексии</h2><p>Какие-то компании различными способами пережили мглу, потому что смогли делать научиться делать казуалки, портировать их на мобильные платформы, или же умели делать игры для консолей. Появлялись новые компании, приходили новые люди. Где-то в этот период попал в индустрию и я (угу, к “Гайдзинам”, которые умели в консоли, и начали учиться в iPhone). Кто-то пытается отрефлексировать то, что происходило тогда, до сих пор.</p><p><a href="https://web.archive.org/web/20180501041548/https://arcticengine.com/posts/vomgla_article/" target="_blank" rel="noopener">Заметки из 2018</a>, с несколькими интересными картинками.<br><a href="https://vk.com/@theworldissaved-russkie-igry-vo-mgle" target="_blank" rel="noopener">Статья</a>, собранная из пачки <a href="https://twitter.com/YarKravtsov/status/1357395078583566337" target="_blank" rel="noopener">твиттов</a>Ярослава Кравцова, рожденная срачем между какими-то <a href="https://youtu.be/50d6rqNjptM" target="_blank" rel="noopener">обзорщиками</a> с ютуба и <a href="https://youtu.be/zfAKuReIjF0" target="_blank" rel="noopener">подкастерами</a><br>Еще забавный <a href="https://youtu.be/Rvc5uiURLH0" target="_blank" rel="noopener">доклад</a> явно неотрефлексировшего ситуацию чувака.</p><blockquote><p>до 2007 типа российские компании делали по его мнению крутые и душевные игры, на которых мы все выросли, но “почему-то” в один момент развалилось всё (из крупных компаний, образованных до 2007 года, которые немобилками занимались, ща остались только гайдзины и wargaming - первые потому что под нексген консоли игры делали для sony и microsoft, вторые танки в 2009 выпустили), отчасти потому что в таком режиме делали фигню разную не задумываясь, и издатели в один момент забили на финансирование местных полностью и стали выпускать и локализовать иностранные игры, отчасти потому, что пропустили 2 новых аудитории - соц игры фейсбука и мобильные игры. Теперь говорит “а давайте как раньше делать, как будто ничего не изменилось, а мобилки эти ваши новомодные скоро умрут”, и реклама своей компании напоследок. В западной индустрии и инди-сцене году так в 2010 уже приняли, что есть кор игры и социальные (там против зинги вначале тоже выступали кор-разработчики), а в российской ещё местами есть люди, которые считают, что кроме кор-игр других нет, и должно быть стыдно тем, кто делает не игры “для души” (если точнее, то игры основных тем для аудитории мужчины 15-30, первые “большие продающиеся идеи” - sports, dragons, robots, guns, jumping &amp; climbing, and car) <a href="https://www.raphkoster.com/2010/03/18/what-core-gamers-should-know-about-social-games/" target="_blank" rel="noopener">https://www.raphkoster.com/2010/03/18/what-core-gamers-should-know-about-social-games/</a></p></blockquote><p>Зачем я собрал все эти срачи, обсуждения, тревоги и мнения в одну кучу? Хотел найти список компаний, перечисленных Ярославом, как спонсоров Девгамма по годам их открытия, чтобы посмотреть, какие выживут через несколько месяцев/лет.</p><h2 id="No-future"><a href="#No-future" class="headerlink" title="No future"></a>No future</h2><p>В 2022 году рынок разработки мобильных игр в россии внезапно накрылся (крякнул, сыграл в ящик, мы его потеряли). И вновь:</p><blockquote><p>У нас не кризис, у нас просто заканчивается целая эпоха, и развитие отечественной индустрии направляется в другую сторону.</p></blockquote><p><img src="/blog/2786387393/bk.png" alt="bk"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ZeptoLab - 2009</span><br><span class="line">Pixonic - 2009</span><br><span class="line">MyTona - 2012</span><br><span class="line">Game Insight - 2009 - 2022 https:&#x2F;&#x2F;app2top.ru&#x2F;industry&#x2F;game-insight-ushla-na-samolikvidatsiyu-raboty-lishilis-do-600-spetsialistov-199488.html</span><br><span class="line">Playgendary - 2016 - https:&#x2F;&#x2F;www.forbes.ru&#x2F;tekhnologii&#x2F;469235-deneg-net-delajte-cto-hotite-kak-gejmstudii-uhodat-iz-rossii-i-sokrasaut-personal</span><br><span class="line">KamaGames - 2010</span><br><span class="line">CrazyPanda - 2010</span><br><span class="line">Easybrain - 2016</span><br><span class="line">Owl Studio - 2015</span><br><span class="line">Social Quantum - 2010</span><br><span class="line">Playkot - 2009</span><br><span class="line">Belka Games - 2010</span><br><span class="line">Vizor Games - 2007</span><br><span class="line">Rocket Jump (RJ Games) - 2012</span><br><span class="line"></span><br><span class="line">Playrix - 2004 - казуальные игры</span><br><span class="line">G5 - 2001 - мобильные и казуальные игры</span><br><span class="line">Nekki - 2002 - браузерки</span><br><span class="line">Gaijin Entertainment - 2002 - релизы на консолях</span><br><span class="line">Wargaming - 1998 - выход World of Tanks в 2009</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;h2 id=&quot;Давны
      
    
    </summary>
    
    
    
      <category term="gamedev" scheme="http://spiiin.github.io/tags/gamedev/"/>
    
  </entry>
  
  <entry>
    <title>daScript - перевод интервью с создателем языка</title>
    <link href="http://spiiin.github.io/blog/2630317622/"/>
    <id>http://spiiin.github.io/blog/2630317622/</id>
    <published>2022-06-12T14:13:37.000Z</published>
    <updated>2022-06-15T17:19:24.011Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Свободный перевод части <a href="https://80.lv/articles/a-look-at-the-current-state-of-independent-gamedev-software-production/" target="_blank" rel="noopener">статьи</a> <code>A Look At The Current State of Independent Gamedev Software Production</code>, интервью с автором языка daScript Борисом Баткиным. Курсивом — мои вставки. Иногда осознанно немного перефразирую или уточняю ответы.<br><a id="more"></a></p><p>Пост посвящен храбрым разработчикам и небольшим инди-командам, создающим собственные технологические решения для разработки игр.</p><p>Сегодня у нас есть множество мощных движков, доступных бесплатно: <code>Unreal, Unity, Lumberyard, CryEngine</code> и другие решения. Они содержат полный набор инструментов, позволяющий разработчикам экономить время на разработке собственных тулзов.</p><p><em>хм, ну не то, чтобы прямо совсем бесплатно доступны…</em></p><p>…</p><p>Но всё же некоторые разработчики продолжают находить причины, чтобы разрабатывать собственные движки. И мы говорим не только о гигантах вроде <code>Guirilla Games</code> или <code>Rockstar</code>. Одиночки или небольшие инди-команды предлагают свои решения, которые призваны справиться с недостатками существующих решений. Не слишком ли сложно это для маленькой команды? Мы связались с авторами нескольких таких технологий, чтобы узнать у них об их мотивах, проблемах, временных затратах и другом.</p><p><em>если говорить о daScript, то “Гайдзины” — не то, чтобы маленькая команда, и имеет свои наработки в области скриптовых языков, а также использования их в продакшене, где-то лет так 15 как минимум</em></p><p>…</p><h2 id="Разработка-daScript"><a href="#Разработка-daScript" class="headerlink" title="Разработка daScript"></a>Разработка daScript</h2><p>Мы связались с Борисом Баткиным, разработчиком <code>daScript</code>. Это высокоуровневый скриптовый язык с сильной статической типизацией. Цель разработки — создать быстрый язык для встраивания в качестве скриптового языка в C++ для критичных по производительности приложений, таких как игры. Посмотрим внимательнее на <code>daScript</code> и на то, как он может помочь улучшить производительность.</p><p><strong>Расскажи пожалуйста о daScript. Почему и когда ты начал над ним работать?</strong></p><p>С самого начала моей карьеры как программиста я хотел создать собственный язык. Фактически, первое, чем я занимался, работая в игровой индустрии в 2000х, было написание кросс-компилятора из <code>UnrealScript</code> в <code>C++</code>. С тех пор я думал о создании своего языка.</p><p>В 2005 я создал несколько черновиков и прототипов, когда я работал на <code>Naughty Dogs</code> и они экспериментировали со своим лиспо-подобным языком <code>Goal</code>, от которого им пришлось отказаться при переходе от PlayStation2 к PlayStation3. Тогда у нас было много продуктивных дискуссий, который натолкнули меня на некоторые идеи.</p><p><em>позволю себе втыкнуть сюда собственные размышления о языках программирования, применительно к геймдеву и не только</em><br><em><a href="/blog/3652741154/" title="10 лет в геймдеве">10 лет в геймдеве</a> — раздел языки программирования, про опыт использования разных языков<br><a href="/blog/1808122922/" title="Nim in imaginary world">Nim in imaginary world</a> — мои критерии выбора языка для хобби- и профессиональной разработки<br><a href="/blog/2297379949/" title="Заметки о языках программирования">Заметки о языках программирования</a> — сборник заметок про языки разного уровня и целей<br><a href="/blog/1728194429/" title="С++ в геймдеве">С++ в геймдеве</a> — почему C++ и всё ли с этим правильно</em></p><p>Уже тогда было до боли очевидно, что язык должен быть встраиваемым (<em>в С++</em>). Большинство компаний используют для создания игр подмножество <code>C++</code> (каждая — своё). Какой бы скриптовый язык мы ни придумали, он должен хорошо совмещаться с существующей кодовой базой. Можно думать о <code>C++</code> как платформе, тогда специализированный язык для игр должен работать на этой платформе. Подобные вещи происходили с другими платформами. <code>Java</code> получила <code>Scala</code>, а позже <code>Kotlin</code>, браузер в определенный момент стал платформой, и получил несколько языков, транслируемых в <code>JavaScript</code>, у <code>.Net</code> сначала был только <code>C#</code>, но позже получил жизнеспособный <code>F#</code>. <code>daScript</code> является чем-то подобным для <code>C++</code>.</p><p>Игровая индустрия давно нуждается в более практичном решении. C++ нельзя назвать идеальным языком программирования, если не сказать ещё хуже. Он многословен, он имеет очень крутую кривую обучения. Мультиплатформенное программирование на C++ напоминает обход минного поля. Вcё может внезапно взорваться. Но при этом, он позволяет создать надёжный код, поэтому мы его используем. Но желание иметь простое решение для быстрых итераций разработки — очень привлекательно.</p><p>Встроенные языки, которые обычно используются в индустрии игр, динамически типизируемые, с дорогостоящей передачей управления между C++ и скриптовым языком. <code>Lua (с LuaJIT), Squirrel, DukTape/QuickJS</code> - вот только некоторые из примеров. В большинстве из них лучшая производительность достигается за счёт just-in-time (JIT), но такая возможность вообще не доступна на большинстве закрытых платформ, таких как консоли или iOS. Маршаллинг данных между нативным и скриптовым кодом быстро становится серьёзной проблемой, даже при включенном JIT. Как правило, такая производительность приемлема только для event-driven приложений с отправкой сообщений, и на этом точка. Но такой подход не масштабируется для приложений типа игр. В результате большая часть “тяжёлого” кода либо сразу пишется на C++, либо же сначала пишется прототип на скриптовом языке, который затем переписывается на C++.</p><p><em>Антон Юдинцев в своём <a href="https://youtu.be/IvHGczF6Go0?t=1301" target="_blank" rel="noopener">докладе</a> про daScript ссылается в качестве примера на <a href="https://youtu.be/KHWquMYtji0" target="_blank" rel="noopener">доклады</a> про оптимизацию Fortnite на мобильные платформы — большая часть оптимизаций заключается в том, чтобы переписать код с блюпринтов на C++. Мой опыт использования Squirrel в продакшене для мобильных телефонов — ~20% работы состоит в переписывании со скриптов обратно на C++</em>.</p><p>Есть примеры статически типизированных скриптовых языков в геймдеве, <code>UnrealScript</code> — один из первых заметных успешных. Однако он показал проблемы с масштабируемостью. Рано или поздно наступает момент, когда “переписать медленную часть на C++” становится типичным решением проблем с производительностью в проекте. В конце концов, <code>Unreal</code> перешёл к <code>BluePrint</code>, у которого есть собственные минусы.</p><p>ООП в стиле C++ (<em>данные разбросаны на хипе</em>) - серьёзное препятствие для написания быстрого кода. Большинство языков предназначены в основном для поддержки той или иной модели программирования. Однако в разработке игр в наши дни часто необходим более ориентированный на данные подход (<em>data oriented design</em>). Многие переходят на ECS-фреймворки, которые сопровождаются какой-либо дополнительной инфраструктурой. <code>Unity</code> создала компилятор <code>Burst</code>, использующий подмножество C# для решения проблемы связи фреймворка с языком. Джонатан Блоу разрабатывает язык <code>Jai</code> для решения той же проблемы. Языки, которые изначально спроектированы с учётом возможности использования с data-oriented фреймворками, могут сделать взаимодействие с ними проше, и <code>daScript</code> делает шаг в этом направлении.</p><p>Когда в 2018 году Антон Юдинцев из <code>Gaijin Entertaiment</code> обратился ко мне с предложением создать собственный язык для их ECS-фреймворка, я “купился”. Запрос был достаточно конкретным, чтобы заинтересовать меня — язык общего назначения с “большой идеей” это не просто академическое упражнение, его очень трудно создать и еще труднее адаптировать к продакшену.</p><p><strong>Какие преимущества использования daScript? Как его можно использовать для разработки игр? Как это повлияет на производительность?</strong></p><p><code>daScript</code> работает быстро. Передача управления между C++ и daScript очень дешёвая. У него очень быстрый интерпретатор. Он выполняется с той же скоростью, что и нативный C++, если использует ahead-of-time компиляцию. По сути, вам никогда не придётся ничего переписывать с daScript на C++.</p><p><strong><em><code>(!) Это серьёзная заявка на киллер-фичу языка. Одну из. Вторая -- при небольшой настройке должно быть можно получить hot code reload, время перекомпиляции+перезапуска игры на мобилках, да и на ПК, критично</code></em></strong></p><p>daScript — безопасный, статически типизированный язык с сильной типизацией, с параноидальным уровней проверки ошибок. Однако у него очень надёжный механизм вывода типов, поэтому большая часть времени вам не нужно декорировать свой код информацией о типах. Безопасный код на языке обычно и выглядит просто, а небезопасный — должен быть явно помечен как таковой.</p><p>daScript — встраиваемый язык. Он хорошо сочетается с вашей кодовой базой на C++. Он сам компилируется тем же компилятором на тех же платформах. Нет проблемы с тем, что платформа не поддерживает JIT, потому что вы можете просто пред-компилировать все скрипты в C++ (aheod-of-time компиляция). При этом, вы можете “патчить” скопмилированные в C++-скрипты с помощью обновлённой интерпретируемой версии в реальном времени.</p><p><em>(Либо обновляя скрипты на девайсе на лету, либо присылая их “динамиками” с сервера)</em></p><p>Язык предоставляет очень глубокие механизмы интеграции, которые выходят далеко за рамки простого связывания методов, чтобы такие вещи, как ECS-фреймворк, могли получить всю необходимую им дополнительную информацию, как используются данные. Мы можем контроллировать, как именно интерпретируется daScript, и какой именно C++ код будет сгенерирован.</p><p><em>(Тут я чё-то не допонимаю, о чём именно говорит автор, не видел в репозитории примеров, возможно речь о <a href="/blog/1547564887/" title="синтаксических макросах">синтаксических макросах</a>)</em></p><p><strong>update</strong><br><em>Связался с Борисом лично для уточнения. Помимо макросов, для типов, описанных в C++, возможно также задавать кастомные simulate-функции и то, как они будут трансформироваться в C++ код (aot-компиляция). Т.е. фактически переопределить в типе любые синтаксические формы обращения с ним, как он ведёт себя на любой чих — сделать с помощью этого какой угодно DSL. В отличие от макросов, можно указывать, как генерируется AOT, и за счёт этого получать оптимальный код. Например, различные vector swizzle операции трансформировать в SIMD-инструкции.</em></p><p>daScript — язык для повышения продуктивности программистов. У него очень быстрое время компиляции. Он поддерживает горячую перезагрузку. Обычно изменения в коде отображаются в программе, как только они слетели с кончиков ваших пальцев. При правильной настройке вы можете запустить приложение и затем реализовать совершенно новую фичу, даже не перезапуская его.</p><p><strong><em><code>(!) а это -- заявка на киллер-фичу #2</code></em></strong></p><p><strong>Разработка собственного решения может показаться слишком сложной для большинства разработчиков, что же заставляет кого-то создавать что-то новое и сложное?</strong></p><p>Некоторые говорят, что необходимость — это мать изобретений. В какой-то момент становится совершенно очевидно, что никакие эволюционные улучшения не позволят сделать следующий шаг в качестве разработки. Наличие хорошего инструмента является признаком хорошего инженерного мышления. В случае с daScript было очевидно, что информацию, необходимую для среды ECS, очень сложно извлечь из кода на C++. Что программисту необходимо будет искуственно размечать код определенным образом, и этот процесс будет постоянно подвержен ошибкам в ходе написания и поддержки, и это просто чтобы предоставить информацию для эффективной работы фреймворка. Добавьте к сравнению разницу в скорости — даже прототип daScript был в 10-35 раз быстрее, чем LuaJit, и вдруг создание новый языка уже покажется очень хорошим вложением.</p><p><code>LuaJit</code> бьл хорошим источником вдохновения. Удивительно, как много можно сделать для языка, который не был спроектирован для достижения максимальной производительности. Если же сделать что-то подобное для языка, который изначально затачивался, чтобы быть производительным, должно быть возможно достичь поразительных результатов. При этом превзойти LuaJit — это непростой челлендж, он задаёт высокую планку, ни один интерпретируемый язык не может даже близко приблизиться к нему.</p><p>Когда дело доходит до фич самого языка, то идеи брались из самых различных источников: <code>Kotlin, Python, Ruby, Lisp, F#, HLSL</code> (!!!) — всего лишь некоторые из них. Одной из ключевых идея было “сделать что-то похожее, только работающее с сумасшедшей скоростью”.</p><p>Другая идея: “писать меньше лишнего”. Наличие в языке простых, но сильных генериков было обязательным с самого начала. Статически типизируемые языки без обобщений и вывода типов, как правило, очень многословны. С другой стороны, декларативное обобщенное программирование очень контр-интуитивно, поэтому мы пошли путём возможности проверки условий во время компиляции и при этом возможностью явно указать…, ну, вообще всё.</p><p><em>(? в оригинале: and explicit… well, explicit everything.)</em></p><p>Сосредоточение внимания на функциональном программировании и data-oriented design подходе, а не на классическом ООП, было еще одним сознательным решением. Язык должен был быть быстрым, а классическое ООП просто не позволило бы сделать его таким.</p><p><strong>Расскажи пожалуйста, о затратах времени. Сколько времени ушло на то, чтобы создать ядро языка? Какие дальнейшие планы?</strong></p><p>Потребовалось 3 месяца, чтобы создать прототип. С тех пор прошло около года, и язык сильно повзрослел. Теперь он работает у нас на клиенте и на сервере, и объём кода только растёт. Роадмап развития языка:</p><ul><li>Доработать язык до спецификации. Сейчас в нём не хватает нескольких важных задуманных вещей.<br>— Variant types.<br>— Мощный pattern-matching.<br>— Нативная поддержка генераторов (yield).<br>— Нативная поддержка регулярных выражений.</li><li>Переписать компилятор daScript и всё остальное (кроме рантайма) на нём самом.<br>— Это даст возможность представлять AST языка для чтения и записи на нём самом. Сейчас, сложные макросы и аннотации функция необходимо писать на нём самом.<br><em>(доступ к ast из daScript есть на момент перевода статьи, как и часть фич выше)</em></li><li>GPU бекэнд. Сейчас aot-компиляция доступна только в C++, но нет никакой фундаментальной причины для этого ограничения.</li><li>Стандартная библиотека и дополнительные модули.<br>— В стандартной библиотеке не хватает многих вещей, особенно для функционального программирования. Как только будут доделаны генераторы, следом нужно будет реализовать стандартные функции высшего порядка.<br><em>(вроде тоже есть уже)</em><br>— Существует несколько де-факто стандартных библиотек, для которых стоит сделать привязку “из коробки”. PugiXml, RapidJson, UriParser и другие.</li><li>Оптимизации, множество и множество оптимизаций.<br>— daScript уже оптимизирующий компилято с большими возможностями, которые будут только расти.<br>— daScript уже экстремально быстрый интерпретатор. И это лишь хорошая причина для того, чтобы сделать его еще быстрее.<br>— daScript при AoT-компиляции генерирует вполне читабельный C++-код. Однако мы хотели бы сделать, чтобы результирующий код на C++ был более надёжным.</li></ul><p>Несмотря на то, что еще слишком рано для standalone компилятора daScript, уже очевидно, что LLVM-бекэнд позволил бы генерировать значительно лучший код, чем AoT-бекэнд. Компилятор daScript знает некоторые факт о том, как используется код, такие как выравнивание, aliasing, зависимости и т.д., которые очень сложно передать компилятору C++. Так что в какой-то момент, вероятно, появится LLVM-бекэнд и возможность использовать daScript для полного цикла разработки, но я не думаю, что это произойдёт скоро.</p><p><a href="https://github.com/borisbat" target="_blank" rel="noopener">Борис Баткин</a>, разработчик языка <a href="https://dascript.org/" target="_blank" rel="noopener">daScript</a></p><p><em>От себя добавлю немного</em>:</p><ul><li>Скорость итераций разработки, который можно добиться с помощью скриптов — ключевой путь к качеству и выживанию игры-сервиса (а такие — почти все игры сейчас)</li><li>Скорость кода — важный параметр, чтобы у вас телефон с 4х-ядерным процессором, и вообщем-то неплохим GPU и кол-вом RAM не считался “тостером” (у конкурентов-то игра на нём отлично работать будет)</li><li>Отсутствие необходимости переписывать код с одного языка на другой ради ускорения просто экономит время, за которое можно сделать что-нибудь новое</li><li>До продакшена долетают типичные ошибки C++ (а это у всех бывает, в тексте ссылка на доклад Антона Юдинцева о статистике ошибок в Warthunder) — если станет меньше C++-кода (и меньше доступа к этому коду у неквалифицированных программистов) - станет и меньше таких ошибок</li><li>Высокая скорость разработки фич (hot-code reload об этом) — один из необходимых моментов для перехода к созданию более масштабных в плане количества кода игр (эх, ещё бы стоимость создания арта для более масштабных проектов как-нибудь сократить)</li></ul><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Свободный перевод части &lt;a href=&quot;https://80.lv/articles/a-look-at-the-current-state-of-independent-gamedev-software-production/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;статьи&lt;/a&gt; &lt;code&gt;A Look At The Current State of Independent Gamedev Software Production&lt;/code&gt;, интервью с автором языка daScript Борисом Баткиным. Курсивом — мои вставки. Иногда осознанно немного перефразирую или уточняю ответы.&lt;br&gt;
    
    </summary>
    
    
    
      <category term="dascript" scheme="http://spiiin.github.io/tags/dascript/"/>
    
  </entry>
  
  <entry>
    <title>daScript: C++ auto-bindings, assimp</title>
    <link href="http://spiiin.github.io/blog/500729544/"/>
    <id>http://spiiin.github.io/blog/500729544/</id>
    <published>2022-06-12T11:41:20.000Z</published>
    <updated>2022-08-01T13:03:34.379Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Продолжение предыдущего поста с генерацией модулей daScript к С++-библиотекам с помощью автоматического генератора <code>dasBind</code>.<br><a href="/blog/4090909622/" title="daScript: C++ auto-bindings, msgpack">daScript: C++ auto-bindings, msgpack</a></p><p>На этот раз чуть более сложный случай с библиотекой <a href="https://github.com/assimp/assimp" target="_blank" rel="noopener">assimp</a>, которая позволяет загружать 3d-модели в различных форматах. Для начала — собираем библиотеку из исходников. Я бы рекомендовал версию 4.1.0, как стабильную, в более новых сломаны некоторые настройки постпроцессинга загруженных мешей.</p><p>Привязки assimp к другим языкам в основном репозитории малость заброшены, так что попутно починим и их.</p><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p>Самый простой случай — достаточно поправить синтаксические отличия между Python 2 и 3. </p><h2 id="DotNet-open3mod"><a href="#DotNet-open3mod" class="headerlink" title="DotNet, open3mod"></a>DotNet, open3mod</h2><p>Живёт <a href="https://github.com/acgessler/open3mod" target="_blank" rel="noopener">тут</a>, необходимо:</p><ul><li>Собрать библиотеку assimp в DLL, переименовать в Assimp32.dll или Assimp64.dll.</li><li>Собрать библиотеку AssimNet.dll с классами обёртками.</li><li>Собрать проект <code>AssimpNet.Interop.Generator</code>, который нужен, чтобы <a href="https://github.com/acgessler/open3mod/blob/master/libs/assimp-net/AssimpNet.Interop.Generator/Program.cs#L34" target="_blank" rel="noopener">пропатчить</a> IL-код из AssimpNet размерами типов, полученных из PDB файла. Для этой техники используется библиотека <a href="https://www.mono-project.com/docs/tools+libraries/libraries/Mono.Cecil/" target="_blank" rel="noopener">Mono.Cecil</a>.</li><li>Пропатчить библиотеку (данный шаг прописан в PostBuild-степ в решении, но лучше убедиться, что он корректно отработал)</li><li>Собрать и запустить open3Mod - просмотрщик, в котором можно проверить работоспособность библиотеки.</li></ul><h2 id="daScript"><a href="#daScript" class="headerlink" title="daScript"></a>daScript</h2><p>Автоматический генератор привязок <code>dasBind</code> не работает с C++ template-кодом, но все заголовочные файлы <code>assimp</code> поддерживают также c-интерфейс. Однако без некоторой “доработки напильником” воспользоваться этим интерфейсом не удастся, так как, несмотря на то, что генератору привязок можно указать, чтобы он парсил заголовочные файлы как c-код, возникают ошибки двойного определения типов при использования этих же хидеров в C++ коде самого проекта, который будет использовать эти привязки. Причины такого поведения — попытка различать, какой из интерфейсов использовать с помощью макроса <code>__cplusplus</code>, который всегда определён в C++ коде (<code>exrern &quot;C&quot;</code> его не отключает).</p><p>Однако можно пойти на хитрость, и просто заменить во всех исходниках макрос <code>__cplusplus</code> на какой-нибудь кастомный, который не будет определен в коде, чтобы как <code>dasBind</code>, так и использующий сгенерированный C++-модуль <code>dasAssimp</code>, “увидели” именно сишный интерфейс к библиотеке.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#replace_cplusplus_to_custom.py</span></span><br><span class="line"><span class="comment">#Script for replace __cplusplus text to some other build directive (__CUSTOM_CPP_DEFINE)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">HEADERS_PATH = <span class="string">"."</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> fname <span class="keyword">in</span> os.listdir(HEADERS_PATH):</span><br><span class="line"><span class="keyword">if</span> os.path.isfile(os.path.join(HEADERS_PATH, fname)) <span class="keyword">and</span> os.path.splitext(fname)[<span class="number">1</span>] != <span class="string">".py"</span>:</span><br><span class="line">print(<span class="string">"Proccessing"</span>, fname)</span><br><span class="line"><span class="keyword">with</span> open(fname, <span class="string">"rt"</span>) <span class="keyword">as</span> f:</span><br><span class="line">lines = f.readlines()</span><br><span class="line">newlines = []</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">newlines.append(line.replace(<span class="string">"__cplusplus"</span>, <span class="string">"__CUSTOM_CPP_DEFINE"</span>))</span><br><span class="line"><span class="keyword">with</span> open(fname, <span class="string">"wt"</span>) <span class="keyword">as</span> f:</span><br><span class="line">f.writelines(newlines)</span><br></pre></td></tr></table></figure><p>Ну и дальше, аналогично инструкции в предыдущем посте:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AssimpGen</span> :</span> CppGenBind</span><br><span class="line">    override func_to_stdout = false</span><br><span class="line">    unique_functions : table&lt;string; bool&gt;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">AssimpGen</span></span></span><br><span class="line">        bind_root = "&#123;get_das_root()&#125;/modules/dasAssimp/src"</span><br><span class="line">        bind_module = <span class="string">"assimp"</span></span><br><span class="line">        bind_das_module = <span class="string">"assimp"</span></span><br><span class="line">        let pfn = <span class="string">"assimp/include_all_import.h"</span></span><br><span class="line">        //<span class="comment"># тут пользуемся сгенерированными сишными заголовочными файлами</span></span><br><span class="line">        let pfp = <span class="string">"&#123;get_das_root()&#125;/modules/dasAssimp/assimp/include_c/"</span> </span><br><span class="line"></span><br><span class="line">        let args &lt;- [&#123;string</span><br><span class="line">            <span class="string">"-xc++-header"</span>;</span><br><span class="line">            <span class="string">"-std=c++1z"</span>;</span><br><span class="line">            <span class="string">"-I&#123;get_full_file_name(pfp)&#125;"</span>;</span><br><span class="line">            <span class="string">"-DSWIG"</span></span><br><span class="line">        &#125;]</span><br></pre></td></tr></table></figure><p>и дописываем функцию преобразования <code>dasString</code> в <code>std::string</code>, чтобы генератор привязок мог понять, как с ней работать</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">das_aiString_to_string</span><span class="params">(aiString* <span class="built_in">string</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">string</span>-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Module_assimp::initMain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">addExtern&lt;DAS_BIND_FUN(das_aiString_to_string)&gt;(*<span class="keyword">this</span>, lib, <span class="string">"assimp_str"</span>,</span><br><span class="line">SideEffects::worstDefault, <span class="string">"das_aiString_to_string"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>После генерации модуля можно попробовать им воспользоваться (предварительно не забыть прилинковать к проекту lib файлы от библиотеки <code>assimp</code> и сделать доступным путь к собранный dll, если ассимп был собран как динамическая библиотека):</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">require assimp</span><br><span class="line">require strings</span><br><span class="line">require daslib/defer</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printNodesHierarchy</span><span class="params">(depth:int; var node:aiNode?&amp;)</span></span></span><br><span class="line"><span class="function">    <span class="title">unsafe</span></span></span><br><span class="line"><span class="function">        <span class="title">print</span><span class="params">(<span class="string">"&#123;repeat("</span>-<span class="string">",depth)&#125;&#123;assimp_str(addr(node.mName))&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function">        <span class="title">for</span> <span class="title">i</span> <span class="title">in</span> <span class="title">range</span><span class="params">(<span class="number">0</span>, int<span class="params">(node.mNumChildren)</span>)</span></span></span><br><span class="line"><span class="function">            <span class="title">printNodesHierarchy</span><span class="params">(depth+<span class="number">1</span>, node.mChildren[i])</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">[<span class="title">export</span>]</span></span><br><span class="line"><span class="function"><span class="title">def</span> <span class="title">main</span></span></span><br><span class="line"><span class="function">    <span class="title">unsafe</span></span></span><br><span class="line">        let path = "character.dae"</span><br><span class="line">        var scene = aiImportFile(path, <span class="number">8</span>u)</span><br><span class="line">        defer &lt;|</span><br><span class="line">            scene |&gt; aiReleaseImport</span><br><span class="line">        </span><br><span class="line">        var mesh = scene.mMeshes</span><br><span class="line">        print(<span class="string">"Meshes: &#123;int(scene.mNumMeshes)&#125;\n"</span>)</span><br><span class="line">        print(<span class="string">"Vertices:&#123;int(mesh[0].mNumVertices)&#125;\n"</span>)</span><br><span class="line">        print(<span class="string">"Faces:&#123;int(mesh[0].mNumFaces)&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line">        var rootNode = scene.mRootNode</span><br><span class="line">        print(<span class="string">"Node hierarchy:\n"</span>)</span><br><span class="line">        printNodesHierarchy(<span class="number">1</span>, rootNode)</span><br></pre></td></tr></table></figure><p>Данный код загружает модель из файла <code>character.dae</code>, и печатает иерархию костей скелета в этой модели:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Meshes: 1</span><br><span class="line">Vertices:14487</span><br><span class="line">Faces:4829</span><br><span class="line">Node hierarchy:</span><br><span class="line">-character.dae</span><br><span class="line">--root</span><br><span class="line">---M_spine_1_joint</span><br><span class="line">----M_spine_2_joint</span><br><span class="line">-----M_spine_3_joint</span><br><span class="line">------M_spine_4_joint</span><br><span class="line">------M_spine_5_joint</span><br><span class="line">-------L_shoulder_joint</span><br><span class="line">--------L_arm_1_joint</span><br><span class="line">---------L_arm_2_joint</span><br><span class="line">...</span><br><span class="line">-------R_leg_4_joint</span><br><span class="line">--------R_leg_5_joint</span><br><span class="line">------R_leg_2_twist_1_joint</span><br><span class="line">-------R_leg_2_twist_2_joint</span><br><span class="line">-----R_leg_1_twist_1_joint</span><br><span class="line">------R_leg_1_twist_2_joint</span><br><span class="line">--body_geo</span><br></pre></td></tr></table></figure></p><p><a href="https://github.com/spiiin/dasClangBind_modules/tree/main/dasAssimp" target="_blank" rel="noopener">Сырой код модуля</a>, когда-нибудь надо будет причесать</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;Продолжени
      
    
    </summary>
    
    
    
      <category term="3d" scheme="http://spiiin.github.io/tags/3d/"/>
    
      <category term="dascript" scheme="http://spiiin.github.io/tags/dascript/"/>
    
  </entry>
  
  <entry>
    <title>daScript: C++ auto-bindings, msgpack</title>
    <link href="http://spiiin.github.io/blog/4090909622/"/>
    <id>http://spiiin.github.io/blog/4090909622/</id>
    <published>2022-05-30T10:36:23.000Z</published>
    <updated>2022-08-01T13:03:26.852Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Ещё один “подход” к языку daScript от Gaijin. В последней заметке про использование <a href="/blog/4232971949/" title="байндингов к OpenGL">байндингов к OpenGL</a> в daScript, я упоминал про наличие скрипта <a href="https://github.com/GaijinEntertainment/daScript/issues/231" target="_blank" rel="noopener">dasClangBind</a>, позволяюшего генерировать байндинги к библиотекам на C и C++. Так как из документации к скрипту только совет автора <code>Use it, abuse it</code>, то неплохо попробовать его в деле, чтобы разобраться, что он умеет/не умеет.</p><p>С помощью этого генератора байндингов сделаны обёртки над: <a href="https://github.com/VasiliyRyabtsev/dasRequests" target="_blank" rel="noopener">dasRequests</a>, <a href="https://github.com/VasiliyRyabtsev/dasPhys2d" target="_blank" rel="noopener">dasPhys2d</a>, а также добавленные в основной репозиторий <strong><code>dasGLFW, dasBGFX, dasImgui, dasOpenGL, dasClangBind</code></strong> (привязки для генератора байндингов тоже сгенерированы им самим).</p><p><code>dasClangBind</code> не собирается с дефолтными настройками cmake, поэтому сначала необходимо включить его сборку. В файле <a href="https://github.com/GaijinEntertainment/daScript/blob/master/modules/dasClangBind/CMakeLists.txt" target="_blank" rel="noopener">CMakeLists.txt</a> видим настройку пути с <code>libclang</code>:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET(PATH_TO_LIBCLANG $&#123;PROJECT_SOURCE_DIR&#125;&#x2F;..&#x2F;libclang)</span><br></pre></td></tr></table></figure></p><p>Можно скачать скомпилированные библиотеки <a href="https://github.com/llvm/llvm-project/releases/tag/llvmorg-14.0.0" target="_blank" rel="noopener">LLVM</a> (yay, даже для windows!), и указать путь к скачанной библиотеке с cmake-файле. Дальше перегенерируем решение с помощью команды <code>generate_msvc_XXX.bat</code> и компилируем проект <code>libDasModuleClangBind</code>.</p><p>Получаем библиотеку <code>libDasModuleClangBind.lib</code>, которую можно подключить для статической линковки из проекта, который будет использовать этот модуль (командой <code>TARGET_LINK_LIBRARIES</code>). В сгенерированном решении убеждаемся в том, что линкер подключает библиотеки <code>libDasModuleClangBind.lib</code> и <code>libclang.lib</code>:<br><img src="/blog/4090909622/lib.png" alt="lib"></p><p>Далее в коде подключаем заголовочный файл и макрос добавления модуля в daScript:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../modules/dasClangBind/src/dasClangBind.h"</span></span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span>, <span class="keyword">char</span> * [] )</span> </span>&#123;</span><br><span class="line">    NEED_ALL_DEFAULT_MODULES;</span><br><span class="line">    NEED_MODULE(Module_dasClangBind); <span class="comment">//&lt;---</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Теперь в das-скрипте можно импортировать модуль <code>cbind</code>, который предоставляет функции-обёртки над библиотекой <code>clang</code>, а главное — <code>cbind_boost</code>, классы, с помощью которых можно настроить поведение генераторы, без низкоуровневого обращения к c-апи clang-а:<br><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">require</span> cbind</span><br><span class="line"><span class="keyword">require</span> cbind_boost</span><br></pre></td></tr></table></figure></p><h2 id="libclang"><a href="#libclang" class="headerlink" title="libclang"></a>libclang</h2><p>Для начала лучше бегло ознакомиться с тем, что умеет <code>libclang</code>:<br><a href="https://shaharmike.com/cpp/libclang/" target="_blank" rel="noopener">Using libclang to Parse C++</a><br><a href="https://habr.com/ru/post/439270/" target="_blank" rel="noopener">Пример разбора C++ кода с помощью libclang на Python</a><br><a href="https://clang.llvm.org/docs/Tooling.html" target="_blank" rel="noopener">Choosing the Right Interface for Your Application</a></p><h2 id="DasGenBind"><a href="#DasGenBind" class="headerlink" title="DasGenBind"></a>DasGenBind</h2><p>У генератор привязок <code>dasClangBind</code>, есть 2 режима: генерация обёрток над функциями в виде daScript (с помощью ffi-интерфейса <code>dasbind</code>) — <code>DasGenBind</code>, и более мощная генерация “обвязочного” c++-кода библиотеки — <code>CppGenBind</code>. С помощью <code>DasGenBind</code> <a href="https://github.com/GaijinEntertainment/daScript/blob/master/modules/dasClangBind/bind/bind_opengl.das" target="_blank" rel="noopener">сгенерированы</a> байндинги к <a href="https://github.com/GaijinEntertainment/daScript/blob/master/modules/dasOpenGL/opengl/opengl_func.das" target="_blank" rel="noopener">OpenGL</a>, так как сама библиотека language-agnostic, и её обвязки тривиальны — используются только функции и примитивные типы.</p><h2 id="CppGenBind"><a href="#CppGenBind" class="headerlink" title="CppGenBind"></a>CppGenBind</h2><p>Более интересно посмотреть на байндинги к <a href="https://github.com/GaijinEntertainment/daScript/blob/master/modules/dasClangBind/bind/bind_glfw.das" target="_blank" rel="noopener">glfw</a>, по которым можно приблизительно понять, что генерируется автоматически, а что необходимо добавлять в исключения и дописывать руками. <code>dasClangBind</code> в ходе своей работы пишет, какие объявляния функций он пропускает (<a href="https://github.com/GaijinEntertainment/daScript/blob/master/modules/dasClangBind/cbind/cbind_boost.das" target="_blank" rel="noopener">код</a> - поиск по ключевому слову <code>skip</code>):</p><ul><li>шаблоны</li><li>функции с аргументами-указателями на функции (к примеру, колбеки)</li><li>чисто виртуальные функции</li><li>глобальные операторы<br>Также генерируются, но вызывают последующие ошибки компиляции, функции (в лучших традициях текстов ошибок шаблонов C++), получающие аргументы POD-типов по значению.</li></ul><p>Для таких функций предполагается добавление их в список пропускаемых при автоматической генерации и последующее написания обработчика вручную:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//переопределение метода AnyGenBind</span></span><br><span class="line"> <span class="function">def <span class="keyword">override</span> <span class="title">skip_anyFunction</span> <span class="params">( var c : CXCursor; isMethod : <span class="keyword">bool</span> )</span></span></span><br><span class="line">        if AnyGenBind`skip_anyFunction(self, c, isMethod)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        <span class="comment">//свои проверки, нужно или нет генерировать обёртку для функции</span></span><br></pre></td></tr></table></figure></p><p>Для дописывания несгенерированных автоматически функций предусмотрен файл <code>MODULENAME.main.cpp</code>. На выходе генератор байндингов выдаёт <a href="https://github.com/borisbat/dasGlfw/tree/48f2715f0fe4cb8076866365a4bf0a29b7104765/src" target="_blank" rel="noopener">пачку</a> и кусок cmake-файла в stdout, с помощью которого можно собрать их в модуль. На практике почему-то у меня не создавались файлы <code>MODULE.func.reg.inc</code> и <code>MODULE.func.decl.,inc</code>, их для теста заполнил руками.</p><h2 id="CmakeList-txt"><a href="#CmakeList-txt" class="headerlink" title="CmakeList.txt"></a>CmakeList.txt</h2><p>В качестве шаблона cmake-файла можно взять готовый из других модулей, основная логика:</p><ul><li>собрать модуль из сгенерированных файлов (это за нас выводит сам <code>dasClangBind</code>)</li><li>подключить lib-файл самой C++ библиотеки, для которой делается обвязка</li><li>определить переменные сборки daScript, позволяющие отключить модуль по желанию пользователя</li></ul><h2 id="Генерация-байндингов-для-библиотеке-MessagePack"><a href="#Генерация-байндингов-для-библиотеке-MessagePack" class="headerlink" title="Генерация байндингов для библиотеке MessagePack"></a>Генерация байндингов для библиотеке MessagePack</h2><p>Исходя из ограничений генератора, для учебного примера проще всего выбрать для примера максимально простую библиотеку, имеющую C, а не С++-интерфейс. Например - <a href="https://github.com/msgpack/msgpack-c/tree/c_master" target="_blank" rel="noopener">MessagePack</a>.</p><p>Стартовый код генератора:</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">require cbind/cbind_boost</span><br><span class="line">require daslib/safe_addr</span><br><span class="line">require daslib/strings</span><br><span class="line">require daslib/defer</span><br><span class="line">require daslib/fio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MsgpackGen</span> :</span> CppGenBind</span><br><span class="line">    override func_to_stdout = false</span><br><span class="line">    unique_functions : table&lt;string; bool&gt;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">MsgpackGen</span></span></span><br><span class="line">        bind_root = "&#123;get_das_root()&#125;/modules/dasMsgpack/src"</span><br><span class="line">        bind_module = <span class="string">"msgpack"</span></span><br><span class="line">        bind_das_module = <span class="string">"msgpack"</span></span><br><span class="line">        let pfn = <span class="string">"msgpack.h"</span></span><br><span class="line">        let pfp = <span class="string">"&#123;get_das_root()&#125;/modules/dasMsgpack/msgpack-c/include/"</span></span><br><span class="line"></span><br><span class="line">        let args &lt;- [&#123;string</span><br><span class="line">            <span class="string">"-xc++-header"</span>;</span><br><span class="line">            <span class="string">"-std=c++1z"</span>;</span><br><span class="line">            <span class="string">"-I&#123;get_full_file_name(pfp)&#125;"</span></span><br><span class="line">        &#125;]</span><br><span class="line"></span><br><span class="line">        func_per_chunk = <span class="number">20</span></span><br><span class="line">        init_args(pfn,pfp,args)</span><br><span class="line">        setDefaultFiles()</span><br><span class="line">        //init_skip_func()</span><br><span class="line">        openAllFiles()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">override</span> <span class="title">namespace_name</span><span class="params">(name:string; dash:string=<span class="string">"::"</span>)</span> :</span> string</span><br><span class="line">        <span class="keyword">return</span> AnyGenBind`namespace_name(self, name, dash)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">override</span> <span class="title">skip_struct</span><span class="params">(name : string)</span></span></span><br><span class="line"><span class="function">        <span class="title">return</span> <span class="title">false</span></span></span><br><span class="line"><span class="function">        //<span class="title">return</span> <span class="title">AnyGenBind</span>`<span class="title">skip_struct</span><span class="params">(name)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">def</span> <span class="title">override</span> <span class="title">skip_anyFunction</span><span class="params">(var c : CXCursor; isMethod:bool)</span> :</span> bool</span><br><span class="line">        let funcname = string(clang_getCursorSpelling(c))</span><br><span class="line">        //не генерировать обвязку для повторно встречаемой функции (не совсем понимаю, почему встречаются повторы)</span><br><span class="line">        <span class="keyword">if</span> unique_functions |&gt; find(funcname) != null</span><br><span class="line">            <span class="keyword">return</span> true</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            unique_functions[funcname] = true</span><br><span class="line">            <span class="keyword">return</span> AnyGenBind`skip_anyFunction(self, c, isMethod)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //генерируем код для файлов, подходящих по шаблону msgpack/*.h</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">override</span> <span class="title">skip_file</span><span class="params">(fname:string)</span> :</span> bool</span><br><span class="line">        <span class="keyword">if</span> fname |&gt; find(<span class="string">"msgpack/"</span>) != <span class="number">-1</span></span><br><span class="line">            <span class="keyword">return</span> false</span><br><span class="line">        <span class="keyword">return</span> ! fname |&gt; ends_with(PARSE_FILE_NAME)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">override</span> <span class="title">generateModuleHPrefix</span></span></span><br><span class="line"><span class="function">        <span class="title">module_h_file</span> |&gt; <span class="title">fwrite</span><span class="params">(<span class="string">"#include \"need_msgpack.h\"\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">[<span class="title">export</span>]</span></span><br><span class="line"><span class="function"><span class="title">def</span> <span class="title">main</span></span></span><br><span class="line">    var cgb = new MsgpackGen()</span><br><span class="line">    defer &lt;|</span><br><span class="line">        unsafe</span><br><span class="line">            delete cgb</span><br><span class="line">    cgb-&gt;generate()</span><br><span class="line">    cgb-&gt;genCMakeDecl("DAS_MSGPACK_BIND")</span><br></pre></td></tr></table></figure><p>Такой скрипт генерирует привязки к библиотеке, однако при её компиляции возникают несколько ошибок вида:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">использование неопределенного типа &quot;das::cast&lt;TT&gt;&quot; libDasModuleMsgpack \daScript\include\daScript\simulate\simulate.h</span><br></pre></td></tr></table></figure></p><p>Необходимо добавить эти функции в список исключаемых из генерации:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;передача в качестве аргумента POD-объекта по значению</span><br><span class="line">msgpack_object_print</span><br><span class="line">msgpack_object_print_buffer</span><br><span class="line">msgpack_object_equal</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;какие-то непонятки с передачей некоторых из базовых типов из C++ в daScript?</span><br><span class="line">msgpack_pack_char</span><br><span class="line">msgpack_pack_long</span><br><span class="line">msgpack_pack_unsigned_long</span><br></pre></td></tr></table></figure></p><p>Убрав их из генерации, получаем компилирующийся модуль daScript <code>dasMsgpack</code>.</p><h2 id="Тестовый-скрипт"><a href="#Тестовый-скрипт" class="headerlink" title="Тестовый скрипт"></a>Тестовый скрипт</h2><p>Попытаемся портировать тестовый <a href="https://github.com/msgpack/msgpack-c/blob/c_master/example/simple_c.c" target="_blank" rel="noopener">пример</a> библиотеки с <code>MessagePack</code> с языка C на daScript:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">require msgpack</span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main</span><br><span class="line">    var sbuf : msgpack_sbuffer</span><br><span class="line">    var pk : msgpack_packer</span><br><span class="line">    var mempool: msgpack_zone</span><br><span class="line">    var deserialized: msgpack_object</span><br><span class="line"></span><br><span class="line">    unsafe</span><br><span class="line">        var ptrBuf = addr(sbuf)</span><br><span class="line">        var ptrPk = addr(pk)</span><br><span class="line">        var ptrMempool = addr(mempool)</span><br><span class="line">        var ptrDeserialized = addr(deserialized)</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* msgpack::sbuffer is a simple buffer implementation. */</span></span><br><span class="line">        msgpack_sbuffer_init(ptrBuf)</span><br><span class="line">        <span class="comment">/* serialize values into the buffer using msgpack_sbuffer_write callback function. */</span></span><br><span class="line">        msgpack_packer_init(ptrPk, ptrBuf)</span><br><span class="line"></span><br><span class="line">        msgpack_pack_array(ptrPk, <span class="number">4u</span>l)</span><br><span class="line">        msgpack_pack_int(ptrPk, <span class="number">1</span>)</span><br><span class="line">        msgpack_pack_true(ptrPk)</span><br><span class="line">        msgpack_pack_float(ptrPk, <span class="number">3.0</span>)</span><br><span class="line">        msgpack_pack_str(ptrPk, <span class="number">7u</span>l)</span><br><span class="line">        msgpack_pack_str_body(ptrPk, <span class="string">"example"</span>, <span class="number">7u</span>l);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//print("&#123;sbuf.data&#125;, &#123;sbuf.size&#125;")</span></span><br><span class="line"></span><br><span class="line">        msgpack_zone_init(ptrMempool, <span class="number">2048u</span>l)</span><br><span class="line"></span><br><span class="line">        var data = <span class="number">0u</span>l;</span><br><span class="line">        var ptrData = addr(data)</span><br><span class="line">        msgpack_unpack(sbuf.data, sbuf.<span class="built_in">size</span>, ptrData, ptrMempool, ptrDeserialized);</span><br><span class="line">        msgpack_object_print(ptrDeserialized);</span><br><span class="line"></span><br><span class="line">        msgpack_zone_destroy(ptrMempool);</span><br><span class="line">        msgpack_sbuffer_destroy(ptrBuf)</span><br></pre></td></tr></table></figure><p>Некоторые функции из примеры не попали в автоматическую обвязку, поэтому необходимо дописать обвязку для них вручную в файле <code>msgpack.main.cpp</code>:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//передаём 3-й параметр по умолчанию</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">das_msgpack_packer_init</span><span class="params">(msgpack_packer* pk, <span class="keyword">void</span>* data)</span> </span>&#123;</span><br><span class="line">msgpack_packer_init(pk, data, msgpack_sbuffer_write);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//передаём параметр по указателю, не по значению</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">das_msgpack_object_print</span><span class="params">(msgpack_object* o)</span> </span>&#123;</span><br><span class="line">msgpack_object_print(<span class="built_in">stdout</span>, *o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//меняем тип второго указателя на const char* вместо неизвестного генератору void *</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">das_msgpack_pack_str_body</span><span class="params">(msgpack_packer* pk, <span class="keyword">const</span> <span class="keyword">char</span>* b, <span class="keyword">size_t</span> l)</span> </span>&#123;</span><br><span class="line">msgpack_pack_str_body(pk, b, l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Module_msgpack::initMain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//добавляем функции в модуль</span></span><br><span class="line">addExtern&lt;DAS_BIND_FUN(das_msgpack_packer_init)&gt;(*<span class="keyword">this</span>,lib,<span class="string">"msgpack_packer_init"</span>,</span><br><span class="line">            SideEffects::worstDefault,<span class="string">"das_msgpack_packer_init"</span>);</span><br><span class="line">addExtern&lt;DAS_BIND_FUN(das_msgpack_object_print)&gt;(*<span class="keyword">this</span>, lib, <span class="string">"msgpack_object_print"</span>,</span><br><span class="line">SideEffects::worstDefault, <span class="string">"das_msgpack_object_print"</span>);</span><br><span class="line">addExtern&lt;DAS_BIND_FUN(das_msgpack_pack_str_body)&gt;(*<span class="keyword">this</span>, lib, <span class="string">"msgpack_pack_str_body"</span>,</span><br><span class="line">SideEffects::worstDefault, <span class="string">"das_msgpack_pack_str_body"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Теперь скрипт работает и выдаёт корректный результат десериализации объекта:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1, true, 3.000000, &quot;example&quot;]</span><br></pre></td></tr></table></figure></p><p>Дальнейшая работа над модулем может предполагать:</p><ul><li>возможность устанавливать daScript колбеки (<a href="https://github.com/borisbat/dasGlfw/blob/48f2715f0fe4cb8076866365a4bf0a29b7104765/src/cb_dasGLFW.h" target="_blank" rel="noopener">пример из dasGlfw</a>)</li><li>daScript-обвязка над POD-структурой msgpack_object и корректная передача исключенных типов(?)</li><li>написание “daScript-ивизирующей” обёртки msgpack_boost, для перехода от с-апи к более удобной работы с библиотекой</li></ul><p><a href="https://github.com/spiiin/dasClangBind_modules" target="_blank" rel="noopener">Репозиторий с примерами кода</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;Ещё один “
      
    
    </summary>
    
    
    
      <category term="dascript" scheme="http://spiiin.github.io/tags/dascript/"/>
    
  </entry>
  
  <entry>
    <title>Хорошие качества программистов</title>
    <link href="http://spiiin.github.io/blog/1257365288/"/>
    <id>http://spiiin.github.io/blog/1257365288/</id>
    <published>2022-05-23T12:00:48.000Z</published>
    <updated>2022-08-01T11:27:21.104Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Качества программистов, которые мне нравятся:</p><ul><li>умение держать в голове большое количество информации</li><li>понимание, как использовать язык программирования в своих целях</li><li>умение решать задачу минимальным количеством изменений в коде</li><li>умение искать причины трудновоспроизводимых багов</li><li>слежение за качеством кодовой базы</li><li>умение ставить эксперименты</li><li>любовь к “тинкерингу”</li><li>умение довести решение сложной задачи до конца</li></ul><a id="more"></a><h2 id="Умение-держать-в-голове-большое-количество-информации"><a href="#Умение-держать-в-голове-большое-количество-информации" class="headerlink" title="Умение держать в голове большое количество информации"></a>Умение держать в голове большое количество информации</h2><p><img src="/blog/1257365288/demoman.png" alt="demoman"><br>Часто в большом проекте приходится переключаться между разными контекстами (исправление багов в различных подсистемах на разных уровнях, участие в обсуждениях будущих фич, базовое слежение за тем, что вообще происходит во всём проекте). Также это умение связано с навыками пользоваться системами структурирования информации — за осознанием, как мало на самом деле можно удерживать информации в голове (по сравнению с потоком информации в проекте), следует желание найти и пользоваться удобной системой задач, организовывать и расшаривать информацию, оптимизировать потоки информации там, где ощущается бардак. То есть, вытащить контекст из головы, и создать “паутину” вспомогательной информации, в которой можно будет найти то, что забылось.</p><p>Также связано с умением распространять информацию — рассказывать о том, как пользоваться готовыми решениями, реагировать на то, как используют библиотеку, документировать код. Другой связанный навык — упрощение работы с большим количеством информации путём автоматизации каких-либо процессов (не нужно знать о том, что обязательно запустить скрипт, если он запускается по расписанию сам).</p><h2 id="Понимание-как-использовать-язык-программирования-в-своих-целях"><a href="#Понимание-как-использовать-язык-программирования-в-своих-целях" class="headerlink" title="Понимание, как использовать язык программирования в своих целях"></a>Понимание, как использовать язык программирования в своих целях</h2><p><img src="/blog/1257365288/soldier.png" alt="soldier"><br>Каждый язык программирования имеет свои плюсы и минусы. Часто о них не говорят, но принимают как должное вместе с языком (библиотекой, фреймворком, движком). Минусы языка могут быть не абсолютными, а проявляться только при использовании языка в определенной области — при решении определенного типа задач, для которых определенные свойства языка становятся критичными.</p><p>Например, требование к скорости выполнения программ при разработке игр. Вот <a href="https://aras-p.info/blog/2009/11/14/improving-cmono-for-games/" target="_blank" rel="noopener">рассуждения</a> о недостатках C# в качестве языка для описания игровой логики и способов борьбы с этими ограничениями — как обойти минусы языка и платформы, чтобы воспользоваться его преимуществами, что было сделано в <code>Unity</code>. Если оценивать язык и пользоваться им только “как принято” и “как пишут в книжках”, то можно просто пропустить то, что возможно сделать с его помощью.</p><p>Хорошее понимание особенностей предметной области позволяет формулировать цели, с которыми можно подходить к выбору языков. Часто целью самого языка или фреймворка является стать “дефолтным выбором” в определенной нише, для тех, кто не задумывается о своих целях. Это может стать опасным в случаях, когда от инструмента автоматически ожидают, что его использование приведёт к тому, что продукт автоматически будет обладать нужными свойствами. За тем, чтобы желаемое свойство не потерялось, нужно следить, никакой язык не будет делать это за вас. Возможность писать быстрый код обеспечивает не язык, а понимание, как писать быстрый код (возможно, отличающиеся для различных языков).</p><p>Чем осознанние цель, с которой выбираешь инструмент, тем проще его выбрать (или даже решиться допилить в своих нуждах), а также отбросить/исправить/запретить “мусорные” вещи, которые, мешают достижению поставленной цели, и не заниматься вещами, которые никак не относятся к поставленным целям.</p><p>Интересный ретроспективный <a href="https://youtu.be/KxQpDIKwGUw" target="_blank" rel="noopener">доклад</a> от <code>Wargaming</code> про выбор движка <code>BigWorld</code> для танков с рассуждениями о важности понимания целей выбора технологии (5-я минута, оценка качеств движка на рынке).</p><h2 id="Умение-решать-задачу-минимальным-количеством-изменений-в-коде"><a href="#Умение-решать-задачу-минимальным-количеством-изменений-в-коде" class="headerlink" title="Умение решать задачу минимальным количеством изменений в коде"></a>Умение решать задачу минимальным количеством изменений в коде</h2><p><img src="/blog/1257365288/spy.png" alt="spy"><br>Первый уровень данного качества — банальное понимание, что количество возможных багов пропорционально количеству измененных строк, больше шанс “зацепить” что-то не относящееся к решаемой задачи, сложнее процесс чтения кода. Во многих гайдах к написанию коду в существующие проекты одним из первых упоминается правило — “старайтесь писать код, используя тот стиль, который уже используется, даже если он противоречит другим правилам”.</p><p>Менее очевидна корреляция небольшого количества изменений с тем, насколько решение вписывается в общую архитектуру системы. Меньшее количество строк также связано с тем, что используется более высокий уровень абстракции, решение собрано из высокоуровневых примитивов, и не дублирует/переделывает существующий код.</p><p>Так что желание решать задачу теми средствами, которые уже есть, стимулирует искать и создавать такие инструменты, которые расширяются и комбинируются между собой. Это важнее на более высоких уровнях астракции — легко увидеть код, который дублирует функционал стандартной библиотеки или какую-нибудь мелкую функцию-хелпер, но сложнее заметить, что не нужно писать целый редактор с нуля там, где есть почти готовый, который можно допилить под себя.</p><h2 id="Умение-искать-причины-трудновоспроизводимых-багов"><a href="#Умение-искать-причины-трудновоспроизводимых-багов" class="headerlink" title="Умение искать причины трудновоспроизводимых багов"></a>Умение искать причины трудновоспроизводимых багов</h2><p><img src="/blog/1257365288/sniper.png" alt="sniper"><br>Под слоем логики современной игры лежит множество других, которые являются для неё чёрным ящиком — код движка, вызовы функций операционной системы, обращение с сервером, слой графического API, взаимодействие множества 3rdParty библиотек, код которых также может обновляться по сети через пакетные менеджеры, особенности компилятора и реализаций стандартной библиотеки, особенности железа. Связи в собственном коде отследить просто, но какое-нибудь хитрое взаимодействие API между собой, без возможности посмотреть, что под капотом у этого API (относительно простой <a href="https://aras-p.info/blog/2007/07/25/can-you-set-opengl-states-independently/" target="_blank" rel="noopener">пример</a> с opengl) — отдельное искусство, которое иногда основывающется на рассуждениях “как бы я реализовал это, будь я разработчиком библиотеки” или на информации о похожих ошибках, собранной по крупицам из разных мест (в хорошем случае — прямым вопросом авторам библиотеки, в плохом — “о, это уже ломалось у них 3 версии назад, снова сломали”).</p><p>Хорошо развитый навык поиска таких ошибок развивает умение писать самому максимально простой код, который с наименьшей вероятностью создаст ошибки, которые трудно обнаружить.<br><a href="/blog/1807815468/" title="Философия поиска ошибок">Философия поиска ошибок</a> — более развёрнутое описание этой связи.</p><p>Пример сложных в решении багов — исправление ANR для мобильных приложений, <a href="https://blog.embrace.io/solve-anrs-with-flame-graphs/" target="_blank" rel="noopener">заметка</a> о причинах сложностей, и описание альтернативного подхода к поиску.</p><h2 id="Слежение-за-качеством-кодовой-базы"><a href="#Слежение-за-качеством-кодовой-базы" class="headerlink" title="Слежение за качеством кодовой базы"></a>Слежение за качеством кодовой базы</h2><p><img src="/blog/1257365288/pyro.png" alt="pyro"><br><a href="https://cs8.pikabu.ru/images/big_size_comm_an/2016-04_4/146100495418031426.webm" target="_blank" rel="noopener">Пуш в мастер.gif</a><br>Качество, которое, кажется, практически невозможно привить, и сложно организовать через рабочие процессы и постановку задач. Либо человек проходит мимо “грязи” в кодовой базе спокойно, либо раздражается, до тех пор, пока не решит исправить. Ответственность за качество кода зависит а от желания работать в комфорте, а не от уровня отвественности или способностей программиста.<br><a href="/blog/1363625753/" title="Мотивация честного программиста">Мотивация честного программиста</a> — повышение качества кода связано с желанием работать в комфортных условиях.</p><h2 id="Умение-ставить-эксперименты"><a href="#Умение-ставить-эксперименты" class="headerlink" title="Умение ставить эксперименты"></a>Умение ставить эксперименты</h2><p><img src="/blog/1257365288/medic.png" alt="medic"><br>Сильно коррелирует с обязательно необходимыми для каждого программиста навыками — умением проверить, надёжно ли работает собственный код, выявить причину ошибки. Код, написанный для эксперимента, вполне может оставаться реюзабельным для регрессивных тестов, или упрощения проверки различных сценариев.</p><p>Особенно необходимо для реализации различных оптимизаций в коде — есть много теоретически работающих трюков, которые не работают на практике. Для отдельных замеров необходимо написание кода, который в несколько раз по объёму больше, чем сам проверяемый код, или написание отдельных программ, позволяющих изучить качества кода, не проверяемые стандартными средствами.<br><a href="/blog/854775037/" title="Расположение объектов C++ в памяти">Расположение объектов C++ в памяти</a> — способы увидеть расположение объектов C++ классов в памяти, с целью улучшения cache locality.</p><p>В более общем случае умение ставить эксперименты позволяет организовать проверки гипотез о продукте — элемент <a href="/blog/2486671624/" title="Lean Development">Lean Development</a>.</p><h2 id="Любовь-к-тинкерингу"><a href="#Любовь-к-тинкерингу" class="headerlink" title="Любовь к тинкерингу"></a>Любовь к тинкерингу</h2><p><img src="/blog/1257365288/engineer.png" alt="engineer"><br>“Тинкерить” — мастерить что-то, изучать, хакать, исследование без особой цели. Попробовать поиграться с новым движком, изучить новый алгоритм или библиотеку. Часто в таком случайном изобретении приобретается полезная экспертиза, на стыке дисциплин можно найти интересные и необычные идеи, нестандартные способы решения задач.</p><p><a href="/blog/2537188794/" title="Прототипирование в геймдеве">Прототипирование в геймдеве</a> — возможно, результат тинкеринга станет прототипом большого проекта. <a href="https://www.igromania.ru/article/31609/Istoriya_Minecraft_i_eyo_sozdatelya._Kto_i_kogda_sdelal_legendarnuyu_igru.html" target="_blank" rel="noopener">Майнкрафт</a> тоже начинался с тинкеринга с воксельной песочницей.</p><h2 id="Умение-довести-решение-сложной-задачи-до-конца"><a href="#Умение-довести-решение-сложной-задачи-до-конца" class="headerlink" title="Умение довести решение сложной задачи до конца"></a>Умение довести решение сложной задачи до конца</h2><p><img src="/blog/1257365288/scout.png" alt="scout"><br>Есть два типа программистов, которые не могут справиться с задачей — те, у которых код настолько плох, что его дольше исправлять, чем написать заново (чаще всего в попытках внести в него улучшения, ломают то, что уже “залатали” во время предыдущего этапа исправлений, исправления никогда не “сходятся” к нормальному решению) и те, которые вообще не понимают, что от них хотят. Никаких уточняющих вопросов или чернового варианта решения дождаться от них невозможно, а в перед дед-лайном наступает какая-нибудь катастрофа, которая уничтожает их решение, существующее только на их машине. Бывают ещё программисты, которые делают часть работы, но не заканчивают её по каким-либо причинам, не хватает фантазии, инициативы, желания связать созданные части в одно целое. В этом случае чаще всего их код не собирается и требует для проверки внесения в него изменений проверяющим.</p><p>В хороших случаях человек способен сам разобраться с тем, чтобы задать уточняющие вопросы и найти того, кто может помочь с решением. В особо хороших случаях — при невозможности  найти полноценное решение, может придумать и реализовать частичное, с пометками, что в нём можно улучшить. В самых хороших — проявить дальнейшую инициативу по поиску ресурсов для полноценного решения.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Качества программистов, которые мне нравятся:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;умение держать в голове большое количество информации&lt;/li&gt;
&lt;li&gt;понимание, как использовать язык программирования в своих целях&lt;/li&gt;
&lt;li&gt;умение решать задачу минимальным количеством изменений в коде&lt;/li&gt;
&lt;li&gt;умение искать причины трудновоспроизводимых багов&lt;/li&gt;
&lt;li&gt;слежение за качеством кодовой базы&lt;/li&gt;
&lt;li&gt;умение ставить эксперименты&lt;/li&gt;
&lt;li&gt;любовь к “тинкерингу”&lt;/li&gt;
&lt;li&gt;умение довести решение сложной задачи до конца&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="dev_evolution" scheme="http://spiiin.github.io/tags/dev-evolution/"/>
    
  </entry>
  
  <entry>
    <title>Города, которые мы выбираем</title>
    <link href="http://spiiin.github.io/blog/1152742413/"/>
    <id>http://spiiin.github.io/blog/1152742413/</id>
    <published>2022-05-09T20:28:27.000Z</published>
    <updated>2022-05-14T12:24:11.728Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Пол Грем в своих статьях <a href="http://paulgraham.com/cities.html" target="_blank" rel="noopener">Cities and Ambition</a> и <a href="http://www.paulgraham.com/gh.html" target="_blank" rel="noopener">Great Hackers</a> (легко ищутся на русском) развёрнуто рассказывает о том, что города определяют образ мышления людей. Города посылают <a href="/blog/649/" title="сообщения">сообщения</a>, можно научиться слушать их и расшифровывать.</p><p>Сообщения эти выражаются в качестве разговоров, которые слышишь вокруг, в потоке поступающей информации. Разговоры за соседними столами в кафе, бизнес-ланч с коллегами, подсмотренная история вечером в окне чьей-то квартиры, ссора соседей за стеной, сцена в электричке, радио в такси, билборд на улице, баннер на сайте или рекомендуемая новость в соцсети (которые тоже зависят от твоей геолокации). Это не что-то, что нужно специально искать, а скорее информация, от которой невозможно уклониться — город говорит тебе, что хочет, чтобы ты делал. Какие-то города тихо нашептывают тебе свои идеи, какие-то кричат так, что становится страшно. Важно понять, что эти сообщения воспринимаются как собственные мысли (ведь если у тебя в голове чужие голоса и мысли — то ты не совсем нормальный, так?).</p><p>Город — не какая-то мистическая сущность, а <code>&quot;масса людей + среда их обитания&quot;</code>. В современном мире “городом” может быть и более маленькая или большая структура. Кембридж — часть города, Кремниевая Долина — не город совсем, какой-нибудь специфический офис крупной компании вполне может быть отдельным пространством, формирующим мышление сотрудников.</p><p>Некоторые игровые студии умеют работать с пространством офиса. Valve использует столы на колесиках — можно переместиться в другой кабинет, и внутренний сайт, который отображает местонахождение сотрудника, за счет чего возможны различные конфигурации потоков информации между сотрудниками необходимыми для эффективной работы в текущий момент. Джесси Шелл рассказывает о том, что структура игровой студии зависит от того, каким образом распространяется информация, а это зависит в том числе от структуры офиса, ссылаясь на “Язык шаблонов” Кристофера Александера.<br><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/y92-vkyHKbY" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></p><p>Вот <a href="https://youtu.be/-zRaFJHK0S4?t=1355" target="_blank" rel="noopener">таймкод</a> из второго его доклада (лучше смотреть весь). Если объединить эту информацию и <a href="https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%BA%D0%BE%D0%BD_%D0%9A%D0%BE%D0%BD%D0%B2%D0%B5%D1%8F" target="_blank" rel="noopener">Закон Конвея</a>, можно сказать, что структура пространства определяет не только структуру компании, но и продукты, которые она производит.</p><p>В снг-шном обществе программистов (не знаю, как в других), как-то принято считать, что профессиональное развитие зависит в первую очередь от самого специалиста, а не от его окружения (офиса+коллег, города+граждан вокруг).</p><p>С начала года ощутил для себя нехватку <em>чего-то</em>, что было при работе в офисе, но потерялось при работе из дома. Собрал немного <a href="https://vas3k.club/post/11435/" target="_blank" rel="noopener">фоток и историй</a> (пост закрытый, чтобы людям проще было откровенничать с историями — это намного важнее картинок) про особенности офисов айтишников — что именно ценят люди в офисах, что им запоминается, влияет на их настроение, работоспособность. И самое главное — отделить мух от котлет, а точнее печеньки и плюшки для заманивания работников, от того, что реально помогает работать.</p><p><img src="/blog/1152742413/of1_small.png" alt="of1"><br><img src="/blog/1152742413/of2_small.png" alt="of2"><br><img src="/blog/1152742413/of3_small.png" alt="of3"></p><p>Я вижу необходимость наличия офиса как пространства для разработки игр в том, чтобы существовала среда общения и среда отдыха.</p><h2 id="Среда-общения"><a href="#Среда-общения" class="headerlink" title="Среда общения"></a>Среда общения</h2><p>Разработка игр — творческий процесс. Игры как медиа передают что-то игроку. Гейм-дизайнер через эстетику хочет вызвать какие-то чувства. К примеру, последняя игра, которую я проходил, <code>Divinity: Original Sin 2</code>,  по жанру вроде как тактическая рпг и про передвижение “пешек” по полю и механику. Но при этом я иногда удивлялся, что некоторые локации вызывают желание рассматривать их под разными углами и любоваться — видовая лавочка рядом с кладбищем с плакучей ивой, на которой хочется посидеть и подумать, или лежанка, на которую можно взобраться по лестнице в подземной таверна в Дрифтвуда с курящим друдену ящером, заставляющая задуматься о том, что ему там находиться должно быть очень уютно. Чтобы передать это ощущение, нужно взаимодействие нескольких человек, пробы и попытки. Нельзя просто описать задачу и ждать результата, живое взаимодействие и общение может привести к нахождению способа задать нужное “настроение” игры.</p><p>Это один из элементов магии игр — возможность разработчику или дизайнеру передать в игре что-то, что он пережил и прочувствовал сам. А между желанием передать какое-то чувство и ощущение, и геймплеем, который вызовет это ощущение у игрока, лежит общение между людьми, которые делают игру. Чем сложнее и глубже ощущение, которое хочет создать команда разработчиков, тем более выразительным должно быть общение в команде. Удаленное взаимодействие здесь сильно проигрывает живому. Инженеры также сталкиваются с задачами, требующими творческого подхода — задачи с серьёзными техническими ограничениями, или такие, которые до них не решал никто, просто описывать такие задачи не так красочно, как задачи артистов/геймдизайнеров.</p><p>С этой точки зрения игра создаёт для игрока целый мир, в котором он может испытать что-то новое, пережить фантастическую историю, задуматься о чём-то, возможно в исключительных случаях даже решиться жить так, как хочется на самом деле.</p><p>Если стараться делать игры так, то кроме взаимодействия команды, необходимо еще и постоянное стремление к развитию себя и команды, желание делать последующие игры круче предыдущих (“Ведьмак 3” был бы невозможен без “Ведьмака 2” и “Ведьмака 1”), общаться, чтобы 1) находить ядро команды, которое способно делать следующую игру масштабнее и сложнее предыдущих, и находить идеи таких игр 2) создавать инструменты такого качества, чтобы их можно было реюзать в следующих проектах 3) делать текущие игры такого качества, чтобы получить ресурсы для разработки более продвинутых следующих игр. “Найти коннект” намного проще в живом общении, чем в удаленном, как и обмениваться идеями и информацией.</p><p>Если не стараться — уровень формулирования задач будет на уровне “делаем как у конкурентов, у них то как-то работает”. Либо же вообще без формулирования задач внутри команды — слепой набор исполнителей поставленных извне задач.</p><p>Высококлассным специалистам больше хочется работать над интересными и сложными задачами в группе таких же высококлассных специалистов. Во-первых, можно обмениваться опытом, во-вторых, легче получить признание своих заслуг от коллег, в-третьих, суммарный результат за единицу времени будет выше, если все в группе приносят больше условной пользы продукту. А узнать, что специалист высококлассный, при живом общении намного быстрее — легче отделить “сигнал” от “шума” (этот пункт актуальнее в больших или растущих командах, когда ядро формируется в существующей команде, а не на этапе найма новых сотрудников).</p><h2 id="Среда-отдыха"><a href="#Среда-отдыха" class="headerlink" title="Среда отдыха"></a>Среда отдыха</h2><p>Для продуктивной работы необходимо переключать состояния сосредоточения и расслабления. Сосредоточенно работать удобно из дома, а вот организовать периоды отдыха сложнее (отвлекают бытовые дела, семья - требуется смена места, которую в доме или квартире организовать сложнее, плюс надо приложить усилия, чтобы вытолкнуть себя из работы в эту зону). В офисе организовать режим и распорядок проще, а главное, проще вернуть смещенный или сбитый режим обратно — дома отсутствует ритм-ориентир, под который можно подстроиться.</p><p>Профессиональное общение с коллегами — тоже важная часть отдыха.</p><p>Ключевые моменты комфортной творческой работы для меня — свобода общения и исследования, и полноценный отдых. Там, где есть тревога, страх, запреты — не будет творчества. Там, где постоянно нужно думать о том, чтобы не нарушить какой-нибудь запрет, не остаётся времени думать о чём-то другом. Все равно, что пытаться ехать, не сняв машину с ручного тормоза. В 2020 многие остались из-за пандемии без комфортного офиса, в 2022 — из-за войны и связанных с ней рисков переместились из своих городов в другие. Сложно угадать, где будут “комфортные для геймдева города” теперь, но точно вне России. Сейчас там города говорят совсем о другом.Очень сложно переучиться в выборе с оценки ситуации “что есть сейчас” на оценку “что будет через несколько месяцев/лет”.</p><p>Кроме внешнего распорядка, для решения по настоящему сложных задач необходима возможность отдохнуть и отвлечься — интересная прогулка по окрестностям, место где можно спокойно посидеть или полежать, или какая-нибудь физическая активность, прогулка к водоему, возможность поиграть с собакой, повисеть на турнике, послушать живую музыку, заняться чем-то максимально отвлеченным (<a href="https://xkcd.ru/230/" target="_blank" rel="noopener">xkcd</a> на тему важности переключения).</p><p> Творческая часть работы — это где-то процентов 10 от общего времени, остальные 90% — это попытки понять, почему что-то работает не так, как задумано, и исправление ошибок. Такая работа даже сильнее требует возможности отдохнуть и отвлечься.</p><h2 id="Источники-вдохновения"><a href="#Источники-вдохновения" class="headerlink" title="Источники вдохновения"></a>Источники вдохновения</h2><p>Грег Костикян в статье <a href="http://www.costik.com/vidiot.html" target="_blank" rel="noopener">“Don’t be a vidiot”</a> (<a href="http://aushestov.ru/%D0%BD%D0%B5-%D0%B1%D1%83%D0%B4%D1%8C-%D0%B2%D0%B8%D0%B4%D0%B8%D0%BE%D1%82%D0%BE%D0%BC-%D0%B8%D0%BB%D0%B8-%D1%87%D0%B5%D0%BC%D1%83-%D0%B4%D0%B8%D0%B7%D0%B0%D0%B9%D0%BD%D0%B5%D1%80-%D0%BA%D0%BE%D0%BC/" target="_blank" rel="noopener">перевод</a>) в качестве поиска источников вдохновения рекомендует не останавливаться на видеоиграх, а исследовать другие области развлечений — настольные игры, варгеймы, ролевые и коллекционнык карточные игры, а также LARP-ы. Я бы добавил еще тематические развлекательные фестивали, комиконы, технологические фестивали, геймдев конференции, подобные бёрнинг-мэну мероприятия, парки развлечений, квест-румы, городские квесты, спортивные и киберспортивные шоу, внедорожное ориентирование (трофи-рейд). Часть из них можно найти локально, чтобы поучаствовать в других — нужно путешествовать. В этом плане главное — предолеть границы стран и языковые барьеры. Т.е. удобство путешествий и доступность таких развлечений вокруг может быть фактором для комфортной работы в городе.</p><h2 id="Рациональные-и-нерациональные-мотивы-выбора-места-работы"><a href="#Рациональные-и-нерациональные-мотивы-выбора-места-работы" class="headerlink" title="Рациональные и нерациональные мотивы выбора места работы"></a>Рациональные и нерациональные мотивы выбора места работы</h2><p>Все перечисленные мотивы выбора места для работы и жизни — от людей, ориентирующихся на профессиональный рост и возможности реализации своего потенциала, для таких же, как и они. Часто выбор проще и прагматичнее — где больше платят и заманчивее бонусы-печеньки, где больше востребованность специалиста, и где больше шансы, что бизнес останется прибыльным. Еще один тип гирек на весах выбора, это банальная привязанность к месту — дом, семья, иногда страх нового, или просто невозможность свободно выбирать, и иногда такие гирьки перевешивают всё остальное. Но если кажется, что никаких весов и выбора нет — значит, возможно, что кто-то спрятал от вас саму возможность, обманул, напугал, и сделал выбор за вас.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;Пол Грем в
      
    
    </summary>
    
    
    
      <category term="log" scheme="http://spiiin.github.io/tags/log/"/>
    
      <category term="tales" scheme="http://spiiin.github.io/tags/tales/"/>
    
      <category term="gamedev" scheme="http://spiiin.github.io/tags/gamedev/"/>
    
  </entry>
  
  <entry>
    <title>daScript ссылки</title>
    <link href="http://spiiin.github.io/blog/2371214813/"/>
    <id>http://spiiin.github.io/blog/2371214813/</id>
    <published>2022-02-23T13:07:49.000Z</published>
    <updated>2022-08-01T13:03:40.058Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Ссылки по библиотекам и примерам на daScript</p><a id="more"></a><p><a href="https://github.com/imp5imp5/dasbox" target="_blank" rel="noopener">dasbox</a> - среда для создания простых 2d-игр, <a href="https://www.youtube.com/playlist?list=PL6Ke-5R5eg2I7oVLR7TJIT5Q0ikGecVrT" target="_blank" rel="noopener">видео</a><br><a href="https://vk.com/gaijinjam" target="_blank" rel="noopener">gaijinjam</a> - группа вк, посвященная хакатону на daScript<br><a href="https://github.com/imp5imp5/daScript-plugin" target="_blank" rel="noopener">daScript language plugin</a> - плагин для работы с языком в VS code - отладчик, автокомплит кода, go to definition, подсветка etc<br><a href="https://github.com/olegus8/dasBinder" target="_blank" rel="noopener">dasBinder</a> - генератор байндингов в библиотекам на C</p><p>Модули<br><a href="https://github.com/VasiliyRyabtsev/dasCurl" target="_blank" rel="noopener">dasCurl</a> - байндинги и libcurl<br><a href="https://github.com/VasiliyRyabtsev/dasRequests" target="_blank" rel="noopener">dasRequests</a> - сгенерированная обёртка над curl<br><a href="https://github.com/VasiliyRyabtsev/dasPhys2d" target="_blank" rel="noopener">dasPhys2d</a> - сгенерированные байндинги к box2d<br><a href="https://github.com/olegus8/dasVulkan" target="_blank" rel="noopener">dasVulkan</a> - байндинги к Vulkan<br><a href="https://github.com/profelis/das-web" target="_blank" rel="noopener">das-web</a> - работа с сетью<br><a href="https://github.com/profelis/das-web-samples" target="_blank" rel="noopener">das-web-samples</a> - примеры работы с web<br><a href="https://github.com/profelis/das-test" target="_blank" rel="noopener">das-test</a> - testing framework</p><p>Примеры игр<br><a href="https://github.com/RikiChiki/asteroids" target="_blank" rel="noopener">asteroids</a> - клон игры с Atari<br><a href="https://github.com/AndreiPotapov/dasbox_survival_game" target="_blank" rel="noopener">survival</a> - survival game<br><a href="https://github.com/antonnikvl/DasTetris" target="_blank" rel="noopener">dastetris</a> - тетрис на daScript<br><a href="https://github.com/perneky/ikplus" target="_blank" rel="noopener">ikplus</a> - клон игры International Karate<br><a href="https://github.com/VasiliyRyabtsev/dasSokoban" target="_blank" rel="noopener">dasSocoban</a> - клон Sokoban<br><a href="https://github.com/RobertNagy1978/Wolfenstein3D/blob/main/Wolfenstein3D.das" target="_blank" rel="noopener">wolfenstein3d</a> - клон wolfenstein<br><a href="https://github.com/hpotamus/igger" target="_blank" rel="noopener">igger</a> - клон Digger<br><a href="https://github.com/kopariadam/LabyrinthThingy" target="_blank" rel="noopener">LabyrinthThingy</a><br><a href="https://github.com/Timai/dalaga" target="_blank" rel="noopener">dalaga</a><br><a href="https://github.com/BADxDI/dasTowerDefens" target="_blank" rel="noopener">dasTowerDefence</a><br><a href="https://github.com/IgnatVopilov/DAgario" target="_blank" rel="noopener">dasAgarIo</a><br><a href="https://github.com/AndreyMironenko/adventure-dascript" target="_blank" rel="noopener">adventureDaScript</a><br><a href="https://github.com/dmitrinosov/space-pressure-2d" target="_blank" rel="noopener">space-pressure-2s</a><br><a href="https://github.com/Thibaut-Fervenca/DaDefense" target="_blank" rel="noopener">DaDefense</a><br><a href="https://github.com/vmaluhin/battlecity" target="_blank" rel="noopener">battle city</a><br><a href="https://github.com/khupjan/WormsIn2daysPrototype" target="_blank" rel="noopener">worms2d</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Ссылки по библиотекам и примерам на daScript&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="dascript" scheme="http://spiiin.github.io/tags/dascript/"/>
    
  </entry>
  
  <entry>
    <title>daScript OpenGL</title>
    <link href="http://spiiin.github.io/blog/4232971949/"/>
    <id>http://spiiin.github.io/blog/4232971949/</id>
    <published>2022-02-20T15:45:39.000Z</published>
    <updated>2022-08-01T13:03:47.363Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Пример использования байдингов OpenGL для языка daScript<br><a id="more"></a></p><p>Попробовал разобраться с использованием байндингов библиотек к языку daScript. В качестве тестовой задачки решил портировать на daScript + OpenGL <a href="https://github.com/bkaradzic/bgfx/issues/1857" target="_blank" rel="noopener">эту демку</a>. Программа реализует алгоритм клиппинга модели несколькими плоскостями, с заполненнием отрезанных частей “крышками”, чтобы не было видно внутренней поверхности модели (<a href="https://github.com/daign/clipping-with-caps/blob/master/screenshot_01.png" target="_blank" rel="noopener">скрин</a>).</p><p>Алгоритм:</p><ul><li>Отрисовать модель с шейдером отсечения (с “дырками”)</li><li>Заполнить буфер трафарета значениями так, чтобы пометить пиксели, которые нужно закрыть:<br>— Отрисовать внутреннюю сторону модели, увеличивая значение в буфере трафарета<br>— Отрисовать внешнюю сторону модели, уменьшая значение в буфере трафарета<br>— Заполнять буфер трафарета в только в точках, в которых плоскость отсечения повернута к камере (для корректной работы нескольких плоскостей отсечения одновременно)</li><li>Отрисовать плоскости отсечения по полученной маске (получаются закрывающие “крышки”)</li></ul><h2 id="Каркас-приложения"><a href="#Каркас-приложения" class="headerlink" title="Каркас приложения"></a>Каркас приложения</h2><p>Для создания байндингов библиотек к daScript используется <a href="https://github.com/GaijinEntertainment/daScript/issues/231" target="_blank" rel="noopener">dasClangBind</a>, с помощью которого сделаны обёртки для <a href="https://github.com/GaijinEntertainment/daScript/tree/master/modules" target="_blank" rel="noopener">нескольких</a> библиотек, включая OpenGL. Последний из <a href="https://github.com/GaijinEntertainment/daScript/blob/master/modules/dasOpenGL/examples/09_hello_mesh.das" target="_blank" rel="noopener">примеров</a> демонстрирует загрузку и отображение модели из obj-файла. Этот пример можно взять за основу. Для задания настроек отсекающих плоскостей можно взять байндинг к <a href="https://github.com/borisbat/dasImgui/" target="_blank" rel="noopener">imgui</a>.</p><p>Эти модули также тащат за собой <code>glfw</code> для создания окна и <code>stbImage</code>. Шаблон C++ кода для подключения модулей:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../modules/dasGlfw/src/dasGLFW.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../modules/dasImgui/src/dasIMGUI.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../modules/dasStbImage/src/dasStbImage.h"</span></span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span>, <span class="keyword">char</span> * [] )</span> </span>&#123;</span><br><span class="line">    NEED_ALL_DEFAULT_MODULES;</span><br><span class="line">    NEED_MODULE(Module_dasGLFW)</span><br><span class="line">    NEED_MODULE(Module_StbImage)</span><br><span class="line">    NEED_MODULE(Module_dasIMGUI)</span><br><span class="line">    NEED_MODULE(Module_imgui_app)</span><br><span class="line">    Module::Initialize();</span><br><span class="line">    tutorial();</span><br><span class="line">    Module::Shutdown();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Пустое окно на glfw + imgui можно создать так:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">imgui_app</span><span class="params">(title:<span class="built_in">string</span>; blk : block)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">if</span> <span class="title">glfwInit</span><span class="params">()</span></span>==<span class="number">0</span></span><br><span class="line">panic(<span class="string">"can't init glfw"</span>)</span><br><span class="line">    defer &lt;|</span><br><span class="line">        glfwTerminate()</span><br><span class="line">    glfwInitOpenGL(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line">    var window = glfwCreateWindow(<span class="number">1280</span>, <span class="number">720</span>, <span class="string">"OpenGL - Hello shader clipping"</span>, null, null)</span><br><span class="line">    <span class="keyword">if</span> window==null</span><br><span class="line">panic(<span class="string">"can't create window"</span>)</span><br><span class="line">    defer &lt;|</span><br><span class="line">        glfwDestroyWindow(window)</span><br><span class="line">    glfwMakeContextCurrent(window)</span><br><span class="line"></span><br><span class="line">    CreateContext(null)</span><br><span class="line">    var io &amp; = unsafe(GetIO())</span><br><span class="line">    StyleColorsDark(null)</span><br><span class="line">    ImGui_ImplGlfw_InitForOpenGL(window, <span class="literal">true</span>)</span><br><span class="line">    ImGui_ImplOpenGL3_Init(<span class="string">"#version 330"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> glfwWindowShouldClose(window)==<span class="number">0</span></span><br><span class="line">        glfwPollEvents()</span><br><span class="line"></span><br><span class="line">        ImGui_ImplOpenGL3_NewFrame()</span><br><span class="line">        ImGui_ImplGlfw_NewFrame()</span><br><span class="line"></span><br><span class="line">        invoke(blk)</span><br><span class="line"></span><br><span class="line">        var display_w, display_h : <span class="keyword">int</span></span><br><span class="line">        glfwGetFramebufferSize(window, display_w, display_h)</span><br><span class="line">        let aspect = display_h!=<span class="number">0</span> ? <span class="keyword">float</span>(display_w)/<span class="keyword">float</span>(display_h) : <span class="number">1.</span></span><br><span class="line">        <span class="comment">// render</span></span><br><span class="line">        glViewport(<span class="number">0</span>, <span class="number">0</span>, display_w, display_h)</span><br><span class="line">        glClearColor(<span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">1.0</span>)</span><br><span class="line">        glClearDepth(<span class="number">1.0l</span>f)</span><br><span class="line">        glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT|GL_STENCIL_BUFFER_BIT)</span><br><span class="line"></span><br><span class="line">        ImGui_ImplOpenGL3_RenderDrawData(GetDrawData())</span><br><span class="line"></span><br><span class="line">        glfwMakeContextCurrent(window)</span><br><span class="line">        glfwSwapBuffers(window)</span><br><span class="line">    <span class="comment">//close app</span></span><br><span class="line">    DestroyContext(null)</span><br><span class="line">    glfwDestroyWindow(window)</span><br><span class="line">    glfwTerminate()</span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def test</span><br><span class="line">imgui_app(<span class="string">"imgui"</span>) &lt;|</span><br><span class="line">        NewFrame()</span><br><span class="line">        Begin(<span class="string">"Crop params"</span>);</span><br><span class="line">        End();</span><br><span class="line">        Render()</span><br></pre></td></tr></table></figure><ul><li>не забыли создать и очистить буфер трафарета (GL_STENCIL_BUFFER_BIT)</li><li><a href="https://dascript.org/doc/reference/language/blocks.html?highlight=block" target="_blank" rel="noopener">block</a> в daScript — безымянная функция, которая захватывает переменные по ссылке (более быстрая, чем лямбда-функции, которые могут управлять способом захвата)</li><li><code>defer</code> — макрос для добавления выражений в блок <a href="https://dascript.org/doc/reference/language/statements.html?highlight=defer#finally-statement" target="_blank" rel="noopener">finally</a></li></ul><p>Исходная демка использует библиотеки three.js и ColladaLoader.js для загрузки меша из dae файла, но можно <a href="https://products.aspose.app/3d/ru/conversion/dae-to-obj" target="_blank" rel="noopener">конвертировать</a> dae в obj, чтобы использовать код загрузки меша из примера daScript. Загрузка меша:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">require opengl/opengl_gen</span><br><span class="line"></span><br><span class="line">let mesh_file_name = <span class="string">"&#123;get_das_root()&#125;/house.obj"</span></span><br><span class="line">var mesh &lt;- load_obj_mesh(mesh_file_name) |&gt; create_geometry_fragment</span><br></pre></td></tr></table></figure><h2 id="Отрисовка-меша"><a href="#Отрисовка-меша" class="headerlink" title="Отрисовка меша"></a>Отрисовка меша</h2><p>Задание стандартных шейдеров:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">require glsl/glsl_common</span><br><span class="line">require glsl/glsl_internal</span><br><span class="line"></span><br><span class="line">var [[in, location=<span class="number">0</span>]] v_position : float3</span><br><span class="line">var [[in, location=<span class="number">1</span>]] v_normal   : float3</span><br><span class="line">var [[in, location=<span class="number">2</span>]] v_texcoord : float2</span><br><span class="line">var [[uniform]] v_model : float4x4</span><br><span class="line">var [[uniform]] v_view : float4x4</span><br><span class="line">var [[uniform]] v_projection : float4x4</span><br><span class="line">var [[inout]] f_texcoord : float2</span><br><span class="line">var [[inout]] f_normal : float3</span><br><span class="line">var [[inout]] f_position : float3</span><br><span class="line">var [[inout]] f_worldpos : float3</span><br><span class="line"></span><br><span class="line">var [[uniform, stage=<span class="number">0</span>]] f_tex : sampler2D</span><br><span class="line">var [[out]] f_FragColor : float4</span><br><span class="line"></span><br><span class="line">[vertex_program]</span><br><span class="line">def vs_preview</span><br><span class="line">    f_texcoord = v_texcoord</span><br><span class="line">    f_normal = normalize ( float3x3(v_model) * v_normal )</span><br><span class="line">    let tpos = v_model * float4(v_position, <span class="number">1.0</span>)</span><br><span class="line">    f_position = tpos.xyz</span><br><span class="line">    f_worldpos = v_position</span><br><span class="line">    gl_Position = v_projection * v_view * tpos</span><br><span class="line"></span><br><span class="line">[fragment_program (version=<span class="number">400</span>)]</span><br><span class="line">def fs_preview</span><br><span class="line">    let pS = <span class="number">24.0</span></span><br><span class="line"></span><br><span class="line">    let light_dir = normalize(float3(<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">-3</span>))</span><br><span class="line">    let camera_dir = normalize(f_position)</span><br><span class="line">    let normal = normalize(f_normal)</span><br><span class="line">    let k = -dot(light_dir,normal)</span><br><span class="line">    let diffuse = float3(saturate(k))</span><br><span class="line">    let refl = normalize ( reflect(camera_dir,normal) )</span><br><span class="line">    let kS = saturate(dot(-light_dir,refl))</span><br><span class="line">    let kS1 = saturate(dot(-light_dir,refl))</span><br><span class="line">    let specular = float3(<span class="built_in">pow</span>(kS,pS)*kS)</span><br><span class="line">    f_FragColor.xyz = texture(f_tex,f_texcoord).xyz * diffuse + specular</span><br><span class="line">    f_FragColor.w = <span class="number">1.</span></span><br></pre></td></tr></table></figure><p>Интересная штука — DSL для работы с шейдерами (<a href="https://github.com/GaijinEntertainment/daScript/blob/master/modules/dasGlsl/glsl/glsl_internal.das" target="_blank" rel="noopener">glsl_internal</a>, набор макросов для того, чтобы писать шейдеры как обычные функции в daScript, а также работать с uniform переменными почти как с обычными переменными языка. Пример передачи uniform-ов в шейдер:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var [[uniform]] v_projection : float4x4                                     <span class="comment">//объявление uniform переменной для шейдера</span></span><br><span class="line"></span><br><span class="line">let aspect = display_h!=<span class="number">0</span> ? <span class="keyword">float</span>(display_w)/<span class="keyword">float</span>(display_h) : <span class="number">1.</span></span><br><span class="line">v_projection = perspective_rh_opengl( <span class="number">45.0f</span>*PI/<span class="number">180.</span>, aspect, <span class="number">0.1f</span>, <span class="number">10.0f</span>)   <span class="comment">//определяем матрицу проекции (daScript-структура)</span></span><br><span class="line">vs_preview_bind_uniform(program_front)                                      <span class="comment">//передаём uniform переменные в шейдер</span></span><br><span class="line">fs_preview_bind_uniform(program_front)                                      <span class="comment">// vs_preview_bind_uniform - сгенерированная макросом [vertex_program] функция!</span></span><br></pre></td></tr></table></figure><p>Помимо простой привязки функций библиотеки, сгенерированной с помощью <code>dasClangBind</code>, написаны также макросы для “daScript-ивизации” кода. Вместо императивного вызова функции <code>glUniformXXX</code>, программист декларирует намерение “эта переменная - uniform для шейдера” — аннотация <code>uniform</code>.</p><p><strong><code>За счёт этого скриптовый язык становится не &quot;условным бейсиком&quot; для императивного вызова функций, а способом приблизить библиотеку к предметной области, в терминах которой мыслит и работает программист</code></strong></p><p>Отрисовка:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">glUseProgram(program)</span><br><span class="line">vs_preview_bind_uniform(program)</span><br><span class="line">fs_preview_bind_uniform(program)</span><br><span class="line">draw_geometry_fragment(mesh)</span><br></pre></td></tr></table></figure><p><img src="/blog/4232971949/clip_1_small.png" alt="1"></p><h2 id="Клиппинг-плоскостями-отсечения"><a href="#Клиппинг-плоскостями-отсечения" class="headerlink" title="Клиппинг плоскостями отсечения"></a>Клиппинг плоскостями отсечения</h2><p>Изменим пиксельный шейдер отрисовки объекта:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[fragment_program (version=<span class="number">400</span>)]</span><br><span class="line">def fs_preview</span><br><span class="line">    <span class="comment">//если вершина отсекается плоскостями -- отбросить её</span></span><br><span class="line">    <span class="keyword">if</span> (f_worldpos.x &lt; f_crop_plane_x) || (f_worldpos.y &lt; f_crop_plane_y) || (f_worldpos.x &gt; f_crop_plane_x_max) || (f_worldpos.y &gt; f_crop_plane_y_max)</span><br><span class="line">        discard()</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">Установка uniform-переменных через панель imGui</span><br><span class="line">```cpp</span><br><span class="line">    Begin(<span class="string">"Crop params"</span>);</span><br><span class="line">    SliderFloat(<span class="string">"Crop plane X"</span>, safe_addr(f_crop_plane_x), <span class="number">-1.0f</span>, <span class="number">1.0f</span>)</span><br><span class="line">    SliderFloat(<span class="string">"Crop plane Xnax"</span>, safe_addr(f_crop_plane_x_max), <span class="number">-1.0f</span>, <span class="number">1.0f</span>)</span><br><span class="line">    SliderFloat(<span class="string">"Crop plane Y"</span>, safe_addr(f_crop_plane_y), <span class="number">-1.0f</span>, <span class="number">1.0f</span>)</span><br><span class="line">    SliderFloat(<span class="string">"Crop plane Ymax"</span>, safe_addr(f_crop_plane_y_max), <span class="number">-1.0f</span>, <span class="number">1.0f</span>)</span><br><span class="line">    End();</span><br></pre></td></tr></table></figure><br><img src="/blog/4232971949/clip_2_small.png" alt="2"></p><p>Сквозь отброшенные пиксели пока видны внутренние грани объекта.</p><h2 id="Заполнение-буфера-трафарета"><a href="#Заполнение-буфера-трафарета" class="headerlink" title="Заполнение буфера трафарета"></a>Заполнение буфера трафарета</h2><p>Исходная демка на three.js использует для описания состояния рендера концепцию <a href="https://github.com/daign/clipping-with-caps/blob/master/js/material.js" target="_blank" rel="noopener">материалов</a> этой библиотеки, но несложно сопоставить свойства материлов с параметрами OpenGL</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//упрощенный шейдер для вывода в буфер трафарета</span></span><br><span class="line">[fragment_program (version=<span class="number">400</span>)]</span><br><span class="line">def fs_preview_front</span><br><span class="line">    let not_inside_camera = (f_worldpos.x &lt; f_crop_plane_x) || (f_worldpos.y &lt; f_crop_plane_y) || (f_worldpos.x &gt; f_crop_plane_x_max) || (f_worldpos.y &gt; f_crop_plane_y_max)</span><br><span class="line">    <span class="keyword">if</span> not_inside_camera</span><br><span class="line">        discard()</span><br><span class="line">    f_FragColor = float4(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">//Включаем рендер в буфер трафарета, отключаем запись в буфера цвета и глубины</span></span><br><span class="line">glEnable(GL_STENCIL_TEST)</span><br><span class="line">glColorMask(<span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>)</span><br><span class="line">glDepthMask(<span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//установка шейдера</span></span><br><span class="line">glUseProgram(program_front)</span><br><span class="line">vs_preview_bind_uniform(program_front)</span><br><span class="line">fs_preview_front_bind_uniform(program_front)</span><br><span class="line"></span><br><span class="line"><span class="comment">//рендер только задних граней объекта с увеличением значения в буфере трафарета</span></span><br><span class="line">glEnable(GL_CULL_FACE);</span><br><span class="line">glCullFace(GL_FRONT);</span><br><span class="line">glStencilFunc(GL_ALWAYS, <span class="number">1</span>, <span class="number">0xFF</span>)</span><br><span class="line">glStencilOp(GL_KEEP, GL_KEEP, GL_INCR)</span><br><span class="line">draw_geometry_fragment(mesh)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Рендер только передних граней объекта с уменьшения значения в буфере трафарета</span></span><br><span class="line">glEnable(GL_CULL_FACE);</span><br><span class="line">glCullFace(GL_BACK);</span><br><span class="line">glStencilFunc(GL_ALWAYS, <span class="number">1</span>, <span class="number">0xFF</span>)</span><br><span class="line">glStencilOp(GL_KEEP, GL_KEEP, GL_DECR)</span><br><span class="line">draw_geometry_fragment(mesh)</span><br></pre></td></tr></table></figure><p>Вывод отсекающих граней:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;функция генерации прямоугольника заданного размера</span><br><span class="line">def gen_axis_rect(plt : GenDirection; x1, x2, y1, y2, coord: float)</span><br><span class="line">    var frag : GeometryFragment</span><br><span class="line">    frag.vertices &lt;- [&#123;GeometryPreviewVertex</span><br><span class="line">        xyz&#x3D;float3( x1, y1, coord), normal&#x3D;float3(  0, 0, 1),  uv&#x3D;float2(0,0);</span><br><span class="line">        xyz&#x3D;float3(x2, y1, coord), normal&#x3D;float3(  0, 0, 1),  uv&#x3D;float2(1,0);</span><br><span class="line">        xyz&#x3D;float3(x2,y2, coord), normal&#x3D;float3(  0, 0, 1),  uv&#x3D;float2(1,1);</span><br><span class="line">        xyz&#x3D;float3( x1,y2, coord), normal&#x3D;float3(  0, 0, 1),  uv&#x3D;float2(0,1)</span><br><span class="line">    &#125;]</span><br><span class="line">    apply_gen_direction_tm(plt, frag)</span><br><span class="line">    frag.indices &lt;- [&#123;int 0; 1; 2; 2; 3; 0 &#125;]</span><br><span class="line">    frag.prim &#x3D; GeometryFragmentType triangles</span><br><span class="line">    gen_bbox(frag)</span><br><span class="line">    return &lt;- frag</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">[fragment_program (version&#x3D;400)]</span><br><span class="line">def fs_preview_caps</span><br><span class="line">    f_FragColor &#x3D; float4(0.0, 1.0, 0.0, 1.0)</span><br><span class="line"></span><br><span class="line">glUseProgram(program_caps)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;отрисовка через полученную в буфере трафарета маску</span><br><span class="line">glStencilFunc(GL_EQUAL, 1, 0xFF)</span><br><span class="line">glStencilOp(GL_KEEP, GL_KEEP, GL_KEEP)</span><br><span class="line">vs_preview_bind_uniform(program_caps)</span><br><span class="line">fs_preview_caps_bind_uniform(program_caps)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;генерация отсекающих плоскостей</span><br><span class="line">var planeX &lt;- gen_axis_rect(GenDirection yz, 2.0, -2.0, f_crop_plane_y_max, f_crop_plane_y, -f_crop_plane_x) |&gt; create_geometry_fragment</span><br><span class="line">draw_geometry_fragment(planeX)</span><br><span class="line">var planeXMax &lt;- gen_axis_rect(GenDirection yz, 2.0, -2.0, f_crop_plane_y_max,f_crop_plane_y, -f_crop_plane_x_max) |&gt; create_geometry_fragment</span><br><span class="line">draw_geometry_fragment(planeXMax)</span><br><span class="line"></span><br><span class="line">var planeY &lt;- gen_axis_rect(GenDirection xz, f_crop_plane_x, f_crop_plane_x_max, 2.0, -2.0, f_crop_plane_y) |&gt; create_geometry_fragment</span><br><span class="line">draw_geometry_fragment(planeY)</span><br><span class="line">var planeYMax &lt;- gen_axis_rect(GenDirection xz, f_crop_plane_x, f_crop_plane_x_max, 2.0, -2.0, f_crop_plane_y_max) |&gt; create_geometry_fragment</span><br><span class="line">draw_geometry_fragment(planeYMax)</span><br></pre></td></tr></table></figure><p>Как отмечено в описании алгоритма <a href="https://github.com/daign/clipping-with-caps#clipping-with-caps" target="_blank" rel="noopener">референсной демки</a>, такой подход нормально работает с одной плоскостью отсечения, но с нескольими плоскостями даёт неверный результат (повёрнутые “от камеры” плоскости отсечения также вносят вклад в маску и портят результат в буфере трафарета — выводят лишние “дырки” или “крышки” в таких местах:</p><p><img src="/blog/4232971949/clip_3_small.png" alt="3"></p><h2 id="Коррекция-буфера-трафарета-для-граней-повернутых-от-камеры"><a href="#Коррекция-буфера-трафарета-для-граней-повернутых-от-камеры" class="headerlink" title="Коррекция буфера трафарета для граней, повернутых от камеры"></a>Коррекция буфера трафарета для граней, повернутых от камеры</h2><p>На этом этапе обнаруживаются отличия между демкой-референсом и примером из daScript. Позиция камеры в референсной демке попадает в шейдера “автоматически”, эта переменная <a href="https://threejs.org/docs/#api/en/renderers/webgl/WebGLProgram" target="_blank" rel="noopener">устанавливается</a> библиотекой three.js. Для примера на daScript нужно передать её вручную и учесть то, что системы координат в демках различаются. Поворот в примере daScript задаётся через матрицу <code>v_model</code>, так что для трансформации камеры в систему координат модели и плоскостей отсечения нужно также “довернуть” её, умножив на матрицу модели.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//позиция камеры в пространстве координат модели</span></span><br><span class="line">var [[uniform]] f_camera_position_rotated : float3</span><br><span class="line"></span><br><span class="line"><span class="comment">//шейдер для вывода в буфер трафарета</span></span><br><span class="line">[fragment_program (version=<span class="number">400</span>)]</span><br><span class="line">def fs_preview_front</span><br><span class="line">    <span class="comment">//let not_inside_camera =  (f_worldpos.x &lt; f_crop_plane_x) || (f_worldpos.y &lt; f_crop_plane_y) || (f_worldpos.x &gt; f_crop_plane_x_max) || (f_worldpos.y &gt; f_crop_plane_y_max)</span></span><br><span class="line">    let not_inside_camera = (f_worldpos.x &lt; f_crop_plane_x) &amp;&amp; (f_camera_position_rotated.x &gt; -f_crop_plane_x) || (f_worldpos.y &lt; f_crop_plane_y) &amp;&amp; (f_camera_position_rotated.y &lt; f_crop_plane_y) || (f_worldpos.x &gt; f_crop_plane_x_max) &amp;&amp; (f_camera_position_rotated.x &lt; -f_crop_plane_x_max) || (f_worldpos.y &gt; f_crop_plane_y_max) &amp;&amp; (f_camera_position_rotated.y &gt; f_crop_plane_y_max)</span><br><span class="line">    <span class="keyword">if</span> not_inside_camera</span><br><span class="line">        discard()</span><br><span class="line">    f_FragColor = float4(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">//поворот камеры в пространство координат модели</span></span><br><span class="line">let camPos = v_model * float4(camera_position, <span class="number">1.0</span>)</span><br><span class="line">f_camera_position_rotated = camPos.xyz</span><br></pre></td></tr></table></figure><p>Можно обратить внимание на идентичный синтаксис умножения вектора на матрицу в коде вершинного шейдера для трансфорфмации вершин меша,  и обычном скрипте на daScript.</p><p>Теперь наконец отсечения смотрятся корректно под любым углом.</p><p><img src="/blog/4232971949/clip_4_small.png" alt="4"></p><p><a href="https://github.com/spiiin/dascript_macro_tutorial/blob/master/clipping_with_caps/tutorial01.das" target="_blank" rel="noopener">Исходный код туториала</a></p><ul><li>daScript хорош, чтобы поиграться с демками графических эффектов :)</li><li>подход авторов к написанию байндингов — автоматическая обёртка на c/c++-функциями + “daScript-тификация” кода — создание макросов, упрощающих работу с библиотекой</li><li>вообще, демку стоило бы ещё перевести на режим <a href="https://github.com/borisbat/dasGlfw/blob/48f2715f0fe4cb8076866365a4bf0a29b7104765/dasglfw/glfw_live.das" target="_blank" rel="noopener">live-изменений</a>, тянет на отдельный туториал</li></ul><p>Ну и более глобальный вывод про совокупность всех фич языка — если большая часть кода на языке делает то, что сложно или долго делать на других языках, с какого-то момента разработки сама программа может получить какие-то свойства, которых нет у программ на других языках (потому что их было слишком долго или трудно реализовывать).</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Пример использования байдингов OpenGL для языка daScript&lt;br&gt;
    
    </summary>
    
    
    
      <category term="opengl" scheme="http://spiiin.github.io/tags/opengl/"/>
    
      <category term="dascript" scheme="http://spiiin.github.io/tags/dascript/"/>
    
  </entry>
  
  <entry>
    <title>daScript macro</title>
    <link href="http://spiiin.github.io/blog/1547564887/"/>
    <id>http://spiiin.github.io/blog/1547564887/</id>
    <published>2022-02-06T17:04:42.000Z</published>
    <updated>2022-08-01T13:04:25.045Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p><a href="https://dascript.org/" target="_blank" rel="noopener">daScript</a> - скриптовый язык для игр от Gaijin Entertaiment.</p><p>После нескольких дней изучения понял, что испытываю интерес и хороший страх по отношению к этому языку. Такой, как если бы нашёл лазерную указку и решил поиграть с котом, но понял, что этой указкой можно легко резать металл. </p><p>Гайдзины делают не замену <code>Lua</code>, они делают замену <code>C++</code>! Точнее даже, не “делают”, а практически “сделали”, язык сейчас находится в версии 0.2, но полноценно используется ими в продакшене в <code>Warthunder</code>.</p><p>Доклад и документация акцентируют внимание на быстродействии языка и возможности серьёзных изменений без перезапуска игры, но только вскользь упоминают о мощных возможностях макросов. Так что я решил попробовать решить задачку, требующую их использования. Это моя первая программа на <code>daScript</code>, после трёх дней изучения, так что где-то возможны и неизбежны косяки.</p><a id="more"></a><h2 id="Задача"><a href="#Задача" class="headerlink" title="Задача"></a>Задача</h2><p>В качестве задачи выбрал такую, которую было бы нетривиально или сложно решить на C++:</p><blockquote><ul><li>Подсказка компилятору аллоцировать блок данных для структуры в линейном блоке памяти без явного написания кода работы с указателями в самой структуре</li></ul></blockquote><a href="/blog/1728194429/" title="C++ в геймдеве">C++ в геймдеве</a><p>Формулировка проблемы из видео про язык <a href="https://youtu.be/TH9VCN6UkyQ?t=4047" target="_blank" rel="noopener">Jai</a> — пример кода, в котором тривиальное объявление медленнее сложного, но быстрого.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Тривиальное объявление меша для моделей</span></span><br><span class="line"><span class="comment">//  2 аллокации, возможно в разных местах памяти</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Mesh</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Vector3&gt; positions;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; indexes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Более реальный вариант для продакшена</span></span><br><span class="line"><span class="comment">//  синтаксис сильно отличается от тривиального варианта </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Mesh</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span>* memblock = <span class="literal">nullptr</span>;</span><br><span class="line">    Vector3* positions = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">int</span>* indices = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">int</span> num_vertices = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> num_indices = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> positions_size = num_vertices * <span class="keyword">sizeof</span> (positions[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">int</span> indices_size = num_indices = <span class="keyword">sizeof</span>(indices[<span class="number">0</span>]);</span><br><span class="line">mesh-&gt;memory_block = <span class="keyword">new</span> <span class="keyword">char</span>[positions_size + indices_size];</span><br><span class="line">mesh-&gt;positions = (Vector3*)mesh-&gt;memblock;</span><br><span class="line">mesh-&gt;indices = (<span class="keyword">int</span>*)(mesh-&gt;memblock + positions_size);</span><br></pre></td></tr></table></figure><p>Второй вариант требует написания рутинного кода вручную при добавлении новых полей в структуру, а также ёмкий в плане количества переписывания кода из существующего. Если захочется переделать в таком стиле для ускорения несколько структур — для каждой потребуется ручная работа. Из-за этого большинство структур навсегда останутся описанными в первой, медленной форме.</p><p>Джонатан Блоу предлагает в качестве решения проблемы вариант синтаксиса своего языка, который позволит легко “переключить” структуру из медленной формы в быструю.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Mesh</span> &#123;</span></span><br><span class="line">    Vector3 []! positions;           <span class="comment">//[]! - семантика для указателя на память, которую должна выделить и освободить сама структура</span></span><br><span class="line">    <span class="keyword">int</span>[]! indices; @joint positions <span class="comment">//@joint - семантика для того, что попросить компилятор</span></span><br><span class="line">                                     <span class="comment">//    расположить данные в памяти одним блоком</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Я захотел попробовать реализовать подобную подсказку компилятору daScript с помощью макросов.</p><h2 id="Документация-к-daScript"><a href="#Документация-к-daScript" class="headerlink" title="Документация к daScript"></a>Документация к daScript</h2><p>Порядок изучения информации про язык:</p><ul><li>Доклад Антона Юдинцева<style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/IvHGczF6Go0" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></li><li>Инфа с оффициального сайта и <a href="https://dascript.org/doc/index.html" target="_blank" rel="noopener">документация</a></li><li><a href="https://youtu.be/inGb9R1NowY" target="_blank" rel="noopener">Live Stream Coding on daScript - Breakoid</a> - стрим с примером реализации арканоида, можно посмотреть на макросы и синтаксис системы ECS, реализованной с помощью макросов</li><li><a href="https://github.com/GaijinEntertainment/daScript/tree/073bc29145207b39180069ae60f00ed43fad6ea7/examples/tutorial" target="_blank" rel="noopener">Серия туториалов</a> - примеры привязки скриптов к C++, Ahead-of-Time компиляции, реализация генерации кода через cmake, архитектура игрового объекта с возможностью hot-reloading кода из скриптов.</li><li><a href="https://github.com/GaijinEntertainment/daScript/tree/073bc29145207b39180069ae60f00ed43fad6ea7/examples/test/misc" target="_blank" rel="noopener">Больше примеров кода</a>, в том числе несколько макросов</li><li><a href="https://github.com/GaijinEntertainment/daScript/tree/073bc29145207b39180069ae60f00ed43fad6ea7/daslib" target="_blank" rel="noopener">Стандартная библиотека</a> языка и <a href="https://github.com/GaijinEntertainment/daScript/tree/073bc29145207b39180069ae60f00ed43fad6ea7/modules" target="_blank" rel="noopener">модули</a>, можно использовать поиск по коду с гитхаба, чтобы найти пример использования той или иной фичи</li></ul><p>Макросы являются достаточно сложной темой, и освещены в документации daScript-а достаточно кратко, поэтому приведу несколько ссылок на туториалы из других языков:<br><a href="https://www.greghendershott.com/fear-of-macros/" target="_blank" rel="noopener">Fear of macros</a> - Racket<br><a href="https://rsdn.org/article/nemerle/NemerleStingFormating.xml" target="_blank" rel="noopener">Макросы в Nemerle</a> - Nemerle<br><a href="https://nim-lang.org/docs/tut3.html" target="_blank" rel="noopener">Nim Tutorial Part 3</a> - Nim</p><h2 id="Наивная-реализация"><a href="#Наивная-реализация" class="headerlink" title="Наивная реализация"></a>Наивная реализация</h2><p>Прежде, чем начинать шаманить с макросами, нужно набросать наивную реализацию “быстрой” версии класса, хранящего свои данные в одном блоке памяти. Для этого можно использовать <a href="https://tiorun.gaijin.team/##S0ksTi7KLCj5/z86taIgv6gklislNU0hNzEzj0sBCAqKMvNKNJQ8UnNy8nUUwvOLclIUlTS5/v8HAA" target="_blank" rel="noopener">онлайн компилятор tio</a>.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Memblock</span></span></span><br><span class="line"><span class="class">    <span class="title">mem</span> :</span> <span class="built_in">array</span>&lt;uint8&gt;</span><br><span class="line">    a: <span class="keyword">int</span>?</span><br><span class="line">    aCount: <span class="keyword">int</span></span><br><span class="line">    b: <span class="keyword">float</span>?</span><br><span class="line">    bCount: <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">initMemblock</span><span class="params">(var memblock: Memblock; aCount:<span class="keyword">int</span>; bCount:<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    let aSize </span>= typeinfo(<span class="keyword">sizeof</span> *memblock.a) * aCount</span><br><span class="line">    let bSize = typeinfo(<span class="keyword">sizeof</span> *memblock.b) * bCount</span><br><span class="line"></span><br><span class="line">    var arr: <span class="built_in">array</span>&lt;uint8&gt;</span><br><span class="line">    arr |&gt; resize(aSize + bSize )</span><br><span class="line">    memblock.mem &lt;- arr</span><br><span class="line"></span><br><span class="line">    memblock.aCount = aCount</span><br><span class="line">    memblock.bCount = bCount</span><br><span class="line">    unsafe</span><br><span class="line">        memblock.a = reinterpret&lt;<span class="keyword">int</span>?&gt; addr(memblock.mem[<span class="number">0</span>])</span><br><span class="line">        memblock.b = reinterpret&lt;<span class="keyword">float</span>?&gt; addr(memblock.mem[aSize])</span><br><span class="line"></span><br><span class="line">        memblock.a[<span class="number">0</span>] = <span class="keyword">int</span>(<span class="number">0x11223344</span>)</span><br><span class="line">        memblock.a[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">        memblock.a[<span class="number">2</span>] = <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        memblock.b[<span class="number">0</span>] = reinterpret&lt;<span class="keyword">float</span>&gt;(<span class="number">0x55667788</span>)</span><br><span class="line">        memblock.b[<span class="number">1</span>] = <span class="number">0.0</span></span><br><span class="line">        memblock.b[<span class="number">2</span>] = <span class="number">123.456</span></span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main</span><br><span class="line">    unsafe</span><br><span class="line">        var memblock: Memblock</span><br><span class="line">        memblock |&gt; initMemblock(<span class="number">5</span>,<span class="number">5</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Memblock = &#123;memblock&#125;"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Output:</span></span><br><span class="line"><span class="comment">//  Memblock = [[ [[0x44; 0x33; 0x22; 0x11; 0x0; 0x0; 0x0; 0x0; 0xff; 0xff; 0xff; 0xff; 0x0; 0x0;</span></span><br><span class="line"><span class="comment">//     0x0; 0x0; 0x0; 0x0; 0x0; 0x0; 0x88; 0x77; 0x66; 0x55; 0x0; 0x0; 0x0; 0x0; 0x79; 0xe9; 0xf6; </span></span><br><span class="line"><span class="comment">//     0x42; 0x0; 0x0; 0x0; 0x0; 0x0; 0x0; 0x0; 0x0]]; 287454020; 5; 15837566074880.000000000; 5]]</span></span><br></pre></td></tr></table></figure><p>Несколько замечаний про язык:</p><ul><li>Питоноподобный синтаксис с отступами. Для тех, кто не переносит такой формы синтаксиса, есть вариант без оступов, со скобочками и точками-с-запятыми.</li><li>Пайпы (<code>|&gt;</code> и <code>&lt;|</code>) как синтаксический сахар различных записи вызова функции (<a href="https://en.wikipedia.org/wiki/Uniform_Function_Call_Syntax" target="_blank" rel="noopener">UFCS</a>).</li><li>Более строгая типизация, чем в C/C++, из-за чего сложнее изучать язык и играться с ним — иногда приходится отвлекаться на то, чтобы разобраться, что именно компилятор от тебя хочет. По идее, должно помогать ловить в компайл-тайм больше того, что поймалось бы только в рантайме.</li><li><em>unsafe</em>, чтобы сказать компилятору “дай мне играться с указателями, как мне хочется, я знаю, что делаю”.</li><li>print умеет выводить внутренности структуры, можно убедиться, что данные действительно лежат в одном блоке памяти, как задумывалось.</li><li>Отсутствие семантики “=” для типов, для которых нет её однозначного определения. Вместо этого компилятор явно предлагает выбрать между клонированием (“:=”) и перемещением (“&lt;-“). В языке есть generic-функции, в них вроде можно попросить у компилятора данные о типах так, чтобы выбрать желаемое поведение.</li></ul><h2 id="Первый-макрос"><a href="#Первый-макрос" class="headerlink" title="Первый макрос"></a>Первый макрос</h2><p>Попробуем для начала написать простейший макрос, который выведет на экран список полей структуры. С этого момента не получится использовать онлайн компилятор, так как он не поддерживает загрузку кода из нескольких файлов, а макрос должен располагаться в отдельном модуле.</p><p>Причина того, что макрос не может находиться в том же модуле, что и структура, которую он обрабатывает, понятна — чтобы выполнить какой-либо код, обрабатывающий структуру на этапе компиляции, необходимо, чтобы сам этот код к этому моменту был уже скомпилирован.</p><p>В репозитории языка валяется готовый <a href="https://github.com/GaijinEntertainment/daScript/blob/073bc29145207b39180069ae60f00ed43fad6ea7/examples/test/misc/dump_fields.das" target="_blank" rel="noopener">пример</a> такого макроса, но в учебных целях немного перепишем его:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> macro_test</span><br><span class="line"></span><br><span class="line">require ast</span><br><span class="line">require daslib/ast_boost</span><br><span class="line"></span><br><span class="line">[structure_macro(name=memblock)]</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DumpFields</span> :</span> AstStructureAnnotation</span><br><span class="line">    <span class="function">def <span class="keyword">override</span> <span class="title">finish</span> <span class="params">( var st:StructurePtr; var group:ModuleGroup; args:AnnotationArgumentList; var errors : das_string )</span> : <span class="keyword">bool</span></span></span><br><span class="line"><span class="function">        <span class="title">print</span><span class="params">(<span class="string">"struct &#123;st.name&#125; \&#123;\n"</span>)</span></span></span><br><span class="line">        for field in st.fields</span><br><span class="line">            print(<span class="string">"\t&#123;describe_cpp(field._type)&#125; &#123;field.name&#125;;\n"</span>)</span><br><span class="line">        print(<span class="string">"\&#125;\n"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>Макрос наследуется от класса <code>AstStructureAnnotation</code>, определённого в модуле <a href="https://github.com/GaijinEntertainment/daScript/blob/073bc29145207b39180069ae60f00ed43fad6ea7/src/builtin/ast.das#L75" target="_blank" rel="noopener">ast</a>, который представляет собой шаблон для аннотации структуры. К самому классу также применяется аннотация <code>structure_macro</code>, которая регистрирует данный макрос для применения к каждой структуре, отмеченной аннотацией <code>memblock</code>.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AstStructureAnnotation</span></span></span><br><span class="line"><span class="class">    <span class="title">def</span> <span class="title">abstract</span> <span class="title">apply</span> ( <span class="title">var</span> <span class="title">st</span>:</span>StructurePtr; var group:ModuleGroup; args:AnnotationArgumentList; var errors : das_string ) : <span class="keyword">bool</span></span><br><span class="line">    <span class="function">def abstract <span class="title">finish</span> <span class="params">( var st:StructurePtr; var group:ModuleGroup; args:AnnotationArgumentList; var errors : das_string )</span> : <span class="keyword">bool</span></span></span><br><span class="line"><span class="function">    def abstract <span class="title">patch</span> <span class="params">( var st:StructurePtr; var group:ModuleGroup; args:AnnotationArgumentList; var errors : das_string; var astChanged:<span class="keyword">bool</span>&amp; )</span> : <span class="keyword">bool</span></span></span><br></pre></td></tr></table></figure><p>Интерфейс макроса позволяет переопределить три функции, чтобы “вклиниться” в процесс того, как компилятор обрабатывает определения структуры, на различных этапах. <a href="https://dascript.org/doc/reference/language/macros.html?highlight=macro#compilation-passes" target="_blank" rel="noopener">Документация по фазам компиляции</a>. <code>Apply</code> - наиболее подходящий момент, чтобы попробовать изменить поля структуры или сгенерировать код.</p><p>Если теперь отметить описание структуры аннотацией <code>memblock</code>, то компилятор “пропустит” её определение через макрос, который выведет названия полей на экран. В момент обработки информация о создаваемой структуре хранится в классе <code>StructurePtr</code>, определение которого можно найти поиском по C++ коду. На данном этапе макрос просто проходит по всем полям структуры и выводит информацию о каждом из них на экран. <code>describe_cpp</code> - это функция, которая выводит определения типа, как если бы он был объявлен в C++.</p><p>При запуске приложения на экран выведется:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct Memblock &#123;</span><br><span class="line">    TArray&lt;uint8_t&gt; mem;</span><br><span class="line">    int32_t * a;</span><br><span class="line">    int32_t aСount;</span><br><span class="line">    int32_t * b;</span><br><span class="line">    int32_t bCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Можно немного поиграться с определением макроса:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[structure_macro(name=memblock)]</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenMemblock</span> :</span> AstStructureAnnotation</span><br><span class="line">    <span class="function">def <span class="keyword">override</span> <span class="title">apply</span> <span class="params">( var st:StructurePtr; var group:ModuleGroup; args:AnnotationArgumentList; var errors : das_string )</span> : <span class="keyword">bool</span></span></span><br><span class="line">        var mkS &lt;- new [[ Structure() ]]         //создаём новую структуру</span><br><span class="line">        mkS.name := <span class="string">"MemblockTest"</span>               <span class="comment">//с именем MemblockTest</span></span><br><span class="line">        let fieldsLen = st.fields |&gt; length</span><br><span class="line">        mkS.fields |&gt; resize(fieldsLen)       </span><br><span class="line">        <span class="keyword">for</span> i in range(<span class="number">0</span>, fieldsLen)</span><br><span class="line">            mkS.fields[i] := st.fields[i]        <span class="comment">//копируем в неё все поля из обрабатываемой структуры</span></span><br><span class="line">        compiling_module() |&gt; add_structure(mkS) <span class="comment">//добавляем в компилирующийся сейчас модуль новый тип</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Скрипт, использующий модуль с макросом</span></span><br><span class="line">require macro_test</span><br><span class="line"></span><br><span class="line">[memblock]</span><br><span class="line">struct Memblock</span><br><span class="line">    mem : <span class="built_in">array</span>&lt;uint8&gt;</span><br><span class="line">    a: <span class="keyword">int</span>?</span><br><span class="line">    aCount: <span class="keyword">int</span></span><br><span class="line">    b: <span class="keyword">float</span>?</span><br><span class="line">    bCount: <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">var memblock1: Memblock</span><br><span class="line">var memblock2: MemblockTest <span class="comment">//ага, новый тип MemblockTest!</span></span><br><span class="line">print(<span class="string">"MemblockTest = &#123;memblock2&#125;"</span>)</span><br></pre></td></tr></table></figure><h2 id="Генерация-полей"><a href="#Генерация-полей" class="headerlink" title="Генерация полей"></a>Генерация полей</h2><p>Следующим шагом попробуем убрать поле <code>mem</code> из исходной структуры, и создать его из макроса.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[structure_macro(name=memblock)]</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenMemblock</span> :</span> AstStructureAnnotation</span><br><span class="line">    <span class="function">def <span class="keyword">override</span> <span class="title">apply</span> <span class="params">( var st:StructurePtr; var group:ModuleGroup; args:AnnotationArgumentList; var errors : das_string )</span> : <span class="keyword">bool</span></span></span><br><span class="line">        var mkS &lt;- new [[ Structure() ]]</span><br><span class="line">        mkS.name := <span class="string">"MemblockTest"</span></span><br><span class="line">        let fieldsLen = st.fields |&gt; length</span><br><span class="line">        mkS.fields |&gt; resize(fieldsLen+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//определение типа uint8, как это видит компилятор</span></span><br><span class="line">        var uint8Type &lt;- <span class="keyword">new</span> [[TypeDecl() baseType=Type tUInt8]]</span><br><span class="line">        <span class="comment">//определение array&lt;uint8&gt; </span></span><br><span class="line">        var uint8ArrayType &lt;- <span class="keyword">new</span> [[TypeDecl() baseType=Type tArray, firstType &lt;- uint8Type]]</span><br><span class="line">        <span class="comment">//декларация нового поля с именем mem и типом array&lt;uint8&gt; </span></span><br><span class="line">        mkS.fields[<span class="number">0</span>] := *<span class="keyword">new</span> [[ FieldDeclaration() name:=<span class="string">"mem"</span>, _type &lt;- uint8ArrayType]]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i in range(<span class="number">0</span>, fieldsLen)</span><br><span class="line">            mkS.fields[i+<span class="number">1</span>] := st.fields[i]</span><br><span class="line">        compiling_module() |&gt; add_structure(mkS)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Скрипт, использующий модуль с макросом</span></span><br><span class="line">[memblock]</span><br><span class="line">struct Memblock</span><br><span class="line">    <span class="comment">//mem : array&lt;uint8&gt;  //теперь поля нет в исходной структуре</span></span><br><span class="line">    a: <span class="keyword">int</span>?</span><br><span class="line">    aCount: <span class="keyword">int</span></span><br><span class="line">    b: <span class="keyword">float</span>?</span><br><span class="line">    bCount: <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">var memblock: MemblockTest</span><br><span class="line"><span class="comment">//у структуры MemblockTest появилось поле mem, сгенерированное макросом</span></span><br><span class="line">print(<span class="string">"MemblockTest = &#123;memblock.mem&#125;"</span>)</span><br></pre></td></tr></table></figure><ul><li>функция <code>resize</code> изменяет размер массива, <a href="https://dascript.org/doc/stdlib/builtin.html#containers" target="_blank" rel="noopener">документация</a> функций для работы с контейерами.</li><li>можно изменять поля определяемой структуры прямо на месте - макрос выполняется в сам момент её определения. Создание новой структуры с другим именем сделано для наглядности примера.</li><li>генерация структур компилятора для определения поля сперва выглядит немного “космически”, дальше будет пример использования функции <code>quote</code>, которая позволяет перевести код как его писал бы человек, в выражение, которое сгенерирует компилятор при парсинге этого кода. Но полезно разобраться с таким способом генерации кода, чтобы привыкнуть к нему. Также стоит найти определения <code>TypeDecl</code> и <code>FieldDeclaration</code> в исходном коде компилятора, это самая надёжная документация.</li><li>“оператор” обращения к конкретному значению перечисления — пробел (<code>Type tArray</code> - значение <code>tArray</code> перечисления <code>Type</code>). Очень необычное решение.</li><li>при кодогенерации необходимо заботиться о том, чтобы сгенерированное имя не пересекалось с тем, которое может захотеть использовать программист. В этом смысле <code>mem</code> — плохое имя для сгенерированного поля, в реальном коде необходимо было бы какое-либо соглашение об именах, авторы языка используют символ ‘`’ (гравис, backquote) для отметки генерированного кода.</li></ul><p>Таким же образом можно перенести поля <code>aCount</code> и <code>bCount</code> в генерирующий макрос:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[structure_macro(name=memblock)]</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenMemblock</span> :</span> AstStructureAnnotation</span><br><span class="line">    <span class="function">def <span class="keyword">override</span> <span class="title">apply</span> <span class="params">( var st:StructurePtr; var group:ModuleGroup; args:AnnotationArgumentList; var errors : das_string )</span> : <span class="keyword">bool</span></span></span><br><span class="line"><span class="function">        <span class="comment">//create "mem" field of type array&lt;uint8&gt;</span></span></span><br><span class="line">        var uint8Type &lt;- new [[TypeDecl() baseType=Type tUInt8]]</span><br><span class="line">        var uint8ArrayType &lt;- <span class="keyword">new</span> [[TypeDecl() baseType=Type tArray, firstType &lt;- uint8Type]]</span><br><span class="line"></span><br><span class="line">        let fieldsLen = st.fields |&gt; length</span><br><span class="line">        var ptrsCount = <span class="number">0</span></span><br><span class="line">        var ptrsTypeIndexes : <span class="built_in">array</span>&lt;<span class="keyword">int</span>&gt;</span><br><span class="line">        ptrsTypeIndexes |&gt; reserve(fieldsLen)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Проходим по списку всех полей и сохраняем индексы полей, тип которых -- указатель</span></span><br><span class="line">        <span class="keyword">for</span> i in range(<span class="number">0</span>, fieldsLen)</span><br><span class="line">            <span class="keyword">if</span> st.fields[i]._type.baseType == Type tPointer <span class="comment">//проверка типа поля</span></span><br><span class="line">                ptrsCount++</span><br><span class="line">                ptrsTypeIndexes |&gt; push(i)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//add one field for memblock and one field per pointer type to handle count of object per type</span></span><br><span class="line">        st.fields |&gt; resize(fieldsLen+ ptrsCount + <span class="number">1</span>)</span><br><span class="line">        st.fields[fieldsLen] := *<span class="keyword">new</span> [[ FieldDeclaration() name:=<span class="string">"mem"</span>, _type &lt;- uint8ArrayType]]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i in range(<span class="number">0</span>, ptrsCount)</span><br><span class="line">            <span class="comment">//генерируем имя поля - добавляем к нему постфикс `count</span></span><br><span class="line">            let fieldCountName = <span class="string">"&#123;st.fields[ptrsTypeIndexes[i]].name&#125;&#123;"</span>`count<span class="string">"&#125;"</span></span><br><span class="line">            <span class="comment">//генерируем новое поля типа int для каждого поля</span></span><br><span class="line">            st.fields[fieldsLen+<span class="number">1</span>+i] := *<span class="keyword">new</span> [[ FieldDeclaration() name:=fieldCountName, _type &lt;- <span class="keyword">new</span> [[TypeDecl() baseType=Type tInt]]]]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">[memblock]</span><br><span class="line"><span class="comment">//сама структура теперь содержит только определение полей</span></span><br><span class="line">struct Memblock</span><br><span class="line">    a: <span class="keyword">int</span>?</span><br><span class="line">    b: <span class="keyword">float</span>?</span><br><span class="line"></span><br><span class="line"><span class="comment">//вывод скрипта -- сгенерированные поля</span></span><br><span class="line">struct Memblock &#123;</span><br><span class="line">        <span class="keyword">int32_t</span> * a;</span><br><span class="line">        <span class="keyword">float</span> * b;</span><br><span class="line">        TArray&lt;<span class="keyword">uint8_t</span>&gt; mem;</span><br><span class="line">        <span class="keyword">int32_t</span> a`count;</span><br><span class="line">        <span class="keyword">int32_t</span> b`count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Разумеется, в реальном мире бывают структуры, которые могут содержать одновременно как указатели на память, которую должна выделять и освобождать сама структура, так и те, которые указывают на память, которую структура трогать не должна. Пока что мы считаем, что структура, отмеченная как <code>memblock</code>, содержит только указатели на память, которую выделяет и освобождает сама. Забегая наперёд, реализовать поддержку обоих типов указателей можно с помощью аннотаций типа (я не нашёл ссылок на аннотации в документации, но их можно найти в коде (<a href="https://github.com/borisbat/dasBGFX/blob/a1e10ab439e5996a0a4d8722689e2b0fab4e72d9/examples/01_hello_triangle.das#L7" target="_blank" rel="noopener">пример</a>)). Аннотации типа будут рассмотрены сильно дальше, при реализации наследования от memblock-структур.</p><p>На данном этапе мы получили возможность описать структуру с любым количеством полей, и с помощью макроса сгенерировать по этому описанию недостающие поля. К сожалению, функцию <code>initMemblock</code> (конструктор структуры), по прежнему необходимо писать руками, что очень неприятно.</p><h2 id="Подготовка-к-генерация-кода-конструктора"><a href="#Подготовка-к-генерация-кода-конструктора" class="headerlink" title="Подготовка к генерация кода конструктора"></a>Подготовка к генерация кода конструктора</h2><p>Для начала стоит немного переписать код <code>initMemblock</code>, чтобы отделить часть инициализации структуры, которую нужно сгенерировать. Также добавлено третье поле, для того, чтобы увидеть, какие изменения потребуется сейчас внести в код <code>initMemblock</code></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//аннотация того, что к структуре надо применить 2 макроса, добавляющий поля, и дебажный, отображающий все поля</span></span><br><span class="line">[memblock, dump_fields]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Memblock</span></span></span><br><span class="line"><span class="class">    <span class="title">a</span>:</span> <span class="keyword">int</span>?</span><br><span class="line">    b: <span class="keyword">float</span>?</span><br><span class="line">    c: <span class="keyword">int</span>?</span><br><span class="line"></span><br><span class="line"><span class="comment">//Шаблонный код инициализации, типовой для memblock-структур</span></span><br><span class="line"><span class="comment">//  необходимо научиться генерировать его, чтобы не писать руками для каждой структуры</span></span><br><span class="line"><span class="function">def <span class="title">initMemblock</span><span class="params">(var memblock: Memblock; aCount:<span class="keyword">int</span>; bCount:<span class="keyword">int</span>; cCount:<span class="keyword">int</span>)</span></span></span><br><span class="line">    memblock.a`count = aCount</span><br><span class="line">    memblock.b`count = bCount</span><br><span class="line">    memblock.c`count = cCount                                          <span class="comment">//новое</span></span><br><span class="line"></span><br><span class="line">    let aSize = typeinfo(<span class="keyword">sizeof</span> *memblock.a) * aCount</span><br><span class="line">    let bSize = typeinfo(<span class="keyword">sizeof</span> *memblock.b) * bCount</span><br><span class="line">    let cSize = typeinfo(<span class="keyword">sizeof</span> *memblock.c) * cCount                  <span class="comment">//новое</span></span><br><span class="line"></span><br><span class="line">    memblock.mem |&gt; resize(aSize + bSize + cSize)                      <span class="comment">//новое</span></span><br><span class="line"></span><br><span class="line">    unsafe</span><br><span class="line">        memblock.a = reinterpret&lt;<span class="keyword">int</span>?&gt; addr(memblock.mem[<span class="number">0</span>])</span><br><span class="line">        memblock.b = reinterpret&lt;<span class="keyword">float</span>?&gt; addr(memblock.mem[aSize])</span><br><span class="line">        memblock.c = reinterpret&lt;<span class="keyword">int</span>?&gt; addr(memblock.mem[aSize+bSize]) <span class="comment">//новое</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Пример использования структуры</span></span><br><span class="line">def fillMemblock(var memblock: Memblock)</span><br><span class="line">    unsafe</span><br><span class="line">        memblock.a[<span class="number">0</span>] = <span class="keyword">int</span>(<span class="number">0x11223344</span>)</span><br><span class="line">        memblock.a[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">        memblock.a[<span class="number">2</span>] = <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        memblock.b[<span class="number">0</span>] = reinterpret&lt;<span class="keyword">float</span>&gt;(<span class="number">0x55667788</span>)</span><br><span class="line">        memblock.b[<span class="number">1</span>] = <span class="number">0.0</span></span><br><span class="line">        memblock.b[<span class="number">2</span>] = <span class="number">123.456</span></span><br><span class="line"></span><br><span class="line">        memblock.c[<span class="number">0</span>] = <span class="keyword">int</span>(<span class="number">0xAABBCCDD</span>)</span><br><span class="line">        memblock.c[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">        memblock.c[<span class="number">2</span>] = <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Тест</span></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def test</span><br><span class="line">    unsafe</span><br><span class="line">        var memblock: Memblock</span><br><span class="line">        memblock |&gt; initMemblock(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>) <span class="comment">//кол-во аргументов конструктора, зависит от количества полей структуры</span></span><br><span class="line">        memblock |&gt; fillMemblock</span><br><span class="line">        print(<span class="string">"Memblock = &#123;memblock&#125;"</span>)</span><br></pre></td></tr></table></figure><p>Прежде, чем приступать к написанию макроса, генерирующего функцию <code>initMemblock</code>, стоит разобраться с парой примеров:</p><p><a href="https://github.com/GaijinEntertainment/daScript/blob/073bc29145207b39180069ae60f00ed43fad6ea7/examples/test/misc/gen_fields.das" target="_blank" rel="noopener">gen_field.das</a> — генерация функции, логгирующей создание полей структуры.</p><ul><li>Приведены два макроса <code>DumpFields</code> и <code>Dump2Fields</code>, работающие на различных стадиях (apply/finish), во время генерации структуры, и после окончания.</li><li>На момент написание заметки пример был сломан, для фикса необходимо убрать код, касающийся типа <code>EntityId</code> — видимо, пример выдран из какого-то более масштабного кода, и опредения то ли забыли перенести, то ли забыли добавить модуль, содержащий их.</li><li>флаг функции “<code>fn.flags |= FunctionFlags init</code>“ говорит компилятору о том, что функция должна быть вызвана сразу после генерации (я какое-то время тупил с тем, чтобы понять, на какой стадии компиляции, кто и почему её вызывает).</li></ul><p><a href="https://github.com/GaijinEntertainment/daScript/blob/073bc29145207b39180069ae60f00ed43fad6ea7/examples/test/misc/ast_print.das" target="_blank" rel="noopener">ast_print.das</a> - макрос, выводящий исходный текст на dascript переданного ему выражения на daScript.</p><ul><li>этот пример в репозитории тоже немного сломан (<a href="https://github.com/spiiin/dascript_macro_tutorial/blob/master/examples/ast_print.das" target="_blank" rel="noopener">Fixed version</a>)</li></ul><p>Теперь применим немного рекурсивной магии.</p><p>Этот макрос может быть очень полезным, если переделать его так, чтобы он печатал не исходный текст переданного ему выражения, а исходный текст МАКРОСА, генерирующего при выполнении само это выражение.</p><p>Это очень важная для упрощения метапрограммирования часть, поэтому повторю ещё раз. Вместо написания макроса, генерирующего функцию <code>initMemblock</code>, мы сначала напишем <strong><code>макрос ast_print_expression, который выведет на экран текст, который поможет нам написать макрос generateInitMemblockFunction, генерирующий функцию initMemblock</code></strong> (или любую другую функцию). Звучит запутанно, но это не так сложно, как кажется.<br>(всё, больше не буду повторять, язык сломать можно)</p><p>Модифицируем функцию <code>ast_print</code> так, чтобы она не просто печатала исходный текст переданного ей выражения, а дополнительно печатала тип каждого подвыражения (<code>Subexpression</code>) этого выражения.<br>Вот такая функция:<br><a href="https://github.com/spiiin/dascript_macro_tutorial/blob/master/examples/macro_print_ast.das" target="_blank" rel="noopener">ast_print_expression</a> (конечно, немного “наколенная”)</p><p>Теперь можно начать последовательно копировать типы подвыражений в макрос, генерирующий функцию <code>initMemblock</code>, постепенно модифицируя его так, чтобы добавлять параметры, позволяющие генерировать различные варианты этой функции.</p><p>Рабочий процесс на этом этапе удобно зациклить так:</p><ul><li>Модифицируем текст initMemblock</li><li>Перезапускаем компиляцию функции, чтобы макрос ast_print_expression применился к этой функции и вывел на экран выражение, в которое преобразуется функция</li><li>Копируем часть выражения в макрос generateInitMemblockFunction, который должен сгенерировать новую функцию initMemblock_generated, идентичную самой функции initMemblock</li><li>Модифицируем макрос generateInitMemblockFunction, чтобы добавить в него код, генерирующий переменную часть функции</li><li>Перекомпилируем функцию initMemblock_generated, чтобы применить к ней макрос ast_print, для того, чтобы получить исходный код функции и сверить его с исходный кодом initMemblock</li></ul><p>Выглядит запутанно, но это необходимо для того, чтобы иметь возможность выполнить шаг 4 - “переменная часть функции” — те строчки, которые изменяются в функции <code>initMemblock</code> после того, как мы изменяем какое-либо поле структуры <code>Memblock</code> (посмотрите исходный код функции <code>initMemblock</code> и отметки <code>//новое</code>, это строчки, которые добавились после добавления поля с именем <code>c</code> — это как раз эта “переменная часть функции”).</p><p>Самое интересное, что перевести программу в режим REPL практически элементарно, достаточно зациклить C++ часть самого первого туториала из репозитория daScript, перекомпилируя daScript-ы заново при вводе любого символа:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span>, <span class="keyword">char</span> * [] )</span> </span>&#123;</span><br><span class="line">    NEED_ALL_DEFAULT_MODULES;</span><br><span class="line">    Module::Initialize();</span><br><span class="line">    <span class="keyword">char</span> a = <span class="string">'x'</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        tutorial();</span><br><span class="line">        <span class="comment">//тут скорее всего надо не забыть очистить память, выделенную в цикле работы</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">    &#125;</span><br><span class="line">    Module::Shutdown();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Рабочий процесс выглядит примерно так:<br><img src="/blog/1547564887/memblock_example.png" alt="fox"><br>Слева код в <a href="https://marketplace.visualstudio.com/items?itemName=profelis.dascript-plugin" target="_blank" rel="noopener">Visual Studio Code</a>, справа программа, выполняющая этот код без необходимости перезапуска. После подготовки можно переходить и к генерации кода, с Repl-режимом это будет значительно проще.</p><h2 id="Генерация-функции-initMemblock"><a href="#Генерация-функции-initMemblock" class="headerlink" title="Генерация функции initMemblock"></a>Генерация функции initMemblock</h2><p>Макрос <code>ast_print_expression</code> применённый к функции initMemblock, выводит на экран:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">---das------------------<span class="comment">// [modifyExternal][modifyArgument]</span></span><br><span class="line"><span class="function">def <span class="title">initMemblock</span> <span class="params">( var memblock : Memblock -<span class="keyword">const</span>; aCount : <span class="keyword">int</span> <span class="keyword">const</span>; bCount : <span class="keyword">int</span> <span class="keyword">const</span>; cCount : <span class="keyword">int</span> <span class="keyword">const</span> )</span></span></span><br><span class="line">        ExprVar memblock. ExprField a`count ExprCopyRight = ExprVar aCount</span><br><span class="line">        ExprVar memblock. ExprField b`count ExprCopyRight = ExprVar bCount</span><br><span class="line">        ExprVar memblock. ExprField c`count ExprCopyRight = ExprVar cCount</span><br><span class="line">        ExprLet var  ExprLetVariable aSize : <span class="keyword">int</span> <span class="keyword">const</span> =  ExprOp2(ExprVar aCount ExprOp2Right * <span class="number">4</span>)</span><br><span class="line">        ExprLet var  ExprLetVariable bSize : <span class="keyword">int</span> <span class="keyword">const</span> =  ExprOp2(ExprVar bCount ExprOp2Right * <span class="number">4</span>)</span><br><span class="line">        ExprLet var  ExprLetVariable cSize : <span class="keyword">int</span> <span class="keyword">const</span> =  ExprOp2(ExprVar cCount ExprOp2Right * <span class="number">4</span>)</span><br><span class="line">        ExprCall __::builtin`resize( ExprCallArgument ExprVar memblock. ExprField mem, ExprCallArgument  ExprOp2( ExprOp2(ExprVar aSize ExprOp2Right + ExprVar bSize) ExprOp2Right + ExprVar cSize))</span><br><span class="line">        ExprVar memblock. ExprField a ExprCopyRight = ExprCast reinterpret&lt;<span class="keyword">int</span>?&gt;  VisitExprRef2Ptr addr(ExprVar memblock. ExprField mem ExprAtIndex[<span class="number">0</span>])</span><br><span class="line">        ExprVar memblock. ExprField b ExprCopyRight = ExprCast reinterpret&lt;<span class="keyword">float</span>?&gt;  VisitExprRef2Ptr addr(ExprVar memblock. ExprField mem ExprAtIndex[ExprVar aSize])</span><br><span class="line">        ExprVar memblock. ExprField c ExprCopyRight = ExprCast reinterpret&lt;<span class="keyword">int</span>?&gt;  VisitExprRef2Ptr addr(ExprVar memblock. ExprField mem ExprAtIndex[ ExprOp2(ExprVar aSize ExprOp2Right + ExprVar bSize)])</span><br><span class="line">        ExprCall init`struct`Memblock( ExprCallArgument ExprVar memblock, ExprCallArgument <span class="number">5</span>, ExprCallArgument <span class="number">5</span>, ExprCallArgument <span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>Здесь перед каждым daScript выражением показан тип этого выражения. Почти все типы выражений объявлены в заголовочных файлах <a href="https://github.com/GaijinEntertainment/daScript/tree/master/include/daScript/ast" target="_blank" rel="noopener">ast_*.h</a>.</p><blockquote><p>С определенного момента начинаешь ценить простые языки — вместо того, что изучать сложные и разрастающиеся правила языка, можно упростить их, чтобы ускорить изучение языка и сделать его более понятным, но при этом дать возможность задавать более сложные правила только в тех местах, где они действительно нужны программисту.</p></blockquote><p><strong><code>Работа с макросами сначала кажется сложной, но с какого-то момента понимаешь, что типичная программа содержит почти все распространённые типы выражений, и понимаешь, что вот они, все перед тобой, других, скрытых мелким шрифтом в примечаниях на 666-й странице стандарта, нет.</code></strong></p><p>Можно было бы пойти ещё дальше, и написать макрос, который выводит код, создающий выражение, но в образовательных целях можно попробовать для начала составить выражения вручную.</p><p>Для генерации функции нужно научиться генерировать строки 5 типов:</p><ul><li>Декларация функции <code>def initMemblock ( var memblock : Memblock, ...)</code></li><li>Присваивание  <code>memblock.a</code>count = aCount`</li><li>Объвление переменной <code>let aSize = typeinfo(sizeof *memblock.a) * aCount</code></li><li>Вызов функции <code>memblock.mem |&gt; resize(aSize + bSize + cSize)</code></li><li>Ещё одно присвание - <code>memblock.a = reinterpret&lt;int?&gt; addr(memblock.mem[0])</code></li></ul><p><strong><code>Декларация функции</code></strong></p><p>Практически готовый пример нужного кода есть в примерах из daScript-a <code>gen_field.das</code>.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">generateStructureFields</span><span class="params">(var st:StructurePtr)</span></span></span><br><span class="line"><span class="function">    <span class="comment">//create "mem" field of type array&lt;uint8&gt;</span></span></span><br><span class="line">    var uint8Type &lt;- new [[TypeDecl() baseType=Type tUInt8]]</span><br><span class="line">    var uint8ArrayType &lt;- <span class="keyword">new</span> [[TypeDecl() baseType=Type tArray, firstType &lt;- uint8Type]]</span><br><span class="line"></span><br><span class="line">    let fieldsLen = st.fields |&gt; length</span><br><span class="line">    var ptrsCount = <span class="number">0</span></span><br><span class="line">    var ptrsTypeIndexes : <span class="built_in">array</span>&lt;<span class="keyword">int</span>&gt;</span><br><span class="line">    ptrsTypeIndexes |&gt; reserve(fieldsLen)</span><br><span class="line">    <span class="keyword">for</span> i in range(<span class="number">0</span>, fieldsLen)</span><br><span class="line">        <span class="keyword">if</span> st.fields[i]._type.baseType == Type tPointer</span><br><span class="line">            ptrsCount++</span><br><span class="line">            ptrsTypeIndexes |&gt; push(i) <span class="comment">//сохраняем индексы полей-указателей</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//add one field for memblock and one field per pointer type to handle count of object per type</span></span><br><span class="line">    st.fields |&gt; resize(fieldsLen+ ptrsCount + <span class="number">1</span>)</span><br><span class="line">    st.fields[fieldsLen] := *<span class="keyword">new</span> [[ FieldDeclaration() name:=<span class="string">"mem"</span>, _type &lt;- uint8ArrayType]]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i in range(<span class="number">0</span>, ptrsCount)</span><br><span class="line">        let fieldCountName = <span class="string">"&#123;st.fields[ptrsTypeIndexes[i]].name&#125;&#123;"</span>`count<span class="string">"&#125;"</span></span><br><span class="line">        st.fields[fieldsLen+<span class="number">1</span>+i] := *<span class="keyword">new</span> [[ FieldDeclaration() name:=fieldCountName, _type &lt;- <span class="keyword">new</span> [[TypeDecl() baseType=Type tInt]]]]</span><br><span class="line">    <span class="keyword">return</span> &lt;-ptrsTypeIndexes</span><br><span class="line"></span><br><span class="line"><span class="comment">//--------------------------</span></span><br><span class="line"><span class="comment">// Генерация функции</span></span><br><span class="line">def generateStructureInitFunction(var st:StructurePtr; ptrsTypeIndexes:<span class="built_in">array</span>&lt;<span class="keyword">int</span>&gt;&amp;)</span><br><span class="line">    let ptrFieldsLen = ptrsTypeIndexes |&gt; length</span><br><span class="line"></span><br><span class="line">    let fnname = <span class="string">"init`struct`&#123;st.name&#125;"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//генерируем объявление функции с именем init`struct`ИмяСтрутуры</span></span><br><span class="line">    var fn &lt;- <span class="keyword">new</span> [[Function() at=st.at, atDecl=st.at, name:=fnname]]</span><br><span class="line">    fn.flags |= FunctionFlags generated</span><br><span class="line">    fn.flags |= FunctionFlags privateFunction</span><br><span class="line"></span><br><span class="line">    <span class="comment">//генерируем список аргументов и тип результата функции</span></span><br><span class="line">    unsafe</span><br><span class="line">        fn.arguments |&gt; emplace_new &lt;| <span class="keyword">new</span> [[Variable() at=st.at, name:= <span class="string">"memblock"</span>, _type &lt;- <span class="keyword">new</span> [[TypeDecl() baseType=Type tStructure, structType=addr(*st)]]]]</span><br><span class="line">    <span class="keyword">for</span> i in range(<span class="number">0</span>, ptrFieldsLen)</span><br><span class="line">        let argumentName = <span class="string">"&#123;st.fields[ptrsTypeIndexes[i]].name&#125;`count"</span></span><br><span class="line">        fn.arguments |&gt; emplace_new &lt;| <span class="keyword">new</span> [[Variable() at=st.at, name:= argumentName,  _type &lt;- <span class="keyword">new</span> [[TypeDecl() baseType=Type tInt]] ]]</span><br><span class="line">    fn.result &lt;- <span class="keyword">new</span> [[TypeDecl() baseType=Type tVoid, at=st.at]]</span><br><span class="line"></span><br><span class="line">    <span class="comment">//генерируем тело функции, пока просто вызов `print("Hello, world!")`</span></span><br><span class="line">    var blk &lt;- <span class="keyword">new</span> [[ExprBlock() at=st.at]]</span><br><span class="line">    var printF &lt;- <span class="keyword">new</span> [[ExprCall() name:=<span class="string">"print"</span>]]</span><br><span class="line">    printF.arguments |&gt; emplace_new &lt;| <span class="keyword">new</span> [[ExprConstString() value:=<span class="string">"Hello, world!\n"</span>]]</span><br><span class="line">    blk.<span class="built_in">list</span> |&gt; emplace(printF)</span><br><span class="line"></span><br><span class="line">    fn.body &lt;- blk</span><br><span class="line">    compiling_module() |&gt; add_function(fn)</span><br></pre></td></tr></table></figure><p>Теперь если сгенерировать макросом функцию, и передать эту функцию в макрос, который возвращает исходный текст функции, то получится такой результат:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">def init`<span class="class"><span class="keyword">struct</span>`<span class="title">Memblock</span> ( <span class="title">var</span> <span class="title">memblock</span> :</span> Memblock; var a`count : <span class="keyword">int</span>; var b`count : <span class="keyword">int</span>; var c`count : <span class="keyword">int</span> )</span><br><span class="line">    print(<span class="string">"Hello, world!"</span>,__context__)</span><br></pre></td></tr></table></figure><p><strong><code>Присваивание и объявление переменной</code></strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//-------------------------</span></span><br><span class="line"><span class="comment">//1. Make Expressions</span></span><br><span class="line"><span class="comment">//-------------------------</span></span><br><span class="line"><span class="comment">//memblock.a`count = aCount</span></span><br><span class="line"><span class="comment">//  ExprVar memblock. ExprField a`count ExprCopyRight = ExprVar aCount</span></span><br><span class="line">var exprVar_memblock &lt;- <span class="keyword">new</span> [[ExprVar() name:=<span class="string">"memblock"</span>]]</span><br><span class="line">var exprField_acount &lt;- <span class="keyword">new</span> [[ExprField() name:=<span class="string">"a`count"</span>, value &lt;- exprVar_memblock]]</span><br><span class="line">var exprVar_acount &lt;- <span class="keyword">new</span> [[ExprVar() name:=<span class="string">"a`count"</span>]]</span><br><span class="line">var exprCopy &lt;- <span class="keyword">new</span> [[ExprCopy() op:=<span class="string">"="</span>, left &lt;- exprField_acount, right &lt;- exprVar_acount]]</span><br><span class="line">blk.<span class="built_in">list</span> |&gt; emplace(exprCopy)</span><br></pre></td></tr></table></figure><p>Тут всё достаточно тривиально, пока составляем только первую строку “memblock.a`count = aCount”</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//-------------------------</span></span><br><span class="line"><span class="comment">//2. Quotes</span></span><br><span class="line"><span class="comment">//-------------------------</span></span><br><span class="line"><span class="comment">//let aSize = typeinfo(sizeof *memblock.a) * aCount</span></span><br><span class="line"><span class="comment">//  ExprLet var  ExprLetVariable aSize : int const =  ExprOp2(ExprVar aCount ExprOp2Right * 4)</span></span><br><span class="line">var exprLet_aSize_value &lt;- quote(</span><br><span class="line">    typeinfo(<span class="keyword">sizeof</span> * memblock.a) * a`count</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var exprLet_aSize &lt;- <span class="keyword">new</span> [[ExprLet()]]</span><br><span class="line">exprLet_aSize.variables |&gt; emplace_new() &lt;| <span class="keyword">new</span> [[Variable()</span><br><span class="line">    name := <span class="string">"aSize"</span>,</span><br><span class="line">    _type &lt;- <span class="keyword">new</span> [[TypeDecl() baseType=Type tInt]],</span><br><span class="line">    init &lt;- exprLet_aSize_value</span><br><span class="line">]]</span><br><span class="line">blk.<span class="built_in">list</span> |&gt; emplace(exprLet_aSize)</span><br><span class="line"></span><br><span class="line"><span class="comment">//prevent drop unused code</span></span><br><span class="line">var exprCall_printUnused &lt;- quote(</span><br><span class="line">    print(<span class="string">"&#123;aSize&#125;"</span>)</span><br><span class="line">)</span><br><span class="line">blk.<span class="built_in">list</span> |&gt; emplace(exprCall_printUnused)</span><br></pre></td></tr></table></figure><p>При генерации следующей строки можно заметить, что:</p><ul><li>макрос ast_print_expression не описал выражение “typeinfo(sizeof *memblock.a)”, а вместо этого вывел его результат. Это происходит потому, что макрос был применён к уже сгенерированной и оптимизированной функции, для которой часть выражений может быть вычислена компилятором.</li><li>макрос ast_print, применённый к сгенерированной функции, не показывает неиспользуемые переменные, так как они были выброшены компилятором, так что увидеть их можно, если добавить использование (print”{aSize}” в данном случае).</li></ul><p>Кроме генерации выражений, здесь показано использование макроса <code>quote</code>, который превращает код в выражение:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var exprLet_aSize_value &lt;- quote(</span><br><span class="line">    typeinfo(<span class="keyword">sizeof</span> * memblock.a) * a`count</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>Вот <a href="https://github.com/GaijinEntertainment/daScript/blob/726d440be7618fb431815b18e6f785c37a335d5d/examples/test/misc/template_example.das" target="_blank" rel="noopener">пример</a> (<a href="https://github.com/spiiin/dascript_macro_tutorial/blob/master/examples/template_example.das" target="_blank" rel="noopener">Fixed version</a>) более продвинутого использования цитирования, с возможностью задать правила переписывания выражения. Это можно использовать для того, чтобы перейти от явного указания названия поля структуры к переменной, в которую можно передать любое имя или выражение:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">require daslib/templates</span><br><span class="line">require daslib/templates_boost</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------</span></span><br><span class="line"><span class="comment">//2. Quotes and templates</span></span><br><span class="line"><span class="comment">//-------------------------</span></span><br><span class="line"><span class="comment">//let aSize = typeinfo(sizeof *memblock.a) * aCount</span></span><br><span class="line"><span class="comment">//  ExprLet var  ExprLetVariable aSize : int const =  ExprOp2(ExprVar aCount ExprOp2Right * 4)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">for</span> i in <span class="title">range</span><span class="params">(<span class="number">0</span>, ptrFieldsLen)</span></span></span><br><span class="line"><span class="function">    let argumentName </span>= <span class="string">"&#123;st.fields[ptrsTypeIndexes[i]].name&#125;"</span></span><br><span class="line">    var exprLet_aSize_value &lt;- quote(</span><br><span class="line">        typeinfo(<span class="keyword">sizeof</span> *ELEMENT) * ELEMENTS_COUNT</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    var exprVar_memblock2 &lt;- <span class="keyword">new</span> [[ExprVar() name:=<span class="string">"memblock"</span>]]</span><br><span class="line">    var exprField_acount2 &lt;- <span class="keyword">new</span> [[ExprField() name:=argumentName, value &lt;- exprVar_memblock2]]</span><br><span class="line"></span><br><span class="line">    var exprLet_rules : Template                                               <span class="comment">//правила переписывания выражения</span></span><br><span class="line">    exprLet_rules |&gt; replaceVariable(<span class="string">"ELEMENT"</span>, exprField_acount2)             <span class="comment">//подставляем выражение</span></span><br><span class="line">    exprLet_rules |&gt; renameVariable(<span class="string">"ELEMENTS_COUNT"</span>, <span class="string">"&#123;argumentName&#125;`count"</span>)  <span class="comment">//подставляем имя переменной</span></span><br><span class="line">    apply_template(exprLet_rules, exprLet_aSize_value.at, exprLet_aSize_value)</span><br><span class="line">    </span><br><span class="line">    var exprLet_aSize &lt;- <span class="keyword">new</span> [[ExprLet()]]</span><br><span class="line">    exprLet_aSize.variables |&gt; emplace_new() &lt;| <span class="keyword">new</span> [[Variable()</span><br><span class="line">        name := <span class="string">"&#123;argumentName&#125;Size"</span>,</span><br><span class="line">        _type &lt;- <span class="keyword">new</span> [[TypeDecl() baseType=Type tInt]],</span><br><span class="line">        init &lt;- exprLet_aSize_value</span><br><span class="line">    ]]</span><br><span class="line">    blk.<span class="built_in">list</span> |&gt; emplace(exprLet_aSize)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Временно руками добавляем код использования переменных, чтобы их не отбросил компилятор</span></span><br><span class="line">    var exprCall_printUnused &lt;- quote(</span><br><span class="line">        print(<span class="string">"&#123;aSize&#125;,&#123;bSize&#125;,&#123;cSize&#125;"</span>)</span><br><span class="line">    blk.<span class="built_in">list</span> |&gt; emplace(exprCall_printUnused)</span><br></pre></td></tr></table></figure><p>Половина кода генерации написана, нужно двигаться дальше.</p><p><strong><code>Вызов функции memblock.mem |&gt; resize(aSize + bSize + cSize)</code></strong></p><p>Здесь есть небольшая хитрость. Строка <code>aSize + bSize + cSize</code>, трансформируется в выражение:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ExprOp2( ExprOp2(ExprVar aSize ExprOp2Right + ExprVar bSize) ExprOp2Right + ExprVar cSize))</span><br></pre></td></tr></table></figure></p><p>У выражения есть определённый шаблон:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">((((a+b)+c)+d)+...)</span><br></pre></td></tr></table></figure></p><p>Подобные выражения удобно сгенерировать с помощью функции <a href="https://en.wikipedia.org/wiki/Fold_(higher-order_function" target="_blank" rel="noopener">свёртки</a>). Я зачём-то использовал правостороннюю свёртку, но для ассоциативных операторов конечный результат будет одинаковым (не нашёл готовой в стандартной библиотеке):</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">foldR</span><span class="params">(var a:<span class="built_in">array</span>&lt;ExpressionPtr&gt;; foldOp:function&lt;(arg1, arg2: ExpressionPtr) : ExpressionPtr&gt; )</span></span></span><br><span class="line"><span class="function">    let aLen </span>= a |&gt; length</span><br><span class="line">    var from &lt;- a[aLen<span class="number">-1</span>]</span><br><span class="line">    <span class="function"><span class="keyword">for</span> i in <span class="title">range</span><span class="params">(<span class="number">1</span>, aLen)</span></span></span><br><span class="line"><span class="function">        from :</span>= foldOp |&gt; invoke(a[aLen<span class="number">-1</span>-i], from)</span><br><span class="line">    <span class="keyword">return</span> from</span><br><span class="line"></span><br><span class="line">def makeSumExpr(a, b: ExpressionPtr <span class="keyword">const</span>): ExpressionPtr</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> [[ExprOp2() op:=<span class="string">"+"</span>, left := a, right := b]]</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------</span></span><br><span class="line"><span class="comment">// 3. Foldr</span></span><br><span class="line"><span class="comment">//-------------------------</span></span><br><span class="line"><span class="comment">//memblock.mem |&gt; resize(aSize + bSize + cSize)</span></span><br><span class="line"><span class="comment">//     ExprCall __::builtin`resize( ExprCallArgument ExprVar memblock. ExprField mem, ExprCallArgument  ExprOp2( ExprOp2(ExprVar aSize ExprOp2Right + ExprVar bSize) ExprOp2Right + ExprVar cSize))</span></span><br><span class="line"></span><br><span class="line">var sumArgumentsArray: <span class="built_in">array</span>&lt;ExpressionPtr&gt;</span><br><span class="line"><span class="keyword">for</span> i in range(<span class="number">0</span>, ptrFieldsLen) </span><br><span class="line">    let argumentName = <span class="string">"&#123;st.fields[ptrsTypeIndexes[i]].name&#125;"</span></span><br><span class="line">    let nameSize := <span class="string">"&#123;argumentName&#125;Size"</span></span><br><span class="line">    sumArgumentsArray |&gt; emplace(<span class="keyword">new</span> [[ExprVar() name:=nameSize]])</span><br><span class="line">var sumExpr &lt;- foldR(sumArgumentsArray, @@makeSumExpr) <span class="comment">//ага, свёртка массива в выражение</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//--------</span></span><br><span class="line">var exprLet_totalSize &lt;- <span class="keyword">new</span> [[ExprLet()]]</span><br><span class="line">exprLet_totalSize.variables |&gt; emplace_new() &lt;| <span class="keyword">new</span> [[Variable()</span><br><span class="line">    name := <span class="string">"totalSize"</span>,</span><br><span class="line">    _type &lt;- <span class="keyword">new</span> [[TypeDecl() baseType=Type tInt]],</span><br><span class="line">    init &lt;- sumExpr</span><br><span class="line">]]</span><br><span class="line">blk.<span class="built_in">list</span> |&gt; emplace(exprLet_totalSize)</span><br><span class="line"><span class="comment">//prevent drop unused code</span></span><br><span class="line">var exprCall_printUnused2 &lt;- quote(</span><br><span class="line">    print(<span class="string">"&#123;totalSize&#125;"</span>)</span><br><span class="line">)</span><br><span class="line">blk.<span class="built_in">list</span> |&gt; emplace(exprCall_printUnused2)</span><br><span class="line"></span><br><span class="line"><span class="comment">//сгенерирует код:</span></span><br><span class="line"><span class="comment">//let totalSize : int = (aSize + (bSize + cSize))</span></span><br><span class="line"><span class="comment">//__::builtin`resize(memblock.mem,totalSize)</span></span><br></pre></td></tr></table></figure><p>(__::builtin`resize здесь просто замангленное название встроенной функции resize)</p><p><strong><code>memblock.a = reinterpret&lt;int?&gt; addr(memblock.mem[0])</code></strong></p><p>Можно немного изменить функцию <code>foldr</code>, чтобы она могла генерировать частичные суммы для получения кода вида:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">memblock.a = reinterpret&lt;<span class="keyword">int</span>?&gt; addr(memblock.mem[<span class="number">0</span>])</span><br><span class="line">memblock.b = reinterpret&lt;<span class="keyword">float</span>?&gt; addr(memblock.mem[(aSize + <span class="number">0</span>)])</span><br><span class="line">memblock.c = reinterpret&lt;<span class="keyword">int</span>?&gt; addr(memblock.mem[(aSize + (bSize + <span class="number">0</span>))])</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//теперь можно задать, какую часть массива превратить в выражение</span></span><br><span class="line"><span class="function">def <span class="title">foldR_partial</span><span class="params">(var a:<span class="built_in">array</span>&lt;ExpressionPtr&gt;; foldOp:function&lt;(arg1, arg2: ExpressionPtr) : ExpressionPtr&gt;; initial: ExpressionPtr; endIndex:<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">    let aLen </span>= a |&gt; length</span><br><span class="line">    var from := initial</span><br><span class="line">    <span class="keyword">for</span> i in range(endIndex, aLen)</span><br><span class="line">        from := foldOp |&gt; invoke(a[aLen<span class="number">-1</span>-i], from)</span><br><span class="line">    <span class="keyword">return</span> from</span><br><span class="line"></span><br><span class="line">var exprCall_resize &lt;- quote(</span><br><span class="line">        memblock.mem |&gt; resize(totalSize)</span><br><span class="line">    )</span><br><span class="line">    blk.<span class="built_in">list</span> |&gt; emplace(exprCall_resize)</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------</span></span><br><span class="line"><span class="comment">// 4. castType</span></span><br><span class="line"><span class="comment">//-------------------------</span></span><br><span class="line"><span class="comment">//memblock.a = reinterpret&lt;int?&gt; addr(memblock.mem[0])</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i in range(<span class="number">0</span>, ptrFieldsLen)</span><br><span class="line">    let argumentName = <span class="string">"&#123;st.fields[ptrsTypeIndexes[i]].name&#125;"</span></span><br><span class="line">    var exprVar_memblock &lt;- <span class="keyword">new</span> [[ExprVar() name:=<span class="string">"memblock"</span>]]</span><br><span class="line">    var exprField_a &lt;- <span class="keyword">new</span> [[ExprField() name:=argumentName, value &lt;- exprVar_memblock]]</span><br><span class="line">    var exprAddr &lt;- quote(</span><br><span class="line">        addr(memblock.mem[START_ADDRESS])</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    var exprZero &lt;- <span class="keyword">new</span> [[ExprConstInt() value=<span class="number">0</span>]]</span><br><span class="line">    var exprStartAddress &lt;- foldR_partial(sumArgumentsArray, @@makeSumExpr, exprZero, ptrFieldsLen-i)</span><br><span class="line">    var exprAddr_rules : Template</span><br><span class="line">    exprAddr_rules |&gt; replaceVariable(<span class="string">"START_ADDRESS"</span>, exprStartAddress)</span><br><span class="line">    apply_template(exprAddr_rules, exprAddr.at, exprAddr)</span><br><span class="line"></span><br><span class="line">    var exprReinterpretCast&lt;- <span class="keyword">new</span> [[ExprCast() </span><br><span class="line">        castType := st.fields[ptrsTypeIndexes[i]]._type,</span><br><span class="line">        castFlags = ExprCastFlags reinterpretCast,</span><br><span class="line">        subexpr &lt;- exprAddr]]</span><br><span class="line">    </span><br><span class="line">    var exprUnsafe&lt;- <span class="keyword">new</span> [[ExprUnsafe() body &lt;- exprReinterpretCast]]</span><br><span class="line">    var exprCopy &lt;- <span class="keyword">new</span> [[ExprCopy() op:=<span class="string">"="</span>, left &lt;- exprField_a, right &lt;- exprUnsafe]]</span><br><span class="line">    blk.<span class="built_in">list</span> |&gt; emplace(exprCopy)</span><br></pre></td></tr></table></figure><p>Все части генерации, составленные вместе, генерируют теперь такую функцию:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">def init`<span class="class"><span class="keyword">struct</span>`<span class="title">Memblock</span> ( <span class="title">var</span> <span class="title">memblock</span> :</span> Memblock; var a`count : <span class="keyword">int</span>; var b`count : <span class="keyword">int</span>; var c`count : <span class="keyword">int</span> )</span><br><span class="line">        memblock.a`count = a`count</span><br><span class="line">        memblock.b`count = b`count</span><br><span class="line">        memblock.c`count = c`count</span><br><span class="line">        let aSize : <span class="keyword">int</span> = (a`count * <span class="number">4</span>)</span><br><span class="line">        let bSize : <span class="keyword">int</span> = (b`count * <span class="number">4</span>)</span><br><span class="line">        let cSize : <span class="keyword">int</span> = (c`count * <span class="number">4</span>)</span><br><span class="line">        let totalSize : <span class="keyword">int</span> = (aSize + (bSize + cSize))</span><br><span class="line">        __::builtin`resize(memblock.mem,totalSize)</span><br><span class="line">        memblock.a = reinterpret&lt;<span class="keyword">int</span>?&gt; addr(memblock.mem[<span class="number">0</span>])</span><br><span class="line">        memblock.b = reinterpret&lt;<span class="keyword">float</span>?&gt; addr(memblock.mem[(aSize + <span class="number">0</span>)])</span><br><span class="line">        memblock.c = reinterpret&lt;<span class="keyword">int</span>?&gt; addr(memblock.mem[(aSize + (bSize + <span class="number">0</span>))])</span><br></pre></td></tr></table></figure></p><p>Сгенерированная функция делает то же, что и написанная руками. Но разница в том, что для любых новых типов структур больше не нужно писать код объявления полей и инициализации руками совсем!</p><h2 id="Наследование"><a href="#Наследование" class="headerlink" title="Наследование"></a>Наследование</h2><p>Теперь можно использовать макрос, чтобы сгенерировать поля структуры и конструктор:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[memblock]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Memblock</span></span></span><br><span class="line"><span class="class">    <span class="title">a</span>:</span> <span class="keyword">int</span>?</span><br><span class="line">    b: <span class="keyword">float</span>?</span><br><span class="line">    c: <span class="keyword">int</span>?</span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def test</span><br><span class="line">    unsafe</span><br><span class="line">        var memblock: Memblock</span><br><span class="line">        memblock |&gt; init`<span class="class"><span class="keyword">struct</span>`<span class="title">Memblock</span>(5,5,5)</span></span><br><span class="line"><span class="class">        <span class="title">memblock</span> |&gt; <span class="title">fillMemblock</span></span></span><br><span class="line"><span class="class">        <span class="title">print</span>("<span class="title">Memblock</span> = &#123;</span>memblock&#125;\n<span class="string">")</span></span><br></pre></td></tr></table></figure></p><p>Всё работает как задумано (реальный код потребовал бы ещё некоторых доработок, вроде добавления паддинга для выравнивания полей в блоке памяти, а также обёрток для того, чтобы скрыть необходимость unsafe доступа к полям, раз уж границы массивов известны).</p><p>Но что будет, если отнаследоваться от такой структуры?</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vec2</span></span></span><br><span class="line"><span class="class">    <span class="title">x</span>, <span class="title">y</span> :</span> <span class="keyword">float</span></span><br><span class="line"></span><br><span class="line">[memblock, dump_fields]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Memblock</span></span></span><br><span class="line"><span class="class">    <span class="title">a</span>:</span> <span class="keyword">int</span>?</span><br><span class="line">    b: <span class="keyword">float</span>?</span><br><span class="line">    c: <span class="keyword">int</span>?</span><br><span class="line">    d: Vec2?</span><br><span class="line"></span><br><span class="line">[memblock, dump_fields]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MemblockInheritor</span> :</span> Memblock</span><br><span class="line">    e: <span class="keyword">int</span>?</span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def test</span><br><span class="line">    unsafe</span><br><span class="line">        var memblock: Memblock</span><br><span class="line">        memblock |&gt; init`<span class="class"><span class="keyword">struct</span>`<span class="title">Memblock</span>(5,5,5,1)</span></span><br><span class="line"><span class="class">        <span class="title">memblock</span> |&gt; <span class="title">fillMemblock</span></span></span><br><span class="line"><span class="class">        <span class="title">print</span>("<span class="title">Memblock</span> = &#123;</span>memblock&#125;\n<span class="string">")</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        var memblock2: MemblockInheritor</span></span><br><span class="line"><span class="string">        //memblock2 |&gt; fillMemblock</span></span><br><span class="line"><span class="string">        memblock2 |&gt; init`struct`MemblockInheritor(5,5,5,1,10)</span></span><br><span class="line"><span class="string">        print("</span>Memblock2 = &#123;memblock2&#125;\n<span class="string">")</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//out:</span></span><br><span class="line"><span class="string">struct Memblock &#123;</span></span><br><span class="line"><span class="string">        int32_t * a;</span></span><br><span class="line"><span class="string">        float * b;</span></span><br><span class="line"><span class="string">        int32_t * c;</span></span><br><span class="line"><span class="string">        Vec2 * d;</span></span><br><span class="line"><span class="string">        TArray&lt;uint8_t&gt; mem;</span></span><br><span class="line"><span class="string">        int32_t a`count;</span></span><br><span class="line"><span class="string">        int32_t b`count;</span></span><br><span class="line"><span class="string">        int32_t c`count;</span></span><br><span class="line"><span class="string">        int32_t d`count;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">struct MemblockInheritor &#123;</span></span><br><span class="line"><span class="string">        int32_t * a;</span></span><br><span class="line"><span class="string">        float * b;</span></span><br><span class="line"><span class="string">        int32_t * c;</span></span><br><span class="line"><span class="string">        Vec2 * d;</span></span><br><span class="line"><span class="string">        TArray&lt;uint8_t&gt; mem;</span></span><br><span class="line"><span class="string">        int32_t a`count;</span></span><br><span class="line"><span class="string">        int32_t b`count;</span></span><br><span class="line"><span class="string">        int32_t c`count;</span></span><br><span class="line"><span class="string">        int32_t d`count;</span></span><br><span class="line"><span class="string">        int32_t * e;</span></span><br><span class="line"><span class="string">        TArray&lt;uint8_t&gt; mem;</span></span><br><span class="line"><span class="string">        int32_t a`count;</span></span><br><span class="line"><span class="string">        int32_t b`count;</span></span><br><span class="line"><span class="string">        int32_t c`count;</span></span><br><span class="line"><span class="string">        int32_t d`count;</span></span><br><span class="line"><span class="string">        int32_t e`count;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>Ауч, все поля в наследнике продублированы. Обработка объявления наследования в языке реализована как копирование деклараций всех полей структуры-предка в дочернюю (можно порыться в документации, или написать макрос, который покажет, что происходит).</p><p>Возможно реализовать пару стратегий правильного размещения полей наследника в памяти:</p><ul><li>каким-либо образом пометить, что базовая структура имеет сгенерированные поля, и добавить только новые</li><li>каким-либо образом пометить поля структуры-предка, удалить их, и перестроить всю структуру заново</li></ul><p>Для пометки полей можно использовать аннотации типов (пример — <a href="https://github.com/borisbat/dasBGFX/blob/a1e10ab439e5996a0a4d8722689e2b0fab4e72d9/examples/01_hello_triangle.das#L7" target="_blank" rel="noopener">аннотации типов шейдеров</a>).</p><p>Простой макрос, который проверяет список аннотаций типа:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">checkFields</span><span class="params">(var st:StructurePtr)</span></span></span><br><span class="line">    for field in st.fields</span><br><span class="line">        var memblockAnnExist = find_arg(<span class="string">"in_memblock"</span>, field.annotation) ?as tBool ?? <span class="literal">false</span></span><br><span class="line">        <span class="keyword">if</span> memblockAnnExist</span><br><span class="line">            print(<span class="string">"\t[in_memblock]\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//можно добавить аннотацию типа</span></span><br><span class="line"> st.fields[i].annotation |&gt; add_annotation_argument(<span class="string">"in_memblock"</span>, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure></p><p>Теперь можно реализовать логику добавления новых полей в уже существующий мемблок, а также генерацию конструктора с правильным количестом полей:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vec2</span></span></span><br><span class="line"><span class="class">    <span class="title">x</span>, <span class="title">y</span> :</span> <span class="keyword">float</span></span><br><span class="line"></span><br><span class="line">[memblock, dump_fields]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Memblock</span></span></span><br><span class="line"><span class="class">    <span class="title">a</span>:</span> <span class="keyword">int</span>?</span><br><span class="line">    b: <span class="keyword">float</span>?</span><br><span class="line">    c: <span class="keyword">int</span>?</span><br><span class="line">    d: Vec2?</span><br><span class="line"></span><br><span class="line">[memblock, dump_fields]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MemblockInheritor</span> :</span> Memblock</span><br><span class="line">    e: <span class="keyword">int</span>?</span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">fillMemblock</span><span class="params">(var memblock: Memblock)</span></span></span><br><span class="line"><span class="function">    unsafe</span></span><br><span class="line">        memblock.a[0] = int(0x11223344)</span><br><span class="line">        memblock.a[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">        memblock.a[<span class="number">2</span>] = <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        memblock.b[<span class="number">0</span>] = reinterpret&lt;<span class="keyword">float</span>&gt;(<span class="number">0x55667788</span>)</span><br><span class="line">        memblock.b[<span class="number">1</span>] = <span class="number">0.0</span></span><br><span class="line">        memblock.b[<span class="number">2</span>] = <span class="number">123.456</span></span><br><span class="line"></span><br><span class="line">        memblock.c[<span class="number">0</span>] = <span class="keyword">int</span>(<span class="number">0xAABBCCDD</span>)</span><br><span class="line">        memblock.c[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">        memblock.c[<span class="number">2</span>] = <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def test</span><br><span class="line">    unsafe</span><br><span class="line">        var memblock: Memblock</span><br><span class="line">        memblock |&gt; init`struct`Memblock(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">1</span>)</span><br><span class="line">        memblock |&gt; fillMemblock</span><br><span class="line">        print(<span class="string">"Memblock = &#123;memblock&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line">        var memblock2: MemblockInheritor</span><br><span class="line">        <span class="comment">//memblock2 |&gt; fillMemblock</span></span><br><span class="line">        memblock2 |&gt; init`struct`MemblockInheritor(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line">        print(<span class="string">"Memblock2 = &#123;memblock2&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Вывод:</span></span><br><span class="line">struct Memblock &#123;</span><br><span class="line">        <span class="keyword">int32_t</span> * a;</span><br><span class="line">        <span class="keyword">float</span> * b;</span><br><span class="line">        <span class="keyword">int32_t</span> * c;</span><br><span class="line">        Vec2 * d;</span><br><span class="line">        TArray&lt;<span class="keyword">uint8_t</span>&gt; mem;</span><br><span class="line">        <span class="keyword">int32_t</span> a`count;</span><br><span class="line">        <span class="keyword">int32_t</span> b`count;</span><br><span class="line">        <span class="keyword">int32_t</span> c`count;</span><br><span class="line">        <span class="keyword">int32_t</span> d`count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MemblockInheritor</span> &#123;</span></span><br><span class="line">        <span class="keyword">int32_t</span> * a;</span><br><span class="line">        <span class="keyword">float</span> * b;</span><br><span class="line">        <span class="keyword">int32_t</span> * c;</span><br><span class="line">        Vec2 * d;</span><br><span class="line">        TArray&lt;<span class="keyword">uint8_t</span>&gt; mem;</span><br><span class="line">        <span class="keyword">int32_t</span> a`count;</span><br><span class="line">        <span class="keyword">int32_t</span> b`count;</span><br><span class="line">        <span class="keyword">int32_t</span> c`count;</span><br><span class="line">        <span class="keyword">int32_t</span> d`count;</span><br><span class="line">        <span class="keyword">int32_t</span> * e;</span><br><span class="line">        <span class="keyword">int32_t</span> e`count;</span><br><span class="line">&#125;</span><br><span class="line">Memblock = [[ <span class="number">287454020</span>; <span class="number">15837566074880.000000000</span>; <span class="number">-1430532899</span>; [[ <span class="number">0.000000000</span>; <span class="number">0.000000000</span>]]; [[ <span class="number">0x44</span>; <span class="number">0x33</span>; <span class="number">0x22</span>; <span class="number">0x11</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0xff</span>; <span class="number">0xff</span>; <span class="number">0xff</span>; <span class="number">0xff</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x88</span>; <span class="number">0x77</span>; <span class="number">0x66</span>; <span class="number">0x55</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x79</span>; <span class="number">0xe9</span>; <span class="number">0xf6</span>; <span class="number">0x42</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0xdd</span>; <span class="number">0xcc</span>; <span class="number">0xbb</span>; <span class="number">0xaa</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0xff</span>; <span class="number">0xff</span>; <span class="number">0xff</span>; <span class="number">0xff</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>]]; <span class="number">5</span>; <span class="number">5</span>; <span class="number">5</span>; <span class="number">1</span>]]</span><br><span class="line">Memblock2 = [[ <span class="number">0</span>; <span class="number">0.000000000</span>; <span class="number">0</span>; [[ <span class="number">0.000000000</span>; <span class="number">0.000000000</span>]]; [[ <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>]]; <span class="number">5</span>; <span class="number">5</span>; <span class="number">5</span>; <span class="number">1</span>; <span class="number">0</span>; <span class="number">10</span>]]</span><br></pre></td></tr></table></figure><h2 id="Финал"><a href="#Финал" class="headerlink" title="Финал"></a>Финал</h2><p>С данным макросом можно продолжать играться, делая его всё круче, но примерно на этом этапе можно сказать, что исходная задача решена.</p><p>Макросы добавляют в язык способ серьёзно модифицировать код и данные по правилам, которые захочет реализовать программист. При этом разница между тривиальной структурой и “продвинутой” с точки зрения клиентского кода — всего одна аннотация.</p><p>Для сравнения с C++, например <a href="https://youtu.be/gVGtNFg4ay0" target="_blank" rel="noopener">доклад  Louis Dionne</a> про реализацию библиотеки, позволяющей переопределить способ реализации полиморфизма. Без макросов невозможно реализовать идею синтаксически так, чтобы это выглядело как наследование — в компиляторе жёстко прошиты правила того, что сгенерирует комплиятор при наследовании одной структуры от другой.</p><p>Естественно, что макросы — это не средство повседневного решения задач. Скорее это средство для того, чтобы лучше “подстроить” язык под предметную область, и уменьшить количество рукописного рутинного кода, не относящего непосредственно к решаемой задаче.</p><p>Для <code>daScript</code> предметная область — это разработка игр, и, возможно, макросы позволят ему уйти далеко вперед по сравнению с тем, что умели делать любые другие скриптовые языки для игр раньше.</p><p><a href="https://github.com/spiiin/dascript_macro_tutorial" target="_blank" rel="noopener">https://github.com/spiiin/dascript_macro_tutorial</a> - репозиторий с кодом из заметки:<br>    <code>/src_dirty</code> — можно посмотреть диффами между парами файлов эволюцию примера из статьи. Хостом для выполнения может послужить tutorial01 - базовый пример работы с языком из официального репозитория. В остальном — непричёсанный код.<br>    <code>/examples</code> — пофикшенные примеры макросов из официального репозитория.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://dascript.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;daScript&lt;/a&gt; - скриптовый язык для игр от Gaijin Entertaiment.&lt;/p&gt;
&lt;p&gt;После нескольких дней изучения понял, что испытываю интерес и хороший страх по отношению к этому языку. Такой, как если бы нашёл лазерную указку и решил поиграть с котом, но понял, что этой указкой можно легко резать металл. &lt;/p&gt;
&lt;p&gt;Гайдзины делают не замену &lt;code&gt;Lua&lt;/code&gt;, они делают замену &lt;code&gt;C++&lt;/code&gt;! Точнее даже, не “делают”, а практически “сделали”, язык сейчас находится в версии 0.2, но полноценно используется ими в продакшене в &lt;code&gt;Warthunder&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Доклад и документация акцентируют внимание на быстродействии языка и возможности серьёзных изменений без перезапуска игры, но только вскользь упоминают о мощных возможностях макросов. Так что я решил попробовать решить задачку, требующую их использования. Это моя первая программа на &lt;code&gt;daScript&lt;/code&gt;, после трёх дней изучения, так что где-то возможны и неизбежны косяки.&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="dascript" scheme="http://spiiin.github.io/tags/dascript/"/>
    
  </entry>
  
  <entry>
    <title>С++ в геймдеве</title>
    <link href="http://spiiin.github.io/blog/1728194429/"/>
    <id>http://spiiin.github.io/blog/1728194429/</id>
    <published>2022-01-30T12:58:23.000Z</published>
    <updated>2022-08-01T12:28:20.174Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Немного о том, почему в геймдеве используется C++, как именно он используется, и всё ли с этим правильно.<br><a id="more"></a></p><h1 id="Почему"><a href="#Почему" class="headerlink" title="Почему"></a>Почему</h1><p>Тут всё просто — потому что:</p><ul><li>Вендоры платформ предлагают некоторый готовый API на уже выбранном языке, использовать что-то альтернативное — дополнительные затраты</li><li>Игры часто портируют на различные платформы, C (или подмножество C++) - это подмножество, которое можно использовать, чтобы переписывать минимальное количество кода</li><li>Компиляторы C оптимизировались годами, на нём можно писать быстрый код, и использовать его как подмножество С++, там где нужна скорость</li></ul><h1 id="Как-используется"><a href="#Как-используется" class="headerlink" title="Как используется"></a>Как используется</h1><p>Я бы выделил в типичной игре, написанной на C++, три “стиля” кода - низкоуровневый, стандартный, и высокоуровневый.</p><p>(Тим Суини в презентации <a href="https://www.st.cs.uni-saarland.de/edu/seminare/2005/advanced-fp/docs/sweeny.pdf" target="_blank" rel="noopener">The Next Mainstream Programming Language</a> в презентации 2010 года, выделяет в отдельную группу так же код шейдеров на HLSL/GLSL, но это уже не C++).</p><h2 id="Низкоуровневый-C"><a href="#Низкоуровневый-C" class="headerlink" title="Низкоуровневый C++"></a>Низкоуровневый C++</h2><p>Используется там, где нужны какие-либо быстрые Numeric Computation - вычисления с большими объёмами данных. Примеры задач:</p><ul><li>Обход графа сцены</li><li>Симуляция физики, определений столкновений</li><li>Легковесная система задач для получения выгоды от использования нескольких процессоров</li><li>Системы анимации 3D персонажей</li><li>Куллинг, отправка данных на отрисовку</li><li>Системы частиц</li><li>Использование особенностей железа - повышение cache locality, пакинг данных в структуры</li><li>Тяжёлые алгоритмы рендеринга (частично решаются не на C++)</li></ul><p>Часто (но не всегда) является “инлайнингом си”, неотделимым от обычного кода. Это бывает как удобным (практически тот же синтаксис), так и не очень — сложнее не допустить в такой код низкоквалифицированного программиста, и почти невозможно запретить использование отдельных синтаксических возможностей языка.</p><p>Суини на примере <code>Gear of War</code> приводит такое разделение:<br><code>LoC</code> - 50%/50% - половина кода на “обычном c++” (стандартный + высокоуровневый по моему разделению), половина на низкоуровневом. Для менее требовательных к ресурсам игр (типа мобильных казуалок), я бы привёл цифру в 10-20% на низкоуровевый код.<br><code>Использование CPU</code> - 10% времени процессор выполняет код написанный на обычном уровне (игровая логика + скрипты), 90% - на требовательные к скорости рассчёты.<br><code>Производительность кода</code> - низкоуровневый код в среднем в 10 раз быстрее стандартного.</p><p>Код на C неидеален, но удобен в том плане, что не нужно переключаться на другой синтаксис или явно инлайнить его какой-либо директивой. Поэтому другие языки, которые стремятся стать “лучшим С”, иногда поддерживают транспиляцию в C — сгенерированный C код может быть быстрее, чем средний код, написанный человеком (так же, как компилятор может сгенерировать более быстрый машинный код, чем средний программист написать на ассемблере), и можно получить переносимость на все платформы, для которых есть компилятор C.</p><p>Минусы других языков в том, что они 1) не “инлайнятся” в C++-код 2) требуют особой обработки для фич, недоступных в C++, чтобы взаимодействовать с ним (что-то вроде отметок unsafe для такого кода). Ну и не имеют столь тесной интеграции с C++, низкоуровневый код — это не обязательно исключительно код на C, можно сочетать “С с элементами C++”/“С++ с элементами С” в любых пропорциях. Быстрый низкоуровневый код получается в случаях, когда программист более-менее представляет, во что он скомпилируется.</p><p>Вообщем, C++ - не столько быстрый язык, сколько язык с возможностью хорошо контроллировать производительность получаемого кода там, где это требуется.</p><h2 id="Стандартный-C"><a href="#Стандартный-C" class="headerlink" title="Стандартный C++"></a>Стандартный C++</h2><p>Это код, написанный “по заветам классиков”. Задачи, решаемые на “стандартном” уровне:</p><ul><li>“Связка” используемых библиотек и языков: ~10-20 middleware библиотек, связка с хост-языком операционной системы (Java с JNI, Objective C++ с “инлайном С++” для мобилок), вызовы скриптовых языков, для которых хостом является игра</li><li>Высокоуровневая архитектура приложения (Object Oriented Design, Data Oriented Design, паттерны проектирования)</li><li>Написание кода, устойчивого к ошибкам (утечки памяти, использование освобожденной памяти, разыменование кривых указателей, неинициализированные переменные, выходы за границы массивов и прочее прелести)</li><li>Описание игровой логики</li><li>Вызов кода API библиотек, предоставляющих интерфейс на этом языке<br>Иногда открывающих доступ к большей части скрытой производительности железа:<br><a href="https://sean-parent.stlab.cc/presentations/2013-03-05-language-delay/language-delay.pdf" target="_blank" rel="noopener">Language Delay</a> - чистый C++ позволяет использовать 0.25% производительности компьютера (объяснение, где скрыты остальные 99.75% на <a href="https://youtu.be/zULU6Hhp42w?t=938" target="_blank" rel="noopener">видео</a>).<br><img src="/blog/1728194429/desktop_power.png" alt="desktop-power"></li></ul><p><code>Описание игровой логики</code></p><p>На этом уровне Суини выделяет такой момент:<br><blockquote><p>Мы с радостью пожертвуем 10% продуктивности ради того, чтобы получить 10% дополнительной производительности”</p></blockquote></p><p>(т.е. фактически, чтобы защититься от стандартных ошибок, которые позволяет совершить язык).</p><p>Распространённый вариант такого обмена — это использование каких-либо других языков, т.е. отказ от C++ в пользу чего-то более медленного, но устойчивого к ошибкам.</p><p>Традиционный для геймдева вариант — Lua. Во многом, идея такой привязки навеяна использованием <a href="https://www.osp.ru/os/1998/03/179470" target="_blank" rel="noopener">языков сценариев</a>. Минусы — производительность снижается далеко не на 10% (что компенсируется ростом производительности железа), и то, что некоторые программисты страдают от искусственного упрощения языка в целях “защиты от дурака”. По опыту, код на Lua, переписанный на C++, ускоряется раз в 5-10. Другие традиционно используемые для скриптования языки, не особо отличаются от Lua ни в плане производительности, ни в плане предоставляемых возможностей.</p><p>Ещё один минус — необходимость создания привязок C++ объектов для возможности использования их в скриптовом языке. Это задача требует использования “высокоуровневого” C++, и её особенности будут описаны в следующем разделе.</p><p>Плюсы — доступ к программированию непрограммистов (хотя их код в плане производительности теряет ещё больше, количество <a href="https://i.imgur.com/J1svNp7.jpg" target="_blank" rel="noopener">WTF в единицу времени</a> в коде гейм-дизайнера зашкаливает).</p><p>Но главный плюс, ради которого часто можно пожертвовать производительностью, это возможность изменить скрипт без перезапуска программы. Это не получается автоматом, а требует некоторой настройки работы с языком, зато в некоторых случаях позволяет повысить производительность программиста не на 10%, а на порядок (в 10 раз). Компиляция, перезапуск игры и прохождение до нужного места с воспроизведением ситуации займёт около минуты, перезагрузка скрипта может выполниться за несколько секунд.</p><p>Иногда, конечно, программист может предусмотреть необходимые читы, позволяющие подтюнить код без перезапуска, в случае использования определённых паттернов проектирования типа <a href="/blog/1488389622/" title="ECS">ECS</a> существенно, разница между таким подходом и использованием скриптов только в уровне радикальности возможных изменений без перезапуска игры.</p><p>Серьёзный шаг вперёд в направлении использования скриптовых языков сделала Unity, предоставляя программисту в качестве языка для скриптов C# — со статической типизацией (также пробовали Boo и JavaScript, но забили), выразительнее минималистичных “подрезанных” соперников, потенциально быстрый, с возможностью рефлексии, компилируемый в C++ с помощью ill2cpp, и с богатой стандартной библиотекой.</p><p>Небольшую проблему представляет запрет на использование виртуальных машин на платформах типа Apple, что обходится “нативизацией” скриптов в C++ код (AoT-компиляция). Таким образом, на устройстве игрока будет присутствовать только нативный код, а на машинах разработчиков — текстовый.</p><p><em>(Честно говоря, не очень понимаю смысл этого запрета, многие современные игры позволяют изменять поведение игры за счёт использования данных, полученных с серверов разработчика — вполне допускается загрузка, к примеру, нового главного меню с кнопкой, которая вызывает код, недоступный для проверки вендору. В одной китайской стратегии я находил использование чата на JavaScript - в котором разработчики теоретически могут хоть запустить игру в игре).</em></p><p><code>Визуальный скриптинг</code><br>Кроме текстовых языков применяется визуальный скриптинг, который ещё больше снижает когнитивную нагрузку при написании кода, и делает более сложным написание тормознутого или неработающего кода для непрограммистов. Как примеры <a href="https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/Blueprints/UserGuide/Types/ClassBlueprint/" target="_blank" rel="noopener">Blueprint classes</a> в Unreal, или <a href="https://habr.com/ru/company/playrix/blog/595385/" target="_blank" rel="noopener">VSO</a> от Playrix.</p><p>Из плюсов — такой язык почти не требует изучения и почти не подвержен ошибкам, по сути, позволяет создавать различные языки для решения различных задач, кроме описания игровой логики.<br>В Unreal с помощью визуального программирования можно описывать:</p><ul><li>Макросы конструирования объектов в редакторе (в том числе параметризированные), вообще не попадающие в игру</li><li>Материалы</li><li>Конечные автоматы поведения персонажей</li><li>Системы анимации</li></ul><p>Подготовка игрового контента чаще всего рассматривается как отдельная задача, не связанная с игрой, однако в некоторых случаях бывает полезна генерация С++ кода для работы с этими данными — задачу генерации такого кода можно отнести к области использования “высокоуровневого” C++.</p><p><code>Вызов кода API библиотек, предоставляющих интерфейс на этом языке</code><br>Часто какой-нибудь SDK представляет только C/C++ интерфейс для работы с ним (в качестве примера, можно взять OpenGL). Несмотря на то, что для многих библиотек существуют биндинги к популярным скриптовым языкам, особого преимущества при работе с ними не будет, если только биндинг каким-либо образом не добавляет библиотеке выразительности — какая разница, из какого языка вызывать сишные функции, по сути, по порядку? Возможно, определенные преимущества можно получить в языках, позволяющих менять семантику самого языка макросами, типа лиспа, но в рамках доступных для геймдева скриптовых языков особенных преимуществ не заметно.</p><p><code>Хардкорные C++-программисты</code><br>Отдельного упоминания заслуживают С++ программисты, которые противятся использованию скриптовых языков для описания игровой логики. Это труднообъяснимое явление, корни которого до конца я не понимаю, поэтому только приведу только те аргументы, которые от них слышал.</p><ul><li><del>С++ быстрый язык, а скрипты — медленные</del><br>С++ быстрый, если писать на низкоуровневом C++, в остальных случаях скрипт после AoT-компиляции может сконвертироваться в средний по качеству/скорости C++ код.</li><li><del>С++ выразительный язык, а скрипты — бейсикоподобные</del><br>Отчасти верно, но зависит от объектной модели, прокинутой в скрипты. Большинство кода в игровой логике на C++, наоборот, используют примитивы слишком низкого уровня там, где отлично было бы обойтись только высокоуровневыми абстракциями. Ну и, какая к чёрту разница, есть или нет какие-то фичи в скриптовом языке, если он позволяет достичь результата раз в 5 быстрее?</li><li><del>Я хочу учить C++, чтобы развиваться только как C++ программист</del><br>Один из самых трудных случаев. Человек верит в миф о самом лучшем языке, вдобавок подкрепив эту веру собственными усилиями, потраченными на изучения премудростей языка. Хз, если не помогают объяснения о том, что выгоднее развиваться не только в одном языке, то возможно, человеку лучше работать над компиляторами, а не в разработке игр.</li></ul><h2 id="Высокоуровневый-C"><a href="#Высокоуровневый-C" class="headerlink" title="Высокоуровневый C++"></a>Высокоуровневый C++</h2><p>Высокоуровневые задачи, с которыми сталкивается типичная игра:</p><ul><li>RTTI и рефлексия — сериализация данных, читы, статистика</li><li>Кодогенерация — введение удобного синтаксиса в язык, генерация типового кода</li><li>Compile/build-time вычисления</li></ul><p>Один из существенных минусов C++ - отсутствие рефлексии, из-за чего её постоянно переизобретают. Часто потому, что к готовой схеме рефлексии сложно “привязаться”, чтобы использовать её для других целей. Например, разметив код один раз, необходимо воспользоваться этой разметкой, чтобы сгенерировать код сериализации или генерации биндингов к скриптовому языку.</p><p>Другая задача, которая решается различными способами — генерация типов и кода десериализации по схеме данных. Если решать её средствами C++ — макросами и шаблонами, то достаточно нетривиально скрестить её со схемой аннотации типов и генерации биндингов.</p><p>Подходы, которые применяются для кодогенерации RTTI-информации:</p><ul><li>Использование схемы данных на отдельном языке (<a href="https://google.github.io/flatbuffers/" target="_blank" rel="noopener">flatbuffers</a>/protobuffers), с генерацией кода внешним компилятором</li><li>Использование языка, генерирующего данные и код работы с этими данными (<a href="https://youtu.be/oSmqbnhHp1c?t=1950" target="_blank" rel="noopener">DataCompiler</a> на Racket от Naughty Dogs)</li><li>Встраивание команд языка в описание данных (<a href="https://beautifulracket.com/jsonic-3/intro.html" target="_blank" rel="noopener">jsonic</a>)</li><li>Встраивание тегов в исходный язык, парсящихся языком, генерирующим данные по тегам (<a href="https://doc.qt.io/archives/qt-4.8/moc.html" target="_blank" rel="noopener">MOC</a>, <a href="https://habr.com/ru/company/playrix/blog/467827/" target="_blank" rel="noopener">CppHeaderParser</a>, парсинг с помощью libclang - половина либ <a href="https://github.com/fffaraz/awesome-cpp#reflection" target="_blank" rel="noopener">отсюда</a>)</li><li>Явное описание с помощью шаблонов C++ (<a href="https://github.com/rttrorg/rttr" target="_blank" rel="noopener">rttr</a>)</li></ul><p>Непосредственно генерация кода часто выполняется в текстовом виде, либо с помощью генерации текста по множеству условий в коде генератора (пример - <a href="https://github.com/GaijinEntertainment/daScript/blob/master/daslib/cpp_gen.das#L587" target="_blank" rel="noopener">dascript</a>), либо с помощью генерации текста с подстановкой по шаблону (чаще всего движки шаблонов изначально задумывались для генерации html-страниц, <a href="https://docs.racket-lang.org/fulmar-doc/index.html" target="_blank" rel="noopener">fulmar</a> — зачаточный генератор С++ на Racket, с удовольствием нашёл бы что-то лучше).</p><p>По идее, не особо сложно генерировать — сериализиацию, биндинги, rtti, типовой C++ код вроде клонирования (сначала всегда хочется пытаться решить эту задачу просто с помощью наследования от “правильного” базового класса :) ).</p><p>Сложнее в C++ с тем, чтобы генерировать синтаксис по уже существующему синтаксису, язык не особо приспособлен для этого. Примеры задач:</p><ul><li>Подсказка компилятору аллоцировать блок данных для структуры в линейном блоке памяти без явного написания кода работы с указателями в самой структуре, формулировка проблемы из <a href="https://youtu.be/TH9VCN6UkyQ?t=4047" target="_blank" rel="noopener">Jai</a></li><li>Смена AoS/SoA выравнивания в памяти</li><li>Регистрация функций в ECS (<a href="https://youtu.be/inGb9R1NowY" target="_blank" rel="noopener">атрибут EC для функций</a> с авто-выведением аргументов)</li></ul><p>Произвольные compile-time вычисления — чаще проще сделать на внешнем языке (экспериментальные попытки завести такое в C++ - <a href="https://youtu.be/NNU6cbG96M4?t=1065" target="_blank" rel="noopener">Circle</a>), и просто выстроить результат, чем пытаться выполнить что-то сложное компилятор.</p><p>Сейчас меня очень интересует в качестве скриптового языка <a href="https://youtu.be/IvHGczF6Go0" target="_blank" rel="noopener">DaScript</a>, доклад Антона Юдинцева сильно корреллирует с моим представлением о том, зачем нужны скриптовые языки на “стандартном” уровне, и замахивается на то, чтобы решать “высокоуровневые” задачи, для которых не всегда есть стандартные решения в самом C++. Пока не успел поиграться с языком, но мне очень нравятся начальные идеи, с которыми подходили к разработке, и заявленные результаты. Я достаточно знаком с использованием скриптовых языков в Gaijin в прошлом, чтобы примерно представлять уровень и объём кода, написанного ими на языке в продакшене и в тулзах, чтобы предварительно положительно отнестись к заявленному, но и без этого выглядит довольно круто. В докладе и стриме почти не освещаются возможности языка по написанию макросов, упоминаемые в <a href="https://dascript.org/doc/reference/language/macros.html" target="_blank" rel="noopener">документации</a>, а также в коде <a href="https://github.com/GaijinEntertainment/daScript/blob/master/daslib/decs_boost.das" target="_blank" rel="noopener">модулей</a> и <a href="https://github.com/borisbat/dasBGFX/blob/a1e10ab439e5996a0a4d8722689e2b0fab4e72d9/examples/01_hello_triangle.das#L12" target="_blank" rel="noopener">привязок</a> либ для реализации “высокоуровневых” фичи.</p><p>Интересно было бы прикинуть оценки пропорции использования C++ на каждом из уровней в различных играх.</p><h2 id="Ссылки"><a href="#Ссылки" class="headerlink" title="Ссылки"></a>Ссылки</h2><p><a href="/blog/1808122922/" title="Nim in imaginary world">Nim in imaginary world</a> — критерии выбора языка<br><a href="/blog/2297379949/" title="Заметки о языках программирования">Заметки о языках программирования</a> — сборник материалов по языкам<br><code>Джесси Шелл - Искусство Геймдизайна</code> — “Итерации делают игру лучше”. Совет использовать для прототипирования языки с возможностью быстрой проверки изменений - Smalltalk, Python, Scheme, JavaScript<br><code>Джейсон Грегори - Архитектура игрового движка</code> — 16.9.4 - Архитектуры для скриптования. Обзор возможных точек привязки скриптов к игре. 16.9.5 - Возможности игровых скриптов на этапе выполнения. Пример подхватывания изменённых данных игрой без перезапуска. 12.10.3 - Параметры состояния и дерева слияния - примеры анимационного клипа, описанного на языке Data Compiler, и Animation Blueprint для Unreal.<br><a href="https://youtu.be/UTqZNujQOlA" target="_blank" rel="noopener">Demo: Base language, compile-time execution</a> - пример запуска игры во время компиляции.<br><a href="https://fungos.github.io/cr-simple-c-hot-reload/" target="_blank" rel="noopener">cr.h: A Simple C Hot Reload Header-only Library</a> - трудности реализации hot code reload в C++. <a href="https://github.com/RuntimeCompiledCPlusPlus/RuntimeCompiledCPlusPlus/wiki/Alternatives" target="_blank" rel="noopener">Больше</a> статей и материалов.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Немного о том, почему в геймдеве используется C++, как именно он используется, и всё ли с этим правильно.&lt;br&gt;
    
    </summary>
    
    
    
      <category term="gamedev" scheme="http://spiiin.github.io/tags/gamedev/"/>
    
      <category term="dascript" scheme="http://spiiin.github.io/tags/dascript/"/>
    
      <category term="cpp" scheme="http://spiiin.github.io/tags/cpp/"/>
    
      <category term="dev_method" scheme="http://spiiin.github.io/tags/dev-method/"/>
    
  </entry>
  
</feed>
