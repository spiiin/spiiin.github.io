<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Spiiin&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://spiiin.github.io/"/>
  <updated>2023-09-05T20:48:46.220Z</updated>
  <id>http://spiiin.github.io/</id>
  
  <author>
    <name>spiiin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>daScript - binding tricks</title>
    <link href="http://spiiin.github.io/blog/1908536621/"/>
    <id>http://spiiin.github.io/blog/1908536621/</id>
    <published>2023-09-05T15:15:38.000Z</published>
    <updated>2023-09-05T20:48:46.220Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Несколько примеров дополнительно к <a href="https://dascript.org/doc/reference/embedding/modules.html" target="_blank" rel="noopener">Modules and C++ bindings</a></p><p><strong><code>Привязка метода класса</code></strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//структура с методами</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">42</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//тип-обёртка, описание структуры для daScript</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStructTypeAnnotation</span> :</span> ManagedStructureAnnotation &lt;MyStruct&gt; &#123;</span><br><span class="line">    MyStructTypeAnnotation(ModuleLibrary&amp; ml) : ManagedStructureAnnotation(<span class="string">"MyStruct"</span>, ml) &#123;</span><br><span class="line">        <span class="comment">//тут может быть описание полей</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">MAKE_TYPE_FACTORY(MyStruct, MyStruct)</span><br><span class="line"></span><br><span class="line"><span class="comment">//описание модуля</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Module_Tutorial02</span> :</span> <span class="keyword">public</span> Module &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Module_Tutorial02() : Module(<span class="string">"tutorial_02"</span>) &#123;   <span class="comment">// module name, when used from das file</span></span><br><span class="line">        ModuleLibrary lib;</span><br><span class="line">        lib.addModule(<span class="keyword">this</span>);</span><br><span class="line">        lib.addBuiltInModule();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//описание структуры</span></span><br><span class="line">        addAnnotation(make_smart&lt;MyStructTypeAnnotation&gt;(lib));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//регистрация метода</span></span><br><span class="line">        <span class="keyword">using</span> method_test = DAS_CALL_MEMBER(MyStruct::test);</span><br><span class="line">        addExtern&lt;DAS_CALL_METHOD(method_test)&gt;(*<span class="keyword">this</span>, lib, <span class="string">"mystruct_test"</span>, SideEffects::none,</span><br><span class="line">            DAS_CALL_MEMBER_CPP(MyStruct::test));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">//возможный вызов метода в daScript</span><br><span class="line">var c: MyStruct</span><br><span class="line">print(<span class="string">"&#123;c |&gt; mystruct_test()&#125;"</span>)</span><br></pre></td></tr></table></figure><p><strong><code>Привязка перегруженных и шаблонных функций с явным указанием сигнатуры</code></strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test2</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123; <span class="keyword">return</span> a; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">test3</span><span class="params">(T a)</span> </span>&#123; <span class="keyword">return</span> a; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//явное указание сигнатуры функции для привязки</span></span><br><span class="line">addExtern&lt;<span class="keyword">int</span>(*)(<span class="keyword">int</span>),test2&gt;(*<span class="keyword">this</span>, lib, <span class="string">"test2"</span>, SideEffects::none, <span class="string">"test2"</span>);</span><br><span class="line">addExtern&lt;<span class="keyword">int</span>(*)(<span class="keyword">int</span>), test3&gt;(*<span class="keyword">this</span>, lib, <span class="string">"test3"</span>, SideEffects::none, <span class="string">"test3"</span>);</span><br></pre></td></tr></table></figure><p><strong><code>Возврат ссылки</code></strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> gValue = <span class="number">111</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">getRef</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> gValue; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span>&amp; <span class="title">getRefInline</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> gValue; &#125;</span><br><span class="line"></span><br><span class="line">addExtern&lt;DAS_BIND_FUN(getRef), SimNode_ExtFuncCallRef&gt;(*<span class="keyword">this</span>, lib, <span class="string">"getRef"</span>, SideEffects::accessExternal, <span class="string">"getRef"</span>);</span><br><span class="line">addExternTempRef&lt;DAS_BIND_FUN(getRefInline), SimNode_ExtFuncCallRef&gt;(*<span class="keyword">this</span>, lib, <span class="string">"getRefInline"</span>, SideEffects::accessExternal, <span class="string">"getRefInline"</span>);</span><br><span class="line">```</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">getRef() = <span class="number">333</span></span><br><span class="line">print(<span class="string">"&#123;getRef()&#125;\n"</span>) //<span class="number">333</span></span><br><span class="line"></span><br><span class="line">var v4&amp; = getRefInline()</span><br><span class="line">v4 = <span class="number">444</span></span><br><span class="line">print(<span class="string">"&#123;getRefInline()&#125;\n"</span>) //<span class="number">444</span></span><br></pre></td></tr></table></figure><p><strong><code>Возврат ссылки по значению</code></strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//returns a ref type by value,</span></span><br><span class="line">addExtern&lt;DAS_BIND_FUN(float4x4_translation), SimNode_ExtFuncCallAndCopyOrMove&gt;(*<span class="keyword">this</span>, lib, <span class="string">"translation"</span>,</span><br><span class="line">        SideEffects::none, <span class="string">"float4x4_translation"</span>)-&gt;arg(<span class="string">"xyz"</span>);</span><br></pre></td></tr></table></figure><p><strong><code>Привязка других типов нод AST</code></strong><br>Способы привязать семантику вызова функции на стороне daScript к генерации других типов нод</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">__forceinline <span class="keyword">float</span> <span class="title">dot3</span><span class="params">(vec4f a, vec4f b)</span></span>&#123;<span class="keyword">return</span> v_extract_x(v_dot3_x(a, b));&#125;</span><br><span class="line">addExternEx&lt;<span class="keyword">float</span>(float3,float3),DAS_BIND_FUN(dot3)&gt;(*<span class="keyword">this</span>, lib, <span class="string">"dot"</span>, SideEffects::none, <span class="string">"dot3"</span>)-&gt;args(&#123;<span class="string">"x"</span>,<span class="string">"y"</span>&#125;);</span><br><span class="line"></span><br><span class="line">addFunction(make_smart&lt;BuiltInFn&lt;SimNode_MatrixCtor&lt;float3x3&gt;,float3x3&gt;&gt;(<span class="string">"float3x3"</span>,lib));</span><br></pre></td></tr></table></figure><p><strong><code>Хинты для аргументов</code></strong></p><p>//TODO<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TT&gt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">registerVectorFunctions</span>&lt;TT&gt; &#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    addExtern&lt;DAS_BIND_FUN(das_vector_pop&lt;TT&gt;)&gt;(*mod, lib, <span class="string">"pop"</span>,</span><br><span class="line">        SideEffects::modifyArgument, <span class="string">"das_vector_pop"</span>);</span><br><span class="line">    <span class="comment">//permanentArgFn</span></span><br><span class="line">    addExtern&lt;DAS_BIND_FUN(das_vector_clear&lt;TT&gt;),SimNode_ExtFuncCall,permanentArgFn&gt;(*mod, lib, <span class="string">"clear"</span>,</span><br><span class="line">        SideEffects::modifyArgument, <span class="string">"das_vector_clear"</span>);</span><br><span class="line">    <span class="comment">//explicitConstArgFn</span></span><br><span class="line">    addExtern&lt;DAS_BIND_FUN(das_vector_each&lt;TT&gt;),SimNode_ExtFuncCallAndCopyOrMove,explicitConstArgFn&gt;(*mod, lib, <span class="string">"each"</span>,</span><br><span class="line">        SideEffects::none, <span class="string">"das_vector_each"</span>);</span><br><span class="line">    <span class="comment">//temporaryArgFn</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong><code>Симуляция walk</code></strong></p><p>Создание своего типа-хендла, который в dascript будет обрабатываться как примитивный тип uint64</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyHandle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> id;</span><br><span class="line">    <span class="comment">//другие методы и свойства handle</span></span><br><span class="line">&#125;;</span><br><span class="line">MAKE_TYPE_FACTORY(MyHandle, MyHandle)</span><br><span class="line"></span><br><span class="line"><span class="comment">//описываем методы каста к примитивному типу и обратно</span></span><br><span class="line"><span class="keyword">namespace</span> das</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;&gt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cast</span>&lt;MyHandle&gt;</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> __forceinline MyHandle <span class="title">to</span><span class="params">(vec4f x)</span> </span>&#123; <span class="keyword">return</span> MyHandle&#123; (<span class="keyword">uint64_t</span>)v_extract_xi64(v_cast_vec4i(x)) &#125;; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> __forceinline vec4f <span class="title">from</span><span class="params">(MyHandle x)</span> </span>&#123; <span class="keyword">return</span> v_cast_vec4f(v_splatsi64(x.id)); &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//описываем аннотацию типа с перегруженным методом walk</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyHandleAnnotation</span> <span class="title">final</span> :</span> ManagedStructureAnnotation&lt;MyHandle&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyHandleAnnotation(ModuleLibrary&amp; ml) : ManagedStructureAnnotation(<span class="string">"MyHandle"</span>, ml) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasNonTrivialCtor</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125; <span class="comment">//trivial type</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canClone</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">(DataWalker&amp; walker, <span class="keyword">void</span>* data)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!walker.reading)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">const</span> MyHandle* t = (MyHandle*)data;</span><br><span class="line">            <span class="keyword">uint64_t</span> eidV = t-&gt;id;</span><br><span class="line">            walker.UInt64(eidV);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> SimNode* <span class="title">simulateClone</span><span class="params">(das::Context&amp; context, <span class="keyword">const</span> das::LineInfo&amp; at, das::SimNode* l, das::SimNode* r)</span> <span class="keyword">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> GenCloneNode&lt;MyHandle&gt;::simulateClone(context, at, l, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><code>Симуляция итератора</code></strong><br>Для кастомного контейнера можно задать прямой способ обращения к элементам (для простоты — нешаблонная версия кода)</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//кастомный вектор из элементов MyHandle</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyVector</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;MyHandle&gt; vec;</span><br><span class="line">&#125;;</span><br><span class="line">MAKE_TYPE_FACTORY(MyVector, MyVector)</span><br><span class="line"></span><br><span class="line"><span class="comment">//создаём вектор в C++ и делаем функцию доступа к нему из daScript</span></span><br><span class="line">MyVector gVector = &#123; &#123;MyHandle&#123;<span class="number">1</span>&#125;, MyHandle&#123;<span class="number">3</span>&#125;, MyHandle&#123;<span class="number">5</span>&#125;&#125; &#125;;</span><br><span class="line"><span class="function"><span class="keyword">auto</span>&amp; <span class="title">getArrayRef</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> gVector; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//кастомный итератор</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyIterator</span> :</span> Iterator</span><br><span class="line">&#123;</span><br><span class="line">    MyIterator(MyVector* ar) : <span class="built_in">array</span>(ar) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">first</span><span class="params">(das::Context&amp;, <span class="keyword">char</span>* _value)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">array</span>-&gt;vec.size())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        iterator_type* value = (iterator_type*)_value;</span><br><span class="line">        *value = <span class="built_in">array</span>-&gt;vec.begin(); <span class="comment">//пишем в память, выделенную в daScript под итератор</span></span><br><span class="line">        end = <span class="built_in">array</span>-&gt;vec.end();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">next</span><span class="params">(das::Context&amp;, <span class="keyword">char</span>* _value)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        iterator_type* value = (iterator_type*)_value;</span><br><span class="line">        ++(*value); <span class="comment">//сдвигаем курсор на следующий элемент</span></span><br><span class="line">        <span class="keyword">return</span> *value != end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(das::Context&amp; context, <span class="keyword">char</span>* _value)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//освобождаем итератор, по хорошему нужно еще занулить value</span></span><br><span class="line">        context.heap-&gt;<span class="built_in">free</span>((<span class="keyword">char</span>*)<span class="keyword">this</span>, <span class="keyword">sizeof</span>(MyIterator));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MyVector* <span class="built_in">array</span> = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(<span class="built_in">array</span>-&gt;vec.begin())</span> iterator_type</span>;</span><br><span class="line">    iterator_type end;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//в аннотации типа вектора говорим:</span></span><br><span class="line"><span class="comment">//"при обращении к итератору контейнера из daScript будет создан кастомный класс итератора и вызываться его методы"</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyVectorAnnotation</span> <span class="title">final</span> :</span> ManagedStructureAnnotation&lt;MyVector, <span class="literal">false</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    TypeDeclPtr vecType;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    MyVectorAnnotation(das::ModuleLibrary&amp; ml) : ManagedStructureAnnotation(<span class="string">"MyVector"</span>, ml)</span><br><span class="line">    &#123;</span><br><span class="line">        cppName = <span class="string">"MyVector"</span>;</span><br><span class="line"></span><br><span class="line">        vecType = makeType&lt;MyHandle&gt;(ml);</span><br><span class="line">        vecType-&gt;ref = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">isIterable</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> das::TypeDeclPtr <span class="title">makeIteratorType</span><span class="params">(<span class="keyword">const</span> das::ExpressionPtr&amp;)</span> <span class="keyword">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> das::make_smart&lt;das::TypeDecl&gt;(*vecType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//используем наш итератор для обхода</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> das::SimNode* <span class="title">simulateGetIterator</span><span class="params">(das::Context&amp; context, <span class="keyword">const</span> das::LineInfo&amp; at,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> das::ExpressionPtr&amp; src)</span> <span class="keyword">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> rv = src-&gt;simulate(context);</span><br><span class="line">        <span class="keyword">return</span> context.code-&gt;makeNode&lt;das::SimNode_AnyIterator&lt;MyVector, MyIterator&gt;&gt;(at, rv);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//не забываем добавить в модуль аннотации</span></span><br><span class="line">addAnnotation(make_smart&lt;MyHandleAnnotation&gt;(lib));</span><br><span class="line">addAnnotation(make_smart&lt;MyVectorAnnotation&gt;(lib));</span><br><span class="line">addExtern&lt;DAS_BIND_FUN(getArrayRef), SimNode_ExtFuncCallRef&gt;(*<span class="keyword">this</span>, lib, <span class="string">"getArrayRef"</span>,</span><br><span class="line">    SideEffects::accessExternal, <span class="string">"getArrayRef"</span>);</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">//теперь можно пройти по C++-контейнеру из daScript без дополнительных затрат на итерации</span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> getArrayRef()</span><br><span class="line">    print(<span class="string">"&#123;v&#125;\n"</span>)</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;Несколько 
      
    
    </summary>
    
    
    
      <category term="dascript" scheme="http://spiiin.github.io/tags/dascript/"/>
    
  </entry>
  
  <entry>
    <title>Turtletoy и dittytoy</title>
    <link href="http://spiiin.github.io/blog/421834894/"/>
    <id>http://spiiin.github.io/blog/421834894/</id>
    <published>2023-09-03T10:33:37.000Z</published>
    <updated>2023-09-03T10:37:56.602Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>javascript-api для черепашьей графики и для генерации звуки<br><a href="https://turtletoy.net/" target="_blank" rel="noopener">https://turtletoy.net/</a><br><a href="https://dittytoy.net/" target="_blank" rel="noopener">https://dittytoy.net/</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;javascript
      
    
    </summary>
    
    
    
      <category term="link" scheme="http://spiiin.github.io/tags/link/"/>
    
      <category term="procgen" scheme="http://spiiin.github.io/tags/procgen/"/>
    
  </entry>
  
  <entry>
    <title>AI фантазии</title>
    <link href="http://spiiin.github.io/blog/2491875181/"/>
    <id>http://spiiin.github.io/blog/2491875181/</id>
    <published>2023-08-27T17:15:45.000Z</published>
    <updated>2023-08-27T17:25:23.245Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Пока изучал природные материалы, пролистал советский учебник по природоведению для 4-го класса. Простенький список материалов — песок с серой, гранит (полевой шпат, слюда, кварц), соль, торф, известняк (мел, мрамор, обыкновенный), каменный уголь, антрацит, нефть, чугун, сталь, железо, аллюминий, растворы порошков в воде. Кроме рисования текстур, фантазиями и галлюцинациями нейронок весело и просто проиллюстрировать текст (а google earth - с прогулками по описанным местам) =)</p><p><img src="/blog/2491875181/1_small.png" alt=""><br><img src="/blog/2491875181/2_small.png" alt=""><br><img src="/blog/2491875181/3_small.png" alt=""><br><img src="/blog/2491875181/4_small.png" alt=""><br><img src="/blog/2491875181/5_small.png" alt=""><br><img src="/blog/2491875181/6_small.png" alt=""><br><img src="/blog/2491875181/7_small.png" alt=""><br><img src="/blog/2491875181/8_small.png" alt=""><br><img src="/blog/2491875181/9_small.png" alt=""></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;Пока изуча
      
    
    </summary>
    
    
    
      <category term="ai" scheme="http://spiiin.github.io/tags/ai/"/>
    
  </entry>
  
  <entry>
    <title>AI - Stable Diffusion и процедурная генерация. Ссылки</title>
    <link href="http://spiiin.github.io/blog/3923038774/"/>
    <id>http://spiiin.github.io/blog/3923038774/</id>
    <published>2023-08-27T15:24:22.000Z</published>
    <updated>2023-09-03T10:35:52.461Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><h2 id="Stable-Diffusion"><a href="#Stable-Diffusion" class="headerlink" title="Stable Diffusion"></a>Stable Diffusion</h2><a href="/blog/1596814086/" title="AI prompts">AI prompts</a><p>Известные ИИ модели для рисования — <code>Dall-E</code>, <code>Midjourney</code> и <code>Stable Diffusion</code>. Stable Diffusion хороша тем, что код открыт, и доступно большое количество плагинов и моделей.</p><p>Первый способ “обращаться” к модели за картинкой — запросом из кода.</p><p><a href="https://habr.com/ru/companies/selectel/articles/712316/" target="_blank" rel="noopener">SD – это Linux, а Midjourney – Mac: краткое полное руководство по Stable Diffusion</a> - терминология<br><a href="https://habr.com/ru/articles/688204/" target="_blank" rel="noopener">Шерудим под капотом Stable Diffusion - python код для теста частей модели</a> - еще, вникнуть в термины vae/clip/unet<br><a href="https://habr.com/ru/articles/693298/" target="_blank" rel="noopener">Как работает Stable Diffusion: объяснение в картинках</a><br><a href="https://habr.com/ru/companies/ruvds/articles/706406/" target="_blank" rel="noopener">Как оптимизировать работу Stable Diffusion при помощи текстовой инверсии</a></p><p>Второй способ — генерация с помощью GUI: <a href="https://github.com/artmamedov/artroom-stable-diffusion/releases" target="_blank" rel="noopener">ArtRoom</a>, <a href="https://github.com/AUTOMATIC1111/stable-diffusion-webui" target="_blank" rel="noopener">Automatic1111 webui</a>, <a href="https://github.com/invoke-ai/InvokeAI" target="_blank" rel="noopener">InvokeAI</a>.</p><p>Третий, кажется, наиболее интересный, составление пайплайна вызовов с помощью нодового редактора - <a href="https://github.com/comfyanonymous/ComfyUI" target="_blank" rel="noopener">ComfyUI</a>. (Нодовый редактор также есть в InvokeAI)</p><p><a href="https://comfyanonymous.github.io/ComfyUI_examples/" target="_blank" rel="noopener">ComfyUI examples</a> - примеры построения пайплайнов. <code>Inpaint</code> и <code>img2img</code> — два базовых способа доработки изображения.</p><p><a href="https://comfyanonymous.github.io/ComfyUI_examples/controlnet/" target="_blank" rel="noopener">ControlNet</a> - группа моделей для “снятия” с изображения параметров и использования их — <code>поза</code>, <a href="https://www.youtube.com/watch?v=_xHC3bT5GBU" target="_blank" rel="noopener">освещение</a>, <code>карта глубины</code>, <a href="https://www.youtube.com/watch?v=GF2vIgyn4Qo" target="_blank" rel="noopener">форма лица</a>, <code>силуэт</code>, <a href="https://github.com/comfyanonymous/ComfyUI/issues/65" target="_blank" rel="noopener">стиль</a> и т.п.<br><a href="https://comfyanonymous.github.io/ComfyUI_examples/area_composition/" target="_blank" rel="noopener">Area Composition</a> - работа с изображением в виде группы текстовых запросов и шагов для различных областей.<br><a href="https://www.youtube.com/watch?v=dVjMiJsuR5o" target="_blank" rel="noopener">LoRA vs Dreambooth vs Textual Inversion vs Hypernetworks</a> - разбор нескольких способов применения “дообучения” моделей.<br><a href="https://www.youtube.com/watch?v=OdMtJMzjNLg" target="_blank" rel="noopener">LATENT Tricks - Amazing ways to use ComfyUI</a> - различные способы генерации вариаций изображений, интересно само по себе, и как объяснение внедрения в различные шаги пайплайна<br><a href="https://github.com/adieyal/sd-dynamic-prompts/blob/main/docs/tutorial.md" target="_blank" rel="noopener">SD dynamic promts</a> - промт-хакинг, генерация вариаций за счет изменений текста запроса<br><a href="https://youtu.be/EmA0RwWv-os" target="_blank" rel="noopener">ControlNet 1.1 Tiles Tutorial</a> - один из способов апскейла изображений (существует много других моделей и методов для апскейла)<br><a href="https://github.com/biegert/ComfyUI-CLIPSeg" target="_blank" rel="noopener">ClipSeg</a> - кастомный плагин для comfyui для текстового запроса выделения объекта с картинки<br><a href="https://www.reddit.com/r/StableDiffusion/comments/zgfbj1/i_used_stable_diffusion_to_create_360_degree/" target="_blank" rel="noopener">360 degree</a> - генерация панорамных изображений в несколько шагов - генерация панорамы сферической карты (бесшовной по одной из осей, и с нужными пропорциями, и правильным текстов запросом), затем разворачивание в cube-map, для того, чтобы с помощью inpaint дорисовать бесшовность у полюсов.</p><p>Базовые модели для рисования с помощью StableDiffusion - <code>sd1.4, sd2.0, sdxl</code>. Вторая не лучше первой, а альтернативная, <a href="https://huggingface.co/stabilityai/stable-diffusion-xl-base-1.0" target="_blank" rel="noopener">sdxl</a> - лучше обеих. Плагины постепенно апдейтятся для использования с ней.</p><h2 id="Процедурная-генерация-текстур"><a href="#Процедурная-генерация-текстур" class="headerlink" title="Процедурная генерация текстур"></a>Процедурная генерация текстур</h2><p>Книга по программной генерации текстур — <code>Texture and modeling: procedural approach</code>.</p><p>Софт для программной генерации:<br><a href="http://www.darksim.com/html/download_darktree2.shtml" target="_blank" rel="noopener">Dark tree</a> - древний, но хороший как референс<br><a href="https://kayv.artstation.com/projects/ww3ow" target="_blank" rel="noopener">Adobe substance designer 3d</a> - пример графа генерации царапин<br><a href="https://www.youtube.com/playlist?list=PLsGl9GczcgBs6TtApKKK-L_0Nm6fovNPk" target="_blank" rel="noopener">Blender nodes</a> - плейлист на ютубе генерации материалов в Blender<br><a href="https://www.shadertoy.com/view/4sXXW2" target="_blank" rel="noopener">Shadertoy</a> - пример шейдера генерации фрактального шума <a href="https://www.kenmusgrave.com/vision.html" target="_blank" rel="noopener">Масгрейва</a></p><p><a href="https://github.com/ASTex-ICube/semiproctex/" target="_blank" rel="noopener">Semi-Procedural Textures</a> - реализация сразу нескольких интересных идей.</p><ul><li>Point Process Texture Basis Functions - rule-them-all шум, позволяющий сгенерировать множество форм для природных материалов</li><li>“снятие” параметров для этого шума с входного изображения</li><li>выделение понятия “структуры” материала (контуров) и “текстуры” (расцветки)</li><li>генерация по структуре и входной текстуре изображения</li></ul><p>Последняя стадия у авторов делается с помощью патентованного алгоритма <code>Parallel controllable texture synthesis</code>.<br>Можно попробовать подменить её на то, чтобы скормить “структуру” как controlnet контур для Stable Diffusion вместе с текстовым описанием материала (<em>пусть нейронка разукрашивает мультифракталы!</em>), получается что-то типа <code>Semi-procedural stable diffusion</code>, материал часто сохраняет визуальные свойства и бесшовность:</p><p><img src="/blog/3923038774/proc_wood.png" alt=""><br><em>(процедурные кирпичи)</em></p><p><img src="/blog/3923038774/proc_marble.png" alt=""><br><em>(и мрамор)</em></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;h2 id=&quot;Stabl
      
    
    </summary>
    
    
    
      <category term="link" scheme="http://spiiin.github.io/tags/link/"/>
    
      <category term="3d" scheme="http://spiiin.github.io/tags/3d/"/>
    
      <category term="procgen" scheme="http://spiiin.github.io/tags/procgen/"/>
    
      <category term="ai" scheme="http://spiiin.github.io/tags/ai/"/>
    
  </entry>
  
  <entry>
    <title>Магистерский курс C++ МФТИ</title>
    <link href="http://spiiin.github.io/blog/1964756683/"/>
    <id>http://spiiin.github.io/blog/1964756683/</id>
    <published>2023-08-27T14:53:01.000Z</published>
    <updated>2023-08-27T16:29:25.315Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p><a href="https://www.youtube.com/playlist?list=PL3BR09unfgcgf7R88ZQRQqWOdLy4pRW2h" target="_blank" rel="noopener">https://www.youtube.com/playlist?list=PL3BR09unfgcgf7R88ZQRQqWOdLy4pRW2h</a></p><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/mDajl0pIUjQ" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div><p>Отличный курс по стандарту C++, у автора получается разбирать сложные и запутанные проблемы относительно простыми примерами.</p><p>Часто материалы затрагивают последние стандарт или то, что еще не вошло (hazzard pointers, facebook libunifex -  std::executor для диспетчеров асинхронных задач в стандарте (из gpu или потоков на cpu)). Доступно и подробно разобраны корутины.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;&lt;a href=&quot;h
      
    
    </summary>
    
    
    
      <category term="cpp" scheme="http://spiiin.github.io/tags/cpp/"/>
    
      <category term="link" scheme="http://spiiin.github.io/tags/link/"/>
    
  </entry>
  
  <entry>
    <title>Итоги первой половины 2023</title>
    <link href="http://spiiin.github.io/blog/3525050862/"/>
    <id>http://spiiin.github.io/blog/3525050862/</id>
    <published>2023-07-30T14:31:15.000Z</published>
    <updated>2023-08-27T13:00:32.591Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Предыдущие<br><a href="/blog/307513906/" title="Итоги 2020">Итоги 2020</a><br><a href="/blog/2738337723/" title="Итоги 2021-2022">Итоги 2021-2022</a></p><p><strong><code>Работа</code></strong></p><p>С начала года вернулся работать в “Gaijin”, теперь пишу на <a href="https://spiiin.github.io/tags/dascript/">daScript</a>. Нашёл несколько своих коммитов девятилетней давности со старого аккаунта, а также фотографии с корпоративных мероприятий.<br><img src="/blog/3525050862/egypt_small.png" alt=""></p><p>Днем отмечаешь релиз и катаешься на квадроциклах по дюнам Шарм-Эль-Шейха, а вечером узнаешь о “зеленых человечках”, и о том, что возвращаться придётся в совсем другой Крым. Опционально — не возвращаться совсем. Необычный опыт погружения в воспоминания из прошлого. Пора уже окончательно попрощаться с этими воспоминаниями.</p><p>Начало новой работы — сложное, за годы кодовая база и тулзы сильно меняются, предыдущее знания устаревают. Побочный эффект накопленного компанией software capital — необходимость в нём осваиваться. В геймдеве так или иначе, почти постоянно учишься, и обновляешь знания. Не успел закончить на прыдущем месте работы изучение геймдизайнерских/продюссерских материалов, как на новом снова вникать в новые темы. Заодно - привет нейронкам, они с нами всерьёз и надолго, и хорошо бы уметь ими пользоваться. Наверное, необходимость изучения — это логичная цена за то, чтобы оставаться на фронтире.</p><p>Хочется скорее выйти в режим своей нормальной производительности.</p><p><img src="/blog/3525050862/krit_ai.png" alt=""><br><em>(из книги Ричарда Бира “Мозг фирмы”) Как-то так, всегда в зоне критического решения и поиска/изучения технологии B</em></p><p>Ещё в этом году двое бывших коллег старше 30 ушли из программистов игр, один - в монетизационные менеджеры, другой в вайт-хакеры. Оба частично из-за того, что стало сложно учиться новому. Хех, мне пока наоборот, в кайф изучать что-то новое, было б еще времени побольше. В этом смысле сильно лучше, когда в окружении есть много крутых ребят. Хотелось бы когда-нибудь отметить свое 25-летие в геймдеве, возможно, тоже на каком-нибудь корпоративе у моря.</p><p><strong><code>Личное/путешествия</code></strong></p><p>Чё-то накрыло с головой от количества событий с начала года. Перебрался из Еревана в Хайфу. Много времени ушло на оформление различных бумажек, много сил на адаптацию в новой среде — Армения намного ближе по культуре к России или Украине, Израиль сильно другой, во всём.</p><p><img src="/blog/3525050862/yerevan_small.png" alt=""><br><em>Фонтаны ночного Еревана</em><br><img src="/blog/3525050862/tree_small.png" alt=""><br><em>Хайфовские бинарные деревья</em></p><p>В какой-то момент, сидишь на холме, смотришь на порт и понимаешь, что всё, нет пути обратно, и уже давно. Представляешь себя где-то на барже в океане</p><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/XTPGpBBwt1w" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div><p>Новости слушаешь только по радио, они важны, но далеко, временно важнее то, что происходит рядом. Такая вот чистка информационного фона.</p><p>Иногда ныряешь, чтобы что-то вспомнить.</p><p>Например, детство. Когда попал в “переход между поколениями”, братья и сестры старше на 10 лет, и на чердаке можно найти их старые игрушки. Забытые и отличающиеся от того, что рекламируется и во что играют все. Когда-то дядя и тетя ездили за границу, и привозили оттуда диковинки, которых не было у нас (я не верил в деда мороза, но верил, что их курица несет шоколадные яйца, откуда ж было знать, что существуют киндер-сюрпризы). Игры в комнате с этими игрушками, попытки генерировать сюжеты, вроде книги правил для построения города для игрушек из киндеров, или перестрелки между замками. Дальше - тамагочи, “ну погоди”, чэпсы, альбомы с наклейками, и прочие атрибуты 90х. Денди и сега, и желание делать игры. Кажется, что компьютерных играх есть что-то от дворовых развлечений, игрушек и математических формул.</p><p>Или позднее, универ и студенческие развлечения, вылазки на природу. Караби и турбаза “точка” на Чатыр Даге (там иногда проводили лан-пати по “контр-страйку”, “героям” и “варкрафту”), около-ролевые движухи, Джанк Пати (такой крымский Burning Man), Генуэзская крепость, фестивали в Коктебеле и под Щёлкино, ночёвки с палатками на Инжире (идешь туда по тропинкам на скале над морем, как будто из второй “готики”, и где ночью летом светится вода, как будто запускаешь фаербол в “мортал комбате”),  деревни на ЮБК.</p><p>Или какой-то момент на работе, когда пытался понять гейм-дизайнеров. Раньше, кажется, многие начинали с редакторов карт. Следующее поколение приходило больше из сценаристов, или игроков/авторов настольных игр. Следующее, вероятно, будет уже начинать с книг по гейм-дизайну или профессионального образования.</p><p>Потом выныриваешь, и возвращаешься.</p><p><em>в общем, путешествия за эти полгода в основном, такие</em></p><p>Необходимо учиться планировать не на короткий срок, когда чаще всего правильной стратегией будет двигаться туда, куда все, и когда завтра будет то же самое, что и сегодня, с небольшими изменениями (которые можно понять, если сравнить вчера и сегодня), а на длинный. Когда необходимо хотя бы попытаться собрать какую-то информацию, относящуюся к решению, и сделать вывод на основе этой информации, даже если он будет противоречить тому, что было вчера и тому, что есть сегодня. <code>Вообще говоря, так наверное надо планировать всегда</code>, а не только когда кажется, что ничего не понятно.</p><p><strong><code>Музыка</code></strong></p><p><code>- Balkan Beat Box + AWA</code><br><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/RT7p9JCoVmI" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></p><p><code>- Balkan Beat Box + Hadag Nahash</code><br><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/wvwHnjhxz0o" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></p><p><code>- Q2A</code><br><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/hcjBogMoX9g" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></p><p><strong><code>Фильмы</code></strong><br><code>- Банши Инеширина</code><br>Нелепый сюжет, но классная игра актёров, природа, и просто атмосфера. Также “играет” акцент, если смотреть в оригинале.</p><p><code>- The Super Mario Bros Movie</code><br>Шикарно. Особенно круто смотреть в 3d с раскачивающимися креслами, весь фильм по сути - экшен над пропастями.</p><p><code>- Дети СССР</code><br>Израильский фильм о эмигрантах 90х. Несколько раз обманывает с сюжетом, сначала ожидаешь рассказа об упавших на дно подростках, затем спортивного фильм, а на самом деле хорошая социальная драма.</p><p><code>- Горячая жевательная резинка</code><br>Еще один израильский фильм по формуле, по которой сделан Американский Пирог, но 1978 года.</p><p><strong><code>Приобретения</code></strong></p><p><code>- Steam deck</code><br>После покупки Ninntendo Switch понял, насколько удобнее играть с портативной платформы. Попробовал эмуляторы (<a href="https://www.emudeck.com/" target="_blank" rel="noopener">Emu Deck</a> - отличная сборка, чтобы не возиться с настройкой слишком много), много инди-игр, и пару экшенов. Безумно крутая вещь.</p><p><img src="/blog/3525050862/steamdeck_small.png" alt=""></p><p>Собрал уже коллекцию портативных приставок, Switch Lite<br><img src="/blog/3525050862/switch_lite_small.png" alt=""></p><p>И рука из Ikea, которая держит провода<br><img src="/blog/3525050862/hand_small.png" alt=""></p><p><strong><code>Игры</code></strong><br>Протыкал на свитче и стимдеке по несколько часов кучу игр.</p><p><code>- Fire Emblem Fates/Awakening/Three Houses/Engage (3ds/switch)</code><br>Достаточно простая, по тактике, но завлекательная, игра. Three Houses прикольна тем, что отношения вынесены из дополнительной механики в основную, большой кусок геймплея завязан на построение отношений с учениками, а не только бои.</p><p><code>- Symfony of War (pc)</code><br>Крутецкая по возможностям тактика.</p><p><code>- Legend of Zelda: Tears of the Kingdoom (switch)</code><br>Новая Зельда - как обычно нестандартная, с кучей новых механик и загадок на применение на механики, игра</p><p><code>- It takes Two (switch)</code><br>Отличная игра для прохождения с напарником</p><p>Еще разные по чуть-чуть<br><code>- Persona 5, Monster Hunter Stories, Kirby Forgotten Land, Fantasy Strike, Elden Ring, Ori and Blind Forest, Age of Calamity, Oxygen not included</code></p><p>Интересные инди (раньше мало играл совсем)<br><code>- Journey, Don&#39;t Starve, Slay the Spire, Subnautica, Oxygen not Included</code></p><p><strong><code>Книги</code></strong></p><p><code>Зубек. Элементы гейм-дизайна</code> - хорошее описание множества приёмов и техник.<br><code>Галенкин. Маркетинг игр</code> - основные приемы и возможности для инди и небольших команд, в большинстве устаревшие цифры.<br><code>Гилберт. Спотыкаясь о счастье</code> - описание множества экспериментов о том, как мы оцениваем будущее, и какие механизмы психики при этом действуют. Наравне с книгами по поведенческой психологии, необходимая книга для понимания действий людей.<br><code>Дневник художника-натуралиста</code> - как зарисовывать животных и растения.<br><code>Больше не мастерю и другое вранье</code> - книга по организации LARP, интересные главы про “модели” — выбор механик и правил. Когда-то ездил на пару ролёвок, но сейчас заинтересовался именно организацией, в рамках расширения знаний по геймдизайну.<br><code>Game feel</code> - устройство управления в играх. О том, как ощущение контроля персонажа помогает созданию погружения в мир игры.<br><code>Designing emergency + Advanced game mechanics</code> - по большей части, описание фреймворка для того, чтобы проектировать игровые механики в виде интерактивных схем.<br><code>Карта культурных различий</code> - в общем вместо книги хватило бы и статьи. О том, что разные команды отличаются в подходах, от количества необходимого общения, до взаимодействий с начальством.</p><p><strong><code>Развитие</code></strong></p><p>Допишу наверное когда-нибудь во второй половине года.</p><p><img src="/blog/3525050862/obsidian_2_small.png" alt=""><br><em>Граф заметок в Obsidian</em></p><p><img src="/blog/3525050862/foxy.jpg" alt=""></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;Предыдущие
      
    
    </summary>
    
    
    
      <category term="log" scheme="http://spiiin.github.io/tags/log/"/>
    
  </entry>
  
  <entry>
    <title>AI in imaginery world</title>
    <link href="http://spiiin.github.io/blog/3605719908/"/>
    <id>http://spiiin.github.io/blog/3605719908/</id>
    <published>2023-04-09T19:40:43.000Z</published>
    <updated>2023-04-10T20:47:39.875Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Попробовал решить <a href="/blog/1160489034/" title="задачу Джеймса Бонда-младшего">задачу Джеймса Бонда-младшего</a> с помощью <code>openai</code>.</p><p>Из интереса, где-то с 30 запросов (притом на русском языке) к 3-й версии ChatGPT получилось объяснить условие задачи. Часть запросов “отладочные”, чтобы понять, то, что пытается делать ИИ с моделью.</p><p>Примеры:<br><em>“Попробуй выполнить операции - сдвиг вправо 2-й строки, сдвиг вправо 3-й строки, сдвиг вправо 4-й строки. Примени каждую из них к начальной позиции”</em><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Конечно, вот результаты применения операций к начальной позиции квадрата чисел:</span><br><span class="line"></span><br><span class="line">Сдвиг вправо 2-й строки на одну позицию:</span><br><span class="line"></span><br><span class="line">Copy code</span><br><span class="line">11 12 13 14</span><br><span class="line">24 21 22 23</span><br><span class="line">31 32 33 34</span><br><span class="line">41 42 43 44</span><br><span class="line">Сдвиг вправо 3-й строки на одну позицию:</span><br><span class="line"></span><br><span class="line">Copy code</span><br><span class="line">11 12 13 14</span><br><span class="line">21 22 23 24</span><br><span class="line">34 31 32 33</span><br><span class="line">41 42 43 44</span><br><span class="line">Сдвиг вправо 4-й строки на одну позицию:</span><br><span class="line"></span><br><span class="line">Copy code</span><br><span class="line">11 12 13 14</span><br><span class="line">21 22 23 24</span><br><span class="line">31 32 33 34</span><br><span class="line">44 41 42 43</span><br><span class="line">В каждом случае соответствующая строка сдвинулась на одну позицию вправо, и последний элемент строки перешел на первое место.</span><br></pre></td></tr></table></figure></p><p><em>“Теперь попробуй выполнить операцию «сдвиг 4го столбца вверх» по шагам”</em></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Конечно! Вот пошаговое описание:</span><br><span class="line"></span><br><span class="line">Выделяем 4-й столбец:</span><br><span class="line">(11 12 13 14) (21 22 23 24) (31 32 33 34) (41 42 43 44)</span><br><span class="line"></span><br><span class="line">14 24 34 44</span><br><span class="line"></span><br><span class="line">Сдвигаем 4-й столбец вверх:</span><br><span class="line">(11 12 13 14) (21 22 23 24) (31 32 33 34) (41 42 43 44)</span><br><span class="line"></span><br><span class="line">14 24 34 44</span><br><span class="line">11 21 31 41</span><br><span class="line"></span><br><span class="line">Вставляем 4-й столбец обратно на своё место:</span><br><span class="line">(11 12 13 14) (21 22 23 24) (31 32 33 34) (41 42 43 44)</span><br><span class="line"></span><br><span class="line">12 13 14 44</span><br><span class="line">22 23 24 21</span><br><span class="line">32 33 34 31</span><br><span class="line">42 43 11 41</span><br><span class="line"></span><br><span class="line">Таким образом, получаем следующую конечную позицию.</span><br></pre></td></tr></table></figure><p><em>Во втором шаге ошибка — столбец 14 24 34 44 при сдвиге вверх станет 24 34 44 14</em><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Извините за ошибку в предыдущем ответе. Правильно будет так:</span><br><span class="line"></span><br><span class="line">Выделяем четвертый столбец: (14, 24, 34, 44)</span><br><span class="line">Сдвигаем его вверх: (24, 34, 44, 14)</span><br><span class="line">Вставляем сдвинутый столбец обратно в исходный квадрат:</span><br><span class="line">(11, 12, 13, 24)</span><br><span class="line"></span><br><span class="line">(21, 22, 23, 34)</span><br><span class="line"></span><br><span class="line">(31, 32, 33, 44)</span><br><span class="line"></span><br><span class="line">(41, 42, 43, 14)</span><br></pre></td></tr></table></figure></p><p>Ощущения — как от объяснения не очень умному школьнику, 4-я версия наверное быстрее уловит смысл. Но с момента, когда просишь переписать решение на Python, “школьник” безошибочно пишет функцию применения всех операций к исходной позиции, и поиск в ширину.</p><p>Дальше — интересней, ИИ может дописать оптимизацию с сортировкой с помощью функции оценки — предлагает эвклидово расстояние, а также манхеттенское расстояние и расстояние чебышева. C расстоянием эвклида он доходит до хорошей скорости выполнения. ИИ использовал для хранения списка открытых вершин <a href="https://docs.python.org/3/library/queue.html#queue.PriorityQueue" target="_blank" rel="noopener">PriorityQueue</a>. Это даёт отличающийся от моей самой первой программы (которая использует для хранения list и сортирует его каждые N шагов) результат — находит путь в 10 шагов, а не 9.</p><p>ИИ предложил добавить в код замену функции оценки с эвклидова расстояния на манхеттенское (при этому утверждает, что для “пятнашек”, за которые он принял эту задачу, эта функция гарантированно даёт лучшую оценку, хотя я не стал бы ему доверять в таких утверждениях). С <code>jupyter notebook</code> обращение к ИИ за переписыванием кода может выглядеть примерно так:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">//cell1, тут недописанный код</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_astar_path</span><span class="params">(start, end, operations)</span>:</span></span><br><span class="line">    queue = PriorityQueue()</span><br><span class="line">    queue.put((<span class="number">0</span>, [start]))</span><br><span class="line">    visited = set()</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> queue.empty():</span><br><span class="line">        _, path = queue.get()</span><br><span class="line">        vertex = path[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span> vertex == end:</span><br><span class="line">            print(<span class="string">"hash "</span>, len(visited), <span class="string">" queue "</span>, queue.qsize())</span><br><span class="line">            <span class="keyword">return</span> path</span><br><span class="line">        <span class="keyword">if</span> tuple(vertex) <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">            <span class="keyword">for</span> operation <span class="keyword">in</span> operations:</span><br><span class="line">                possible_path = path + [operation(vertex)]</span><br><span class="line">                queue.put((len(path) + euclide_distance(possible_path[<span class="number">-1</span>], target), possible_path))</span><br><span class="line">            visited.add(tuple(vertex))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">//cell2</span><br><span class="line">ss = <span class="string">"Rewrite function find_astar_path for using manhattan distance instead of euclide distance:\n"</span></span><br><span class="line">ss += _i1 <span class="comment">#обращение к тексту cell1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os, openai</span><br><span class="line"></span><br><span class="line">openai.api_key = os.getenv(<span class="string">"OPENAI_API_KEY"</span>)</span><br><span class="line"></span><br><span class="line">response = openai.Completion.create(</span><br><span class="line">  model=<span class="string">"text-davinci-003"</span>,</span><br><span class="line">  prompt=ss,</span><br><span class="line">  temperature=<span class="number">0.7</span>,</span><br><span class="line">  max_tokens=<span class="number">256</span>,</span><br><span class="line">  top_p=<span class="number">1</span>,</span><br><span class="line">  frequency_penalty=<span class="number">0</span>,</span><br><span class="line">  presence_penalty=<span class="number">0</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>Это позволило ИИ дойти до решения в 9 шагов, однако увеличило время выполнения с 2 до 10 секунд. Дальнейшие предложенные ChatGPT методы оптимизации — распараллеливание работы, построение предпросчитанной базы решений и переход на С++.</p><p>Ни одним из них он не справился сам. Мне не удалось заставить его реализовать свою наивную идею, или предложить её — <em>“если мы знаем, что функции оценки не очень хорошие, то вместо использования очереди приоритетов на каждом шаге, проверим заодно еще группу решений с немного худшей оценкой и посмотрим, не нашлось ли там решения лучше”</em>. Скорее всего, я просто не знаю “правильного” названия этого метода, поэтому пришлось дописать эту логику самому.</p><p>Интересно, что при этом я случайно обнаружил, что существует решение не в 9, а 8 шагов:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">source = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">2</span>]</span><br><span class="line">target = [<span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">path:</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span> ,<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">2</span>] source</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">2</span>] Right(<span class="number">2</span>)</span><br><span class="line">    [<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">2</span>] Left(<span class="number">0</span>)</span><br><span class="line">    [<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">1</span>] Down(<span class="number">3</span>)</span><br><span class="line">    [<span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>] Up(<span class="number">1</span>)</span><br><span class="line">    [<span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>] Left(<span class="number">0</span>)</span><br><span class="line">    [<span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>] Left(<span class="number">2</span>)</span><br><span class="line">    [<span class="number">4</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>] Down(<span class="number">2</span>)</span><br><span class="line">    [<span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>] Up(<span class="number">1</span>) == target</span><br></pre></td></tr></table></figure></p><p><strong>Когда есть возможность быстро попробовать много вариантов, среди них больше шансов обнаружить лучший</strong></p><p>Код: <a href="https://github.com/spiiin/james_bond_jr_problem/blob/main/james_bond_jr_openai.ipynb" target="_blank" rel="noopener">https://github.com/spiiin/james_bond_jr_problem/blob/main/james_bond_jr_openai.ipynb</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;Попробовал
      
    
    </summary>
    
    
    
      <category term="python" scheme="http://spiiin.github.io/tags/python/"/>
    
      <category term="ai" scheme="http://spiiin.github.io/tags/ai/"/>
    
  </entry>
  
  <entry>
    <title>AI prompts</title>
    <link href="http://spiiin.github.io/blog/1596814086/"/>
    <id>http://spiiin.github.io/blog/1596814086/</id>
    <published>2023-04-08T13:02:32.000Z</published>
    <updated>2023-09-03T10:36:07.262Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Потестил немного, что умеют нейронки.</p><p><a href="https://github.com/f/awesome-chatgpt-prompts" target="_blank" rel="noopener">Awesome ChatGPT Prompts</a> - примеры запросов к <code>ChatGPT</code><br><a href="https://trello.com/b/4BPkSY1w/100-ai-prompts-resources-prompt-lovers" target="_blank" rel="noopener">100+ AI Prompts &amp; Resources</a> - еще один список чит-кодов</p><p>Можно попросить ChatGPT сгенерировать развёрнутое описание личности по простому описанию, которое которое можно применить к другому диалогу с ней же. <code>&quot;Act as English translator&quot;</code> — для корректирования своих же запросов на английском, <code>&quot;Act as photographer&quot;</code> — для более красивого описания сцены для генератора изображений. Можно попросить действовать в стиле “Акинатора” — задавать наводящие вопросы по тому, как должна выглядеть описываемая сцена.</p><p>Трюки для <code>Midjourney</code>:<br><a href="https://www.youtube.com/watch?v=NBT7hJEZw4k" target="_blank" rel="noopener">The Ultimate MidJourney Prompting Guide</a> — гайд по фичам midjourney<br><a href="https://medium.com/mlearning-ai/an-advanced-guide-to-writing-prompts-for-midjourney-text-to-image-aa12a1e33b6" target="_blank" rel="noopener">An advanced guide to writing prompts for Midjourney</a> - список стилей<br><a href="https://docs.midjourney.com/docs/explore-prompting" target="_blank" rel="noopener">Explore Prompting</a> — дока, тоже список стилей<br><a href="https://www.youtube.com/watch?v=Asg1e_IYzR8" target="_blank" rel="noopener">GPT-4 + Midjourney V5 = A New Era of Photography?</a> — chat-gpt4 для генерации запросов (act as photograph)<br><a href="https://www.youtube.com/watch?v=N90yjO0bm_w" target="_blank" rel="noopener">Midjourney AI Tutorial | Get AMAZING Midjourney Prompts</a> — генератор в виде опросника (free trial)<br><a href="https://www.youtube.com/watch?v=_7eH8ugjQtg" target="_blank" rel="noopener">I Found the Ultimate CHEAT CODE in Midjourney!</a> — чит с подготовкой фона, на котором будет нарисован следующий промт</p><p>Трюки — детальное описание сцены, подсказки по стилю, “улучшающие” слова вроде hires, best quality, попытки сохранения стиля с повторением сида, дорисовки по исходной картинке, смешивание картинок.</p><p>Одна из фич — позволяет получить несколько детальных описаний из загруженной картинки, чтобы поэкспериментировать с перегенерацией картинки по этому описанию.</p><p>Midjourney рисует лучше Dall-E и StableDiffussion, но платный. Лучше знает названия мест, животных и растений. Для примера сгенерил запросы по местам в Крыму, знает форму дворца Ласточкино Гнездо:<br><img src="/blog/1596814086/gnezdo_small.png" alt=""></p><p><code>StableDiffusion</code> — бесплатный, рисует хуже, обучен на открытых базах, существуют различные модели, заточенные под различные стили или задачи, а также множество инструментов под различные задачи. Можно поставить локально (нужна видеокарта с 6-8 гб памяти). Можно использовать как библиотеку, либо поставить webgui:<br><a href="https://github.com/artmamedov/artroom-stable-diffusion/releases" target="_blank" rel="noopener">Artroom</a><br><a href="https://github.com/AUTOMATIC1111/stable-diffusion-webui" target="_blank" rel="noopener">Stable Diffustion web UI</a><br><a href="https://huggingface.co/models?other=stable-diffusion" target="_blank" rel="noopener">Модели</a></p><p>Примеры работы:<br><a href="https://www.youtube.com/watch?v=PUFlt4JVlvI" target="_blank" rel="noopener">Гравировка за 10 минут в Stable Diffusion для любой 3D МОДЕЛИ</a> - генерация по маске<br><a href="https://www.youtube.com/watch?v=Ffl8b_GfJ-M" target="_blank" rel="noopener">Stable Diffusion Consistent Character Animation Technique - Tutorial</a> - дорисовка по маске позы<br><a href="https://huggingface.co/blog/controlnet" target="_blank" rel="noopener">Ultra fast ControlNet with Diffusers</a> - генерация по драфту, определение позы, <a href="https://huggingface.co/docs/diffusers/main/en/api/pipelines/stable_diffusion/controlnet" target="_blank" rel="noopener">ещё пример</a><br><a href="https://www.youtube.com/watch?v=FLaics4IT-w" target="_blank" rel="noopener">Interactive Map Generation using Stable Diffusion</a> - итеративная дорисовка (если использовать как библиотеку, а не webui, можно было бы вызывать повторения одной функцией)</p><p>Модели плагина <a href="https://www.youtube.com/watch?v=vFZgPyCJflE&amp;list=PLXS4AwfYDUi7zeEgJRM-PfB6KKhXt1faY" target="_blank" rel="noopener">ControlNet</a> для StableDiffusion:<br>    <code>canny</code> - дорисовка по силуэту<br>    <code>depth</code> - дорисовка по карте глубины, эту модель использует также расширение Blender Dream Texture, для проекции текстуры на 3d модель. метод depth-leres позволяет настраивать освещение<br>    <code>openpose</code> - захват позы в виде скелета, openpose editor - редактирование скелета<br>    <code>scribble</code> - по грубому черновику картинки</p><p>Попробовал скормить midjourney скриншот из Botw-ы с узором на дереве, сгенерировал похожие текстуры:<br><img src="/blog/1596814086/wood1_small.png" alt=""></p><p>Так как и Midjourney и Stable Diffusion позволяют сгенерировать тайлящиеся текстуры, то можно пойти дальше и попросить CharGPT написать скрипт, разрезающий результат на части, и отобразить результат сшитой текстуры:<br><img src="/blog/1596814086/gpt1_small.png" alt=""></p><p><img src="/blog/1596814086/wood2_tiled.png" alt=""></p><p>(вместо общения через чат проще использовать <a href="https://github.com/openai/openai-python" target="_blank" rel="noopener">openai</a>)</p><p>Из полученной текстуры можно с помощью ещё одной модели нейронки <a href="https://github.com/HugoTini/DeepBump" target="_blank" rel="noopener">DeepBump</a> получить карту нормалей и высот. <code>DeepBump</code> можно использовать как плагин для Blender или из командной строки:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cli.py color.jpg normals.jpg color_to_normals</span><br><span class="line">cli.py normals.png height.png normals_to_height</span><br></pre></td></tr></table></figure><p>Чтобы посмотреть результат, можно снова попросить ChatGpt написать программу для отображения результата (проще всего выбрать <a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a>):</p><p><em>“Provide code to show plane with diffuse texture and normal map”</em> +<br><em>“provide minimal html page to show this example”</em> +<br><em>“how to run server in python to show this html page?”</em> +<br><em>“change example to rotate not a plane, but light source”</em> +<br><em>“change rotating light from timer to rotating by user with mouse”</em> =<br>Код примера, и напутствие:<br>And that’s it! With this code, you can display a plane with a diffuse texture and normal map. Keep in mind that this is just a simple example and there are many ways to improve and extend it.</p><p><img src="/blog/1596814086/ans2_small.png" alt=""><br><img src="/blog/1596814086/ans1_small.png" alt=""><br><img src="/blog/1596814086/ans3_small.png" alt=""></p><p>Код нагенерированных примеров, 0 строк ручного кода (кроме тыкания параметров материала для бампа — roughness/metalness)<br><a href="https://github.com/spiiin/openai_threejs_bump" target="_blank" rel="noopener">https://github.com/spiiin/openai_threejs_bump</a></p><p>Местами уже может сильно упростить жизнь — собрать несколько простых примеров вместе, напрототипить, выполнить рутинную задачу (иногда с захватом корнер кейсов), получить саммари знаний по теме. С риском галлюцинаций и обмана, но быстрее, чем делать руками.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;Потестил н
      
    
    </summary>
    
    
    
      <category term="procgen" scheme="http://spiiin.github.io/tags/procgen/"/>
    
      <category term="ai" scheme="http://spiiin.github.io/tags/ai/"/>
    
  </entry>
  
  <entry>
    <title>C++ Metaprogramming - ссылки</title>
    <link href="http://spiiin.github.io/blog/4174799834/"/>
    <id>http://spiiin.github.io/blog/4174799834/</id>
    <published>2023-03-19T00:30:26.000Z</published>
    <updated>2023-03-19T20:26:15.820Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Список книг и ресурсов по метапрограммированию в C++. Грубая карта небольшой части огромной территории.</p><p>Желание разобраться с очередным трюком с шаблонами в C++ приходит после обнаружения какой-либо библиотеки или кода, который непонятно как работает, но вроде что-то ловко делает. И заканчивается мыслью “это ж ебануться можно, так писать”.</p><a id="more"></a><p>Такие мысли приходят в голову всем практикующим и работающим в командах программистам. Пара примеров лютых исходников — <a href="https://github.com/lewissbaker/cppcoro" target="_blank" rel="noopener">cppcoro</a>, <a href="https://github.com/ericniebler/range-v3" target="_blank" rel="noopener">range-v3</a> (<a href="https://aras-p.info/blog/2018/12/28/Modern-C-Lamentations/" target="_blank" rel="noopener">“Modern” C++ Lamenations</a>).<br><img src="/blog/4174799834/spiderman.jpg" alt=""></p><p><a href="/blog/2297379949/" title="Заметки о языках программирования">Заметки о языках программирования</a> — про использование различных языков для решения задач различных уровней, а также подходы к борьбе с возрастающей сложностью при масштабируемости.<br><a href="/blog/1728194429/" title="С++ в геймдеве">С++ в геймдеве</a> — “высокоуровневый” С++ - часть задач решаемых метапрограммированием.</p><h2 id="Общий-обзор-возможностей-шаблонов-и-списки-примеров-использования"><a href="#Общий-обзор-возможностей-шаблонов-и-списки-примеров-использования" class="headerlink" title="Общий обзор возможностей шаблонов и списки примеров использования:"></a>Общий обзор возможностей шаблонов и списки примеров использования:</h2><p><strong><code>Vandervoorde D. Josuttis N. Gregor D. - C++ Templates: The Complete Guide</code></strong> - полный обзор возможностей языка, второе издание — по C++17<br><strong><code>Александреску А. - Современное проектирование на C++</code></strong> - pre-C++11, но классические идеи<br><strong><code>Di Genaro D. - Advanced Metaprogramming in Classic C++</code></strong> - много небольших примеров<br><a href="https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms" target="_blank" rel="noopener">More C++ idioms</a> - еще больше примеров, не только с шаблонами<br><a href="https://www.boost.org/" target="_blank" rel="noopener">Boost</a> - лучший учебник</p><h2 id="Generic-типы"><a href="#Generic-типы" class="headerlink" title="Generic-типы"></a>Generic-типы</h2><p>Часто первое столкновение с шаблонами — обобщенные контейнеры, итераторы и умные указатели из <code>stl</code><br>Более продвинутые примеры — стратегии Александреску, задание отношений между типами, CRTP, template template параметры</p><p><a href="https://github.com/skypjack/entt/blob/master/src/entt/container/dense_set.hpp" target="_blank" rel="noopener">EnTT dense set</a> - пример кода контейнера и итератора не из stl<br><a href="https://github.com/tamasmeszaros/libnest2d/blob/master/include/libnest2d/libnest2d.hpp" target="_blank" rel="noopener">libnest2d</a> - небольшая библиотека для паковки многоугольников, использующая стратегии для выбора вариантов оптимизации, паковки и математического бекэнда</p><h2 id="Задание-ограничений-и-свойств-для-типов"><a href="#Задание-ограничений-и-свойств-для-типов" class="headerlink" title="Задание ограничений и свойств для типов"></a>Задание ограничений и свойств для типов</h2><p>Контракты, распознавание свойств типов (<code>std::is_XXX</code>), частичная специализация</p><p><strong><code>Stepanov A. - Elements of programming</code></strong> - математическое описание типов и структур, контракты<br><a href="https://sean-parent.stlab.cc/papers-and-presentations/" target="_blank" rel="noopener">Lecture and presentation Sean Parent</a> - и другие лекции Шона Парента, про value-oriented programming</p><p><a href="https://github.com/GaijinEntertainment/daScript/pull/472/files#diff-2a42eb62b92995bc578cc927dc871b66a1a00f003c819a108abd291e23b33bb1R150" target="_blank" rel="noopener">Пример из daScript</a> — частичная специализация с захватом новых шаблонных параметров<br><a href="https://stackoverflow.com/questions/4189945/templated-class-specialization-where-template-argument-is-a-template" target="_blank" rel="noopener">Templated class specialization where template argument is a template</a> - описание возможных подходов к созданию связи между шаблонными параметрами</p><h2 id="Работа-с-типами-как-с-данными"><a href="#Работа-с-типами-как-с-данными" class="headerlink" title="Работа с типами как с данными"></a>Работа с типами как с данными</h2><p>Типы не являются объектами первого класса, поэтому работы с ними, поэтому все действия выполняются во время компиляции. Один из ключевых приёмов — выбор того, или иного типа в зависимости от статически известного условия. При этом не определяется новый тип, а создаётся псевдоним для существуюшего, “слот”, в который можно сохранить любой тип (<code>typedef</code>). Типы используются не для создания экземпляров, а для вообще чего угодно, от управляющих конструкций и отправки сигналов в рантайм, до операций группировки других типов.</p><p><strong><code>Abrahams D. Gurtovoy A. - C++ Template Metaprogramming</code></strong> - одна из наиболее замороченных книг, pre-C++11. Частично описывает <a href="https://www.boost.org/doc/libs/1_43_0/libs/mpl/doc/index.html" target="_blank" rel="noopener">Boost.MPL</a><br><a href="https://www.boost.org/doc/libs/master/libs/mp11/doc/html/mp11.html" target="_blank" rel="noopener">Boost.Mp11</a> - C++11-версия библиотеки для манипуляции с типами, несколько статей сравнения новых подходов со старыми</p><h2 id="Domain-Specific-Language"><a href="#Domain-Specific-Language" class="headerlink" title="Domain Specific Language"></a>Domain Specific Language</h2><p>Следующая идея — пойти еще дальше: построить на специальных типах свой язык, с управляющими конструкциями. Примеры задач — парсинг команд и создание деревьев выражений для последующего вычисления в рантайме.</p><p><a href="https://www.youtube.com/watch?v=r_ZASJFQGQI" target="_blank" rel="noopener">Hana Dusíková — A state of сompile time regular expressions</a> — регулярные выражения в compile-time (<a href="https://github.com/hanickadot/compile-time-regular-expressions" target="_blank" rel="noopener">compile-time.re</a>)<br><a href="https://www.youtube.com/watch?v=PJwd4JLYJJY" target="_blank" rel="noopener">Ben Deane &amp; Jason Turner “constexpr ALL the Things!”</a> — парсинг json в compile-time</p><p><a href="/blog/1552834708/" title="Runtime-полиморфизм в C++">Runtime-полиморфизм в C++</a> - пост со ссылками на серию видео про построение в compile-time кастомных версий динамического полиморфизма. <a href="https://github.com/ldionne/dyno" target="_blank" rel="noopener">dyno</a> - библиотека Louis Dionne, автора Boost.Hana</p><h2 id="Выполнение-кода-в-compile-time"><a href="#Выполнение-кода-в-compile-time" class="headerlink" title="Выполнение кода в compile-time"></a>Выполнение кода в compile-time</h2><p>Изначально возможность выполнения кода во время компиляции в С++ была артефактом шаблонов (первая “программа” - вывод простых чисел в сообщении об ошибке). Со временем добавляются более серьёзные возможности, однако код времени компиляции серьёзно ограничен и отличается от среды выполнения.</p><p>Примеры задач в compile-time:</p><ul><li>заранее предпосчитать значение выражение, все части которого известны на момент компиляции</li><li>построить таблицу значений чистой функции, которая долго вычисляется</li></ul><p>Основная возможность в pre-C++11 - SFINAE и рекурсивные+терминальные пары функций, и дополнительно const-expr/if/eval в более поздних стандартах.</p><p><a href="https://www.youtube.com/watch?v=NNU6cbG96M4" target="_blank" rel="noopener">Don’t constexpr All the Things - David Sankel CppNow 2021</a> - обзор ограничений подъязыка времени выполнения<br><a href="https://www.circle-lang.org/" target="_blank" rel="noopener">Circle</a> - wip компилятор C++ Шона Бакстера, с возможностью выполнение кода на этапе компиляции без ограничений<br><a href="https://probablydance.com/2015/02/16/ideas-for-a-programming-language-part-3-no-shadow-worlds/" target="_blank" rel="noopener">Ideas for a Programming Language Part 3: No Shadow Worlds</a> - похожие рассуждения на тему того, что не полностью интегрированные в основной язык подмножества создают “теневые миры”, в которых приходится переизобреть заново возможности основного языка</p><p><em>В Circle меня настораживает, что код, кажется, должен компилироваться дважды, особенно с учетом того, что скорее всего выполнение кода в compile-time будет медленнее, чем в рантайм. Для nim выполнение кода в compile-time — раз в 10 медленее</em></p><h2 id="Доступ-к-данным-о-типах-в-рантайм"><a href="#Доступ-к-данным-о-типах-в-рантайм" class="headerlink" title="Доступ к данным о типах в рантайм"></a>Доступ к данным о типах в рантайм</h2><p>Отсутствует в C, и не zero-cost абстракция, так что в стандарте языка отсутствует механизм неявной передачи информации о типах в рантайм (можно откопать <a href="https://youtu.be/NWIsRFDaHhs?t=847" target="_blank" rel="noopener">пачку</a> предложений для будущих улучшений).</p><p>Поэтому задачи типа <code>рефлексии/инстроспекции</code> решаются либо явной декларацией полей и методов класса (как при создании врапперов для других языков), либо предварительным внешним парсингом кода — либо кастомной метаинформации, которую пропускает компилятор C++ (в комментариях), либо полноценным разбором кода (<code>clang</code>), с последующей генерацией по этой информации кода.</p><p>Аналогично, без явной интроспекции и вещи вроде <code>сериализации</code> или описания RPC не могут быть неявными — необходимо явно аннотировать типы. </p><p><code>Кодогенерация</code> выражений на C++ в рантайме также отсутствует в стандарте, и заменяется генерации во время компиляции — текста, либо бинарного кода (или промежуточного кода, вроде IR для LLVM).</p><p><a href="/blog/315556844/" title="LLVM - обзор">LLVM - обзор</a> — обзор тулзов из набора LLVM, для парсинга и генерации кода, в настоящий момент state-of-art для генерации кода на C++<br><a href="https://www.youtube.com/watch?v=aPTyatTI42k" target="_blank" rel="noopener">Automatic C++ source code generation with clang - Sergei Sadovnikov ACCU 2017</a> - доклад с обзором подходов, и способа генерации с помощью clang<br><a href="https://www.youtube.com/watch?v=NWIsRFDaHhs" target="_blank" rel="noopener">Reflection in C++ Next - Anton Bikineev - Meeting C++ 2017</a> - обзор пропозалов в стандарт, связанных с рефлексией<br><a href="https://www.boost.org/doc/libs/1_79_0/libs/serialization/doc/tutorial.html" target="_blank" rel="noopener">Boost.Serialization</a> - сериализация в Boost</p><h2 id="Функциональное-программирование"><a href="#Функциональное-программирование" class="headerlink" title="Функциональное программирование"></a>Функциональное программирование</h2><p>Обширная тема. Элементы функционального стиля программирования — <code>комбинирование функций</code> (функции высшего порядка, частичное применение, отложенные вычисления) и их <code>чистота</code>. Часть перечисленных выше методов метапрограммирования направлена на борьбу со возрастающей при масштабировании программ сложностью путем создания новых абстракций. Функциональное программирование также работает с абстракциями, но выбирает их со стороны математики, ради того, чтобы использовать свойства уже изученных объектов (с поправкой на то, что в языках программирования реализуются приближения к математическим объектам).</p><p><strong><code>Чукич И. - Функциональное программирование на языке С++</code></strong> — книга о том, как использовать элементы функционального программирования на C++, ссылки на библиотеки буста, реализующие концепции<br><a href="https://github.com/hmemcpy/milewski-ctfp-pdf/" target="_blank" rel="noopener">Milewski B. - Category Theory For Programmers</a> - серия статей (собранная в книгу), по теории категорий для программистов, с примерами на C++ и хаскелл. <a href="https://www.youtube.com/watch?v=I8LbkfSSR58&amp;list=PLbgaMIhjbmEnaH_LTkxLI7FMa2HsnawM_" target="_blank" rel="noopener">Видеолекции</a> на ту же тему<br><a href="https://www.gamedeveloper.com/programming/in-depth-functional-programming-in-c-" target="_blank" rel="noopener">In-depth: Functional programming in C++</a> - статья Кармака про бонусы, которые можно получить, если использовать функциональный подход, в частности, бонусы от чистоты функций</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Список книг и ресурсов по метапрограммированию в C++. Грубая карта небольшой части огромной территории.&lt;/p&gt;
&lt;p&gt;Желание разобраться с очередным трюком с шаблонами в C++ приходит после обнаружения какой-либо библиотеки или кода, который непонятно как работает, но вроде что-то ловко делает. И заканчивается мыслью “это ж ебануться можно, так писать”.&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="cpp" scheme="http://spiiin.github.io/tags/cpp/"/>
    
      <category term="книги" scheme="http://spiiin.github.io/tags/%D0%BA%D0%BD%D0%B8%D0%B3%D0%B8/"/>
    
      <category term="link" scheme="http://spiiin.github.io/tags/link/"/>
    
  </entry>
  
  <entry>
    <title>daScript - контексты</title>
    <link href="http://spiiin.github.io/blog/3298324261/"/>
    <id>http://spiiin.github.io/blog/3298324261/</id>
    <published>2023-03-08T11:57:37.000Z</published>
    <updated>2023-04-06T23:11:55.267Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>В заметке про <a href="/blog/3006126295/" title="live-режим">live-режим</a> для opengl-приложений в daScript я кратко описывал контексты (раздел <code>Архитектура приложения</code>). Здесь разберу их немного более подробно.</p><a id="more"></a><h2 id="Контекст"><a href="#Контекст" class="headerlink" title="Контекст"></a>Контекст</h2><p>Программы daScript выполняются в <a href="https://github.com/GaijinEntertainment/daScript/blob/master/include/daScript/simulate/simulate.h#L252" target="_blank" rel="noopener">контексте</a>, структуре, которая хранит окружение программы — выделенную память, в которой хранятся код и данные программы, загруженные модули, настройки виртуальной машины.</p><p><a href="https://github.com/GaijinEntertainment/daScript/blob/master/examples/tutorial/tutorial06.cpp" target="_blank" rel="noopener">tutorual06</a> показывает работу с контекстом в daScript:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//загружаем das-файл и компилируем его</span></span><br><span class="line"><span class="keyword">auto</span> program = compileDaScript(<span class="string">"dummy.das"</span>, fAccess, tout, dummyLibGroup);</span><br><span class="line"><span class="comment">//создаём контекст, в котором будет выполняться программа</span></span><br><span class="line">ContextPtr ctx = make_shared&lt;Context&gt;(program-&gt;getContextStackSize());</span><br><span class="line"><span class="comment">//симулируем выполнение программу (строит дерево симуляции для выполнения в виртуальной машине)</span></span><br><span class="line">program-&gt;simulate(*ctx, tout);</span><br><span class="line"><span class="comment">//находим в контексте скомпилированную функцию</span></span><br><span class="line">SimFunction *fni = ctx-&gt;findFunction(<span class="string">"test"</span>);</span><br><span class="line"><span class="comment">//тут могут быть опциональные стадии проверки сигнатуры функции</span></span><br><span class="line">verifyCall&lt;<span class="keyword">float</span>&gt;(fni-&gt;debugInfo, dummyLibGroup);</span><br><span class="line"><span class="comment">//выполняем функцию в контексте, тип результата -- 128-бит</span></span><br><span class="line">vec4f res = ctx-&gt;evalWithCatch(fni, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="comment">//приводим результат к C++-типу</span></span><br><span class="line"><span class="keyword">float</span> result = cast&lt;<span class="keyword">float</span>&gt;::to(res);</span><br></pre></td></tr></table></figure><p>(<a href="/blog/2115627465/" title="Устройство интерпретаторов lua-jit и daScript">Устройство интерпретаторов lua-jit и daScript</a> — немного более детально про симуляцию программы)</p><p>Создание и удаление контекстов в daScript дешёво, один из паттернов организации C++-приложения, использующего daScript — выделение нового контекста, выполнение в нём работы и уничтожение.</p><p>Контекст можно воспринимать как экземпляр выполняющейся программы. Программа на С++ может иметь несколько контекстов, каждый из которых может выполнять программу на daScript (как скомпилированную из различных das-файлов, так и из одного и того же).</p><h2 id="Создание-контекста-из-daScript"><a href="#Создание-контекста-из-daScript" class="headerlink" title="Создание контекста из daScript"></a>Создание контекста из daScript</h2><p>API для создания контекстов также доступно в самом daScript, так что скрипт сам может создавать новые контексты и выполнять в них программы.</p><p>Пример <a href="https://github.com/GaijinEntertainment/daScript/blob/master/examples/test/misc/eval_in_context.das" target="_blank" rel="noopener">eval_in_context</a>:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//создание текста программы</span></span><br><span class="line">let text = build_string &lt;| $(st)</span><br><span class="line">    st |&gt; write(<span class="string">"[export]\n"</span>)</span><br><span class="line">    st |&gt; write(<span class="string">"def eval(var res:int?)\n"</span>)</span><br><span class="line">    st |&gt; write(<span class="string">"\tunsafe\n"</span>)</span><br><span class="line">    st |&gt; write(<span class="string">"\t\t*res = 42\n"</span>)</span><br><span class="line">    st |&gt; write(<span class="string">"\n"</span>)</span><br><span class="line"><span class="comment">//def eval(var res:int?)</span></span><br><span class="line"><span class="comment">//  unsafe</span></span><br><span class="line"><span class="comment">//      *res = 42</span></span><br><span class="line"></span><br><span class="line">access |&gt; set_file_source(<span class="string">"__dummy_file_name"</span>, text)</span><br><span class="line">  <span class="keyword">using</span> &lt;| $(var mg:ModuleGroup)</span><br><span class="line">    <span class="keyword">using</span> &lt;| $(var cop:CodeOfPolicies)</span><br><span class="line">      <span class="comment">//компилируем строку с текстом программы</span></span><br><span class="line">      compile_file(<span class="string">"__dummy_file_name"</span>,access,unsafe(addr(mg)), cop) &lt;| $(ok,program,errors)</span><br><span class="line">        <span class="comment">//строим дерево симуляции</span></span><br><span class="line">        simulate(program) &lt;| $ (sok; context; serrors )</span><br><span class="line">          unsafe</span><br><span class="line">            var res:<span class="keyword">int</span></span><br><span class="line">            <span class="comment">//выполняем функцию eval в контексте скомпилированной программы</span></span><br><span class="line">            context |&gt; invoke_in_context(<span class="string">"eval"</span>, addr(res))</span><br><span class="line">            print(<span class="string">"&#123;res&#125;\n"</span>)</span><br></pre></td></tr></table></figure><p>В примере выше в скомплированные программу передаётся адрес из другого контекста. Это небезопасно, так как один контекст ничего не знает про время жизни переменных другом, поэтому операция отмечена как <code>unsafe</code>.</p><h2 id="Форк-контекста"><a href="#Форк-контекста" class="headerlink" title="Форк контекста"></a>Форк контекста</h2><p>Кроме возможности иметь раздельные контексты, daScript позволяет склонировать существующий контекст — <a href="https://github.com/GaijinEntertainment/daScript/blob/cd448fdbd4c6aa81897d2a8543943af112e2cbeb/src/simulate/simulate.cpp#L1659" target="_blank" rel="noopener">fork_debug_agent_context</a>. Функция создаёт клон контекста, и выставляет флаг контекста <code>persistent</code>, а затем в этом клонированном контексте выполняет функцию инициализации, переданную аргументом. Обычно в этой функции регистрируется новый <code>DebugAgent</code> — обёртка над контекстом, которая позволяет найти указатель на склонированный контекст по имени (и опционально, изменить поведение с помощью хуков). Склонированный контекст имеет доступ к тому же окружению, что и основной (модули, функции, копии переменных).</p><p><strong>Склонированный контекст не копирует состояние из основного!</strong></p><p>Пример <a href="https://github.com/GaijinEntertainment/daScript/blob/726d440be7618fb431815b18e6f785c37a335d5d/examples/test/misc/agent_fork_sample.das" target="_blank" rel="noopener">agent_fork_sample.das</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">require debugapi</span><br><span class="line"></span><br><span class="line">var test_value = <span class="string">"default"</span></span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>] def debug_context_set()</span><br><span class="line">    print(<span class="string">"&#123;this_context().name&#125;:&#123;test_value&#125;\n"</span>)</span><br><span class="line">    test_value = <span class="string">"debug_context"</span> <span class="comment">//изменить значение переменной в контексте debug_context</span></span><br><span class="line">    print(<span class="string">"&#123;this_context().name&#125;:&#123;test_value&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main</span><br><span class="line">    this_context().name := <span class="string">"my_context"</span></span><br><span class="line">    fork_debug_agent_context &lt;| @@(var new_context : Context)</span><br><span class="line">        <span class="comment">//вызывается в новом контексте, устанавливаем DebugAgent, который сохранит ссылку на новый контекст</span></span><br><span class="line">        install_new_debug_agent(<span class="keyword">new</span> DapiDebugAgent(), <span class="string">"debug_context"</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"&#123;this_context().name&#125;:&#123;test_value&#125;\n"</span>)</span><br><span class="line">    <span class="comment">//меняем значение глобальной переменной</span></span><br><span class="line">    test_value = <span class="string">"my_context"</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"&#123;this_context().name&#125;:&#123;test_value&#125;\n"</span>)</span><br><span class="line">    <span class="comment">//ждём создания контекста агента</span></span><br><span class="line">    <span class="keyword">while</span> !has_debug_agent_context(<span class="string">"debug_context"</span>)</span><br><span class="line">        pass</span><br><span class="line">    unsafe</span><br><span class="line">        <span class="comment">//изменяем значение переменной в контексте debug_context</span></span><br><span class="line">        get_debug_agent_context(<span class="string">"debug_context"</span>) |&gt; invoke_in_context(<span class="string">"debug_context_set"</span>)</span><br><span class="line">    </span><br><span class="line">    print(<span class="string">"&#123;this_context().name&#125;:&#123;test_value&#125;\n"</span>)</span><br></pre></td></tr></table></figure><p>Выведет:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">my_context:default                            &#x2F;&#x2F; в основном контексте test_value имеет значение по умолчанию</span><br><span class="line">my_context:my_context                         &#x2F;&#x2F; изменили значение в основном контексте</span><br><span class="line">debug agent debug_context:default             &#x2F;&#x2F; &lt;--в склонированном контексте test_value имеет значение по умолчанию</span><br><span class="line">debug agent debug_context:debug_context       &#x2F;&#x2F; изменили значение в склонированном контексте</span><br><span class="line">my_context:my_context                         &#x2F;&#x2F; в основном контексте значение test_value не изменилось</span><br></pre></td></tr></table></figure></p><p>Аннотация для функций <a href="https://github.com/GaijinEntertainment/daScript/blob/726d440be7618fb431815b18e6f785c37a335d5d/examples/test/misc/apply_in_context_example.das" target="_blank" rel="noopener">apply_in_context</a> позволяет вызывать функцию в другом контексте прозрачно для вызывающего кода. Пример выше можно переписать так:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">require daslib/apply_in_context</span><br><span class="line"></span><br><span class="line">[apply_in_context(debug_context)]</span><br><span class="line"><span class="function">def <span class="title">debug_context_set</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;this_context().name&#125;:&#123;test_value&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function">    test_value </span>= <span class="string">"debug_context"</span> <span class="comment">//изменить значение переменной в контексте debug_context</span></span><br><span class="line">    print(<span class="string">"&#123;this_context().name&#125;:&#123;test_value&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line">...<span class="comment">//тот же код создания агента</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> !has_debug_agent_context(<span class="string">"debug_context"</span>)</span><br><span class="line">    pass</span><br><span class="line">debug_context_set() <span class="comment">//функция будет вызвана в контексте debug_context</span></span><br></pre></td></tr></table></figure><p>Пример создания отдельного контекста — модуль <a href="https://github.com/GaijinEntertainment/daScript/blob/master/daslib/live.das#L189" target="_blank" rel="noopener">live</a>, пример клонирования — <a href="https://github.com/GaijinEntertainment/daScript/blob/5649b32e8b779ceb90b7eabd73f58b7d2077cff6/modules/dasOpenGL/opengl/opengl_cache.das#L56" target="_blank" rel="noopener">opengl_cache</a>.</p><h2 id="Переопределение-поведения-debug-агентов"><a href="#Переопределение-поведения-debug-агентов" class="headerlink" title="Переопределение поведения debug-агентов"></a>Переопределение поведения debug-агентов</h2><p>Можно вызвать функции, определённые в классе-наследнике debug-агента (<a href="https://github.com/GaijinEntertainment/daScript/blob/37b86881a8f4890913e2f80537708575c3441a3f/examples/test/misc/invoke_debug_agent_function.das" target="_blank" rel="noopener">invoke_debug_agent_function</a>), но намного более интересной возможностью является переопределения методов. Виртуальная машина daScript отслеживает наличие зарегистрированных отладочных агентов и передаёт им информацию в ходе выполнения программы — интерфейс <a href="https://github.com/GaijinEntertainment/daScript/blob/62f8b1b2ff4c873c9fc1b7ada61ed332fb349e4c/src/builtin/debugger.das#L10" target="_blank" rel="noopener">DapiDebugAgent</a>.</p><p>Простые примеры определения кастомных debug-агентов:<br><a href="https://github.com/GaijinEntertainment/daScript/blob/685f0415fc1cb2d52ae6c875f702eb7c09862e38/examples/test/misc/logger_and_logger_agent.das" target="_blank" rel="noopener">logger_agent</a> — добавление кастомного префикса при логгировании<br><a href="https://github.com/GaijinEntertainment/daScript/blob/eaa99142af33e7499137c4c7351d02075223cd5b/examples/test/misc/insturment_function.das" target="_blank" rel="noopener">insturment_function</a> — профилирование вызовов функций.<br><a href="https://github.com/GaijinEntertainment/daScript/blob/726d440be7618fb431815b18e6f785c37a335d5d/examples/test/misc/instrument.das" target="_blank" rel="noopener">instrument</a> — программный брейкпоинт и пошаговая трассировка</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">options debugger = <span class="literal">true</span>    <span class="comment">//настройка контекста для работы с хуками debug-агентов</span></span><br><span class="line">require debugapi           <span class="comment">//интерфейсы для кастомных debug-агентов</span></span><br><span class="line">require rtti               <span class="comment">//получение информации о контексте выполнения (доступные модули/функции/переменные/etc)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//программный брейкпоинт, вызывает хук onBreakpoint в debug-агенте</span></span><br><span class="line">breakpoint</span><br><span class="line"><span class="comment">//устанавливает номер строчки, для которой будет вызван хук onInstrument</span></span><br><span class="line">instrument_node </span><br><span class="line"><span class="comment">//устанавливает режим трассирования, хук onSingleStep будет вызван для каждой строчки выполнения до отключения</span></span><br><span class="line">set_single_step</span><br><span class="line"><span class="comment">//устанавливает фильтр на функции, для которых будет вызван хук onInstrumentFunction </span></span><br><span class="line">instrument_all_functions</span><br><span class="line"><span class="comment">//вызывает хук onLog</span></span><br><span class="line">to_log</span><br><span class="line"><span class="comment">//вызывает хук onCollect</span></span><br><span class="line">collect_debug_agent_state</span><br><span class="line"><span class="comment">//вызывает хук onVariable у установленного DapiStackWalker</span></span><br><span class="line">report_context_state</span><br></pre></td></tr></table></figure><p>Более сложные примеры:<br><a href="https://github.com/GaijinEntertainment/daScript/blob/726d440be7618fb431815b18e6f785c37a335d5d/examples/test/misc/stackwalk.das" target="_blank" rel="noopener">stackwalk</a> — более продвинутая версия <code>instrument</code>, устанавливает кастомный <code>DapiStackWalker</code> и <code>DapiDataWalker</code>, печатает значение локальных переменных на каждом шаге<br><a href="https://github.com/GaijinEntertainment/daScript/blob/66e627465d8aca7934c4b6a92f2fc0d16347c9f7/examples/test/misc/context_state_example.das" target="_blank" rel="noopener">context_state_example</a> — еще немного более полная версия информации о переменных, уже более похожая на информацию для отладчика<br><a href="https://github.com/GaijinEntertainment/daScript/blob/767ebf69143244c544dacdc2efed5a7410940ed5/modules/dasOpenGL/opengl/opengl_state.das" target="_blank" rel="noopener">opengl_state</a> — в хуке onCollect печатает информацию о состояниях OpenGL<br><a href="https://github.com/GaijinEntertainment/daScript/blob/62f8b1b2ff4c873c9fc1b7ada61ed332fb349e4c/daslib/decs_state.das" target="_blank" rel="noopener">decs_state</a> — собирает информацию из модуля <code>decs</code> (entity-component-system)<br><a href="https://github.com/GaijinEntertainment/daScript/blob/62f8b1b2ff4c873c9fc1b7ada61ed332fb349e4c/daslib/ast_debug.das" target="_blank" rel="noopener">ast_debug</a> — информация о состоянии expression tree, для отладки макросов</p><h2 id="Инструмнты-основе-debug-агентов"><a href="#Инструмнты-основе-debug-агентов" class="headerlink" title="Инструмнты  основе debug-агентов"></a>Инструмнты  основе debug-агентов</h2><p>Полноценный <strong><code>отладчик</code></strong> — <a href="https://github.com/GaijinEntertainment/daScript/blob/2695f756b17bc184016ea97973ef143a669a937e/daslib/debug.das" target="_blank" rel="noopener">debug</a> (debug-агент + сервер для связи с IDE) (<a href="https://marketplace.visualstudio.com/items?itemName=profelis.dascript-plugin" target="_blank" rel="noopener">плагин для vscode</a>):<br>(необходимо определить <code>#define DAS_DEBUGGER 1</code> если это по каким-то причинам не определилось в das_config.h автоматически)<br><img src="/blog/3298324261/debugger.png" alt=""></p><p>Более продвинутый <a href="https://borisbat.github.io/dascf-blog/2022/12/11/instruments/" target="_blank" rel="noopener">пример</a> <strong><code>instrument_function</code></strong> — обёртка, сохраняющая результат в файл, который можно посмотреть в виде флеймграфа.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;В заметке про &lt;a href=&quot;/blog/3006126295/&quot; title=&quot;live-режим&quot;&gt;live-режим&lt;/a&gt; для opengl-приложений в daScript я кратко описывал контексты (раздел &lt;code&gt;Архитектура приложения&lt;/code&gt;). Здесь разберу их немного более подробно.&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="dascript" scheme="http://spiiin.github.io/tags/dascript/"/>
    
  </entry>
  
  <entry>
    <title>daScript - мелочи</title>
    <link href="http://spiiin.github.io/blog/1728452067/"/>
    <id>http://spiiin.github.io/blog/1728452067/</id>
    <published>2023-03-05T18:25:54.000Z</published>
    <updated>2023-03-11T12:22:51.682Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Научился читать грамматику для bison, нашёл несколько новых для себя мелочей синтаксиса <a href="https://github.com/GaijinEntertainment/daScript/blob/master/src/parser/ds_parser.ypp" target="_blank" rel="noopener">daScript</a>.<br><a id="more"></a></p><p><strong><code>1. assume</code></strong><br>Аналог <code>#define</code> в си, текстовая подстановка выражений. Со всеми ее минусами.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var a = <span class="string">"global_string"</span></span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main</span><br><span class="line">    assume x = a <span class="comment">//not capture global var a, but only text name</span></span><br><span class="line">    var a = <span class="string">"local string"</span></span><br><span class="line">    x = <span class="string">"changed string"</span> <span class="comment">//change local, but not global a!</span></span><br><span class="line">    print(<span class="string">"&#123;a&#125;\n"</span>)</span><br><span class="line">    print(<span class="string">"&#123;::a&#125;\n"</span>)</span><br><span class="line"><span class="comment">//changed string</span></span><br><span class="line"><span class="comment">//global_string</span></span><br></pre></td></tr></table></figure><p><strong><code>2. =&gt;</code></strong></p><p>Символ стрелки используется для записи коротких блоков/лямбд/безымянных функций:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">radd</span><span class="params">(var ext:<span class="keyword">int</span>&amp;; b:block&lt;(var arg:<span class="keyword">int</span>&amp;):<span class="keyword">int</span>&gt;)</span>:<span class="keyword">int</span></span></span><br><span class="line"><span class="function">    <span class="keyword">return</span> <span class="title">invoke</span><span class="params">(b,ext)</span></span></span><br><span class="line"><span class="function">def <span class="title">radd</span><span class="params">(var ext:<span class="keyword">int</span>&amp;; b:lambda&lt;(var arg:<span class="keyword">int</span>&amp;):<span class="keyword">int</span>&gt;)</span>:<span class="keyword">int</span></span></span><br><span class="line"><span class="function">    <span class="keyword">return</span> <span class="title">invoke</span><span class="params">(b,ext)</span></span></span><br><span class="line"><span class="function">def <span class="title">radd</span><span class="params">(var ext:<span class="keyword">int</span>&amp;; b:function&lt;(var arg:<span class="keyword">int</span>&amp;):<span class="keyword">int</span>&gt;)</span>:<span class="keyword">int</span></span></span><br><span class="line"><span class="function">    <span class="keyword">return</span> <span class="title">invoke</span><span class="params">(b,ext)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">[export]</span><br><span class="line">def main</span><br><span class="line">    var x = <span class="number">0</span></span><br><span class="line">    radd(x, $(a) =&gt; a++) </span><br><span class="line">    radd(x, @(a) =&gt; a++)</span><br><span class="line">    radd(x, @@(a) =&gt; a++) </span><br><span class="line">    print(<span class="string">"&#123;x&#125;\n"</span>)</span><br><span class="line">    <span class="comment">//Output: 3</span></span><br></pre></td></tr></table></figure><p>А также для записи создания кортежей и таблиц:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var x &lt;- [[<span class="keyword">auto</span> <span class="number">1</span>=&gt;<span class="string">"one"</span>]] <span class="comment">//работает также в массивах [[auto 1=&gt;"one"; 2=&gt;"two"]]</span></span><br><span class="line">print(<span class="string">"&#123;x&#125; &#123;typeinfo(typename x)&#125;\n"</span>)</span><br><span class="line"><span class="comment">//[[ 1; one]] tuple&lt;int;string&gt; - кортеж</span></span><br><span class="line">var y &lt;- &#123;&#123; <span class="number">1</span>=&gt;<span class="string">"one"</span>&#125;&#125;</span><br><span class="line">print(<span class="string">"&#123;y&#125; &#123;typeinfo(typename y)&#125;\n"</span>)</span><br><span class="line"><span class="comment">//[[ 1 : one]] table&lt;int;string&gt; - таблица</span></span><br></pre></td></tr></table></figure><p><strong><code>3. auto для инициализации</code></strong></p><p>auto при инициализации может выводить тип массивов (статических и динамических) и кортежей. Для структур — не может</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">printType</span><span class="params">(a)</span> </span>&#123; print(<span class="string">"&#123;typeinfo(typename a)&#125;\n"</span>); &#125;</span><br><span class="line">printType([[<span class="keyword">auto</span> <span class="number">1</span>=&gt;<span class="number">2</span>]]) <span class="comment">//tuple&lt;int;int&gt; const</span></span><br><span class="line">printType([[<span class="keyword">auto</span> <span class="number">1</span>,<span class="number">2</span>]])  <span class="comment">//tuple&lt;int;int&gt; const</span></span><br><span class="line">printType([[<span class="keyword">auto</span> <span class="number">1</span>;<span class="number">2</span>]])  <span class="comment">//int const[2]</span></span><br><span class="line">printType([&#123;<span class="keyword">auto</span> <span class="number">1</span>;<span class="number">2</span>&#125;])  <span class="comment">//array&lt;int&gt; const</span></span><br></pre></td></tr></table></figure><p><strong><code>4. сокращенная запись при обьявлении переменных ссылочных типов</code></strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">let a = <span class="number">1</span></span><br><span class="line">let ar&amp; = a <span class="comment">//let ar: int&amp; = a</span></span><br></pre></td></tr></table></figure></p><p><strong><code>5. if после выражений</code></strong><br>Условие может стоять после определённых выражений (с опциональной веткой else):</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">def fun</span><br><span class="line">    print(<span class="string">"1"</span>) <span class="function"><span class="keyword">if</span> <span class="literal">true</span> <span class="keyword">else</span> <span class="title">print</span><span class="params">(<span class="string">"2"</span>)</span>  <span class="comment">//expr if</span></span></span><br><span class="line"><span class="function">    <span class="keyword">while</span> <span class="literal">true</span></span></span><br><span class="line"><span class="function">        <span class="keyword">break</span> <span class="keyword">if</span> <span class="literal">true</span> <span class="keyword">else</span> <span class="keyword">continue</span> <span class="comment">//break if</span></span></span><br><span class="line"><span class="function">        <span class="keyword">continue</span> <span class="keyword">if</span> <span class="literal">false</span> <span class="comment">//continue if</span></span></span><br><span class="line">    return &lt;- generator&lt;int&gt;() &lt;| $() </span><br><span class="line">        <span class="function"><span class="keyword">for</span> t in <span class="title">range</span><span class="params">(<span class="number">0</span>,<span class="number">10</span>)</span></span></span><br><span class="line"><span class="function">            yield t <span class="keyword">if</span> <span class="literal">true</span> <span class="comment">//yield if</span></span></span><br><span class="line"><span class="function">        <span class="keyword">return</span> <span class="literal">false</span> <span class="keyword">if</span> <span class="literal">true</span> <span class="comment">//return if</span></span></span><br></pre></td></tr></table></figure><p><strong><code>6. aka</code></strong><br>Синоним для имени переменной (как намного менее “злобный” вариант <code>assume</code>)<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var a aka b: <span class="keyword">int</span></span><br><span class="line">b = <span class="number">1</span></span><br><span class="line">print(<span class="string">"&#123;a&#125;\n"</span>) <span class="comment">//1</span></span><br></pre></td></tr></table></figure></p><p><strong><code>7. expect</code></strong></p><p>Ключевое слово для тестового фреймворка <a href="https://borisbat.github.io/dascf-blog/2023/02/25/wake-up-and-test-the-damn-thing/" target="_blank" rel="noopener">dasTest</a><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">expect <span class="number">10003</span>:<span class="number">1</span>, <span class="number">20000</span>:<span class="number">1</span></span><br><span class="line"><span class="comment">//ожидается по одной ошибке компилятора типа 10003 и 20000 (незакрытая кавычка и неожиданный конец файла)</span></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def test</span><br><span class="line">    print(<span class="string">"ok</span></span><br></pre></td></tr></table></figure><br>Для запуска теста нужно вызвать скрипт <a href="https://github.com/GaijinEntertainment/daScript/tree/master/dastest" target="_blank" rel="noopener">dastest</a> и передает в параметре <code>test</code> имя скрипт для тестирования (или директории с группой скриптов):<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">daScript dastest.das -- --test my_test.das</span><br></pre></td></tr></table></figure></p><p><strong><code>8. named arguments</code></strong></p><p>Функцию можно вызвать с <a href="https://dascript.org/doc/reference/language/functions.html?highlight=named#named-arguments-function-call" target="_blank" rel="noopener">явными именами</a> аргументов.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">foo</span><span class="params">(a:<span class="keyword">int</span>=<span class="number">13</span>; b: <span class="keyword">int</span>)</span></span></span><br><span class="line">    return a + b</span><br><span class="line">foo([b = <span class="number">2</span>])  <span class="comment">// same as foo(13, 2)</span></span><br></pre></td></tr></table></figure><p>Также можно скомбинировать первые неименованные аргументы, или вызов через пайп:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">func</span><span class="params">(a:<span class="keyword">int</span>; b=<span class="number">1</span>; c=<span class="number">2</span>)</span></span></span><br><span class="line"><span class="function">  pass</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span><span class="params">([a=<span class="number">0</span>, c=<span class="number">2</span>]    <span class="comment">//ok</span></span></span></span><br><span class="line"><span class="function"><span class="params">func(<span class="number">0</span>, [c=<span class="number">2</span>])   <span class="comment">//error</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="number">0</span> |&gt; func([c=<span class="number">2</span>]) <span class="comment">//error</span></span></span></span><br></pre></td></tr></table></figure><p><a href="https://github.com/GaijinEntertainment/daScript/blob/master/tests/language/named_call.das" target="_blank" rel="noopener">Больше примеров</a>. Логика выбора — именованные аргументы применяются после неименованных и могут “перекрывать” их.</p><p><strong><code>9. with</code></strong></p><p><a href="https://dascript.org/doc/reference/language/classes.html?highlight=class#implementation-details" target="_blank" rel="noopener">with</a> позволяет внутри блока обращаться к полям структуры без явного указания её имени:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span></span></span><br><span class="line"><span class="class">    <span class="title">a</span>, <span class="title">b</span>:</span> <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">var s = [[S a=<span class="number">1</span>, b=<span class="number">2</span>]]</span><br><span class="line">with s</span><br><span class="line">    print(<span class="string">"&#123;a&#125;, &#123;b&#125;\n"</span>) <span class="comment">//s.a, s.b</span></span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Научился читать грамматику для bison, нашёл несколько новых для себя мелочей синтаксиса &lt;a href=&quot;https://github.com/GaijinEntertainment/daScript/blob/master/src/parser/ds_parser.ypp&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;daScript&lt;/a&gt;.&lt;br&gt;
    
    </summary>
    
    
    
      <category term="dascript" scheme="http://spiiin.github.io/tags/dascript/"/>
    
  </entry>
  
  <entry>
    <title>Книги и курсы</title>
    <link href="http://spiiin.github.io/blog/1567638407/"/>
    <id>http://spiiin.github.io/blog/1567638407/</id>
    <published>2023-02-25T14:07:24.000Z</published>
    <updated>2023-03-04T18:25:31.727Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>В январе, перед переходом на новую работу, успел немного почитать. Ориентировался на список из старого <a href="https://dtf.ru/gamedev/470-gaijin-interview" target="_blank" rel="noopener">интервью</a> А. Юдинцева</p><p><strong><code>Пенроуз Р. &quot;Новый ум короля&quot;</code></strong><br>Взгляд физика и математика Пенроуза из 1989 на искусственный интеллект. Пролистал бегло часть про математику, физику почти пропустил. Основная идея начала — сознание неалгоритмично, и часто неформализуемо. Плюс гипотеза о том, что раз мы еще не нашли объяснения сознания там, где искали, оно может быть спрятано там, где еще искали плохо.<br>Кажется, в книге не рассматривается, а скорее и отрицается эмерджентность, свойство возникновения нового уровня организации из более примитивных элементов. Хотя Пенроуз подходит к этому феномену в описании существования кристаллов с непериодической решеткой, математически описанных им самим (<a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%BE%D0%B7%D0%B0%D0%B8%D0%BA%D0%B0_%D0%9F%D0%B5%D0%BD%D1%80%D0%BE%D1%83%D0%B7%D0%B0" target="_blank" rel="noopener">мозаика Пенроуза</a>), для построения которых необходимо “знать” о том, как будет организована далеко отстоящая часть структуры.</p><p>Наверное, интересно для любителей истории развития идей про искусственный интеллект. Когда-то также бегло просматривал книги Минского <code>&quot;Вычисления: конечные и бесконечные машины&quot;</code> и <code>&quot;Общество разума&quot;</code>, но не особо связаны с тем, чем я занимаюсь, поэтому не вникал в них детально.</p><p>Одна из глав посвящена также фракталам, но про них лучше почитать отдельно у Мандельброта в <code>&quot;Фракталы и хаос&quot;</code> (тоже просматривал бегло), до этой книги почему-то считал их скорее математической диковинкой, чем структурой для описания объектов природы.</p><p>Собственно, разобрал только <a href="https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D0%BE%D1%80%D0%B5%D0%BC%D0%B0_%D0%93%D1%83%D0%B4%D1%81%D1%82%D0%B5%D0%B9%D0%BD%D0%B0" target="_blank" rel="noopener">теорему Гудстейна</a>, так как она связана с теоремой Гёделя о неполноте, которую очень часто любят упоминать по поводу и без. Разбор теоремы:<br>ЖЖ avva:<br><a href="https://avva.livejournal.com/244874.html" target="_blank" rel="noopener">Геркулес и гидра</a><br><a href="https://avva.livejournal.com/245918.html" target="_blank" rel="noopener">Геркулес и гидра (решение)</a><br><a href="https://avva.livejournal.com/248899.html" target="_blank" rel="noopener">Геркулес и гидра (что такое ординалы)</a><br>Канал маткульт-привет:<br><a href="https://www.youtube.com/watch?v=IS_PazHA2_0" target="_blank" rel="noopener">Теорема Гудстейна. Введение</a><br><a href="https://www.youtube.com/watch?v=0WLmiejT9vM" target="_blank" rel="noopener">Теорема Гудстейна. Формулировка</a><br><a href="https://www.youtube.com/watch?v=0SoydsEr0OA" target="_blank" rel="noopener">Теорема Гудстейна. Введение в ординалы</a><br><a href="https://www.youtube.com/watch?v=dEx5xlB9PTc" target="_blank" rel="noopener">Теорема Гудстейна. Доказательство и заключение</a></p><p>Интересно скорее для математиков, на любительский взгляд выглядит просто как определение набора правил, как именно можно оперировать неизвестными заранее, но конечными числами</p><p><strong><code>Прайор К. &quot;Не рычите на собаку&quot;</code></strong><br>Книга о практических методах дрессировки животных и людей, не делающая значительных отличий между ними. Собственно, все методы практичны, из серии “бери и делай”.</p><p>Когда-то увлекался популярными книгами про языки животных — <a href="/blog/14110/" title="Джон Лилли. Человек и Дельфин.">Джон Лилли. Человек и Дельфин.</a>. Недавно читал также про язык муравьев в <code>&quot;Планете муравьев&quot;</code> и <code>&quot;Superorganism&quot;</code> Уилсона.<br><a href="https://galicarnax.livejournal.com/39260.html" target="_blank" rel="noopener">Биосемиотика: молекулярные коды как основа жизни</a> — наука о том, что жизнь основана на знаках и кодах, а эволюция связана с возникновением новых систем кодирования. Наверное, если бы не занимался геймдевом, занимался б биоинформатикой.</p><p><strong><code>Даймонд Дж. &quot;Ружья, микробы и сталь&quot;</code></strong><br><a href="https://kobak.livejournal.com/73007.html" target="_blank" rel="noopener">Краткий конспект</a> содержания книги. Автор связывает развитие цивилизаций с экологическими условиями, в которых они оказывались. Сложнопроверяемо, но много интересных фактов. Похожие книги, про политические системы — <code>&quot;Почему одни страны богатые, а другие бедные&quot;</code> и <code>&quot;Русская модель управления&quot;</code> (хотя тут больше притягиваний фактов).</p><p><strong><code>Чалдини Р. &quot;Психология влияния&quot;</code></strong><br>Как и Доккинза, читал раньше. Считаю методы из Чалдини, Ариели, Канемана и Талера необходимыми и обязательными во фреймворке гейм-дизайнера (особенно для free-to-play) — <a href="/blog/3649678047/" title="Путь гейм-дизайнера">Путь гейм-дизайнера</a></p><p><strong><code>Курс лекций: &quot;Наукоёмкий подход к кулинарии&quot;</code></strong> [<a href="https://www.youtube.com/playlist?list=PLXOrZPAO2Ui021R3sKD5z0n9Qzeix9Kbj" target="_blank" rel="noopener">ссылка</a>]<br>Колоссальное количество фактов о кулинарии и способах приготовления еды. Лекции не о том, как правильно готовить, а о том, что можно в принципе делать с едой. Хорошо идёт в дополнении с книгой <code>Вкус</code> Боба Холмса.</p><p><strong><code>Системное программирование. Лаборатория Tarantool</code></strong> [<a href="https://www.youtube.com/playlist?list=PLrCZzMib1e9pOdLmE2qtMgL3QMEIrxyu7" target="_blank" rel="noopener">ссылка</a>]<br>Введение в Linux, вместе с книгой Таненбаума <code>&quot;Современные операционные системы&quot;</code> позволяет понять ос настолько, чтобы разбираться в более продвинутых материалах.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;В январе, 
      
    
    </summary>
    
    
    
      <category term="книги" scheme="http://spiiin.github.io/tags/%D0%BA%D0%BD%D0%B8%D0%B3%D0%B8/"/>
    
      <category term="link" scheme="http://spiiin.github.io/tags/link/"/>
    
  </entry>
  
  <entry>
    <title>Немного о проектировании</title>
    <link href="http://spiiin.github.io/blog/1337028819/"/>
    <id>http://spiiin.github.io/blog/1337028819/</id>
    <published>2023-02-19T11:40:56.000Z</published>
    <updated>2023-04-04T20:59:17.300Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Дамп мыслей про проектирование систем, как обычно, с уклоном в геймдев.<br><a id="more"></a></p><h2 id="Cohesion-and-Coupling"><a href="#Cohesion-and-Coupling" class="headerlink" title="Cohesion and Coupling"></a>Cohesion and Coupling</h2><p><a href="https://en.wikipedia.org/wiki/Cohesion_(computer_science%29" target="_blank" rel="noopener">Cohesion</a> — степень смысловой связи между сгруппированными элементами (функциями в классе или модуле).<br><a href="https://en.wikipedia.org/wiki/Coupling_(computer_programming%29" target="_blank" rel="noopener">Coupling</a> — степень запутанности связи между модулями.</p><p><img src="/blog/1337028819/coupling_small.png" alt=""><br>Хороший вариант дизайна — высокая cohesion и низкая coupling.</p><p>Примеры модулей, в которых скорее всего окажется <code>низкий cohesion</code>:</p><ul><li>Utils - сгруппировано все небольшие функции</li><li>GameObject - в котором при ООП дизайне рано или поздно собирается весь функционал, который может потребоваться потомкам (анти-паттерны GodObject/Blob)</li></ul><p>Примеры модулей, которые скорее всего могут быть связаны с другими (<code>высокий coupling</code>) - системы логгирования, профилирования.<br>Подсистемы также связываются на уровне реализации игровой логики — звук шагов задействует подсистемы анимации, звука, физики. Сильно лучше, если подсистемы связаны не между собой, а на отдельном слое связывания.</p><h2 id="Компоненты"><a href="#Компоненты" class="headerlink" title="Компоненты"></a>Компоненты</h2><p>Для подсистем с высокой cohesion и низкой coupling встречается название <strong><code>компоненты</code></strong>, за счет того, что они изолированы друг от друга и могут переиспользоваться.<br>Один из приемов проектирования — строить программу из компонентов.</p><p>Между слоем компонентов и логики приложения могут лежать и промежуточные слои библиотек:</p><p><img src="/blog/1337028819/components_levels_small.png" alt=""><br><em>(картинка из книги John Lacos - Large-Scale C++ )</em></p><p>Однако при этом часто на среднем уровне библиотека не оформлена в виде компонентов или даже компоненты на спроектированы так, чтобы использоваться вне библиотеки очень высокого уровня.</p><p>Примеры библиотек:<br>В которых сложно “оторвать компоненты” для использования вне библиотеки (в плане coupling, иногда заниматься отрыванием может мешать и лицензия библиотеки): <code>Qt</code><br>Средний уровень сложности: <code>boost</code> (зависит от конкретной библиотеки, некоторые отрываются неплохо, некоторые тянут за собой в зависимостях половину библиотеки), <code>entt</code> (для примера — оторвать basic_sparse_set/basic_storage можно, но требует усилий)<br>Легко отделить компоненты: <a href="https://github.com/tamasmeszaros/libnest2d" target="_blank" rel="noopener">libnest2d</a> - надстроена над <code>clipper/nlopt/boost.geometry</code>, вполне позволяет подменить любую из этих библиотек</p><h2 id="Software-Capital"><a href="#Software-Capital" class="headerlink" title="Software Capital"></a>Software Capital</h2><p><a href="https://youtu.be/ta3S8CRN2TM?t=572" target="_blank" rel="noopener">CppCon 2016: David Sankel “Building Software Capital: How to write the highest quality code and why”</a> — software capital как противоположность техническому долгу.</p><p>Необходимые условия для создания software capital:</p><p><code>Code review</code></p><ul><li>позволяет получить не только собственную оценку качества кода</li><li>поиск багов</li><li>проверка соотвествия стандартам компании (взаимодействие позволяет создать стандарты!)</li><li>социализация -&gt; распространение знаний</li><li>отчётность качества кода - проверка наличия документации, юнит тестов, отвественность за код на двух людях</li></ul><p>О ревью кода часто говорят, но мало кто делает полноценно. У автора есть ещё несколько докладов на тему того, как бороться с менеджерами, которые запрещают не пропускать плохой код. Основной аргумент для менеджеров — “мы знаем, что данные правила позволяют уменьшить time to market в перспективе”. Не пропускать плохой код в мастер, иначе он там и останется (технический долг — антипод sofware capital). Каждый коммит должен проходить ревью.</p><p><em>Интересно проверить на практике, насколько эта идея работает</em></p><p><code>Стандарты</code><br>(форматирование, идиомы, организация компонентов, лучшие практики, требования к документации)</p><ul><li>уменьшение вариативности даёт увеличение продуктивности</li><li>профессионализм</li><li>чем более похожа структура, тем проще навигация</li><li>и обработки кода тулзами (clang-format, refactor, codegen)</li></ul><p><code>Unit testing</code></p><ul><li>безопасный рефакторинг</li><li>ранее вычищение некоторых багов</li><li>хинты: для gui — modularized gui, для io - dependency injections, против “i need ship” - код должен иметь тесты, чтобы пройти код-ревью!, против “я знаю что код работает” — нам нужно уметь поймать момент, когда из-за изменений в ходе добавления других фич он сломается. Требует CI.</li></ul><p><code>Контракты</code></p><ul><li>Спецификация ожидаемого поведения (in/out), не деталей реализации</li><li>Позволяет абстрагироваться от реализации, экономит время</li><li>Плохие интерфейсы видны по их контрактам</li><li>Подсказка для того, как написать unit-тесты</li></ul><p><em>Я не встречал, чтобы это применяли на практике</em></p><p><code>Хорошие интерфейсы</code></p><ul><li>форма искусства</li><li>простые контракты</li><li>управляемые части</li><li>организация кода: разделение на уровни “компонент/пакет/группа пакетов”. Функции класса, не требующие доступа к приватным членам отделяются в ClassUtil</li><li>не должно быть взаимных зависимостей между двумя компонентами</li></ul><p><code>Инновации</code></p><ul><li>инновации имеют стоимость - code rot (существующий код становится устравшим), добавление сложности</li><li>плата - освоение книг, курсов, конференции</li></ul><p><code>Инфраструктура</code></p><ul><li>vcs, ci, build system, core libraries, standards</li><li>кто-то должен отвечает за всю картину, эта задача требует высокой квалификации</li></ul><p><em>неочевидное свойство software capital — новые разработчики обязаны отказываться от своих привычек программирования и используемых инструментов, и переходить/изучать то, что использует и создала компания</em></p><h2 id="Зависимости-от-компонентов-и-свойства-API"><a href="#Зависимости-от-компонентов-и-свойства-API" class="headerlink" title="Зависимости от компонентов и свойства API"></a>Зависимости от компонентов и свойства API</h2><p>По субъективному опыту — для open-source библиотек можно найти качественные компоненты более “низкого” уровня (то, что можно забросить в 3rdPartyLibs), библиотеки среднего уровня чаще всего (если не считать движения свободного кода) — проприетарная собственность компаний (1stPartyLibs), так как требуют серьёзного уровня поддержки, который сложно поддерживать небольшой группе разработчиков, а также могут быть заточены под нужды конкретной компании. В Large-Scale C++ такие компоненты, накопленные компаниями, упоминаются, как <code>software capital</code>. Большие open-source библиотеки компонентов часто появляются как открытие накопленного корпорацией software capital (<code>abseil</code>, <code>folly</code>).</p><p>Еще одно интересное свойство компонент, которое влияет на простоту их использования — компактность их API. Так как библиотеки “среднего” уровня могут быть достаточно объёмными, Эрик Реймонд в книге “Искусство программирования для UNIX” вводит термин <code>полукомпактность</code> для систем, которые позволяет решать с их помощью большинство задач, используя только небольшую и наиболее используемую компактную часть их API. В качестве примеров полукомпактных систем он приводит <code>html</code> или язык <code>c</code> (не c++).</p><p><a href="https://www.youtube.com/watch?v=ZQ5_u8Lgvyk" target="_blank" rel="noopener">Designing and Evaluating Reusable Components - 2004</a> — доклад Casey Muratori (соавтор библиотек <a href="http://www.radgametools.com/granny.html" target="_blank" rel="noopener">Granny 3D</a>, которая изолирует нижний уровень компонет - “лист” на графе), про дизайн компонентов и виды зависимостей, которые они могут добавлять на уровне, который их использует. На скриншоте с графом уровней компонент выше рёбра — это абстрактное “использование” компонент, доклад разбирает виды и характеристики этих соединений.</p><p><img src="/blog/1337028819/reuse_small.png" alt=""></p><p>Свойства API:</p><p><code>Разделяемость (Granularity)</code><br>Возможность установить/изменить параметры за несколько вызовов — вставить действие между между ними.<br>Гибкость VS простота</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Orientation = GetOrientation(Object)</span><br><span class="line">Change = GetOrientationChange(Object)</span><br><span class="line">Change += <span class="number">3.14f</span>                <span class="comment">//</span></span><br><span class="line">RunSomeOtherUnrelatedTthing()  <span class="comment">// возможность поменять отложенно</span></span><br><span class="line">SetOrientation(Object, Orientation + Change)</span><br></pre></td></tr></table></figure><p><code>Избыточность (Redundancy)</code><br>Возможность выполнить действия несколькими способами<br>Удобство VS ортогональность</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//установка направления с помощью матрицы</span></span><br><span class="line">SetOrientation3x3(Object, Matrix)</span><br><span class="line"><span class="comment">//то же самое с помощью кватерниона</span></span><br><span class="line">SetOrientationQ(Object, Quat)</span><br><span class="line"><span class="comment">//то же самое с помощью заготовленных разработчиками методов/констант</span></span><br><span class="line">IdentityOrientation(Object)</span><br><span class="line">FaceForward(Object)</span><br></pre></td></tr></table></figure><p><code>Cвязанность (Coupling)</code><br>Зависимости между частями системы (почти всегда плохо, не часто неизбежно)<br>Несвязанность VS запутанность (<a href="https://www.youtube.com/watch?v=SxdOUGdseq4 -- более детально" target="_blank" rel="noopener">“Simple Made Easy” - Rich Hickey (2011)</a>)</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//неразделяемый апдейт всего (к примеру, физики)</span></span><br><span class="line">UpdateEverything(World)</span><br><span class="line"></span><br><span class="line"><span class="comment">//нужно установить состояние, прежде чем сделать что-то,</span></span><br><span class="line"><span class="comment">//  возможно скрыто</span></span><br><span class="line">SetTime(GlobalTime) </span><br><span class="line">UpdateObject(Object)</span><br><span class="line"></span><br><span class="line"><span class="comment">//возможность настройки только внутри пары вызовов</span></span><br><span class="line"><span class="comment">// часто подразумевает "не должно быть вложенности"</span></span><br><span class="line">BeginObjectSpecification()</span><br><span class="line">SetObjectState(Param1, Value1)</span><br><span class="line">Object = EndObjectSpecification()</span><br><span class="line"></span><br><span class="line"><span class="comment">//Использование скрытого общего буфера</span></span><br><span class="line"><span class="comment">// на который могут указывать String1 и String2</span></span><br><span class="line">String1 = GetMungedName(Name1)</span><br><span class="line">String2 = GetMungedName(Name2)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Нельзя сказать "у меня уже есть выделенная память, на которой нужно построить объект"</span></span><br><span class="line"><span class="comment">// или "выдели объект, но я инициализирую его, у меня кастомные инициализаторы из архивов"</span></span><br><span class="line">Object = AllocateAndInitialize()</span><br><span class="line"></span><br><span class="line"><span class="comment">//нужно обязательно создавать кастомный тип, хотя клиент может иметь тип для представления</span></span><br><span class="line"><span class="comment">// пример - QString для апи QT</span></span><br><span class="line">Matrix = MakeMatrixFrom(FloatPointer)</span><br><span class="line">SetOrientation(Object, Matrix)</span><br><span class="line"></span><br><span class="line"><span class="comment">//связь с форматом файла, нельзя создать самому,</span></span><br><span class="line"><span class="comment">//  зависимость от формата и I/O функций</span></span><br><span class="line">Object = ReadObject(filename)</span><br></pre></td></tr></table></figure><p><code>Запоминание (Retention)</code><br>Сохранение переданной ранее информации<br>Ведет к дублирование описания мира “внутри” библиотеки и в пользовательском коде<br>Сложность синхронизации состояний (комбинаторный рост от количества параметров) VS автоматизация работы после настройки</p><p>Immediate mode API (<a href="https://github.com/ocornut/imgui" target="_blank" rel="noopener">imgui</a> как пример) — одна из идея отказа от запоминания</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Настройка значений, которые повлияют на последующие вычисления</span></span><br><span class="line">SetTime(GlobalTime)</span><br><span class="line">SetPi(<span class="number">3.14f</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//изменение положение потомка также зависит от родителя</span></span><br><span class="line">SetParent(ChildObject, ParentObject)</span><br><span class="line">UpdateOrientation(ChildObject)</span><br></pre></td></tr></table></figure><p>Возможно, к “запоминанию” состояния можно отнести также некоторые идеи, которые предлагаются паттернами и парадигмами программирования:</p><ul><li>Асинхронное программирование с запоминанием точек продолжения программы (async/await)</li><li>Реактивное программирование, с запоминаем настроенных потоков данных</li><li>Декларативное программирование, с выполнением кода на какой-либо настроенной или заполненной ранее модели/системе</li></ul><p>В системах, в которых настройка может осуществляться гибко, императивное описание может быть лучше декларативного — явно указываем последовательность операций вместо того, чтобы извращаться с тем, чтобы оставалась возможность точно настроить декларативное описание.</p><p>Примеры:</p><ul><li>Декларативные системы сборки в Java Ant и Maven проиграли императивному способу gradle.</li><li><a href="https://github.com/spiiin/CadEditor/tree/master/CadEditor/settings_nes" target="_blank" rel="noopener">CadEditor</a> — мой редактор уровней для NES игр. “Стандартный” путь для редакторов уровней — декларативные конфигурационные файлы. Императивный — скриптовый язык, позволяющий описать, как загружать уровни, за счёт чего можно добавлять в редактор сотни игр, несильно отличающихся между собой, но всё же отличающихся настолько, что сложно предугадать в декларативной системе заранее.</li></ul><p><code>Порядок вызовов (Flow Control)</code><br>Вызывает ли библиотека колбеки приложения или приложение функции библиотеки (и зовут ли функции библиотеки колбеки из приложения). Чем чаще необходимо осуществлять передачу управления, тем сложнее отслеживать это пользователю библиотеки.<br>Контроль на стороне приложения (почти всегда лучше) VS на стороне библиотеки</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Для открытия файла будет вызван колбек Open</span></span><br><span class="line">SetFileCallbacks(Open, Read, Close)</span><br><span class="line">File = OpenFile(Filemame)</span><br><span class="line"></span><br><span class="line"><span class="comment">//То же самое, но спрятано за ООП,</span></span><br><span class="line"><span class="comment">// где-то скрыто сохранён указатель на функцию открытия</span></span><br><span class="line">class MyHandler: <span class="keyword">public</span> LibraryHandler &#123;</span><br><span class="line">  <span class="keyword">virtual</span> <span class="keyword">void</span> Open(<span class="keyword">char</span>* Filename)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Ещё про свойства библиотек — <a href="/blog/1152347544/" title="Хорошие библиотеки">Хорошие библиотеки</a></p><h2 id="Копирование-лучших"><a href="#Копирование-лучших" class="headerlink" title="Копирование лучших"></a>Копирование лучших</h2><p>Вместо написания чего-то с нуля нужно использовать или копировать лучших (смысл не пользоваться накоплненным software capital?).</p><ul><li>Черновая реализация на несколько оптимизаций отстает от оптимальной</li><li>Часто оптимальная может так сильно отличаться от наивной, что переделать станет сложно/невозможно</li><li>Для понимания оптимальной версии может потребоваться больше времени, и знаний для сравнения, чем для написания наивной</li></ul><p>Кроме оптимизаций, готовый код содержит фиксы множества ошибок, найденные за время его использования. Джоэл Спольски в эссе <a href="https://www.joelonsoftware.com/2000/04/06/things-you-should-never-do-part-i/" target="_blank" rel="noopener">Things You Should Never Do</a> расписывает печально известную проектировщикам истину — простой код, написанный с чистого листа, сильно отстаёт от давно написанного сложного, но отлаженного.</p><p>При этом копирование плохо работает в чём-то, отличном от кода. <a href="https://vadzimv.dev/2020/03/07/childs-illusions.html" target="_blank" rel="noopener">Книжки не заменяют опыта</a>, но обещают успех в случае повторения внешних признаков (чтобы понять границы применимости общих техник, необходимо колоссальное количество опыта).</p><p><code>Создание инструментов</code></p><p>Использование и создание лучших инструментов даёт <a href="https://borisbat.github.io/dascf-blog/2023/03/20/a-matter-of-multipliction/" target="_blank" rel="noopener">мультипликативный эффект</a>.</p><p>Раздел “Инструменты” — <a href="/blog/3652741154/" title="10 лет в геймдеве">10 лет в геймдеве</a></p><p><em>Примеры инструментов для профилирования программ на C++</em></p><p>Изучение memory layout для C++-структур — <a href="/blog/1170009669/" title="Расположение объектов C++ в памяти. Часть 2">Расположение объектов C++ в памяти. Часть 2</a><br>Отображение информации от профайлера xcode (cpu и memory) и xperf в виде флеймграфа — <a href="/blog/2526702897/" title="Flamegraph. Windows&#x2F;iOS&#x2F;Android">Flamegraph. Windows&#x2F;iOS&#x2F;Android</a></p><p>Новый инструмент для создания кода (и не только) сейчас — нейронные сети.</p><h2 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h2><p><strong><code>Data oriented</code></strong></p><ul><li>сначала кажется непривычным</li><li>так как (в случае, если мы думаем о локальности данных в памяти) подстраивается под данные, иногда требует дублирования кода под новые данные<br>(редко встречается достаточно генерик код, который может работать с кастомными структурами)</li><li>когда подстроишься под то, чтобы думать о расположении данных в памяти, становится сильно проще</li></ul><blockquote><p>Архитектура - это искусство проектировать и конструировать структуры</p><footer><strong>Sean Parent</strong></footer></blockquote><p>В геймдеве часто производительность имеет значение:</p><ul><li>там где ограниченные ресурсы - <a href="http://ru.esotericsoftware.com/" target="_blank" rel="noopener">Spine</a>-анимации для мобильных игр начинают тормозить уже на тех телефонах, но которых запускается Fortnite, при этом разработчиков не особо волнует эта проблема. <a href="https://youtu.be/rX0ItVEVjHc?t=4645" target="_blank" rel="noopener">Ответ</a> Mike Acton на позицию “We want not care about this stuff” - “из-за вас я должен ждать 2 минуты, пока открывается word”.</li><li>там где конкуренция, кто может выдать круче результат (точнее рассчёт физики, освещения, анимаций, ии)</li><li>там где платишь за сервера. <a href="https://youtu.be/KxQpDIKwGUw?t=2399" target="_blank" rel="noopener">Ответ</a> Максима Барышникова про то, зачем WoT сохраняется поддержка распределенных между серверами арен — на одном сервере помещается 3 арены, но за счёт того, что движок поддерживает разбиение, можно разместить 7 арен на 2х серверах (по 3.5 на сервер), а не на 3х, плюс можно динамически балансировать рассчёты, если все 4 арены одновременно становятся максимально нагруженными.</li></ul><p><strong><code>Performance if a feature</code></strong></p><ul><li>там где количество может переходить в качество, давать новые фичи. Например, без оптимизаций можем сделать RTS, в которых у игрока будет только 100 юнитов, а оптимизациями - как 100, так и 10000 - геймдизайнеры могут сделать фичей огромные армии, или более быстрая обработка позволяет “запихнуть” в освободившееся время ещё что-нибудь интересное.</li></ul><p>Кроме производительности конечной программы, немаловажно <strong><code>время сборки/пересборки и производительность дебажного билда</code></strong> (отлаживать не небажный билд добровольно — не очень весело).</p><p><a href="https://aras-p.info/blog/2018/12/28/Modern-C-Lamentations/" target="_blank" rel="noopener">“Modern” C++ Lamentations</a> — важная и большая статья о состоянии этого в современном C++ с большим количеством ссылок и сравнениями (<em>серьёзно, тот случай, когда стоит изучить каждую ссылку из статьи</em>). Кто-то пишет на ограниченном С++ (<code>Orthodox C++</code>), переучивая коллег и новичков, кто-то выбирает и создаёт альтернативные библиотеки (<code>EASTL</code>), кто-то переходит на другие языки (<code>Rust, Jai, Burst C#, daScript</code>).</p><ul><li><a href="/blog/1728194429/" title="С++ в геймдеве">С++ в геймдеве</a> — мой обзор применения C++ для разработки игр</li></ul><p><a href="https://www.youtube.com/watch?v=NAVbI1HIzCE" target="_blank" rel="noopener">Practical Optimizations</a> — доклад Jason Booth c измерениями производительности DoD кода. Важный тезис — <strong><code>optimization is a DESIGN time problem</code></strong>. Если не организовать данные в памяти сразу, переделать будет сложно. В докладе есть нестандартные примеры оптимизаций.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Дамп мыслей про проектирование систем, как обычно, с уклоном в геймдев.&lt;br&gt;
    
    </summary>
    
    
    
      <category term="dev_method" scheme="http://spiiin.github.io/tags/dev-method/"/>
    
      <category term="dev_evolution" scheme="http://spiiin.github.io/tags/dev-evolution/"/>
    
  </entry>
  
  <entry>
    <title>Иерархические компании vs плоские</title>
    <link href="http://spiiin.github.io/blog/3914071471/"/>
    <id>http://spiiin.github.io/blog/3914071471/</id>
    <published>2023-02-12T15:21:34.000Z</published>
    <updated>2023-02-12T23:05:17.776Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Несколько дней назад “уволенный сотрудник Mytona опубликовал открытое письмо” (на самом деле, <a href="https://www.youtube.com/watch?v=lYvNWf4Q2xE" target="_blank" rel="noopener">видео</a> на 2 часа). Я проработал в Майтоне 3.5 года, прошёл там путь от обычного программиста, “второго лида”, лида-проекта, программиста движка и технического продюссера, плюс долгое время занимался собеседованиями (провел штук 100 интервью), так что знаю там устройство компании на различных уровнях. Устройство не сильно отличается от типовой корпорации, так что и проблемы, озвученные в видео, типичны скорее для каждой компании, чем для конкретной.</p><p>В первую очередь, немного по сути видео — автор достаточно склочен, и по большей части озвученных ситуаций раздувает из мухи слона. На мой взгляд, выбрасывать подобное в паблик очень неэтично (а то и подсудно, особенно клевета на CEO fntastic, с учётом того, что они разрабатывают свои игры никак не связано с издателем), так как журналисты из мутного обезличенного рассказа сделают “жёлтый” пересказ. Первый же пересказы в гугле красуются фразами — “лид держит их в страхе: Mytona трещит по швам?” и “многие люди просто попали в депрессию и начали жрать таблетки”. При этом, сам автор вначале делает 20-минутный дисклеймер, что в целом работалось неплохо.</p><p>Но хотел написать небольшую заметку о том, чем отличаются большие компании от небольших, без отсылок на конкретные компании. Конечно, структура компаний может сильно отличаться, как и внутренняя культура, так что рассуждения дальше — это сферический конь в вакууме.</p><p>Критический размер для маленьких компаний, которые стремятся к плоской организации — число Данбара (100-230 человек), встречается в докладах про структуру Unity - <a href="https://aras-p.info/texts/files/201312-BuildStuffLightweightChaos.pdf" target="_blank" rel="noopener">Lightweight Chaos For Distributed Teams</a>, Github - <a href="https://zachholman.com/talk/how-github-no-longer-works/" target="_blank" rel="noopener">How GitHub (no longer) Works</a> или в докладах Джесси Шелла - <a href="https://www.youtube.com/watch?v=-zRaFJHK0S4" target="_blank" rel="noopener">Game Studio Management: Making It Great</a> и <a href="https://www.youtube.com/watch?v=O1zP6yJjc1o" target="_blank" rel="noopener">Game Studio Leadership: You Can Do It</a>.</p><p>С таким размером компании можно обходиться <em>почти</em> без менеджеров, с чем и связы основные отличия от “больших” корпораций (естественно, маленький размер не гарантирует того, что компания не будет организована как корпоративный ад). Число данбара говорит скорее о том, чем у компании с &gt;230 человек практические неизбежно будут наблюдаться все признаки “большой”. Так что более удачные термины вместо “больших” и “маленьких” —  иерархические и плоские.</p><p><strong><code>Распространение новостей в компании</code></strong></p><p>В иерархических компаниях часто встречается “испорченный телефон”. На высоком “уровне” условный продюссер проекта общается как с издателем/топ-менеджментом, так и с лидами направлений своего проекта (программисты, арт, геймдизайнеры) и общих отделов всей компании. Невозможно передать всю важную информацию по проекту “вниз по иерархии” исполнителям. Также практически необходимы каналы с освещением жизни компании и других отделов, если она хочет существовать как единое целое. Бонусом — всякие корпоративы, тимбилдинги и ивенты для организации дополнительных неформальных связей. При этом всём по прежнему самый надёжный способ узнать что-то достоверно — иметь знакомого, которые откуда-то умудряется знать всё и со всеми дружит.</p><p><strong><code>Разрешение конфликтов</code></strong></p><p>На кого-то ложится обязанность знать об атмосфере в коллективе, разруливать конфликты делегируется кому-нибудь типа специально обученных эйчаров. Причём задача сложная, отсюда неизбежны отзывы типа “меня уволили из-за конфликта с одним человеком” — это стандартный способ решения конфликта, который не могут уладить сами сотрудники, в случае, если невозможно перевести их подальше друг от друга. В плоской компании необходимо вписываться в коллектив, в иерархической — наверное можно попасть в другой проект, не пересекаясь больше ни с кем из предыдущего. Вообще найти себе команду и место, где применить свои навыки в плоской компании — задача самого сотрудника.</p><p><strong><code>Скорость реагирования</code></strong></p><p>Передача информации по уровням иерархии — очень медленный процесс, особенно если выполняется через какие-нибудь метрики или отчеты. Поэтому для задач, которые вроде требуют оперативного реагирования, могут происходить какие-то чудовищные ынтырпрайз истории (<a href="https://vas3k.club/post/5070/" target="_blank" rel="noopener">пример подборки</a>). Вполне могут существовать никому не нужные отделы, не выгоняться по году неработающие раздолбаи. Ну, и скорость реакции на меняющийся рынок — тоже не лучшие сторона иерархических компаний. Книга “Дилемма инноватора” рассматривает это подробно.</p><p><strong><code>Ценности</code></strong></p><p>Ценности в плоской компании — это или очевидные вещи, или негласные правила. Но! Если они таки есть, то сотрудники “впитывают” их естественным образом, просто продолжая работать в компании. Скорее всего плоская компания и занимается исключительно тем, что считает ценным. В иерархических компаниях ценности более абстрактны, и причастность к ним — скорее способ мотивации и повышения лояльности работников, а не способ выбора варианта действий в непонятных случаях. Вместо ценностей работают инструкции, что можно, нужно или нельзя делать.</p><p><strong><code>Найм</code></strong></p><p>Иерархические компании стремятся быть похожими друг на другу, и в теории иметь возможность заменить хоть всех сотрудников. Из-за этого вполне способны впитывать больше новичков. В плоских — процессы найма отличаются, но часто новый сотрудник должен приносить что-то новое. Недавняя истории с увольнениями десятков тысяч сотрудников тажке показывает, что иерархические компании могут расширяться просто чтобы расширяться (“наймём, чтобы другие не наняли”).</p><p><strong><code>Свобода действий</code></strong></p><p>Иерархическая компания как структура стремится воспроизводить сама себя, поэтому новые проекты делаются как старые, даже если декларируется свобода организации внутри проекта. В отдельных случаях иерархические компании стремятся изображать плоские, что выглядит как “менеджерам была поставлена задачи организовать команду без менеджеров”. Также очень нерационально для общих отделов иерархической компании работать с каждой командой по разному, так что рано или поздно кто-нибудь выступит с инициативой стандартизации.</p><p>Плоские команды изначально работают как в стиле “управляемый хаос”, в котором приживаются те практики, которые полезны в настоящий момент.</p><p><strong><code>Количество менеджеров</code></strong></p><p>В иерархических компаниях часто встречается случай, когда у тебя 2 менеджера — руководитель проекта и руководитель направления. На мой взгляд это основная причина фрустрации автора видео, как руководитель нарративных дизайнеров он не очень хотел вникать в проблемы руководителей частного проекта, который противоречат его видению. Такая система доставляет больше сложностей самим менеджерам, чем работникам, потому что требует хорошей координации и способности договариваться между самими менеджерами.</p><p>Иерархическая компания требует большого количества менеджеров, которых проще вырастить, чем нанять внешних, в связи с чем способный работник с большой долей вероятности станет менеджером.</p><p>В плоских компаниях организацией занимается неформальный лидер. Но при этом в иерархических компаниях также скорее всего тоже есть ещё и неформальные лидеры.</p><p><strong><code>Инертность к изменениям</code></strong></p><p>В иерархических компаниях сложно передать изменения в другую часть системы — несмотря на унификацию частей, изменения нужно отдельно внедрить в каждой подсистемы, причем так, чтобы внедряли их именно менеджеры этих подсистем, которые могут исказить смысл или даже осознанно противиться изменениям. Так что — сложнее обучать людей, менять или внедрять правила, пробовать новое, и сложнее прекратить порочные устоявшиеся практики.</p><p>Плоские компании могут быть как инертными, так и гибкими. Готовность к изменением “копится” до тех пор, пока или проблема станет мешать всем настолько, что найдётся желающий её поправить, или кто-то узнает про то, как можно серьёзно что-то улучшить. Активный поиск информации и исследование — кажется, одна из отличительных черт плоских компаний, которую редко подчёркивают.</p><p><strong><code>Доступ к ресурсам</code></strong></p><p>Содержать иерархическую компанию дороже (кроме специалистов нужны доп. менеджеры, а то и “менеджеры менеджеров”, корпоративы и тимбилдинг также стоят денег), так что такие компании должны располагать достаточными ресурсами, там где плоские могут быть экономнее. Хотя слышал и обратное мнение — из-за того, что плоские компании не хотят тратиться на менеджеров или содержать отдельные отделы, чтобы не расширяться, им приходится аутсорить часть работы, что выходит дороже, если делать это регулярно.</p><p>Доступ к ресурсам также определяет степень риска, на который готовы пойти. Содержание бОльших команд (а иерархические часто больше) стоит дороже, но при этом появляется стремление уменьшить риски. Маленькие команды готовы к большему риску ради того, чтобы получить больший выигрыш (а он также нужен, чтобы иметь больше возможности конкурировать с компаниями бОльших размеров). При этом скорость реализации проектов иерархическими и плоскими командами может быть примерно сопоставима. Если команда из 10 человек делает за одно и то же время то же, что и команда из 100, то это можно было бы объяснить тем, что все 10 — гении, но если команда из 200 человек делает столько же, сколько команда из 1000, скорее всего разница объясняется эффективностью организации.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;Несколько 
      
    
    </summary>
    
    
    
      <category term="log" scheme="http://spiiin.github.io/tags/log/"/>
    
      <category term="gamedev" scheme="http://spiiin.github.io/tags/gamedev/"/>
    
  </entry>
  
  <entry>
    <title>daScript: обобщенное программирование</title>
    <link href="http://spiiin.github.io/blog/2629978232/"/>
    <id>http://spiiin.github.io/blog/2629978232/</id>
    <published>2023-01-21T21:33:14.000Z</published>
    <updated>2023-03-04T18:28:28.613Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Обобщенное программирование — одна из серых, но важных и интересных сторон daScript. “Серость” темы связана с тем, что, во-первых, система типов не очень детально описана в документации, во-вторых — в рассуждениях о типизации можно от практики быстро уйти в дебри академических терминов, в-третьих, тема плохо укладывается в голову C++-программисту.</p><p>Поддержка обобщенного программирования в языке, если “на пальцах” — совокупность способов вызывать одну функцию для разных типов.</p><h2 id="Перегрузка-функций"><a href="#Перегрузка-функций" class="headerlink" title="Перегрузка функций"></a>Перегрузка функций</h2><p>Перегруженные функции (ad-hoc полиморфизм) — простейший способ определить функцию для двух различных типов</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">func</span><span class="params">(a : <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;a&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function">def <span class="title">func</span><span class="params">(a : <span class="keyword">float</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;a&#125;\n"</span>)</span></span></span><br><span class="line">[export]</span><br><span class="line">def main</span><br><span class="line">    func(<span class="number">1</span>)</span><br><span class="line">    func(<span class="number">1.0f</span>)</span><br></pre></td></tr></table></figure><p><strong><code>Константность</code></strong></p><p>Напечатаем тип параметра-аргумента:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">func</span><span class="params">(a : <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;typeinfo(typename a)&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"><span class="comment">//Output:</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="keyword">const</span></span></span><br></pre></td></tr></table></figure></p><p>По умолчанию к типу был добавлен спецификатор <code>const</code>, который не позволяет поменять значение аргумента. Его можно убрать, добавив ключевое слово <code>var</code>:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">func</span><span class="params">(var a: <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;typeinfo(typename a)&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"><span class="comment">//Output</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br></pre></td></tr></table></figure></p><p>При выборе перегрузки, константная и неконстантная версия, в отличие от C++, не имеют приоритета друг перед другом и при нахождении двух вариантов функции <code>daScript</code> выдаст ошибку (<a href="https://dascript.org/doc/reference/language/functions.html#function-overloading" target="_blank" rel="noopener">Правила выбора функции</a>).<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var a: <span class="keyword">int</span></span><br><span class="line">func(a)</span><br><span class="line"><span class="comment">//Output</span></span><br><span class="line"><span class="number">30304</span>: too many matching functions <span class="keyword">or</span> generics func</span><br><span class="line">candidates:</span><br><span class="line">        func ( a : <span class="keyword">int</span> <span class="keyword">const</span> ) : <span class="keyword">void</span> at generics.das:<span class="number">3</span>:<span class="number">4</span> <span class="comment">//принимает int и int const</span></span><br><span class="line">        func ( a : <span class="keyword">int</span> -<span class="keyword">const</span> ) : <span class="keyword">void</span> at generics.das:<span class="number">9</span>:<span class="number">4</span> <span class="comment">//-const читается как "удалить у типа спецификатор const"</span></span><br></pre></td></tr></table></figure></p><p>Для того, чтобы daScript различил функции, можно добавить <a href="https://dascript.org/doc/reference/language/generic_programming.html#type-contracts-and-type-operations" target="_blank" rel="noopener">спецификатор типа</a> <code>== const</code> (“константность аргумента должна совпадать).<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">func</span><span class="params">(a : <span class="keyword">int</span> ==<span class="keyword">const</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;typeinfo(typename a)&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">def <span class="title">func</span><span class="params">(var a : <span class="keyword">int</span> ==<span class="keyword">const</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;typeinfo(typename a)&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">[export]</span><br><span class="line">def main</span><br><span class="line">    var a: <span class="keyword">int</span></span><br><span class="line">    func(a)</span><br><span class="line">    func(<span class="number">1</span>)</span><br><span class="line"><span class="comment">//Output:</span></span><br><span class="line"><span class="keyword">int</span> ==<span class="keyword">const</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> ==<span class="keyword">const</span></span><br></pre></td></tr></table></figure></p><p><strong><code>Ссылки</code></strong></p><p>В предыдущем примере аргумент передавался по значению, поэтому даже <code>var int</code> не позволяет изменить переданную переменную (меняется <strong>значение аргумента</strong>, а не оригинальная переменная). Возможно передать аргумент по ссылке:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">func</span><span class="params">(var a : <span class="keyword">int</span>&amp;)</span></span></span><br><span class="line"><span class="function">    a </span>= <span class="number">42</span></span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main</span><br><span class="line">    var a: <span class="keyword">int</span></span><br><span class="line">    func(a)</span><br><span class="line">    print(<span class="string">"&#123;a&#125;\n"</span>)</span><br><span class="line"><span class="comment">//Output: 42</span></span><br></pre></td></tr></table></figure></p><p><strong> Все непримитивные типы передаются по ссылке, независимо от того, был ли описан аргумент со спецификатором <code>&amp;</code> или без него. </strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">    <span class="title">a</span> :</span> <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">func</span><span class="params">(var arg : A)</span></span></span><br><span class="line">    arg.a = 42</span><br><span class="line">    print(<span class="string">"&#123;typeinfo(typename arg)&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main</span><br><span class="line">    var a : A</span><br><span class="line">    func(a)</span><br><span class="line">    print(<span class="string">"&#123;a&#125;\n"</span>)</span><br><span class="line"><span class="comment">//Output</span></span><br><span class="line">A</span><br><span class="line">[[ <span class="number">42</span>]]</span><br></pre></td></tr></table></figure><p><em>(причём можно описать 2 перегруженные функции с аргуметами типа A и A&amp;, несмотря на то, что для структур семантически это будет идентичная запись)</em></p><p>При этом, как и с константностью, компилятор не различает приоритета перегрузки функций с аргументом-ссылкой и значением, и выдаёт ошибку неоднозначности разрешения перегрузки.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">func</span><span class="params">(var a: <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">    pass</span></span><br><span class="line"><span class="function">def <span class="title">func</span><span class="params">(var a : <span class="keyword">int</span>&amp;)</span></span></span><br><span class="line"><span class="function">    pass</span></span><br><span class="line"><span class="function"></span></span><br><span class="line">[export]</span><br><span class="line">def main</span><br><span class="line">    func(<span class="number">1</span>) <span class="comment">//ok</span></span><br><span class="line">    var a: <span class="keyword">int</span></span><br><span class="line">    func(a) <span class="comment">//30304: too many matching functions or generics func</span></span><br><span class="line">            <span class="comment">//candidates:</span></span><br><span class="line">            <span class="comment">//func ( a : int -const ) : void at generics.das:1:4</span></span><br><span class="line">            <span class="comment">//func ( a : int&amp; -const ) : void at generics.das:3:4</span></span><br></pre></td></tr></table></figure><p><strong><code>Контракты</code></strong></p><p>Макросы работают раньше разрешения перегрузки, что позволяет реализовать паттерн <a href="https://github.com/GaijinEntertainment/daScript/blob/e7992b384dad13c1a201f9eee1c6a6ae1e0cf8b8/daslib/contracts.das" target="_blank" rel="noopener">contracts</a> — произвольную функцию, которая предварительно проверяет тип аргументов:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">require daslib/contracts</span><br><span class="line"></span><br><span class="line">[!expect_ref(arg)]</span><br><span class="line"><span class="function">def <span class="title">func</span><span class="params">(var arg : <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;typeinfo(typename arg)&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">[expect_ref(arg)]</span><br><span class="line"><span class="function">def <span class="title">func</span><span class="params">(var arg : <span class="keyword">int</span>&amp;)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;typeinfo(typename arg)&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">[export]</span><br><span class="line">def main</span><br><span class="line">    var a: <span class="keyword">int</span></span><br><span class="line">    func(a)</span><br><span class="line">    func(<span class="number">1</span>)</span><br><span class="line"><span class="comment">//Output:</span></span><br><span class="line"><span class="keyword">int</span> <span class="comment">//must be int&amp;</span></span><br><span class="line"><span class="keyword">int</span></span><br></pre></td></tr></table></figure><p><a href="https://github.com/GaijinEntertainment/daScript/blob/master/examples/test/misc/contracts_example.das" target="_blank" rel="noopener">https://github.com/GaijinEntertainment/daScript/blob/master/examples/test/misc/contracts_example.das</a><br><em>вывод typeinfo, кажется, содержит <a href="https://github.com/GaijinEntertainment/daScript/issues/393" target="_blank" rel="noopener">баг</a></em></p><p><strong><code>Временные ссылки</code></strong></p><p>Кроме обычных ссылок в daScript есть временные ссылки, которые позволяют работать с объектами из C++-кода внутри блоков. Временная ссылка доступна только внутри блока, и не может быть сохранена вне его (но может быть передана в другую функцию, принимающую временные объекты).</p><p>Рассмотрим для примера C++ тип <code>Color</code> из <a href="https://github.com/GaijinEntertainment/daScript/blob/master/examples/tutorial/tutorial03.cpp#L15" target="_blank" rel="noopener">туториала к daScript</a>. Для него создаётся daScript-обёртка, в которую можно добавить декларацию конструктора и инициализатора с помощью паттерна <code>using</code> — в этом случае можно создать временную ссылку на тип, которая будет доступна только внутри блока: </p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//cpp</span></span><br><span class="line">Module_Tutorial03() : Module(<span class="string">"tutorial_03"</span>) &#123;   <span class="comment">// module name, when used from das file</span></span><br><span class="line">    ModuleLibrary lib;</span><br><span class="line">    ...</span><br><span class="line">    addCtorAndUsing&lt;Color&gt;(*<span class="keyword">this</span>, lib, <span class="string">"Color"</span>, <span class="string">"Color"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//das</span></span><br><span class="line"></span><br><span class="line">require tutorial_03</span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">printColor</span><span class="params">(c : Color)</span> <span class="comment">//same as Color&amp; as c is struct</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;typeinfo(typename c)&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">def <span class="title">printColor</span><span class="params">(c : Color#)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;typeinfo(typename c)&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">[export]</span><br><span class="line">def test</span><br><span class="line">    let c = [[Color]]</span><br><span class="line">    printColor(c)</span><br><span class="line">    <span class="keyword">using</span>() &lt;| $(var c_temp : Color#)</span><br><span class="line">        printColor(c_temp)</span><br><span class="line"><span class="comment">//Output</span></span><br><span class="line">tutorial_03::Color <span class="keyword">const</span></span><br><span class="line">tutorial_03::Color <span class="keyword">const</span>#</span><br></pre></td></tr></table></figure><p><strong>Если тип нельзя <a href="https://github.com/GaijinEntertainment/daScript/commit/9521fdba38c4f5ea422450c6b4979cc2808f58ef" target="_blank" rel="noopener">скопировать или переместить</a>, то <code>using</code> не будет не будет создавать временный тип — аргумент и так не сможет покинуть блок</strong></p><p>Чаще всего нет необходимости в раздельной обработке обычных и временных ссылок, в этом случае можно добавить к типу аргумента спецификатор <code>implicit</code>:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">printColor</span><span class="params">(c:Color implicit)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;typeinfo(typename c)&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"><span class="comment">//Output</span></span></span><br><span class="line"><span class="function">tutorial_03::Color <span class="keyword">const</span> implicit</span></span><br><span class="line"><span class="function">tutorial_03::Color <span class="keyword">const</span> implicit</span></span><br></pre></td></tr></table></figure><p>Небольшое отличие в том, как будет трактоваться аргумент:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">printColor</span><span class="params">(c:Color implicit)</span>    <span class="comment">// accepts Color and Color#, a will be treated as Color</span></span></span><br><span class="line"><span class="function">def <span class="title">printColor</span><span class="params">(c:Color# implicit)</span>   <span class="comment">// accepts Color and Color#, a will be treated as Color#</span></span></span><br></pre></td></tr></table></figure></p><p><strong><code>Указатели</code></strong></p><p>Как и в C++, указатели — это ссылки, которые могут указывать на <code>null</code>, также имеют чуть другую семантику, что позволяет уже без шаманства иметь перегрузки для значения и указателя.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">require daslib/safe_addr</span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">func</span><span class="params">(var a: <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;typeinfo(typename a)&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">def <span class="title">func</span><span class="params">(var a: <span class="keyword">int</span>?)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;typeinfo(typename a)&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">[export]</span><br><span class="line">def main</span><br><span class="line">    var a: <span class="keyword">int</span></span><br><span class="line">    var a_ptr: <span class="keyword">int</span>? = safe_addr(a)</span><br><span class="line">    func(a)</span><br><span class="line">    func(a_ptr)</span><br><span class="line"><span class="comment">//Output</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line"><span class="keyword">int</span>?</span><br></pre></td></tr></table></figure><p><strong><code>Приведение базовых типов</code></strong></p><p>Базовые типы не приводятся друг другу неявно, требуется явный вызов конструктора типа (<em>Explicit is better than implicit</em>).</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">func</span><span class="params">(a : <span class="keyword">int</span>)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function">def <span class="title">func</span><span class="params">(a : <span class="keyword">float</span>)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function">def <span class="title">func</span><span class="params">(a : int4)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function">def <span class="title">func</span><span class="params">(a : <span class="keyword">bool</span>)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function">def <span class="title">func</span><span class="params">(a : uint)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function">def <span class="title">func</span><span class="params">(a : int64)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main</span><br><span class="line">    func(<span class="number">1</span>) <span class="comment">//int</span></span><br><span class="line">    func(<span class="keyword">float</span>(<span class="number">1</span>)); func(<span class="number">1.0f</span>) <span class="comment">//float</span></span><br><span class="line">    func(int4(<span class="number">1</span>)) <span class="comment">//int4</span></span><br><span class="line">    func(<span class="literal">true</span>) <span class="comment">//bool</span></span><br><span class="line">    func(uint(<span class="number">1</span>)); func(<span class="number">1u</span>); func(<span class="number">0x1</span>) <span class="comment">//uint</span></span><br><span class="line">    func(int64(<span class="number">1</span>)); func(<span class="number">1l</span>) <span class="comment">//int64</span></span><br></pre></td></tr></table></figure><p><strong><code>Приведение классов/структур</code></strong></p><p>Для типов, поддерживающих наследование, неявно выполняется приведение указателей и ссылок от дочернего к родительскомму типу (<a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle" target="_blank" rel="noopener">LSP</a>).</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> </span></span><br><span class="line"><span class="class">    <span class="title">a</span> :</span> <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> :</span> A</span><br><span class="line">    b : <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">func</span><span class="params">(a : A)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;typeinfo(typename a)&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">[export]</span><br><span class="line">def main</span><br><span class="line">    var a : A</span><br><span class="line">    var b : B</span><br><span class="line">    func(a)</span><br><span class="line">    func(b)</span><br><span class="line"><span class="comment">//Output:</span></span><br><span class="line">A <span class="keyword">const</span></span><br><span class="line">A <span class="keyword">const</span></span><br></pre></td></tr></table></figure><p>Приведение типов структур (<code>cast/upcast/reinterpret</code>):<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var a : A</span><br><span class="line">var b : B</span><br><span class="line"></span><br><span class="line">var refA : A&amp; = a</span><br><span class="line">var refB : B&amp; = b</span><br><span class="line"></span><br><span class="line"><span class="comment">//downcast, safe</span></span><br><span class="line">refA = cast&lt;A&amp;&gt; refB </span><br><span class="line"><span class="comment">//upcase, unsafe</span></span><br><span class="line">unsafe</span><br><span class="line">    refB = upcast&lt;B&amp;&gt; refA</span><br><span class="line"><span class="comment">//reinterpret cast, VERY unsafe, can cast any</span></span><br><span class="line">unsafe</span><br><span class="line">    refA = reinterpret&lt;A&amp;&gt;(<span class="number">1</span>) <span class="comment">//will crash</span></span><br></pre></td></tr></table></figure></p><p><strong>При выборе перегрузки функции выбирается та, для которой нужно выполнить наименьшее количество преобразований (при равном количестве daScript выдаст ошибку неоднозначности выбора)</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> </span></span><br><span class="line"><span class="class">    <span class="title">a</span> :</span> <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> :</span> A</span><br><span class="line">    b: <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">func</span><span class="params">(var a : A?)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"a: &#123;typeinfo(typename a)&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">def <span class="title">func</span><span class="params">(var b : B?)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"b: &#123;typeinfo(typename b)&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">def <span class="title">func4</span><span class="params">(var a,b,c,d: A?)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"AAAA\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">def <span class="title">func4</span><span class="params">(var a,b,c: A?; var d: B?)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"AAAB\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">def <span class="title">func4</span><span class="params">(var a,b : A?; var c: B?; var d: A?)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"AABA\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">def <span class="title">func4</span><span class="params">(var a,b,c,d: B?)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"BBBB\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">[export]</span><br><span class="line">def main</span><br><span class="line">    <span class="comment">//simple cases</span></span><br><span class="line">    var refA = <span class="keyword">new</span> A()</span><br><span class="line">    func(refA) <span class="comment">//a: A?</span></span><br><span class="line">    var refB = <span class="keyword">new</span> B()</span><br><span class="line">    func(refB) <span class="comment">//b: B?</span></span><br><span class="line">    var refAB = cast&lt;A?&gt; <span class="keyword">new</span> B()</span><br><span class="line">    func(refAB) <span class="comment">//a: A?</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//advanced cases</span></span><br><span class="line">    func4(refA, refA, refA, refA) <span class="comment">//shortest LSP to AAAA = 0</span></span><br><span class="line">    func4(refA, refA, refA, refB) <span class="comment">//shortest LSP to AAAB = 0</span></span><br><span class="line">    <span class="comment">//func4(refA, refA, refB, refB) //shortest LSP to AAAB/AABA = 1, conflict error</span></span><br><span class="line">    func4(refA, refB, refB, refA) <span class="comment">//shortest LSP to AABA = 1</span></span><br><span class="line">    func4(refB, refB, refB, refB) <span class="comment">//shortest LSP to BBBB = 0</span></span><br></pre></td></tr></table></figure><p><strong><code>explicit</code></strong></p><p>Для того, чтобы отключить LSP приведение типа аргумента, можно добавить ключевое слово <code>explicit</code>. Так </p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> </span></span><br><span class="line"><span class="class">    <span class="title">a</span> :</span> <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> :</span> A</span><br><span class="line">    b : <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">func</span><span class="params">(var a : A <span class="keyword">explicit</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;typeinfo(typename a)&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">[export]</span><br><span class="line">def main</span><br><span class="line">    var a : A</span><br><span class="line">    var b : B</span><br><span class="line">    func(a)   <span class="comment">//A</span></span><br><span class="line">    <span class="comment">//func(b) //invalid argument a (0). expecting A explicit -const, passing B&amp; -const</span></span><br></pre></td></tr></table></figure><p><strong><code>Приведение generic-типов</code></strong></p><p>В документации не описана работа с generic-типами (и не дано общее определение для них, также пока отсутствует возможность создания своих типов), но поиском по коду находятся такие встроенные типы (исключая те, которые связаны с оператором typeinfo и кастами):</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Функциональные объекты:</span><br><span class="line">block</span><br><span class="line">function</span><br><span class="line">lambda</span><br><span class="line"></span><br><span class="line">Коллекции:</span><br><span class="line">array</span><br><span class="line">table&lt;key&gt;</span><br><span class="line">table&lt;key, value&gt;</span><br><span class="line"></span><br><span class="line">iterator</span><br><span class="line">generator</span><br><span class="line">smart_ptr</span><br><span class="line">tuple</span><br><span class="line">variant</span><br></pre></td></tr></table></figure><p>Для таких типов, возможно явное LSP-приведение для типов их аргументов (<code>ковариантность</code>). Пример для функций:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> </span></span><br><span class="line"><span class="class">    <span class="title">a</span> :</span> <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> :</span> A</span><br><span class="line">    b : <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">func1</span><span class="params">(var a : A)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"a\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">def <span class="title">func2</span><span class="params">(var b : B)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"b\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">def <span class="title">highOrder</span><span class="params">(func: function&lt;(var a:A):<span class="keyword">void</span>&gt;)</span></span></span><br><span class="line"><span class="function">    <span class="title">invoke</span><span class="params">(func, [[B]])</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">[export]</span><br><span class="line">def main</span><br><span class="line">    highOrder(@@func1)</span><br><span class="line">    highOrder(cast&lt;function&lt;(var a:A):<span class="keyword">void</span>&gt;&gt; @@func2) <span class="comment">//возможно привести тип function&lt;(var b:B):void&gt; к function&lt;(var a:A):void&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Generic-функции"><a href="#Generic-функции" class="headerlink" title="Generic-функции"></a>Generic-функции</h2><p>Вернёмся к самому первому примеру — если мы хотим написать функцию, семантически одинаково обрабатывающую различные типы (например, выводящую значение типа с помощью функции <code>print</code>) для типов. Чтобы не реализовывать её для каждого нового типа, в языках программирования используется понятие generic-функций, которые могут производить конкретные функции для новых типов автоматически.</p><p><a href="https://habr.com/ru/company/piter/blog/656377/" target="_blank" rel="noopener">Обзор реализаций в языках</a>.</p><p>Шаблонные функции в C++ производят код конкретных функций на уровне текста, который отдаётся компилятору (если не ошибаюсь, компилятор visual studio в этом плане действительно генерирует полные копии, не остлеживаю возможных повторов, чтобы иметь больше простора для частных оптимизаций функции под конкретные типы, а clang чуть раньше начинает отслеживать потенциально идентичные реализации для экономии памяти).</p><p>Другой возможный вариант реализации в Java — “изображать” generic на высоком уровне для контроля типов, но оставлять одну реализацию (все объекты передаются по ссылке, добавляется overhead при работе с value-типами по боксингу/анбоксингу в обёртку).</p><p>Третий путь из C# — добавить поддержку generic-функций в виртуальную машину, в этом случае возможна комбинированная реализация — value-типы получают свои сгенерированные копии функций, а reference-типы — общую функцию. Также возможно инстанцировать новые версии функций в runtime. daScript близок к такому типу реализации generic-функций.</p><p><strong><code>Автоматический вывод типов</code></strong></p><p>Если не указан тип аргумента функции, daScript выводит его автоматически, пример функции id принимающей аргумент любого типа и возвращающий его:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">options <span class="built_in">log</span>=<span class="literal">true</span>, optimize=<span class="literal">false</span></span><br><span class="line"></span><br><span class="line">struct S1</span><br><span class="line">    a: <span class="keyword">int</span></span><br><span class="line">struct S2</span><br><span class="line">    a: <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">def id(T)</span><br><span class="line">    <span class="keyword">return</span> T</span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main</span><br><span class="line">    let a = id(<span class="number">1</span>)</span><br><span class="line">    let b = id(<span class="number">1.0f</span>)</span><br><span class="line">    let c = id([[S1]])</span><br><span class="line">    let d = id([[S2]])</span><br><span class="line"><span class="comment">//Output</span></span><br><span class="line"></span><br><span class="line">def `id ( T:<span class="keyword">int</span> <span class="keyword">const</span> <span class="keyword">explicit</span> ) : <span class="keyword">int</span> <span class="keyword">const</span></span><br><span class="line">        <span class="keyword">return</span> T</span><br><span class="line"></span><br><span class="line">def `id ( T:<span class="keyword">float</span> <span class="keyword">const</span> <span class="keyword">explicit</span> ) : <span class="keyword">float</span> <span class="keyword">const</span></span><br><span class="line">        <span class="keyword">return</span> T</span><br><span class="line"></span><br><span class="line">def `id ( T:S1 <span class="keyword">const</span> <span class="keyword">explicit</span> ) : S1 <span class="keyword">const</span></span><br><span class="line">        <span class="keyword">return</span> T</span><br><span class="line"></span><br><span class="line">def `id ( T:S2 <span class="keyword">const</span> <span class="keyword">explicit</span> ) : S2 <span class="keyword">const</span></span><br><span class="line">        <span class="keyword">return</span> T</span><br><span class="line"></span><br><span class="line">def <span class="keyword">public</span> main</span><br><span class="line">        let a:<span class="keyword">int</span> <span class="keyword">const</span> = __::`id(<span class="number">1</span>)</span><br><span class="line">        let b:<span class="keyword">float</span> <span class="keyword">const</span> = __::`id(<span class="number">1f</span>)</span><br><span class="line">        let c:S1 <span class="keyword">const</span> = __::`id([[S1 ]])</span><br><span class="line">        let d:S2 <span class="keyword">const</span> = __::`id([[S2 ]])</span><br></pre></td></tr></table></figure><p>По выводу текста сгенерированной программы понятна реализация. Символы подчёркивания перед именем функции <code>__::id</code> означают “взять реализацию функции только из текущего модуля” (<a href="https://dascript.org/doc/reference/language/modules.html#module-function-visibility" target="_blank" rel="noopener">линк</a>), идея будет рассмотрена далее.</p><p>Большая часть фич, связанных с generic-функциями, связана с тем, чтобы так или иначе задать или использовать информацию о типах.</p><p><strong><code>auto</code></strong></p><p>Определение для id более развернуто выглядит так:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">id</span><span class="params">(a:<span class="keyword">auto</span>)</span>: <span class="keyword">auto</span></span></span><br><span class="line"><span class="function">    <span class="keyword">return</span> a</span></span><br></pre></td></tr></table></figure></p><p>Такая форма синтаксиса позволяет задать для каждого из выводимых типов псевдоним, который можно использовать для сравнения типа или получения rtti информации. Несколько примеров:</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">//print typename</span></span><br><span class="line"><span class="function">def <span class="title">func</span><span class="params">(a : <span class="keyword">auto</span>(T))</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;typeinfo(typename type&lt;T&gt;)&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//generic sum, a and b must be same type</span></span></span><br><span class="line"><span class="function">def <span class="title">sum</span><span class="params">(a, b : <span class="keyword">auto</span>(T))</span></span></span><br><span class="line">    return a + b</span><br></pre></td></tr></table></figure><p><strong><code>Использование типа в качестве аргумента</code></strong></p><p>Можно передать информацию о типе в качестве аргумента шаблона, как обычный <code>auto</code> аргумент.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//generic linear interpolation between int types via cast to float type</span></span><br><span class="line"><span class="function">def <span class="title">lerpi</span><span class="params">(a, b : <span class="keyword">auto</span>(IntType); part : <span class="keyword">float</span>; tempCastType : <span class="keyword">auto</span>(CastType))</span></span></span><br><span class="line"><span class="function">    <span class="keyword">return</span> <span class="title">IntType</span><span class="params">(CastType(a) + CastType(b - a) * part)</span></span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">"&#123;lerpi(int2(0, 0), int2(4, 4), 0.5f, type&lt;float2&gt;)&#125;\n"</span>)</span> <span class="comment">// (2,2)</span></span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">"&#123;lerpi(int3(1, 2, 3), int3(2, 4, 7), 0.5f, type&lt;float3&gt;)&#125;\n"</span>)</span> <span class="comment">// (1,3,5)</span></span></span><br></pre></td></tr></table></figure><p>Для того, чтобы тип не передавался в runtime, существует макрос <a href="https://github.com/GaijinEntertainment/daScript/blob/master/daslib/templates.das#L41" target="_blank" rel="noopener">template</a>, который в compile-time убирает такие аргументы.</p><p><strong><code>Шаблоны для auto</code></strong></p><p>Различные формы <a href="https://dascript.org/doc/reference/language/generic_programming.html#type-contracts-and-type-operations" target="_blank" rel="noopener">ограчений</a> для типов аргументов auto. Примеры из доки</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">foo</span><span class="params">( a : <span class="keyword">auto</span>&amp;)</span>           <span class="comment">// accepts any type, passed by reference</span></span></span><br><span class="line"><span class="function">def <span class="title">foo</span><span class="params">( a : <span class="keyword">auto</span>[])</span>          <span class="comment">// accepts static array of any type of any size</span></span></span><br><span class="line"><span class="function">def <span class="title">foo</span><span class="params">( a : <span class="built_in">array</span>&lt;<span class="keyword">auto</span> -<span class="keyword">const</span>&gt;)</span>  <span class="comment">// matches any array, with non-const elements</span></span></span><br><span class="line"><span class="function"><span class="comment">//some tests</span></span></span><br><span class="line"><span class="function">def <span class="title">foo</span><span class="params">(a: tuple&lt;<span class="keyword">auto</span>; <span class="keyword">auto</span>; <span class="keyword">auto</span>&gt;)</span> <span class="comment">//tuple of 3 elements, any type</span></span></span><br><span class="line"><span class="function">def <span class="title">foo</span><span class="params">(a: function&lt;(a : <span class="keyword">auto</span>) : <span class="keyword">auto</span>&gt;)</span> <span class="comment">//any function with 1 argument</span></span></span><br><span class="line"><span class="function">def <span class="title">foo</span><span class="params">(a: table&lt;<span class="keyword">int</span>; <span class="keyword">auto</span>&gt;)</span> <span class="comment">//any tables with int keys</span></span></span><br></pre></td></tr></table></figure><p>Еще раз приведу <a href="https://dascript.org/doc/reference/language/functions.html#function-overloading" target="_blank" rel="noopener">ссылку</a> на правила выбора функций при наличии нескольких специализаций и перегрузок.</p><p><strong><code>Контракты</code></strong></p><p>Так же, как и к аргументам обычным функциям, к аргументам generic-функциям могут быть применены контракты, позволяющие в более общем виде описать ограничения для типа аргумента. Именно c generic-функциями видна вся мощь контрактов.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">require daslib/contracts</span><br><span class="line"></span><br><span class="line"><span class="comment">//accept any functions</span></span><br><span class="line">[expect_any_function(a)]</span><br><span class="line"><span class="function">def <span class="title">foo</span><span class="params">(a: <span class="keyword">auto</span>(T))</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;typeinfo(typename type&lt;T&gt;)&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//accept any tuples</span></span></span><br><span class="line">[expect_any_tuple(a)]</span><br><span class="line"><span class="function">def <span class="title">bar</span><span class="params">(a:<span class="keyword">auto</span>(T))</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;typeinfo(typename type&lt;T&gt;)&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">[export]</span><br><span class="line">def main</span><br><span class="line">    foo(@@(a : <span class="keyword">int</span>) =&gt; a)                       <span class="comment">//function&lt;(a:int const):int const&gt; const</span></span><br><span class="line">    foo(@@(a : <span class="keyword">int</span>; b: <span class="keyword">float</span>) =&gt; <span class="string">"hello world"</span>) <span class="comment">//function&lt;(a:int const;b:float const):string const&gt; const</span></span><br><span class="line">    bar([[<span class="keyword">auto</span> <span class="number">1</span> ,<span class="number">2.0f</span>, <span class="string">"test"</span>]])               <span class="comment">//tuple&lt;int;float;string&gt; const</span></span><br><span class="line">    bar([[<span class="keyword">auto</span> <span class="number">1</span>, <span class="number">1</span>]])                          <span class="comment">//tuple&lt;int;int&gt; const</span></span><br></pre></td></tr></table></figure><p>Контракты для одного аргумента могут комбинироваться с помощью операторов !, &amp;&amp;, || и ^^</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">require daslib/contracts</span><br><span class="line"></span><br><span class="line">[expect_any_function(arg) || expect_any_tuple(arg)]</span><br><span class="line"><span class="function">def <span class="title">func_or_tuple</span><span class="params">(var arg : <span class="keyword">auto</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;typeinfo(typename arg)&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//expect_any_array разрешает любые массивы, expect_dim - статические массивы</span></span></span><br><span class="line">[expect_any_array(arg) &amp;&amp; !expect_dim(arg)]</span><br><span class="line"><span class="function">def <span class="title">array_and_notdim</span><span class="params">(var arg : <span class="keyword">auto</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;typeinfo(typename arg)&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">[export]</span><br><span class="line">def main</span><br><span class="line">    func_or_tuple(@@(a : <span class="keyword">int</span>) =&gt; a)</span><br><span class="line">    func_or_tuple([[<span class="keyword">auto</span> <span class="number">1</span>, <span class="number">2.0</span>, <span class="string">"3"</span>]])</span><br><span class="line"></span><br><span class="line">    array_and_notdim([&#123; <span class="keyword">int</span>[] <span class="number">1</span>;<span class="number">2</span>;<span class="number">3</span> &#125;]) <span class="comment">//array&lt;int&gt; allowed</span></span><br><span class="line">    <span class="comment">//array_and_notdim([[ int[] 1;2;3 ]]) //int4[2] not allowed</span></span><br></pre></td></tr></table></figure><p><strong><code>Сумма типов</code></strong></p><p>Еще один способ задать ограничения для типа — перечислить разрешенные типы через символ <code>|</code> (<a href="https://dascript.org/doc/reference/language/generic_programming.html#options" target="_blank" rel="noopener">options</a> в доках):</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">foo</span><span class="params">(var a : <span class="keyword">int</span> | <span class="keyword">float</span> | <span class="built_in">string</span>)</span> <span class="comment">//accept int or float or string</span></span></span><br><span class="line"><span class="function">def <span class="title">foo</span><span class="params">(var a : <span class="built_in">array</span>&lt;<span class="keyword">int</span> | <span class="keyword">float</span>&gt;)</span> <span class="comment">//array of int of array of float</span></span></span><br><span class="line"><span class="function">def <span class="title">foo</span><span class="params">(a : function&lt;(a : <span class="keyword">auto</span>) : <span class="keyword">auto</span>&gt; | function&lt;(a, b : <span class="keyword">auto</span>) : <span class="keyword">auto</span>&gt;)</span> <span class="comment">//accept any function with 1 or 2 arguments</span></span></span><br><span class="line"><span class="function">def <span class="title">foo</span> <span class="params">(a : Bar <span class="keyword">explicit</span> | Foo)</span>   <span class="comment">// accept exactly Bar or anything inherited from Foo</span></span></span><br><span class="line"><span class="function">def <span class="title">foo</span> <span class="params">(a : Foo | #)</span> <span class="comment">//accept Foo and Foo#, looks like this short syntax only works with #</span></span></span><br></pre></td></tr></table></figure><p>Порядок проверки соответствия опций — слева направо:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">foo</span><span class="params">(var a : <span class="keyword">auto</span> | <span class="keyword">int</span>&amp;)</span> </span>&#123; a = <span class="number">84</span>; &#125;</span><br><span class="line"><span class="function">def <span class="title">bar</span><span class="params">(var a : <span class="keyword">int</span>&amp; | <span class="keyword">auto</span>)</span> </span>&#123; a = <span class="number">42</span>; &#125;</span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main</span><br><span class="line">    var a: <span class="keyword">int</span></span><br><span class="line">    foo(a) <span class="comment">// match foo(auto)</span></span><br><span class="line">    print(<span class="string">"&#123;a&#125;\n"</span>) <span class="comment">// a == 0</span></span><br><span class="line">    bar(a) <span class="comment">// match bar(int&amp;)</span></span><br><span class="line">    print(<span class="string">"&#123;a&#125;\n"</span>) <span class="comment">// a == 42</span></span><br></pre></td></tr></table></figure><p><strong><code>static_if</code></strong></p><p>Проверка наличия методов или полей структуры выполняется в момент инстанцирования generic-функции</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span></span></span><br><span class="line"><span class="class">    <span class="title">a</span> :</span> <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">foo</span><span class="params">(var s)</span></span></span><br><span class="line">    s.a = 42 //not check if s has field</span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main</span><br><span class="line">    var s : S</span><br><span class="line">    foo(s) <span class="comment">//ok</span></span><br></pre></td></tr></table></figure><p>Ошибка возникнет только в момент инстанциирования <code>foo</code> со структурой, не имеющей поля <code>a</code>. Проверить наличие полей или другую информацию о типе в время компиляции можно с помощью оператора <code>static_if</code>:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span></span></span><br><span class="line"><span class="class">    <span class="title">a</span> :</span> <span class="keyword">int</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">T</span></span></span><br><span class="line"><span class="class">    <span class="title">a</span> :</span> float4</span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">foo</span><span class="params">(var s)</span></span></span><br><span class="line"><span class="function">    static_if <span class="title">typeinfo</span><span class="params">(has_field&lt;a&gt; s)</span> &amp;&amp; <span class="params">(typeinfo(<span class="keyword">typename</span> s.a) == typeinfo(<span class="keyword">typename</span> type&lt;<span class="keyword">int</span> -<span class="keyword">const</span>&gt;))</span></span></span><br><span class="line">        s.a = 42</span><br><span class="line"></span><br><span class="line">var s : S</span><br><span class="line">foo(s) <span class="comment">//ok</span></span><br><span class="line">var t: T</span><br><span class="line">foo(t) <span class="comment">//also ok, but do nothing</span></span><br></pre></td></tr></table></figure><p><strong><code>Вызываемые макросы</code></strong></p><p>Более сложные конструкции вроде “вызвать конструктор того же типа, что и поле структуры <code>s.a</code> можно выразить с помощью макросов</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//generics macro</span></span><br><span class="line"><span class="keyword">module</span> generics_macro shared <span class="keyword">private</span></span><br><span class="line"></span><br><span class="line">[call_macro(name=<span class="string">"convert_to"</span>)]  <span class="comment">// convert_to(convertType, arg)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApplyMacro</span> :</span> AstCallMacro</span><br><span class="line">    <span class="comment">//! convert_to("float4", 42) -&gt; float4(42)</span></span><br><span class="line">    <span class="function">def <span class="keyword">override</span> <span class="title">visit</span> <span class="params">( prog:ProgramPtr; mod:Module?; var expr:smart_ptr&lt;ExprCallMacro&gt; )</span> : ExpressionPtr</span></span><br><span class="line">        var exprConstStr &lt;- unsafe(reinterpret&lt; smart_ptr&lt;ast::ExprConstString&gt;&amp;&gt; expr.arguments[0])</span><br><span class="line">        var call &lt;- <span class="keyword">new</span> [[ExprCall() name:=exprConstStr.value, at=expr.at]]</span><br><span class="line">        emplace_new(call.arguments, clone_expression(expr.arguments[<span class="number">1</span>]))</span><br><span class="line">        <span class="keyword">return</span> &lt;- call</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">require generics_macro</span><br><span class="line"></span><br><span class="line">def foo(var s)</span><br><span class="line">    static_if typeinfo(has_field&lt;a&gt; s)</span><br><span class="line">        static_if typeinfo(has_field&lt;a&gt; s)</span><br><span class="line">            static_if typeinfo(<span class="keyword">typename</span> s.a) == typeinfo(<span class="keyword">typename</span> type&lt;<span class="keyword">int</span> -<span class="keyword">const</span>&gt;)</span><br><span class="line">                s.a = <span class="number">42</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                s.a = convert_to(typeinfo(<span class="keyword">typename</span> s.a), <span class="number">42</span>) <span class="comment">// --&gt; s.a = float4(42)</span></span><br><span class="line"></span><br><span class="line">var t : T</span><br><span class="line">foo(t)</span><br><span class="line">print(<span class="string">"&#123;t&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Output:</span></span><br><span class="line">[[ <span class="number">42</span>,<span class="number">42</span>,<span class="number">42</span>,<span class="number">42</span>]]</span><br></pre></td></tr></table></figure><p><strong><code>[generic]</code></strong></p><p>daScript распознаёт обычные или generic-функции по синтаксису, но можно также явно обозначить функцию как generic:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">options <span class="built_in">log</span>=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">[generic]</span><br><span class="line">def func()</span><br><span class="line">    print(<span class="string">"hello"</span>)</span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main</span><br><span class="line">    func()</span><br><span class="line"></span><br><span class="line"><span class="comment">//Output:</span></span><br><span class="line"></span><br><span class="line">def <span class="keyword">private</span> `func</span><br><span class="line">        print(<span class="string">"hello"</span>,__context__)</span><br><span class="line"></span><br><span class="line"><span class="comment">// [modify_external]</span></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def <span class="keyword">public</span> main</span><br><span class="line">        __::`func()</span><br></pre></td></tr></table></figure><p>В таком случае вызов <code>func</code> будет преобразован в <code>__::</code>func` - вызов версии функции только из текущего модуля. Это используется в <a href="https://github.com/GaijinEntertainment/daScript/blob/87ab585fc3704896bff3eea71ab87e29f772be94/src/builtin/fio.das#L10" target="_blank" rel="noopener">некоторых функциях</a> стандартной библиотеки daslib, потому что если компилятор знает, что функция находится в том же модуле, что и вызывающий код, то может её оптимизировать — при AoT-компиляции генериуется не полноценный вызов через ABI (который может вести в другой не-AoT daScript модуль), а прямой вызов, что быстрее.</p><p><strong><code>[instance_function]</code></strong></p><p>С помощью макроса <code>[instance_function]</code> можно попросить явно специализировать generic-функцию с определенными типами:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">require daslib/instance_function</span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">func</span><span class="params">(a : <span class="keyword">auto</span>(TT))</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;typeinfo(typename a )&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">[instance_function(func, TT = "int const")]</span><br><span class="line"><span class="function">def <span class="title">print_int</span><span class="params">(a)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main</span><br><span class="line">    print_int(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><strong><code>Видимость модулей</code></strong></p><p>Для generic функций, которые подразумевают переопределение для новых кастомных типов в других модулях, необходимо добавлять префикс <code>_::</code> или <code>__::</code>, чтобы обозначить, что функций должна искаться в том модуле, который её вызывает.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//module1.das</span></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line"><span class="function">def <span class="title">call_func</span><span class="params">(a)</span></span></span><br><span class="line"><span class="function">    <span class="title">_::func</span><span class="params">(a)</span> <span class="comment">//func will be declared somewhere later</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//main.das</span></span></span><br><span class="line"><span class="function">require module1</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">struct S</span></span><br><span class="line"><span class="function">    a: <span class="keyword">int</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">def <span class="title">func</span><span class="params">(s: S)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;s&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">call_func</span><span class="params">(s)</span> <span class="comment">//module1::call_func will see and call main::func()</span></span></span><br></pre></td></tr></table></figure><p><code>__::</code> — подразумевает возможность определения функции только в том же модуле, что и вызывающий код (main)<br><code>_::</code> — допускает определение как в том же модуле, что и вызывающий код, так и в других модулях (main, module1 или другие модули)</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;Обобщенное
      
    
    </summary>
    
    
    
      <category term="dascript" scheme="http://spiiin.github.io/tags/dascript/"/>
    
  </entry>
  
  <entry>
    <title>daScript: ООП и всякое</title>
    <link href="http://spiiin.github.io/blog/1023396573/"/>
    <id>http://spiiin.github.io/blog/1023396573/</id>
    <published>2023-01-12T17:20:25.000Z</published>
    <updated>2023-01-21T12:26:52.990Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><h1 id="Структуры"><a href="#Структуры" class="headerlink" title="Структуры"></a>Структуры</h1><h2 id="Структуры-daScript-наследование"><a href="#Структуры-daScript-наследование" class="headerlink" title="Структуры daScript, наследование"></a>Структуры daScript, наследование</h2><p><a href="https://dascript.org/doc/reference/language/structs.html#struct-declaration" target="_blank" rel="noopener">https://dascript.org/doc/reference/language/structs.html#struct-declaration</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">V2</span></span></span><br><span class="line"><span class="class">    <span class="title">x</span> :</span> <span class="keyword">float</span> = <span class="number">-1.0f</span></span><br><span class="line">    y : <span class="keyword">float</span></span><br><span class="line"></span><br><span class="line">struct V3: V2</span><br><span class="line">    z = <span class="number">3.0f</span></span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main</span><br><span class="line">    let a : V3</span><br><span class="line">    print(<span class="string">"a = &#123;a&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line">    let b = V3()</span><br><span class="line">    print(<span class="string">"b = &#123;b&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line">    let c = [[V3 y = <span class="number">2.0f</span>]]</span><br><span class="line">    print(<span class="string">"c = &#123;c&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line">    let d = [[V3() y = <span class="number">2.0f</span>]]</span><br><span class="line">    print(<span class="string">"d = &#123;d&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line">    let e = [[V3() y = <span class="number">2.0f</span>, x = <span class="number">1.0f</span>]]</span><br><span class="line">    print(<span class="string">"e = &#123;e&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    let pd = <span class="keyword">new</span> [[V3() y = <span class="number">2.0f</span>]]</span><br><span class="line">    print(<span class="string">"pd = &#123;pd&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Output:</span></span><br><span class="line">a = [[ <span class="number">0.000000000</span>; <span class="number">0.000000000</span>; <span class="number">0.000000000</span>]]</span><br><span class="line">b = [[ <span class="number">-1.000000000</span>; <span class="number">0.000000000</span>; <span class="number">3.000000000</span>]]</span><br><span class="line">c = [[ <span class="number">0.000000000</span>; <span class="number">2.000000000</span>; <span class="number">0.000000000</span>]]</span><br><span class="line">d = [[ <span class="number">-1.000000000</span>; <span class="number">2.000000000</span>; <span class="number">3.000000000</span>]]</span><br><span class="line">e = [[ <span class="number">1.000000000</span>; <span class="number">2.000000000</span>; <span class="number">3.000000000</span>]]</span><br><span class="line">pd = [[ <span class="number">-1.000000000</span>; <span class="number">2.000000000</span>; <span class="number">3.000000000</span>]]</span><br></pre></td></tr></table></figure><p>a,b,c,d,e - структуры, размещенные на стеке. В зависимости от способа объявления можно пропускать инициализацию полей по умолчанию — круглые скобки в объявлении добавляют код инициализации (в порядке от родительской структуры к дочерним). Синтаксис с квадратными скобками позволяет изменить значения отдельных полей. Неинициализированные явно или по умолчанию поля инициализируются нулями — получить в качестве значений неинициализированный мусор нельзя.</p><p>Ещё несколько примеров комбинаций синтаксиса инициализации, в первом случае создаётся структура, во втором — массив структур, в третьем — итератор<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//where clause: post init function</span></span><br><span class="line">let f = [[V3 where $(var self) &#123;</span><br><span class="line">    self.x = <span class="number">11.0f</span>;</span><br><span class="line">    self.y = <span class="number">11.0f</span>;</span><br><span class="line">    self.z = <span class="number">11.0f</span>;</span><br><span class="line">&#125;]]</span><br><span class="line"></span><br><span class="line"><span class="comment">//array initialization, g_arr: V3[2]</span></span><br><span class="line">let g_arr = [[V3 </span><br><span class="line">    x=<span class="number">1.0f</span>, y=<span class="number">1.0f</span>, z=<span class="number">1.0f</span>;</span><br><span class="line">    x=<span class="number">2.0f</span>, y=<span class="number">2.0f</span>, z=<span class="number">2.0f</span></span><br><span class="line">]]</span><br><span class="line"></span><br><span class="line"><span class="comment">//array comprehesion, h_arr : iterator&lt;V3&gt;</span></span><br><span class="line">let h_iter &lt;- [[ <span class="keyword">for</span> i in range(<span class="number">0</span>, <span class="number">10</span>); [[V3 x=<span class="keyword">float</span>(i), y=<span class="keyword">float</span>(i), z=<span class="keyword">float</span>(i)]]; where (i&amp;<span class="number">1</span>)==<span class="number">1</span> ]]</span><br><span class="line">let g_iter &lt;- [[ <span class="keyword">for</span> i in range(<span class="number">0</span>, <span class="number">10</span>); invoke(&#123; let fi = <span class="keyword">float</span>(i); <span class="keyword">return</span> [[V3 x=fi, y=fi, z=fi]]; &#125;); where (i&amp;<span class="number">1</span>)==<span class="number">1</span> ]] <span class="comment">// same</span></span><br></pre></td></tr></table></figure></p><p>pd - указатель на структуру, размещенную в куче. Сама структура может быть инициализирована любым из перечисленных выше способов.</p><h2 id="Финализаторы"><a href="#Финализаторы" class="headerlink" title="Финализаторы"></a>Финализаторы</h2><p><a href="https://dascript.org/doc/reference/language/finalizers.html#finalizers" target="_blank" rel="noopener">https://dascript.org/doc/reference/language/finalizers.html#finalizers</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var d = [[V3() y = <span class="number">2.0f</span>]]</span><br><span class="line">print(<span class="string">"d = &#123;d&#125;\n"</span>)</span><br><span class="line"><span class="keyword">delete</span> d</span><br><span class="line">print(<span class="string">"d = &#123;d&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line">var pd = <span class="keyword">new</span> [[V3() y = <span class="number">2.0f</span>]]</span><br><span class="line">print(<span class="string">"pd = &#123;pd&#125;\n"</span>)</span><br><span class="line">unsafe &#123; <span class="keyword">delete</span> pd; &#125;</span><br><span class="line">print(<span class="string">"pd = &#123;pd&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Output</span></span><br><span class="line">d = [[ <span class="number">-1.000000000</span>; <span class="number">2.000000000</span>; <span class="number">3.000000000</span>]]</span><br><span class="line">d = [[ <span class="number">0.000000000</span>; <span class="number">0.000000000</span>; <span class="number">0.000000000</span>]]</span><br><span class="line">pd = [[ <span class="number">-1.000000000</span>; <span class="number">2.000000000</span>; <span class="number">3.000000000</span>]]</span><br><span class="line">pd = null</span><br></pre></td></tr></table></figure><p>Финализатор по умолчанию для структуры зануляет память (в порядке от потомков к родителям, при необходимости зовёт финализаторы для членов структуры в порядке объявления). Для указателей — после зануления полей структуры дополнительно меняет адрес указателя на null. Финализаторы для структур и классов зовутся вручную. Финализаторы не освобождают память, на которую указывает объект.</p><h2 id="Освобождение-памяти"><a href="#Освобождение-памяти" class="headerlink" title="Освобождение памяти"></a>Освобождение памяти</h2><p>Модель памяти по умолчанию в daScript не подразумевает очистки памяти в ходе выполнения скрипта, за очистку отвечает хост-приложение, которое может просто освободить всю память контекста целиком — пересоздание контекстов by design быстро и эффективно, так что такой способ предпочтительный.</p><p>Но можно настроить поведение контекста опцией <code>persistent_heap</code>:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">options persistent_heap = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">var pd = <span class="keyword">new</span> [[V3() y = <span class="number">2.0f</span>]]</span><br><span class="line">var pd2 = pd</span><br><span class="line">unsafe</span><br><span class="line">    print(<span class="string">"addr(pd) = &#123;reinterpret&lt;uint&gt;(pd)&#125;\n"</span>)</span><br><span class="line">    print(<span class="string">"addr(pd2) = &#123;reinterpret&lt;uint&gt;(pd2)&#125;\n"</span>)</span><br><span class="line">    <span class="keyword">delete</span> pd</span><br><span class="line">pd2.x = <span class="number">33.0f</span></span><br><span class="line">print(<span class="string">"pd2 = &#123;pd2&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Output</span></span><br><span class="line">addr(pd) = <span class="number">0xf1909e10</span></span><br><span class="line">addr(pd2) = <span class="number">0xf1909e10</span></span><br><span class="line">pd2 = [[ <span class="number">33.000000000</span>; <span class="number">-431602080.000000000</span>; <span class="number">-431602080.000000000</span>]] <span class="comment">//мусор</span></span><br></pre></td></tr></table></figure><p>Я включил опцию <code>DAS_SANITIZER</code> при сборке daScript, чтобы после освобождения объектов в случае с persistent_heap память перезаписывалась мусорными значениями (0xCD, -431602080 если интерпретировать 0xCDCDCDCD как float-значение). В данном случае программа по счастливому стечению обстоятельств не упала, но благодаря санитайзеру видно, что указатель pd2 после удаления pd стал висячим — указывает на свободную память, которая могла бы быть выделена другому объекту (объекту daScript того же контекста в случае <code>persistent_heap=false</code>, или любому другому объекту хост-приложения с <code>persistent_heap=true</code>).</p><p>Более “злобный” вариант примера:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var pd = <span class="keyword">new</span> [[V3() y = <span class="number">2.0f</span>]]</span><br><span class="line">var pd2 = pd</span><br><span class="line">unsafe &#123; <span class="keyword">delete</span> pd; &#125;</span><br><span class="line">var pd3 = <span class="keyword">new</span> [[V3() x = <span class="number">33.0f</span>, y = <span class="number">33.0f</span>, z = <span class="number">33.0f</span>]]</span><br><span class="line">pd2.x = <span class="number">-100.0f</span> <span class="comment">// &lt;----- kaboom!</span></span><br><span class="line">print(<span class="string">"pd2 = &#123;pd2&#125;\n"</span>)</span><br><span class="line">print(<span class="string">"pd3 = &#123;pd3&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Output</span></span><br><span class="line">pd2 = [[ <span class="number">-100.000000000</span>; <span class="number">33.000000000</span>; <span class="number">33.000000000</span>]]</span><br><span class="line">pd3 = [[ <span class="number">-100.000000000</span>; <span class="number">33.000000000</span>; <span class="number">33.000000000</span>]]</span><br></pre></td></tr></table></figure><br>После освобождения память на которую указывали pd и pd2 была повторно отдана новому объекту, на который указывает pd3. Этот объект теперь может поменяться через указатель pd2. Должно быть понятно, насколько unsafe операция удаления — код стал насколько же опасным (но и настолько же быстрым), как и код на языке си.</p><h2 id="Кастомные-финализаторы"><a href="#Кастомные-финализаторы" class="headerlink" title="Кастомные финализаторы"></a>Кастомные финализаторы</h2><p>Финализатор можно переопределить, пример: финализатор для структуры V2</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">finalize</span><span class="params">(var v : V2)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"kill V2 &#123;v&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">var d </span>= [[ V3 x = <span class="number">11.0f</span>, y = <span class="number">22.0f</span>, z = <span class="number">33.0f</span>]]</span><br><span class="line"><span class="keyword">delete</span> d</span><br><span class="line">print(<span class="string">"d = &#123;d&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Output</span></span><br><span class="line">kill V2 [[ <span class="number">11.000000000</span>; <span class="number">22.000000000</span>]]</span><br><span class="line">d = [[ <span class="number">11.000000000</span>; <span class="number">22.000000000</span>; <span class="number">33.000000000</span>]]</span><br></pre></td></tr></table></figure><p>Вместо финализатора зануления по умолчанию вызывается функция, логгирующая поле. Также можно заметить неочевидную вещь (если думать о финализаторах как о деструкторах, но лучше не думать) — финализаторы не зовутся в порядке от потомков к предкам, а как работают как обычные функции, daScript нашёл подходящую функцию, принимающую тип V2, и не вызвал зануления также и у поля z - т.е. финализатор родительской структуры “подошёл” к дочерней.</p><p>Более похожий на порядок вызова деструкторов в C/C++ код<br><blockquote><p>(<strong>ещё раз, финализаторы — это не деструкторы, они вызываются только при явном вызове оператора delete!</strong>)</p></blockquote></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">finalize</span><span class="params">(var v : V2 <span class="keyword">explicit</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"kill V2 &#123;v&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">def <span class="title">finalize</span><span class="params">(var v : V3 <span class="keyword">explicit</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">finalize</span><span class="params">(cast&lt;V2&gt; v)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"kill V3 &#123;v&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">[export]</span><br><span class="line">def main</span><br><span class="line">    var d = [[ V3 x = <span class="number">11.0f</span>, y = <span class="number">22.0f</span>, z = <span class="number">33.0f</span>]]</span><br><span class="line">    <span class="keyword">delete</span> d</span><br><span class="line">    print(<span class="string">"d = &#123;d&#125;\n"</span>)</span><br><span class="line"><span class="comment">//Output</span></span><br><span class="line">kill V2 [[ <span class="number">11.000000000</span>; <span class="number">22.000000000</span>]]</span><br><span class="line">kill V3 [[ <span class="number">11.000000000</span>; <span class="number">22.000000000</span>; <span class="number">33.000000000</span>]]</span><br><span class="line">d = [[ <span class="number">11.000000000</span>; <span class="number">22.000000000</span>; <span class="number">33.000000000</span>]]</span><br></pre></td></tr></table></figure><p>daScript не позволяет каст к дочерним типам <code>explicit</code>-аргументов.</p><p>Вместо перегрузки <code>finalize</code> можно перегрузить <code>def operator delete(var v : V2 explicit)</code> — семантически более точно описывает, что для структур код финализатора будет вызван только в момент явного вызова оператора <code>delete</code>.</p><h2 id="Методы"><a href="#Методы" class="headerlink" title="Методы"></a>Методы</h2><p>Методы не могут быть объявлены при объявлении структур, но структуры могут хранить указатели на функции</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">V2</span></span></span><br><span class="line"><span class="class">    <span class="title">x</span> :</span> <span class="keyword">float</span></span><br><span class="line">    y : <span class="keyword">float</span></span><br><span class="line">    <span class="built_in">set</span> = @@<span class="built_in">set</span></span><br><span class="line"></span><br><span class="line">var a = V2()</span><br><span class="line">a |&gt; <span class="built_in">set</span>(<span class="number">1.0f</span>, <span class="number">2.0f</span>) <span class="comment">//call function via pipe syntax</span></span><br><span class="line">invoke(a.<span class="built_in">set</span>, a, <span class="number">1.0f</span>, <span class="number">2.0f</span>)  <span class="comment">// exactly same thing as above</span></span><br><span class="line">a-&gt;<span class="built_in">set</span>(<span class="number">1.0f</span>, <span class="number">2.0f</span>)  <span class="comment">// this one can call something else, if overridden in derived class.</span></span><br></pre></td></tr></table></figure><p>Потомок может переопределить функцию</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">V2</span></span></span><br><span class="line"><span class="class">    <span class="title">x</span> :</span> <span class="keyword">float</span></span><br><span class="line">    y : <span class="keyword">float</span></span><br><span class="line">    <span class="built_in">set</span> = @@<span class="built_in">set</span></span><br><span class="line">struct V3: V2</span><br><span class="line">    z : <span class="keyword">float</span></span><br><span class="line">    <span class="keyword">override</span> <span class="built_in">set</span> = cast&lt;<span class="keyword">auto</span>&gt; @@set_v3</span><br><span class="line">    </span><br><span class="line">def <span class="built_in">set</span>(var thisV: V2; X, Y: <span class="keyword">float</span>)</span><br><span class="line">    with thisV</span><br><span class="line">        x = X</span><br><span class="line">        y = Y</span><br><span class="line"></span><br><span class="line">def set_v3(var thisV: V3; X, Y: <span class="keyword">float</span>)</span><br><span class="line">    <span class="built_in">set</span>(cast&lt;V2&gt; thisV, X, Y)</span><br><span class="line">    with thisV</span><br><span class="line">        z = <span class="number">3.0f</span></span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main</span><br><span class="line">    var a = V3()</span><br><span class="line">    a |&gt; set_v3(<span class="number">1.0f</span>, <span class="number">2.0f</span>) <span class="comment">//non virtual call</span></span><br><span class="line">    invoke(a.<span class="built_in">set</span>, a, <span class="number">1.0f</span>, <span class="number">2.0f</span>)  <span class="comment">// exactly same thing as above</span></span><br><span class="line">    a-&gt;<span class="built_in">set</span>(<span class="number">1.0f</span>, <span class="number">2.0f</span>)  <span class="comment">// this one can call something else, if overridden in derived class.</span></span><br></pre></td></tr></table></figure><p>(<a href="https://github.com/GaijinEntertainment/daScript/blob/master/examples/test/unit_tests/override.das" target="_blank" rel="noopener">https://github.com/GaijinEntertainment/daScript/blob/master/examples/test/unit_tests/override.das</a>)</p><p>daScript позволяет создать две перегрузки функции set (а не определять дополнительное имя <code>set_v3</code>), принимающие V2 и V3, тогда можно переписать пример без использования дополнительного имени, с уточнением типа функции set перед кастом и последующим автоматическим приведением этого указателя к правильному типу, определённому в V2:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">V2</span></span></span><br><span class="line"><span class="class">    <span class="title">x</span> :</span> <span class="keyword">float</span></span><br><span class="line">    y : <span class="keyword">float</span></span><br><span class="line">    <span class="built_in">set</span> = @@&lt;(var thisV: V2; X, Y: <span class="keyword">float</span>):<span class="keyword">void</span>&gt; <span class="built_in">set</span></span><br><span class="line">struct V3: V2</span><br><span class="line">    z : <span class="keyword">float</span></span><br><span class="line">    <span class="keyword">override</span> <span class="built_in">set</span> = cast&lt;<span class="keyword">auto</span>&gt; @@&lt;(var thisV: V3; X, Y: <span class="keyword">float</span>):<span class="keyword">void</span>&gt; <span class="built_in">set</span> <span class="comment">//&lt;------ cast</span></span><br><span class="line">    </span><br><span class="line">def <span class="built_in">set</span>(var thisV: V2 <span class="keyword">explicit</span>; X, Y: <span class="keyword">float</span>)</span><br><span class="line">    with thisV</span><br><span class="line">        x = X</span><br><span class="line">        y = Y</span><br><span class="line"></span><br><span class="line">def <span class="built_in">set</span>(var thisV: V3; X, Y: <span class="keyword">float</span>)</span><br><span class="line">    <span class="built_in">set</span>(cast&lt;V2&gt; thisV, X, Y)</span><br><span class="line">    with thisV</span><br><span class="line">        z = <span class="number">3.0f</span></span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main</span><br><span class="line">    var a = V3()</span><br><span class="line">    a |&gt; <span class="built_in">set</span>(<span class="number">1.0f</span>, <span class="number">2.0f</span>) <span class="comment">//virtual call</span></span><br><span class="line">    invoke(a.<span class="built_in">set</span>, a, <span class="number">1.0f</span>, <span class="number">2.0f</span>)  <span class="comment">// exactly same thing as above</span></span><br><span class="line">    a-&gt;<span class="built_in">set</span>(<span class="number">1.0f</span>, <span class="number">2.0f</span>)</span><br><span class="line">    print(<span class="string">"&#123;a&#125;\n"</span>)</span><br></pre></td></tr></table></figure><p>Здесь <code>explicit</code> в первом объявлении свободной функции <code>set</code> позволяет сделать некоторую магию — несмотря на то, что эта функция “пропускает” только указатели на V2, это позволяет однозначно выделить эту функцию в приведении <code>set = @@&lt;(var thisV: V2; X, Y: float):void&gt; set</code> среди двух прегруженных (иначе возникла бы неоднозначность — обе приводились бы с одинаковым приоритетом, и daScript выдавал бы ошибку). Но при этом сигнатура функции <code>V2&#39;set</code> уже не содержит этого <code>explicit</code> (её тип выводится автоматически по правой части выражения, где явно указана сигнатура без <code>explicit</code>). Таким образом <code>V2&#39;set</code> работает как виртуальная функция — может принимать первым аргументом как <code>V2</code>, так и её потомков, которые не переопределили функцию.</p><h1 id="Классы"><a href="#Классы" class="headerlink" title="Классы"></a>Классы</h1><p><a href="https://dascript.org/doc/reference/language/classes.html#classes" target="_blank" rel="noopener">https://dascript.org/doc/reference/language/classes.html#classes</a></p><p>Классы в daScript — это структуры “на стероидах”. Немного отличий:</p><ul><li>Класс может быть отнаследован от структуры, но структура не может быть унаследована от класса (связано с тем, что классы могут иметь инициализаторы)</li><li>Объявление локального класса на стеке небезопасно (требует явного unsafe)</li></ul><p>Методы <a href="https://dascript.org/doc/reference/language/structs.html#structure-function-members" target="_blank" rel="noopener">реализованы</a> как указатели на функции, но с возможностью объявлять их в теле класса и переопределять с помощью ключевого слова <code>override</code> без явного каста типа метода, как было со структурами</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">V2</span></span></span><br><span class="line"><span class="class">    <span class="title">x</span> :</span> <span class="keyword">float</span></span><br><span class="line">    y : <span class="keyword">float</span></span><br><span class="line">    <span class="function">def <span class="title">set</span><span class="params">(X, Y: <span class="keyword">float</span>)</span></span></span><br><span class="line"><span class="function">        x </span>= X</span><br><span class="line">        y = Y</span><br><span class="line">class V3: V2</span><br><span class="line">    z : <span class="keyword">float</span></span><br><span class="line">    def <span class="keyword">override</span> <span class="built_in">set</span>(X, Y: <span class="keyword">float</span>)</span><br><span class="line">        V2`<span class="built_in">set</span>(self, X, Y)</span><br><span class="line">        z = <span class="number">3.0f</span></span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main</span><br><span class="line">    var a = <span class="keyword">new</span> V3()</span><br><span class="line">    a-&gt;<span class="built_in">set</span>(<span class="number">1.0f</span>, <span class="number">2.0f</span>) <span class="comment">//V3`set(*a, 1.0f, 2.0f)</span></span><br><span class="line">    print(<span class="string">"a = &#123;a&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Output</span></span><br><span class="line">a = [[ <span class="number">0x29990d19b90</span>; V3<span class="number">'</span>__finalize<span class="comment">/*V3'__finalize S&lt;::V3&gt;*/</span>; <span class="number">1.000000000</span>; <span class="number">2.000000000</span>; V3`<span class="built_in">set</span><span class="comment">/*V3`set S&lt;::V3&gt; Cf Cf*/</span>; <span class="number">3.000000000</span>]]</span><br></pre></td></tr></table></figure><p>Можно заметить, что имя объявленной внутри класса-функции манглится с помощью префикса-имени класса (<code>set -&gt; V2&#39;set</code>). Также внутри метода доступен указатель <code>self</code>, неявно передаваемый первым аргументов в методы класса.</p><p>Стоит более детально рассмотреть вывод результата.</p><h2 id="Порядок-полей-объекта-в-памяти"><a href="#Порядок-полей-объекта-в-памяти" class="headerlink" title="Порядок полей объекта в памяти"></a>Порядок полей объекта в памяти</h2><p><a href="https://dascript.org/doc/reference/language/classes.html#implementation-details" target="_blank" rel="noopener">https://dascript.org/doc/reference/language/classes.html#implementation-details</a></p><p>Содержимое <code>a</code>:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; [[</span><br><span class="line">    0x29990d19b90; &#x2F;&#x2F;указатель на rtti информацию</span><br><span class="line">    V3&#39;__finalize&#x2F;*V3&#39;__finalize S&lt;::V3&gt;*&#x2F;;  &#x2F;&#x2F;указатель на функцию-финализатор</span><br><span class="line">    1.000000000; &#x2F;&#x2F;x</span><br><span class="line">    2.000000000; &#x2F;&#x2F;y</span><br><span class="line">    V3&#96;set&#x2F;*V3&#96;set S&lt;::V3&gt; Cf Cf*&#x2F;; &#x2F;&#x2F;указатель на виртуальную функцию set</span><br><span class="line">    3.000000000 &#x2F;&#x2F;z</span><br><span class="line">]]</span><br></pre></td></tr></table></figure></p><p>Комментарии после имён функций — замангленное имя функции и её сигнатуры (аргументы и результаты). </p><blockquote><p>Расположение в памяти серьёзно отличается от C++ — указатели на виртуальные функции хранятся не в отдельной таблице (vtable), а в каждом объекте класса в том порядке, в котором были объявлены функции. Это позволяет убрать один уровень индирекции при вызове функций (не нужно идти за адресом в виртуальную таблицу) и изменять адреса функций динамически для каждого отдельного объекта, но увеличивает расходы памяти на хранение указателей, и также может повлиять на выравнивание и padding между полями.</p></blockquote><p>Тем не менее, для модификации порядка данных структур возможно написать собственный макрос, который будет хранить функции в самостоятельно сгенерированной таблице или выносить указатели на функции в конец структуры.<br><a href="/blog/1547564887/" title="daScript macro">daScript macro</a> — пример макроса перестановки порядка полей при определении структур</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">    unsafe</span><br><span class="line">        print(</span><br><span class="line"><span class="string">"\nsizeof(a) = &#123;typeinfo(sizeof type&lt;V3&gt;)&#125;\n</span></span><br><span class="line"><span class="string">offset __rtti      = &#123;typeinfo(offsetof&lt;__rtti&gt; type&lt;V3&gt;)&#125; &#123;reinterpret&lt;uint&gt;  addr(a.__rtti)&#125; </span></span><br><span class="line"><span class="string">offset __finalize  = &#123;typeinfo(offsetof&lt;__finalize &gt; type&lt;V3&gt;)&#125; &#123;reinterpret&lt;uint&gt;  addr(a.__finalize )&#125; </span></span><br><span class="line"><span class="string">offset x           = &#123;typeinfo(offsetof&lt;x&gt; type&lt;V3&gt;)&#125; &#123;reinterpret&lt;uint&gt;  addr(a.x)&#125;</span></span><br><span class="line"><span class="string">offset y           = &#123;typeinfo(offsetof&lt;y&gt; type&lt;V3&gt;)&#125; &#123;reinterpret&lt;uint&gt; addr(a.y)&#125;</span></span><br><span class="line"><span class="string">offset set         = &#123;typeinfo(offsetof&lt;set&gt; type&lt;V3&gt;)&#125; &#123;reinterpret&lt;uint&gt; addr(a.set)&#125;</span></span><br><span class="line"><span class="string">offset z           = &#123;typeinfo(offsetof&lt;z&gt; type&lt;V3&gt;)&#125; &#123;reinterpret&lt;uint&gt; addr(a.z)&#125;\n"</span></span><br><span class="line">        )</span><br><span class="line">Output:</span><br><span class="line"><span class="keyword">sizeof</span>(a) = <span class="number">40</span></span><br><span class="line">offset __rtti      = <span class="number">0</span>  <span class="number">0x4adb5f80</span></span><br><span class="line">offset __finalize  = <span class="number">8</span>  <span class="number">0x4adb5f88</span></span><br><span class="line">offset x           = <span class="number">16</span> <span class="number">0x4adb5f90</span></span><br><span class="line">offset y           = <span class="number">20</span> <span class="number">0x4adb5f94</span></span><br><span class="line">offset set1        = <span class="number">24</span> <span class="number">0x4adb5f98</span></span><br><span class="line">offset z           = <span class="number">32</span> <span class="number">0x4adb5fa0</span></span><br></pre></td></tr></table></figure><p>Существует также макрос <code>[cpp_layout]</code>, который не меняет порядок членов класса/структуры, но добавляет дополнительное правило выравнивания, как делают С/C++ — в конце родительской структуры будет оставлено пространство для её выравнивания по максимальному выравниванию членов структуры — например, если добавить в конце V2 поле на 4 байта <code>padding: uint8[4]</code>, то из-за выравнивания структуры в 8 байт (из-за указателей на 64-битной платформе), поле z, будет добавлено с отступом в 8 байт (без макроса daScript без проблем “встраивает” это поле сразу за 4-байтным отступом).</p><h2 id="Переопределение-метода-в-экземпляре-класса"><a href="#Переопределение-метода-в-экземпляре-класса" class="headerlink" title="Переопределение метода в экземпляре класса"></a>Переопределение метода в экземпляре класса</h2><p>Как было замеченно выше, каждый экземпляр класса/структуры хранит собственные копии указателей на функции, так что можно переопределить метод не на уровне класса-потомка, а в экземпляре класса (в пост-инициализаторе, или в любой момент после создания):<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">V2</span></span></span><br><span class="line"><span class="class">    <span class="title">x</span> :</span> <span class="keyword">float</span></span><br><span class="line">    y : <span class="keyword">float</span></span><br><span class="line">    <span class="function">def <span class="title">set</span><span class="params">(X, Y: <span class="keyword">float</span>)</span></span></span><br><span class="line"><span class="function">        x </span>= X</span><br><span class="line">        y = Y</span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main</span><br><span class="line">    let fn &lt;- @@ &lt;| ( a : <span class="keyword">int</span> )</span><br><span class="line">        <span class="keyword">return</span> a </span><br><span class="line"></span><br><span class="line">    unsafe</span><br><span class="line">        <span class="comment">//inplace init syntax</span></span><br><span class="line">        var v_customset = [[ V2() </span><br><span class="line">            <span class="built_in">set</span> &lt;- @@ (var self : V2; X,Y : <span class="keyword">float</span>) &#123;</span><br><span class="line">                self.x = X * <span class="number">100.0f</span>;</span><br><span class="line">                self.y = Y * <span class="number">100.0f</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        ]]</span><br><span class="line">        v_customset-&gt;<span class="built_in">set</span>(<span class="number">1.0f</span>, <span class="number">2.0f</span>)</span><br><span class="line">        print(<span class="string">"&#123;v_customset.x&#125;, &#123;v_customset.y&#125;\n"</span>)</span><br><span class="line">        <span class="comment">//Output: 100.000000000, 200.000000000</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//reset after construction, pipe + block syntax</span></span><br><span class="line">        v_customset.<span class="built_in">set</span> = @@ &lt;| (var self : V2; X,Y : <span class="keyword">float</span>)</span><br><span class="line">            self.x = X * <span class="number">200.0f</span></span><br><span class="line">            self.y = Y * <span class="number">200.0f</span></span><br><span class="line">        print(<span class="string">"&#123;v_customset.x&#125;, &#123;v_customset.y&#125;\n"</span>)</span><br><span class="line">        <span class="comment">//Output: 200.000000000, 400.000000000</span></span><br></pre></td></tr></table></figure><br><em>(более практичное применение этого — паттерны типа event/callback)</em></p><h2 id="RTTI"><a href="#RTTI" class="headerlink" title="RTTI"></a>RTTI</h2><p><a href="https://github.com/GaijinEntertainment/daScript/blob/f050f7f9a4aaaac75e454834663389c9d8ebd343/examples/test/unit_tests/reflection.das#L110" target="_blank" rel="noopener">https://github.com/GaijinEntertainment/daScript/blob/f050f7f9a4aaaac75e454834663389c9d8ebd343/examples/test/unit_tests/reflection.das#L110</a></p><p>Пример вывода на экран информации о типе в runtime:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">require rtti</span><br><span class="line">...</span><br><span class="line">var a = <span class="keyword">new</span> V3()</span><br><span class="line">print(<span class="string">"class_info(a): &#123;class_info(a)&#125;\n"</span>) </span><br><span class="line">describeStructure(*class_info(a))</span><br><span class="line"><span class="comment">//Output:</span></span><br><span class="line"><span class="comment">//https://dascript.org/doc/stdlib/rtti.html?highlight=rtti#StructInfo</span></span><br><span class="line">class_info(a): [[ <span class="number">0x6</span>; V3; ; (_class|heapGC); <span class="number">0x28</span>; <span class="number">0x93b8d07b5cc8cee</span>; <span class="number">0xcf51414d2d20b41e</span>]]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">V3</span></span></span><br><span class="line"><span class="class">    __<span class="title">rtti</span> :</span> <span class="keyword">void</span>?</span><br><span class="line">    __finalize : function&lt;(V2):<span class="keyword">void</span>&gt;</span><br><span class="line">    x : <span class="keyword">float</span></span><br><span class="line">    y : <span class="keyword">float</span></span><br><span class="line">    set1 : function&lt;(V2;<span class="keyword">float</span> <span class="keyword">const</span>;<span class="keyword">float</span> <span class="keyword">const</span>):<span class="keyword">void</span>&gt;</span><br><span class="line">    z : <span class="keyword">float</span></span><br></pre></td></tr></table></figure><p>Доступна информация о названиях и типах полей, а также мета-информация (<a href="https://dascript.org/doc/stdlib/rtti.html?highlight=rtti#alias-structinfoflags" target="_blank" rel="noopener">флаги</a> класс/структура, выделена на стеке/хипе, аннотации и т.п.).</p><p>Для того, чтобы передать и распознать аннотации, необходимо включить опцию <code>options rtti=true</code> (в противном случае, метаинформация о произвольных аннотациях выбрасывается после симуляции, <a href="https://github.com/GaijinEntertainment/daScript/wiki/options" target="_blank" rel="noopener">линк</a>). Пример:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">options rtti=<span class="literal">true</span></span><br><span class="line">...</span><br><span class="line">class V3: V2</span><br><span class="line">    [[test]] z : <span class="keyword">float</span></span><br><span class="line">...</span><br><span class="line">def describeStructure(sinfo)</span><br><span class="line">    var anyAnn = <span class="literal">false</span></span><br><span class="line">    structure_for_each_annotation(sinfo) &lt;| $(ann; annArgs)</span><br><span class="line">        let argT = join([&#123;<span class="keyword">for</span> arg in annArgs; <span class="string">"&#123;arg.name&#125;&#123;describeValue(get_annotation_argument_value(arg))&#125;"</span>&#125;],<span class="string">","</span>)</span><br><span class="line">        print(<span class="string">"[&#123;ann.name&#125;(&#123;argT&#125;)]\n"</span>)</span><br><span class="line">    print(<span class="string">"struct &#123;sinfo.name&#125;\n"</span>)</span><br><span class="line">    <span class="keyword">for</span> sfield in sinfo</span><br><span class="line">        <span class="keyword">if</span> sfield.annotation_arguments != null</span><br><span class="line">            <span class="keyword">for</span> arg in deref(sfield.annotation_arguments)</span><br><span class="line">                print(<span class="string">"\t[[&#123;arg.name&#125;]] "</span>)</span><br><span class="line">        describeVariable(sfield,<span class="string">"\t"</span>)</span><br><span class="line">...</span><br><span class="line">var a = <span class="keyword">new</span> V3()</span><br><span class="line">print(<span class="string">"class_info(a): &#123;class_info(a)&#125;\n"</span>)</span><br><span class="line">describeStructure(*class_info(a))</span><br><span class="line"></span><br><span class="line"><span class="comment">//Output:</span></span><br><span class="line">struct V3</span><br><span class="line">    __rtti : <span class="keyword">void</span>?</span><br><span class="line">    __finalize : function&lt;(V2):<span class="keyword">void</span>&gt;</span><br><span class="line">    x : <span class="keyword">float</span></span><br><span class="line">    y : <span class="keyword">float</span></span><br><span class="line">    set1 : function&lt;(V2;<span class="keyword">float</span> <span class="keyword">const</span>;<span class="keyword">float</span> <span class="keyword">const</span>):<span class="keyword">void</span>&gt;</span><br><span class="line">    [[test]] z : <span class="keyword">float</span> <span class="comment">//&lt;-- аннотация test</span></span><br></pre></td></tr></table></figure><p><a href="https://gist.github.com/spiiin/961974938919cc9233bacf0bb5c71cd1" target="_blank" rel="noopener">Полный пример</a></p><h2 id="Abstract-и-sealed-методы"><a href="#Abstract-и-sealed-методы" class="headerlink" title="Abstract и sealed-методы"></a>Abstract и sealed-методы</h2><p>Методы можно сделать абстрактыми, или закрытыми для переопределения</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">    <span class="title">def</span> <span class="title">abstract</span> <span class="title">setX</span>(<span class="title">X</span>:</span> <span class="keyword">int</span>): <span class="keyword">void</span> <span class="comment">//необходимо явно определить сигнатуру метода -- тип аргументов и результата</span></span><br><span class="line">    <span class="function">def sealed <span class="title">setY</span><span class="params">(Y: <span class="keyword">int</span>)</span>         <span class="comment">//метод нельзя переопределить в потомках</span></span></span><br><span class="line"><span class="function">        pass</span></span><br></pre></td></tr></table></figure><h2 id="Видимость"><a href="#Видимость" class="headerlink" title="Видимость"></a>Видимость</h2><ul><li>Из модуля экспортируются функции с аннотацией [export]</li></ul><p><code>options always_export_initializer=true</code> позволяет проставить аннотацию для всех инициализаторов на уровне модуля</p><ul><li><code>private</code> для переменных и типов ограничивает их доступность из других модулей</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//module1.das</span></span><br><span class="line"><span class="keyword">module</span> module1</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">private</span> <span class="title">V1</span></span></span><br><span class="line"><span class="class">    <span class="title">w</span> :</span> <span class="keyword">float</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">private</span> <span class="title">V2</span></span></span><br><span class="line"><span class="class">    <span class="title">x</span> :</span> <span class="keyword">float</span></span><br><span class="line">    y : <span class="keyword">float</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">public</span> <span class="title">V3</span>:</span> V2</span><br><span class="line">    v1 : V1</span><br><span class="line">    z : <span class="keyword">float</span> = <span class="number">3.0</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">//main.das</span></span><br><span class="line">require module1</span><br><span class="line"><span class="comment">//можно звать инициализацию полей, и пост-инициализацию для V3 (также открываются поля V2), но нельзя инициализировать явно поле приватного класса V1</span></span><br><span class="line">var a = <span class="keyword">new</span> [[V3() x=<span class="number">1.0f</span>, y=<span class="number">2.0f</span>, z=<span class="number">3.0f</span>]]</span><br></pre></td></tr></table></figure><p>Приватными могут быть также поля и функции структур/классов</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">    <span class="title">private</span> <span class="title">a</span> :</span> <span class="keyword">int</span></span><br><span class="line">    <span class="function">def <span class="keyword">private</span> <span class="title">set_a</span><span class="params">(val:<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">        a </span>= val</span><br><span class="line">    def get_a</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    def MyClass()</span><br><span class="line">        self-&gt;set_a(<span class="number">42</span>)</span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main</span><br><span class="line">    var f = <span class="keyword">new</span> MyClass()</span><br><span class="line">    print(<span class="string">"f.a = &#123;f-&gt;get_a()&#125;\n"</span>)</span><br></pre></td></tr></table></figure><h2 id="Инициализаторы"><a href="#Инициализаторы" class="headerlink" title="Инициализаторы"></a>Инициализаторы</h2><p>Инициализатор для класса — это функция, у которой имя совпадает с именем класса. Так как классы — надстройки над структурами, и все варианты синтаксиса иницилизации действуют и для них, то нет никакой гарантии того, что инициализатор класса будет вызван.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">    <span class="title">i</span> :</span> <span class="keyword">float</span></span><br><span class="line">    <span class="function">def <span class="title">Test</span><span class="params">(I : <span class="keyword">float</span>)</span></span></span><br><span class="line"><span class="function">        i </span>= I</span><br><span class="line"></span><br><span class="line">def main</span><br><span class="line">    var a &lt;- <span class="keyword">new</span> Test(<span class="number">33.0f</span>)         <span class="comment">//initializer called</span></span><br><span class="line">    var b &lt;- <span class="keyword">new</span> Test()              <span class="comment">//initializer dont called</span></span><br><span class="line">    var c &lt;- <span class="keyword">new</span> [[Test() i = <span class="number">2.0f</span>]] <span class="comment">//initializer dont called</span></span><br></pre></td></tr></table></figure><h2 id="Интерфейсы"><a href="#Интерфейсы" class="headerlink" title="Интерфейсы"></a>Интерфейсы</h2><p><a href="https://github.com/GaijinEntertainment/daScript/blob/eaecd72d6d44b46f5566dc4a0ce3956d5488672c/daslib/interfaces.das" target="_blank" rel="noopener">https://github.com/GaijinEntertainment/daScript/blob/eaecd72d6d44b46f5566dc4a0ce3956d5488672c/daslib/interfaces.das</a></p><p>Библиотека <code>interfaces</code> с помощью пары макросов позволяет реализовать паттерн интерфейса — классы, который содержит только абстрактные методы. Макрос <code>implements</code> позволяет изобразить множественное наследование от интерфейсов.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[interface]</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ITick</span></span></span><br><span class="line"><span class="class">    <span class="title">def</span> <span class="title">abstract</span> <span class="title">tick</span> (<span class="title">dt</span>:</span><span class="keyword">float</span>) : <span class="keyword">void</span></span><br><span class="line"></span><br><span class="line">[interface]</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ILogger</span></span></span><br><span class="line"><span class="class">    <span class="title">def</span> <span class="title">abstract</span> <span class="title">log</span> (<span class="title">message</span> :</span> <span class="built_in">string</span>) : <span class="keyword">void</span></span><br><span class="line"></span><br><span class="line">[implements(ITick), implements(ILogger)]</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">    ...</span></span><br></pre></td></tr></table></figure><h1 id="Связь-с-C-типами"><a href="#Связь-с-C-типами" class="headerlink" title="Связь с C++ типами"></a>Связь с C++ типами</h1><p><a href="https://github.com/GaijinEntertainment/daScript/blob/master/examples/tutorial/tutorial03.cpp#L15" target="_blank" rel="noopener">https://github.com/GaijinEntertainment/daScript/blob/master/examples/tutorial/tutorial03.cpp#L15</a><br>Базовый пример прокидывания C++ класса в daScript. Похоже на другие скриптовые языки, создаётся класс-обёртка (<code>ManagedStructureAnnotation</code>) над типом, которая позволяет привязать и настроить отображение полей и методов структуры на тип в daScript, а также переопределить группу методов, определяющих свойства этого типа в daScript.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Color</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> r, g, b, a;</span><br><span class="line">&#125;;</span><br><span class="line">MAKE_TYPE_FACTORY(Color, Color);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ColorAnnotation</span> :</span> <span class="keyword">public</span> ManagedStructureAnnotation&lt;Color,<span class="literal">true</span>,<span class="literal">true</span>&gt; &#123;</span><br><span class="line">    ColorAnnotation(ModuleLibrary &amp; ml) : ManagedStructureAnnotation (<span class="string">"Color"</span>, ml) &#123;</span><br><span class="line">        <span class="comment">//type fields</span></span><br><span class="line">        addField&lt;DAS_BIND_MANAGED_FIELD(r)&gt;(<span class="string">"r"</span>);</span><br><span class="line">        addField&lt;DAS_BIND_MANAGED_FIELD(g)&gt;(<span class="string">"g"</span>);</span><br><span class="line">        addField&lt;DAS_BIND_MANAGED_FIELD(b)&gt;(<span class="string">"b"</span>);</span><br><span class="line">        addField&lt;DAS_BIND_MANAGED_FIELD(a)&gt;(<span class="string">"a"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//type behaviour</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">isLocal</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">canCopy</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125; </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">canMove</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Module_Tutorial03</span> :</span> <span class="keyword">public</span> Module &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Module_Tutorial03() : Module(<span class="string">"tutorial_03"</span>) &#123;</span><br><span class="line">        ModuleLibrary lib;</span><br><span class="line">        lib.addModule(<span class="keyword">this</span>);</span><br><span class="line">        addAnnotation(make_smart&lt;ColorAnnotation&gt;(lib));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">REGISTER_MODULE(Module_Tutorial03);</span><br></pre></td></tr></table></figure><p>Более продвинутые <a href="https://github.com/GaijinEntertainment/daScript/blob/master/examples/test/test_handles.cpp" target="_blank" rel="noopener">примеры</a>, также можно смотреть код <a href="https://github.com/GaijinEntertainment/daScript/tree/master/modules" target="_blank" rel="noopener">модулей</a>.</p><h2 id="Наследование"><a href="#Наследование" class="headerlink" title="Наследование"></a>Наследование</h2><p>Отнаследоваться от C++ типа нельзя (<em>ну, или я не нашёл способа сделать такой тип</em>).</p><p>Существует возможность передать в daScript связь родитель-потомок между C++-типами (<a href="https://github.com/borisbat/dasSFML/blob/4501a9167692180d138da4a487a42375a377db68/src/dasSFML.struct.add.inc#L134" target="_blank" rel="noopener">пример</a>), для upcast-приведения типов аргументов функций.</p><p>Пример организации связи между С++ и daScript-классами - <a href="https://github.com/GaijinEntertainment/daScript/blob/master/examples/tutorial/tutorial04.cpp#L45" target="_blank" rel="noopener">tutorial04</a>.</p><img style="background-color:white;" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjk3IiBoZWlnaHQ9IjE5OSIgdmVyc2lvbj0iMS4xIiBiYXNlUHJvZmlsZT0iZnVsbCIgdmlld2JveD0iMCAwIDY5NyAxOTkiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHhtbG5zOmV2PSJodHRwOi8vd3d3LnczLm9yZy8yMDAxL3htbC1ldmVudHMiIHN0eWxlPSJmb250LXdlaWdodDpib2xkOyBmb250LXNpemU6MTJwdDsgZm9udC1mYW1pbHk6J0NhbGlicmknLCBIZWx2ZXRpY2EsIHNhbnMtc2VyaWY7O3N0cm9rZS13aWR0aDozO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbGluZWNhcDpyb3VuZCI+PHBhdGggZD0iTTE4NC4xIDQ0LjUgTDExMiA2NC41IEwxMTIgODQuNSBMMTEyIDg0LjUgIiBzdHlsZT0ic3Ryb2tlOiMzMzMyMkU7ZmlsbDpub25lO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTsiPjwvcGF0aD4KPHBhdGggZD0iTTEwNi43IDcxLjIgTDExMiA3Ny44IEwxMTcuMyA3MS4yIEwxMTIgODQuNSBaIiBzdHlsZT0ic3Ryb2tlOiMzMzMyMkU7ZmlsbDojMzMzMjJFO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTsiPjwvcGF0aD4KPHBhdGggZD0iTTI5NS45IDQ0LjUgTDM2OCA2NC41IEwzNjggODQuNSBMMzY4IDg0LjUgIiBzdHlsZT0ic3Ryb2tlOiMzMzMyMkU7ZmlsbDpub25lO3N0cm9rZS1kYXNoYXJyYXk6NiA2OyI+PC9wYXRoPgo8cGF0aCBkPSJNMzYyLjcgNzEuMiBMMzY4IDc3LjggTDM3My4zIDcxLjIgTDM2OCA4NC41IFoiIHN0eWxlPSJzdHJva2U6IzMzMzIyRTtmaWxsOiMzMzMyMkU7c3Ryb2tlLWRhc2hhcnJheTpub25lOyI+PC9wYXRoPgo8cGF0aCBkPSJNNjA1IDExNS41IEw2MDUgMTM1LjUgTDUzOC4yIDE1NS41IEw1MzguMiAxNTUuNSAiIHN0eWxlPSJzdHJva2U6IzMzMzIyRTtmaWxsOm5vbmU7c3Ryb2tlLWRhc2hhcnJheTpub25lOyI+PC9wYXRoPgo8cGF0aCBkPSJNNTQ5LjUgMTQ2LjYgTDU0NC42IDE1My42IEw1NTIuNSAxNTYuOCBMNTM4LjIgMTU1LjUgWiIgc3R5bGU9InN0cm9rZTojMzMzMjJFO2ZpbGw6IzMzMzIyRTtzdHJva2UtZGFzaGFycmF5Om5vbmU7Ij48L3BhdGg+CjxwYXRoIGQ9Ik0zNjggMTE1LjUgTDM2OCAxMzUuNSBMNDM0LjggMTU1LjUgTDQzNC44IDE1NS41ICIgc3R5bGU9InN0cm9rZTojMzMzMjJFO2ZpbGw6bm9uZTtzdHJva2UtZGFzaGFycmF5Om5vbmU7Ij48L3BhdGg+CjxwYXRoIGQ9Ik00MjAuNSAxNTYuOCBMNDI4LjQgMTUzLjYgTDQyMy41IDE0Ni42IEw0MzQuOCAxNTUuNSBaIiBzdHlsZT0ic3Ryb2tlOiMzMzMyMkU7ZmlsbDojMzMzMjJFO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTsiPjwvcGF0aD4KPHJlY3QgeD0iMTIyLjUiIHk9IjEzLjUiIGhlaWdodD0iMzEiIHdpZHRoPSIyMzUiIHN0eWxlPSJzdHJva2U6IzMzMzIyRTtmaWxsOnBpbms7c3Ryb2tlLWRhc2hhcnJheTpub25lOyI+PC9yZWN0Pgo8dGV4dCB4PSIxMzAuOCIgeT0iMzUiIHN0eWxlPSIiPlR1dG9yaWFsQmFzZUNsYXNzIChkYXMpPC90ZXh0Pgo8cmVjdCB4PSIxMy41IiB5PSI4NC41IiBoZWlnaHQ9IjMxIiB3aWR0aD0iMTk3IiBzdHlsZT0ic3Ryb2tlOiMzMzMyMkU7ZmlsbDpwaW5rO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTsiPjwvcmVjdD4KPHRleHQgeD0iMjEuOCIgeT0iMTA2IiBzdHlsZT0iIj5FeGFtcGxlT2JqZWN0IChkYXMpPC90ZXh0Pgo8cmVjdCB4PSIyNTAuNSIgeT0iODQuNSIgaGVpZ2h0PSIzMSIgd2lkdGg9IjIzNSIgc3R5bGU9InN0cm9rZTojMzMzMjJFO2ZpbGw6I2VlZThkNTtzdHJva2UtZGFzaGFycmF5Om5vbmU7Ij48L3JlY3Q+Cjx0ZXh0IHg9IjI1OC44IiB5PSIxMDYiIHN0eWxlPSIiPlR1dG9yaWFsQmFzZUNsYXNzIChjcHApPC90ZXh0Pgo8cmVjdCB4PSI1MjUuNSIgeT0iODQuNSIgaGVpZ2h0PSIzMSIgd2lkdGg9IjE1OSIgc3R5bGU9InN0cm9rZTojMzMzMjJFO2ZpbGw6I2VlZThkNTtzdHJva2UtZGFzaGFycmF5Om5vbmU7Ij48L3JlY3Q+Cjx0ZXh0IHg9IjUzMy44IiB5PSIxMDYiIHN0eWxlPSIiPkJhc2VDbGFzcyAoY3BwKTwvdGV4dD4KPHJlY3QgeD0iMzc0LjUiIHk9IjE1NS41IiBoZWlnaHQ9IjMxIiB3aWR0aD0iMjI1IiBzdHlsZT0ic3Ryb2tlOiMzMzMyMkU7ZmlsbDojZWVlOGQ1O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTsiPjwvcmVjdD4KPHRleHQgeD0iMzgyLjUiIHk9IjE3NyIgc3R5bGU9IiI+QmFzZUNsYXNzQWRhcHRlciAoY3BwKTwvdGV4dD48L3N2Zz4=" /><p>В примере связь организуется через класс <code>BaseClassAdapter</code>, который наследуется одновременно от базового C++-класса и сгенерированного по das-коду C++-классу-адаптеру</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">options remove_unused_symbols = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//interface C++/daScript</span></span><br><span class="line">class TutorialBaseClass</span><br><span class="line">    def abstract update ( dt : <span class="keyword">float</span> ) : <span class="keyword">void</span></span><br><span class="line">    def abstract get_position : float3</span><br><span class="line"></span><br><span class="line"><span class="comment">// uncomment the section to generate C++ bindings for the TutorialBaseClass</span></span><br><span class="line"><span class="comment">// this code will generate tutorial04_gen.inc which contains C++ bindings</span></span><br><span class="line"></span><br><span class="line">require fio</span><br><span class="line">require ast</span><br><span class="line">require daslib/cpp_bind</span><br><span class="line">[init]</span><br><span class="line">def generate_cpp_bindings</span><br><span class="line">    let root = get_das_root() + <span class="string">"/examples/tutorial/"</span></span><br><span class="line">    fopen(root + <span class="string">"tutorial04_gen.inc"</span>,<span class="string">"wb"</span>) &lt;| $ ( cpp_file )</span><br><span class="line">        <span class="comment">//generate c++ code from dascript rtti class information</span></span><br><span class="line">        log_cpp_class_adapter(cpp_file, <span class="string">"TutorialBaseClass"</span>, typeinfo(ast_typedecl type&lt;TutorialBaseClass&gt;))</span><br></pre></td></tr></table></figure><p><code>TutorialBaseClass</code> - интерфейс между C++/daScript, который используется генератором C++-обёрток <code>log_cpp_class_adapter</code>, на выходе получается примерно такой C++-код:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TutorialBaseClass</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">enum</span> &#123;</span><br><span class="line">    __fn_update = <span class="number">0</span>,</span><br><span class="line">    __fn_get_position = <span class="number">1</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> _das_class_method_offset[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  TutorialBaseClass ( <span class="keyword">const</span> StructInfo * info ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( _das_class_method_offset[<span class="number">0</span>]==<span class="number">0</span> ) &#123;</span><br><span class="line">      _das_class_method_offset[__fn_update] = adapt_field_offset(<span class="string">"update"</span>,info);</span><br><span class="line">      _das_class_method_offset[__fn_get_position] = adapt_field_offset(<span class="string">"get_position"</span>,info);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">static</span> __forceinline Func <span class="title">get_get_position</span> <span class="params">( <span class="keyword">void</span> * self )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getDasClassMethod(self,_das_class_method_offset[__fn_get_position]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> __forceinline float3 <span class="title">invoke_get_position</span> <span class="params">( Context * __context__, Func __funcCall__, <span class="keyword">void</span> * self )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> das_invoke_function&lt;float3&gt;::invoke</span><br><span class="line">      &lt;<span class="keyword">void</span> *&gt;</span><br><span class="line">        (__context__,<span class="literal">nullptr</span>,__funcCall__,</span><br><span class="line">          self);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> TutorialBaseClass::_das_class_method_offset[<span class="number">2</span>];</span><br></pre></td></tr></table></figure><p>Вызов:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseClassAdapter</span> :</span> <span class="keyword">public</span> BaseClass, <span class="keyword">public</span> TutorialBaseClass &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// in the constructor we store pointer to the original class and context</span></span><br><span class="line">    <span class="comment">// we also pass StructInfo of the daScript class to the generated class</span></span><br><span class="line">    BaseClassAdapter ( <span class="keyword">char</span> * pClass, <span class="keyword">const</span> StructInfo * info, Context * ctx )</span><br><span class="line">        : TutorialBaseClass(info), classPtr(pClass), context(ctx) &#123; &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> float3 <span class="title">getPosition</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// we check if daScript class has 'get_position'</span></span><br><span class="line">        <span class="keyword">if</span> ( <span class="keyword">auto</span> fn = get_get_position(classPtr) ) &#123;</span><br><span class="line">            <span class="comment">// we invoke it, and return it's result</span></span><br><span class="line">            <span class="keyword">return</span> invoke_get_position(context, fn, classPtr);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> float3(<span class="number">0.0f</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">void</span> *      classPtr;   <span class="comment">// stored pointer to the daScript class</span></span><br></pre></td></tr></table></figure></p><p>Класс не содержит особой магии, а просто хранит адреса daScript-функций и позволяет прозрачно для вызывающего C++-кода их вызывать и изменять.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;h1 id=&quot;Струк
      
    
    </summary>
    
    
    
      <category term="dascript" scheme="http://spiiin.github.io/tags/dascript/"/>
    
  </entry>
  
  <entry>
    <title>daScript -&gt; dasLang?</title>
    <link href="http://spiiin.github.io/blog/2975166623/"/>
    <id>http://spiiin.github.io/blog/2975166623/</id>
    <published>2023-01-01T20:44:11.000Z</published>
    <updated>2023-01-02T01:41:46.880Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Год назад в первых же заметках про <code>daScript</code>:<br><a href="/blog/1728194429/" title="С++ в геймдеве">С++ в геймдеве</a><br><a href="/blog/1547564887/" title="daScript macro">daScript macro</a><br>я отметил для себя такой парадокс - <strong><code>Гайдзины делают не замену Lua, они делают замену C++!</code></strong>, т.е. дизайн языка — это совсем не про скрипты, это generic язык, удобный, чтобы делать с его помощью игры.</p><a id="more"></a><p>Сам Борис, видимо, устал отвечать на вопросы новичков в стиле “это такая альтернатива lua?” и написал <a href="https://borisbat.github.io/dascf-blog/2022/12/31/its-not-a-script/" target="_blank" rel="noopener">заметку</a> про то, что название сильно сбивает с толку.</p><h2 id="Слои-языка"><a href="#Слои-языка" class="headerlink" title="Слои языка"></a>Слои языка</h2><p><strong><code>Разделение по уровню понимания языка</code></strong></p><p><code>daScript</code> — это айсберг, в котором новичкам видно его верхушку — скриптовый слой, на котором можно описывать логику и дёргать API движка, например, <a href="https://github.com/imp5imp5/dasbox/blob/main/doc/api.txt" target="_blank" rel="noopener">dasbox api</a>. Это первый слой — glue-язык, на котором можно писать семантически сжатый компактный код как на каком-нибудь python/lua/javascript.<br>Но при синтаксической похожести уже явно будут видны отличия:</p><ul><li>язык типизированный — при изучении приходится потратить некоторое время на то, чтобы научиться правильно работать с его типами. В этом он местами сложнее не только луа, но и на C, скорее похож на языки из ml-семейства. Это сделано by-design, ради того, чтобы компилятор ловил больше ошибок, и легче было рефакторить код.<br><em>Некоторые простые для lua паттерны мета-программирования, в котором rtti-информация о типе — это просто таблица, к которой можно получить доступ, необходимо переделывать с помощью магических макросов, что требует намного более глубокого понимания языка</em></li><li>язык позволяет работать на низком уровне — на котором можно делать практически то же, что и C. Местами про lifetime объектов нужно думать больше, а не меньше, чем в C++, и уж точно не на уровне “включил GC и выключил голову”.</li><li>язык быстрый — наивный код получается +/- таким же производительным, как и наивный С++, а gamedev-specific код (много работы с векторами/матрицами) — часто и сильно быстрее. Сам код возможно оптимизировать на самом daScript, без подхода “перепишем то, что тормозит на C”.</li><li>виртуальную машину языка можно рассматривать не как абстрактную машину, а как AoT-компилятор в C++, который используется как <a href="https://www.youtube.com/watch?v=8SoJR3sCaR4" target="_blank" rel="noopener">платформа</a>.</li></ul><p>Т.е. уже на этом уровне свойства языка существенно отличаются от того, что обычно понимают под скриптовым языком в геймдеве. Что представляет проблему, так как с позиции изучающего язык новичка “с высоты птичьего полёта” язык кажется не тем, чем он есть на самом деле.</p><p><img src="/blog/2975166623/iceberg_small.png" alt=""><br>При этом сам айсберг — это генерики и макросы, с помощью которых можно создавать edsl, изменять синтаксис: от добавления привычных для ООП вещей, которых нет в ядре языка, вроде <a href="https://raw.githubusercontent.com/GaijinEntertainment/daScript/master/daslib/interfaces.das" target="_blank" rel="noopener">интерфейсов</a>, или привычных для асинхронного программирования <a href="https://github.com/GaijinEntertainment/daScript/blob/138f625c7f95943341a5e96cca114ae7d0772ba6/daslib/coroutines.das" target="_blank" rel="noopener">корутин</a>, до dsl: языки-обёртки над <a href="https://github.com/GaijinEntertainment/daScript/blob/master/modules/dasOpenGL/glsl/glsl_opengl.das" target="_blank" rel="noopener">шейдерными языками</a>, и чёрной магии reader macro, позволяющей встраивать альтернативные синтаксисы вроде <a href="https://github.com/GaijinEntertainment/daScript/blob/master/daslib/regex_boost.das" target="_blank" rel="noopener">регулярных выражений</a>, а также модифицировать AST-языка.</p><p>Парсинг и модификация/генерация AST также упрощает создание инструментов для работы с кодом:</p><ul><li><a href="https://marketplace.visualstudio.com/items?itemName=profelis.dascript-plugin" target="_blank" rel="noopener">daScript language support for vs code</a> — отладчик, подсветка кода и вывод типов, помощь с выводом выражений</li><li><a href="https://borisbat.github.io/dascf-blog/2022/12/11/instruments/" target="_blank" rel="noopener">профайлер</a></li><li>генерация <a href="https://github.com/GaijinEntertainment/daScript/tree/master/modules/dasClangBind/bind" target="_blank" rel="noopener">привязок</a> к C/C++ библиотекам (можно смотреть, к примеру, <code>bind_opengl</code> — генерится daScript код, для других может генериться и c++-код привязки)</li><li><a href="https://github.com/GaijinEntertainment/daScript/blob/073bc29145207b39180069ae60f00ed43fad6ea7/examples/test/misc/ast_print.das" target="_blank" rel="noopener">описание выражений</a> в runtime</li><li><a href="https://github.com/GaijinEntertainment/daScript/blob/9e217204864177cf6886c7d8ecc86be1d47dbfca/daslib/lint.das" target="_blank" rel="noopener">линтеры</a></li><li>hot code reload — <a href="/blog/3006126295/" title="daScript - live-режим">daScript - live-режим</a><br>и многое другое.</li></ul><p>Такое разделения по испольуемым фичам похоже на то, чем отличается код приложения от кода библиотек на C++ — прикладной уровень требует знания только основ языка, тогда как написание библиотеки может требовать умений использовать наиболее мощные фичи.</p><p><strong><code>Разделение по архитектуре языка</code></strong></p><p>В заметке Борис выделяет такие уровни языка (явного название уровней у него нет, поэтому придумал я):</p><ul><li>Lowest level. Низкоуровневое ядро языка, на этом уровне язык можно представить себе как альтернативу C, с фичами вроде арифметики указателей, копирования областей памяти, pod-структур с возможностью настройки размещения в памяти.</li><li>Syntax-sugar level. Уровень синтаксического сахара, абстракции уровня языков Ruby или Python — блоки, замыкания, таблицы, классы, генераторы и итераторы. Чаще всего реализованы в виде библиотек на самом daScript.</li><li>Macro level. Фичи работы с AST языка, похожие на то, что можно делать в Lisp или Haxe — “bring your own language”, пишем код, который говорит компилятору, как именно интерпретировать другой код.</li></ul><p><img src="/blog/2975166623/onion_small.png" alt=""></p><p>Ни один из уровней не предназначен для решения проблем, которыми обычно занимаются скриптовые языки — <code>daScript</code> не для написания игровой логики, а для написания <em>всего</em> для игры, от логики, до движка — рендера, шейдеров и физики, и до тулзов - редактора игры, компилятора данных, сервера, скриптов сборки и прочей инфраструктуры вокруг, и соединения всего этого вместе.</p><h2 id="Проблема-названия"><a href="#Проблема-названия" class="headerlink" title="Проблема названия"></a>Проблема названия</h2><p>Вывод заметки — если <em>script</em> в названии не соответствует тому, что представляет собой язык, и только отвлекает от того, на что он потенциально способен (да и <em>da</em> - в названии, отсылка к названию движка Gaijin — <strong>Da</strong>gor Engine, язык начинался как попытка сделать замену предыдущим скриптовым языкам для движка, но уже может использовать и без него), то этого достаточно для того, чтобы переименовать язык во что-то типа <strong><code>dasLang</code></strong>, так как <strong>das</strong>-часть уже закрепилась в качестве расширения файлов для языка.</p><p>Как по мне — прикольный ход, новое название сохраняет узнаваемость для знакомых со старым, и перестаёт исправляться “умным” поиском на что-то другое и выдавать нерелевантные результаты, хотя и читается по немецки как “так долго”.</p><p>Побалуюсь немного на тему того, сокращением от чего могло бы быть это название, по аналогии, как <code>Nimrod</code>, сократилось до <a href="https://nim-lang.org/" target="_blank" rel="noopener">nim-lang</a> для nim. Случайные свойства и идеи языка, которые первыми пришли мне на ум после изучения <code>daScript</code>:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- скорость цикла разработки</span><br><span class="line">- выразительность</span><br><span class="line">- экономность ресурсов</span><br><span class="line">- создание абстракций</span><br><span class="line">- чистота (stateless)</span><br><span class="line">- контроль ошибок</span><br><span class="line">- встраиваемость (комбинируемость с другими)</span><br><span class="line">- типизация</span><br><span class="line">- быстрая интерпретация</span><br><span class="line">- дружественность к особенностям железа (hardware-friendly)</span><br><span class="line">- открытость</span><br><span class="line">- бесплатность</span><br><span class="line">- быстрые контексты (fast context reset)</span><br></pre></td></tr></table></figure><p>Если попробовать аппроксимировать слова вместе, максимально абстрактно склеивая их друг с другом, можно получить что-то такое:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">скорость (4) &lt;- скорость разработки + быстрая интерпретация + hardware friendly + fast context reset</span><br><span class="line">низкоуровневость (2) &lt;- экономность + hardware friendly</span><br><span class="line">защита (3) &lt;- контроль + типизация + чистота</span><br><span class="line">свобода (4) &lt;- выразительность + комбинируемость + бесплатность + открытость</span><br><span class="line">виртуальность (2) &lt;- выразительность + создание абстракций</span><br></pre></td></tr></table></figure><p>И еще разок:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">производительность&#x2F;performance (6) &lt;- низкоуровневость + скорость</span><br><span class="line">свобода&#x2F;freedom (4)</span><br><span class="line">безопасность&#x2F;safety (5) &lt;- защита + виртуальность</span><br></pre></td></tr></table></figure><p>Уже похоже на motto:</p><blockquote><p>“Performance &amp; creative freedom in safety environment”</p></blockquote><p>Производительный код и свобода творчества в безопасном скриптовом окружении? Кажется безумной, но заманчивой затеей? — но отчаянный <strong><code>dAsperado language (dasLang)</code></strong> позволяет именно это.<br><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/zVMObSx3E1M?start=26" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Год назад в первых же заметках про &lt;code&gt;daScript&lt;/code&gt;:&lt;br&gt;&lt;a href=&quot;/blog/1728194429/&quot; title=&quot;С++ в геймдеве&quot;&gt;С++ в геймдеве&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;/blog/1547564887/&quot; title=&quot;daScript macro&quot;&gt;daScript macro&lt;/a&gt;&lt;br&gt;я отметил для себя такой парадокс - &lt;strong&gt;&lt;code&gt;Гайдзины делают не замену Lua, они делают замену C++!&lt;/code&gt;&lt;/strong&gt;, т.е. дизайн языка — это совсем не про скрипты, это generic язык, удобный, чтобы делать с его помощью игры.&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="dev_method" scheme="http://spiiin.github.io/tags/dev-method/"/>
    
      <category term="gamedev" scheme="http://spiiin.github.io/tags/gamedev/"/>
    
      <category term="dascript" scheme="http://spiiin.github.io/tags/dascript/"/>
    
  </entry>
  
  <entry>
    <title>Хеш-таблицы. Шпаргалка</title>
    <link href="http://spiiin.github.io/blog/847579411/"/>
    <id>http://spiiin.github.io/blog/847579411/</id>
    <published>2022-12-25T20:09:16.000Z</published>
    <updated>2022-12-26T13:30:22.109Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Небольшой обзор типов хеш-таблиц, которые чаще всего встречаются в языках программирования.</p><a id="more"></a><p>Материалы:<br>[1] - <a href="https://youtu.be/ncHmEUmJZf4" target="_blank" rel="noopener">Matt Kulukundis “Designing a Fast, Efficient, Cache-friendly Hash Table, Step by Step”</a><br>[2] - <a href="http://bannalia.blogspot.com/2022/06/advancing-state-of-art-for.html" target="_blank" rel="noopener">Advancing the state of the art for std::unordered_map implementations</a><br>[3] - <a href="http://craftinginterpreters.com/hash-tables.html" target="_blank" rel="noopener">Crafting Interpreters</a>. Глава “Hash tables”<br>[4] - <a href="https://www.sebastiansylvan.com/post/robin-hood-hashing-should-be-your-default-hash-table-implementation/" target="_blank" rel="noopener">Robin Hood Hashing should be your default Hash Table implementation</a><br>[5] - <a href="https://www.youtube.com/watch?v=M2fKMP47slQ" target="_blank" rel="noopener">You Can Do Better than std::unordered_map: New Improvements to Hash Table Performance</a> - доклад автора ska::flat_hash_map<br>[6] - <a href="https://pdimov.github.io/articles/unordered_dev_plan.html" target="_blank" rel="noopener">Development Plan for Boost.Unordered</a></p><p>Хеш-таблицы (наряду с массивами) — одна из основных структур данных стандартной библиотеки практически каждого языка программирования. Базовые понятия можно изучить из любой книги по алгоритмам и структурам данных, например, <code>Седжвик - Фундаментальные алгоритмы на C++</code>.</p><p>Теоретически, хеш-таблица (ассоциативный массив) — это контейнер, который хранит пары [ключ, значение] с быстрым доступом (амортизированно, O(1)). Практически, есть много интересных нюансов организации хранения.<br>Хеш-таблица логически организована как несколько корзин (bucket/slot), которые хранят данные (пары, значения, указатели на них). Место хранения (конкретная корзина) определяется с помощью хеш-функции, которая отображает ключ на номер корзины.</p><h2 id="Размер-таблицы"><a href="#Размер-таблицы" class="headerlink" title="Размер таблицы"></a>Размер таблицы</h2><p>Память компьютера не бесконечна, так что количество корзин очевидно должно быть меньше, чем все количество всех возможных значений ключей. Так как хеш-таблицы — очень общая структура данных, то баланс между размером таблицы и скоростью доступа является сложной задачей. Разные типы хеш-таблиц начинают просаживаться по скорости начиная с различной степени заполненности, так что оптимальный размер таблицы зависит от её внутреннего устройства. Бывают типы таблиц, которые “расширяются” начиная от 50%, 75% или даже 90-95%</p><h2 id="Хеш-функции"><a href="#Хеш-функции" class="headerlink" title="Хеш-функции"></a>Хеш-функции</h2><p>Идеальный случай — если каждый ключ отображается на уникальную корзину. Но когда хеш-функция для двух ключей возвращает одно и то же значение, происходит коллизия. Одно из фундаментальных различий организации хеш-таблиц — способ работы с коллизиями. От него же зависит от отклонение между теоретическим и практическим временем поиска элемента в таблице.</p><p>Тем не менее, перед рассмотрением способов работы с коллизиями, стоит сказать пару слов о хеш-функциях. Чем более равномерно будут “размазаны” входные значения по корзинам хеш-таблицы, тем лучше. Если входные данные неизвестны заранее, то хорошим способом будет максимально рандомизировать хеш-функцию. Огромная часть производительности хеш-таблиц зависит от того, насколько равномерно входные данные попадают в различные корзины, так что первый шаг в проверке производительности — проверить используемую функцию ([1], <a href="https://youtu.be/ncHmEUmJZf4?t=170" target="_blank" rel="noopener">тайминг</a>)</p><h2 id="Идеальное-хеширование"><a href="#Идеальное-хеширование" class="headerlink" title="Идеальное хеширование"></a>Идеальное хеширование</h2><p>В случае, если входные данные известны заранее и можно построить по ним таблицу до начала её использования, можно попробовать перебором подобрать такую хеш-функцию, которая вообще не вызовет коллизий на входных данных (<code>идеальное хеширование</code>). Отчасти расширением этого подхода можно назвать <a href="https://www.geeksforgeeks.org/cuckoo-hashing/" target="_blank" rel="noopener">хеширование кукушки</a>. В этом случае есть две отдельных хеш таблицы с разными хеш-функциями, и элемент может храниться в любой из двух таблиц. Если слот в одной из корзин занят, можно попробовать положить один из элементов в другую таблицу, и циклически переместить другие занятые в одной из таблиц слоты с другую. Если же найден цикл — можно попробовать или сменить пару хеш-функций и переложить все элементы в другую таблицу, или добавить третью таблицу с еще одной хеш-функцией.</p><h2 id="Separate-chaining"><a href="#Separate-chaining" class="headerlink" title="Separate chaining"></a>Separate chaining</h2><p>Один из простых случаев разрешения коллизий — хранить в корзинах не значения, а односвязный список, в который добавляются значения с одинаковым ключом. Такой подход могут называть раздельное хеширование или закрытая адресация (closed addressing, в значении “возможность положить значение не в свою корзину закрыта”). Минусы такого способа, как и самого связанного списка — необходимость динамического выделения памяти и дополнительный прыжок в памяти по указателю на элемент.</p><p>Тем не менее, практически в чистом виде встречается в C++ (<code>stl::unordered_map</code>), в <a href="https://github.com/mono/mono/blob/mono-3.0.3/mcs/class/corlib/System.Collections.Generic/Dictionary.cs#L66" target="_blank" rel="noopener">C#</a>, Java, <a href="https://medium.com/kalamsilicon/hash-tables-implementation-in-go-48c165c54553" target="_blank" rel="noopener">Go</a>.</p><p>Для C++, вдобавок, в стандарте прописана необходимость реализации API в виде связанного списка (<a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1456.html" target="_blank" rel="noopener">N1456</a>, комментарий в [1], <a href="https://youtu.be/ncHmEUmJZf4?t=549" target="_blank" rel="noopener">тайминг</a> — <em>when stl is starting to make sense, and that is never a good sign</em>).</p><p><code>boost::unordered_map</code><br>В [2] приводятся примеры нескольких реализаций такого API и возможных оптимизаций по производительности (<em>Time and memory performance of Boost 1.80 boost::unordered_map</em>).<br><img src="/blog/847579411/fca_small.png" alt=""></p><ul><li>bucket groups - бит-маска занятых элементов вместо указателей из одного слота в другой (на скрине выше), за счет экономии памяти лучше влезает в кеш</li><li>количество корзин при максимально допустимой загруженности таблицы растет не в 2 раза, а как последовательность простых чисел — способствует более равномерному распределению при плохом (non-uniform) выборе хеш-функции<br>(<a href="https://www.boost.org/doc/libs/develop/libs/unordered/doc/html/unordered.html#compliance" target="_blank" rel="noopener">бенчмарк</a>)<br>[6] - обзор альтернативных типов таблиц</li></ul><p>Одна из нераспространенных на практике идей из классических книг — сохранять упорядоченность списков для небольшого ускорения проверки наличия элемента в списке (<em>скорее всего, из-за потери возможности хранить указатели на элементы корзины</em>)</p><h2 id="Open-addressing"><a href="#Open-addressing" class="headerlink" title="Open addressing"></a>Open addressing</h2><p>Варианты названия:<br><code>Open addressing</code> (открытая адресация, в смысле, что возможность попадания элемента не свою корзину отрыта)<br><code>Closed hashing</code> (<a href="http://craftinginterpreters.com/hash-tables.html#open-addressing" target="_blank" rel="noopener">3</a>, закрытое хеширование в смысле что возможность элемента оказаться вне корзин закрыта)<br><code>Probing table</code>(<a href="https://youtu.be/ncHmEUmJZf4?t=943" target="_blank" rel="noopener">1</a>, для случая, если в корзинах хранятся не указатели, а значения)<br><code>Scatter tables</code>(<a href="https://book.huihoo.com/data-structures-and-algorithms-with-object-oriented-design-patterns-in-java/html/page231.html" target="_blank" rel="noopener">Data Structures and Algorithms with Object-Oriented Design Patterns in Java</a>, аналогично)<br><code>Flat map</code> (аналогично)</p><p>Зачем хранить элементы с повторяющимся хешем ключа в связанном списке, если можно положить их в другие корзины? Это сложнее в организации, возникает серия вопросов — как именно выбрать альтернативную корзину, как узнать, что в корзине находится “не родное” значение, как удалять элементы? Дальнейшую таксономию таблиц с открытой адресацией можно выстроить в зависимости от ответов на эти вопросы.</p><p>Варианты ответов:</p><p><strong><code>Как выбрать альтернативную корзину</code></strong></p><ul><li>Попробовать следующую (после последней заново проверить первую) — линейное пробирование.<br>Распространенный метод из-за того, что дружественный к кешу, элементы хранятся в памяти близко друг к другу.<br>Может вызывать проблемы при большой загруженности таблицы, но это можно решать различными способами — пересортировать элементы хранящиеся рядом, позаботиться о более качественном “размазывании”, см. раздел “Хеш-функции”), уменьшить коэффициент заполненности, при котором будет увеличено количество корзин. Эти решения проблем будут более детально рассмотрено далее</li><li>Увеличивать шаг не на 1, а по более сложным правилам — квадрат от номера попытки, другая хеш-функция от значения элемента, etc. Требует хорошего понимания вероятности, насколько выбор шага может действительно улучшить распределение ключей по корзинам (может зависеть от размера таблицы и хеш-функции).</li></ul><p>Встречаются экзотические комбинации стратегий - <a href="https://github.com/ktprime/emhash" target="_blank" rel="noopener">emhash</a> в режиме 3-way combined сначала делает несколько линейных проб, затем квадратичные, и дальше пробует втиснуть элемент поочередно в начало/конец таблицы.</p><p><strong><code>Удаление значений</code></strong></p><ul><li>Вместо удаления значений, заменить реальное значение в корзине на “надгробие” (tombstone), чтобы при поиске элемента по списку рассматривать его “за этим значением есть другие для проверки”, а при вставке нового элемента рассматривать надгробие как пустую корзину для вставки</li><li>В случае линейной вставки элементов в первую попавшуюся пустую корзину можно переместить последний элемент списка на освободившееся пустое место. Несмотря на кажущуюся тривиальность алгоритма, требует аккуратности в реализации (как пример, в книге Кнута алгоритм содержал ошибки)</li></ul><p><strong><code>Как отличить неродное значение</code></strong></p><ul><li>В случае линейного пробирования, проверять все соседние занятые элементы до нахождения пустого значения<br>В случае сильно заполненной корзины, даже без наличия коллизий, может оказаться для что вставки нового значения потребуется проверить по порядку множество уже занятых значений (кластеры из занятых корзин). Аналогичная проблема при поиске несуществующего элемента.</li></ul><p>Тривиальный подход слежения за тем, чтобы не образовывались кластеры — хорошая хеш-функция и низкие значение коеффициенты заполненности (~0.5-0.6) для того, чтобы таблица разрослась раньше, чем в ней образовались большие кластеры из заполненных корзин. Более сложный — переставлять элементы внутри кластеров так, чтобы уменьшить количество необходимых поисков (алгориты <code>Брента</code>, <code>Робин Гуда</code>, детальнее ниже)</p><h2 id="Линейное-пробирование-без-перестановок"><a href="#Линейное-пробирование-без-перестановок" class="headerlink" title="Линейное пробирование без перестановок"></a>Линейное пробирование без перестановок</h2><p>Почти чистый вариант линейного пробирования без дополнительных хитростей с перестановками элементов приведен в [3].</p><p>Вариант из <code>daScript</code>:</p><ul><li>Рост таблицы при кластеризации в 2 раза. Чем больше таблица, тем меньше <a href="https://github.com/GaijinEntertainment/daScript/blob/a0fcdfdbf134d3dfb8055c9218c6e57ff4ae925b/include/daScript/simulate/runtime_table.h#L61" target="_blank" rel="noopener">коеффициент заполненности</a> (при увеличение таблицы в 2 раза разрешаем в 6 раз больше промахов)</li><li>Раздельное хранение хешей, хеширование <a href="https://github.com/GaijinEntertainment/daScript/blob/master/include/daScript/misc/fnv.h" target="_blank" rel="noopener">fnv</a></li><li>Tombstone при удалении</li></ul><p><a href="https://abseil.io/docs/cpp/guides/container" target="_blank" rel="noopener">absl::flat_hash_map</a> + <a href="https://abseil.io/about/design/swisstables" target="_blank" rel="noopener">Swiss Tables Design Notes</a><br>[1] - доклад с пошаговым описанием идей дизайна flat_hash_map + <a href="https://www.youtube.com/watch?v=JZE3_0qvrMg" target="_blank" rel="noopener">дополнение</a></p><ul><li>Раздельное хранение метаинформации + simd инструкции для ускорения проверок</li></ul><p>Пример возможной проблемы с кластеризацией значений:<br><img src="/blog/847579411/cluster_small.png" alt=""></p><p>Даже если все элементы отмеченные красным, стояли на своих местах, может получиться, что новый элемент (зеленый), будет вставлен далеко от своего потенциального места (первая стрелка).</p><p>Одна из неочевидных проблем линейного пробирования — про последовательном обходе элементов из хеш-таблицы (неявно отсортированы по возрастанию хешей) и перекладывании их в другую таблицу они попадут туда в очень плохом порядке (при добавлении второй половины таблицы до роста хеши элементов по модулю будут совпадать с хешами из первой половины, которая будет уже плотно заполнена — зона заполненности “от 0.5 до коэффициент роста” будет содержать большое количество коллизий) — пример багов в <a href="https://habr.com/ru/post/282902/" target="_blank" rel="noopener">Delphi</a>, <a href="http://lemire.me/blog/2017/01/30/maps-and-sets-can-have-quadratic-time-performance/" target="_blank" rel="noopener">Swift</a>, <a href="https://accidentallyquadratic.tumblr.com/post/153545455987/rust-hash-iteration-reinsertion" target="_blank" rel="noopener">Rust</a>. Возможное решение — использовать хеш-функцию с возможностью задать стартовый сид и менять его для каждой новой таблицы. Или попробовать предсказать размер заполняемой таблицы заранее.</p><h2 id="Линейное-хеширование-с-перестановкой-Брента"><a href="#Линейное-хеширование-с-перестановкой-Брента" class="headerlink" title="Линейное хеширование с перестановкой Брента"></a>Линейное хеширование с перестановкой Брента</h2><p>На скриншоте выше все элементы представленные красным стоят на своих местах, и могут быть найдены за 1 запрос к таблице. Но при поиске красного элемента нужно будет проверить 9 элементов. При этом, если все красные элементы кластера сдвинуть на 1 вправо, то для поиска каждого из них потребовалось бы всего 2 запроса — среднее время поиска осталось бы таким же, но максимальное время поиска уменьшилось бы с 9 до 2, в 4.5 раза. Метод Брента — перед вставкой проверить сколько запросов будет при такой перестановке и выбрать самый оптимальный вариант (<a href="https://www.cs.umd.edu/class/fall2018/cmsc420-0301/lecnotes/Hashing-spring17.pdf" target="_blank" rel="noopener">описание и пример</a>, а также какое-то расширение метода в поиск по дереву Gonnet-Munro, <a href="https://github.com/ncilengir/brent-hashing" target="_blank" rel="noopener">другое описание</a> и <a href="http://www.minkhollow.ca/Courses/461/Notes/Hashing/HashBrentex1.html" target="_blank" rel="noopener">другой пример</a>).</p><p>Реализация метода Брента в таблицах <a href="https://www.lua.org/source/5.4/ltable.c.html" target="_blank" rel="noopener">lua</a> и <a href="https://poga.github.io/lua53-notes/table.html" target="_blank" rel="noopener">описание</a></p><h2 id="Линейное-хеширование-с-перестановкой-Робин-Гуда"><a href="#Линейное-хеширование-с-перестановкой-Робин-Гуда" class="headerlink" title="Линейное хеширование с перестановкой Робин Гуда"></a>Линейное хеширование с перестановкой Робин Гуда</h2><p><a href="https://cs.uwaterloo.ca/research/tr/1986/CS-86-14.pdf" target="_blank" rel="noopener">Пейпер</a> с описанием метода, там же есть сравнение с методом Брента (стр 51-53) — чуть более быстрая вставка, за счет немного медленного среднего времени поиска, но более быстрая проверка несуществующего элемента. Позволяет заполнять таблицы на 90% перед тем, как увеличивать объём.</p><p>Логика вставки — если для уже сохраненного в слоте элемента расстояние до его идеальной позиции меньше, чем для нового, то “выселяем” элемент из слота, и проверяем дальше, с кем можно переставить его (“забираем позицию у богатого элемента и отдаём бедному”). <a href="http://web.stanford.edu/class/archive/cs/cs166/cs166.1196/lectures/13/Slides13.pdf" target="_blank" rel="noopener">Пример вставки</a></p><p>Описание в <a href="https://cglab.ca/~abeinges/blah/robinhood-part-1/" target="_blank" rel="noopener">Rust</a>:</p><ul><li>Линейное хеширование с перестановкой Робин Гуда</li><li>Рост таблицы после заполненности 0.9 в 2 раза</li><li>Хеш-функция с уникальным сидом для каждой таблицы для защиты от неудачной вставки ключей в порядке увеличения хеш-значений</li></ul><p><a href="https://github.com/skarupke/flat_hash_map" target="_blank" rel="noopener">ska::flat_hash_map</a>:</p><ul><li>Линейное хеширование с перестановкой Робин Гуда</li><li>Рост таблицы при первом длинном неудачном пробировании, до следующего prime number</li></ul><p><a href="https://probablydance.com/2017/02/26/i-wrote-the-fastest-hashtable/" target="_blank" rel="noopener">I Wrote The Fastest Hashtable</a> - описание<br>Используются для внутренних структур данных в <a href="https://github.com/GaijinEntertainment/daScript/blob/dcecc6f126843fc0914b0be314542caa658fc8d6/include/daScript/das_config.h#L34" target="_blank" rel="noopener">daScript</a><br>[5] - доклад автора о влиянии отдельных приёмов оптимизации (крутое объяснение форм графиков, можно прикинуть свои паттерны и размеры таблиц), сравнение с различными реализациями хеш карт и хинты реализации</p><h2 id="Бенчмарки"><a href="#Бенчмарки" class="headerlink" title="Бенчмарки"></a>Бенчмарки</h2><p>Несколько бенчмарков различных C++ реализаций, с описанием типов таблиц:<br><a href="https://martin.ankerl.com/2016/09/15/very-fast-hashmap-in-c-part-1/" target="_blank" rel="noopener">https://martin.ankerl.com/2016/09/15/very-fast-hashmap-in-c-part-1/</a><br><a href="https://martin.ankerl.com/2019/04/01/hashmap-benchmarks-01-overview/" target="_blank" rel="noopener">https://martin.ankerl.com/2019/04/01/hashmap-benchmarks-01-overview/</a><br><a href="https://martin.ankerl.com/2022/08/27/hashmap-bench-01/" target="_blank" rel="noopener">https://martin.ankerl.com/2022/08/27/hashmap-bench-01/</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Небольшой обзор типов хеш-таблиц, которые чаще всего встречаются в языках программирования.&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="dev" scheme="http://spiiin.github.io/tags/dev/"/>
    
  </entry>
  
  <entry>
    <title>Making tools for big games</title>
    <link href="http://spiiin.github.io/blog/2767873544/"/>
    <id>http://spiiin.github.io/blog/2767873544/</id>
    <published>2022-12-25T14:57:07.000Z</published>
    <updated>2022-12-25T17:51:51.467Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Тезисы из доклада технического директора <code>Guerilla</code> Michiel van der Leeuw <a href="https://www.guerrilla-games.com/read/making-tools-for-big-games" target="_blank" rel="noopener">Making tools for big games</a></p><a id="more"></a><p><strong><code>Вступление</code></strong></p><ul><li>Технология в геймдеве перестала определять игру и её геймдизайн, а является одной из фич игры</li><li>Технология сейчас — это не только движок игры, а её тулсет</li><li>Тулсет позволяет поддерживать масштабирование количества контента игр, а также следить за качеством и процессом производства</li><li>Респект автора доклада <code>Naughty Dog</code>, часть идей оттуда</li></ul><p><strong><code>Идея 1. Сокращение &quot;зоны сумерек&quot;, когда QA находятся между игрой, таск-трекером, браузером, vcs, мессенджером и почтовым клиентом</code></strong></p><ul><li>Кастомный интерфейс к vcs, шаблоны для заполнения полей близкие к стандартам компании</li><li>Соединение перед пуллом с билд сервером для сверки, в порядке ли ревизия, которую собираешься получить</li><li>In-game gui для оформления задач в Jira — запись видео, логгирование игровых ресурсов в кадре</li><li>Редактор видео, в котором можно отметить тайминг бага/задачи, связанные ассеты, разметить зоны и отрезать лишнее. Ссылки на фрейм видео можно добавлять в задачи</li><li>Ассеты хранятся в базе данных с метаинформацией. Среди прочего, хранят обратные ссылки на баги, ссылающиеся на эти ассеты.</li></ul><p>Выявить точки, из которых удобнее всего совершать действия, и из этих точек с помощью api к другим приложениям дать возможность работать с этими приложениями без переключения контекста. Убрать рутину.<br>Пара бонусных идей не из доклада:</p><ul><li>В code-review вычислять, какие из прошлых коммитов/мердж реквестов затрагивает диф кода и выводить список этих коммитов (“чей код ты потенциально мог сломать”).</li><li>Подтягивать к багу в Jira данные из всех систем аналатики (доступ ко всей полезной инфе на одной страничке)</li></ul><p><strong><code>Идея 2. Слежение за здоровьем билда позволяет увеличить количество итераций</code></strong></p><ul><li>Бот-фермы из девкитов, которые выполняют скрипты телепортации по миру и сохраняют профилирование, телеметрию и игровую информацию в виде карты мира, отдельный редактор для визуализации и изучения этой карты</li><li>Примеры применения — визуализатор информации для гейм-дизайнеров и непосредственно отладка геометрических данных (карты рек, эрозии, нормалей, карты видимости неба), heat-map тормозящих мест, визуализация мест багов в jira. Всю информацию можно посмотреть в других местах, но такое картографирование позволяет оценить общую картину</li><li>Запросы к данным для отображения на карте исторических данных (диффы, графики, экспорт в json/csv)</li><li>Вьюер карты тесно связан с игрой (можно получать графики производительности с девайсов и кол-во потребляемой памяти, а также делать отметки на графиках и ссылаться на них)</li><li>Метрика — количество изменений, которое команда может позволить себе без страха делать в последние дни/недели перед релизом</li></ul><p><a href="/blog/1687824628/" title="Паттерны организации разработки уровней игр">Паттерны организации разработки уровней игр</a> - итерации делают игру лучше, упрощая процесс разработки<br><a href="/blog/3309518526/" title="Системы поиска сокровищ">Системы поиска сокровищ</a> - итерации кроме полировки могут позволить найти новые уникальные решения</p><p>Глобальная карта для отображения оверлеями различной информации — отличный инструмент, кажется, впервые видел идею с тепловой картой производительности еще в докладе про <code>starcraft 2</code>. Я такое тоже делал, чтобы отслеживать ассеты, которые артисты/геймдизайнеры забыли правильно разметить.</p><p><strong><code>Идея 3. Работу с ассетами всегда можно улучшить</code></strong></p><ul><li>Всё висит на сервере в памяти и стримится на девелоперские машины (10 Gb сеть в локалке)</li><li>Позволило серьёзно уменьшить размер дубликатов ресурсов</li><li>Можно сгенерить строковый айдишник, по которому другой человек может запустить в точности такую же версию игры</li><li>Самописный сервер на 650 строк, БД с парами ключ значение, быстрее шеринг через SMB, NFS, файловый сервер Apache, etc</li><li>Виртуальная файловая система, ОС не видит изменений</li><li>18 core cpu, 768 Gb ram, 80 Gb network, 16 tb ssd на 300 человек</li></ul><p>Наиболее радикальная идея, работать локально с исходными версиями ассетов, и стримить ресурсы через глобальный общий сервер. Доклад 2019 года, когда все сидели в одном офисе, но в <a href="https://twitter.com/MvdLeeuwGG/status/1606268200143970304" target="_blank" rel="noopener">твиттере</a> автор упоминает, что адаптировали и для домашней работы. Кроме блоба ассета хранится также метаинформация (например, ссылки, в каких тасках он задействован).</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Тезисы из доклада технического директора &lt;code&gt;Guerilla&lt;/code&gt; Michiel van der Leeuw &lt;a href=&quot;https://www.guerrilla-games.com/read/making-tools-for-big-games&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Making tools for big games&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="dev_method" scheme="http://spiiin.github.io/tags/dev-method/"/>
    
      <category term="link" scheme="http://spiiin.github.io/tags/link/"/>
    
  </entry>
  
  <entry>
    <title>daScript tiny renderer port</title>
    <link href="http://spiiin.github.io/blog/3563373441/"/>
    <id>http://spiiin.github.io/blog/3563373441/</id>
    <published>2022-12-25T14:02:28.000Z</published>
    <updated>2022-12-25T14:31:25.242Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Портировал первые несколько примеров <a href="https://github.com/ssloy/tinyrenderer/wiki" target="_blank" rel="noopener">Tiny renderer or how OpenGL works: software rendering in 500 lines of code</a> софт-рендера с C++ на daScript. Механически и неоптимально, но близко к коду оригинального туториала, для желающих потренироваться в базовых алгоритмах растеризации на daScript.<br><a href="https://github.com/spiiin/dascript_soft_render" target="_blank" rel="noopener">https://github.com/spiiin/dascript_soft_render</a></p><p>Растеризация отрезков, wireframe<br><img src="/blog/3563373441/1.png" alt=""><br>Растеризация треугольников line sweeping, flat shading, отсечение задних граней<br><img src="/blog/3563373441/2.png" alt=""><br>Z-буфер, наложение текстурных координат<br><img src="/blog/3563373441/3.png" alt=""><br>Перспективная проекция<br><img src="/blog/3563373441/4.png" alt=""><br>Камера, Gouraud shading<br><img src="/blog/3563373441/5.png" alt=""><br>Коррекция перспективных искажений текстурных координат, растеризация треугольника проверкой барицентрических координат точки, пиксельный и вершинный шейдеры<br><img src="/blog/3563373441/6.png" alt=""></p><p>В оригинале есть ещё детальный разбор матриц (model, view, projection), наложение карты нормалей, тени и ambient occlusion. Но, мне кажется где-то с этого уровня можно продолжать разбираться с графикой уже с помощью графического API.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;Портировал
      
    
    </summary>
    
    
    
      <category term="opengl" scheme="http://spiiin.github.io/tags/opengl/"/>
    
      <category term="3d" scheme="http://spiiin.github.io/tags/3d/"/>
    
      <category term="dascript" scheme="http://spiiin.github.io/tags/dascript/"/>
    
  </entry>
  
</feed>
