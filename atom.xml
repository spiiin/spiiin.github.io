<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Spiiin&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://spiiin.github.io/"/>
  <updated>2023-02-19T15:06:58.936Z</updated>
  <id>http://spiiin.github.io/</id>
  
  <author>
    <name>spiiin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Немного о проектировании</title>
    <link href="http://spiiin.github.io/blog/1337028819/"/>
    <id>http://spiiin.github.io/blog/1337028819/</id>
    <published>2023-02-19T11:40:56.000Z</published>
    <updated>2023-02-19T15:06:58.936Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Дамп мыслей про проектирование систем, как обычно, с уклоном в геймдев.<br><a id="more"></a></p><h2 id="Cohesion-and-Coupling"><a href="#Cohesion-and-Coupling" class="headerlink" title="Cohesion and Coupling"></a>Cohesion and Coupling</h2><p><a href="https://en.wikipedia.org/wiki/Cohesion_(computer_science%29" target="_blank" rel="noopener">Cohesion</a> — степень смысловой связи между сгруппированными элементами (функциями в классе или модуле).<br><a href="https://en.wikipedia.org/wiki/Coupling_(computer_programming%29" target="_blank" rel="noopener">Coupling</a> — степень запутанности связи между модулями.</p><p><img src="/blog/1337028819/coupling_small.png" alt=""><br>Хороший вариант дизайна — высокая cohesion и низкая coupling.</p><p>Примеры модулей, в которых скорее всего окажется <code>низкий cohesion</code>:</p><ul><li>Utils - сгруппировано все небольшие функции</li><li>GameObject - в котором при ООП дизайне рано или поздно собирается весь функционал, который может потребоваться потомкам (анти-паттерны GodObject/Blob)</li></ul><p>Примеры модулей, которые скорее всего могут быть связаны с другими (<code>высокий coupling</code>) - системы логгирования, профилирования.<br>Подсистемы также связываются на уровне реализации игровой логики — звук шагов задействует подсистемы анимации, звука, физики. Сильно лучше, если подсистемы связаны не между собой, а на отдельном слое связывания.</p><h2 id="Компоненты"><a href="#Компоненты" class="headerlink" title="Компоненты"></a>Компоненты</h2><p>Для подсистем с высокой cohesion и низкой coupling встречается название <strong><code>компоненты</code></strong>, за счет того, что они изолированы друг от друга и могут переиспользоваться.<br>Один из приемов проектирования — строить программу из компонентов.</p><p>Между слоем компонентов и логики приложения могут лежать и промежуточные слои библиотек:</p><p><img src="/blog/1337028819/components_levels_small.png" alt=""><br><em>(картинка из книги John Lacos - Large-Scale C++ )</em></p><p>Однако при этом часто на среднем уровне библиотека не оформлена в виде компонентов или даже компоненты на спроектированы так, чтобы использоваться вне библиотеки очень высокого уровня.</p><p>Примеры библиотек:<br>В которых сложно “оторвать компоненты” для использования вне библиотеки (в плане coupling, иногда заниматься отрыванием может мешать и лицензия библиотеки): <code>Qt</code><br>Средний уровень сложности: <code>boost</code> (зависит от конкретной библиотеки, некоторые отрываются неплохо, некоторые тянут за собой в зависимостях половину библиотеки), <code>entt</code> (для примера — оторвать basic_sparse_set/basic_storage можно, но требует усилий)<br>Легко отделить компоненты: <a href="https://github.com/tamasmeszaros/libnest2d" target="_blank" rel="noopener">libnest2d</a> - надстроена над <code>clipper/nlopt/boost.geometry</code>, вполне позволяет подменить любую из этих библиотек</p><p><a href="https://www.youtube.com/watch?v=ZQ5_u8Lgvyk" target="_blank" rel="noopener">Designing and Evaluating Reusable Components - 2004</a> — доклад Casey Muratori про дизайн компонентов и виды зависимостей, которые они могут добавлять на уровне, который их использовует.</p><p>По субъективному опыту — для open-source библиотек можно найти качественные компоненты более “низкого” уровня (то, что можно забросить в 3rdPartyLibs), библиотеки среднего уровня чаще всего (если не считать движения свободного кода) — проприетарная собственность компаний (1stPartyLibs), так как требуют серьёзного уровня поддержки, который сложно поддерживать небольшой группе разработчиков, а также могут быть заточены под нужды конкретной компании. В Large-Scale C++ такие компоненты, накопленные компаниями, упоминаются, как <code>software capital</code>. Большие open-source библиотеки компонентов часто появляются как открытие накопленного корпорацией software capital (<code>abseil</code>, <code>folly</code>).</p><p>Еще одно интересное свойство компонент, которое влияет на простоту их использования — компактность их API. Так как библиотеки “среднего” уровня могут быть достаточно объёмными, Эрик Реймонд в книге “Искусство программирования для UNIX” вводит термин <code>полукомпактность</code> для систем, которые позволяет решать с их помощью большинство задач, используя только небольшую и наиболее используемую компактную часть их API. В качестве примеров полукомпактных систем он приводит <code>html</code> или язык <code>c</code> (не c++).</p><h2 id="Копирование-лучших"><a href="#Копирование-лучших" class="headerlink" title="Копирование лучших"></a>Копирование лучших</h2><p>Вместо написания чего-то с нуля нужно использовать или копировать лучших (смысл не пользоваться накоплненным software capital?).</p><ul><li>Черновая реализация на несколько оптимизаций отстает от оптимальной</li><li>Часто оптимальная может так сильно отличаться от наивной, что переделать станет сложно/невозможно</li><li>Для понимания оптимальной версии может потребоваться больше времени, и знаний для сравнения, чем для написания наивной</li></ul><p>При этом копирование плохо работает в чём-то, отличном от кода. <a href="https://vadzimv.dev/2020/03/07/childs-illusions.html" target="_blank" rel="noopener">Книжки не заменяют опыта</a>, но обещают успех в случае повторения внешних признаков (чтобы понять границы применимости общих техник, необходимо колоссальное количество опыта).</p><h2 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h2><p>Data oriented</p><ul><li>сначала кажется непривычным</li><li>так как (в случае, если мы думаем о локальности данных в памяти) подстраивается под данные, иногда требует дублирования кода под новые данные<br>(редко встречается достаточно генерик код, который может работать с кастомными структурами)</li><li>когда подстроишься под то, чтобы думать о расположении данных в памяти, становится сильно проще</li></ul><p>В геймдеве часто производительность имеет значение:</p><ul><li>там где ограниченные ресурсы - <a href="http://ru.esotericsoftware.com/" target="_blank" rel="noopener">Spine</a>-анимации для мобильных игр начинают тормозить уже на тех телефонах, но которых запускается Fortnite, при этом разработчиков не особо волнует эта проблема. <a href="https://youtu.be/rX0ItVEVjHc?t=4645" target="_blank" rel="noopener">Ответ</a> Mike Acton на позицию “We want not care about this stuff” - “из-за вас я должен ждать 2 минуты, пока открывается word”.</li><li>там где количество может переходить в качество, давать новые фичи. Например, без оптимизаций можем сделать RTS, в которых у игрока будет только 100 юнитов, а оптимизациями - как 100, так и 10000 - геймдизайнеры могут сделать фичей огромные армии</li><li>там где конкуренция, кто может выдать круче результат (точнее рассчёт физики, освещения, анимаций, ии)</li><li>там где платишь за сервера. <a href="https://youtu.be/KxQpDIKwGUw?t=2399" target="_blank" rel="noopener">Ответ</a> Максима Барышникова про то, зачем WoT сохраняется поддержка распределенных между серверами арен — на одном сервере помещается 3 арены, но за счёт того, что движок поддерживает разбиение, можно разместить 7 арен на 2х серверах (по 3.5 на сервер), а не на 3х, плюс можно динамически балансировать рассчёты, если все 4 арены одновременно становятся максимально нагруженными.</li></ul><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Дамп мыслей про проектирование систем, как обычно, с уклоном в геймдев.&lt;br&gt;
    
    </summary>
    
    
    
      <category term="dev_evolution" scheme="http://spiiin.github.io/tags/dev-evolution/"/>
    
      <category term="dev_method" scheme="http://spiiin.github.io/tags/dev-method/"/>
    
  </entry>
  
  <entry>
    <title>Иерархические компании vs плоские</title>
    <link href="http://spiiin.github.io/blog/3914071471/"/>
    <id>http://spiiin.github.io/blog/3914071471/</id>
    <published>2023-02-12T15:21:34.000Z</published>
    <updated>2023-02-12T23:05:17.776Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Несколько дней назад “уволенный сотрудник Mytona опубликовал открытое письмо” (на самом деле, <a href="https://www.youtube.com/watch?v=lYvNWf4Q2xE" target="_blank" rel="noopener">видео</a> на 2 часа). Я проработал в Майтоне 3.5 года, прошёл там путь от обычного программиста, “второго лида”, лида-проекта, программиста движка и технического продюссера, плюс долгое время занимался собеседованиями (провел штук 100 интервью), так что знаю там устройство компании на различных уровнях. Устройство не сильно отличается от типовой корпорации, так что и проблемы, озвученные в видео, типичны скорее для каждой компании, чем для конкретной.</p><p>В первую очередь, немного по сути видео — автор достаточно склочен, и по большей части озвученных ситуаций раздувает из мухи слона. На мой взгляд, выбрасывать подобное в паблик очень неэтично (а то и подсудно, особенно клевета на CEO fntastic, с учётом того, что они разрабатывают свои игры никак не связано с издателем), так как журналисты из мутного обезличенного рассказа сделают “жёлтый” пересказ. Первый же пересказы в гугле красуются фразами — “лид держит их в страхе: Mytona трещит по швам?” и “многие люди просто попали в депрессию и начали жрать таблетки”. При этом, сам автор вначале делает 20-минутный дисклеймер, что в целом работалось неплохо.</p><p>Но хотел написать небольшую заметку о том, чем отличаются большие компании от небольших, без отсылок на конкретные компании. Конечно, структура компаний может сильно отличаться, как и внутренняя культура, так что рассуждения дальше — это сферический конь в вакууме.</p><p>Критический размер для маленьких компаний, которые стремятся к плоской организации — число Данбара (100-230 человек), встречается в докладах про структуру Unity - <a href="https://aras-p.info/texts/files/201312-BuildStuffLightweightChaos.pdf" target="_blank" rel="noopener">Lightweight Chaos For Distributed Teams</a>, Github - <a href="https://zachholman.com/talk/how-github-no-longer-works/" target="_blank" rel="noopener">How GitHub (no longer) Works</a> или в докладах Джесси Шелла - <a href="https://www.youtube.com/watch?v=-zRaFJHK0S4" target="_blank" rel="noopener">Game Studio Management: Making It Great</a> и <a href="https://www.youtube.com/watch?v=O1zP6yJjc1o" target="_blank" rel="noopener">Game Studio Leadership: You Can Do It</a>.</p><p>С таким размером компании можно обходиться <em>почти</em> без менеджеров, с чем и связы основные отличия от “больших” корпораций (естественно, маленький размер не гарантирует того, что компания не будет организована как корпоративный ад). Число данбара говорит скорее о том, чем у компании с &gt;230 человек практические неизбежно будут наблюдаться все признаки “большой”. Так что более удачные термины вместо “больших” и “маленьких” —  иерархические и плоские.</p><p><strong><code>Распространение новостей в компании</code></strong></p><p>В иерархических компаниях часто встречается “испорченный телефон”. На высоком “уровне” условный продюссер проекта общается как с издателем/топ-менеджментом, так и с лидами направлений своего проекта (программисты, арт, геймдизайнеры) и общих отделов всей компании. Невозможно передать всю важную информацию по проекту “вниз по иерархии” исполнителям. Также практически необходимы каналы с освещением жизни компании и других отделов, если она хочет существовать как единое целое. Бонусом — всякие корпоративы, тимбилдинги и ивенты для организации дополнительных неформальных связей. При этом всём по прежнему самый надёжный способ узнать что-то достоверно — иметь знакомого, которые откуда-то умудряется знать всё и со всеми дружит.</p><p><strong><code>Разрешение конфликтов</code></strong></p><p>На кого-то ложится обязанность знать об атмосфере в коллективе, разруливать конфликты делегируется кому-нибудь типа специально обученных эйчаров. Причём задача сложная, отсюда неизбежны отзывы типа “меня уволили из-за конфликта с одним человеком” — это стандартный способ решения конфликта, который не могут уладить сами сотрудники, в случае, если невозможно перевести их подальше друг от друга. В плоской компании необходимо вписываться в коллектив, в иерархической — наверное можно попасть в другой проект, не пересекаясь больше ни с кем из предыдущего. Вообще найти себе команду и место, где применить свои навыки в плоской компании — задача самого сотрудника.</p><p><strong><code>Скорость реагирования</code></strong></p><p>Передача информации по уровням иерархии — очень медленный процесс, особенно если выполняется через какие-нибудь метрики или отчеты. Поэтому для задач, которые вроде требуют оперативного реагирования, могут происходить какие-то чудовищные ынтырпрайз истории (<a href="https://vas3k.club/post/5070/" target="_blank" rel="noopener">пример подборки</a>). Вполне могут существовать никому не нужные отделы, не выгоняться по году неработающие раздолбаи. Ну, и скорость реакции на меняющийся рынок — тоже не лучшие сторона иерархических компаний. Книга “Дилемма инноватора” рассматривает это подробно.</p><p><strong><code>Ценности</code></strong></p><p>Ценности в плоской компании — это или очевидные вещи, или негласные правила. Но! Если они таки есть, то сотрудники “впитывают” их естественным образом, просто продолжая работать в компании. Скорее всего плоская компания и занимается исключительно тем, что считает ценным. В иерархических компаниях ценности более абстрактны, и причастность к ним — скорее способ мотивации и повышения лояльности работников, а не способ выбора варианта действий в непонятных случаях. Вместо ценностей работают инструкции, что можно, нужно или нельзя делать.</p><p><strong><code>Найм</code></strong></p><p>Иерархические компании стремятся быть похожими друг на другу, и в теории иметь возможность заменить хоть всех сотрудников. Из-за этого вполне способны впитывать больше новичков. В плоских — процессы найма отличаются, но часто новый сотрудник должен приносить что-то новое. Недавняя истории с увольнениями десятков тысяч сотрудников тажке показывает, что иерархические компании могут расширяться просто чтобы расширяться (“наймём, чтобы другие не наняли”).</p><p><strong><code>Свобода действий</code></strong></p><p>Иерархическая компания как структура стремится воспроизводить сама себя, поэтому новые проекты делаются как старые, даже если декларируется свобода организации внутри проекта. В отдельных случаях иерархические компании стремятся изображать плоские, что выглядит как “менеджерам была поставлена задачи организовать команду без менеджеров”. Также очень нерационально для общих отделов иерархической компании работать с каждой командой по разному, так что рано или поздно кто-нибудь выступит с инициативой стандартизации.</p><p>Плоские команды изначально работают как в стиле “управляемый хаос”, в котором приживаются те практики, которые полезны в настоящий момент.</p><p><strong><code>Количество менеджеров</code></strong></p><p>В иерархических компаниях часто встречается случай, когда у тебя 2 менеджера — руководитель проекта и руководитель направления. На мой взгляд это основная причина фрустрации автора видео, как руководитель нарративных дизайнеров он не очень хотел вникать в проблемы руководителей частного проекта, который противоречат его видению. Такая система доставляет больше сложностей самим менеджерам, чем работникам, потому что требует хорошей координации и способности договариваться между самими менеджерами.</p><p>Иерархическая компания требует большого количества менеджеров, которых проще вырастить, чем нанять внешних, в связи с чем способный работник с большой долей вероятности станет менеджером.</p><p>В плоских компаниях организацией занимается неформальный лидер. Но при этом в иерархических компаниях также скорее всего тоже есть ещё и неформальные лидеры.</p><p><strong><code>Инертность к изменениям</code></strong></p><p>В иерархических компаниях сложно передать изменения в другую часть системы — несмотря на унификацию частей, изменения нужно отдельно внедрить в каждой подсистемы, причем так, чтобы внедряли их именно менеджеры этих подсистем, которые могут исказить смысл или даже осознанно противиться изменениям. Так что — сложнее обучать людей, менять или внедрять правила, пробовать новое, и сложнее прекратить порочные устоявшиеся практики.</p><p>Плоские компании могут быть как инертными, так и гибкими. Готовность к изменением “копится” до тех пор, пока или проблема станет мешать всем настолько, что найдётся желающий её поправить, или кто-то узнает про то, как можно серьёзно что-то улучшить. Активный поиск информации и исследование — кажется, одна из отличительных черт плоских компаний, которую редко подчёркивают.</p><p><strong><code>Доступ к ресурсам</code></strong></p><p>Содержать иерархическую компанию дороже (кроме специалистов нужны доп. менеджеры, а то и “менеджеры менеджеров”, корпоративы и тимбилдинг также стоят денег), так что такие компании должны располагать достаточными ресурсами, там где плоские могут быть экономнее. Хотя слышал и обратное мнение — из-за того, что плоские компании не хотят тратиться на менеджеров или содержать отдельные отделы, чтобы не расширяться, им приходится аутсорить часть работы, что выходит дороже, если делать это регулярно.</p><p>Доступ к ресурсам также определяет степень риска, на который готовы пойти. Содержание бОльших команд (а иерархические часто больше) стоит дороже, но при этом появляется стремление уменьшить риски. Маленькие команды готовы к большему риску ради того, чтобы получить больший выигрыш (а он также нужен, чтобы иметь больше возможности конкурировать с компаниями бОльших размеров). При этом скорость реализации проектов иерархическими и плоскими командами может быть примерно сопоставима. Если команда из 10 человек делает за одно и то же время то же, что и команда из 100, то это можно было бы объяснить тем, что все 10 — гении, но если команда из 200 человек делает столько же, сколько команда из 1000, скорее всего разница объясняется эффективностью организации.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;Несколько 
      
    
    </summary>
    
    
    
      <category term="log" scheme="http://spiiin.github.io/tags/log/"/>
    
      <category term="gamedev" scheme="http://spiiin.github.io/tags/gamedev/"/>
    
  </entry>
  
  <entry>
    <title>daScript: обобщенное программирование</title>
    <link href="http://spiiin.github.io/blog/2629978232/"/>
    <id>http://spiiin.github.io/blog/2629978232/</id>
    <published>2023-01-21T21:33:14.000Z</published>
    <updated>2023-02-05T12:45:54.748Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Обобщенное программирование — одна из серых, но важных и интересных сторон daScript. “Серость” темы связана с тем, что, во-первых, система типов не очень детально описана в документации, во-вторых — в рассуждениях о типизации можно от практики быстро уйти в дебри академических терминов, в-третьих, тема плохо укладывается в голову C++-программисту.</p><p>Поддержка обобщенного программирования в языке, если “на пальцах” — совокупность способов вызывать одну функцию для разных типов.</p><h2 id="Перегрузка-функций"><a href="#Перегрузка-функций" class="headerlink" title="Перегрузка функций"></a>Перегрузка функций</h2><p>Перегруженные функции (ad-hoc полиморфизм) — простейший способ определить функцию для двух различных типов</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">func</span><span class="params">(a : <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;a&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function">def <span class="title">func</span><span class="params">(a : <span class="keyword">float</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;a&#125;\n"</span>)</span></span></span><br><span class="line">[export]</span><br><span class="line">def main</span><br><span class="line">    func(<span class="number">1</span>)</span><br><span class="line">    func(<span class="number">1.0f</span>)</span><br></pre></td></tr></table></figure><p><strong><code>Константность</code></strong></p><p>Напечатаем тип параметра-аргумента:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">func</span><span class="params">(a : <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;typeinfo(typename a)&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"><span class="comment">//Output:</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="keyword">const</span></span></span><br></pre></td></tr></table></figure></p><p>По умолчанию к типу был добавлен спецификатор <code>const</code>, который не позволяет поменять значение аргумента. Его можно убрать, добавив ключевое слово <code>var</code>:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">func</span><span class="params">(var a: <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;typeinfo(typename a)&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"><span class="comment">//Output</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br></pre></td></tr></table></figure></p><p>При выборе перегрузки, константная и неконстантная версия, в отличие от C++, не имеют приоритета друг перед другом и при нахождении двух вариантов функции <code>daScript</code> выдаст ошибку (<a href="https://dascript.org/doc/reference/language/functions.html#function-overloading" target="_blank" rel="noopener">Правила выбора функции</a>).<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var a: <span class="keyword">int</span></span><br><span class="line">func(a)</span><br><span class="line"><span class="comment">//Output</span></span><br><span class="line"><span class="number">30304</span>: too many matching functions <span class="keyword">or</span> generics func</span><br><span class="line">candidates:</span><br><span class="line">        func ( a : <span class="keyword">int</span> <span class="keyword">const</span> ) : <span class="keyword">void</span> at generics.das:<span class="number">3</span>:<span class="number">4</span> <span class="comment">//принимает int и int const</span></span><br><span class="line">        func ( a : <span class="keyword">int</span> -<span class="keyword">const</span> ) : <span class="keyword">void</span> at generics.das:<span class="number">9</span>:<span class="number">4</span> <span class="comment">//-const читается как "удалить у типа спецификатор const"</span></span><br></pre></td></tr></table></figure></p><p>Для того, чтобы daScript различил функции, можно добавить <a href="https://dascript.org/doc/reference/language/generic_programming.html#type-contracts-and-type-operations" target="_blank" rel="noopener">спецификатор типа</a> <code>== const</code> (“константность аргумента должна совпадать).<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">func</span><span class="params">(a : <span class="keyword">int</span> ==<span class="keyword">const</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;typeinfo(typename a)&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">def <span class="title">func</span><span class="params">(var a : <span class="keyword">int</span> ==<span class="keyword">const</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;typeinfo(typename a)&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">[export]</span><br><span class="line">def main</span><br><span class="line">    var a: <span class="keyword">int</span></span><br><span class="line">    func(a)</span><br><span class="line">    func(<span class="number">1</span>)</span><br><span class="line"><span class="comment">//Output:</span></span><br><span class="line"><span class="keyword">int</span> ==<span class="keyword">const</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> ==<span class="keyword">const</span></span><br></pre></td></tr></table></figure></p><p><strong><code>Ссылки</code></strong></p><p>В предыдущем примере аргумент передавался по значению, поэтому даже <code>var int</code> не позволяет изменить переданную переменную (меняется <strong>значение аргумента</strong>, а не оригинальная переменная). Возможно передать аргумент по ссылке:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">func</span><span class="params">(var a : <span class="keyword">int</span>&amp;)</span></span></span><br><span class="line"><span class="function">    a </span>= <span class="number">42</span></span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main</span><br><span class="line">    var a: <span class="keyword">int</span></span><br><span class="line">    func(a)</span><br><span class="line">    print(<span class="string">"&#123;a&#125;\n"</span>)</span><br><span class="line"><span class="comment">//Output: 42</span></span><br></pre></td></tr></table></figure></p><p><strong> Все непримитивные типы передаются по ссылке, независимо от того, был ли описан аргумент со спецификатором <code>&amp;</code> или без него. </strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">    <span class="title">a</span> :</span> <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">func</span><span class="params">(var arg : A)</span></span></span><br><span class="line">    arg.a = 42</span><br><span class="line">    print(<span class="string">"&#123;typeinfo(typename arg)&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main</span><br><span class="line">    var a : A</span><br><span class="line">    func(a)</span><br><span class="line">    print(<span class="string">"&#123;a&#125;\n"</span>)</span><br><span class="line"><span class="comment">//Output</span></span><br><span class="line">A</span><br><span class="line">[[ <span class="number">42</span>]]</span><br></pre></td></tr></table></figure><p><em>(причём можно описать 2 перегруженные функции с аргуметами типа A и A&amp;, несмотря на то, что для структур семантически это будет идентичная запись)</em></p><p>При этом, как и с константностью, компилятор не различает приоритета перегрузки функций с аргументом-ссылкой и значением, и выдаёт ошибку неоднозначности разрешения перегрузки.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">func</span><span class="params">(var a: <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">    pass</span></span><br><span class="line"><span class="function">def <span class="title">func</span><span class="params">(var a : <span class="keyword">int</span>&amp;)</span></span></span><br><span class="line"><span class="function">    pass</span></span><br><span class="line"><span class="function"></span></span><br><span class="line">[export]</span><br><span class="line">def main</span><br><span class="line">    func(<span class="number">1</span>) <span class="comment">//ok</span></span><br><span class="line">    var a: <span class="keyword">int</span></span><br><span class="line">    func(a) <span class="comment">//30304: too many matching functions or generics func</span></span><br><span class="line">            <span class="comment">//candidates:</span></span><br><span class="line">            <span class="comment">//func ( a : int -const ) : void at generics.das:1:4</span></span><br><span class="line">            <span class="comment">//func ( a : int&amp; -const ) : void at generics.das:3:4</span></span><br></pre></td></tr></table></figure><p><strong><code>Контракты</code></strong></p><p>Макросы работают раньше разрешения перегрузки, что позволяет реализовать паттерн <a href="https://github.com/GaijinEntertainment/daScript/blob/e7992b384dad13c1a201f9eee1c6a6ae1e0cf8b8/daslib/contracts.das" target="_blank" rel="noopener">contracts</a> — произвольную функцию, которая предварительно проверяет тип аргументов:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">require daslib/contracts</span><br><span class="line"></span><br><span class="line">[!expect_ref(arg)]</span><br><span class="line"><span class="function">def <span class="title">func</span><span class="params">(var arg : <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;typeinfo(typename arg)&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">[expect_ref(arg)]</span><br><span class="line"><span class="function">def <span class="title">func</span><span class="params">(var arg : <span class="keyword">int</span>&amp;)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;typeinfo(typename arg)&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">[export]</span><br><span class="line">def main</span><br><span class="line">    var a: <span class="keyword">int</span></span><br><span class="line">    func(a)</span><br><span class="line">    func(<span class="number">1</span>)</span><br><span class="line"><span class="comment">//Output:</span></span><br><span class="line"><span class="keyword">int</span> <span class="comment">//must be int&amp;</span></span><br><span class="line"><span class="keyword">int</span></span><br></pre></td></tr></table></figure><p><a href="https://github.com/GaijinEntertainment/daScript/blob/master/examples/test/misc/contracts_example.das" target="_blank" rel="noopener">https://github.com/GaijinEntertainment/daScript/blob/master/examples/test/misc/contracts_example.das</a><br><em>вывод typeinfo, кажется, содержит <a href="https://github.com/GaijinEntertainment/daScript/issues/393" target="_blank" rel="noopener">баг</a></em></p><p><strong><code>Временные ссылки</code></strong></p><p>Кроме обычных ссылок в daScript есть временные ссылки, которые позволяют работать с объектами из C++-кода внутри блоков. Временная ссылка доступна только внутри блока, и не может быть сохранена вне его (но может быть передана в другую функцию, принимающую временные объекты).</p><p>Рассмотрим для примера C++ тип <code>Color</code> из <a href="https://github.com/GaijinEntertainment/daScript/blob/master/examples/tutorial/tutorial03.cpp#L15" target="_blank" rel="noopener">туториала к daScript</a>. Для него создаётся daScript-обёртка, в которую можно добавить декларацию конструктора и инициализатора с помощью паттерна <code>using</code> — в этом случае можно создать временную ссылку на тип, которая будет доступна только внутри блока: </p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//cpp</span></span><br><span class="line">Module_Tutorial03() : Module(<span class="string">"tutorial_03"</span>) &#123;   <span class="comment">// module name, when used from das file</span></span><br><span class="line">    ModuleLibrary lib;</span><br><span class="line">    ...</span><br><span class="line">    addCtorAndUsing&lt;Color&gt;(*<span class="keyword">this</span>, lib, <span class="string">"Color"</span>, <span class="string">"Color"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//das</span></span><br><span class="line"></span><br><span class="line">require tutorial_03</span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">printColor</span><span class="params">(c : Color)</span> <span class="comment">//same as Color&amp; as c is struct</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;typeinfo(typename c)&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">def <span class="title">printColor</span><span class="params">(c : Color#)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;typeinfo(typename c)&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">[export]</span><br><span class="line">def test</span><br><span class="line">    let c = [[Color]]</span><br><span class="line">    printColor(c)</span><br><span class="line">    <span class="keyword">using</span>() &lt;| $(var c_temp : Color#)</span><br><span class="line">        printColor(c_temp)</span><br><span class="line"><span class="comment">//Output</span></span><br><span class="line">tutorial_03::Color <span class="keyword">const</span></span><br><span class="line">tutorial_03::Color <span class="keyword">const</span>#</span><br></pre></td></tr></table></figure><p><strong>Если тип нельзя <a href="https://github.com/GaijinEntertainment/daScript/commit/9521fdba38c4f5ea422450c6b4979cc2808f58ef" target="_blank" rel="noopener">скопировать или переместить</a>, то <code>using</code> не будет не будет создавать временный тип — аргумент и так не сможет покинуть блок</strong></p><p>Чаще всего нет необходимости в раздельной обработке обычных и временных ссылок, в этом случае можно добавить к типу аргумента спецификатор <code>implicit</code>:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">printColor</span><span class="params">(c:Color implicit)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;typeinfo(typename c)&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"><span class="comment">//Output</span></span></span><br><span class="line"><span class="function">tutorial_03::Color <span class="keyword">const</span> implicit</span></span><br><span class="line"><span class="function">tutorial_03::Color <span class="keyword">const</span> implicit</span></span><br></pre></td></tr></table></figure><p>Небольшое отличие в том, как будет трактоваться аргумент:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">printColor</span><span class="params">(c:Color implicit)</span>    <span class="comment">// accepts Color and Color#, a will be treated as Color</span></span></span><br><span class="line"><span class="function">def <span class="title">printColor</span><span class="params">(c:Color# implicit)</span>   <span class="comment">// accepts Color and Color#, a will be treated as Color#</span></span></span><br></pre></td></tr></table></figure></p><p><strong><code>Указатели</code></strong></p><p>Как и в C++, указатели — это ссылки, которые могут указывать на <code>null</code>, также имеют чуть другую семантику, что позволяет уже без шаманства иметь перегрузки для значения и указателя.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">require daslib/safe_addr</span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">func</span><span class="params">(var a: <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;typeinfo(typename a)&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">def <span class="title">func</span><span class="params">(var a: <span class="keyword">int</span>?)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;typeinfo(typename a)&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">[export]</span><br><span class="line">def main</span><br><span class="line">    var a: <span class="keyword">int</span></span><br><span class="line">    var a_ptr: <span class="keyword">int</span>? = safe_addr(a)</span><br><span class="line">    func(a)</span><br><span class="line">    func(a_ptr)</span><br><span class="line"><span class="comment">//Output</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line"><span class="keyword">int</span>?</span><br></pre></td></tr></table></figure><p><strong><code>Приведение базовых типов</code></strong></p><p>Базовые типы не приводятся друг другу неявно, требуется явный вызов конструктора типа (<em>Explicit is better than implicit</em>).</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">func</span><span class="params">(a : <span class="keyword">int</span>)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function">def <span class="title">func</span><span class="params">(a : <span class="keyword">float</span>)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function">def <span class="title">func</span><span class="params">(a : int4)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function">def <span class="title">func</span><span class="params">(a : <span class="keyword">bool</span>)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function">def <span class="title">func</span><span class="params">(a : uint)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function">def <span class="title">func</span><span class="params">(a : int64)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main</span><br><span class="line">    func(<span class="number">1</span>) <span class="comment">//int</span></span><br><span class="line">    func(<span class="keyword">float</span>(<span class="number">1</span>)); func(<span class="number">1.0f</span>) <span class="comment">//float</span></span><br><span class="line">    func(int4(<span class="number">1</span>)) <span class="comment">//int4</span></span><br><span class="line">    func(<span class="literal">true</span>) <span class="comment">//bool</span></span><br><span class="line">    func(uint(<span class="number">1</span>)); func(<span class="number">1u</span>); func(<span class="number">0x1</span>) <span class="comment">//uint</span></span><br><span class="line">    func(int64(<span class="number">1</span>)); func(<span class="number">1l</span>) <span class="comment">//int64</span></span><br></pre></td></tr></table></figure><p><strong><code>Приведение классов/структур</code></strong></p><p>Для типов, поддерживающих наследование, неявно выполняется приведение указателей и ссылок от дочернего к родительскомму типу (<a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle" target="_blank" rel="noopener">LSP</a>).</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> </span></span><br><span class="line"><span class="class">    <span class="title">a</span> :</span> <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> :</span> A</span><br><span class="line">    b : <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">func</span><span class="params">(a : A)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;typeinfo(typename a)&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">[export]</span><br><span class="line">def main</span><br><span class="line">    var a : A</span><br><span class="line">    var b : B</span><br><span class="line">    func(a)</span><br><span class="line">    func(b)</span><br><span class="line"><span class="comment">//Output:</span></span><br><span class="line">A <span class="keyword">const</span></span><br><span class="line">A <span class="keyword">const</span></span><br></pre></td></tr></table></figure><p>Приведение типов структур (<code>cast/upcast/reinterpret</code>):<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var a : A</span><br><span class="line">var b : B</span><br><span class="line"></span><br><span class="line">var refA : A&amp; = a</span><br><span class="line">var refB : B&amp; = b</span><br><span class="line"></span><br><span class="line"><span class="comment">//downcast, safe</span></span><br><span class="line">refA = cast&lt;A&amp;&gt; refB </span><br><span class="line"><span class="comment">//upcase, unsafe</span></span><br><span class="line">unsafe</span><br><span class="line">    refB = upcast&lt;B&amp;&gt; refA</span><br><span class="line"><span class="comment">//reinterpret cast, VERY unsafe, can cast any</span></span><br><span class="line">unsafe</span><br><span class="line">    refA = reinterpret&lt;A&amp;&gt;(<span class="number">1</span>) <span class="comment">//will crash</span></span><br></pre></td></tr></table></figure></p><p><strong>При выборе перегрузки функции выбирается та, для которой нужно выполнить наименьшее количество преобразований (при равном количестве daScript выдаст ошибку неоднозначности выбора)</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> </span></span><br><span class="line"><span class="class">    <span class="title">a</span> :</span> <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> :</span> A</span><br><span class="line">    b: <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">func</span><span class="params">(var a : A?)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"a: &#123;typeinfo(typename a)&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">def <span class="title">func</span><span class="params">(var b : B?)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"b: &#123;typeinfo(typename b)&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">def <span class="title">func4</span><span class="params">(var a,b,c,d: A?)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"AAAA\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">def <span class="title">func4</span><span class="params">(var a,b,c: A?; var d: B?)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"AAAB\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">def <span class="title">func4</span><span class="params">(var a,b : A?; var c: B?; var d: A?)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"AABA\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">def <span class="title">func4</span><span class="params">(var a,b,c,d: B?)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"BBBB\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">[export]</span><br><span class="line">def main</span><br><span class="line">    <span class="comment">//simple cases</span></span><br><span class="line">    var refA = <span class="keyword">new</span> A()</span><br><span class="line">    func(refA) <span class="comment">//a: A?</span></span><br><span class="line">    var refB = <span class="keyword">new</span> B()</span><br><span class="line">    func(refB) <span class="comment">//b: B?</span></span><br><span class="line">    var refAB = cast&lt;A?&gt; <span class="keyword">new</span> B()</span><br><span class="line">    func(refAB) <span class="comment">//a: A?</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//advanced cases</span></span><br><span class="line">    func4(refA, refA, refA, refA) <span class="comment">//shortest LSP to AAAA = 0</span></span><br><span class="line">    func4(refA, refA, refA, refB) <span class="comment">//shortest LSP to AAAB = 0</span></span><br><span class="line">    <span class="comment">//func4(refA, refA, refB, refB) //shortest LSP to AAAB/AABA = 1, conflict error</span></span><br><span class="line">    func4(refA, refB, refB, refA) <span class="comment">//shortest LSP to AABA = 1</span></span><br><span class="line">    func4(refB, refB, refB, refB) <span class="comment">//shortest LSP to BBBB = 0</span></span><br></pre></td></tr></table></figure><p><strong><code>explicit</code></strong></p><p>Для того, чтобы отключить LSP приведение типа аргумента, можно добавить ключевое слово <code>explicit</code>. Так </p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> </span></span><br><span class="line"><span class="class">    <span class="title">a</span> :</span> <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> :</span> A</span><br><span class="line">    b : <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">func</span><span class="params">(var a : A <span class="keyword">explicit</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;typeinfo(typename a)&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">[export]</span><br><span class="line">def main</span><br><span class="line">    var a : A</span><br><span class="line">    var b : B</span><br><span class="line">    func(a)   <span class="comment">//A</span></span><br><span class="line">    <span class="comment">//func(b) //invalid argument a (0). expecting A explicit -const, passing B&amp; -const</span></span><br></pre></td></tr></table></figure><p><strong><code>Приведение generic-типов</code></strong></p><p>В документации не описана работа с generic-типами (и не дано общее определение для них, также пока отсутствует возможность создания своих типов), но поиском по коду находятся такие встроенные типы (исключая те, которые связаны с оператором typeinfo и кастами):</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Функциональные объекты:</span><br><span class="line">block</span><br><span class="line">function</span><br><span class="line">lambda</span><br><span class="line"></span><br><span class="line">Коллекции:</span><br><span class="line">array</span><br><span class="line">table&lt;key&gt;</span><br><span class="line">table&lt;key, value&gt;</span><br><span class="line"></span><br><span class="line">iterator</span><br><span class="line">generator</span><br><span class="line">smart_ptr</span><br><span class="line">tuple</span><br><span class="line">variant</span><br></pre></td></tr></table></figure><p>Для таких типов, возможно явное LSP-приведение для типов их аргументов (<code>ковариантность</code>). Пример для функций:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> </span></span><br><span class="line"><span class="class">    <span class="title">a</span> :</span> <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> :</span> A</span><br><span class="line">    b : <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">func1</span><span class="params">(var a : A)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"a\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">def <span class="title">func2</span><span class="params">(var b : B)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"b\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">def <span class="title">highOrder</span><span class="params">(func: function&lt;(var a:A):<span class="keyword">void</span>&gt;)</span></span></span><br><span class="line"><span class="function">    <span class="title">invoke</span><span class="params">(func, [[B]])</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">[export]</span><br><span class="line">def main</span><br><span class="line">    highOrder(@@func1)</span><br><span class="line">    highOrder(cast&lt;function&lt;(var a:A):<span class="keyword">void</span>&gt;&gt; @@func2) <span class="comment">//возможно привести тип function&lt;(var b:B):void&gt; к function&lt;(var a:A):void&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Generic-функции"><a href="#Generic-функции" class="headerlink" title="Generic-функции"></a>Generic-функции</h2><p>Вернёмся к самому первому примеру — если мы хотим написать функцию, семантически одинаково обрабатывающую различные типы (например, выводящую значение типа с помощью функции <code>print</code>) для типов. Чтобы не реализовывать её для каждого нового типа, в языках программирования используется понятие generic-функций, которые могут производить конкретные функции для новых типов автоматически.</p><p><a href="https://habr.com/ru/company/piter/blog/656377/" target="_blank" rel="noopener">Обзор реализаций в языках</a>.</p><p>Шаблонные функции в C++ производят код конкретных функций на уровне текста, который отдаётся компилятору (если не ошибаюсь, компилятор visual studio в этом плане действительно генерирует полные копии, не остлеживаю возможных повторов, чтобы иметь больше простора для частных оптимизаций функции под конкретные типы, а clang чуть раньше начинает отслеживать потенциально идентичные реализации для экономии памяти).</p><p>Другой возможный вариант реализации в Java — “изображать” generic на высоком уровне для контроля типов, но оставлять одну реализацию (все объекты передаются по ссылке, добавляется overhead при работе с value-типами по боксингу/анбоксингу в обёртку).</p><p>Третий путь из C# — добавить поддержку generic-функций в виртуальную машину, в этом случае возможна комбинированная реализация — value-типы получают свои сгенерированные копии функций, а reference-типы — общую функцию. Также возможно инстанцировать новые версии функций в runtime. daScript близок к такому типу реализации generic-функций.</p><p><strong><code>Автоматический вывод типов</code></strong></p><p>Если не указан тип аргумента функции, daScript выводит его автоматически, пример функции id принимающей аргумент любого типа и возвращающий его:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">options <span class="built_in">log</span>=<span class="literal">true</span>, optimize=<span class="literal">false</span></span><br><span class="line"></span><br><span class="line">struct S1</span><br><span class="line">    a: <span class="keyword">int</span></span><br><span class="line">struct S2</span><br><span class="line">    a: <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">def id(T)</span><br><span class="line">    <span class="keyword">return</span> T</span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main</span><br><span class="line">    let a = id(<span class="number">1</span>)</span><br><span class="line">    let b = id(<span class="number">1.0f</span>)</span><br><span class="line">    let c = id([[S1]])</span><br><span class="line">    let d = id([[S2]])</span><br><span class="line"><span class="comment">//Output</span></span><br><span class="line"></span><br><span class="line">def `id ( T:<span class="keyword">int</span> <span class="keyword">const</span> <span class="keyword">explicit</span> ) : <span class="keyword">int</span> <span class="keyword">const</span></span><br><span class="line">        <span class="keyword">return</span> T</span><br><span class="line"></span><br><span class="line">def `id ( T:<span class="keyword">float</span> <span class="keyword">const</span> <span class="keyword">explicit</span> ) : <span class="keyword">float</span> <span class="keyword">const</span></span><br><span class="line">        <span class="keyword">return</span> T</span><br><span class="line"></span><br><span class="line">def `id ( T:S1 <span class="keyword">const</span> <span class="keyword">explicit</span> ) : S1 <span class="keyword">const</span></span><br><span class="line">        <span class="keyword">return</span> T</span><br><span class="line"></span><br><span class="line">def `id ( T:S2 <span class="keyword">const</span> <span class="keyword">explicit</span> ) : S2 <span class="keyword">const</span></span><br><span class="line">        <span class="keyword">return</span> T</span><br><span class="line"></span><br><span class="line">def <span class="keyword">public</span> main</span><br><span class="line">        let a:<span class="keyword">int</span> <span class="keyword">const</span> = __::`id(<span class="number">1</span>)</span><br><span class="line">        let b:<span class="keyword">float</span> <span class="keyword">const</span> = __::`id(<span class="number">1f</span>)</span><br><span class="line">        let c:S1 <span class="keyword">const</span> = __::`id([[S1 ]])</span><br><span class="line">        let d:S2 <span class="keyword">const</span> = __::`id([[S2 ]])</span><br></pre></td></tr></table></figure><p>По выводу текста сгенерированной программы понятна реализация. Символы подчёркивания перед именем функции <code>__::id</code> означают “взять реализацию функции только из текущего модуля” (<a href="https://dascript.org/doc/reference/language/modules.html#module-function-visibility" target="_blank" rel="noopener">линк</a>), идея будет рассмотрена далее.</p><p>Большая часть фич, связанных с generic-функциями, связана с тем, чтобы так или иначе задать или использовать информацию о типах.</p><p><strong><code>auto</code></strong></p><p>Определение для id более развернуто выглядит так:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">id</span><span class="params">(a:<span class="keyword">auto</span>)</span>: <span class="keyword">auto</span></span></span><br><span class="line"><span class="function">    <span class="keyword">return</span> a</span></span><br></pre></td></tr></table></figure></p><p>Такая форма синтаксиса позволяет задать для каждого из выводимых типов псевдоним, который можно использовать для сравнения типа или получения rtti информации. Несколько примеров:</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">//print typename</span></span><br><span class="line"><span class="function">def <span class="title">func</span><span class="params">(a : <span class="keyword">auto</span>(T))</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;typeinfo(typename type&lt;T&gt;)&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//generic sum, a and b must be same type</span></span></span><br><span class="line"><span class="function">def <span class="title">sum</span><span class="params">(a, b : <span class="keyword">auto</span>(T))</span></span></span><br><span class="line">    return a + b</span><br></pre></td></tr></table></figure><p><strong><code>Использование типа в качестве аргумента</code></strong></p><p>Можно передать информацию о типе в качестве аргумента шаблона, как обычный <code>auto</code> аргумент.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//generic linear interpolation between int types via cast to float type</span></span><br><span class="line"><span class="function">def <span class="title">lerpi</span><span class="params">(a, b : <span class="keyword">auto</span>(IntType); part : <span class="keyword">float</span>; tempCastType : <span class="keyword">auto</span>(CastType))</span></span></span><br><span class="line"><span class="function">    <span class="keyword">return</span> <span class="title">IntType</span><span class="params">(CastType(a) + CastType(b - a) * part)</span></span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">"&#123;lerpi(int2(0, 0), int2(4, 4), 0.5f, type&lt;float2&gt;)&#125;\n"</span>)</span> <span class="comment">// (2,2)</span></span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">"&#123;lerpi(int3(1, 2, 3), int3(2, 4, 7), 0.5f, type&lt;float3&gt;)&#125;\n"</span>)</span> <span class="comment">// (1,3,5)</span></span></span><br></pre></td></tr></table></figure><p><strong><code>Шаблоны для auto</code></strong></p><p>Различные формы <a href="https://dascript.org/doc/reference/language/generic_programming.html#type-contracts-and-type-operations" target="_blank" rel="noopener">ограчений</a> для типов аргументов auto. Примеры из доки</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">foo</span><span class="params">( a : <span class="keyword">auto</span>&amp;)</span>           <span class="comment">// accepts any type, passed by reference</span></span></span><br><span class="line"><span class="function">def <span class="title">foo</span><span class="params">( a : <span class="keyword">auto</span>[])</span>          <span class="comment">// accepts static array of any type of any size</span></span></span><br><span class="line"><span class="function">def <span class="title">foo</span><span class="params">( a : <span class="built_in">array</span>&lt;<span class="keyword">auto</span> -<span class="keyword">const</span>&gt;)</span>  <span class="comment">// matches any array, with non-const elements</span></span></span><br><span class="line"><span class="function"><span class="comment">//some tests</span></span></span><br><span class="line"><span class="function">def <span class="title">foo</span><span class="params">(a: tuple&lt;<span class="keyword">auto</span>; <span class="keyword">auto</span>; <span class="keyword">auto</span>&gt;)</span> <span class="comment">//tuple of 3 elements, any type</span></span></span><br><span class="line"><span class="function">def <span class="title">foo</span><span class="params">(a: function&lt;(a : <span class="keyword">auto</span>) : <span class="keyword">auto</span>&gt;)</span> <span class="comment">//any function with 1 argument</span></span></span><br><span class="line"><span class="function">def <span class="title">foo</span><span class="params">(a: table&lt;<span class="keyword">int</span>; <span class="keyword">auto</span>&gt;)</span> <span class="comment">//any tables with int keys</span></span></span><br></pre></td></tr></table></figure><p>Еще раз приведу <a href="https://dascript.org/doc/reference/language/functions.html#function-overloading" target="_blank" rel="noopener">ссылку</a> на правила выбора функций при наличии нескольких специализаций и перегрузок.</p><p><strong><code>Контракты</code></strong></p><p>Так же, как и к аргументам обычным функциям, к аргументам generic-функциям могут быть применены контракты, позволяющие в более общем виде описать ограничения для типа аргумента. Именно c generic-функциями видна вся мощь контрактов.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">require daslib/contracts</span><br><span class="line"></span><br><span class="line"><span class="comment">//accept any functions</span></span><br><span class="line">[expect_any_function(a)]</span><br><span class="line"><span class="function">def <span class="title">foo</span><span class="params">(a: <span class="keyword">auto</span>(T))</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;typeinfo(typename type&lt;T&gt;)&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//accept any tuples</span></span></span><br><span class="line">[expect_any_tuple(a)]</span><br><span class="line"><span class="function">def <span class="title">bar</span><span class="params">(a:<span class="keyword">auto</span>(T))</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;typeinfo(typename type&lt;T&gt;)&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">[export]</span><br><span class="line">def main</span><br><span class="line">    foo(@@(a : <span class="keyword">int</span>) =&gt; a)                       <span class="comment">//function&lt;(a:int const):int const&gt; const</span></span><br><span class="line">    foo(@@(a : <span class="keyword">int</span>; b: <span class="keyword">float</span>) =&gt; <span class="string">"hello world"</span>) <span class="comment">//function&lt;(a:int const;b:float const):string const&gt; const</span></span><br><span class="line">    bar([[<span class="keyword">auto</span> <span class="number">1</span> ,<span class="number">2.0f</span>, <span class="string">"test"</span>]])               <span class="comment">//tuple&lt;int;float;string&gt; const</span></span><br><span class="line">    bar([[<span class="keyword">auto</span> <span class="number">1</span>, <span class="number">1</span>]])                          <span class="comment">//tuple&lt;int;int&gt; const</span></span><br></pre></td></tr></table></figure><p>Контракты для одного аргумента могут комбинироваться с помощью операторов !, &amp;&amp;, || и ^^</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">require daslib/contracts</span><br><span class="line"></span><br><span class="line">[expect_any_function(arg) || expect_any_tuple(arg)]</span><br><span class="line"><span class="function">def <span class="title">func_or_tuple</span><span class="params">(var arg : <span class="keyword">auto</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;typeinfo(typename arg)&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//expect_any_array разрешает любые массивы, expect_dim - статические массивы</span></span></span><br><span class="line">[expect_any_array(arg) &amp;&amp; !expect_dim(arg)]</span><br><span class="line"><span class="function">def <span class="title">array_and_notdim</span><span class="params">(var arg : <span class="keyword">auto</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;typeinfo(typename arg)&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">[export]</span><br><span class="line">def main</span><br><span class="line">    func_or_tuple(@@(a : <span class="keyword">int</span>) =&gt; a)</span><br><span class="line">    func_or_tuple([[<span class="keyword">auto</span> <span class="number">1</span>, <span class="number">2.0</span>, <span class="string">"3"</span>]])</span><br><span class="line"></span><br><span class="line">    array_and_notdim([&#123; <span class="keyword">int</span>[] <span class="number">1</span>;<span class="number">2</span>;<span class="number">3</span> &#125;]) <span class="comment">//array&lt;int&gt; allowed</span></span><br><span class="line">    <span class="comment">//array_and_notdim([[ int[] 1;2;3 ]]) //int4[2] not allowed</span></span><br></pre></td></tr></table></figure><p><strong><code>Сумма типов</code></strong></p><p>Еще один способ задать ограничения для типа — перечислить разрешенные типы через символ <code>|</code> (<a href="https://dascript.org/doc/reference/language/generic_programming.html#options" target="_blank" rel="noopener">options</a> в доках):</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">foo</span><span class="params">(var a : <span class="keyword">int</span> | <span class="keyword">float</span> | <span class="built_in">string</span>)</span> <span class="comment">//accept int or float or string</span></span></span><br><span class="line"><span class="function">def <span class="title">foo</span><span class="params">(var a : <span class="built_in">array</span>&lt;<span class="keyword">int</span> | <span class="keyword">float</span>&gt;)</span> <span class="comment">//array of int of array of float</span></span></span><br><span class="line"><span class="function">def <span class="title">foo</span><span class="params">(a : function&lt;(a : <span class="keyword">auto</span>) : <span class="keyword">auto</span>&gt; | function&lt;(a, b : <span class="keyword">auto</span>) : <span class="keyword">auto</span>&gt;)</span> <span class="comment">//accept any function with 1 or 2 arguments</span></span></span><br><span class="line"><span class="function">def <span class="title">foo</span> <span class="params">(a : Bar <span class="keyword">explicit</span> | Foo)</span>   <span class="comment">// accept exactly Bar or anything inherited from Foo</span></span></span><br><span class="line"><span class="function">def <span class="title">foo</span> <span class="params">(a : Foo | #)</span> <span class="comment">//accept Foo and Foo#, looks like this short syntax only works with #</span></span></span><br></pre></td></tr></table></figure><p>Порядок проверки соответствия опций — слева направо:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">foo</span><span class="params">(var a : <span class="keyword">auto</span> | <span class="keyword">int</span>&amp;)</span> </span>&#123; a = <span class="number">84</span>; &#125;</span><br><span class="line"><span class="function">def <span class="title">bar</span><span class="params">(var a : <span class="keyword">int</span>&amp; | <span class="keyword">auto</span>)</span> </span>&#123; a = <span class="number">42</span>; &#125;</span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main</span><br><span class="line">    var a: <span class="keyword">int</span></span><br><span class="line">    foo(a) <span class="comment">// match foo(auto)</span></span><br><span class="line">    print(<span class="string">"&#123;a&#125;\n"</span>) <span class="comment">// a == 0</span></span><br><span class="line">    bar(a) <span class="comment">// match bar(int&amp;)</span></span><br><span class="line">    print(<span class="string">"&#123;a&#125;\n"</span>) <span class="comment">// a == 42</span></span><br></pre></td></tr></table></figure><p><strong><code>static_if</code></strong></p><p>Проверка наличия методов или полей структуры выполняется в момент инстанцирования generic-функции</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span></span></span><br><span class="line"><span class="class">    <span class="title">a</span> :</span> <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">foo</span><span class="params">(var s)</span></span></span><br><span class="line">    s.a = 42 //not check if s has field</span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main</span><br><span class="line">    var s : S</span><br><span class="line">    foo(s) <span class="comment">//ok</span></span><br></pre></td></tr></table></figure><p>Ошибка возникнет только в момент инстанциирования <code>foo</code> со структурой, не имеющей поля <code>a</code>. Проверить наличие полей или другую информацию о типе в время компиляции можно с помощью оператора <code>static_if</code>:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span></span></span><br><span class="line"><span class="class">    <span class="title">a</span> :</span> <span class="keyword">int</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">T</span></span></span><br><span class="line"><span class="class">    <span class="title">a</span> :</span> float4</span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">foo</span><span class="params">(var s)</span></span></span><br><span class="line"><span class="function">    static_if <span class="title">typeinfo</span><span class="params">(has_field&lt;a&gt; s)</span> &amp;&amp; <span class="params">(typeinfo(<span class="keyword">typename</span> s.a) == typeinfo(<span class="keyword">typename</span> type&lt;<span class="keyword">int</span> -<span class="keyword">const</span>&gt;))</span></span></span><br><span class="line">        s.a = 42</span><br><span class="line"></span><br><span class="line">var s : S</span><br><span class="line">foo(s) <span class="comment">//ok</span></span><br><span class="line">var t: T</span><br><span class="line">foo(t) <span class="comment">//also ok, but do nothing</span></span><br></pre></td></tr></table></figure><p><strong><code>Вызываемые макросы</code></strong></p><p>Более сложные конструкции вроде “вызвать конструктор того же типа, что и поле структуры <code>s.a</code> можно выразить с помощью макросов</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//generics macro</span></span><br><span class="line"><span class="keyword">module</span> generics_macro shared <span class="keyword">private</span></span><br><span class="line"></span><br><span class="line">[call_macro(name=<span class="string">"convert_to"</span>)]  <span class="comment">// convert_to(convertType, arg)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApplyMacro</span> :</span> AstCallMacro</span><br><span class="line">    <span class="comment">//! convert_to("float4", 42) -&gt; float4(42)</span></span><br><span class="line">    <span class="function">def <span class="keyword">override</span> <span class="title">visit</span> <span class="params">( prog:ProgramPtr; mod:Module?; var expr:smart_ptr&lt;ExprCallMacro&gt; )</span> : ExpressionPtr</span></span><br><span class="line">        var exprConstStr &lt;- unsafe(reinterpret&lt; smart_ptr&lt;ast::ExprConstString&gt;&amp;&gt; expr.arguments[0])</span><br><span class="line">        var call &lt;- <span class="keyword">new</span> [[ExprCall() name:=exprConstStr.value, at=expr.at]]</span><br><span class="line">        emplace_new(call.arguments, clone_expression(expr.arguments[<span class="number">1</span>]))</span><br><span class="line">        <span class="keyword">return</span> &lt;- call</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">require generics_macro</span><br><span class="line"></span><br><span class="line">def foo(var s)</span><br><span class="line">    static_if typeinfo(has_field&lt;a&gt; s)</span><br><span class="line">        static_if typeinfo(has_field&lt;a&gt; s)</span><br><span class="line">            static_if typeinfo(<span class="keyword">typename</span> s.a) == typeinfo(<span class="keyword">typename</span> type&lt;<span class="keyword">int</span> -<span class="keyword">const</span>&gt;)</span><br><span class="line">                s.a = <span class="number">42</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                s.a = convert_to(typeinfo(<span class="keyword">typename</span> s.a), <span class="number">42</span>) <span class="comment">// --&gt; s.a = float4(42)</span></span><br><span class="line"></span><br><span class="line">var t : T</span><br><span class="line">foo(t)</span><br><span class="line">print(<span class="string">"&#123;t&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Output:</span></span><br><span class="line">[[ <span class="number">42</span>,<span class="number">42</span>,<span class="number">42</span>,<span class="number">42</span>]]</span><br></pre></td></tr></table></figure><p><strong><code>[generic]</code></strong></p><p>daScript распознаёт обычные или generic-функции по синтаксису, но можно также явно обозначить функцию как generic:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">options <span class="built_in">log</span>=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">[generic]</span><br><span class="line">def func()</span><br><span class="line">    print(<span class="string">"hello"</span>)</span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main</span><br><span class="line">    func()</span><br><span class="line"></span><br><span class="line"><span class="comment">//Output:</span></span><br><span class="line"></span><br><span class="line">def <span class="keyword">private</span> `func</span><br><span class="line">        print(<span class="string">"hello"</span>,__context__)</span><br><span class="line"></span><br><span class="line"><span class="comment">// [modify_external]</span></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def <span class="keyword">public</span> main</span><br><span class="line">        __::`func()</span><br></pre></td></tr></table></figure><p>В таком случае вызов <code>func</code> будет преобразован в <code>__::</code>func` - вызов версии функции только из текущего модуля. Это используется в <a href="https://github.com/GaijinEntertainment/daScript/blob/87ab585fc3704896bff3eea71ab87e29f772be94/src/builtin/fio.das#L10" target="_blank" rel="noopener">некоторых функциях</a> стандартной библиотеки daslib, потому что если компилятор знает, что функция находится в том же модуле, что и вызывающий код, то может её оптимизировать — при AoT-компиляции генериуется не полноценный вызов через ABI (который может вести в другой не-AoT daScript модуль), а прямой вызов, что быстрее.</p><p><strong><code>[instance_function]</code></strong></p><p>С помощью макроса <code>[instance_function]</code> можно попросить явно специализировать generic-функцию с определенными типами:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">require daslib/instance_function</span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">func</span><span class="params">(a : <span class="keyword">auto</span>(TT))</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;typeinfo(typename a )&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">[instance_function(func, TT = "int const")]</span><br><span class="line"><span class="function">def <span class="title">print_int</span><span class="params">(a)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main</span><br><span class="line">    print_int(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><strong><code>Видимость модулей</code></strong></p><p>Для generic функций, которые подразумевают переопределение для новых кастомных типов в других модулях, необходимо добавлять префикс <code>_::</code> или <code>__::</code>, чтобы обозначить, что функций должна искаться в том модуле, который её вызывает.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//module1.das</span></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line"><span class="function">def <span class="title">call_func</span><span class="params">(a)</span></span></span><br><span class="line"><span class="function">    <span class="title">_::func</span><span class="params">(a)</span> <span class="comment">//func will be declared somewhere later</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//main.das</span></span></span><br><span class="line"><span class="function">require module1</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">struct S</span></span><br><span class="line"><span class="function">    a: <span class="keyword">int</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">def <span class="title">func</span><span class="params">(s: S)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;s&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">call_func</span><span class="params">(s)</span> <span class="comment">//module1::call_func will see and call main::func()</span></span></span><br></pre></td></tr></table></figure><p><code>__::</code> — подразумевает возможность определения функции только в том же модуле, что и вызывающий код (main)<br><code>_::</code> — допускает определение как в том же модуле, что и вызывающий код, так и в других модулях (main, module1 или другие модули)</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;Обобщенное
      
    
    </summary>
    
    
    
      <category term="dascript" scheme="http://spiiin.github.io/tags/dascript/"/>
    
  </entry>
  
  <entry>
    <title>daScript: ООП и всякое</title>
    <link href="http://spiiin.github.io/blog/1023396573/"/>
    <id>http://spiiin.github.io/blog/1023396573/</id>
    <published>2023-01-12T17:20:25.000Z</published>
    <updated>2023-01-21T12:26:52.990Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><h1 id="Структуры"><a href="#Структуры" class="headerlink" title="Структуры"></a>Структуры</h1><h2 id="Структуры-daScript-наследование"><a href="#Структуры-daScript-наследование" class="headerlink" title="Структуры daScript, наследование"></a>Структуры daScript, наследование</h2><p><a href="https://dascript.org/doc/reference/language/structs.html#struct-declaration" target="_blank" rel="noopener">https://dascript.org/doc/reference/language/structs.html#struct-declaration</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">V2</span></span></span><br><span class="line"><span class="class">    <span class="title">x</span> :</span> <span class="keyword">float</span> = <span class="number">-1.0f</span></span><br><span class="line">    y : <span class="keyword">float</span></span><br><span class="line"></span><br><span class="line">struct V3: V2</span><br><span class="line">    z = <span class="number">3.0f</span></span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main</span><br><span class="line">    let a : V3</span><br><span class="line">    print(<span class="string">"a = &#123;a&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line">    let b = V3()</span><br><span class="line">    print(<span class="string">"b = &#123;b&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line">    let c = [[V3 y = <span class="number">2.0f</span>]]</span><br><span class="line">    print(<span class="string">"c = &#123;c&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line">    let d = [[V3() y = <span class="number">2.0f</span>]]</span><br><span class="line">    print(<span class="string">"d = &#123;d&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line">    let e = [[V3() y = <span class="number">2.0f</span>, x = <span class="number">1.0f</span>]]</span><br><span class="line">    print(<span class="string">"e = &#123;e&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    let pd = <span class="keyword">new</span> [[V3() y = <span class="number">2.0f</span>]]</span><br><span class="line">    print(<span class="string">"pd = &#123;pd&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Output:</span></span><br><span class="line">a = [[ <span class="number">0.000000000</span>; <span class="number">0.000000000</span>; <span class="number">0.000000000</span>]]</span><br><span class="line">b = [[ <span class="number">-1.000000000</span>; <span class="number">0.000000000</span>; <span class="number">3.000000000</span>]]</span><br><span class="line">c = [[ <span class="number">0.000000000</span>; <span class="number">2.000000000</span>; <span class="number">0.000000000</span>]]</span><br><span class="line">d = [[ <span class="number">-1.000000000</span>; <span class="number">2.000000000</span>; <span class="number">3.000000000</span>]]</span><br><span class="line">e = [[ <span class="number">1.000000000</span>; <span class="number">2.000000000</span>; <span class="number">3.000000000</span>]]</span><br><span class="line">pd = [[ <span class="number">-1.000000000</span>; <span class="number">2.000000000</span>; <span class="number">3.000000000</span>]]</span><br></pre></td></tr></table></figure><p>a,b,c,d,e - структуры, размещенные на стеке. В зависимости от способа объявления можно пропускать инициализацию полей по умолчанию — круглые скобки в объявлении добавляют код инициализации (в порядке от родительской структуры к дочерним). Синтаксис с квадратными скобками позволяет изменить значения отдельных полей. Неинициализированные явно или по умолчанию поля инициализируются нулями — получить в качестве значений неинициализированный мусор нельзя.</p><p>Ещё несколько примеров комбинаций синтаксиса инициализации, в первом случае создаётся структура, во втором — массив структур, в третьем — итератор<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//where clause: post init function</span></span><br><span class="line">let f = [[V3 where $(var self) &#123;</span><br><span class="line">    self.x = <span class="number">11.0f</span>;</span><br><span class="line">    self.y = <span class="number">11.0f</span>;</span><br><span class="line">    self.z = <span class="number">11.0f</span>;</span><br><span class="line">&#125;]]</span><br><span class="line"></span><br><span class="line"><span class="comment">//array initialization, g_arr: V3[2]</span></span><br><span class="line">let g_arr = [[V3 </span><br><span class="line">    x=<span class="number">1.0f</span>, y=<span class="number">1.0f</span>, z=<span class="number">1.0f</span>;</span><br><span class="line">    x=<span class="number">2.0f</span>, y=<span class="number">2.0f</span>, z=<span class="number">2.0f</span></span><br><span class="line">]]</span><br><span class="line"></span><br><span class="line"><span class="comment">//array comprehesion, h_arr : iterator&lt;V3&gt;</span></span><br><span class="line">let h_iter &lt;- [[ <span class="keyword">for</span> i in range(<span class="number">0</span>, <span class="number">10</span>); [[V3 x=<span class="keyword">float</span>(i), y=<span class="keyword">float</span>(i), z=<span class="keyword">float</span>(i)]]; where (i&amp;<span class="number">1</span>)==<span class="number">1</span> ]]</span><br><span class="line">let g_iter &lt;- [[ <span class="keyword">for</span> i in range(<span class="number">0</span>, <span class="number">10</span>); invoke(&#123; let fi = <span class="keyword">float</span>(i); <span class="keyword">return</span> [[V3 x=fi, y=fi, z=fi]]; &#125;); where (i&amp;<span class="number">1</span>)==<span class="number">1</span> ]] <span class="comment">// same</span></span><br></pre></td></tr></table></figure></p><p>pd - указатель на структуру, размещенную в куче. Сама структура может быть инициализирована любым из перечисленных выше способов.</p><h2 id="Финализаторы"><a href="#Финализаторы" class="headerlink" title="Финализаторы"></a>Финализаторы</h2><p><a href="https://dascript.org/doc/reference/language/finalizers.html#finalizers" target="_blank" rel="noopener">https://dascript.org/doc/reference/language/finalizers.html#finalizers</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var d = [[V3() y = <span class="number">2.0f</span>]]</span><br><span class="line">print(<span class="string">"d = &#123;d&#125;\n"</span>)</span><br><span class="line"><span class="keyword">delete</span> d</span><br><span class="line">print(<span class="string">"d = &#123;d&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line">var pd = <span class="keyword">new</span> [[V3() y = <span class="number">2.0f</span>]]</span><br><span class="line">print(<span class="string">"pd = &#123;pd&#125;\n"</span>)</span><br><span class="line">unsafe &#123; <span class="keyword">delete</span> pd; &#125;</span><br><span class="line">print(<span class="string">"pd = &#123;pd&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Output</span></span><br><span class="line">d = [[ <span class="number">-1.000000000</span>; <span class="number">2.000000000</span>; <span class="number">3.000000000</span>]]</span><br><span class="line">d = [[ <span class="number">0.000000000</span>; <span class="number">0.000000000</span>; <span class="number">0.000000000</span>]]</span><br><span class="line">pd = [[ <span class="number">-1.000000000</span>; <span class="number">2.000000000</span>; <span class="number">3.000000000</span>]]</span><br><span class="line">pd = null</span><br></pre></td></tr></table></figure><p>Финализатор по умолчанию для структуры зануляет память (в порядке от потомков к родителям, при необходимости зовёт финализаторы для членов структуры в порядке объявления). Для указателей — после зануления полей структуры дополнительно меняет адрес указателя на null. Финализаторы для структур и классов зовутся вручную. Финализаторы не освобождают память, на которую указывает объект.</p><h2 id="Освобождение-памяти"><a href="#Освобождение-памяти" class="headerlink" title="Освобождение памяти"></a>Освобождение памяти</h2><p>Модель памяти по умолчанию в daScript не подразумевает очистки памяти в ходе выполнения скрипта, за очистку отвечает хост-приложение, которое может просто освободить всю память контекста целиком — пересоздание контекстов by design быстро и эффективно, так что такой способ предпочтительный.</p><p>Но можно настроить поведение контекста опцией <code>persistent_heap</code>:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">options persistent_heap = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">var pd = <span class="keyword">new</span> [[V3() y = <span class="number">2.0f</span>]]</span><br><span class="line">var pd2 = pd</span><br><span class="line">unsafe</span><br><span class="line">    print(<span class="string">"addr(pd) = &#123;reinterpret&lt;uint&gt;(pd)&#125;\n"</span>)</span><br><span class="line">    print(<span class="string">"addr(pd2) = &#123;reinterpret&lt;uint&gt;(pd2)&#125;\n"</span>)</span><br><span class="line">    <span class="keyword">delete</span> pd</span><br><span class="line">pd2.x = <span class="number">33.0f</span></span><br><span class="line">print(<span class="string">"pd2 = &#123;pd2&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Output</span></span><br><span class="line">addr(pd) = <span class="number">0xf1909e10</span></span><br><span class="line">addr(pd2) = <span class="number">0xf1909e10</span></span><br><span class="line">pd2 = [[ <span class="number">33.000000000</span>; <span class="number">-431602080.000000000</span>; <span class="number">-431602080.000000000</span>]] <span class="comment">//мусор</span></span><br></pre></td></tr></table></figure><p>Я включил опцию <code>DAS_SANITIZER</code> при сборке daScript, чтобы после освобождения объектов в случае с persistent_heap память перезаписывалась мусорными значениями (0xCD, -431602080 если интерпретировать 0xCDCDCDCD как float-значение). В данном случае программа по счастливому стечению обстоятельств не упала, но благодаря санитайзеру видно, что указатель pd2 после удаления pd стал висячим — указывает на свободную память, которая могла бы быть выделена другому объекту (объекту daScript того же контекста в случае <code>persistent_heap=false</code>, или любому другому объекту хост-приложения с <code>persistent_heap=true</code>).</p><p>Более “злобный” вариант примера:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var pd = <span class="keyword">new</span> [[V3() y = <span class="number">2.0f</span>]]</span><br><span class="line">var pd2 = pd</span><br><span class="line">unsafe &#123; <span class="keyword">delete</span> pd; &#125;</span><br><span class="line">var pd3 = <span class="keyword">new</span> [[V3() x = <span class="number">33.0f</span>, y = <span class="number">33.0f</span>, z = <span class="number">33.0f</span>]]</span><br><span class="line">pd2.x = <span class="number">-100.0f</span> <span class="comment">// &lt;----- kaboom!</span></span><br><span class="line">print(<span class="string">"pd2 = &#123;pd2&#125;\n"</span>)</span><br><span class="line">print(<span class="string">"pd3 = &#123;pd3&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Output</span></span><br><span class="line">pd2 = [[ <span class="number">-100.000000000</span>; <span class="number">33.000000000</span>; <span class="number">33.000000000</span>]]</span><br><span class="line">pd3 = [[ <span class="number">-100.000000000</span>; <span class="number">33.000000000</span>; <span class="number">33.000000000</span>]]</span><br></pre></td></tr></table></figure><br>После освобождения память на которую указывали pd и pd2 была повторно отдана новому объекту, на который указывает pd3. Этот объект теперь может поменяться через указатель pd2. Должно быть понятно, насколько unsafe операция удаления — код стал насколько же опасным (но и настолько же быстрым), как и код на языке си.</p><h2 id="Кастомные-финализаторы"><a href="#Кастомные-финализаторы" class="headerlink" title="Кастомные финализаторы"></a>Кастомные финализаторы</h2><p>Финализатор можно переопределить, пример: финализатор для структуры V2</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">finalize</span><span class="params">(var v : V2)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"kill V2 &#123;v&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">var d </span>= [[ V3 x = <span class="number">11.0f</span>, y = <span class="number">22.0f</span>, z = <span class="number">33.0f</span>]]</span><br><span class="line"><span class="keyword">delete</span> d</span><br><span class="line">print(<span class="string">"d = &#123;d&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Output</span></span><br><span class="line">kill V2 [[ <span class="number">11.000000000</span>; <span class="number">22.000000000</span>]]</span><br><span class="line">d = [[ <span class="number">11.000000000</span>; <span class="number">22.000000000</span>; <span class="number">33.000000000</span>]]</span><br></pre></td></tr></table></figure><p>Вместо финализатора зануления по умолчанию вызывается функция, логгирующая поле. Также можно заметить неочевидную вещь (если думать о финализаторах как о деструкторах, но лучше не думать) — финализаторы не зовутся в порядке от потомков к предкам, а как работают как обычные функции, daScript нашёл подходящую функцию, принимающую тип V2, и не вызвал зануления также и у поля z - т.е. финализатор родительской структуры “подошёл” к дочерней.</p><p>Более похожий на порядок вызова деструкторов в C/C++ код<br><blockquote><p>(<strong>ещё раз, финализаторы — это не деструкторы, они вызываются только при явном вызове оператора delete!</strong>)</p></blockquote></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">finalize</span><span class="params">(var v : V2 <span class="keyword">explicit</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"kill V2 &#123;v&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">def <span class="title">finalize</span><span class="params">(var v : V3 <span class="keyword">explicit</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">finalize</span><span class="params">(cast&lt;V2&gt; v)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"kill V3 &#123;v&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">[export]</span><br><span class="line">def main</span><br><span class="line">    var d = [[ V3 x = <span class="number">11.0f</span>, y = <span class="number">22.0f</span>, z = <span class="number">33.0f</span>]]</span><br><span class="line">    <span class="keyword">delete</span> d</span><br><span class="line">    print(<span class="string">"d = &#123;d&#125;\n"</span>)</span><br><span class="line"><span class="comment">//Output</span></span><br><span class="line">kill V2 [[ <span class="number">11.000000000</span>; <span class="number">22.000000000</span>]]</span><br><span class="line">kill V3 [[ <span class="number">11.000000000</span>; <span class="number">22.000000000</span>; <span class="number">33.000000000</span>]]</span><br><span class="line">d = [[ <span class="number">11.000000000</span>; <span class="number">22.000000000</span>; <span class="number">33.000000000</span>]]</span><br></pre></td></tr></table></figure><p>daScript не позволяет каст к дочерним типам <code>explicit</code>-аргументов.</p><p>Вместо перегрузки <code>finalize</code> можно перегрузить <code>def operator delete(var v : V2 explicit)</code> — семантически более точно описывает, что для структур код финализатора будет вызван только в момент явного вызова оператора <code>delete</code>.</p><h2 id="Методы"><a href="#Методы" class="headerlink" title="Методы"></a>Методы</h2><p>Методы не могут быть объявлены при объявлении структур, но структуры могут хранить указатели на функции</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">V2</span></span></span><br><span class="line"><span class="class">    <span class="title">x</span> :</span> <span class="keyword">float</span></span><br><span class="line">    y : <span class="keyword">float</span></span><br><span class="line">    <span class="built_in">set</span> = @@<span class="built_in">set</span></span><br><span class="line"></span><br><span class="line">var a = V2()</span><br><span class="line">a |&gt; <span class="built_in">set</span>(<span class="number">1.0f</span>, <span class="number">2.0f</span>) <span class="comment">//call function via pipe syntax</span></span><br><span class="line">invoke(a.<span class="built_in">set</span>, a, <span class="number">1.0f</span>, <span class="number">2.0f</span>)  <span class="comment">// exactly same thing as above</span></span><br><span class="line">a-&gt;<span class="built_in">set</span>(<span class="number">1.0f</span>, <span class="number">2.0f</span>)  <span class="comment">// this one can call something else, if overridden in derived class.</span></span><br></pre></td></tr></table></figure><p>Потомок может переопределить функцию</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">V2</span></span></span><br><span class="line"><span class="class">    <span class="title">x</span> :</span> <span class="keyword">float</span></span><br><span class="line">    y : <span class="keyword">float</span></span><br><span class="line">    <span class="built_in">set</span> = @@<span class="built_in">set</span></span><br><span class="line">struct V3: V2</span><br><span class="line">    z : <span class="keyword">float</span></span><br><span class="line">    <span class="keyword">override</span> <span class="built_in">set</span> = cast&lt;<span class="keyword">auto</span>&gt; @@set_v3</span><br><span class="line">    </span><br><span class="line">def <span class="built_in">set</span>(var thisV: V2; X, Y: <span class="keyword">float</span>)</span><br><span class="line">    with thisV</span><br><span class="line">        x = X</span><br><span class="line">        y = Y</span><br><span class="line"></span><br><span class="line">def set_v3(var thisV: V3; X, Y: <span class="keyword">float</span>)</span><br><span class="line">    <span class="built_in">set</span>(cast&lt;V2&gt; thisV, X, Y)</span><br><span class="line">    with thisV</span><br><span class="line">        z = <span class="number">3.0f</span></span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main</span><br><span class="line">    var a = V3()</span><br><span class="line">    a |&gt; set_v3(<span class="number">1.0f</span>, <span class="number">2.0f</span>) <span class="comment">//non virtual call</span></span><br><span class="line">    invoke(a.<span class="built_in">set</span>, a, <span class="number">1.0f</span>, <span class="number">2.0f</span>)  <span class="comment">// exactly same thing as above</span></span><br><span class="line">    a-&gt;<span class="built_in">set</span>(<span class="number">1.0f</span>, <span class="number">2.0f</span>)  <span class="comment">// this one can call something else, if overridden in derived class.</span></span><br></pre></td></tr></table></figure><p>(<a href="https://github.com/GaijinEntertainment/daScript/blob/master/examples/test/unit_tests/override.das" target="_blank" rel="noopener">https://github.com/GaijinEntertainment/daScript/blob/master/examples/test/unit_tests/override.das</a>)</p><p>daScript позволяет создать две перегрузки функции set (а не определять дополнительное имя <code>set_v3</code>), принимающие V2 и V3, тогда можно переписать пример без использования дополнительного имени, с уточнением типа функции set перед кастом и последующим автоматическим приведением этого указателя к правильному типу, определённому в V2:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">V2</span></span></span><br><span class="line"><span class="class">    <span class="title">x</span> :</span> <span class="keyword">float</span></span><br><span class="line">    y : <span class="keyword">float</span></span><br><span class="line">    <span class="built_in">set</span> = @@&lt;(var thisV: V2; X, Y: <span class="keyword">float</span>):<span class="keyword">void</span>&gt; <span class="built_in">set</span></span><br><span class="line">struct V3: V2</span><br><span class="line">    z : <span class="keyword">float</span></span><br><span class="line">    <span class="keyword">override</span> <span class="built_in">set</span> = cast&lt;<span class="keyword">auto</span>&gt; @@&lt;(var thisV: V3; X, Y: <span class="keyword">float</span>):<span class="keyword">void</span>&gt; <span class="built_in">set</span> <span class="comment">//&lt;------ cast</span></span><br><span class="line">    </span><br><span class="line">def <span class="built_in">set</span>(var thisV: V2 <span class="keyword">explicit</span>; X, Y: <span class="keyword">float</span>)</span><br><span class="line">    with thisV</span><br><span class="line">        x = X</span><br><span class="line">        y = Y</span><br><span class="line"></span><br><span class="line">def <span class="built_in">set</span>(var thisV: V3; X, Y: <span class="keyword">float</span>)</span><br><span class="line">    <span class="built_in">set</span>(cast&lt;V2&gt; thisV, X, Y)</span><br><span class="line">    with thisV</span><br><span class="line">        z = <span class="number">3.0f</span></span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main</span><br><span class="line">    var a = V3()</span><br><span class="line">    a |&gt; <span class="built_in">set</span>(<span class="number">1.0f</span>, <span class="number">2.0f</span>) <span class="comment">//virtual call</span></span><br><span class="line">    invoke(a.<span class="built_in">set</span>, a, <span class="number">1.0f</span>, <span class="number">2.0f</span>)  <span class="comment">// exactly same thing as above</span></span><br><span class="line">    a-&gt;<span class="built_in">set</span>(<span class="number">1.0f</span>, <span class="number">2.0f</span>)</span><br><span class="line">    print(<span class="string">"&#123;a&#125;\n"</span>)</span><br></pre></td></tr></table></figure><p>Здесь <code>explicit</code> в первом объявлении свободной функции <code>set</code> позволяет сделать некоторую магию — несмотря на то, что эта функция “пропускает” только указатели на V2, это позволяет однозначно выделить эту функцию в приведении <code>set = @@&lt;(var thisV: V2; X, Y: float):void&gt; set</code> среди двух прегруженных (иначе возникла бы неоднозначность — обе приводились бы с одинаковым приоритетом, и daScript выдавал бы ошибку). Но при этом сигнатура функции <code>V2&#39;set</code> уже не содержит этого <code>explicit</code> (её тип выводится автоматически по правой части выражения, где явно указана сигнатура без <code>explicit</code>). Таким образом <code>V2&#39;set</code> работает как виртуальная функция — может принимать первым аргументом как <code>V2</code>, так и её потомков, которые не переопределили функцию.</p><h1 id="Классы"><a href="#Классы" class="headerlink" title="Классы"></a>Классы</h1><p><a href="https://dascript.org/doc/reference/language/classes.html#classes" target="_blank" rel="noopener">https://dascript.org/doc/reference/language/classes.html#classes</a></p><p>Классы в daScript — это структуры “на стероидах”. Немного отличий:</p><ul><li>Класс может быть отнаследован от структуры, но структура не может быть унаследована от класса (связано с тем, что классы могут иметь инициализаторы)</li><li>Объявление локального класса на стеке небезопасно (требует явного unsafe)</li></ul><p>Методы <a href="https://dascript.org/doc/reference/language/structs.html#structure-function-members" target="_blank" rel="noopener">реализованы</a> как указатели на функции, но с возможностью объявлять их в теле класса и переопределять с помощью ключевого слова <code>override</code> без явного каста типа метода, как было со структурами</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">V2</span></span></span><br><span class="line"><span class="class">    <span class="title">x</span> :</span> <span class="keyword">float</span></span><br><span class="line">    y : <span class="keyword">float</span></span><br><span class="line">    <span class="function">def <span class="title">set</span><span class="params">(X, Y: <span class="keyword">float</span>)</span></span></span><br><span class="line"><span class="function">        x </span>= X</span><br><span class="line">        y = Y</span><br><span class="line">class V3: V2</span><br><span class="line">    z : <span class="keyword">float</span></span><br><span class="line">    def <span class="keyword">override</span> <span class="built_in">set</span>(X, Y: <span class="keyword">float</span>)</span><br><span class="line">        V2`<span class="built_in">set</span>(self, X, Y)</span><br><span class="line">        z = <span class="number">3.0f</span></span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main</span><br><span class="line">    var a = <span class="keyword">new</span> V3()</span><br><span class="line">    a-&gt;<span class="built_in">set</span>(<span class="number">1.0f</span>, <span class="number">2.0f</span>) <span class="comment">//V3`set(*a, 1.0f, 2.0f)</span></span><br><span class="line">    print(<span class="string">"a = &#123;a&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Output</span></span><br><span class="line">a = [[ <span class="number">0x29990d19b90</span>; V3<span class="number">'</span>__finalize<span class="comment">/*V3'__finalize S&lt;::V3&gt;*/</span>; <span class="number">1.000000000</span>; <span class="number">2.000000000</span>; V3`<span class="built_in">set</span><span class="comment">/*V3`set S&lt;::V3&gt; Cf Cf*/</span>; <span class="number">3.000000000</span>]]</span><br></pre></td></tr></table></figure><p>Можно заметить, что имя объявленной внутри класса-функции манглится с помощью префикса-имени класса (<code>set -&gt; V2&#39;set</code>). Также внутри метода доступен указатель <code>self</code>, неявно передаваемый первым аргументов в методы класса.</p><p>Стоит более детально рассмотреть вывод результата.</p><h2 id="Порядок-полей-объекта-в-памяти"><a href="#Порядок-полей-объекта-в-памяти" class="headerlink" title="Порядок полей объекта в памяти"></a>Порядок полей объекта в памяти</h2><p><a href="https://dascript.org/doc/reference/language/classes.html#implementation-details" target="_blank" rel="noopener">https://dascript.org/doc/reference/language/classes.html#implementation-details</a></p><p>Содержимое <code>a</code>:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; [[</span><br><span class="line">    0x29990d19b90; &#x2F;&#x2F;указатель на rtti информацию</span><br><span class="line">    V3&#39;__finalize&#x2F;*V3&#39;__finalize S&lt;::V3&gt;*&#x2F;;  &#x2F;&#x2F;указатель на функцию-финализатор</span><br><span class="line">    1.000000000; &#x2F;&#x2F;x</span><br><span class="line">    2.000000000; &#x2F;&#x2F;y</span><br><span class="line">    V3&#96;set&#x2F;*V3&#96;set S&lt;::V3&gt; Cf Cf*&#x2F;; &#x2F;&#x2F;указатель на виртуальную функцию set</span><br><span class="line">    3.000000000 &#x2F;&#x2F;z</span><br><span class="line">]]</span><br></pre></td></tr></table></figure></p><p>Комментарии после имён функций — замангленное имя функции и её сигнатуры (аргументы и результаты). </p><blockquote><p>Расположение в памяти серьёзно отличается от C++ — указатели на виртуальные функции хранятся не в отдельной таблице (vtable), а в каждом объекте класса в том порядке, в котором были объявлены функции. Это позволяет убрать один уровень индирекции при вызове функций (не нужно идти за адресом в виртуальную таблицу) и изменять адреса функций динамически для каждого отдельного объекта, но увеличивает расходы памяти на хранение указателей, и также может повлиять на выравнивание и padding между полями.</p></blockquote><p>Тем не менее, для модификации порядка данных структур возможно написать собственный макрос, который будет хранить функции в самостоятельно сгенерированной таблице или выносить указатели на функции в конец структуры.<br><a href="/blog/1547564887/" title="daScript macro">daScript macro</a> — пример макроса перестановки порядка полей при определении структур</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">    unsafe</span><br><span class="line">        print(</span><br><span class="line"><span class="string">"\nsizeof(a) = &#123;typeinfo(sizeof type&lt;V3&gt;)&#125;\n</span></span><br><span class="line"><span class="string">offset __rtti      = &#123;typeinfo(offsetof&lt;__rtti&gt; type&lt;V3&gt;)&#125; &#123;reinterpret&lt;uint&gt;  addr(a.__rtti)&#125; </span></span><br><span class="line"><span class="string">offset __finalize  = &#123;typeinfo(offsetof&lt;__finalize &gt; type&lt;V3&gt;)&#125; &#123;reinterpret&lt;uint&gt;  addr(a.__finalize )&#125; </span></span><br><span class="line"><span class="string">offset x           = &#123;typeinfo(offsetof&lt;x&gt; type&lt;V3&gt;)&#125; &#123;reinterpret&lt;uint&gt;  addr(a.x)&#125;</span></span><br><span class="line"><span class="string">offset y           = &#123;typeinfo(offsetof&lt;y&gt; type&lt;V3&gt;)&#125; &#123;reinterpret&lt;uint&gt; addr(a.y)&#125;</span></span><br><span class="line"><span class="string">offset set         = &#123;typeinfo(offsetof&lt;set&gt; type&lt;V3&gt;)&#125; &#123;reinterpret&lt;uint&gt; addr(a.set)&#125;</span></span><br><span class="line"><span class="string">offset z           = &#123;typeinfo(offsetof&lt;z&gt; type&lt;V3&gt;)&#125; &#123;reinterpret&lt;uint&gt; addr(a.z)&#125;\n"</span></span><br><span class="line">        )</span><br><span class="line">Output:</span><br><span class="line"><span class="keyword">sizeof</span>(a) = <span class="number">40</span></span><br><span class="line">offset __rtti      = <span class="number">0</span>  <span class="number">0x4adb5f80</span></span><br><span class="line">offset __finalize  = <span class="number">8</span>  <span class="number">0x4adb5f88</span></span><br><span class="line">offset x           = <span class="number">16</span> <span class="number">0x4adb5f90</span></span><br><span class="line">offset y           = <span class="number">20</span> <span class="number">0x4adb5f94</span></span><br><span class="line">offset set1        = <span class="number">24</span> <span class="number">0x4adb5f98</span></span><br><span class="line">offset z           = <span class="number">32</span> <span class="number">0x4adb5fa0</span></span><br></pre></td></tr></table></figure><p>Существует также макрос <code>[cpp_layout]</code>, который не меняет порядок членов класса/структуры, но добавляет дополнительное правило выравнивания, как делают С/C++ — в конце родительской структуры будет оставлено пространство для её выравнивания по максимальному выравниванию членов структуры — например, если добавить в конце V2 поле на 4 байта <code>padding: uint8[4]</code>, то из-за выравнивания структуры в 8 байт (из-за указателей на 64-битной платформе), поле z, будет добавлено с отступом в 8 байт (без макроса daScript без проблем “встраивает” это поле сразу за 4-байтным отступом).</p><h2 id="Переопределение-метода-в-экземпляре-класса"><a href="#Переопределение-метода-в-экземпляре-класса" class="headerlink" title="Переопределение метода в экземпляре класса"></a>Переопределение метода в экземпляре класса</h2><p>Как было замеченно выше, каждый экземпляр класса/структуры хранит собственные копии указателей на функции, так что можно переопределить метод не на уровне класса-потомка, а в экземпляре класса (в пост-инициализаторе, или в любой момент после создания):<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">V2</span></span></span><br><span class="line"><span class="class">    <span class="title">x</span> :</span> <span class="keyword">float</span></span><br><span class="line">    y : <span class="keyword">float</span></span><br><span class="line">    <span class="function">def <span class="title">set</span><span class="params">(X, Y: <span class="keyword">float</span>)</span></span></span><br><span class="line"><span class="function">        x </span>= X</span><br><span class="line">        y = Y</span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main</span><br><span class="line">    let fn &lt;- @@ &lt;| ( a : <span class="keyword">int</span> )</span><br><span class="line">        <span class="keyword">return</span> a </span><br><span class="line"></span><br><span class="line">    unsafe</span><br><span class="line">        <span class="comment">//inplace init syntax</span></span><br><span class="line">        var v_customset = [[ V2() </span><br><span class="line">            <span class="built_in">set</span> &lt;- @@ (var self : V2; X,Y : <span class="keyword">float</span>) &#123;</span><br><span class="line">                self.x = X * <span class="number">100.0f</span>;</span><br><span class="line">                self.y = Y * <span class="number">100.0f</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        ]]</span><br><span class="line">        v_customset-&gt;<span class="built_in">set</span>(<span class="number">1.0f</span>, <span class="number">2.0f</span>)</span><br><span class="line">        print(<span class="string">"&#123;v_customset.x&#125;, &#123;v_customset.y&#125;\n"</span>)</span><br><span class="line">        <span class="comment">//Output: 100.000000000, 200.000000000</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//reset after construction, pipe + block syntax</span></span><br><span class="line">        v_customset.<span class="built_in">set</span> = @@ &lt;| (var self : V2; X,Y : <span class="keyword">float</span>)</span><br><span class="line">            self.x = X * <span class="number">200.0f</span></span><br><span class="line">            self.y = Y * <span class="number">200.0f</span></span><br><span class="line">        print(<span class="string">"&#123;v_customset.x&#125;, &#123;v_customset.y&#125;\n"</span>)</span><br><span class="line">        <span class="comment">//Output: 200.000000000, 400.000000000</span></span><br></pre></td></tr></table></figure><br><em>(более практичное применение этого — паттерны типа event/callback)</em></p><h2 id="RTTI"><a href="#RTTI" class="headerlink" title="RTTI"></a>RTTI</h2><p><a href="https://github.com/GaijinEntertainment/daScript/blob/f050f7f9a4aaaac75e454834663389c9d8ebd343/examples/test/unit_tests/reflection.das#L110" target="_blank" rel="noopener">https://github.com/GaijinEntertainment/daScript/blob/f050f7f9a4aaaac75e454834663389c9d8ebd343/examples/test/unit_tests/reflection.das#L110</a></p><p>Пример вывода на экран информации о типе в runtime:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">require rtti</span><br><span class="line">...</span><br><span class="line">var a = <span class="keyword">new</span> V3()</span><br><span class="line">print(<span class="string">"class_info(a): &#123;class_info(a)&#125;\n"</span>) </span><br><span class="line">describeStructure(*class_info(a))</span><br><span class="line"><span class="comment">//Output:</span></span><br><span class="line"><span class="comment">//https://dascript.org/doc/stdlib/rtti.html?highlight=rtti#StructInfo</span></span><br><span class="line">class_info(a): [[ <span class="number">0x6</span>; V3; ; (_class|heapGC); <span class="number">0x28</span>; <span class="number">0x93b8d07b5cc8cee</span>; <span class="number">0xcf51414d2d20b41e</span>]]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">V3</span></span></span><br><span class="line"><span class="class">    __<span class="title">rtti</span> :</span> <span class="keyword">void</span>?</span><br><span class="line">    __finalize : function&lt;(V2):<span class="keyword">void</span>&gt;</span><br><span class="line">    x : <span class="keyword">float</span></span><br><span class="line">    y : <span class="keyword">float</span></span><br><span class="line">    set1 : function&lt;(V2;<span class="keyword">float</span> <span class="keyword">const</span>;<span class="keyword">float</span> <span class="keyword">const</span>):<span class="keyword">void</span>&gt;</span><br><span class="line">    z : <span class="keyword">float</span></span><br></pre></td></tr></table></figure><p>Доступна информация о названиях и типах полей, а также мета-информация (<a href="https://dascript.org/doc/stdlib/rtti.html?highlight=rtti#alias-structinfoflags" target="_blank" rel="noopener">флаги</a> класс/структура, выделена на стеке/хипе, аннотации и т.п.).</p><p>Для того, чтобы передать и распознать аннотации, необходимо включить опцию <code>options rtti=true</code> (в противном случае, метаинформация о произвольных аннотациях выбрасывается после симуляции, <a href="https://github.com/GaijinEntertainment/daScript/wiki/options" target="_blank" rel="noopener">линк</a>). Пример:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">options rtti=<span class="literal">true</span></span><br><span class="line">...</span><br><span class="line">class V3: V2</span><br><span class="line">    [[test]] z : <span class="keyword">float</span></span><br><span class="line">...</span><br><span class="line">def describeStructure(sinfo)</span><br><span class="line">    var anyAnn = <span class="literal">false</span></span><br><span class="line">    structure_for_each_annotation(sinfo) &lt;| $(ann; annArgs)</span><br><span class="line">        let argT = join([&#123;<span class="keyword">for</span> arg in annArgs; <span class="string">"&#123;arg.name&#125;&#123;describeValue(get_annotation_argument_value(arg))&#125;"</span>&#125;],<span class="string">","</span>)</span><br><span class="line">        print(<span class="string">"[&#123;ann.name&#125;(&#123;argT&#125;)]\n"</span>)</span><br><span class="line">    print(<span class="string">"struct &#123;sinfo.name&#125;\n"</span>)</span><br><span class="line">    <span class="keyword">for</span> sfield in sinfo</span><br><span class="line">        <span class="keyword">if</span> sfield.annotation_arguments != null</span><br><span class="line">            <span class="keyword">for</span> arg in deref(sfield.annotation_arguments)</span><br><span class="line">                print(<span class="string">"\t[[&#123;arg.name&#125;]] "</span>)</span><br><span class="line">        describeVariable(sfield,<span class="string">"\t"</span>)</span><br><span class="line">...</span><br><span class="line">var a = <span class="keyword">new</span> V3()</span><br><span class="line">print(<span class="string">"class_info(a): &#123;class_info(a)&#125;\n"</span>)</span><br><span class="line">describeStructure(*class_info(a))</span><br><span class="line"></span><br><span class="line"><span class="comment">//Output:</span></span><br><span class="line">struct V3</span><br><span class="line">    __rtti : <span class="keyword">void</span>?</span><br><span class="line">    __finalize : function&lt;(V2):<span class="keyword">void</span>&gt;</span><br><span class="line">    x : <span class="keyword">float</span></span><br><span class="line">    y : <span class="keyword">float</span></span><br><span class="line">    set1 : function&lt;(V2;<span class="keyword">float</span> <span class="keyword">const</span>;<span class="keyword">float</span> <span class="keyword">const</span>):<span class="keyword">void</span>&gt;</span><br><span class="line">    [[test]] z : <span class="keyword">float</span> <span class="comment">//&lt;-- аннотация test</span></span><br></pre></td></tr></table></figure><p><a href="https://gist.github.com/spiiin/961974938919cc9233bacf0bb5c71cd1" target="_blank" rel="noopener">Полный пример</a></p><h2 id="Abstract-и-sealed-методы"><a href="#Abstract-и-sealed-методы" class="headerlink" title="Abstract и sealed-методы"></a>Abstract и sealed-методы</h2><p>Методы можно сделать абстрактыми, или закрытыми для переопределения</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">    <span class="title">def</span> <span class="title">abstract</span> <span class="title">setX</span>(<span class="title">X</span>:</span> <span class="keyword">int</span>): <span class="keyword">void</span> <span class="comment">//необходимо явно определить сигнатуру метода -- тип аргументов и результата</span></span><br><span class="line">    <span class="function">def sealed <span class="title">setY</span><span class="params">(Y: <span class="keyword">int</span>)</span>         <span class="comment">//метод нельзя переопределить в потомках</span></span></span><br><span class="line"><span class="function">        pass</span></span><br></pre></td></tr></table></figure><h2 id="Видимость"><a href="#Видимость" class="headerlink" title="Видимость"></a>Видимость</h2><ul><li>Из модуля экспортируются функции с аннотацией [export]</li></ul><p><code>options always_export_initializer=true</code> позволяет проставить аннотацию для всех инициализаторов на уровне модуля</p><ul><li><code>private</code> для переменных и типов ограничивает их доступность из других модулей</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//module1.das</span></span><br><span class="line"><span class="keyword">module</span> module1</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">private</span> <span class="title">V1</span></span></span><br><span class="line"><span class="class">    <span class="title">w</span> :</span> <span class="keyword">float</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">private</span> <span class="title">V2</span></span></span><br><span class="line"><span class="class">    <span class="title">x</span> :</span> <span class="keyword">float</span></span><br><span class="line">    y : <span class="keyword">float</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">public</span> <span class="title">V3</span>:</span> V2</span><br><span class="line">    v1 : V1</span><br><span class="line">    z : <span class="keyword">float</span> = <span class="number">3.0</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">//main.das</span></span><br><span class="line">require module1</span><br><span class="line"><span class="comment">//можно звать инициализацию полей, и пост-инициализацию для V3 (также открываются поля V2), но нельзя инициализировать явно поле приватного класса V1</span></span><br><span class="line">var a = <span class="keyword">new</span> [[V3() x=<span class="number">1.0f</span>, y=<span class="number">2.0f</span>, z=<span class="number">3.0f</span>]]</span><br></pre></td></tr></table></figure><p>Приватными могут быть также поля и функции структур/классов</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">    <span class="title">private</span> <span class="title">a</span> :</span> <span class="keyword">int</span></span><br><span class="line">    <span class="function">def <span class="keyword">private</span> <span class="title">set_a</span><span class="params">(val:<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">        a </span>= val</span><br><span class="line">    def get_a</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    def MyClass()</span><br><span class="line">        self-&gt;set_a(<span class="number">42</span>)</span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main</span><br><span class="line">    var f = <span class="keyword">new</span> MyClass()</span><br><span class="line">    print(<span class="string">"f.a = &#123;f-&gt;get_a()&#125;\n"</span>)</span><br></pre></td></tr></table></figure><h2 id="Инициализаторы"><a href="#Инициализаторы" class="headerlink" title="Инициализаторы"></a>Инициализаторы</h2><p>Инициализатор для класса — это функция, у которой имя совпадает с именем класса. Так как классы — надстройки над структурами, и все варианты синтаксиса иницилизации действуют и для них, то нет никакой гарантии того, что инициализатор класса будет вызван.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">    <span class="title">i</span> :</span> <span class="keyword">float</span></span><br><span class="line">    <span class="function">def <span class="title">Test</span><span class="params">(I : <span class="keyword">float</span>)</span></span></span><br><span class="line"><span class="function">        i </span>= I</span><br><span class="line"></span><br><span class="line">def main</span><br><span class="line">    var a &lt;- <span class="keyword">new</span> Test(<span class="number">33.0f</span>)         <span class="comment">//initializer called</span></span><br><span class="line">    var b &lt;- <span class="keyword">new</span> Test()              <span class="comment">//initializer dont called</span></span><br><span class="line">    var c &lt;- <span class="keyword">new</span> [[Test() i = <span class="number">2.0f</span>]] <span class="comment">//initializer dont called</span></span><br></pre></td></tr></table></figure><h2 id="Интерфейсы"><a href="#Интерфейсы" class="headerlink" title="Интерфейсы"></a>Интерфейсы</h2><p><a href="https://github.com/GaijinEntertainment/daScript/blob/eaecd72d6d44b46f5566dc4a0ce3956d5488672c/daslib/interfaces.das" target="_blank" rel="noopener">https://github.com/GaijinEntertainment/daScript/blob/eaecd72d6d44b46f5566dc4a0ce3956d5488672c/daslib/interfaces.das</a></p><p>Библиотека <code>interfaces</code> с помощью пары макросов позволяет реализовать паттерн интерфейса — классы, который содержит только абстрактные методы. Макрос <code>implements</code> позволяет изобразить множественное наследование от интерфейсов.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[interface]</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ITick</span></span></span><br><span class="line"><span class="class">    <span class="title">def</span> <span class="title">abstract</span> <span class="title">tick</span> (<span class="title">dt</span>:</span><span class="keyword">float</span>) : <span class="keyword">void</span></span><br><span class="line"></span><br><span class="line">[interface]</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ILogger</span></span></span><br><span class="line"><span class="class">    <span class="title">def</span> <span class="title">abstract</span> <span class="title">log</span> (<span class="title">message</span> :</span> <span class="built_in">string</span>) : <span class="keyword">void</span></span><br><span class="line"></span><br><span class="line">[implements(ITick), implements(ILogger)]</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">    ...</span></span><br></pre></td></tr></table></figure><h1 id="Связь-с-C-типами"><a href="#Связь-с-C-типами" class="headerlink" title="Связь с C++ типами"></a>Связь с C++ типами</h1><p><a href="https://github.com/GaijinEntertainment/daScript/blob/master/examples/tutorial/tutorial03.cpp#L15" target="_blank" rel="noopener">https://github.com/GaijinEntertainment/daScript/blob/master/examples/tutorial/tutorial03.cpp#L15</a><br>Базовый пример прокидывания C++ класса в daScript. Похоже на другие скриптовые языки, создаётся класс-обёртка (<code>ManagedStructureAnnotation</code>) над типом, которая позволяет привязать и настроить отображение полей и методов структуры на тип в daScript, а также переопределить группу методов, определяющих свойства этого типа в daScript.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Color</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> r, g, b, a;</span><br><span class="line">&#125;;</span><br><span class="line">MAKE_TYPE_FACTORY(Color, Color);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ColorAnnotation</span> :</span> <span class="keyword">public</span> ManagedStructureAnnotation&lt;Color,<span class="literal">true</span>,<span class="literal">true</span>&gt; &#123;</span><br><span class="line">    ColorAnnotation(ModuleLibrary &amp; ml) : ManagedStructureAnnotation (<span class="string">"Color"</span>, ml) &#123;</span><br><span class="line">        <span class="comment">//type fields</span></span><br><span class="line">        addField&lt;DAS_BIND_MANAGED_FIELD(r)&gt;(<span class="string">"r"</span>);</span><br><span class="line">        addField&lt;DAS_BIND_MANAGED_FIELD(g)&gt;(<span class="string">"g"</span>);</span><br><span class="line">        addField&lt;DAS_BIND_MANAGED_FIELD(b)&gt;(<span class="string">"b"</span>);</span><br><span class="line">        addField&lt;DAS_BIND_MANAGED_FIELD(a)&gt;(<span class="string">"a"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//type behaviour</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">isLocal</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">canCopy</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125; </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">canMove</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Module_Tutorial03</span> :</span> <span class="keyword">public</span> Module &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Module_Tutorial03() : Module(<span class="string">"tutorial_03"</span>) &#123;</span><br><span class="line">        ModuleLibrary lib;</span><br><span class="line">        lib.addModule(<span class="keyword">this</span>);</span><br><span class="line">        addAnnotation(make_smart&lt;ColorAnnotation&gt;(lib));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">REGISTER_MODULE(Module_Tutorial03);</span><br></pre></td></tr></table></figure><p>Более продвинутые <a href="https://github.com/GaijinEntertainment/daScript/blob/master/examples/test/test_handles.cpp" target="_blank" rel="noopener">примеры</a>, также можно смотреть код <a href="https://github.com/GaijinEntertainment/daScript/tree/master/modules" target="_blank" rel="noopener">модулей</a>.</p><h2 id="Наследование"><a href="#Наследование" class="headerlink" title="Наследование"></a>Наследование</h2><p>Отнаследоваться от C++ типа нельзя (<em>ну, или я не нашёл способа сделать такой тип</em>).</p><p>Существует возможность передать в daScript связь родитель-потомок между C++-типами (<a href="https://github.com/borisbat/dasSFML/blob/4501a9167692180d138da4a487a42375a377db68/src/dasSFML.struct.add.inc#L134" target="_blank" rel="noopener">пример</a>), для upcast-приведения типов аргументов функций.</p><p>Пример организации связи между С++ и daScript-классами - <a href="https://github.com/GaijinEntertainment/daScript/blob/master/examples/tutorial/tutorial04.cpp#L45" target="_blank" rel="noopener">tutorial04</a>.</p><img style="background-color:white;" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjk3IiBoZWlnaHQ9IjE5OSIgdmVyc2lvbj0iMS4xIiBiYXNlUHJvZmlsZT0iZnVsbCIgdmlld2JveD0iMCAwIDY5NyAxOTkiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHhtbG5zOmV2PSJodHRwOi8vd3d3LnczLm9yZy8yMDAxL3htbC1ldmVudHMiIHN0eWxlPSJmb250LXdlaWdodDpib2xkOyBmb250LXNpemU6MTJwdDsgZm9udC1mYW1pbHk6J0NhbGlicmknLCBIZWx2ZXRpY2EsIHNhbnMtc2VyaWY7O3N0cm9rZS13aWR0aDozO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbGluZWNhcDpyb3VuZCI+PHBhdGggZD0iTTE4NC4xIDQ0LjUgTDExMiA2NC41IEwxMTIgODQuNSBMMTEyIDg0LjUgIiBzdHlsZT0ic3Ryb2tlOiMzMzMyMkU7ZmlsbDpub25lO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTsiPjwvcGF0aD4KPHBhdGggZD0iTTEwNi43IDcxLjIgTDExMiA3Ny44IEwxMTcuMyA3MS4yIEwxMTIgODQuNSBaIiBzdHlsZT0ic3Ryb2tlOiMzMzMyMkU7ZmlsbDojMzMzMjJFO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTsiPjwvcGF0aD4KPHBhdGggZD0iTTI5NS45IDQ0LjUgTDM2OCA2NC41IEwzNjggODQuNSBMMzY4IDg0LjUgIiBzdHlsZT0ic3Ryb2tlOiMzMzMyMkU7ZmlsbDpub25lO3N0cm9rZS1kYXNoYXJyYXk6NiA2OyI+PC9wYXRoPgo8cGF0aCBkPSJNMzYyLjcgNzEuMiBMMzY4IDc3LjggTDM3My4zIDcxLjIgTDM2OCA4NC41IFoiIHN0eWxlPSJzdHJva2U6IzMzMzIyRTtmaWxsOiMzMzMyMkU7c3Ryb2tlLWRhc2hhcnJheTpub25lOyI+PC9wYXRoPgo8cGF0aCBkPSJNNjA1IDExNS41IEw2MDUgMTM1LjUgTDUzOC4yIDE1NS41IEw1MzguMiAxNTUuNSAiIHN0eWxlPSJzdHJva2U6IzMzMzIyRTtmaWxsOm5vbmU7c3Ryb2tlLWRhc2hhcnJheTpub25lOyI+PC9wYXRoPgo8cGF0aCBkPSJNNTQ5LjUgMTQ2LjYgTDU0NC42IDE1My42IEw1NTIuNSAxNTYuOCBMNTM4LjIgMTU1LjUgWiIgc3R5bGU9InN0cm9rZTojMzMzMjJFO2ZpbGw6IzMzMzIyRTtzdHJva2UtZGFzaGFycmF5Om5vbmU7Ij48L3BhdGg+CjxwYXRoIGQ9Ik0zNjggMTE1LjUgTDM2OCAxMzUuNSBMNDM0LjggMTU1LjUgTDQzNC44IDE1NS41ICIgc3R5bGU9InN0cm9rZTojMzMzMjJFO2ZpbGw6bm9uZTtzdHJva2UtZGFzaGFycmF5Om5vbmU7Ij48L3BhdGg+CjxwYXRoIGQ9Ik00MjAuNSAxNTYuOCBMNDI4LjQgMTUzLjYgTDQyMy41IDE0Ni42IEw0MzQuOCAxNTUuNSBaIiBzdHlsZT0ic3Ryb2tlOiMzMzMyMkU7ZmlsbDojMzMzMjJFO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTsiPjwvcGF0aD4KPHJlY3QgeD0iMTIyLjUiIHk9IjEzLjUiIGhlaWdodD0iMzEiIHdpZHRoPSIyMzUiIHN0eWxlPSJzdHJva2U6IzMzMzIyRTtmaWxsOnBpbms7c3Ryb2tlLWRhc2hhcnJheTpub25lOyI+PC9yZWN0Pgo8dGV4dCB4PSIxMzAuOCIgeT0iMzUiIHN0eWxlPSIiPlR1dG9yaWFsQmFzZUNsYXNzIChkYXMpPC90ZXh0Pgo8cmVjdCB4PSIxMy41IiB5PSI4NC41IiBoZWlnaHQ9IjMxIiB3aWR0aD0iMTk3IiBzdHlsZT0ic3Ryb2tlOiMzMzMyMkU7ZmlsbDpwaW5rO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTsiPjwvcmVjdD4KPHRleHQgeD0iMjEuOCIgeT0iMTA2IiBzdHlsZT0iIj5FeGFtcGxlT2JqZWN0IChkYXMpPC90ZXh0Pgo8cmVjdCB4PSIyNTAuNSIgeT0iODQuNSIgaGVpZ2h0PSIzMSIgd2lkdGg9IjIzNSIgc3R5bGU9InN0cm9rZTojMzMzMjJFO2ZpbGw6I2VlZThkNTtzdHJva2UtZGFzaGFycmF5Om5vbmU7Ij48L3JlY3Q+Cjx0ZXh0IHg9IjI1OC44IiB5PSIxMDYiIHN0eWxlPSIiPlR1dG9yaWFsQmFzZUNsYXNzIChjcHApPC90ZXh0Pgo8cmVjdCB4PSI1MjUuNSIgeT0iODQuNSIgaGVpZ2h0PSIzMSIgd2lkdGg9IjE1OSIgc3R5bGU9InN0cm9rZTojMzMzMjJFO2ZpbGw6I2VlZThkNTtzdHJva2UtZGFzaGFycmF5Om5vbmU7Ij48L3JlY3Q+Cjx0ZXh0IHg9IjUzMy44IiB5PSIxMDYiIHN0eWxlPSIiPkJhc2VDbGFzcyAoY3BwKTwvdGV4dD4KPHJlY3QgeD0iMzc0LjUiIHk9IjE1NS41IiBoZWlnaHQ9IjMxIiB3aWR0aD0iMjI1IiBzdHlsZT0ic3Ryb2tlOiMzMzMyMkU7ZmlsbDojZWVlOGQ1O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTsiPjwvcmVjdD4KPHRleHQgeD0iMzgyLjUiIHk9IjE3NyIgc3R5bGU9IiI+QmFzZUNsYXNzQWRhcHRlciAoY3BwKTwvdGV4dD48L3N2Zz4=" /><p>В примере связь организуется через класс <code>BaseClassAdapter</code>, который наследуется одновременно от базового C++-класса и сгенерированного по das-коду C++-классу-адаптеру</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">options remove_unused_symbols = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//interface C++/daScript</span></span><br><span class="line">class TutorialBaseClass</span><br><span class="line">    def abstract update ( dt : <span class="keyword">float</span> ) : <span class="keyword">void</span></span><br><span class="line">    def abstract get_position : float3</span><br><span class="line"></span><br><span class="line"><span class="comment">// uncomment the section to generate C++ bindings for the TutorialBaseClass</span></span><br><span class="line"><span class="comment">// this code will generate tutorial04_gen.inc which contains C++ bindings</span></span><br><span class="line"></span><br><span class="line">require fio</span><br><span class="line">require ast</span><br><span class="line">require daslib/cpp_bind</span><br><span class="line">[init]</span><br><span class="line">def generate_cpp_bindings</span><br><span class="line">    let root = get_das_root() + <span class="string">"/examples/tutorial/"</span></span><br><span class="line">    fopen(root + <span class="string">"tutorial04_gen.inc"</span>,<span class="string">"wb"</span>) &lt;| $ ( cpp_file )</span><br><span class="line">        <span class="comment">//generate c++ code from dascript rtti class information</span></span><br><span class="line">        log_cpp_class_adapter(cpp_file, <span class="string">"TutorialBaseClass"</span>, typeinfo(ast_typedecl type&lt;TutorialBaseClass&gt;))</span><br></pre></td></tr></table></figure><p><code>TutorialBaseClass</code> - интерфейс между C++/daScript, который используется генератором C++-обёрток <code>log_cpp_class_adapter</code>, на выходе получается примерно такой C++-код:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TutorialBaseClass</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">enum</span> &#123;</span><br><span class="line">    __fn_update = <span class="number">0</span>,</span><br><span class="line">    __fn_get_position = <span class="number">1</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> _das_class_method_offset[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  TutorialBaseClass ( <span class="keyword">const</span> StructInfo * info ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( _das_class_method_offset[<span class="number">0</span>]==<span class="number">0</span> ) &#123;</span><br><span class="line">      _das_class_method_offset[__fn_update] = adapt_field_offset(<span class="string">"update"</span>,info);</span><br><span class="line">      _das_class_method_offset[__fn_get_position] = adapt_field_offset(<span class="string">"get_position"</span>,info);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">static</span> __forceinline Func <span class="title">get_get_position</span> <span class="params">( <span class="keyword">void</span> * self )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getDasClassMethod(self,_das_class_method_offset[__fn_get_position]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> __forceinline float3 <span class="title">invoke_get_position</span> <span class="params">( Context * __context__, Func __funcCall__, <span class="keyword">void</span> * self )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> das_invoke_function&lt;float3&gt;::invoke</span><br><span class="line">      &lt;<span class="keyword">void</span> *&gt;</span><br><span class="line">        (__context__,<span class="literal">nullptr</span>,__funcCall__,</span><br><span class="line">          self);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> TutorialBaseClass::_das_class_method_offset[<span class="number">2</span>];</span><br></pre></td></tr></table></figure><p>Вызов:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseClassAdapter</span> :</span> <span class="keyword">public</span> BaseClass, <span class="keyword">public</span> TutorialBaseClass &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// in the constructor we store pointer to the original class and context</span></span><br><span class="line">    <span class="comment">// we also pass StructInfo of the daScript class to the generated class</span></span><br><span class="line">    BaseClassAdapter ( <span class="keyword">char</span> * pClass, <span class="keyword">const</span> StructInfo * info, Context * ctx )</span><br><span class="line">        : TutorialBaseClass(info), classPtr(pClass), context(ctx) &#123; &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> float3 <span class="title">getPosition</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// we check if daScript class has 'get_position'</span></span><br><span class="line">        <span class="keyword">if</span> ( <span class="keyword">auto</span> fn = get_get_position(classPtr) ) &#123;</span><br><span class="line">            <span class="comment">// we invoke it, and return it's result</span></span><br><span class="line">            <span class="keyword">return</span> invoke_get_position(context, fn, classPtr);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> float3(<span class="number">0.0f</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">void</span> *      classPtr;   <span class="comment">// stored pointer to the daScript class</span></span><br></pre></td></tr></table></figure></p><p>Класс не содержит особой магии, а просто хранит адреса daScript-функций и позволяет прозрачно для вызывающего C++-кода их вызывать и изменять.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;h1 id=&quot;Струк
      
    
    </summary>
    
    
    
      <category term="dascript" scheme="http://spiiin.github.io/tags/dascript/"/>
    
  </entry>
  
  <entry>
    <title>daScript -&gt; dasLang?</title>
    <link href="http://spiiin.github.io/blog/2975166623/"/>
    <id>http://spiiin.github.io/blog/2975166623/</id>
    <published>2023-01-01T20:44:11.000Z</published>
    <updated>2023-01-02T01:41:46.880Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Год назад в первых же заметках про <code>daScript</code>:<br><a href="/blog/1728194429/" title="С++ в геймдеве">С++ в геймдеве</a><br><a href="/blog/1547564887/" title="daScript macro">daScript macro</a><br>я отметил для себя такой парадокс - <strong><code>Гайдзины делают не замену Lua, они делают замену C++!</code></strong>, т.е. дизайн языка — это совсем не про скрипты, это generic язык, удобный, чтобы делать с его помощью игры.</p><a id="more"></a><p>Сам Борис, видимо, устал отвечать на вопросы новичков в стиле “это такая альтернатива lua?” и написал <a href="https://borisbat.github.io/dascf-blog/2022/12/31/its-not-a-script/" target="_blank" rel="noopener">заметку</a> про то, что название сильно сбивает с толку.</p><h2 id="Слои-языка"><a href="#Слои-языка" class="headerlink" title="Слои языка"></a>Слои языка</h2><p><strong><code>Разделение по уровню понимания языка</code></strong></p><p><code>daScript</code> — это айсберг, в котором новичкам видно его верхушку — скриптовый слой, на котором можно описывать логику и дёргать API движка, например, <a href="https://github.com/imp5imp5/dasbox/blob/main/doc/api.txt" target="_blank" rel="noopener">dasbox api</a>. Это первый слой — glue-язык, на котором можно писать семантически сжатый компактный код как на каком-нибудь python/lua/javascript.<br>Но при синтаксической похожести уже явно будут видны отличия:</p><ul><li>язык типизированный — при изучении приходится потратить некоторое время на то, чтобы научиться правильно работать с его типами. В этом он местами сложнее не только луа, но и на C, скорее похож на языки из ml-семейства. Это сделано by-design, ради того, чтобы компилятор ловил больше ошибок, и легче было рефакторить код.<br><em>Некоторые простые для lua паттерны мета-программирования, в котором rtti-информация о типе — это просто таблица, к которой можно получить доступ, необходимо переделывать с помощью магических макросов, что требует намного более глубокого понимания языка</em></li><li>язык позволяет работать на низком уровне — на котором можно делать практически то же, что и C. Местами про lifetime объектов нужно думать больше, а не меньше, чем в C++, и уж точно не на уровне “включил GC и выключил голову”.</li><li>язык быстрый — наивный код получается +/- таким же производительным, как и наивный С++, а gamedev-specific код (много работы с векторами/матрицами) — часто и сильно быстрее. Сам код возможно оптимизировать на самом daScript, без подхода “перепишем то, что тормозит на C”.</li><li>виртуальную машину языка можно рассматривать не как абстрактную машину, а как AoT-компилятор в C++, который используется как <a href="https://www.youtube.com/watch?v=8SoJR3sCaR4" target="_blank" rel="noopener">платформа</a>.</li></ul><p>Т.е. уже на этом уровне свойства языка существенно отличаются от того, что обычно понимают под скриптовым языком в геймдеве. Что представляет проблему, так как с позиции изучающего язык новичка “с высоты птичьего полёта” язык кажется не тем, чем он есть на самом деле.</p><p><img src="/blog/2975166623/iceberg_small.png" alt=""><br>При этом сам айсберг — это генерики и макросы, с помощью которых можно создавать edsl, изменять синтаксис: от добавления привычных для ООП вещей, которых нет в ядре языка, вроде <a href="https://raw.githubusercontent.com/GaijinEntertainment/daScript/master/daslib/interfaces.das" target="_blank" rel="noopener">интерфейсов</a>, или привычных для асинхронного программирования <a href="https://github.com/GaijinEntertainment/daScript/blob/138f625c7f95943341a5e96cca114ae7d0772ba6/daslib/coroutines.das" target="_blank" rel="noopener">корутин</a>, до dsl: языки-обёртки над <a href="https://github.com/GaijinEntertainment/daScript/blob/master/modules/dasOpenGL/glsl/glsl_opengl.das" target="_blank" rel="noopener">шейдерными языками</a>, и чёрной магии reader macro, позволяющей встраивать альтернативные синтаксисы вроде <a href="https://github.com/GaijinEntertainment/daScript/blob/master/daslib/regex_boost.das" target="_blank" rel="noopener">регулярных выражений</a>, а также модифицировать AST-языка.</p><p>Парсинг и модификация/генерация AST также упрощает создание инструментов для работы с кодом:</p><ul><li><a href="https://marketplace.visualstudio.com/items?itemName=profelis.dascript-plugin" target="_blank" rel="noopener">daScript language support for vs code</a> — отладчик, подсветка кода и вывод типов, помощь с выводом выражений</li><li><a href="https://borisbat.github.io/dascf-blog/2022/12/11/instruments/" target="_blank" rel="noopener">профайлер</a></li><li>генерация <a href="https://github.com/GaijinEntertainment/daScript/tree/master/modules/dasClangBind/bind" target="_blank" rel="noopener">привязок</a> к C/C++ библиотекам (можно смотреть, к примеру, <code>bind_opengl</code> — генерится daScript код, для других может генериться и c++-код привязки)</li><li><a href="https://github.com/GaijinEntertainment/daScript/blob/073bc29145207b39180069ae60f00ed43fad6ea7/examples/test/misc/ast_print.das" target="_blank" rel="noopener">описание выражений</a> в runtime</li><li><a href="https://github.com/GaijinEntertainment/daScript/blob/9e217204864177cf6886c7d8ecc86be1d47dbfca/daslib/lint.das" target="_blank" rel="noopener">линтеры</a></li><li>hot code reload — <a href="/blog/3006126295/" title="daScript - live-режим">daScript - live-режим</a><br>и многое другое.</li></ul><p>Такое разделения по испольуемым фичам похоже на то, чем отличается код приложения от кода библиотек на C++ — прикладной уровень требует знания только основ языка, тогда как написание библиотеки может требовать умений использовать наиболее мощные фичи.</p><p><strong><code>Разделение по архитектуре языка</code></strong></p><p>В заметке Борис выделяет такие уровни языка (явного название уровней у него нет, поэтому придумал я):</p><ul><li>Lowest level. Низкоуровневое ядро языка, на этом уровне язык можно представить себе как альтернативу C, с фичами вроде арифметики указателей, копирования областей памяти, pod-структур с возможностью настройки размещения в памяти.</li><li>Syntax-sugar level. Уровень синтаксического сахара, абстракции уровня языков Ruby или Python — блоки, замыкания, таблицы, классы, генераторы и итераторы. Чаще всего реализованы в виде библиотек на самом daScript.</li><li>Macro level. Фичи работы с AST языка, похожие на то, что можно делать в Lisp или Haxe — “bring your own language”, пишем код, который говорит компилятору, как именно интерпретировать другой код.</li></ul><p><img src="/blog/2975166623/onion_small.png" alt=""></p><p>Ни один из уровней не предназначен для решения проблем, которыми обычно занимаются скриптовые языки — <code>daScript</code> не для написания игровой логики, а для написания <em>всего</em> для игры, от логики, до движка — рендера, шейдеров и физики, и до тулзов - редактора игры, компилятора данных, сервера, скриптов сборки и прочей инфраструктуры вокруг, и соединения всего этого вместе.</p><h2 id="Проблема-названия"><a href="#Проблема-названия" class="headerlink" title="Проблема названия"></a>Проблема названия</h2><p>Вывод заметки — если <em>script</em> в названии не соответствует тому, что представляет собой язык, и только отвлекает от того, на что он потенциально способен (да и <em>da</em> - в названии, отсылка к названию движка Gaijin — <strong>Da</strong>gor Engine, язык начинался как попытка сделать замену предыдущим скриптовым языкам для движка, но уже может использовать и без него), то этого достаточно для того, чтобы переименовать язык во что-то типа <strong><code>dasLang</code></strong>, так как <strong>das</strong>-часть уже закрепилась в качестве расширения файлов для языка.</p><p>Как по мне — прикольный ход, новое название сохраняет узнаваемость для знакомых со старым, и перестаёт исправляться “умным” поиском на что-то другое и выдавать нерелевантные результаты, хотя и читается по немецки как “так долго”.</p><p>Побалуюсь немного на тему того, сокращением от чего могло бы быть это название, по аналогии, как <code>Nimrod</code>, сократилось до <a href="https://nim-lang.org/" target="_blank" rel="noopener">nim-lang</a> для nim. Случайные свойства и идеи языка, которые первыми пришли мне на ум после изучения <code>daScript</code>:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- скорость цикла разработки</span><br><span class="line">- выразительность</span><br><span class="line">- экономность ресурсов</span><br><span class="line">- создание абстракций</span><br><span class="line">- чистота (stateless)</span><br><span class="line">- контроль ошибок</span><br><span class="line">- встраиваемость (комбинируемость с другими)</span><br><span class="line">- типизация</span><br><span class="line">- быстрая интерпретация</span><br><span class="line">- дружественность к особенностям железа (hardware-friendly)</span><br><span class="line">- открытость</span><br><span class="line">- бесплатность</span><br><span class="line">- быстрые контексты (fast context reset)</span><br></pre></td></tr></table></figure><p>Если попробовать аппроксимировать слова вместе, максимально абстрактно склеивая их друг с другом, можно получить что-то такое:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">скорость (4) &lt;- скорость разработки + быстрая интерпретация + hardware friendly + fast context reset</span><br><span class="line">низкоуровневость (2) &lt;- экономность + hardware friendly</span><br><span class="line">защита (3) &lt;- контроль + типизация + чистота</span><br><span class="line">свобода (4) &lt;- выразительность + комбинируемость + бесплатность + открытость</span><br><span class="line">виртуальность (2) &lt;- выразительность + создание абстракций</span><br></pre></td></tr></table></figure><p>И еще разок:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">производительность&#x2F;performance (6) &lt;- низкоуровневость + скорость</span><br><span class="line">свобода&#x2F;freedom (4)</span><br><span class="line">безопасность&#x2F;safety (5) &lt;- защита + виртуальность</span><br></pre></td></tr></table></figure><p>Уже похоже на motto:</p><blockquote><p>“Performance &amp; creative freedom in safety environment”</p></blockquote><p>Производительный код и свобода творчества в безопасном скриптовом окружении? Кажется безумной, но заманчивой затеей? — но отчаянный <strong><code>dAsperado language (dasLang)</code></strong> позволяет именно это.<br><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/zVMObSx3E1M?start=26" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Год назад в первых же заметках про &lt;code&gt;daScript&lt;/code&gt;:&lt;br&gt;&lt;a href=&quot;/blog/1728194429/&quot; title=&quot;С++ в геймдеве&quot;&gt;С++ в геймдеве&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;/blog/1547564887/&quot; title=&quot;daScript macro&quot;&gt;daScript macro&lt;/a&gt;&lt;br&gt;я отметил для себя такой парадокс - &lt;strong&gt;&lt;code&gt;Гайдзины делают не замену Lua, они делают замену C++!&lt;/code&gt;&lt;/strong&gt;, т.е. дизайн языка — это совсем не про скрипты, это generic язык, удобный, чтобы делать с его помощью игры.&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="gamedev" scheme="http://spiiin.github.io/tags/gamedev/"/>
    
      <category term="dascript" scheme="http://spiiin.github.io/tags/dascript/"/>
    
      <category term="dev_method" scheme="http://spiiin.github.io/tags/dev-method/"/>
    
  </entry>
  
  <entry>
    <title>Хеш-таблицы. Шпаргалка</title>
    <link href="http://spiiin.github.io/blog/847579411/"/>
    <id>http://spiiin.github.io/blog/847579411/</id>
    <published>2022-12-25T20:09:16.000Z</published>
    <updated>2022-12-26T13:30:22.109Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Небольшой обзор типов хеш-таблиц, которые чаще всего встречаются в языках программирования.</p><a id="more"></a><p>Материалы:<br>[1] - <a href="https://youtu.be/ncHmEUmJZf4" target="_blank" rel="noopener">Matt Kulukundis “Designing a Fast, Efficient, Cache-friendly Hash Table, Step by Step”</a><br>[2] - <a href="http://bannalia.blogspot.com/2022/06/advancing-state-of-art-for.html" target="_blank" rel="noopener">Advancing the state of the art for std::unordered_map implementations</a><br>[3] - <a href="http://craftinginterpreters.com/hash-tables.html" target="_blank" rel="noopener">Crafting Interpreters</a>. Глава “Hash tables”<br>[4] - <a href="https://www.sebastiansylvan.com/post/robin-hood-hashing-should-be-your-default-hash-table-implementation/" target="_blank" rel="noopener">Robin Hood Hashing should be your default Hash Table implementation</a><br>[5] - <a href="https://www.youtube.com/watch?v=M2fKMP47slQ" target="_blank" rel="noopener">You Can Do Better than std::unordered_map: New Improvements to Hash Table Performance</a> - доклад автора ska::flat_hash_map<br>[6] - <a href="https://pdimov.github.io/articles/unordered_dev_plan.html" target="_blank" rel="noopener">Development Plan for Boost.Unordered</a></p><p>Хеш-таблицы (наряду с массивами) — одна из основных структур данных стандартной библиотеки практически каждого языка программирования. Базовые понятия можно изучить из любой книги по алгоритмам и структурам данных, например, <code>Седжвик - Фундаментальные алгоритмы на C++</code>.</p><p>Теоретически, хеш-таблица (ассоциативный массив) — это контейнер, который хранит пары [ключ, значение] с быстрым доступом (амортизированно, O(1)). Практически, есть много интересных нюансов организации хранения.<br>Хеш-таблица логически организована как несколько корзин (bucket/slot), которые хранят данные (пары, значения, указатели на них). Место хранения (конкретная корзина) определяется с помощью хеш-функции, которая отображает ключ на номер корзины.</p><h2 id="Размер-таблицы"><a href="#Размер-таблицы" class="headerlink" title="Размер таблицы"></a>Размер таблицы</h2><p>Память компьютера не бесконечна, так что количество корзин очевидно должно быть меньше, чем все количество всех возможных значений ключей. Так как хеш-таблицы — очень общая структура данных, то баланс между размером таблицы и скоростью доступа является сложной задачей. Разные типы хеш-таблиц начинают просаживаться по скорости начиная с различной степени заполненности, так что оптимальный размер таблицы зависит от её внутреннего устройства. Бывают типы таблиц, которые “расширяются” начиная от 50%, 75% или даже 90-95%</p><h2 id="Хеш-функции"><a href="#Хеш-функции" class="headerlink" title="Хеш-функции"></a>Хеш-функции</h2><p>Идеальный случай — если каждый ключ отображается на уникальную корзину. Но когда хеш-функция для двух ключей возвращает одно и то же значение, происходит коллизия. Одно из фундаментальных различий организации хеш-таблиц — способ работы с коллизиями. От него же зависит от отклонение между теоретическим и практическим временем поиска элемента в таблице.</p><p>Тем не менее, перед рассмотрением способов работы с коллизиями, стоит сказать пару слов о хеш-функциях. Чем более равномерно будут “размазаны” входные значения по корзинам хеш-таблицы, тем лучше. Если входные данные неизвестны заранее, то хорошим способом будет максимально рандомизировать хеш-функцию. Огромная часть производительности хеш-таблиц зависит от того, насколько равномерно входные данные попадают в различные корзины, так что первый шаг в проверке производительности — проверить используемую функцию ([1], <a href="https://youtu.be/ncHmEUmJZf4?t=170" target="_blank" rel="noopener">тайминг</a>)</p><h2 id="Идеальное-хеширование"><a href="#Идеальное-хеширование" class="headerlink" title="Идеальное хеширование"></a>Идеальное хеширование</h2><p>В случае, если входные данные известны заранее и можно построить по ним таблицу до начала её использования, можно попробовать перебором подобрать такую хеш-функцию, которая вообще не вызовет коллизий на входных данных (<code>идеальное хеширование</code>). Отчасти расширением этого подхода можно назвать <a href="https://www.geeksforgeeks.org/cuckoo-hashing/" target="_blank" rel="noopener">хеширование кукушки</a>. В этом случае есть две отдельных хеш таблицы с разными хеш-функциями, и элемент может храниться в любой из двух таблиц. Если слот в одной из корзин занят, можно попробовать положить один из элементов в другую таблицу, и циклически переместить другие занятые в одной из таблиц слоты с другую. Если же найден цикл — можно попробовать или сменить пару хеш-функций и переложить все элементы в другую таблицу, или добавить третью таблицу с еще одной хеш-функцией.</p><h2 id="Separate-chaining"><a href="#Separate-chaining" class="headerlink" title="Separate chaining"></a>Separate chaining</h2><p>Один из простых случаев разрешения коллизий — хранить в корзинах не значения, а односвязный список, в который добавляются значения с одинаковым ключом. Такой подход могут называть раздельное хеширование или закрытая адресация (closed addressing, в значении “возможность положить значение не в свою корзину закрыта”). Минусы такого способа, как и самого связанного списка — необходимость динамического выделения памяти и дополнительный прыжок в памяти по указателю на элемент.</p><p>Тем не менее, практически в чистом виде встречается в C++ (<code>stl::unordered_map</code>), в <a href="https://github.com/mono/mono/blob/mono-3.0.3/mcs/class/corlib/System.Collections.Generic/Dictionary.cs#L66" target="_blank" rel="noopener">C#</a>, Java, <a href="https://medium.com/kalamsilicon/hash-tables-implementation-in-go-48c165c54553" target="_blank" rel="noopener">Go</a>.</p><p>Для C++, вдобавок, в стандарте прописана необходимость реализации API в виде связанного списка (<a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1456.html" target="_blank" rel="noopener">N1456</a>, комментарий в [1], <a href="https://youtu.be/ncHmEUmJZf4?t=549" target="_blank" rel="noopener">тайминг</a> — <em>when stl is starting to make sense, and that is never a good sign</em>).</p><p><code>boost::unordered_map</code><br>В [2] приводятся примеры нескольких реализаций такого API и возможных оптимизаций по производительности (<em>Time and memory performance of Boost 1.80 boost::unordered_map</em>).<br><img src="/blog/847579411/fca_small.png" alt=""></p><ul><li>bucket groups - бит-маска занятых элементов вместо указателей из одного слота в другой (на скрине выше), за счет экономии памяти лучше влезает в кеш</li><li>количество корзин при максимально допустимой загруженности таблицы растет не в 2 раза, а как последовательность простых чисел — способствует более равномерному распределению при плохом (non-uniform) выборе хеш-функции<br>(<a href="https://www.boost.org/doc/libs/develop/libs/unordered/doc/html/unordered.html#compliance" target="_blank" rel="noopener">бенчмарк</a>)<br>[6] - обзор альтернативных типов таблиц</li></ul><p>Одна из нераспространенных на практике идей из классических книг — сохранять упорядоченность списков для небольшого ускорения проверки наличия элемента в списке (<em>скорее всего, из-за потери возможности хранить указатели на элементы корзины</em>)</p><h2 id="Open-addressing"><a href="#Open-addressing" class="headerlink" title="Open addressing"></a>Open addressing</h2><p>Варианты названия:<br><code>Open addressing</code> (открытая адресация, в смысле, что возможность попадания элемента не свою корзину отрыта)<br><code>Closed hashing</code> (<a href="http://craftinginterpreters.com/hash-tables.html#open-addressing" target="_blank" rel="noopener">3</a>, закрытое хеширование в смысле что возможность элемента оказаться вне корзин закрыта)<br><code>Probing table</code>(<a href="https://youtu.be/ncHmEUmJZf4?t=943" target="_blank" rel="noopener">1</a>, для случая, если в корзинах хранятся не указатели, а значения)<br><code>Scatter tables</code>(<a href="https://book.huihoo.com/data-structures-and-algorithms-with-object-oriented-design-patterns-in-java/html/page231.html" target="_blank" rel="noopener">Data Structures and Algorithms with Object-Oriented Design Patterns in Java</a>, аналогично)<br><code>Flat map</code> (аналогично)</p><p>Зачем хранить элементы с повторяющимся хешем ключа в связанном списке, если можно положить их в другие корзины? Это сложнее в организации, возникает серия вопросов — как именно выбрать альтернативную корзину, как узнать, что в корзине находится “не родное” значение, как удалять элементы? Дальнейшую таксономию таблиц с открытой адресацией можно выстроить в зависимости от ответов на эти вопросы.</p><p>Варианты ответов:</p><p><strong><code>Как выбрать альтернативную корзину</code></strong></p><ul><li>Попробовать следующую (после последней заново проверить первую) — линейное пробирование.<br>Распространенный метод из-за того, что дружественный к кешу, элементы хранятся в памяти близко друг к другу.<br>Может вызывать проблемы при большой загруженности таблицы, но это можно решать различными способами — пересортировать элементы хранящиеся рядом, позаботиться о более качественном “размазывании”, см. раздел “Хеш-функции”), уменьшить коэффициент заполненности, при котором будет увеличено количество корзин. Эти решения проблем будут более детально рассмотрено далее</li><li>Увеличивать шаг не на 1, а по более сложным правилам — квадрат от номера попытки, другая хеш-функция от значения элемента, etc. Требует хорошего понимания вероятности, насколько выбор шага может действительно улучшить распределение ключей по корзинам (может зависеть от размера таблицы и хеш-функции).</li></ul><p>Встречаются экзотические комбинации стратегий - <a href="https://github.com/ktprime/emhash" target="_blank" rel="noopener">emhash</a> в режиме 3-way combined сначала делает несколько линейных проб, затем квадратичные, и дальше пробует втиснуть элемент поочередно в начало/конец таблицы.</p><p><strong><code>Удаление значений</code></strong></p><ul><li>Вместо удаления значений, заменить реальное значение в корзине на “надгробие” (tombstone), чтобы при поиске элемента по списку рассматривать его “за этим значением есть другие для проверки”, а при вставке нового элемента рассматривать надгробие как пустую корзину для вставки</li><li>В случае линейной вставки элементов в первую попавшуюся пустую корзину можно переместить последний элемент списка на освободившееся пустое место. Несмотря на кажущуюся тривиальность алгоритма, требует аккуратности в реализации (как пример, в книге Кнута алгоритм содержал ошибки)</li></ul><p><strong><code>Как отличить неродное значение</code></strong></p><ul><li>В случае линейного пробирования, проверять все соседние занятые элементы до нахождения пустого значения<br>В случае сильно заполненной корзины, даже без наличия коллизий, может оказаться для что вставки нового значения потребуется проверить по порядку множество уже занятых значений (кластеры из занятых корзин). Аналогичная проблема при поиске несуществующего элемента.</li></ul><p>Тривиальный подход слежения за тем, чтобы не образовывались кластеры — хорошая хеш-функция и низкие значение коеффициенты заполненности (~0.5-0.6) для того, чтобы таблица разрослась раньше, чем в ней образовались большие кластеры из заполненных корзин. Более сложный — переставлять элементы внутри кластеров так, чтобы уменьшить количество необходимых поисков (алгориты <code>Брента</code>, <code>Робин Гуда</code>, детальнее ниже)</p><h2 id="Линейное-пробирование-без-перестановок"><a href="#Линейное-пробирование-без-перестановок" class="headerlink" title="Линейное пробирование без перестановок"></a>Линейное пробирование без перестановок</h2><p>Почти чистый вариант линейного пробирования без дополнительных хитростей с перестановками элементов приведен в [3].</p><p>Вариант из <code>daScript</code>:</p><ul><li>Рост таблицы при кластеризации в 2 раза. Чем больше таблица, тем меньше <a href="https://github.com/GaijinEntertainment/daScript/blob/a0fcdfdbf134d3dfb8055c9218c6e57ff4ae925b/include/daScript/simulate/runtime_table.h#L61" target="_blank" rel="noopener">коеффициент заполненности</a> (при увеличение таблицы в 2 раза разрешаем в 6 раз больше промахов)</li><li>Раздельное хранение хешей, хеширование <a href="https://github.com/GaijinEntertainment/daScript/blob/master/include/daScript/misc/fnv.h" target="_blank" rel="noopener">fnv</a></li><li>Tombstone при удалении</li></ul><p><a href="https://abseil.io/docs/cpp/guides/container" target="_blank" rel="noopener">absl::flat_hash_map</a> + <a href="https://abseil.io/about/design/swisstables" target="_blank" rel="noopener">Swiss Tables Design Notes</a><br>[1] - доклад с пошаговым описанием идей дизайна flat_hash_map + <a href="https://www.youtube.com/watch?v=JZE3_0qvrMg" target="_blank" rel="noopener">дополнение</a></p><ul><li>Раздельное хранение метаинформации + simd инструкции для ускорения проверок</li></ul><p>Пример возможной проблемы с кластеризацией значений:<br><img src="/blog/847579411/cluster_small.png" alt=""></p><p>Даже если все элементы отмеченные красным, стояли на своих местах, может получиться, что новый элемент (зеленый), будет вставлен далеко от своего потенциального места (первая стрелка).</p><p>Одна из неочевидных проблем линейного пробирования — про последовательном обходе элементов из хеш-таблицы (неявно отсортированы по возрастанию хешей) и перекладывании их в другую таблицу они попадут туда в очень плохом порядке (при добавлении второй половины таблицы до роста хеши элементов по модулю будут совпадать с хешами из первой половины, которая будет уже плотно заполнена — зона заполненности “от 0.5 до коэффициент роста” будет содержать большое количество коллизий) — пример багов в <a href="https://habr.com/ru/post/282902/" target="_blank" rel="noopener">Delphi</a>, <a href="http://lemire.me/blog/2017/01/30/maps-and-sets-can-have-quadratic-time-performance/" target="_blank" rel="noopener">Swift</a>, <a href="https://accidentallyquadratic.tumblr.com/post/153545455987/rust-hash-iteration-reinsertion" target="_blank" rel="noopener">Rust</a>. Возможное решение — использовать хеш-функцию с возможностью задать стартовый сид и менять его для каждой новой таблицы. Или попробовать предсказать размер заполняемой таблицы заранее.</p><h2 id="Линейное-хеширование-с-перестановкой-Брента"><a href="#Линейное-хеширование-с-перестановкой-Брента" class="headerlink" title="Линейное хеширование с перестановкой Брента"></a>Линейное хеширование с перестановкой Брента</h2><p>На скриншоте выше все элементы представленные красным стоят на своих местах, и могут быть найдены за 1 запрос к таблице. Но при поиске красного элемента нужно будет проверить 9 элементов. При этом, если все красные элементы кластера сдвинуть на 1 вправо, то для поиска каждого из них потребовалось бы всего 2 запроса — среднее время поиска осталось бы таким же, но максимальное время поиска уменьшилось бы с 9 до 2, в 4.5 раза. Метод Брента — перед вставкой проверить сколько запросов будет при такой перестановке и выбрать самый оптимальный вариант (<a href="https://www.cs.umd.edu/class/fall2018/cmsc420-0301/lecnotes/Hashing-spring17.pdf" target="_blank" rel="noopener">описание и пример</a>, а также какое-то расширение метода в поиск по дереву Gonnet-Munro, <a href="https://github.com/ncilengir/brent-hashing" target="_blank" rel="noopener">другое описание</a> и <a href="http://www.minkhollow.ca/Courses/461/Notes/Hashing/HashBrentex1.html" target="_blank" rel="noopener">другой пример</a>).</p><p>Реализация метода Брента в таблицах <a href="https://www.lua.org/source/5.4/ltable.c.html" target="_blank" rel="noopener">lua</a> и <a href="https://poga.github.io/lua53-notes/table.html" target="_blank" rel="noopener">описание</a></p><h2 id="Линейное-хеширование-с-перестановкой-Робин-Гуда"><a href="#Линейное-хеширование-с-перестановкой-Робин-Гуда" class="headerlink" title="Линейное хеширование с перестановкой Робин Гуда"></a>Линейное хеширование с перестановкой Робин Гуда</h2><p><a href="https://cs.uwaterloo.ca/research/tr/1986/CS-86-14.pdf" target="_blank" rel="noopener">Пейпер</a> с описанием метода, там же есть сравнение с методом Брента (стр 51-53) — чуть более быстрая вставка, за счет немного медленного среднего времени поиска, но более быстрая проверка несуществующего элемента. Позволяет заполнять таблицы на 90% перед тем, как увеличивать объём.</p><p>Логика вставки — если для уже сохраненного в слоте элемента расстояние до его идеальной позиции меньше, чем для нового, то “выселяем” элемент из слота, и проверяем дальше, с кем можно переставить его (“забираем позицию у богатого элемента и отдаём бедному”). <a href="http://web.stanford.edu/class/archive/cs/cs166/cs166.1196/lectures/13/Slides13.pdf" target="_blank" rel="noopener">Пример вставки</a></p><p>Описание в <a href="https://cglab.ca/~abeinges/blah/robinhood-part-1/" target="_blank" rel="noopener">Rust</a>:</p><ul><li>Линейное хеширование с перестановкой Робин Гуда</li><li>Рост таблицы после заполненности 0.9 в 2 раза</li><li>Хеш-функция с уникальным сидом для каждой таблицы для защиты от неудачной вставки ключей в порядке увеличения хеш-значений</li></ul><p><a href="https://github.com/skarupke/flat_hash_map" target="_blank" rel="noopener">ska::flat_hash_map</a>:</p><ul><li>Линейное хеширование с перестановкой Робин Гуда</li><li>Рост таблицы при первом длинном неудачном пробировании, до следующего prime number</li></ul><p><a href="https://probablydance.com/2017/02/26/i-wrote-the-fastest-hashtable/" target="_blank" rel="noopener">I Wrote The Fastest Hashtable</a> - описание<br>Используются для внутренних структур данных в <a href="https://github.com/GaijinEntertainment/daScript/blob/dcecc6f126843fc0914b0be314542caa658fc8d6/include/daScript/das_config.h#L34" target="_blank" rel="noopener">daScript</a><br>[5] - доклад автора о влиянии отдельных приёмов оптимизации (крутое объяснение форм графиков, можно прикинуть свои паттерны и размеры таблиц), сравнение с различными реализациями хеш карт и хинты реализации</p><h2 id="Бенчмарки"><a href="#Бенчмарки" class="headerlink" title="Бенчмарки"></a>Бенчмарки</h2><p>Несколько бенчмарков различных C++ реализаций, с описанием типов таблиц:<br><a href="https://martin.ankerl.com/2016/09/15/very-fast-hashmap-in-c-part-1/" target="_blank" rel="noopener">https://martin.ankerl.com/2016/09/15/very-fast-hashmap-in-c-part-1/</a><br><a href="https://martin.ankerl.com/2019/04/01/hashmap-benchmarks-01-overview/" target="_blank" rel="noopener">https://martin.ankerl.com/2019/04/01/hashmap-benchmarks-01-overview/</a><br><a href="https://martin.ankerl.com/2022/08/27/hashmap-bench-01/" target="_blank" rel="noopener">https://martin.ankerl.com/2022/08/27/hashmap-bench-01/</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Небольшой обзор типов хеш-таблиц, которые чаще всего встречаются в языках программирования.&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="dev" scheme="http://spiiin.github.io/tags/dev/"/>
    
  </entry>
  
  <entry>
    <title>Making tools for big games</title>
    <link href="http://spiiin.github.io/blog/2767873544/"/>
    <id>http://spiiin.github.io/blog/2767873544/</id>
    <published>2022-12-25T14:57:07.000Z</published>
    <updated>2022-12-25T17:51:51.467Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Тезисы из доклада технического директора <code>Guerilla</code> Michiel van der Leeuw <a href="https://www.guerrilla-games.com/read/making-tools-for-big-games" target="_blank" rel="noopener">Making tools for big games</a></p><a id="more"></a><p><strong><code>Вступление</code></strong></p><ul><li>Технология в геймдеве перестала определять игру и её геймдизайн, а является одной из фич игры</li><li>Технология сейчас — это не только движок игры, а её тулсет</li><li>Тулсет позволяет поддерживать масштабирование количества контента игр, а также следить за качеством и процессом производства</li><li>Респект автора доклада <code>Naughty Dog</code>, часть идей оттуда</li></ul><p><strong><code>Идея 1. Сокращение &quot;зоны сумерек&quot;, когда QA находятся между игрой, таск-трекером, браузером, vcs, мессенджером и почтовым клиентом</code></strong></p><ul><li>Кастомный интерфейс к vcs, шаблоны для заполнения полей близкие к стандартам компании</li><li>Соединение перед пуллом с билд сервером для сверки, в порядке ли ревизия, которую собираешься получить</li><li>In-game gui для оформления задач в Jira — запись видео, логгирование игровых ресурсов в кадре</li><li>Редактор видео, в котором можно отметить тайминг бага/задачи, связанные ассеты, разметить зоны и отрезать лишнее. Ссылки на фрейм видео можно добавлять в задачи</li><li>Ассеты хранятся в базе данных с метаинформацией. Среди прочего, хранят обратные ссылки на баги, ссылающиеся на эти ассеты.</li></ul><p>Выявить точки, из которых удобнее всего совершать действия, и из этих точек с помощью api к другим приложениям дать возможность работать с этими приложениями без переключения контекста. Убрать рутину.<br>Пара бонусных идей не из доклада:</p><ul><li>В code-review вычислять, какие из прошлых коммитов/мердж реквестов затрагивает диф кода и выводить список этих коммитов (“чей код ты потенциально мог сломать”).</li><li>Подтягивать к багу в Jira данные из всех систем аналатики (доступ ко всей полезной инфе на одной страничке)</li></ul><p><strong><code>Идея 2. Слежение за здоровьем билда позволяет увеличить количество итераций</code></strong></p><ul><li>Бот-фермы из девкитов, которые выполняют скрипты телепортации по миру и сохраняют профилирование, телеметрию и игровую информацию в виде карты мира, отдельный редактор для визуализации и изучения этой карты</li><li>Примеры применения — визуализатор информации для гейм-дизайнеров и непосредственно отладка геометрических данных (карты рек, эрозии, нормалей, карты видимости неба), heat-map тормозящих мест, визуализация мест багов в jira. Всю информацию можно посмотреть в других местах, но такое картографирование позволяет оценить общую картину</li><li>Запросы к данным для отображения на карте исторических данных (диффы, графики, экспорт в json/csv)</li><li>Вьюер карты тесно связан с игрой (можно получать графики производительности с девайсов и кол-во потребляемой памяти, а также делать отметки на графиках и ссылаться на них)</li><li>Метрика — количество изменений, которое команда может позволить себе без страха делать в последние дни/недели перед релизом</li></ul><p><a href="/blog/1687824628/" title="Паттерны организации разработки уровней игр">Паттерны организации разработки уровней игр</a> - итерации делают игру лучше, упрощая процесс разработки<br><a href="/blog/3309518526/" title="Системы поиска сокровищ">Системы поиска сокровищ</a> - итерации кроме полировки могут позволить найти новые уникальные решения</p><p>Глобальная карта для отображения оверлеями различной информации — отличный инструмент, кажется, впервые видел идею с тепловой картой производительности еще в докладе про <code>starcraft 2</code>. Я такое тоже делал, чтобы отслеживать ассеты, которые артисты/геймдизайнеры забыли правильно разметить.</p><p><strong><code>Идея 3. Работу с ассетами всегда можно улучшить</code></strong></p><ul><li>Всё висит на сервере в памяти и стримится на девелоперские машины (10 Gb сеть в локалке)</li><li>Позволило серьёзно уменьшить размер дубликатов ресурсов</li><li>Можно сгенерить строковый айдишник, по которому другой человек может запустить в точности такую же версию игры</li><li>Самописный сервер на 650 строк, БД с парами ключ значение, быстрее шеринг через SMB, NFS, файловый сервер Apache, etc</li><li>Виртуальная файловая система, ОС не видит изменений</li><li>18 core cpu, 768 Gb ram, 80 Gb network, 16 tb ssd на 300 человек</li></ul><p>Наиболее радикальная идея, работать локально с исходными версиями ассетов, и стримить ресурсы через глобальный общий сервер. Доклад 2019 года, когда все сидели в одном офисе, но в <a href="https://twitter.com/MvdLeeuwGG/status/1606268200143970304" target="_blank" rel="noopener">твиттере</a> автор упоминает, что адаптировали и для домашней работы. Кроме блоба ассета хранится также метаинформация (например, ссылки, в каких тасках он задействован).</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Тезисы из доклада технического директора &lt;code&gt;Guerilla&lt;/code&gt; Michiel van der Leeuw &lt;a href=&quot;https://www.guerrilla-games.com/read/making-tools-for-big-games&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Making tools for big games&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="link" scheme="http://spiiin.github.io/tags/link/"/>
    
      <category term="dev_method" scheme="http://spiiin.github.io/tags/dev-method/"/>
    
  </entry>
  
  <entry>
    <title>daScript tiny renderer port</title>
    <link href="http://spiiin.github.io/blog/3563373441/"/>
    <id>http://spiiin.github.io/blog/3563373441/</id>
    <published>2022-12-25T14:02:28.000Z</published>
    <updated>2022-12-25T14:31:25.242Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Портировал первые несколько примеров <a href="https://github.com/ssloy/tinyrenderer/wiki" target="_blank" rel="noopener">Tiny renderer or how OpenGL works: software rendering in 500 lines of code</a> софт-рендера с C++ на daScript. Механически и неоптимально, но близко к коду оригинального туториала, для желающих потренироваться в базовых алгоритмах растеризации на daScript.<br><a href="https://github.com/spiiin/dascript_soft_render" target="_blank" rel="noopener">https://github.com/spiiin/dascript_soft_render</a></p><p>Растеризация отрезков, wireframe<br><img src="/blog/3563373441/1.png" alt=""><br>Растеризация треугольников line sweeping, flat shading, отсечение задних граней<br><img src="/blog/3563373441/2.png" alt=""><br>Z-буфер, наложение текстурных координат<br><img src="/blog/3563373441/3.png" alt=""><br>Перспективная проекция<br><img src="/blog/3563373441/4.png" alt=""><br>Камера, Gouraud shading<br><img src="/blog/3563373441/5.png" alt=""><br>Коррекция перспективных искажений текстурных координат, растеризация треугольника проверкой барицентрических координат точки, пиксельный и вершинный шейдеры<br><img src="/blog/3563373441/6.png" alt=""></p><p>В оригинале есть ещё детальный разбор матриц (model, view, projection), наложение карты нормалей, тени и ambient occlusion. Но, мне кажется где-то с этого уровня можно продолжать разбираться с графикой уже с помощью графического API.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;Портировал
      
    
    </summary>
    
    
    
      <category term="opengl" scheme="http://spiiin.github.io/tags/opengl/"/>
    
      <category term="3d" scheme="http://spiiin.github.io/tags/3d/"/>
    
      <category term="dascript" scheme="http://spiiin.github.io/tags/dascript/"/>
    
  </entry>
  
  <entry>
    <title>Итоги 2021-2022</title>
    <link href="http://spiiin.github.io/blog/2738337723/"/>
    <id>http://spiiin.github.io/blog/2738337723/</id>
    <published>2022-11-28T11:59:06.000Z</published>
    <updated>2022-12-16T18:39:17.161Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Сумбурная попытка собрать в кучу события в жизни за 2 года. В конце 2021 не успел, в начале 2022 уже как-то не до того было. Допишу понемногу как раз к новому году.</p><a id="more"></a><p>Предыдущая - <a href="/blog/307513906/" title="Итоги 2020">Итоги 2020</a></p><p><strong><code>Дисклеймер</code></strong></p><p>Очень не хочется писать про войну, слишком сложно и больно написать что-то коротко. Поэтому, в основном, просто списки из нескольких запомнившихся книг/игр/посещенных стран etc с небольшими заметками</p><p><strong><code>Личное/путешествия</code></strong></p><p>В начале 2021 года накрыло выгоранием от работы, одновременно с ощущением, “надо развиваться, иначе пиздец” и питерской простудой (это которая потом может привести к больному зубу и гаймариту). Ушёл в длинный отпуск, лечиться, читать книжки и медитировать над тем, где пропустил важный поворот. Попутно женился (снова с поездкой в Крым и отдыхом в Многоречье, Евпатории и Балаклаве), наконец продал старый дом в Бахчисарае, доставшийся в наследство много лет назад, и слетал отдохнуть в Калинград с коллегами.<br><img src="/blog/2738337723/photo1.png" alt=""></p><p>Охта-парк в последние выходные в Питере<br><img src="/blog/2738337723/ohta.png" alt=""></p><p>2022-й год — внезапный “развесёлый” трип (безвозвратная релокация) Самарканд-Стамбул-Ереван.<br><img src="/blog/2738337723/photo2.png" alt=""></p><p>Армения очень гостеприимная страна, с множеством как официальных достопримечательностей, так и <a href="https://www.wirade.ru/cgi-bin/wirade/YaBB.pl?board=stories;action=display;num=1086946148" target="_blank" rel="noopener">маленьких</a> мест и историй. Особенно порадовал Дилижан и окрестности. Успел слетать в Анталию в отпуск и в Дубаи и Пхукет в командировку. Так что год выдался богатым на поездки и ощущения.<br><img src="/blog/2738337723/photo3.png" alt=""></p><p>В конце года оказался в Израиле. Если Армения почти не отличалась по флоре и фауне от Украины и России, то тут на деревьях можно увидеть попугаев, ночью — больших летающих мышей (точнее, даже летающих лисиц), и кабанов, разгуливающих по городу. Бросаются в глаза и отличия в ценах и порядках. Другой мир со своими правилами.<br><img src="/blog/2738337723/photo4.png" alt=""></p><p><strong><code>Работа</code></strong></p><p>За пару лет побыл тим-лидом, разработчиком движка и техническим продюсером. Кроме плюсов в виде большого количества контактов и понимания процессов работы компании, существуют и минусы такого движения — “шлейф” переходов излишне расширяет зоны ответственности, необходимо явно “отвязываться” от прошлых обязанностей.</p><p>Снова запустили софт-ланч матч-3 игры - <a href="https://mytona.com/game/15" target="_blank" rel="noopener">Tasty Makeover</a><br><img src="/blog/2738337723/tmo.png" alt=""></p><p>Получил на память серебрянный значок<br><img src="/blog/2738337723/mytona.png" alt=""></p><p><strong><code>Музыка</code></strong><br><code>Piazzolla - Libertango</code><br><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/elYSQkTWfTw" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div><br>Пьяццолла удивительным образом стимулирует творческое настроение, подсмотрел у авторов “Worlds of Goo”</p><p><code>Dave Stewart, Boris Grebenshikov &amp; Serhii Babkin - Face to Face (feat. Stevie Nicks)</code><br><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/dRFIoyeU_bg" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div><br>Сергей Бабкин — это гитарно-дворовое регги из детства, а у Бориса Гребенщикова, кроме музыки, попадалась еще хорошая инструкция по медитации.</p><p><code>The Death Set - They Come to Get Us</code><br><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/dleV9-9xXsw" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div><br>Немного драйва десятилетней давности.</p><p><code>DakhaBrakha - Carpathian rap</code><br><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/OKhV3kLTTv8" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div><br>Видеоряд и мистика.</p><p><code>Selena Gomez, Rauw Alejandro - Baila Conmigo</code><br><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/h5WN3pkxPF0" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></p><p><strong><code>Игры</code></strong></p><p><code>- Divinity Original Sin 2 (Switch)</code><br>Красивая и интересная тактика, в которой можно позалипать в дизайн локаций. Очень много часов геймплея, хорошая адаптация управления под консоль. Рассчитана явно на пару прохождений (физическая и магическая партия). Много подготовки — обновление ассортимента оружия на каждый уровень партии, необходимость “пылесосить” локации, с возможностью полной зачистки лагерей или даже деревень.<br><code>- Monster Hunter: Rise (Switch)</code><br>Необычная смесь RPG с элементами файтинга (различные комбо для различного оружия), крутое взаимодействие с окружением (набор бустов перед боем, изучение фишек локаций). Не очень понравился переход из сингл-плейера в мульти-плейер — одиночный сюжет просто обрывается, без возможности посмотреть и победить самых сильных боссов.<br><code>- Civilization 6 (Switch/PC)</code><br>Эмерджентные механики, которые расширяют возможности геймплея в дополнительных правилах и нациях. Геймплей с дополнениями и без сильно отличается. Хорошая кривая обучения игре — интересно играть как в первый раз, так и в сотый, обучаясь нюансам механик.<br><code>- C&amp;C Rivals (iOS/Android)</code><br>Игра в жанре Clash Royale, тактическая RTS с элементами карточной игры. Юниты более-менее сбалансированы, большинство из них требует микроконтроля для полноценной реализации их в бою. Вызвала хейт фанатов серии из-за забивания на лор, но тем не менее, необычный и самобытный проект.<br><code>- Risen 3 (PC)</code><br>Моё первое знакомство с играми Pyranha Bytes и их подходу к разработке игр. Ну и пиратский сеттинг всегда приятно увидеть.<br><code>- Axie Infinity (PC/Android/iOS)</code><br>NFT-игра, притом не pay-to-win, скорее похожая по стратегии игры на покер (а вообще — безумная смесь тактики, кки и покемонов). Заодно и понятны опасности экономик подобного типа игр — баловство разработчиков с балансом, от нерфа карт в середине сезона, до выпуска новых типов предметов, или вообще выпуска альтернативной игры со сменой всех механик; взломы кошельков с хранилищем крипты, возможность общего обрушения игры; часть экономики, зависимая от привлечения новых игроков в игру. Тем не менее, в предыдущей версии — могла затянуть на несколько ночей в построение идеальных команд с тетрадкой, ручкой и экселем. Заслуживает отдельной статьи.<br><img src="/blog/2738337723/axie.png" alt=""><br><code>- Valheim</code><br>Хардкорная выживалка-песочница про викингов, с необычной графикой. Простые и низкодетализированные текстуры (если верить книге “Понимание комиксов” — менее детализированное окружение = меньшая враждебность в восприятии игрока) и прикольные эффекты и звук создают интересное восприятия локаций.<br><code>-TMNT: Shredder’s Revenge (PC/Switch)</code><br>Идеальный beat-them-up для игры на двоих и более черепашек.<br><code>- Candy Crush/Homescapes/Royal Match (iOS/Android)</code><br>Профессиональное изучение жанра<br><code>- Disco Elisium (PC)</code><br>Классный русский перевод и одна из лучших РПГ, в которых можно действительно отыграть поведение<br><code>- Hades (PC)</code><br>Отличный пример дизайна — встраивание механики развития и сюжета в рогалик, эмерджентные механики комбинаций оружия и бонусов, нарративная связь кор-геймплея и меты, сюжетный путь героя<br><code>- Witcher 1-2 (PC)</code><br>По прежнему крутые для фанатов, особенно в сочетании с книгами и третьей частью. В том числе и основной линией сюжета, которая продолжает историю из книг и дает возможность повлиять на судьбу персонажей.<br><img src="/blog/2738337723/witcher1.png" alt=""><br><img src="/blog/2738337723/witcher2.png" alt=""><br><a href="https://www.dropbox.com/sh/kwgasmi89f4su3q/AABinxk2WKfun6rNulXrX6Tka?dl=0" target="_blank" rel="noopener">Больше моих скриншотов</a> из всех трёх “ведьмаков”.</p><p>Традиционно заканчиваю год просмотром треда со скриншотами из игр на neogaf, <a href="https://www.neogaf.com/threads/2022-pc-screenshot-thread-of-no-compromises.1626951/" target="_blank" rel="noopener">2022 год</a> (и <a href="/blog/2486469456/" title="прошлые">прошлые</a>). Лучше всего характеризует этот год:<br><a href="https://live.staticflickr.com/65535/52090974365_3ec1d1b1db_o.jpg" target="_blank" rel="noopener"><img src="/blog/2738337723/jump.png" alt=""></a></p><p><strong><code>Книги</code></strong></p><p>Из нетехнического:</p><p><code>- Никулин Н., &quot;Воспоминания о войне&quot;</code><br>Реальность и ужасы войны.<br><code>- Нил Шубин, &quot;Внутренняя рыба&quot;</code><br>Про то, как млекопитающие выходили на сушу. И про то, что человек — перестроенная рыба, что до сих пор прослеживается в особенностях строения, и иногда в болезнях.<br><code>- Уилсон Э., &quot;Планета муравьев&quot;</code><br>Особенности муравьиного общества<br><code>- Даррелл Дж., &quot;Гончие Бафута&quot;, &quot;Под пологом пьяного леса&quot;</code><br><a href="https://vas3k.club/post/9639/" target="_blank" rel="noopener">Даррелл</a> — человек, который занимался своим делом, несмотря на происходящие в мире события — войны, революции. Что бы ни происходило вокруг, он собирал животных во всех уголках земли.<br><code>- Кристофер Александер, &quot;Язык шаблонов&quot;, &quot;Timeless way to building&quot;</code><br>Интересно было изучить как минимум потому, что на книги Александера часто ссылается в книге и докладах Джесси Шелл. Ну и как сам способ выделения паттернов из общего, что можно использовать не только в архитектуре, но в и программировании.</p><p>Из технического:</p><p><a href="/blog/37481721/" title="О книгах и самообразовании">О книгах и самообразовании</a> — много всякого. Старые книги о программировании, новых языках программирования, книги и доклады за последние годы по геймдеву, всё до чего удалось дотянуться по геймдизайну, немного о продюссировании игр и психологии.</p><p><strong><code>Фильмы</code></strong></p><p><code>- Эдди &quot;Орёл&quot;</code><br>Рассказ про отбитого прыгуна с трамплина на лыжах, который нашёл баг в правилах, и выступил на олимпиаде, не заморачиваясь общественным мнением. <a href="https://ru.wikipedia.org/wiki/%D0%AD%D0%B4%D0%B2%D0%B0%D1%80%D0%B4%D1%81,_%D0%AD%D0%B4%D0%B4%D0%B8" target="_blank" rel="noopener">Эдди Эдвардс</a>, много интересных фактов из биографии.<br><code>- Серьёзный человек</code><br>Черная комедия, нарушаюшая закон кино о том, что у совпадений должно быть какое-нибудь объяснение<br><code>- Душа</code><br>Мультик о поиске смысла и цели в жизни<br><code>- Терминал</code><br>Искренне сочувствуешь персонажу только в случае, когда понимаешь, что оказаться в подобной ситуации вполне реально<br><code>- Курс лекций Tymoty Snider по истории Украины</code><br>Бесплатные <a href="https://www.youtube.com/playlist?list=PLh9mgdi4rNewfxO7LhBoz_1Mx1MaO6sw_" target="_blank" rel="noopener">лекции</a> Йельского университета 2022 года. Интересно сравнить с российским и украинским видением истории страны.</p><p><strong><code>Приобретения</code></strong><br>iPad чтобы смотреть фильмы и читать комиксы и пачка low-end телефонов на андроиде для исследований багов и оптимизаций игр. Но в основном вспоминаются потери оставленного при переезде =\</p><p><strong><code>Развитие</code></strong><br>Изучил <code>историю C++</code> и <code>подхода ООП (в smalltalk)</code>, немного глубже вник в <code>STL</code> и библиотек <code>boost</code>, наконец посмотрел на относительно новые языки (<code>nim</code>, <code>go</code>, <code>racket</code>, <code>daScript</code>). Особенно заинтересовал <a href="https://spiiin.github.io/tags/dascript/">daScript</a> огромным потенциалом и заложенными в него идеями.</p><p>Прокачал немножко экспертизу в геймдеве в общем, занялся английским (с мотивацией делать это сильно проще, чем просто ради изучения), и прочитал несколько книг по истории.</p><p>Немного практиковался в жонглировании на скорость, получилось придумать, как прокачать каскад до <a href="https://youtu.be/VoyR2o0W5T8" target="_blank" rel="noopener">402 бросков в минуту</a> — не <a href="https://youtu.be/MDnMhMTekI0?t=128" target="_blank" rel="noopener">мировой рекорд</a>, но уже <a href="https://www.youtube.com/watch?v=Hd6Du2bYcRo" target="_blank" rel="noopener">быстрее всех</a> в России. Обнаружил у себя <a href="https://vas3k.club/post/1412/" target="_blank" rel="noopener">афантазию</a> (на самом деле, правильнее называть это “а-визуализацией”, с фантазией всё в порядке) — невозможность видеть образы с закрытыми глазами. Очень необычно осознать себя ощущающим мир не так, как большинство людей.</p><p><img src="/blog/2738337723/kfox.png" alt=""><br><em>Нейронные сети изображают играющих лис</em></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Сумбурная попытка собрать в кучу события в жизни за 2 года. В конце 2021 не успел, в начале 2022 уже как-то не до того было. Допишу понемногу как раз к новому году.&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="log" scheme="http://spiiin.github.io/tags/log/"/>
    
  </entry>
  
  <entry>
    <title>Уровень программирования: Senior++</title>
    <link href="http://spiiin.github.io/blog/1976052536/"/>
    <id>http://spiiin.github.io/blog/1976052536/</id>
    <published>2022-11-21T09:16:32.000Z</published>
    <updated>2022-12-21T13:26:37.211Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Предыдущая пачка:<br><a href="/blog/1048/" title="Как устроиться на работу программистом">Как устроиться на работу программистом</a><br><a href="/blog/15798/" title="Уровень программирования: Middle">Уровень программирования: Middle</a><br><a href="/blog/3652741154/" title="10 лет в геймдеве">10 лет в геймдеве</a><br><a href="/blog/258274191/" title="Уровень программирования: Senior">Уровень программирования: Senior</a></p><p>Качается всё то же, что и на предыдущем “уровне” — накопление критической массы знаний, и попытки их систематизировать.</p><p><img src="/blog/1976052536/fin.png" alt=""></p><h2 id="Миф"><a href="#Миф" class="headerlink" title="Миф"></a>Миф</h2><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/6_OUwXl8T_Y?start=981%2C" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div><p>Misha Nestor - Антропологический менеджмент и лидерство</p><p>Миф — не о поиске магии или мистике, а о совпадении ценностей и поиске смыслов.</p><img style="background-color:white;text-align:center;" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTg5IiBoZWlnaHQ9IjM0MSIgdmVyc2lvbj0iMS4xIiBiYXNlUHJvZmlsZT0iZnVsbCIgdmlld2JveD0iMCAwIDE4OSAzNDEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHhtbG5zOmV2PSJodHRwOi8vd3d3LnczLm9yZy8yMDAxL3htbC1ldmVudHMiIHN0eWxlPSJmb250LXdlaWdodDpib2xkOyBmb250LXNpemU6MTJwdDsgZm9udC1mYW1pbHk6J0NhbGlicmknLCBIZWx2ZXRpY2EsIHNhbnMtc2VyaWY7O3N0cm9rZS13aWR0aDozO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbGluZWNhcDpyb3VuZCI+PHBhdGggZD0iTTk1IDQ0LjUgTDk1IDY0LjUgTDk1IDg0LjUgTDk1IDg0LjUgIiBzdHlsZT0ic3Ryb2tlOiMzMzMyMkU7ZmlsbDpub25lO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTsiPjwvcGF0aD4KPHBhdGggZD0iTTg5LjcgNzEuMiBMOTUgNzcuOCBMMTAwLjMgNzEuMiBMOTUgODQuNSBaIiBzdHlsZT0ic3Ryb2tlOiMzMzMyMkU7ZmlsbDojMzMzMjJFO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTsiPjwvcGF0aD4KPHBhdGggZD0iTTk1IDExNS41IEw5NSAxMzUuNSBMOTUgMTU1LjUgTDk1IDE1NS41ICIgc3R5bGU9InN0cm9rZTojMzMzMjJFO2ZpbGw6bm9uZTtzdHJva2UtZGFzaGFycmF5Om5vbmU7Ij48L3BhdGg+CjxwYXRoIGQ9Ik04OS43IDE0Mi4yIEw5NSAxNDguOCBMMTAwLjMgMTQyLjIgTDk1IDE1NS41IFoiIHN0eWxlPSJzdHJva2U6IzMzMzIyRTtmaWxsOiMzMzMyMkU7c3Ryb2tlLWRhc2hhcnJheTpub25lOyI+PC9wYXRoPgo8cGF0aCBkPSJNOTUgMTg2LjUgTDk1IDIwNi41IEw5NSAyMjYuNSBMOTUgMjI2LjUgIiBzdHlsZT0ic3Ryb2tlOiMzMzMyMkU7ZmlsbDpub25lO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTsiPjwvcGF0aD4KPHBhdGggZD0iTTg5LjcgMjEzLjIgTDk1IDIxOS44IEwxMDAuMyAyMTMuMiBMOTUgMjI2LjUgWiIgc3R5bGU9InN0cm9rZTojMzMzMjJFO2ZpbGw6IzMzMzIyRTtzdHJva2UtZGFzaGFycmF5Om5vbmU7Ij48L3BhdGg+CjxwYXRoIGQ9Ik05NSAyNTcuNSBMOTUgMjc3LjUgTDk1IDI5Ny41IEw5NSAyOTcuNSAiIHN0eWxlPSJzdHJva2U6IzMzMzIyRTtmaWxsOm5vbmU7c3Ryb2tlLWRhc2hhcnJheTpub25lOyI+PC9wYXRoPgo8cGF0aCBkPSJNODkuNyAyODQuMiBMOTUgMjkwLjggTDEwMC4zIDI4NC4yIEw5NSAyOTcuNSBaIiBzdHlsZT0ic3Ryb2tlOiMzMzMyMkU7ZmlsbDojMzMzMjJFO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTsiPjwvcGF0aD4KPHJlY3QgeD0iMTMuNSIgeT0iMTMuNSIgaGVpZ2h0PSIzMSIgd2lkdGg9IjE2MyIgc3R5bGU9InN0cm9rZTojMzMzMjJFO2ZpbGw6I2VlZThkNTtzdHJva2UtZGFzaGFycmF5Om5vbmU7Ij48L3JlY3Q+Cjx0ZXh0IHg9IjIxLjUiIHk9IjM1IiBzdHlsZT0iIj7QvNC40YQg0L4g0YHQtdCx0LU8L3RleHQ+CjxyZWN0IHg9IjE1LjUiIHk9Ijg0LjUiIGhlaWdodD0iMzEiIHdpZHRoPSIxNjAiIHN0eWxlPSJzdHJva2U6IzMzMzIyRTtmaWxsOiNlZWU4ZDU7c3Ryb2tlLWRhc2hhcnJheTpub25lOyI+PC9yZWN0Pgo8dGV4dCB4PSIyMy41IiB5PSIxMDYiIHN0eWxlPSIiPtC+0LrRgNGD0LbQtdC90LjQuDwvdGV4dD4KPHJlY3QgeD0iMjMuNSIgeT0iMTU1LjUiIGhlaWdodD0iMzEiIHdpZHRoPSIxNDQiIHN0eWxlPSJzdHJva2U6IzMzMzIyRTtmaWxsOiNlZWU4ZDU7c3Ryb2tlLWRhc2hhcnJheTpub25lOyI+PC9yZWN0Pgo8dGV4dCB4PSIzMS41IiB5PSIxNzciIHN0eWxlPSIiPtC60L7QvNC/0LDQvdC40Lg8L3RleHQ+CjxyZWN0IHg9IjIzLjUiIHk9IjIyNi41IiBoZWlnaHQ9IjMxIiB3aWR0aD0iMTQ0IiBzdHlsZT0ic3Ryb2tlOiMzMzMyMkU7ZmlsbDojZWVlOGQ1O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTsiPjwvcmVjdD4KPHRleHQgeD0iMzEuNSIgeT0iMjQ4IiBzdHlsZT0iIj7QvtCx0YnQtdGB0YLQstC1PC90ZXh0Pgo8cmVjdCB4PSI1NS41IiB5PSIyOTcuNSIgaGVpZ2h0PSIzMSIgd2lkdGg9IjgwIiBzdHlsZT0ic3Ryb2tlOiMzMzMyMkU7ZmlsbDojZWVlOGQ1O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTsiPjwvcmVjdD4KPHRleHQgeD0iNjMuNSIgeT0iMzE5IiBzdHlsZT0iIj7QvNC40YDQtTwvdGV4dD48L3N2Zz4=" /><p><a href="/blog/1363625753/" title="Мотивация &quot;честного&quot; программиста">Мотивация &quot;честного&quot; программиста</a> — мои поиски профессионального личного мифа.</p><p>Основная идея — современное общество вокруг дисциплинарное, и “миф по умолчанию” для компаний — фабрика, серийное производство, в котором люди становятся похожи на механизмы. В таких условиях многим становится некомфортно, что не способствует ни творческой работе, ни выкладыванию на творческий максимум (в понятиях фабрики более ценится “средняя”, но предсказуемая работа). Один из способов работать в таких условиях — осознанное слежение за уровнем комфорта вокруг рабочих процессов.</p><p><a href="/blog/1152742413/" title="Города, которые мы выбираем">Города, которые мы выбираем</a> — миф о компании и обществе.<br>На нас сильно влияет среда вокруг — пространство и информационный фон. Люди с общей идеей собираются в определенных местах, и в таких местах возможна передача знаний и идей. Чтобы “загореться” разумом, необходимо чтобы кто-то из других людей вокруг уже горел. Ребёнок, воспитанный животными, после определенного возраста, не сможет интегрироваться в общество людей. Также и с более продвинутыми знаниями — не получив культурный импринт, невозможно рассуждать о сложных вещах, хотя возможно пытаться повторить их с помощью карго-ритуалов.</p><p>При повышении роли в компании часто отсутствует схема ритуала/инициации/личного кризиса, сопутствующего “переходу”. Из-за этого человек либо проходит это сам, либо за ним тянется “шлейф” предыдущих обязанностей/форм работы.</p><p><em>Материалы — Джесси Шелл, Кристофер Александер, Джозеф Кэмпбелл, Алан Кэй, Рич Хики, Пол Грем</em></p><h2 id="Карты-знаний"><a href="#Карты-знаний" class="headerlink" title="Карты знаний"></a>Карты знаний</h2><p>Прежде чем накапливать и систематизировать знания, можно “осмотреться”, как рассуждают о знаниях/скиллах другие.</p><p><strong>Примеры матрицы/графа/списка материалов и компетенций</strong><br><a href="https://github.com/miloyip/game-programmer" target="_blank" rel="noopener">A study path for game programmer</a> — материалы из нескольких областей для геймдев-программиста, разделены на основные и дополнительные.<br><a href="https://tlroadmap.io/guide.html" target="_blank" rel="noopener">Teamlead Roadmap</a> — роадпам тимлида. Сумма компетенций тимлида по опросам российских IT-компаний. Обязанностей где-то на 2-3 людей, упор на скиллы лида, менеджера, cto (как “директора программистов”), а не технические скиллы<br><a href="https://sijinjoseph.netlify.app/programmer-competency-matrix/" target="_blank" rel="noopener">Programmer Competency Matrix</a> — схема оценки навыков программиста. Очень странный выбор примеров знаний, но иллюстрирует экпоненциальный рост знаний с переходом на каждый новый уровень</p><p><strong>Списки книг</strong><br><a href="https://30minbooks.livejournal.com/11011.html" target="_blank" rel="noopener">Список книг от Алана Кея</a> — список рекомандаций для студентов CS. Часто, если смотреть выступления Кея, можно понять, что он рекомендует не книгу, а какую-то конкретную идею в ней.<br>Другие варианты — разобрать список интересной рекомендуемой литературы в любой серьёзной книге (одной-двух) — в качестве примеров: <strong><code>&quot;Книга линз&quot; Джесси Шелла</code></strong> и <strong><code>&quot;Архитектура Игрового движка&quot; Джейсона Грегори</code></strong>.<br><a href="/blog/3649678047/" title="Путь гейм-дизайнера">Путь гейм-дизайнера</a> — мой граф по Джесси Шеллу.</p><p><strong>Примеры вопросов на собеседованиях в геймдев-компании</strong><br><a href="https://web.archive.org/web/20191006063124/http://blog.gamedeff.com/?p=64" target="_blank" rel="noopener">Интервью глазами пострадавшего</a> — образец интервью из 2007, Midway Home Entertaiment<br><a href="Interviewing for Game Programming">Interviewing for Game Programming</a> — более свежий образец, примерно такого же уровня</p><p><strong>Варианты того, что можно и нужно изучать</strong><br>(список направлений для геймдева, навскидку)</p><ul><li>render</li><li>железо, особенности архитектуры, проц/память/видео</li><li>популярные движки unity/unreal/godot</li><li>dod/ecs</li><li>llvm/libclang и инфраструктура</li><li>multithreading/async программирование</li><li>unreal blueprints, визуальное программирование</li><li>скриптовые языки daScript/lua-jit</li><li>идеи в языках go/rust/closure/scala/nim/zig/racket</li><li>внутренности библиотек stl/boost, структуры данных</li><li>gamedev-specific математика и алгоритмы</li><li>тулзы git/серверы сборки/системы задач/cd-ci и прочее</li><li>пайплайны работы, устройство организаций, agile/lean/scrum</li><li>способы генерации арта</li><li>сеть, звук, системы анимаций, ии в играх, компрессия, форматы данных etc etc etc</li></ul><p><strong>Примеры видения сотрудников от компаний</strong><br><a href="http://media.steampowered.com/apps/valve/hbook-RU.pdf" target="_blank" rel="noopener">Valve</a>, <a href="https://www.dropbox.com/s/0z2p0qokdmm6eaw/Roblox%20Rendering%20-%20Career%20Guide%20v1.1public.pdf?dl=0" target="_blank" rel="noopener">Roblox</a>, <a href="https://www.gameenginebook.com/resources/SINFO.pdf" target="_blank" rel="noopener">Naughty Dog</a>, <a href="https://aras-p.info/texts/files/201410-TUM-HobbyEngineToGameEngine.pdf" target="_blank" rel="noopener">Unity</a>, разделение программистов в <a href="https://youtu.be/9nB_8LDaEVE?t=705" target="_blank" rel="noopener">IO Inreractive/Square Enix</a> от Bobby Anguelov.</p><p>Можно использовать для обнаружения пробелов в знаниях для того, чтобы их заполнять в свободное время, карьерного планирования, а также для обнаружения интересных “зацепок” в культуре других компаний.</p><h2 id="Как-и-зачем-заниматься-самообразованием"><a href="#Как-и-зачем-заниматься-самообразованием" class="headerlink" title="Как и зачем заниматься самообразованием"></a>Как и зачем заниматься самообразованием</h2><p><a href="/blog/37481721/" title="О книгах и самообразовании">О книгах и самообразовании</a> - про свой способ чтения книг, а также развернуто зачем заниматься самообразованием.</p><p>Соберу и дополню список возможных ответов “зачем”:</p><ul><li>несмотря на то, что на работе знания могут не понадобится сейчас или в ближайшем будущем, они попадут в список скиллов (“тебя не будут просить делать то, что ты умеешь плохо”)</li><li>над тобой всегда есть несколько уровней развития, которых ты не видишь с текущего (парадокс блаба)</li><li>шанс найти инсайты в соседних областях, которые не изучены в твоей области (либо получить синергию знаний от двух направлений)</li><li>возможность оценить компетенции коллег и руководства (или кандидатов при подборе команды), а также улучшить возможности профессионального взаимодействия</li><li>возможность делать новые для себя или более крутые вещи, которые не умел делать раньше</li><li>знание и понимание rocket-science решений</li><li>обнаружение готовых решений, умение их оценить, видеть весь спектр возможных решений (антибиблиотека Умберто Эко)</li><li>возможность учиться идеям у лучших (“поджечь свой факел разума от уже горящих”)</li><li>обойти грабли, на которые уже наступили десятки людей, понимание открытых проблем</li><li>обновление знаний и подходов (иначе когда случится очередная <a href="/blog/2786387393/" title="вомгла">вомгла</a>, работу сложно будет найти)</li><li>систематизация, даже неуклюжая, неплохо прокачивает понимание</li><li>шанс понять свои сильные и слабые стороны (а также, возможно, <a href="/blog/4256110900/" title="&quot;эволюционировать&quot;">&quot;эволюционировать&quot;</a> в другую геймдев-профессию)</li></ul><p><strong><code>&quot;Как заниматься&quot;</code></strong>.</p><p>“Традиционный путь в программисты” — это прочитать пару книг по языку и перейти от теории к практике (попутно нафаршировав голову в универе всяким computer scienсe, engeneering, math или еще чем-нибудь). Дальше обычно с некоторой периодичностью изучаются мануалы или best practices, но чаще всего ведущим способом изучения является практика. В такой схеме сильно страдают еще два способа набора знаний:</p><p><strong>Наблюдение</strong><br> Что делают другие и с какими целями:</p><ul><li>изучение докладов с профильных конференций</li><li>профессиональное общение</li><li>изучение open-source кода</li><li>использование различных middleware-инструментов</li><li>играть в игры конкурентов<br>Примеры задачек на наблюдение:</li><li>найти 10 субъективно наиболее интересных библиотек из boost (abseil/folly/eastl или еще какой-нибудь base library) и разобраться, с какой целью они сделаны и как устроены</li><li>найти 10 устаревших <a href="https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms" target="_blank" rel="noopener">идиом</a> C++ и посмотреть, почему они устарели, и что предлагает язык сейчас</li><li>изучить <a href="/blog/2826376146/" title="примитивы">примитивы</a> асинхронного программирования в 5-10 языках программирования (варианты — реализации хеш-таблиц/сборщиков мусора/конкретные оптимизации компилятора)</li><li>выбрать какую-нибудь популярную open-source библиотеку (например, <a href="https://github.com/bkaradzic/bgfx#who-is-using-it-madewithbgfx" target="_blank" rel="noopener">bgfx</a>) и пройтись по 5-10 примерам сделанным с её помощью проектам, изучить их фичи, а также изучить все 3rdParty библиотеки, которые используют эти проекты (или пройтись по уже собранным коллекциям, <a href="https://github.com/floooh/bookmarks" target="_blank" rel="noopener">пример</a>)</li><li>выбрать какую-нибудь фичу популярного движка, которую можно отделить, и попробовать реализовать её самому from scratch быстрее/удобнее/лучше чем то, что уже существует (например, реализация <a href="https://github.com/BobbyAnguelov/Esoterica" target="_blank" rel="noopener">системы анимаций</a> “как в трипл-эй движках” от Bobby Anguelov)<br><em>тут у него скорее наблюдение + тинкеринг + мышление</em></li><li>попробовать откопать максимум информации про устройство какой-нибудь фичи, которая понравилась в игре (к примеру, кастомизация персонажей в Sims)</li></ul><p><strong>Мышление</strong></p><ul><li>систематизация</li><li>придумывание</li><li>выводы</li><li>улучшение лучших решений</li></ul><p>Кажется, именно из-за пробелов в этих направлениях и возникает необходимость периодического заныривания в тонны материалов (в дальнейшем, систематизация позволяет значительно сократить время, просеивая эти объёмы). Так что, логично было бы более равномерно заниматься каждым из 4х способов прокачки:</p><p><img src="/blog/1976052536/scheme.png" alt=""></p><p><em>тинкеринг — то же, что и практика, свободные эксперименты с кодом</em></p><h2 id="Общение"><a href="#Общение" class="headerlink" title="Общение"></a>Общение</h2><p>От управления командой развитие общения идёт по пути расширения круга профессиональных знакомств, чтобы начинала работать “магия нетворкинга”, что в теории, иногда позволяет эффективно решать задачи типа таких:</p><ul><li>Нужен классный профильный специалист, разобраться с пачкой проблем, которые мы толком не понимаем как решить - затюнить андроид-порт движка, или выловить пачку мутных крешей где-то на границе мутных 3rdParty сдк и NDK (андроидщики в геймдеве, впрочем, кажется, всем нужны)<br>Или возможно, и в обратную сторону:</li><li>Фанатею от игр компании XXX и горю желанием там работать (или же “мечтаю сделать более крутую версию игры YYY, ищу единомышленников”)</li></ul><p>Примеры способов заявлять о себе</p><ul><li>совместная работа в прошлом</li><li>тематические онлайн или оффлайн тусовки (как участие, так и организация)</li><li>случайные знакомства (хех, в “правильных” городах шанс такого больше)</li><li>курсы/стажировки/лекции/конкурсы как платформа для общения и знакомств</li><li>медиа - подкасты, блоги</li></ul><p>Нетворкинг и взаимодействие с людьми разных скиллов также позволяет оценить важность diversity — группа людей с разным бекграундом и навыками может эффективнее решать сложные задачи.</p><p>Также, с какого-то момента приходит понимание, какие типы людей не могут нормально работать в командах — <a href="/blog/2316905704/" title="Про увольнения">Про увольнения</a><br></p><p>Отдельная, скорее субкультурная, тема — выстраивание “моста между поколениями”, изучение истории игр, а также эволюции компаний и методов разработки (<a href="https://app2top.ru/industry/10-knig-ob-istorii-igrovoj-industrii-126776.html" target="_blank" rel="noopener">пример подборки</a>). Не могу утверждать о конкретной пользе, но, кажется, это имеет и элементы медиа, и элементы объединяющего индустрию мифа.</p><p>Еще один способ взаимодействовать с командой — пропускать всё общение и код коллег через призму, “а возможно ли было бы переиспользовать решение в других местах/хотел бы я работать с этим человеком, если бы было нужно начинать новый проект и было необходимо собрать команду из тех, кто есть сейчас”.</p><p>Развитие себя при работе в команде — не личная, а общекомандная задача, можно вырасти выше команды на одну голову, но невозможно на три. Необходимо или тянуть команду вверх, или менять, или работать отдельно от группы.</p><h2 id="Жизненный-план"><a href="#Жизненный-план" class="headerlink" title="Жизненный план"></a>Жизненный план</h2><p>Обозначить цели и сроки, что хочется сделать и когда. Точно стоит обратить внимание на то, чтобы не терять здоровье и близких людей, а также на изучение языков. Полезно (и невероятно сложно!) попробовать обозначить собственные личные/профессиональные недостатки, и попробовать исправить один из них — хороший повод задуматься о себе.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;Предыдущая
      
    
    </summary>
    
    
    
      <category term="dev_evolution" scheme="http://spiiin.github.io/tags/dev-evolution/"/>
    
  </entry>
  
  <entry>
    <title>daScript. Brainfuck и оптимизации</title>
    <link href="http://spiiin.github.io/blog/621874082/"/>
    <id>http://spiiin.github.io/blog/621874082/</id>
    <published>2022-11-11T15:42:54.000Z</published>
    <updated>2023-01-14T14:30:04.951Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Попробовал портировать с <code>nim</code> на <code>daScript</code> <a href="https://howistart.org/posts/nim/1/" target="_blank" rel="noopener">интерпретатор</a> <code>brainfuck</code> кода. Брейфак предельно простой язык, и базовая реализация интерпретатора занимает полчаса, но на нём можно потренироваться в ускорении кода и продемонстрировать возможности daScript в оптимизации.</p><a id="more"></a><p>Самая первая, максимально наивная, построчно скопированная реализация:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">require strings</span><br><span class="line">require fio</span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">run</span><span class="params">(code: <span class="built_in">string</span>; var tape: <span class="built_in">array</span>&lt;uint8&gt;; var codePos, tapePos: <span class="keyword">int</span>&amp;; skip: <span class="keyword">bool</span>)</span>: <span class="keyword">bool</span></span></span><br><span class="line"><span class="function"><span class="keyword">while</span> tapePos &gt;</span>= <span class="number">0</span> &amp;&amp; codePos &lt; length(code)</span><br><span class="line"><span class="keyword">if</span> tapePos &gt;= length(tape) &#123; tape |&gt; push(uint8(<span class="number">0</span>)); &#125;</span><br><span class="line"></span><br><span class="line">let sym1  = code |&gt; character_at(codePos)</span><br><span class="line"><span class="keyword">if</span> sym1 == <span class="string">'['</span></span><br><span class="line">++codePos</span><br><span class="line">let oldPos = codePos</span><br><span class="line"><span class="keyword">while</span> run(code, tape, codePos, tapePos, tape[tapePos] == uint8(<span class="number">0</span>))</span><br><span class="line">codePos = oldPos</span><br><span class="line">elif sym1 == <span class="string">']'</span></span><br><span class="line"><span class="keyword">return</span> tape[tapePos] != uint8(<span class="number">0</span>)</span><br><span class="line">elif !skip</span><br><span class="line">let sym  = code |&gt; character_at(codePos)</span><br><span class="line"><span class="keyword">if</span> sym == <span class="string">'+'</span> &#123; tape[tapePos] = uint8(<span class="keyword">int</span>(tape[tapePos]) + <span class="number">1</span>); &#125;</span><br><span class="line">elif sym == <span class="string">'-'</span> &#123; tape[tapePos] = uint8(<span class="keyword">int</span>(tape[tapePos]) - <span class="number">1</span>); &#125;</span><br><span class="line">elif sym == <span class="string">'&gt;'</span> &#123; ++tapePos; &#125;</span><br><span class="line">elif sym == <span class="string">'&lt;'</span> &#123; --tapePos; &#125;</span><br><span class="line">elif sym == <span class="string">'.'</span> &#123; print(<span class="string">"&#123;int(tape[tapePos]) |&gt; to_char&#125;"</span>); &#125;</span><br><span class="line">elif sym == <span class="string">','</span> &#123; tape[tapePos] = uint8(getchar()); &#125;</span><br><span class="line"><span class="keyword">else</span> &#123; &#125;</span><br><span class="line">++codePos</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">def interpret(code: <span class="built_in">string</span>)</span><br><span class="line">let totalTime = ref_time_ticks()</span><br><span class="line">var tape: <span class="built_in">array</span>&lt;uint8&gt;</span><br><span class="line">var codePos, tapePos : <span class="keyword">int</span></span><br><span class="line">run(code, tape, codePos, tapePos, <span class="literal">false</span>)</span><br><span class="line">let totalDt = <span class="keyword">double</span>(get_time_usec(totalTime)) /<span class="number">1000000.0l</span>f</span><br><span class="line">to_log(LOG_INFO, <span class="string">"total &#123;totalDt&#125; sec\n"</span>)</span><br></pre></td></tr></table></figure><p>Если попытаться протестировать его на генераторе <a href="https://github.com/def-/nim-brainfuck/blob/master/examples/mandelbrot.b" target="_blank" rel="noopener">множества Мандельброта</a>, можно заметить серьёзные проблемы со скоростью, вычисления занимают около 5 часов. Стоит попробовать его разогнать!</p><h2 id="Отключение-проверок-границ-и-указателей"><a href="#Отключение-проверок-границ-и-указателей" class="headerlink" title="Отключение проверок границ и указателей"></a>Отключение проверок границ и указателей</h2><p>Код на brainfuck - это простая числодробилка, ускорить которую можно, отключив все дополнительные проверки обращений к памяти.</p><p><em>Как отключать проверки, мне рассказал <a href="https://github.com/borisbat" target="_blank" rel="noopener">Борис Баткин</a> (так как интерпретатор nim делал один основных контрибьютеров языка, то его подсказки не отменяют честности сравнения — авторы находятся в одной “весовой категории” знания своего языка).</em></p><p>В первую очередь, можно заменить функцию <code>charcter_at</code>, которая <a href="https://github.com/GaijinEntertainment/daScript/blob/e9f4c486848a8985e4126e0fc2d04afbc6abd883/src/builtin/module_builtin_string.cpp#L26" target="_blank" rel="noopener">проверяет</a>,что индекс меньше длины строки, на <code>character_uat</code>, которая не делает этой проверки.</p><p>Также отключается проверка ссылок на null макросом <code>[unsafe_deref]</code>.</p><p>Наконец, обращение к массиву можно выполнять не через разыменование ссылки, а через обращение по указателю:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">tape: <span class="built_in">array</span>&lt;uint8&gt;</span><br><span class="line">tape[index] <span class="comment">// tape[check_range(index)] //медленно</span></span><br><span class="line"></span><br><span class="line">var ptape: uint8? = addr(tape[<span class="number">0</span>])</span><br><span class="line">ptape[index] <span class="comment">//check_not_null(ptape)[index] //быстрее, обращение без проверок</span></span><br><span class="line"></span><br><span class="line">[unsafe_deref]</span><br><span class="line">ptape[index] <span class="comment">//ptape[index] //еще быстрее, обращение без перепроверок указателя на nullptr</span></span><br></pre></td></tr></table></figure><p>Переписанная версия кода:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[unsafe_deref]</span><br><span class="line"><span class="function">def <span class="title">run</span><span class="params">(code: uint8?; lengthOfCode:<span class="keyword">int</span>; var tape: uint8?; var codePos, tapePos: <span class="keyword">int</span>&amp;; skip: <span class="keyword">bool</span>)</span>: <span class="keyword">bool</span></span></span><br><span class="line"><span class="function">unsafe</span></span><br><span class="line"><span class="function"><span class="keyword">while</span> tapePos &gt;</span>= <span class="number">0</span> &amp;&amp; codePos &lt; lengthOfCode</span><br><span class="line">let sym1  = <span class="keyword">int</span>(code[codePos])</span><br><span class="line"><span class="keyword">if</span> sym1 == <span class="string">'['</span></span><br><span class="line">++codePos</span><br><span class="line">let oldPos = codePos</span><br><span class="line"><span class="keyword">while</span> run(code, lengthOfCode, tape, codePos, tapePos, tape[tapePos] == uint8(<span class="number">0</span>))</span><br><span class="line">codePos = oldPos</span><br><span class="line">elif sym1 == <span class="string">']'</span></span><br><span class="line"><span class="keyword">return</span> tape[tapePos] != uint8(<span class="number">0</span>)</span><br><span class="line">elif !skip</span><br><span class="line">let sym  = <span class="keyword">int</span>(code[codePos])</span><br><span class="line"><span class="keyword">if</span> sym == <span class="string">'+'</span> &#123; tape[tapePos] = uint8(<span class="keyword">int</span>(tape[tapePos]) + <span class="number">1</span>); &#125;</span><br><span class="line">elif sym == <span class="string">'-'</span> &#123; tape[tapePos] = uint8(<span class="keyword">int</span>(tape[tapePos]) - <span class="number">1</span>); &#125;</span><br><span class="line">elif sym == <span class="string">'&gt;'</span> &#123; ++tapePos; &#125;</span><br><span class="line">elif sym == <span class="string">'&lt;'</span> &#123; --tapePos; &#125;</span><br><span class="line">elif sym == <span class="string">'.'</span> &#123; print(<span class="keyword">int</span>(tape[tapePos]) |&gt; to_char); &#125;</span><br><span class="line">elif sym == <span class="string">','</span> &#123; tape[tapePos] = uint8(getchar()); &#125;</span><br><span class="line"><span class="keyword">else</span> &#123; &#125;</span><br><span class="line">++codePos</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">def interpret(code: <span class="built_in">string</span>)</span><br><span class="line">let totalTime = ref_time_ticks()</span><br><span class="line">var tape: <span class="built_in">array</span>&lt;uint8&gt;</span><br><span class="line">var codePos, tapePos : <span class="keyword">int</span></span><br><span class="line">tape |&gt; resize(<span class="number">1000000</span>)</span><br><span class="line">unsafe</span><br><span class="line">run(reinterpret&lt;uint8?&gt; code, length(code), addr(tape[<span class="number">0</span>]), codePos, tapePos, <span class="literal">false</span>)</span><br><span class="line">let totalDt = <span class="keyword">double</span>(get_time_usec(totalTime)) /<span class="number">1000000.0l</span>f</span><br><span class="line">to_log(LOG_INFO, <span class="string">"total &#123;totalDt&#125; sec\n"</span>)</span><br></pre></td></tr></table></figure><p>Такая версия интерпретатора всё ещё тормозная, но уже позволяет дождаться завершения выполнения кода:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">e:\src\daScript\bin\Release&gt;daScript.exe brainfuck_00.das</span><br><span class="line">AAAAAAAAAAAAAAAABBBBBBBBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDEGFFEEEEDDDDDDCCCCCCCCCBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB</span><br><span class="line">AAAAAAAAAAAAAAABBBBBBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDEEEFGIIGFFEEEDDDDDDDDCCCCCCCCCBBBBBBBBBBBBBBBBBBBBBBBBBB</span><br><span class="line">AAAAAAAAAAAAABBBBBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDEEEEFFFI KHGGGHGEDDDDDDDDDCCCCCCCCCBBBBBBBBBBBBBBBBBBBBBBB</span><br><span class="line">AAAAAAAAAAAABBBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDEEEEEFFGHIMTKLZOGFEEDDDDDDDDDCCCCCCCCCBBBBBBBBBBBBBBBBBBBBB</span><br><span class="line">AAAAAAAAAAABBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDEEEEEEFGGHHIKPPKIHGFFEEEDDDDDDDDDCCCCCCCCCCBBBBBBBBBBBBBBBBBB</span><br><span class="line">AAAAAAAAAABBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDEEEEEEFFGHIJKS  X KHHGFEEEEEDDDDDDDDDCCCCCCCCCCBBBBBBBBBBBBBBBB</span><br><span class="line">AAAAAAAAABBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDEEEEEEFFGQPUVOTY   ZQL[MHFEEEEEEEDDDDDDDCCCCCCCCCCCBBBBBBBBBBBBBB</span><br><span class="line">AAAAAAAABBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDEEEEEFFFFFGGHJLZ         UKHGFFEEEEEEEEDDDDDCCCCCCCCCCCCBBBBBBBBBBBB</span><br><span class="line">AAAAAAABBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDEEEEFFFFFFGGGGHIKP           KHHGGFFFFEEEEEEDDDDDCCCCCCCCCCCBBBBBBBBBBB</span><br><span class="line">AAAAAAABBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDEEEEEFGGHIIHHHHHIIIJKMR        VMKJIHHHGFFFFFFGSGEDDDDCCCCCCCCCCCCBBBBBBBBB</span><br><span class="line">AAAAAABBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDEEEEEEFFGHK   MKJIJO  N R  X      YUSR PLV LHHHGGHIOJGFEDDDCCCCCCCCCCCCBBBBBBBB</span><br><span class="line">AAAAABBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDEEEEEEEEEFFFFGH O    TN S                       NKJKR LLQMNHEEDDDCCCCCCCCCCCCBBBBBBB</span><br><span class="line">AAAAABBCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDEEEEEEEEEEEEFFFFFGHHIN                                 Q     UMWGEEEDDDCCCCCCCCCCCCBBBBBB</span><br><span class="line">AAAABBCCCCCCCCCCCCCCCCCCCCCCCCCDDDDEEEEEEEEEEEEEEEFFFFFFGHIJKLOT                                     [JGFFEEEDDCCCCCCCCCCCCCBBBBB</span><br><span class="line">AAAABCCCCCCCCCCCCCCCCCCCCCCDDDDEEEEEEEEEEEEEEEEFFFFFFGGHYV RQU                                     QMJHGGFEEEDDDCCCCCCCCCCCCCBBBB</span><br><span class="line">AAABCCCCCCCCCCCCCCCCCDDDDDDDEEFJIHFFFFFFFFFFFFFFGGGGGGHIJN                                            JHHGFEEDDDDCCCCCCCCCCCCCBBB</span><br><span class="line">AAABCCCCCCCCCCCDDDDDDDDDDEEEEFFHLKHHGGGGHHMJHGGGGGGHHHIKRR                                           UQ L HFEDDDDCCCCCCCCCCCCCCBB</span><br><span class="line">AABCCCCCCCCDDDDDDDDDDDEEEEEEFFFHKQMRKNJIJLVS JJKIIIIIIJLR                                               YNHFEDDDDDCCCCCCCCCCCCCBB</span><br><span class="line">AABCCCCCDDDDDDDDDDDDEEEEEEEFFGGHIJKOU  O O   PR LLJJJKL                                                OIHFFEDDDDDCCCCCCCCCCCCCCB</span><br><span class="line">AACCCDDDDDDDDDDDDDEEEEEEEEEFGGGHIJMR              RMLMN                                                 NTFEEDDDDDDCCCCCCCCCCCCCB</span><br><span class="line">AACCDDDDDDDDDDDDEEEEEEEEEFGGGHHKONSZ                QPR                                                NJGFEEDDDDDDCCCCCCCCCCCCCC</span><br><span class="line">ABCDDDDDDDDDDDEEEEEFFFFFGIPJIIJKMQ                   VX                                                 HFFEEDDDDDDCCCCCCCCCCCCCC</span><br><span class="line">ACDDDDDDDDDDEFFFFFFFGGGGHIKZOOPPS                                                                      HGFEEEDDDDDDCCCCCCCCCCCCCC</span><br><span class="line">ADEEEEFFFGHIGGGGGGHHHHIJJLNY                                                                        TJHGFFEEEDDDDDDDCCCCCCCCCCCCC</span><br><span class="line">A                                                                                                 PLJHGGFFEEEDDDDDDDCCCCCCCCCCCCC</span><br><span class="line">ADEEEEFFFGHIGGGGGGHHHHIJJLNY                                                                        TJHGFFEEEDDDDDDDCCCCCCCCCCCCC</span><br><span class="line">ACDDDDDDDDDDEFFFFFFFGGGGHIKZOOPPS                                                                      HGFEEEDDDDDDCCCCCCCCCCCCCC</span><br><span class="line">ABCDDDDDDDDDDDEEEEEFFFFFGIPJIIJKMQ                   VX                                                 HFFEEDDDDDDCCCCCCCCCCCCCC</span><br><span class="line">AACCDDDDDDDDDDDDEEEEEEEEEFGGGHHKONSZ                QPR                                                NJGFEEDDDDDDCCCCCCCCCCCCCC</span><br><span class="line">AACCCDDDDDDDDDDDDDEEEEEEEEEFGGGHIJMR              RMLMN                                                 NTFEEDDDDDDCCCCCCCCCCCCCB</span><br><span class="line">AABCCCCCDDDDDDDDDDDDEEEEEEEFFGGHIJKOU  O O   PR LLJJJKL                                                OIHFFEDDDDDCCCCCCCCCCCCCCB</span><br><span class="line">AABCCCCCCCCDDDDDDDDDDDEEEEEEFFFHKQMRKNJIJLVS JJKIIIIIIJLR                                               YNHFEDDDDDCCCCCCCCCCCCCBB</span><br><span class="line">AAABCCCCCCCCCCCDDDDDDDDDDEEEEFFHLKHHGGGGHHMJHGGGGGGHHHIKRR                                           UQ L HFEDDDDCCCCCCCCCCCCCCBB</span><br><span class="line">AAABCCCCCCCCCCCCCCCCCDDDDDDDEEFJIHFFFFFFFFFFFFFFGGGGGGHIJN                                            JHHGFEEDDDDCCCCCCCCCCCCCBBB</span><br><span class="line">AAAABCCCCCCCCCCCCCCCCCCCCCCDDDDEEEEEEEEEEEEEEEEFFFFFFGGHYV RQU                                     QMJHGGFEEEDDDCCCCCCCCCCCCCBBBB</span><br><span class="line">AAAABBCCCCCCCCCCCCCCCCCCCCCCCCCDDDDEEEEEEEEEEEEEEEFFFFFFGHIJKLOT                                     [JGFFEEEDDCCCCCCCCCCCCCBBBBB</span><br><span class="line">AAAAABBCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDEEEEEEEEEEEEFFFFFGHHIN                                 Q     UMWGEEEDDDCCCCCCCCCCCCBBBBBB</span><br><span class="line">AAAAABBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDEEEEEEEEEFFFFGH O    TN S                       NKJKR LLQMNHEEDDDCCCCCCCCCCCCBBBBBBB</span><br><span class="line">AAAAAABBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDEEEEEEFFGHK   MKJIJO  N R  X      YUSR PLV LHHHGGHIOJGFEDDDCCCCCCCCCCCCBBBBBBBB</span><br><span class="line">AAAAAAABBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDEEEEEFGGHIIHHHHHIIIJKMR        VMKJIHHHGFFFFFFGSGEDDDDCCCCCCCCCCCCBBBBBBBBB</span><br><span class="line">AAAAAAABBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDEEEEFFFFFFGGGGHIKP           KHHGGFFFFEEEEEEDDDDDCCCCCCCCCCCBBBBBBBBBBB</span><br><span class="line">AAAAAAAABBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDEEEEEFFFFFGGHJLZ         UKHGFFEEEEEEEEDDDDDCCCCCCCCCCCCBBBBBBBBBBBB</span><br><span class="line">AAAAAAAAABBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDEEEEEEFFGQPUVOTY   ZQL[MHFEEEEEEEDDDDDDDCCCCCCCCCCCBBBBBBBBBBBBBB</span><br><span class="line">AAAAAAAAAABBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDEEEEEEFFGHIJKS  X KHHGFEEEEEDDDDDDDDDCCCCCCCCCCBBBBBBBBBBBBBBBB</span><br><span class="line">AAAAAAAAAAABBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDEEEEEEFGGHHIKPPKIHGFFEEEDDDDDDDDDCCCCCCCCCCBBBBBBBBBBBBBBBBBB</span><br><span class="line">AAAAAAAAAAAABBBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDEEEEEFFGHIMTKLZOGFEEDDDDDDDDDCCCCCCCCCBBBBBBBBBBBBBBBBBBBBB</span><br><span class="line">AAAAAAAAAAAAABBBBBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDEEEEFFFI KHGGGHGEDDDDDDDDDCCCCCCCCCBBBBBBBBBBBBBBBBBBBBBBB</span><br><span class="line">AAAAAAAAAAAAAAABBBBBBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDEEEFGIIGFFEEEDDDDDDDDCCCCCCCCCBBBBBBBBBBBBBBBBBBBBBBBBBB</span><br><span class="line">[I] total 564.99929999999994834 sec</span><br></pre></td></tr></table></figure><p>564 секунды — в 30 раз быстрее первой версии, но всё ещё сильно медленнее интерпретатора на <code>nim</code>, который в релизной версии выполняется за 40 секунд.</p><h2 id="Ahead-of-Time"><a href="#Ahead-of-Time" class="headerlink" title="Ahead-of-Time"></a>Ahead-of-Time</h2><p>daScript умеет транспилироваться в C++ код, для сравнения с nim попробуем скомпилировать интерпретатор, без внесения каких-либо изменений в код.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">daScript.exe -aot brainfuck.das brainfuck.das.cpp</span><br></pre></td></tr></table></figure><p>Полученный C++-файл проще всего подсунуть в пример <a href="https://github.com/GaijinEntertainment/daScript/blob/master/examples/tutorial/tutorial02aot.cpp" target="_blank" rel="noopener">tutorial02aot</a>, который настроен на использование AoT варианта кода. Скомпилированный файл можно запустить:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">e:\src\daScript\bin\Release&gt;tutorial02aot.exe</span><br><span class="line">[I] total <span class="number">34.27342399999999856</span> sec</span><br></pre></td></tr></table></figure><p>34 секунды — уже быстрее, чем nim, который сам по себе достаточно быстрый!</p><h2 id="Just-in-Time"><a href="#Just-in-Time" class="headerlink" title="Just-in-Time"></a>Just-in-Time</h2><p>Можно попробовать двигаться дальше, подключив экспериментальный модуль <a href="https://github.com/borisbat/dasLLVM" target="_blank" rel="noopener">dasLLVM</a>. Чтобы собрать его, необходимо:</p><ul><li>включить сборку модуля в cmake:</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">option(DAS_LLVM_DISABLED &quot;Disable dasLLVM (llvm bindings)&quot; OFF)</span><br></pre></td></tr></table></figure><ul><li>собрать проект llvm, или скачать собранный (например, от <a href="https://download.qt.io/development_releases/prebuilt/libclang/" target="_blank" rel="noopener">qt</a>) и положить на уровень выше корневой директории проекта daScript, напрммер:</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:&#x2F;dascript</span><br><span class="line">C:&#x2F;libclang</span><br></pre></td></tr></table></figure><ul><li>сгенерировать решение и пересобрать dascript:</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">generate_msvc_2019.bat</span><br></pre></td></tr></table></figure><p>Теперь можно воспользоваться аннотацией <code>[jit]</code>, чтобы код функциии интерпретатора без AoT-компиляции перед первым выполнением компилировался с помощью <code>llvm-c</code>.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[jit,unsafe_deref]</span><br><span class="line"><span class="function">def <span class="title">run</span><span class="params">(code: uint8?; lengthOfCode:<span class="keyword">int</span>; var tape: uint8?; var codePos, tapePos: <span class="keyword">int</span>&amp;; skip: <span class="keyword">bool</span>)</span>: <span class="keyword">bool</span></span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">e:\src\daScript_my\bin\Release&gt;daScript.exe brainfuck_2_jit.das</span><br><span class="line">[I] total 22.66654300000000077 sec</span><br></pre></td></tr></table></figure><p>22.6 секунды, еще лучше! Генерация daScript-кода в llvm-ассемблер быстрее, чем в C++ — генератор передаёт больше полезной для оптимизации о кода, а также, возможно, задействуется сила оптимизаций LLVM.</p><h2 id="Метапрограммирование"><a href="#Метапрограммирование" class="headerlink" title="Метапрограммирование"></a>Метапрограммирование</h2><p>Можно двигаться дальше. Вместо того, чтобы писать функцию, которая интерпретирует любой код на brainfuck, можно написать макрос, который сгенерирует код конкретной функции в compile-time, и измерить время выполнения этой функции.</p><p>Можно использовать <a href="https://dascript.org/doc/reference/language/macros.html#astreadermacro" target="_blank" rel="noopener">AstReaderMacro</a> — тип макроса, который обрабатывает отдельные символы. Синтаксис вызова такого макроса:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">% READER_MACRO_NAME ~ character_sequence %% &#x2F;&#x2F;character_sequence будет передана на вход макросу</span><br></pre></td></tr></table></figure><p>Шаблоны таких макросов можно посмотреть в модулях <code>json_boost</code> и <code>regex_boost</code></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> brainfuck_macro shared <span class="keyword">public</span></span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">generateFunction</span><span class="params">(uniqueName, code)</span></span></span><br><span class="line"><span class="function">    let seqStr </span>= <span class="built_in">string</span>(code)</span><br><span class="line"></span><br><span class="line">    var blkArr : <span class="built_in">array</span>&lt;<span class="built_in">array</span>&lt;ExpressionPtr&gt;&gt;; defer_delete(blkArr)</span><br><span class="line"></span><br><span class="line">    var blk : <span class="built_in">array</span>&lt;ExpressionPtr&gt;; defer_delete(blk)</span><br><span class="line">    blkArr |&gt; emplace(blk)</span><br><span class="line"></span><br><span class="line">    blkArr[<span class="number">0</span>] |&gt; emplace_new &lt;| qmacro_expr( $&#123; var tape: <span class="built_in">array</span>&lt;uint8&gt;; &#125;)</span><br><span class="line">    blkArr[<span class="number">0</span>] |&gt; emplace_new &lt;| qmacro_expr( $&#123; var tapePos : <span class="keyword">int</span>; &#125;)</span><br><span class="line">    blkArr[<span class="number">0</span>] |&gt; emplace_new &lt;| qmacro_expr( $&#123; tape |&gt; resize(<span class="number">1000000</span>); &#125;)</span><br><span class="line">    blkArr[<span class="number">0</span>] |&gt; emplace_new &lt;| qmacro_expr( $&#123; var ptape = addr(tape[<span class="number">0</span>]); &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> sym in seqStr</span><br><span class="line">        <span class="keyword">if</span> sym == <span class="string">'+'</span>   &#123; back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( $&#123; ptape[tapePos] = uint8(<span class="keyword">int</span>(ptape[tapePos]) + <span class="number">1</span>); &#125;); &#125;</span><br><span class="line">        elif sym == <span class="string">'-'</span> &#123; back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( $&#123; ptape[tapePos] = uint8(<span class="keyword">int</span>(ptape[tapePos]) - <span class="number">1</span>); &#125;); &#125;</span><br><span class="line">        elif sym == <span class="string">'&gt;'</span> &#123; back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( $&#123; ++tapePos; &#125;); &#125; </span><br><span class="line">        elif sym == <span class="string">'&lt;'</span> &#123; back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( $&#123; --tapePos; &#125;); &#125;</span><br><span class="line">        elif sym == <span class="string">'.'</span> &#123; back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( $&#123; print(<span class="keyword">int</span>(ptape[tapePos]) |&gt; to_char); &#125;); &#125;</span><br><span class="line">        elif sym == <span class="string">','</span> &#123; back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( $&#123; ptape[tapePos] = uint8(getchar()); &#125;); &#125;</span><br><span class="line">        elif sym == <span class="string">'['</span></span><br><span class="line">            var blk1 : <span class="built_in">array</span>&lt;ExpressionPtr&gt;; defer_delete(blk1)</span><br><span class="line">            blkArr |&gt; emplace(blk1)</span><br><span class="line">        elif sym == <span class="string">']'</span></span><br><span class="line">            var last &lt;- back(blkArr)</span><br><span class="line">            blkArr |&gt; pop()</span><br><span class="line">            var whileExpr &lt;- qmacro_expr &lt;|</span><br><span class="line">                <span class="keyword">while</span> ptape[tapePos] != uint8(<span class="number">0</span>)</span><br><span class="line">                    $b(last)</span><br><span class="line">            back(blkArr) |&gt; emplace_new &lt;| whileExpr</span><br><span class="line">        <span class="keyword">else</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    var fnArguments : <span class="built_in">array</span>&lt;VariablePtr&gt;;</span><br><span class="line">    var fn &lt;- qmacro_function(uniqueName) &lt;| $ ($a(fnArguments))</span><br><span class="line">        unsafe</span><br><span class="line">            $b(blkArr[<span class="number">0</span>])</span><br><span class="line">    defer_delete(fn)</span><br><span class="line"></span><br><span class="line">    var args:<span class="built_in">array</span>&lt; tuple&lt;argname:<span class="built_in">string</span>;argvalue:RttiValue&gt; &gt;</span><br><span class="line">    fn |&gt; append_annotation(<span class="string">"$"</span>, <span class="string">"unsafe_deref"</span>, args)</span><br><span class="line">    <span class="comment">//print(describe(fn))</span></span><br><span class="line">    compiling_module() |&gt; add_function(fn)</span><br><span class="line"></span><br><span class="line">[reader_macro(name=<span class="string">"bf"</span>)]</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">private</span> <span class="title">BrainfuckReader</span> :</span> AstReaderMacro</span><br><span class="line">    <span class="function">def <span class="keyword">override</span> <span class="title">accept</span><span class="params">( prog:ProgramPtr; mod:Module?; var expr:ExprReader?; ch:<span class="keyword">int</span>; info:LineInfo)</span> : <span class="keyword">bool</span></span></span><br><span class="line"><span class="function">        <span class="title">append</span><span class="params">(expr.sequence, ch)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">if</span> <span class="title">ends_with</span><span class="params">(expr.sequence,<span class="string">"%%"</span>)</span></span></span><br><span class="line"><span class="function">            let len </span>= length(expr.sequence)</span><br><span class="line">            resize(expr.sequence,len<span class="number">-2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    def <span class="keyword">override</span> visit( prog:ProgramPtr; mod:Module?; expr:smart_ptr&lt;ExprReader&gt;) : ExpressionPtr</span><br><span class="line">        let str &lt;- make_unique_private_name(<span class="string">"bf`exec"</span>, expr.at)</span><br><span class="line">        generateFunction(str, expr.sequence)</span><br><span class="line"></span><br><span class="line">        var ftype &lt;- <span class="keyword">new</span> [[TypeDecl() at=expr.at, baseType=Type tFunction ]]</span><br><span class="line">        ftype.firstType &lt;- <span class="keyword">new</span> [[TypeDecl() at=expr.at, baseType=Type tVoid]]</span><br><span class="line">        var funcPtr &lt;- <span class="keyword">new</span> [[ExprAddr() at=expr.at, target:=str, funcType &lt;- ftype]]</span><br><span class="line">        <span class="keyword">return</span> funcPtr</span><br></pre></td></tr></table></figure><p>Тогда вызвать такой макрос можно так:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">require brainfuck_macro</span><br><span class="line"><span class="comment">//генерируем функцию</span></span><br><span class="line">let func = %bf~++++++++[&gt;++++[&gt;++&gt;+++&gt;+++&gt;+&lt;&lt;&lt;&lt;-]&gt;+&gt;+&gt;-&gt;&gt;+[&lt;]&lt;-]&gt;&gt;.&gt;---.+++++++..+++.&gt;&gt;.&lt;-.&lt;.+++.------.--------.&gt;&gt;+.&gt;++.%%</span><br><span class="line"><span class="comment">//вызываем сгенерированную функцию</span></span><br><span class="line">invoke(func)</span><br></pre></td></tr></table></figure><p>Если раскомментировать строчку <code>print(describe(fn))</code> можно посмотреть на сгенерированное тело функции.</p><p>Например:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">let func = %bf~[-&gt;+&lt;]%%</span><br><span class="line"><span class="comment">//сгенерированный код</span></span><br><span class="line"></span><br><span class="line">[unsafe_deref]</span><br><span class="line">def <span class="keyword">public</span> bf`exec_0xd_0xc</span><br><span class="line">    unsafe</span><br><span class="line">        var tape:<span class="built_in">array</span>&lt;uint8&gt; -<span class="keyword">const</span>                          <span class="comment">//declare variables</span></span><br><span class="line">        var tapePos:<span class="keyword">int</span> -<span class="keyword">const</span></span><br><span class="line">        resize(tape,<span class="number">1000000</span>)</span><br><span class="line">        var ptape:<span class="keyword">auto</span> -<span class="keyword">const</span> = addr(tape[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ptape[tapePos] != uint8(<span class="number">0</span>)                      <span class="comment">//[</span></span><br><span class="line">            ptape[tapePos] = uint8(<span class="keyword">int</span>(ptape[tapePos]) - <span class="number">1</span>)   <span class="comment">//-</span></span><br><span class="line">            ++tapePos                                         <span class="comment">//&gt;</span></span><br><span class="line">            ptape[tapePos] = uint8(<span class="keyword">int</span>(ptape[tapePos]) + <span class="number">1</span>)   <span class="comment">//+</span></span><br><span class="line">            --tapePos                                         <span class="comment">//&lt;]</span></span><br><span class="line">let func = @@bf`exec_0xd_0xc <span class="comment">//указатель на функцию</span></span><br></pre></td></tr></table></figure><p>Для каждой функции генерируется уникальное имя, чтобы можно было создать несколько отдельных интерпретатов, и своя “лента” памяти. В дальнейшем, каждый отдельный символ brainfuck компилируется в одну или несколько ast-нод daScript, который затем могут быть просимулированы.</p><p>(Раздел <code>daScript</code> про симуляцию и устройство виртуальной машины daScript)<br><a href="/blog/2115627465/" title="Устройство интерпретаторов lua-jit и daScript">Устройство интерпретаторов lua-jit и daScript</a> </p><p>(Генерация кода с помощью <a href="https://dascript.org/doc/reference/language/reification.html" target="_blank" rel="noopener">реификации выражений</a>)<br><a href="/blog/4046309382/" title="daScript macro - 2">daScript macro - 2</a></p><p>Если говорить о терминологии, то brainfuck можно рассматривать как <code>предметно-ориентированный язык (DSL)</code>. Переменные состояния tape и tapePos вместе составляют <code>семантическую модель</code> этого языка, которая настраивается с помощью DSL, а затем транслируется в синтаксическое дерево на <code>daScript</code> (в терминах Мартина Фаулера из книги “Предметно-ориентированные языки программирования”).</p><p>Время выполнения такой скомпилированной функции <strong>в режиме интерпретации</strong>:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">e:\src\daScript_my\bin\Release&gt;daScript.exe brainfuck.das</span><br><span class="line">[I] total 29.28014399999999995 sec</span><br></pre></td></tr></table></figure><p>Это немного медленнее скомпилированной JiT-версии, но уже быстрее AoT версии интерпретатора.</p><h2 id="Macro-JiT"><a href="#Macro-JiT" class="headerlink" title="Macro + JiT"></a>Macro + JiT</h2><p>Дальше будет интереснее. Наша скомпилированная версия функции представляет собой по сути развёрнутую трассированную версию исполнения кода (и занимающую больше памяти). Попробуем применить к ней макрос [jit]:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">fn |&gt; append_annotation(<span class="string">"$"</span>, <span class="string">"unsafe_deref"</span>, args)</span><br><span class="line">fn |&gt; append_annotation(<span class="string">"$"</span>, <span class="string">"jit"</span>, args)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">e:\src\daScript_my\bin\Release&gt;daScript.exe brainfuck.das</span><br><span class="line">[I] total 0.85775599999999996 sec</span><br></pre></td></tr></table></figure><p>0.85 секунды! (плюс около секунды на само время компиляции функции). llvm jit умеет сворачивать идущие подряд повторяющиеся операторы инкремента и декремента, за счёт чего получилось ускорение в 30 раз (и соотвествующее уменьшение размера функции).</p><p>Для сравнения — compile-time версия на nim работает ~3 секунды и тратит ~20 секунд на компиляцию (nim работает медленно в compile-time режиме).</p><h2 id="Оптимизации-Brainfuck-gt-daScript-AST"><a href="#Оптимизации-Brainfuck-gt-daScript-AST" class="headerlink" title="Оптимизации Brainfuck -&gt; daScript AST"></a>Оптимизации Brainfuck -&gt; daScript AST</h2><p>Получается интересная цепочка преобразования кода:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bf --&gt; (bf macro) --&gt; dascript ast --&gt; (dascript simulate - unsafe deref macro + optimizations) --&gt; dascript ast optimized --&gt; (llvm macro) --&gt; llvm native optimized code --&gt; (execute)</span><br></pre></td></tr></table></figure><p>На каждом из шагов происходят серьёзные трансформации кода, которые могут включать оптимизации. Можно рассмотреть оптимизации в обратном порядке:</p><ul><li>llvm — бекэнд генерации кода оптимизирует байт-код, на этом этапе заметен эффект от сворачивания идущих подряд операций</li><li>dascript simulate — при симуляции ast-дерева выбираются оптимизированные частные версии нод, мелкие ноды могут “сплавляться” в более крупные, применяются кастомные макросы, трансформирующие дерево по различным правилам</li><li>bf macro — на данном уровне производится трансляция команд brainfuck в ноды dascript, пока без оптимизаций</li></ul><p>Оптимизации на стадиях трансформаций llvm были сделаны библиотекой из “комплекта” языка, на стадиях преобразования daScript — как встроенными в язык оптимизациями, так и добавленными для своего кода вручную. Можно теперь попробовать добавить пару оптимизаций на “стороне DSL”, т.е. в макрос трансформации <code>brainfuck-&gt;daScript</code>.</p><p>На данном этапе первую тупую и наивную реализацию уже получилось разогнать где-то в 20000 раз, и это отличный повод разогнать ещё немного :)</p><p>Можно выбрать несколько простых паттернов brainfuck кода и попробовать распознавать их и генерить более оптимальный код для этих частных случаев:</p><ul><li>цепочка повторяющихся операций. Например, “+++++” можно интерпретировать не как 5 отдельных инкрементов, а как одну операцию увеличения на 5. Эту свёртку делает llvm для версии <code>Macro+JiT</code>, но если сделать её в своём макросе, то она также ускорит и обычный режим интерпретации</li><li>паттерн [-] можно интерпретировать как очистку ячейки памяти одной операцией</li><li>[-&gt;+&lt;] - чуть более сложный паттерн, который часто встречается в примерах на brainfuck, “сложение двух ячеек с очисткой исходной”, может быть интерпретирован как 2 команды вместо цикла</li><li>можно продолжать обнаруживать и добавлять всё более сложные паттерны</li></ul><p>(Приём с отслеживанием паттернов подходит, естественно, не только для brainfuck-кода, но и для любых DSL)</p><p>“Продвинутая” версия макроса, отслеживающая перечисленные паттерны</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">seachRepeats</span><span class="params">(symIt; var sym:<span class="keyword">int</span>&amp;; symbolToCheck)</span></span></span><br><span class="line"><span class="function">    var count </span>= <span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">while</span> <span class="title">next</span><span class="params">(symIt, sym)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">if</span> sym </span>== symbolToCheck</span><br><span class="line">            ++count</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> count</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line">def match_reset(data: <span class="built_in">array</span>&lt;<span class="keyword">int</span>&gt;)</span><br><span class="line">    <span class="keyword">return</span> length(data) == <span class="number">3</span> &amp;&amp; data[<span class="number">0</span>] == <span class="string">'['</span> &amp;&amp; data[<span class="number">1</span>] == <span class="string">'-'</span> &amp;&amp; data[<span class="number">2</span>] == <span class="string">']'</span></span><br><span class="line"></span><br><span class="line">def match_add_right_reset(data: <span class="built_in">array</span>&lt;<span class="keyword">int</span>&gt;)</span><br><span class="line">    <span class="keyword">return</span> length(data) == <span class="number">6</span> &amp;&amp; data[<span class="number">0</span>] == <span class="string">'['</span> &amp;&amp; data[<span class="number">1</span>] == <span class="string">'-'</span> &amp;&amp; data[<span class="number">2</span>] == <span class="string">'&gt;'</span> &amp;&amp; data[<span class="number">3</span>] == <span class="string">'+'</span> &amp;&amp; data[<span class="number">4</span>] == <span class="string">'&lt;'</span> &amp;&amp; data[<span class="number">5</span>] == <span class="string">']'</span></span><br><span class="line"></span><br><span class="line">def generateFunction(uniqueName, code)</span><br><span class="line">    let seqStr = <span class="built_in">string</span>(code)</span><br><span class="line"></span><br><span class="line">    var blkArr : <span class="built_in">array</span>&lt;<span class="built_in">array</span>&lt;ExpressionPtr&gt;&gt;; defer_delete(blkArr)</span><br><span class="line"></span><br><span class="line">    var blk : <span class="built_in">array</span>&lt;ExpressionPtr&gt;; defer_delete(blk)</span><br><span class="line">    blkArr |&gt; emplace(blk)</span><br><span class="line"></span><br><span class="line">    var cyclePatternChecker:<span class="built_in">array</span>&lt;<span class="keyword">int</span>&gt;</span><br><span class="line"></span><br><span class="line">    var initBlock &lt;- quote() &lt;|</span><br><span class="line">        var tape: <span class="built_in">array</span>&lt;uint8&gt;</span><br><span class="line">        var tapePos : <span class="keyword">int</span></span><br><span class="line">        tape |&gt; resize(<span class="number">1000000</span>)</span><br><span class="line">        var ptape = addr(tape[<span class="number">0</span>])</span><br><span class="line">    <span class="comment">//blkArr[0] |&gt; emplace_new &lt;| initBlock</span></span><br><span class="line">    unsafe</span><br><span class="line">        var _block &lt;- reinterpret&lt;smart_ptr&lt;ExprBlock&gt;&gt;(reinterpret&lt;smart_ptr&lt;ExprMakeBlock&gt;&gt; initBlock)._block</span><br><span class="line">        <span class="keyword">for</span> blockItem in _block.<span class="built_in">list</span></span><br><span class="line">            blkArr[<span class="number">0</span>] |&gt; emplace_new &lt;| blockItem</span><br><span class="line">    var symIt &lt;- unsafe(each(seqStr))</span><br><span class="line">    var sym : <span class="keyword">int</span></span><br><span class="line">    var repeat = <span class="literal">false</span></span><br><span class="line">    var count : <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> repeat || next(symIt, sym)</span><br><span class="line">        repeat = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">if</span> sym == <span class="string">'+'</span></span><br><span class="line">            cyclePatternChecker |&gt; push(sym)</span><br><span class="line">            repeat = <span class="literal">true</span></span><br><span class="line">            count = seachRepeats(symIt, sym, <span class="string">'+'</span>)</span><br><span class="line">            back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( $&#123; ptape[tapePos] = uint8(<span class="keyword">int</span>(ptape[tapePos]) + $v(count)); &#125;)</span><br><span class="line">        elif sym == <span class="string">'-'</span></span><br><span class="line">            cyclePatternChecker |&gt; push(sym)</span><br><span class="line">            repeat = <span class="literal">true</span></span><br><span class="line">            count = seachRepeats(symIt, sym, <span class="string">'-'</span>)</span><br><span class="line">            back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( $&#123; ptape[tapePos] = uint8(<span class="keyword">int</span>(ptape[tapePos]) - $v(count)); &#125;)</span><br><span class="line">        elif sym == <span class="string">'&gt;'</span></span><br><span class="line">            cyclePatternChecker |&gt; push(sym)</span><br><span class="line">            repeat = <span class="literal">true</span></span><br><span class="line">            count = seachRepeats(symIt, sym, <span class="string">'&gt;'</span>)</span><br><span class="line">            back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( $&#123; tapePos +=  $v(count); &#125;)</span><br><span class="line">        elif sym == <span class="string">'&lt;'</span></span><br><span class="line">            cyclePatternChecker |&gt; push(sym)</span><br><span class="line">            repeat = <span class="literal">true</span></span><br><span class="line">            count = seachRepeats(symIt, sym, <span class="string">'&lt;'</span>)</span><br><span class="line">            back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( $&#123; tapePos -= $v(count); &#125;)</span><br><span class="line"></span><br><span class="line">        elif sym == <span class="string">'.'</span> &#123; back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( $&#123; print(<span class="keyword">int</span>(ptape[tapePos]) |&gt; to_char); &#125;); &#125;</span><br><span class="line">        elif sym == <span class="string">','</span> &#123; back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( $&#123; ptape[tapePos] = uint8(getchar()); &#125;); &#125;</span><br><span class="line">        elif sym == <span class="string">'['</span></span><br><span class="line">            cyclePatternChecker |&gt; clear</span><br><span class="line">            cyclePatternChecker |&gt; push(sym)</span><br><span class="line">            var blk1 : <span class="built_in">array</span>&lt;ExpressionPtr&gt;; defer_delete(blk1)</span><br><span class="line">            blkArr |&gt; emplace(blk1)</span><br><span class="line">        elif sym == <span class="string">']'</span></span><br><span class="line">            cyclePatternChecker |&gt; push(sym)</span><br><span class="line">            <span class="keyword">if</span> match_reset(cyclePatternChecker)</span><br><span class="line">                <span class="comment">//match [-]</span></span><br><span class="line">                blkArr |&gt; pop()</span><br><span class="line">                back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( $&#123; ptape[tapePos] = uint8(<span class="number">0</span>); &#125;)</span><br><span class="line">            elif match_add_right_reset(cyclePatternChecker)</span><br><span class="line">                <span class="comment">//match [-&gt;+&lt;]</span></span><br><span class="line">                blkArr |&gt; pop()</span><br><span class="line">                back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( $&#123; ptape[tapePos+$v(count)] = uint8(<span class="keyword">int</span>(ptape[tapePos+$v(count)]) + <span class="keyword">int</span>(ptape[tapePos])); &#125;)</span><br><span class="line">                back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( $&#123; ptape[tapePos] = uint8(<span class="number">0</span>); &#125;)</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">//usual cycle</span></span><br><span class="line">                var last &lt;- back(blkArr)</span><br><span class="line">                blkArr |&gt; pop()</span><br><span class="line">                var whileExpr &lt;- qmacro_expr &lt;|</span><br><span class="line">                    <span class="keyword">while</span> ptape[tapePos] != uint8(<span class="number">0</span>)</span><br><span class="line">                        $b(last)</span><br><span class="line">                back(blkArr) |&gt; emplace_new &lt;| whileExpr</span><br><span class="line"></span><br><span class="line">            cyclePatternChecker |&gt; clear</span><br><span class="line">        <span class="keyword">else</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    var fnArguments : <span class="built_in">array</span>&lt;VariablePtr&gt;;</span><br><span class="line">    var fn &lt;- qmacro_function(uniqueName) &lt;| $ ($a(fnArguments))</span><br><span class="line">        unsafe</span><br><span class="line">            $b(blkArr[<span class="number">0</span>])</span><br><span class="line">    defer_delete(fn)</span><br><span class="line"></span><br><span class="line">    var args:<span class="built_in">array</span>&lt; tuple&lt;argname:<span class="built_in">string</span>;argvalue:RttiValue&gt; &gt;</span><br><span class="line">    fn |&gt; append_annotation(<span class="string">"$"</span>, <span class="string">"jit"</span>, args)</span><br><span class="line">    fn |&gt; append_annotation(<span class="string">"$"</span>, <span class="string">"unsafe_deref"</span>, args)</span><br><span class="line">    <span class="comment">//print(describe(fn))</span></span><br><span class="line">    compiling_module() |&gt; add_function(fn)</span><br></pre></td></tr></table></figure><p>Результат:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">e:\src\daScript_my\bin\Release&gt;daScript.exe brainfuck.das</span><br><span class="line">[I] total 0.70142899999999999 sec</span><br></pre></td></tr></table></figure><p>Еще на 17% быстрее<br><em>Из замеров явно стоило бы еще вынести print</em></p><h2 id="Немного-выводов"><a href="#Немного-выводов" class="headerlink" title="Немного выводов"></a>Немного выводов</h2><ul><li>Основа оптимизации — написание грамотного кода на основном языке.</li><li>Техники JiT-компиляции (особенно в сочетании с кодогенерацией или замерами hot участков) могут давать крутые результаты, в том числе превосходящие статическую компиляцию</li><li>Организация цепочки преобразований кода в одной среде НАМНОГО удобнее, чем в разных (какой-нибудь вариант “кодоген на python” + макросы/шаблоны + код на C++” - мрак с отладкой). Особенно для более длинных цепочек.</li><li>Нормальные макросы = нормальная отладка и скорость компиляции DSL.</li></ul><p><a href="https://github.com/spiiin/dascript_brainfuck" target="_blank" rel="noopener">Код примеров</a></p><p><em>update от 14.01.2023</em><br><em><a href="https://tratt.net/laurie/blog/2023/compiled_and_interpreted_languages_two_ways_of_saying_tomato.html" target="_blank" rel="noopener">Compiled and Interpreted Languages: Two Ways of Saying Tomato</a> - похожие замеры на rust</em></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Попробовал портировать с &lt;code&gt;nim&lt;/code&gt; на &lt;code&gt;daScript&lt;/code&gt; &lt;a href=&quot;https://howistart.org/posts/nim/1/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;интерпретатор&lt;/a&gt; &lt;code&gt;brainfuck&lt;/code&gt; кода. Брейфак предельно простой язык, и базовая реализация интерпретатора занимает полчаса, но на нём можно потренироваться в ускорении кода и продемонстрировать возможности daScript в оптимизации.&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="dascript" scheme="http://spiiin.github.io/tags/dascript/"/>
    
      <category term="llvm" scheme="http://spiiin.github.io/tags/llvm/"/>
    
  </entry>
  
  <entry>
    <title>ECS - типы и проблемы</title>
    <link href="http://spiiin.github.io/blog/1601029690/"/>
    <id>http://spiiin.github.io/blog/1601029690/</id>
    <published>2022-11-05T22:13:02.000Z</published>
    <updated>2022-11-06T09:38:35.748Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><h2 id="Where-is-my-components"><a href="#Where-is-my-components" class="headerlink" title="Where is my components"></a>Where is my components</h2><p>Одна из идей <code>ecs</code> — держать компоненты рядом в памяти и обходить в порядке хранения в памяти. По способу организации хранения <a href="https://github.com/SanderMertens/ecs-faq#what-are-the-different-ways-to-implement-an-ecs" target="_blank" rel="noopener">ECS FAQ</a> выделяет такие группы:</p><ul><li>Реактивные ECS</li></ul><p><a href="https://github.com/sschmid/Entitas/blob/main/src/Entitas/src/Entity/Entity.cs#L96" target="_blank" rel="noopener">Entitas</a> - компоненты валяются где-то на хипе, entity хранит указатели на компоненты. Добавление и удаление компонентов с помощью событий уведомляет системы, чтобы они обновили свои списки. О хранении рядом речи не идёт. На самом деле, по типу хранения тут скорее “Entity based”. Идея с тем, чтобы уведомлять системы при изменении списка компонента на сущности реализована и в других типах ECS</p><ul><li>Bitset based</li></ul><p><a href="hhttps://github.com/alecthomas/entityx/blob/82ab2d304ef5e6933cf6622721f086a1f4731e80/entityx/Entity.h#L641">EntityX</a> - компоненты хранятcя в отдельных пулах, entity хранит битовую маску, присутствует ли компонент в конкретной entity. Быстро, но очень расточительно в плане количества потребляемой памяти.</p><ul><li>Sparse set</li></ul><p><a href="https://github.com/skypjack/entt" target="_blank" rel="noopener">EnTT</a> - компоненты хранятся в системах, в структурах под названием <a href="https://github.com/skypjack/entt/blob/master/src/entt/entity/sparse_set.hpp#L151" target="_blank" rel="noopener">sparse_set</a>. Бывают структуры, владеющие компонентами, и хранящие индексы компонентов (дополнительный уровень индирекции), а также совмещенные варианты (владеет частью компонентов, но обращается к другим по индексам). Способ хранения компонент задаёт пользователь библиотеки, что позволяет выбирать наиболее быстрые способы, но взамен требуется хорошее понимание того, как правильно его выбрать.</p><p><a href="http://bitsquid.blogspot.com/2011/09/managing-decoupling-part-4-id-lookup.html" target="_blank" rel="noopener">Managing Decoupling Part 4 — The ID Lookup Table</a> - простое объяснение.<br><a href="https://skypjack.github.io/2019-03-07-ecs-baf-part-2/" target="_blank" rel="noopener">ECS back and forth Part 2 - Where are my entities?</a> - объяснение использования в EnTT.<br><a href="https://github.com/skypjack/entt/wiki/Crash-Course:-entity-component-system#groups" target="_blank" rel="noopener">Groups</a> - более детальное объяснения того, как ускорить доступ к паре компонентов, которыми владеет одна система. Совсем кратко — если система владеет компонентами A и B, то она может хранить их так, чтобы при обращении за сущностями с обоими компонентами компоненты этих сущностей всегда лежали в начале массивов.<br><a href="https://skypjack.github.io/2019-03-21-ecs-baf-part-2-insights/" target="_blank" rel="noopener">Part 2, insights - Sparse sets and grouping functionalities</a> - еще раз подробно о способе сортировки групп.</p><ul><li>Archetypes (aka “Dense ECS” or “Table based ECS”)<br><a href="https://github.com/SanderMertens/flecs" target="_blank" rel="noopener">flecs</a> - компоненты хранятся в архетипах. Архетип — сочетание уникального множества компонентов. Для каждого архетипа существует отдельный массив. Компонент хранит список архетипов, которые его включают. Сущность хранит указатель на массив архетипов, и индекс внутри этого массива (по которому получает сразу все свои компоненты).</li></ul><p>Таким образом, легко получить сразу все компоненты сущности, но при удалении/добавлении компонента необходимо “перекладывание” всей пачки компонентов из одного массива архетипов в другой. Также, если существует множество различных архетипов (сочетаний компонентов), и существует несколько систем, выбирающих одиночные компоненты, то расстояние в памяти между различными архетипами будет большим (как и если архетип достаточно большой - шаг между отдельными компонентами может быть большим)</p><p><a href="https://ajmmertens.medium.com/building-an-ecs-1-where-are-my-entities-and-components-63d07c7da742" target="_blank" rel="noopener">Building an ECS #1: Where are my Entities and Components</a> и<br><a href="https://ajmmertens.medium.com/building-an-ecs-2-archetypes-and-vectorization-fe21690805f9" target="_blank" rel="noopener">Building an ECS #2: Archetypes and Vectorization</a> - идея расскладыванием на архетипы</p><p><a href="https://github.com/GaijinEntertainment/daScript/blob/master/daslib/decs.das#L323" target="_blank" rel="noopener">decs</a> - библиотека ecs в <code>daScript</code> на архетипах<br><a href="https://github.com/GaijinEntertainment/daScript/blob/master/daslib/decs_boost.das" target="_blank" rel="noopener">decs_boost</a> - набор макросов, с помощью которых обращение с архетипами синтаксически похоже на обычный императивный код</p><p>Идеальным сочетанием для скорости выглядит использование <code>архетипов</code> в тех системах, где 1) не происходит постоянного добавления/удаления компонентов и 2) компонент используются только небольшим количеством систем (в примеры приводят низкоуровневые физические и графические подсистемы) + использование <code>sparse sets</code> там где существует большое количество типов компонент, которые постоянно добавляются/удаляются и систем, использующих разные сочетания компонентов (игровая логика).</p><h2 id="Проблемы-с-ECS"><a href="#Проблемы-с-ECS" class="headerlink" title="Проблемы с ECS"></a>Проблемы с ECS</h2><p>На чистом ECS сложно выразить некоторые распространённые в геймдеве задачи:</p><ul><li>Иерархии</li><li>Конечные автоматы</li><li>Декларативный GUI</li><li>Порядок работы систем (и повторный запуск)</li><li>Расширение/наследование компонентов</li><li>Контракты компонентов (взаимоисключающие сочетания, неудаляемые и т.п.)</li><li>Отображение объекта из нескольких сущностей как целого</li></ul><p>И более редкие</p><ul><li>Общее использование компонента сущностями</li><li>Несколько компонентов одного типа на сущности</li></ul><p><a href="https://ajmmertens.medium.com/ecs-from-tool-to-paradigm-350587cdf216" target="_blank" rel="noopener">ECS: From Tool to Paradigm</a> - список проблем<br><a href="https://takinginitiative.wordpress.com/2019/09/30/ecs-questions/" target="_blank" rel="noopener">ECS Questions</a> + <a href="https://takinginitiative.wordpress.com/2019/11/09/more-ecs-questions/" target="_blank" rel="noopener">More ECS Questions</a> - еще пара разборов ситуаций в игровом коде и способов их решения — порядок вызова систем в иерархических структурах, применительно к подсистеме анимации.</p><h2 id="Kruger-Engine-Entity-Model"><a href="#Kruger-Engine-Entity-Model" class="headerlink" title="Kruger Engine Entity Model"></a>Kruger Engine Entity Model</h2><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/jjEsB611kxs" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div><p><code>Game Engine Entity/Object Models</code> — большой обзор ECS подхода от Bobby Anguelov, с предложением гибридного подхода.<br><a href="https://takinginitiative.files.wordpress.com/2019/11/krgentitymodel.pdf" target="_blank" rel="noopener">Kruger Engine Entity Model</a> — презентация про демо-движок с подходом из видео-доклада.<br><a href="https://github.com/BobbyAnguelov/Esoterica" target="_blank" rel="noopener">Esoterica</a> - более позднее название демо-движка</p><p>Системы делятся на глобальные и локальные.</p><ul><li>Глобальные</li></ul><p>Чтобы передавать информацию между сущностями, и обновлять состояние мира</p><ul><li>Локальные<br>Чтобы передавать информацию между компонентами одной сущности (сущность не может получить доступ к компонентам напрямую, не через локальную систему, компоненты не могут ссылаться друг на друга или обновляться сами)<br>Чтобы гарантированно обновлять все компоненты родителя раньше дочерних, для систем, которым необходим порядок обновления</li></ul><p><img src="/blog/1601029690/slide_1_small.png" alt=""></p><p>Разрешено добавление нескольких компонентов одного типа на сущность, чтобы упростить построение иерархий (меш + сабмеши).<br>Разрешено явное задание пространственной иерархии между сущностями (с помощью <code>Spatial Component</code>, который имеет список дочерних Spatial Component и хранит пространственные матрицы)</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;h2 id=&quot;Where
      
    
    </summary>
    
    
    
      <category term="link" scheme="http://spiiin.github.io/tags/link/"/>
    
      <category term="ecs" scheme="http://spiiin.github.io/tags/ecs/"/>
    
  </entry>
  
  <entry>
    <title>daScript. SFML, dasBox и спайны</title>
    <link href="http://spiiin.github.io/blog/887709799/"/>
    <id>http://spiiin.github.io/blog/887709799/</id>
    <published>2022-11-05T16:42:25.000Z</published>
    <updated>2022-11-05T18:49:02.297Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Вкрутил в <a href="https://github.com/spiiin/dasbox_sfml" target="_blank" rel="noopener">dasbox_sfml</a> поддержку <a href="http://ru.esotericsoftware.com/" target="_blank" rel="noopener">spine-runtime</a>.</p><p>Добавлена минимальная поддержка — <a href="https://github.com/spiiin/dasbox_sfml/blob/main/src/sfmlSpine.cpp" target="_blank" rel="noopener">модуль</a> с кастомной обёрткой над типом и несколькими функциями настройки.</p><p>Сделан для того, чтобы детальнее разобраться с байндингом (проверить, как работает вручную, в отличие от автоматической генерации)<br><a href="/blog/500729544/" title="daScript: C++ auto-bindings, assimp">daScript: C++ auto-bindings, assimp</a><br>И чтобы улучшить визуал примеров<br><a href="/blog/4060902549/" title="daScript. SFML, dasBox и semi-transparent render target">daScript. SFML, dasBox и semi-transparent render target</a></p><p>Примеры:</p><h2 id="Рендер-спайна-в-текстуру"><a href="#Рендер-спайна-в-текстуру" class="headerlink" title="Рендер спайна в текстуру"></a>Рендер спайна в текстуру</h2><p><img src="/blog/887709799/spine_sfml_1_small.png" alt=""><br><a href="https://github.com/spiiin/dasbox_sfml/blob/main/samples/sfml_spines/demo_spines_2_rt.das" target="_blank" rel="noopener">https://github.com/spiiin/dasbox_sfml/blob/main/samples/sfml_spines/demo_spines_2_rt.das</a></p><p>Способ отрендерить полупрозрачный объект в рендер-таргет текстуру детально описан в первой части статьи (<code>source-over</code> и <code>premultiply alpha</code>). Также для сравнения выведена текстура с обычным режимом блендинга (посередине) — полупрозрачный шлем излишне чёрный.</p><h2 id="Shader"><a href="#Shader" class="headerlink" title="Shader"></a>Shader</h2><p><img src="/blog/887709799/spine_sfml_2_small.png" alt=""><br><a href="https://github.com/spiiin/dasbox_sfml/blob/main/samples/sfml_spines/demo_spines_3_shader.das" target="_blank" rel="noopener">https://github.com/spiiin/dasbox_sfml/blob/main/samples/sfml_spines/demo_spines_3_shader.das</a></p><p>Спайны чаще всего состоят из большого количества аттачментов (чаще всего 2d-меши), которые рендерятся послойно, так что для наложения некоторых эффектов, влияющих на изображение целиком (outline, различные виды distortion, motion-эффекты, glow), необходимо также предварительно отрендерить спайн целиком в текстуру. Отдельное приключение — получить размеры render-target текстуры, в которые поместиться спайн во время анимации. Чаще всего эти сведения можно получить только от артиста, либо просчитать в real-time/compile-time (анимации могут накладываться друг на друга различными способами).</p><p>В live-режиме удобно, что нет особой необходимости писать gui для настройки параметров шейдера, можно играться с ними, мгновенно получая фидбек на экране.</p><h2 id="Реверс-блендинг"><a href="#Реверс-блендинг" class="headerlink" title="Реверс-блендинг"></a>Реверс-блендинг</h2><p><img src="/blog/887709799/spine_sfml_3_small.png" alt=""><br><a href="https://github.com/spiiin/dasbox_sfml/blob/main/samples/sfml_spines/demo_spines_4_reverse_blending.das" target="_blank" rel="noopener">https://github.com/spiiin/dasbox_sfml/blob/main/samples/sfml_spines/demo_spines_4_reverse_blending.das</a></p><p>Напоследок — интересный и сложный в реализации через sfml и spine-runtime эффект, описанный в статье <a href="https://habr.com/ru/company/playrix/blog/487250/" target="_blank" rel="noopener">Отложенный Alpha blending</a>. Способ позволяет отрендерить “дырки” в спайнах любой формы за один проход, без использования предзаготовленных масок и рендер-таргет текстур. На скриншоте — анимированный спайн лианы, через которую сквозь основной спайн видно фоновый спрайт.</p><p>Реализация требует обратного порядка отрисовки и специальных формул блендинга. Порядок отрисовки:</p><ul><li>экран очищается цветом [0,255,0,0] - в альфа-компоненте должен быть 0, а не 255!</li><li>передний спайн с обычным режимом блендинга</li><li>спайн-“дырка”, с режимом блендинга “вычитание” - glBlendFunc(GL_ZERO, GL_ONE_MINUS_SRC_ALPHA)</li><li>фон, который “просвечивает” через основной спрайт только там, где была нарисована дырка - glBlendFuncSeparate(GL_SRC_ALPHA_SATURATE, GL_ONEU, GL_ONEU, GL_ONE_MINUS_SRC_ALPHA)</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">def initialize</span><br><span class="line">    ...</span><br><span class="line">    spine = <span class="keyword">new</span> SpineWrapper(<span class="string">"spineboy-pro.skel"</span>,  <span class="string">"spineboy-pma.atlas"</span>)</span><br><span class="line">    spine |&gt; set_position(<span class="number">320.0</span>, <span class="number">590.0</span>)</span><br><span class="line">    spine |&gt; set_animation(<span class="number">0</span>, <span class="string">"walk"</span>, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">    spineHole = <span class="keyword">new</span> SpineWrapper(<span class="string">"vine-pro.skel"</span>,  <span class="string">"vine-pma.atlas"</span>)</span><br><span class="line">    spineHole |&gt; set_premultiply_alpha(<span class="literal">false</span>) <span class="comment">//отключаем режим premultiply</span></span><br><span class="line">    spineHole |&gt; set_position(<span class="number">320.0</span>, <span class="number">640.0</span>)</span><br><span class="line">    spineHole |&gt; set_animation(<span class="number">0</span>, <span class="string">"grow"</span>, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">def draw</span><br><span class="line">    withRenderTarget &lt;| $(var rt: RenderTarget&amp;)</span><br><span class="line">        rt |&gt; clear(Color(<span class="number">0u</span>,<span class="number">255u</span>,<span class="number">0u</span>,<span class="number">0u</span>))</span><br><span class="line">        <span class="comment">//draw base spine</span></span><br><span class="line">        rt |&gt; draw(spine, RenderStates_Default())</span><br><span class="line"></span><br><span class="line">        <span class="comment">//draw hole spine</span></span><br><span class="line">        <span class="keyword">using</span>(Factor Zero, Factor OneMinusSrcAlpha, Equation Add) &lt;| $(var blendMode: BlendMode#)</span><br><span class="line">            <span class="keyword">using</span>(blendMode) &lt;| $(var renderState: RenderStates#)</span><br><span class="line">                rt |&gt; draw(spineHole, renderState)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//draw triangle, special render mode</span></span><br><span class="line">        <span class="comment">//raw opengl</span></span><br><span class="line">        glBlendFuncSeparate(GL_SRC_ALPHA_SATURATE, GL_ONEU, GL_ONEU, GL_ONE_MINUS_SRC_ALPHA)</span><br><span class="line">        glUseProgram(program)</span><br><span class="line">        vs_main_bind_uniform(program)</span><br><span class="line">        fs_main_bind_uniform(program)</span><br><span class="line">        glBindVertexArray(vao)</span><br><span class="line">        glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">6</span>)</span><br><span class="line">        glBindVertexArray(<span class="number">0u</span>)</span><br><span class="line">        glUseProgram(<span class="number">0u</span>)</span><br></pre></td></tr></table></figure><ul><li>spine-runtime позволяет аниматорам выставлять и переключать режимы блендинга самостоятельно, поэтому чтобы спайн был отрисован с кастомным режимом блендинга, необходимо использовать не “нормальный” блендинг, а <a href="https://github.com/spiiin/spine_cpp_sfml/blob/main/spine-sfml/spine-sfml.cpp#L171" target="_blank" rel="noopener">тот</a>, который был выставлен в sfml. Также спайн-“дырка” не должен использовать каких-либо дополнительный режимов блендинга в ходе анимации.</li><li>режим блендинга GL_SRC_ALPHA_SATURATE почему-то вообще не прокинут в <a href="https://www.sfml-dev.org/documentation/2.5.1/structsf_1_1BlendMode.php" target="_blank" rel="noopener">SFML</a>, поэтому фон отрисован с помощью функций opengl (<a href="https://www.sfml-dev.org/tutorials/2.5/window-opengl.php" target="_blank" rel="noopener">sfml+opengl</a> без проблем уживаются вместе).</li></ul><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;Вкрутил в 
      
    
    </summary>
    
    
    
      <category term="opengl" scheme="http://spiiin.github.io/tags/opengl/"/>
    
      <category term="dascript" scheme="http://spiiin.github.io/tags/dascript/"/>
    
  </entry>
  
  <entry>
    <title>daScript. SFML, dasBox и semi-transparent render target</title>
    <link href="http://spiiin.github.io/blog/4060902549/"/>
    <id>http://spiiin.github.io/blog/4060902549/</id>
    <published>2022-10-22T12:29:18.000Z</published>
    <updated>2022-10-23T17:36:01.564Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Пример работы с SFML в dasBox — рендер полупрозрачных объектов в рендер-таргет. Тривиальная задача для графического программиста, но почему-то многие разработчики игр не знают, как это корректно сделать.</p><h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>Изначальная задумка поста — собрать небольшой пример, показывающий алгоритм рендеринга полупрозрачных объектов в текстуру, с последующим корректным отображением этой текстуры, как если бы объекты рендерились на экран напрямую, без использования этой текстуры. Но попутно оказалось, что можно запилить фреймворк для таких демок, с возможноостью в live-режиме поиграться с параметрами и посмотреть результат.</p><h2 id="dasSFML"><a href="#dasSFML" class="headerlink" title="dasSFML"></a>dasSFML</h2><p>Примеры на <code>Opengl+GLFW</code>:<br><a href="/blog/4232971949/" title="daScript OpenGL">daScript OpenGL</a><br><a href="/blog/3006126295/" title="daScript - live-режим">daScript - live-режим</a></p><p>В отличие от GLFW, <code>SFML</code> представляет простые объекты-обёртки над функциями OpenGL для работы с текстурами, шейдерами, рендер-таргетами, и прочими примитивами библиотеки рендера, в то же время представляя для кастомизации практически все параметры рендера (во всяком случае необходимые для задуманного примера), для того, чтобы можно было писать небольшие примеры алгоритмов рендера на OpenGL.</p><p>Для начала, можно “завести” простейший <a href="https://github.com/borisbat/dasSFML/blob/main/examples/graphics.das" target="_blank" rel="noopener">пример</a> из комплекта привязки <code>SFML</code> к <code>daScript</code>.</p><p>Для его сборки выкачиваем сабмодули <code>daScript</code>:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git submodule update --init --recursive</span><br></pre></td></tr></table></figure></p><p>Затем включаем сборку этого модуля в CmakeLists.txt и добавляем линковку статической библиотеки с модулем libDasSFML и самих библиотек SFML:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">option(DAS_SFML_DISABLED &quot;Disable dasSFML (SFML multimedia library)&quot; OFF)</span><br><span class="line">...</span><br><span class="line">target_link_libraries(sfmlApp</span><br><span class="line">  libDasModuleSFML</span><br><span class="line">  sfml-graphics</span><br><span class="line">  sfml-network</span><br><span class="line">  sfml-system</span><br><span class="line">  sfml-window</span><br><span class="line">  #для windows также:</span><br><span class="line">  legacy_stdio_definitions</span><br><span class="line">  winmm</span><br><span class="line">  Opengl32</span><br><span class="line">  sfml-main</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>и перегененируем проект<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;generate_msvc_2019.bat</span><br></pre></td></tr></table></figure></p><p>Затем в хост-приложении на C++:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//подключение заголовка с определением модуля</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dasSFML/src/dasSFML.h&gt;</span></span></span><br><span class="line">...</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span>, <span class="keyword">char</span> * [] )</span> </span>&#123;</span><br><span class="line">    NEED_ALL_DEFAULT_MODULES;</span><br><span class="line">    NEED_MODULE(Module_dasSFML); <span class="comment">//&lt;---создаём модуль sfml</span></span><br><span class="line">    Module::Initialize();</span><br><span class="line">    run_script();</span><br><span class="line">    Module::Shutdown();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>run_script</code> вызывает метод <code>main</code> из примера, который создаёт SFML-окно и запускает цикл обработки сообщений в нём.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main</span><br><span class="line">    <span class="keyword">using</span>(VideoMode(<span class="number">640u</span>,<span class="number">480u</span>), <span class="string">"SFML window"</span>, uint(WindowStyle Default), ContextSettings()) &lt;| $ ( var window : RenderWindow# )</span><br><span class="line">        <span class="keyword">while</span> window |&gt; isOpen()</span><br><span class="line">            var event : Event</span><br><span class="line">            <span class="keyword">while</span> window |&gt; pollEvent(event)</span><br><span class="line">                <span class="keyword">if</span> event._type == EventType Closed</span><br><span class="line">                    window |&gt; close()</span><br><span class="line">            interface(window) &lt;| $ ( var rt : RenderTarget )</span><br><span class="line">                rt |&gt; clear( Color(<span class="number">64u</span>,<span class="number">0u</span>,<span class="number">0u</span>,<span class="number">255u</span>) )</span><br><span class="line">                <span class="keyword">using</span>(<span class="number">50.0f</span>,<span class="number">0x1e</span>ul) &lt;| $ ( var shape : CircleShape# )</span><br><span class="line">                    interface(shape) &lt;| $ ( var tr : Transformable )</span><br><span class="line">                        tr |&gt; move(<span class="number">20.</span>,<span class="number">30.</span>)</span><br><span class="line">                    shape |&gt; setFillColor(Color(<span class="number">150u</span>,<span class="number">50u</span>,<span class="number">250u</span>,<span class="number">255u</span>))</span><br><span class="line">                    shape |&gt; setOutlineThickness(<span class="number">10.f</span>)</span><br><span class="line">                    shape |&gt; setOutlineColor(Color(<span class="number">250u</span>,<span class="number">150u</span>,<span class="number">100u</span>,<span class="number">255u</span>))</span><br><span class="line">                    rt |&gt; draw(shape, RenderStates_Default())</span><br><span class="line">            window |&gt; display()</span><br></pre></td></tr></table></figure><p>В качестве фреймворка для создания окна используется имеющийся в SFML класс <code>Window</code>. Однако проще воспользоваться другим фреймворком, в который уже внедрены возможности daScript-а по перезагрузке кода.</p><h2 id="dasbox"><a href="#dasbox" class="headerlink" title="dasbox"></a>dasbox</h2><p><a href="https://github.com/imp5imp5/dasbox" target="_blank" rel="noopener">dasbox</a> — примитивный движок для 2d-игр, который Gaijin-ы использовали для проведения конкурса <a href="https://gaijinjam.net/ru" target="_blank" rel="noopener">Gaijin Jam</a> (<a href="https://github.com/AlexLemminG/TheFarmers" target="_blank" rel="noopener">игра-победитель</a>). Движок имеет простую <a href="https://github.com/imp5imp5/dasbox/blob/main/doc/api.txt" target="_blank" rel="noopener">апишку</a>, на которой можно потренироваться использованию языка на уровне “как будто типизированная lua”, а также настроен для подключения отладчика языка, веб-инспектора для отображения состояния ecs-модуля и горячей перезагрузке кода.</p><p>Но для меня интереснее другое — <code>dasbox</code> использует в качестве бекэнда <code>SFML</code>. И хотя это осознанно скрыто от пользователей для того, чтобы можно было сменить бекэнд, можно немного “поломать инкапсуляцию”, для того, чтобы воспользоваться в нём модулем <code>dasSFML</code>, и получить доступ к более богатому API, получив от самого dasbox-а фичи и инструменты по работе с кодом.</p><p><a href="https://github.com/spiiin/dasbox_sfml" target="_blank" rel="noopener">dasbox_sfml</a> — порт дасбокса с включенным модулем dasSFML.</p><p>Базовый пример на нём выглядит так:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">require daslib/media</span><br><span class="line">require sfml</span><br><span class="line">require dasbox_sfml</span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def initialize</span><br><span class="line">    set_window_title(<span class="string">"sfml"</span>)</span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line"><span class="function">def <span class="title">act</span><span class="params">(dt: <span class="keyword">float</span>)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">if</span> <span class="title">get_key</span><span class="params">(VK_ESCAPE)</span></span></span><br><span class="line"><span class="function">        <span class="title">schedule_quit_game</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">[export]</span><br><span class="line">def draw</span><br><span class="line">    withRenderTarget &lt;| $(var rt: RenderTarget&amp;)</span><br><span class="line">        rt |&gt; clear(Color(<span class="number">0u</span>,<span class="number">255u</span>,<span class="number">0u</span>,<span class="number">255u</span>))</span><br><span class="line">        <span class="keyword">using</span>(<span class="number">50.0f</span>,<span class="number">0x1e</span>ul) &lt;| $(var shape: CircleShape#)</span><br><span class="line">            interface(shape) &lt;| $(var tr: Transformable)</span><br><span class="line">                tr |&gt; move(<span class="number">20.</span>,<span class="number">30.</span>)</span><br><span class="line">            shape |&gt; setFillColor(Color(<span class="number">150u</span>,<span class="number">50u</span>,<span class="number">250u</span>,<span class="number">255u</span>))</span><br><span class="line">            shape |&gt; setOutlineThickness(<span class="number">10.f</span>)</span><br><span class="line">            shape |&gt; setOutlineColor(Color(<span class="number">250u</span>,<span class="number">150u</span>,<span class="number">100u</span>,<span class="number">255u</span>))</span><br><span class="line">            rt |&gt; draw(shape, RenderStates_Default())</span><br></pre></td></tr></table></figure><br><img src="/blog/4060902549/screen1_small.png" alt=""></p><p><code>dasBox_sfml</code> подхватывает изменения в файле с кодом, а также отображает в своей консоли ошибки в этом файле.</p><p>Идиомы <code>daScript</code> в примере:</p><ul><li><code>using()</code> - создание переменной <a href="https://dascript.org/doc/reference/language/temporary.html" target="_blank" rel="noopener">временного типа</a>, который существует только в пределах блока using</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span>() &lt;| $(var fs: das_string#)</span><br><span class="line">    fs := <span class="string">"hello world"</span></span><br><span class="line">    <span class="comment">//тут можно использовать переменную, в том числе передавать в другие функции</span></span><br><span class="line">    some_func(fs)</span><br><span class="line">    <span class="comment">//но нельзя как-либо сохранить указатель на эту переменную</span></span><br><span class="line">    <span class="comment">//var s = fs //ошибка, нельзя копировать временный тип</span></span><br></pre></td></tr></table></figure><ul><li><code>interface</code> - приведение к базовому типу</li></ul><p>Генератор привязок на C++ позволяет передать отношение наследования двух C++ типов в daScript так:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">addExtern&lt; <span class="keyword">decltype</span>(&amp;with_interface&lt;sf::Sprite,sf::Transformable&gt;), with_interface&lt;sf::Sprite,sf::Transformable&gt; &gt;(*<span class="keyword">this</span>,lib,<span class="string">"interface"</span>,SideEffects::invoke,<span class="string">"with_interface&lt;sf::Sprite,sf::Transformable&gt;"</span>);</span><br></pre></td></tr></table></figure></p><p><code>daScript</code> заставляет думать о типах и их времени жизни немного больше, чем C++, но и позволяет выразить больше таких утверждений, которые сможет проверить компилятор, чтобы уберечься от ошибок.</p><h2 id="RenderTarget"><a href="#RenderTarget" class="headerlink" title="RenderTarget"></a>RenderTarget</h2><p>Следующий пример — рендер в текстуру и отображение её на экране. В SFML для этого можно использовать класс <a href="https://www.sfml-dev.org/documentation/2.5.1/classsf_1_1RenderTexture.php" target="_blank" rel="noopener">RenderTexture</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">def draw</span><br><span class="line">    withRenderTarget &lt;| $(var rt: RenderTarget&amp;)</span><br><span class="line">        clear(rt, Color(<span class="number">0u</span>,<span class="number">255u</span>,<span class="number">0u</span>,<span class="number">255u</span>))</span><br><span class="line">        <span class="keyword">using</span>() &lt;| $(var rtTex: RenderTexture#)</span><br><span class="line">            rtTex |&gt; create(<span class="number">300u</span>, <span class="number">300u</span>, <span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">using</span>(<span class="number">50.0f</span>,<span class="number">0x1e</span>ul) &lt;| $(var shape: CircleShape#)</span><br><span class="line">                interface(shape) &lt;| $(var tr: Transformable)</span><br><span class="line">                    tr |&gt; move(<span class="number">20.</span>,<span class="number">30.</span>)</span><br><span class="line">                shape |&gt; setFillColor(Color(<span class="number">150u</span>,<span class="number">50u</span>,<span class="number">250u</span>,<span class="number">255u</span>))</span><br><span class="line">                shape |&gt; setOutlineThickness(<span class="number">10.f</span>)</span><br><span class="line">                shape |&gt; setOutlineColor(Color(<span class="number">250u</span>,<span class="number">150u</span>,<span class="number">100u</span>,<span class="number">255u</span>))</span><br><span class="line">                rtTex |&gt; draw(shape, RenderStates_Default())</span><br><span class="line">            <span class="keyword">using</span>(rtTex |&gt; getTexture()) &lt;| $(var sprite: Sprite#)</span><br><span class="line">                rt |&gt; draw(sprite, RenderStates_Default())</span><br></pre></td></tr></table></figure><p>Пока всё хорошо, и круг отрендеренный в текстуру выглядит также, как если бы был выведен на экран напрямую</p><h2 id="Полупрозрачные-объекты-в-RenderTarget"><a href="#Полупрозрачные-объекты-в-RenderTarget" class="headerlink" title="Полупрозрачные объекты в RenderTarget"></a>Полупрозрачные объекты в RenderTarget</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//рендер двух полупрозрачных кругов</span></span><br><span class="line"><span class="function">def <span class="title">drawCircles</span><span class="params">(var rt: RenderTarget&amp;)</span></span></span><br><span class="line">    using(125.0f, 128ul) &lt;| $(var shape: CircleShape#)</span><br><span class="line">        shape |&gt; setFillColor(Color(<span class="number">0u</span>,<span class="number">255u</span>,<span class="number">0u</span>,<span class="number">128u</span>))</span><br><span class="line">        rt |&gt; draw(shape, RenderStates_Default())</span><br><span class="line">    <span class="keyword">using</span>(<span class="number">125.0f</span>, <span class="number">128u</span>l) &lt;| $(var shape: CircleShape#)</span><br><span class="line">        interface(shape) &lt;| $(var tr: Transformable) &#123; tr |&gt; move(<span class="number">125.0f</span>, <span class="number">0.0f</span>); &#125;</span><br><span class="line">        shape |&gt; setFillColor(Color(<span class="number">255u</span>,<span class="number">05u</span>,<span class="number">0u</span>,<span class="number">128u</span>))</span><br><span class="line">        rt |&gt; draw(shape, RenderStates_Default())</span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def draw</span><br><span class="line">    withRenderTarget &lt;| $(var rt: RenderTarget&amp;)</span><br><span class="line">        rt |&gt; clear(Color(<span class="number">255u</span>,<span class="number">255u</span>,<span class="number">255u</span>,<span class="number">255u</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment">//простой рендер</span></span><br><span class="line">        text_out(<span class="number">0</span>, <span class="number">0</span>, <span class="string">"Simple"</span>, <span class="number">0xFF000000</span>)</span><br><span class="line">        drawCircles(rt)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//рендер в текстуру</span></span><br><span class="line">        text_out(<span class="number">0</span>, <span class="number">300</span>, <span class="string">"Texture"</span>, <span class="number">0xFF000000</span>)</span><br><span class="line">        <span class="keyword">using</span>() &lt;| $(var rtTex: RenderTexture#)</span><br><span class="line">            rtTex |&gt; create(<span class="number">250u</span> + <span class="number">125u</span>, <span class="number">250u</span>, <span class="literal">false</span>)</span><br><span class="line">            rtTex |&gt; clear(Color(<span class="number">0u</span>, <span class="number">0u</span>, <span class="number">0u</span>, <span class="number">0u</span>))</span><br><span class="line">            drawCircles(rtTex)</span><br><span class="line">            <span class="keyword">using</span>(rtTex |&gt; getTexture()) &lt;| $(var sprite: Sprite#)</span><br><span class="line">                interface(sprite) &lt;| $(var tr: Transformable)</span><br><span class="line">                    tr |&gt; move(<span class="number">0.0f</span>, <span class="number">300.0f</span>)</span><br><span class="line">                rt |&gt; draw(sprite, RenderStates_Default())</span><br></pre></td></tr></table></figure><p><img src="/blog/4060902549/screen2_small.png" alt=""></p><p>Полупрозрачные круги, отрендеренные в текстуру, выглядят темнее, чем отрисованные на экране напрямую. С реальными текстурами (или отрендеренными в текстуру шрифтами), проблема обычно выглядит как темная рамка на краях объекта (там где края ради сглаживания плавно “уходят” в прозрачность).</p><p>Из-за чего это возникает?</p><p>Цвет пиксела отрисованного объекта смешивается в пикселем, уже находящимся в буфере цвете по настраиваемым формулам. При прямой отрисовке порядок рендера получается таким:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">рисуется пиксел красного круга -&gt; смешивается с цветом dst1 фона (белое изображение) &#x3D; получаем цвет dst2</span><br><span class="line">рисуется пиксел зеленого круга -&gt; смешивается с цветом dst2 (фон + красный круг)</span><br></pre></td></tr></table></figure></p><p>Тогда как в случае рендера в текстуру происходит:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">рисуется пиксел красного круга -&gt; смешивается с фоновым цветом рендер таргет текстуры dst_rt1 (&quot;пустой&quot; rgba цвет, rgb каналы по умолчанию чёрные) &#x3D; получаем dst_rt2</span><br><span class="line">рисуется пиксел зелёного круга -&gt; смешивается с цветом dst_rt2 (пустой цвет текстуры + красный круг)</span><br><span class="line">текстура выводится на экран -&gt; смешивается цвет фона dst1 с цветом рендер таргет текстуры (пустой цвет текстуры + красный круг + зелёный круг)</span><br></pre></td></tr></table></figure></p><p>Видно, что в итоговом цвете на экрана присутствует влияние цвета render-target текстуры — прозрачного по альфа каналу, но в итоговой формуле кроме альфа канала влияение оказывают также и RGB каналы цвета (чёрного или любого другого — неважно, но избавиться от влияния этого фонового цвета без изменения формулы смешивания невозможно, “невидимый” цвет начинает быть видимым).</p><h2 id="Настройка-режимов-смешивания"><a href="#Настройка-режимов-смешивания" class="headerlink" title="Настройка режимов смешивания"></a>Настройка режимов смешивания</h2><p><code>OpenGL</code> (и <code>SFML</code> над ней) дают возможность переключать формулы режимов смешивания. Важно отойти от представления “определенная формула магическим образом включает полупрозрачность” к тому, что графический API просто даёт возможность изменить уравнение смешивание, а вывод конкретных формул ложится на плечи программиста.</p><p>Стандартное уравнение смешивания для полупрозрачности смешивает цвета в пропорции:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); </span><br><span class="line">GL_SRC_ALPHA - коэффициент смешивания рисуемого цвета - чем прозрачнее рисуемая фигура, тем меньше видно её цвет</span><br><span class="line">GL_ONE_MINUS_SRC_ALPHA - коэффициент смешивания фонового цвета - обратный, чем прозрачнее рисуемая фигура, тем больше видно цвет за ней</span><br><span class="line"></span><br><span class="line">r1 - цвет фона</span><br><span class="line">r2 - цвет 1-го круга</span><br><span class="line">r3 - цвет 2-го круга</span><br><span class="line">после отрисовки фона m1 &#x3D; (a1 * r1)</span><br><span class="line">смешанный цвет после отрисовки первого круга m2 &#x3D; (a2 * r2 + (1.0 - a2) * a1 * r1)</span><br><span class="line">смешанный цвет после отрисовки второго круга m3 &#x3D; (a3 * r3 + (1.0 - a3) * (a2 * r2 + (1.0 - a2) * a1 * r1)) &#x3D; </span><br><span class="line"> &#x3D; (a3 * r3 + (1.0 - a3) * a2 * r2 + (1.0 - a3) * (1.0 - a2) * a1 * r1)</span><br></pre></td></tr></table></figure></p><p>При рендере в текстуру по умолчанию используется другая формула, которая разделяет рассчёты для RGB-каналов цвета и для A-канала.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ONE_MINUS_SRC_ALPHA);</span><br><span class="line">для RGB-каналов - аналогично предыдущей формуле</span><br><span class="line">для A-канала:</span><br><span class="line">  Asrc + Adst * (1-Asrc) - альфа значение рисуемого цвета берётся &quot;как есть&quot; и складывается с уменьшенным фоновым значением </span><br><span class="line"></span><br><span class="line">Цвет и альфа для рендер-таргет текстуры - glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ONE_MINUS_SRC_ALPHA);</span><br><span class="line">цвет в рендер-таргет текстуре rt1 &#x3D; r1 * a1 (берём черный прозрачный цвет r1&#x3D;(0,0,0), a1&#x3D;0 - четвёртый компонент важен)</span><br><span class="line">цвет после добавления круга rt2 &#x3D; (a2 * r2 + (1.0 - a2) * a1 * r1) &#x3D; a2 * r2     &#x2F;&#x2F;premultiply alpha</span><br><span class="line">альфа после добавления круга rta2 &#x3D; a2 + a1 * (1-a2) &#x3D; a2</span><br><span class="line">цвет после добавления второго круга rt3 &#x3D; (a3 * r3 + (1.0 - a3) * a2 * r2)</span><br><span class="line">альфа после добавления второго круга rta3 &#x3D; a3 + a2 * (1 - a3)</span><br></pre></td></tr></table></figure><p>Эта формула годится только для рендера полностью непрозрачных объектов. Если какие-то части объекта прозрачные, необходимо использовать другую пару формул (для рендера в текстуру + для рендера полученной текстуры на экране). Для рендера в текстуру при этом можно даже получать “неправильные” цвета, которые можно потом смешать с изображением на экране так, чтобы смешанный итоговый цвет стал корректным.</p><p>Хороший разбор проблемы на <a href="https://stackoverflow.com/questions/24346585/opengl-render-to-texture-with-partial-transparancy-translucency-and-then-rende" target="_blank" rel="noopener">stackoverflow</a><br>Формулы смешивания также разжеваны в статье <a href="https://habr.com/ru/post/468067/" target="_blank" rel="noopener">Как работает альфа-композитинг</a></p><h2 id="Source-Over"><a href="#Source-Over" class="headerlink" title="Source-Over"></a>Source-Over</h2><p>Одно из возможных решений — смешать цвет полученной render target текстуры в режиме <code>Source-Over</code> (термин из статьи выше, из списка операторов смешивания Портера-Даффа):<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA)</span><br><span class="line">итоговый цвет m3 &#x3D; rt3 + m1 * (1.0 - rta3)</span><br><span class="line"></span><br><span class="line">подставим сюда значения значения из предудыщей формулы для рендерт-таргет цвета и текстуры:</span><br><span class="line">m3 &#x3D; (a3 * r3 + (1.0 - a3) * a2 * r2) + (a1 * r1) * (1.0 - a3 - a2 * (1 - a3))</span><br><span class="line"></span><br><span class="line">Теперь можно сравнить полученные значения итогового цвета m3 из формулы прямого рендера и этой формулы:</span><br><span class="line">m3_direct &#x3D;&#x3D; m3_sourceover</span><br><span class="line">(a3 * r3 + (1.0 - a3) * a2 * r2 + (1.0 - a3) * (1.0 - a2) * a1 * r1) &#x3D;&#x3D; (a3 * r3 + (1.0 - a3) * a2 * r2) + (a1 * r1) * (1.0 - a3 - a2 * (1 - a3))</span><br><span class="line">(1.0 - a3) * (1.0 - a2) &#x3D;&#x3D; (1.0 - a3 - a2 * (1 - a3)</span><br><span class="line">1.0 - a3 - a2 + a2*a3 &#x3D;&#x3D; 1.0 - a3 - a2 + a2*a3</span><br><span class="line"></span><br><span class="line">Тада! убедились в равенстве</span><br></pre></td></tr></table></figure></p><p>Код смешивания в режиме <code>Source-Over</code>, правильный результат:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">def draw</span><br><span class="line">    withRenderTarget &lt;| $(var rt: RenderTarget&amp;)</span><br><span class="line">        rt |&gt; clear(Color(<span class="number">255u</span>,<span class="number">255u</span>,<span class="number">255u</span>,<span class="number">255u</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment">//simple draw</span></span><br><span class="line">        text_out(<span class="number">0</span>, <span class="number">0</span>, <span class="string">"Simple"</span>, <span class="number">0xFF000000</span>)</span><br><span class="line">        drawCircles(rt)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//render texture draw</span></span><br><span class="line">        text_out(<span class="number">0</span>, <span class="number">300</span>, <span class="string">"Texture: Satsub"</span>, <span class="number">0xFF000000</span>)</span><br><span class="line">        <span class="keyword">using</span>() &lt;| $(var rtTex: RenderTexture#)</span><br><span class="line">            rtTex |&gt; create(<span class="number">250u</span> + <span class="number">125u</span>, <span class="number">250u</span>, <span class="literal">false</span>)</span><br><span class="line">            rtTex |&gt; clear(Color(<span class="number">0u</span>, <span class="number">0u</span>, <span class="number">0u</span>, <span class="number">0u</span>))</span><br><span class="line">            drawCircles(rtTex)</span><br><span class="line">            <span class="keyword">using</span>(rtTex |&gt; getTexture()) &lt;| $(var sprite: Sprite#)</span><br><span class="line">                interface(sprite) &lt;| $(var tr: Transformable)</span><br><span class="line">                    tr |&gt; move(<span class="number">0.0f</span>, <span class="number">300.0f</span>)</span><br><span class="line">                <span class="keyword">using</span>(Factor One, Factor OneMinusSrcAlpha, Equation Add) &lt;| $(var blendMode: BlendMode#)</span><br><span class="line">                    <span class="keyword">using</span>(blendMode) &lt;| $(var renderState: RenderStates#)</span><br><span class="line">                        rt |&gt; draw(sprite, renderState)</span><br></pre></td></tr></table></figure><br><img src="/blog/4060902549/screen3_small.png" alt=""></p><h2 id="Premultiply-alpha"><a href="#Premultiply-alpha" class="headerlink" title="Premultiply alpha"></a>Premultiply alpha</h2><p>Если посмотреть на коэффициенты смешивания в “неправильном” блендинге, и в <code>Sourse-Over</code>, можно прийти к более правильному интуитивному пониманию лишнего влияния цвета в неправильной версии. В неё не “вмешан” лишний чёрный цвет, а добавлено лишнее умножение цвета на альфа канал, которое “гасит” этот цвет больше, чем необходимо при корректном смешивании.</p><p>Можно пойти другим путём — убрать умножение цвета на альфу при смешивании совсем, но производить его 1 раз в шейдере — тогда не нужно переключать режим прозрачности, но нужно переключать шейдер, с которым отрисован объект. Преимуществом такого способами может быть то, что исходное изображение часто можно домножить на альфа-канал еще до запуска приложения (в демо-примере изображение генерится динамически, поэтому умножение сделано в шейдере).</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var fragmentShaderTex = (</span><br><span class="line"><span class="string">"uniform sampler2D texture;</span></span><br><span class="line"><span class="string">void main()</span></span><br><span class="line"><span class="string">\&#123;</span></span><br><span class="line"><span class="string">    gl_FragColor = texture2D(texture, gl_TexCoord[0].st);</span></span><br><span class="line"><span class="string">\&#125;"</span>)</span><br><span class="line"></span><br><span class="line">var fragmentShaderPremultiply = (</span><br><span class="line"><span class="string">"void main()</span></span><br><span class="line"><span class="string">\&#123;</span></span><br><span class="line"><span class="string">    //gl_FragColor = gl_Color;  //for testing no premultiply</span></span><br><span class="line"><span class="string">    gl_FragColor = vec4(gl_Color.rgb * gl_Color.a, gl_Color.a);</span></span><br><span class="line"><span class="string">\&#125;"</span>)</span><br><span class="line"></span><br><span class="line">var rsPremultiplySatSub, rsSatSub : RenderStates?</span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def initialize</span><br><span class="line">    set_window_title(<span class="string">"sfml"</span>) </span><br><span class="line"></span><br><span class="line">    var shaderPremult = <span class="keyword">new</span> Shader()</span><br><span class="line">    shaderPremult |&gt; load_fragment_shader_from_string(fragmentShaderPremultiply)</span><br><span class="line"></span><br><span class="line">    var shaderTex = <span class="keyword">new</span> Shader()</span><br><span class="line">    shaderTex |&gt; load_fragment_shader_from_string(fragmentShaderTex)    </span><br><span class="line">    shaderTex |&gt; bind_current_texture_to_uniform(<span class="string">"texture"</span>)</span><br><span class="line">    </span><br><span class="line">    var blendModeSatSubSeparate = <span class="keyword">new</span> BlendMode(Factor One, Factor OneMinusSrcAlpha, Equation Add, Factor OneMinusDstAlpha, Factor One, Equation Add)</span><br><span class="line"></span><br><span class="line">    rsPremultiplySatSub = makeRenderTarget(shaderPremult, blendModeSatSubSeparate)</span><br><span class="line">    rsSatSub = makeRenderTarget(shaderTex, blendModeSatSubSeparate)</span><br><span class="line"></span><br><span class="line">def drawCircles(var rt: RenderTarget&amp;; rs: RenderStates&amp; implicit)</span><br><span class="line">    <span class="keyword">using</span>(<span class="number">125.0f</span>, <span class="number">128u</span>l) &lt;| $(var shape: CircleShape#)</span><br><span class="line">        shape |&gt; setFillColor(Color(<span class="number">0u</span>,<span class="number">255u</span>,<span class="number">0u</span>,<span class="number">128u</span>))</span><br><span class="line">        rt |&gt; draw(shape, rs)</span><br><span class="line">    <span class="keyword">using</span>(<span class="number">125.0f</span>, <span class="number">128u</span>l) &lt;| $(var shape: CircleShape#)</span><br><span class="line">        interface(shape) &lt;| $(var tr: Transformable) &#123; tr |&gt; move(<span class="number">125.0f</span>, <span class="number">0.0f</span>); &#125;</span><br><span class="line">        shape |&gt; setFillColor(Color(<span class="number">255u</span>,<span class="number">05u</span>,<span class="number">0u</span>,<span class="number">128u</span>))</span><br><span class="line">        rt |&gt; draw(shape, rs)</span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">render_with_blend_and_premultiply</span><span class="params">(var rt: RenderTarget&amp;)</span></span></span><br><span class="line"><span class="function">    <span class="title">drawCircles</span><span class="params">(rt, *rsPremultiplySatSub)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">def <span class="title">render_sprite_with_blend</span><span class="params">(var rt: RenderTarget&amp;; var sprite: Sprite&amp; implicit)</span></span></span><br><span class="line">    rt |&gt; draw(sprite, *rsSatSub)</span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def draw</span><br><span class="line">    withRenderTarget &lt;| $(var rt: RenderTarget&amp;)</span><br><span class="line">        rt |&gt; clear(Color(<span class="number">255u</span>,<span class="number">255u</span>,<span class="number">255u</span>,<span class="number">255u</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment">//simple draw</span></span><br><span class="line">        text_out(<span class="number">0</span>, <span class="number">0</span>, <span class="string">"Simple"</span>, <span class="number">0xFF000000</span>)</span><br><span class="line">        drawCircles(rt, RenderStates_Default())</span><br><span class="line"></span><br><span class="line">        <span class="comment">//render texture draw</span></span><br><span class="line">        text_out(<span class="number">0</span>, <span class="number">300</span>, <span class="string">"Texture: Premult"</span>, <span class="number">0xFF000000</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">using</span>() &lt;| $(var rtTex: RenderTexture#)</span><br><span class="line">            rtTex |&gt; create(<span class="number">250u</span> + <span class="number">125u</span>, <span class="number">250u</span>, <span class="literal">false</span>)</span><br><span class="line">            rtTex |&gt; clear(Color(<span class="number">0u</span>, <span class="number">0u</span>, <span class="number">0u</span>, <span class="number">0u</span>))</span><br><span class="line">            render_with_blend_and_premultiply(rtTex)</span><br><span class="line">            <span class="keyword">using</span>(rtTex |&gt; getTexture()) &lt;| $(var sprite: Sprite#)</span><br><span class="line">                interface(sprite) &lt;| $(var tr: Transformable)</span><br><span class="line">                    tr |&gt; move(<span class="number">0.0f</span>, <span class="number">300.0f</span>)</span><br><span class="line">                render_sprite_with_blend(rt, sprite)</span><br></pre></td></tr></table></figure><p><img src="/blog/4060902549/screen4_small.png" alt=""></p><p>Универсальный режим смешивания для premultiply изображений:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">glBlendFuncSeparate(GL_ONE, GL_ONE_MINUS_SRC_ALPHA, GL_ONE_MINUS_DST_ALPHA, GL_ONE);</span><br><span class="line"></span><br><span class="line">Порядок рендера:</span><br><span class="line">1. Вывод в изображения в рендер-таргет текстуру с premultiply-шейдером (или же вывод подготовленного заранее изображения с обычным шейдером)</span><br><span class="line">2. Вывод рендер-таргет текстуры на экран с обычным шейдером (чтобы избежать лишнего умножения)</span><br><span class="line"></span><br><span class="line">математика (скопипащена с stackoverflow ответа):</span><br><span class="line">after layer 2: (a2 * r2, a2)</span><br><span class="line">after layer 3: (a3 * r3 + (1.0 - a3) * a2 * r2, (1.0 - a2) * a3 + a2)</span><br><span class="line"></span><br><span class="line">srcR &#x3D; a3 * r3 + (1.0 - a3) * a2 * r2</span><br><span class="line">srcA &#x3D; (1.0 - a2) * a3 + a2</span><br><span class="line">dstR &#x3D; a1 * r1</span><br><span class="line">ONE * srcR + ONE_MINUS_SRC_ALPHA * dstR</span><br><span class="line">    &#x3D; srcR + (1.0 - srcA) * dstR</span><br><span class="line">    &#x3D; a3 * r3 + (1.0 - a3) * a2 * r2 + (1.0 - ((1.0 - a2) * a3 + a2)) * a1 * r1</span><br><span class="line">    &#x3D; a3 * r3 + (1.0 - a3) * a2 * r2 + (1.0 - a3 + a2 * a3 - a2) * a1 * r1</span><br><span class="line">    &#x3D; a3 * r3 + (1.0 - a3) * a2 * r2 + (1.0 - a3) * (1.0 - a2) * a1 * r1</span><br></pre></td></tr></table></figure></p><p>Заметки по daScript:</p><ul><li>Вывод объекта с изменённым режимом блендинга и шейдером в <code>SFML</code> инкапуслирован в объекте <code>RenderStates</code></li><li>Вместо создания временных типов в этом примере используются “обычные” для <code>daScript</code> указатели:</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var shaderPremult : Shader? = <span class="keyword">new</span> Shader()</span><br></pre></td></tr></table></figure><p>Такие <a href="https://dascript.org/doc/reference/language/datatypes.html#pointers" target="_blank" rel="noopener">указатели</a> хранят объект в куче и владеют им, по семантике близко к <code>std::unique_ptr</code>. При желании можно освободить объект вручную, присвоив указателю <code>nullptr</code>.</p><ul><li>ключевое слово implicit после имени типа в аргументах функции позволяет функции работать с обычными типами, так и с временными.</li></ul><p>Код примеров - <a href="https://github.com/spiiin/dasbox_sfml/tree/main/samples/sfml_blending" target="_blank" rel="noopener">https://github.com/spiiin/dasbox_sfml/tree/main/samples/sfml_blending</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;Пример раб
      
    
    </summary>
    
    
    
      <category term="opengl" scheme="http://spiiin.github.io/tags/opengl/"/>
    
      <category term="dascript" scheme="http://spiiin.github.io/tags/dascript/"/>
    
  </entry>
  
  <entry>
    <title>daScript - решение задачек</title>
    <link href="http://spiiin.github.io/blog/2385889062/"/>
    <id>http://spiiin.github.io/blog/2385889062/</id>
    <published>2022-10-16T13:00:11.000Z</published>
    <updated>2022-10-16T13:55:33.792Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Решение нескольких алгоритмических задачек на <code>daScript</code>.<br><a id="more"></a></p><p>Задачки со старого собеса Nokia на C++ программиста (уже закрыли офис в России), <a href="https://twitter.com/st_1ena/status/1419689924505260032" target="_blank" rel="noopener">разбор</a></p><h2 id="Вычислить-первые-N-простых-чисел"><a href="#Вычислить-первые-N-простых-чисел" class="headerlink" title="Вычислить первые N простых чисел"></a>Вычислить первые N простых чисел</h2><p>.. и вернуть результат в качестве массива.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">calc_primes</span><span class="params">(n: <span class="keyword">int</span>; var a:<span class="built_in">array</span>&lt;<span class="keyword">int</span>&gt;)</span></span></span><br><span class="line">    a |&gt; clear</span><br><span class="line">    a |&gt; reserve(n)</span><br><span class="line"></span><br><span class="line">    a |&gt; push(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    a |&gt; push(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    let gen &lt;- generator&lt;<span class="keyword">int</span>&gt;() &lt;| $()</span><br><span class="line">        var t = <span class="number">6</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">true</span></span><br><span class="line">            yield t<span class="number">-1</span></span><br><span class="line">            yield t+<span class="number">1</span></span><br><span class="line">            t += <span class="number">6</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    var iterVal: <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">while</span> length(a) &lt; n</span><br><span class="line">        next(gen, iterVal)</span><br><span class="line">        var simple = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">for</span> prim in a</span><br><span class="line">            <span class="keyword">if</span> iterVal % prim == <span class="number">0</span></span><br><span class="line">                simple = <span class="literal">false</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> prim * prim &gt; iterVal</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> simple</span><br><span class="line">            a |&gt; push(iterVal)</span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main</span><br><span class="line">    var a: <span class="built_in">array</span>&lt;<span class="keyword">int</span>&gt;</span><br><span class="line">    calc_primes(<span class="number">1000000</span>, a)</span><br><span class="line">    print(<span class="string">"&#123;a[length(a)-1]&#125;\n"</span>)</span><br></pre></td></tr></table></figure><p><a href="https://github.com/spiiin/dascript_trivial_examples/blob/main/primes/primes.das" target="_blank" rel="noopener">https://github.com/spiiin/dascript_trivial_examples/blob/main/primes/primes.das</a></p><p>Тривиальная версия:</p><ul><li>чуть более улучшенная формула перебора чисел-кандидатов (вместо всех нечётных — t*6+/-1) + проверка границы не корнем, а квадратом.</li><li>не совсем понял, как хочет применить решето Эратосфена в варианте на C++ сама st_1ena, если нужны первые N простых чисел, а не “все числа меньшие N”, то возникает подзадача оценить минимальное натуральное число, меньше которого точно окажутся N простых чисел, что также нетривиально, или построить ленивых фильтров, что совсем нетривиально на C++, и требует оценки памяти под эти фильтры.</li><li>вместо этого, версия решения, которая может вычислить первые N чисел в compile-time — в предположении, что у нас есть некоторое количество памяти, для сохранения решета эратосфена, эффективнее тогда потратить всю эту память на хранение предпросчитанных первых значений, и начинать рассчёт только сверх этих предпросчитанных чисел. На языках с макросами — предпросчёт в compile-time выполняется той же функцией, что в run-time, т.е. не требует написания дополнительного кода.<br><a href="https://github.com/spiiin/dascript_trivial_examples/blob/main/primes/primes_mix_compile_runtime.das" target="_blank" rel="noopener">Версия</a>, которая сохраняет первый числа в кеш (макрос [cached_primes (count=200)] - с параметром, сколько чисел будет предпросчитано заранее)</li></ul><h2 id="Посчитать-статистику-слов-в-тексте-по-длине-слова"><a href="#Посчитать-статистику-слов-в-тексте-по-длине-слова" class="headerlink" title="Посчитать статистику слов в тексте по длине слова"></a>Посчитать статистику слов в тексте по длине слова</h2><p>Задача на то, чтобы найти в стандартной библиотеке языка нужные функциии</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">require fio</span><br><span class="line">require strings</span><br><span class="line">require daslib/strings_boost</span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line"><span class="function">def <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    var strings : <span class="built_in">array</span>&lt;<span class="built_in">string</span>&gt;</span></span><br><span class="line">    fopen("eng_to_rus.txt","rt") &lt;| $(f)</span><br><span class="line">        <span class="keyword">if</span> f != null</span><br><span class="line">            <span class="keyword">while</span> !feof(f)</span><br><span class="line">                strings |&gt; push &lt;| fgets(f)</span><br><span class="line"></span><br><span class="line">    var counter : table&lt;<span class="keyword">int</span>; <span class="keyword">int</span>&gt;</span><br><span class="line">    <span class="keyword">for</span> str in strings</span><br><span class="line">        var words &lt;- str |&gt; split_by_chars(<span class="string">" .,:-\n\t()%\"'"</span>)</span><br><span class="line">        <span class="keyword">for</span> word in words</span><br><span class="line">            <span class="keyword">if</span> word != <span class="string">""</span></span><br><span class="line">                counter[length(word)] += <span class="number">1</span>   <span class="comment">//word length</span></span><br><span class="line">                <span class="comment">//counter[word] += 1         //word</span></span><br><span class="line">    </span><br><span class="line">    var freq_pairs : <span class="built_in">array</span>&lt;tuple&lt;<span class="keyword">int</span>;<span class="keyword">int</span>&gt;&gt;</span><br><span class="line">    for k, v in keys(counter), values(counter)</span><br><span class="line">        freq_pairs |&gt; push &lt;| [[ tuple&lt;<span class="keyword">int</span>;<span class="keyword">int</span>&gt; k, v]]</span><br><span class="line">    freq_pairs |&gt; sort($(a,b) =&gt; !(a._1 &lt; b._1))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> pair in freq_pairs</span><br><span class="line">        print(<span class="string">"&#123;pair._0&#125; : &#123;pair._1&#125;\n"</span>)</span><br></pre></td></tr></table></figure><p><a href="https://github.com/spiiin/dascript_trivial_examples/blob/main/sort_words_stat_by_word_len/sort_words_stat_by_word_len.das" target="_blank" rel="noopener">https://github.com/spiiin/dascript_trivial_examples/blob/main/sort_words_stat_by_word_len/sort_words_stat_by_word_len.das</a></p><p>Решение в лоб - прочитать файл построчно, разбить на символы <code>split_by_chars</code>, обновляя в словаре значения количество слов. Дальше переложить значение в список пар, который отсортировать по первому элементу, и вывести на экран.</p><ul><li>Можно упороться по тому, чтобы выяснять у интервьюера, какие допустимы кодировки, разделители или что есть слова, как кажется подразумевали авторы задачи, которые потом расстроились, что ни один кандидат не учёл все возможные кейсы.</li><li>Можно сохранять данные не в словаре, а сразу в списке пар <code>(длина слова, частота)</code>, не так то и много возможных длин слов. Сортировка такого списка пар в daScript - либо с помощью явной передачи функции сортировки, либо определением <a href="https://github.com/GaijinEntertainment/daScript/blob/17941ef0b0199dff0db27a2bee603db1a45b69b3/examples/test/unit_tests/sort.das#L20" target="_blank" rel="noopener">оператора &lt;</a> для своего типа.</li></ul><h2 id="Удалить-из-односвязного-списка-каждый-пятый-элемент"><a href="#Удалить-из-односвязного-списка-каждый-пятый-элемент" class="headerlink" title="Удалить из односвязного списка каждый пятый элемент"></a>Удалить из односвязного списка каждый пятый элемент</h2><p>Интересно посмотреть на разницу в работе с памятью между C++ и daScript</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListItem</span></span></span><br><span class="line"><span class="class">    <span class="title">value</span>:</span> <span class="keyword">int</span></span><br><span class="line">    [[do_not_delete]] next: ListItem?</span><br><span class="line"></span><br><span class="line">def makeDemoList</span><br><span class="line">    var head =  <span class="keyword">new</span> [[ListItem value=<span class="number">1</span>]]</span><br><span class="line">    var current = head</span><br><span class="line">    <span class="keyword">for</span> i in range(<span class="number">2</span>, <span class="number">21</span>)</span><br><span class="line">        current.next = <span class="keyword">new</span> [[ListItem value=i]]</span><br><span class="line">        current = current.next</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">[sideeffects]</span><br><span class="line">def deleteEveryFifth(lst: ListItem?)</span><br><span class="line">    var counter = <span class="number">1</span></span><br><span class="line">    var current = lst</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> current != null</span><br><span class="line">        <span class="keyword">if</span> counter++ % <span class="number">4</span> == <span class="number">0</span></span><br><span class="line">            var toDelete = current.next</span><br><span class="line">            current.next = current.next?.next</span><br><span class="line">            unsafe &#123; <span class="keyword">delete</span> toDelete; &#125;</span><br><span class="line">        current = current.next</span><br><span class="line"></span><br><span class="line">def printList(lst: ListItem?)</span><br><span class="line">    <span class="keyword">if</span> lst != null</span><br><span class="line">        print(<span class="string">"&#123;lst.value&#125; "</span>)</span><br><span class="line">        printList(lst.next)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        print(<span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main</span><br><span class="line">    var <span class="built_in">list</span> = makeDemoList()</span><br><span class="line">    printList(<span class="built_in">list</span>)</span><br><span class="line">    deleteEveryFifth(<span class="built_in">list</span>)</span><br><span class="line">    printList(<span class="built_in">list</span>)</span><br><span class="line">    <span class="comment">//freeList //or just kill context</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Output:</span></span><br><span class="line"><span class="comment">// 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20</span></span><br><span class="line"><span class="comment">// 1 2 3 4 6 7 8 9 11 12 13 14 16 17 18 19</span></span><br></pre></td></tr></table></figure><p><a href="https://github.com/spiiin/dascript_trivial_examples/blob/main/delete_list_every_5/delete_every_fifth.das" target="_blank" rel="noopener">https://github.com/spiiin/dascript_trivial_examples/blob/main/delete_list_every_5/delete_every_fifth.das</a></p><ul><li>Раз мы “играем в C++”, то попробуем при удалении элемента из списка сразу же звать <a href="https://dascript.org/doc/reference/language/finalizers.html?highlight=finalizer" target="_blank" rel="noopener">финализатор</a> для него. Финализатор по умолчанию рекурсивно зовёт финализаторы для всех полей структуры. Это поведение можно изменить, если переопределить функцию <code>finalize</code>, или если пометить поле атрибутом <code>[[do_not_delete]]</code> (так как мы вручную измененяем указатели при удалении элемента, то элемент списка не отвечает за удаление следующего элемента по ссылке next).</li><li>С помощью <code>options persistent_heap = true</code>, можно настроить также освобождение памяти после вызова финализатора (иначе за освобождение памяти отвечает хост-программа, один из паттернов быстрой работы с памятью — грохнуть всю выделенную в цикле работы скрипта память разом).</li></ul><h2 id="Вывести-максимальное-число-составленное-из-единиц-двоичного-представления-заданного-числа"><a href="#Вывести-максимальное-число-составленное-из-единиц-двоичного-представления-заданного-числа" class="headerlink" title="Вывести максимальное число, составленное из единиц двоичного представления заданного числа"></a>Вывести максимальное число, составленное из единиц двоичного представления заданного числа</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">popcount</span><span class="params">(x)</span></span></span><br><span class="line"><span class="function">    var temp </span>= x</span><br><span class="line">    var count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> temp != <span class="number">0</span></span><br><span class="line">        temp &amp;= temp - <span class="number">1</span></span><br><span class="line">        count++</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line">def maxFrom1s(x)</span><br><span class="line">    let count1s = popcount(x)</span><br><span class="line">    var res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i in range(count1s)</span><br><span class="line">        res++</span><br><span class="line">        res&lt;&lt;=<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i in range(<span class="number">31</span> - count1s) <span class="comment">//assume 32 bits</span></span><br><span class="line">        res&lt;&lt;=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res </span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main</span><br><span class="line">    print(<span class="string">"&#123;uint(maxFrom1s(256-1))&#125;\n"</span>)  <span class="comment">//'0xff000000'</span></span><br></pre></td></tr></table></figure><p><a href="https://github.com/spiiin/dascript_trivial_examples/blob/main/max_value_from_1s/max_value_from_1s.das" target="_blank" rel="noopener">https://github.com/spiiin/dascript_trivial_examples/blob/main/max_value_from_1s/max_value_from_1s.das</a></p><p>Тоже без заморочек, в лоб.</p><p>В продакшен-варианте, если нужно действительно быстро, решение прокидывается в C++, где задействуются всевозможные интринсики компилятора для того, чтобы получать кол-во битов так, как умеет процессор, или другие трюки для минимизации количества инструкций (развернуть циклы, и наложить кучу масок — <a href="https://en.wikipedia.org/wiki/Hamming_weight" target="_blank" rel="noopener">Hamming weight</a>).</p><h2 id="Вывести-список-всех-самых-длинных-путей-в-дереве"><a href="#Вывести-список-всех-самых-длинных-путей-в-дереве" class="headerlink" title="Вывести список всех самых длинных путей в дереве"></a>Вывести список всех самых длинных путей в дереве</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">require daslib/functional</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span></span></span><br><span class="line"><span class="class">    <span class="title">data</span> :</span> <span class="keyword">int</span></span><br><span class="line">    left, right : Tree?</span><br><span class="line"></span><br><span class="line">var tree = <span class="keyword">new</span> [[ Tree data = <span class="number">5</span>,</span><br><span class="line">    left = <span class="keyword">new</span> [[Tree data = <span class="number">1</span>, </span><br><span class="line">        right = <span class="keyword">new</span> [[Tree data = <span class="number">2</span>]]</span><br><span class="line">    ]],</span><br><span class="line">    right = <span class="keyword">new</span> [[Tree data = <span class="number">7</span>,</span><br><span class="line">        right = <span class="keyword">new</span> [[Tree data = <span class="number">10</span>]]</span><br><span class="line">    ]]</span><br><span class="line">]]</span><br><span class="line"></span><br><span class="line"><span class="comment">//<span class="doctag">TODO:</span> optimize</span></span><br><span class="line">def clone_array(a: <span class="built_in">array</span>&lt;<span class="keyword">int</span>&gt;; newData:<span class="keyword">int</span>)</span><br><span class="line">    unsafe</span><br><span class="line">        var newArr &lt;- to_array(each(a))</span><br><span class="line">        newArr |&gt; push &lt;| newData</span><br><span class="line">        <span class="keyword">return</span> &lt;- newArr</span><br><span class="line"></span><br><span class="line">def each_element(var tree:Tree?; path: <span class="built_in">array</span>&lt;<span class="keyword">int</span>&gt;; depth:<span class="keyword">int</span>; blk:lambda&lt;(what: <span class="keyword">int</span>; path: <span class="built_in">array</span>&lt;<span class="keyword">int</span>&gt;; depth: <span class="keyword">int</span>):<span class="keyword">void</span>&gt;)</span><br><span class="line">    <span class="keyword">if</span> tree.left != null</span><br><span class="line">        each_element(tree.left, clone_array(path, tree.data), depth+<span class="number">1</span>, blk)</span><br><span class="line">    invoke(blk, tree.data, path, depth)</span><br><span class="line">    <span class="keyword">if</span> tree.right != null</span><br><span class="line">        each_element(tree.right, clone_array(path, tree.data), depth+<span class="number">1</span>, blk)</span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main</span><br><span class="line">    let startPath: <span class="built_in">array</span>&lt;<span class="keyword">int</span>&gt;</span><br><span class="line">    var globalResult : table&lt;<span class="keyword">int</span>; <span class="built_in">array</span>&lt;<span class="built_in">array</span>&lt;<span class="keyword">int</span>&gt;&gt;&gt;</span><br><span class="line">    unsafe</span><br><span class="line">        tree |&gt; each_element(startPath, <span class="number">0</span>) &lt;| @[[&amp;globalResult]](value: <span class="keyword">int</span>; path: <span class="built_in">array</span>&lt;<span class="keyword">int</span>&gt;; depth: <span class="keyword">int</span>)</span><br><span class="line">            globalResult[depth] |&gt; push_clone &lt;| clone_array(path, value)</span><br><span class="line">    <span class="comment">//find max depth</span></span><br><span class="line">    let maxDepth = reduce(keys(globalResult)) &lt;| $(left, right : <span class="keyword">int</span>)</span><br><span class="line">        <span class="keyword">return</span> left &gt; right ? left : right</span><br><span class="line">    <span class="comment">//print all pathes</span></span><br><span class="line">    print(<span class="string">"All pathes with longest depth:\n"</span>)</span><br><span class="line">    <span class="keyword">for</span> path in globalResult[maxDepth]</span><br><span class="line">        print(<span class="string">"&#123;path&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//All pathes with longest depth:</span></span><br><span class="line"><span class="comment">//[[ 5; 1; 2]]</span></span><br><span class="line"><span class="comment">//[[ 5; 7; 10]]</span></span><br></pre></td></tr></table></figure><p><a href="https://github.com/spiiin/dascript_trivial_examples/blob/main/all_pathes_max_depth/all_pathes_max_depth.das" target="_blank" rel="noopener">https://github.com/spiiin/dascript_trivial_examples/blob/main/all_pathes_max_depth/all_pathes_max_depth.das</a></p><p>Туповатое решение, с кучей лишних копирований путей.</p><p>Можно оптимайзить. Либо по памяти, разделив обход на 2 — сначала найти максимальную глубину, затем собрать только самые длинные пути. Либо в один проход, но сохраняя не полные копии путей, а альтернативное дерево с записью глубины каждой ветви рядом с указателем на оригинальные ноды left и right, по которому можно будет восстановить пути + обновляя максимальное значение глубины каждую итерацию.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Решение нескольких алгоритмических задачек на &lt;code&gt;daScript&lt;/code&gt;.&lt;br&gt;
    
    </summary>
    
    
    
      <category term="dascript" scheme="http://spiiin.github.io/tags/dascript/"/>
    
  </entry>
  
  <entry>
    <title>Устройство интерпретаторов lua-jit и daScript</title>
    <link href="http://spiiin.github.io/blog/2115627465/"/>
    <id>http://spiiin.github.io/blog/2115627465/</id>
    <published>2022-10-14T09:37:34.000Z</published>
    <updated>2022-11-11T13:45:00.037Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Устройство виртуальных машин для самых быстрых скриптовых языков — <a href="https://luajit.org/" target="_blank" rel="noopener">lua-jit</a> и <a href="https://dascript.org/" target="_blank" rel="noopener">daScript</a>.<br>Более развёрнутое продолжение беглой заметки <a href="/blog/1067581840/" title="daScript - скорость">daScript - скорость</a></p><a id="more"></a><h2 id="Lua"><a href="#Lua" class="headerlink" title="Lua"></a>Lua</h2><p>По <a href="https://github.com/r-lyeh-archived/scriptorium" target="_blank" rel="noopener">бенчмаркам языков</a> <code>lua</code> находится высоко даже в режиме интерпретации.</p><p>Первые стадии трансформации текста скрипта — лексический и синтаксический анализ. Текст разбивается на отдельные лексемы/токены, которые затем собираются парсером во что-то, что можно интерпретировать. Чаще всего это или поток последовательных инструкций (байт код для интерпретатора) в случае с <code>lua</code>, или AST(дерево, которое будет обходить интерпретатор) в случае с <code>daScript</code>.</p><p>Я не буду заострять внимание на отличиях типов интерпретаторов, детально можно прочитать про это в книге <a href="http://craftinginterpreters.com/" target="_blank" rel="noopener">Crafting Interpreters</a>, с примерами интерпретаторов обоих типов (или даже более <a href="https://gameprogrammingpatterns.com/bytecode.html" target="_blank" rel="noopener">сжато</a>). Интереснее следующий шаг — посмотреть почему именно эти интерпретаторы быстрее других.</p><p>“Традиционный” подход к дизайну языков с байт-кодом — динамическая типизация, управление памятью с помощью подсчёта ссылок/garbage collector, небольшой набор базовых типов (примитивы + строки + массивы + функции/замыкания + таблицы, опционально - итераторы, корутины, исключения). Из таблиц (пары ключ-значения) можно построить объекты и “собрать” классы — некоторые ключи таблицы делаем зарезервированными, вызывая их для создания/удаления объектов, ссылки на родительскую таблицу, перегрузки операторов и т.п.</p><p>Возможные оптимизации:</p><ul><li>Так как чаще всего данные группируются в объекты (представленные таблицами) — то очень важна быстрая реализация этих хеш-таблиц, в чём lua традиционна считается хорошей.</li><li><a href="http://craftinginterpreters.com/optimization.html#nan-boxing" target="_blank" rel="noopener">Nan-tagging</a> — распространённая паковка базовых типов языка виртуальной машины в тип <code>double</code>. Возникает отчасти из желания хранить примитивные типы в той же форме, что и сложные — в динамически типизированном языке нужно где-то сохранить в том числе и тип аргумента, чтобы знать, как его интерпретировать, и при этом не хочется иметь оверхед для примитивных типов. </li></ul><p>Отчасти из этой оптимизаций возникает ограничение на количество базовых типов языка — с точки зрения скриптового языка два класса будут иметь разные типы, но для интерпретатора виртуальной машины они оба будут представлены типом “таблица”, и отличаться только значением ключа “название класса”. Также любой вызов метода означает поиск его в таблице. Ещё один минус — требование “раскодировать” аргументы из запакованной формы при взаимодействии с нативным кодом, из-за чего замедляется передача управления в хост язык и обратно. Т.е. нельзя оптимизировать код, просто переносом мелких функций в хост-язык — необходимо переписывать сразу большие куски кода.</p><ul><li>Поиск частых паттернов в инструкциях. <a href="http://craftinginterpreters.com/methods-and-initializers.html#optimized-invocations" target="_blank" rel="noopener">Optimizing invocation</a> — пример слияния пары инструкций “получение метода класса + вызов метода”. В общем случае, метод может быть получен не для вызова, а для сохранения в переменную, но чаще всего вызывается напрямую, так что две инструкции, идущие подряд, можно “слить” в одну. В lua вроде не применяется, но повсеместно юзается в daScript, примеры приведу дальше. Оптимизация известна под названиями <code>Instruction fusion</code> или <code>Super-instructions</code>.</li></ul><h2 id="Tracing-JIT"><a href="#Tracing-JIT" class="headerlink" title="Tracing JIT"></a>Tracing JIT</h2><p>Основная сила lut-jit - just-in-time компиляция. Каждый раз, при вызовах функций и циклов (<code>thermal function/cycle</code>), интерпретатор подсчитывает количество таких вызовов, и таким образом, определяет “горячий” код. Алгоритм подсчёта (NLF region-selection) также умеет обнаруживать вложенные циклы и вызовы.</p><p>При достижении предельного количества вызовов, интерпретатор выполняет отмеченный участок кода с “трассированием”, то есть кроме выполнения инструкции дополнительно сохраняет её же в список инструкций — уже на другом байт-код языке (intermediate representation, <a href="http://webcache.googleusercontent.com/search?q=cache:U5V-zQuM-ikJ:wiki.luajit.org/SSA-IR-2.0&amp;cd=1&amp;hl=ru&amp;ct=clnk&amp;gl=am" target="_blank" rel="noopener">спек</a>).</p><p>После записи всех инструкций из IR генерируется машинный код, и следующий вызов этого участка кода уже приведёт к тому, чтобы будет вызвана нативная версия кода. Подмена способов вызова функции реализована с помощью патчинга оп-кодов байт-кода lua (call gates).</p><p>Генерация нативного машинного кода разрешена не на всех платформах/ОС (память для выполнения нативного кода защищена от записи), поэтому недоступна для части платформ. Также нативный код для различных архитектур отличается, поэтому добавление новой платформы может требовать написания отдельного генератора кода.</p><p><a href="http://lua-users.org/lists/lua-l/2009-11/msg00089.html" target="_blank" rel="noopener">Список особенностей</a> jit-компилятора lua:</p><ul><li>оптимизация IR-кода - сворачивание и выбрасывание неиспользуемых блоков</li><li>при возврате из нативной части кода в интерпретируемую, оптимизиуется восстановление состояния виртуальной машины, сохраняются “дифы” между состояниями</li><li>типизация аргументов, при трассировании кода записываются реальные типы переменных</li></ul><p>Тривиальный пример, с неизвестными типами аргументов:<br><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(t, k)</span></span></span><br><span class="line">    <span class="keyword">return</span> t[k]</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><br>Может быть интерпретирован различными способами - t может быть таблицей или любым типом, у которого установлена метатаблица, k - числом, строкой или любым типом, и даже [] - метаметодом. В принципе, этот код может со всеми возможными комбинациями задействовать половину ветвей интерпретации ядра lua. Но если трассирующий компилятор запишет реально используемые типы, то он может сгенерировать быстрый нативный код, к примеру индексации массива (сгенерировав предварительно код проверки типов аргументов). Это даёт ускорение ~3 раза, по <a href="https://staff.fnwi.uva.nl/h.vandermeer/docs/lua/luajit/luajit_intro.html#:~:text=As%20the%20name%20says%20LuaJIT,are%20not%20compiled%20at%20all." target="_blank" rel="noopener">замерам</a> авторов.</p><h2 id="daScript"><a href="#daScript" class="headerlink" title="daScript"></a>daScript</h2><p>daScript серьёзно отличается от “традиционных” скриптовых языков.</p><p>В первую очередь — на выходе синтаксического анализатора получается на байт-код, а абстрактное синтаксическое дерево, причём типизированное.</p><p>Типизация немного усложняет изучение языка, но позволяет избавиться от огромного количества ошибок типов. Если рассмотреть синтетический пример на lua, то обнаружить фактические типы аргменутов t и k может быть сложно в цепочке вызовов, а проверить их корректность можно только в рантайме. Представьте, что <code>foo</code> ожидает в качестве t список из строк и выбирает из него первый элемент (допустим, сортированный список допустимых фраз персонажа игры). Список составляется и сортируется динамически. На каком-то этапе в ходе рефактора программист добавляет дополнительную функцию в цепочку вызовов, которая проверяет граничное условие (не то, чтобы это хороший код или пример, но подобную ошибку с подменой списка строкой встречал много раз):</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkIfGameOver</span><span class="params">(t, k)</span></span></span><br><span class="line">    <span class="keyword">if</span> life &lt;= <span class="number">0</span> <span class="keyword">then</span> </span><br><span class="line">        foo(<span class="string">"game over!"</span>, k) //вместо foo([<span class="string">"game over!"</span>], k)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        foo(t, k)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>Если условие редкое, и код кажется программисту слишком тривиальным, чтобы его проверить в рантайме, баг может остаться незамеченным для ревьюера, а то и для QA. В типизированном языке ошибка бы скорее всего обнаружилась компилятором.</p><p>Представление в виде AST, а не байт-кода, упрощает генерацию и анализ кода, например — с ним работают <a href="/blog/1547564887/" title="макросы">макросы</a>, а также упрощается написание тулзов, анализирующих код.</p><p>На уровне AST намного удобнее проводить оптимизации, в этот момент интерпретатор иметь достаточно много информации о коде. <code>daScript</code> позволяет изучить код на каждом шаге оптимизации. Простейший пример:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//log_optimization_passes - выводит результаты всех промежуточных стадий оптимизации AST</span></span><br><span class="line">options optimize=<span class="literal">true</span>, log_optimization_passes = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">def test(cond, a, b)</span><br><span class="line">    <span class="keyword">if</span> cond</span><br><span class="line">        <span class="keyword">return</span> a + b</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main()</span><br><span class="line">    print(<span class="string">"&#123;test(true, 2, 2)&#125;\n"</span>)</span><br></pre></td></tr></table></figure><p>После стадии <code>CONST_FOLDING</code> можно увидеть, что AST “свернулся” до:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;4&#125;\n"</span>)</span></span></span><br></pre></td></tr></table></figure></p><p>После оптимизаций <code>daScript</code> <strong>не интерпретирует AST</strong> и <strong>не генерирует</strong> байт-код. Вместо этого генерируется <a href="https://github.com/GaijinEntertainment/daScript/blob/master/src/ast/ast_simulate.cpp#L2912" target="_blank" rel="noopener">дерево симуляции</a>. На этом этапе также происходит оптимизация — AST ноды “отбрасывают” ненужную для симуляции информацию, например, информацию о типах (она больше не нужна, типы известны и статически проверены на уровне AST), и умеют генерировать более оптимизированные частные случаи (<a href="simulate">симуляция</a> simulate-ноды из ast-ноды ifThenElse, ветка <em>//good old if</em> - дефолтный вариант, остальные — оптимизированные).</p><p>Базовый класс нод simulate-ноды<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SimNode</span> &#123;</span></span><br><span class="line">    SimNode ( <span class="keyword">const</span> LineInfo &amp; at ) : debugInfo(at) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> SimNode * <span class="title">copyNode</span> <span class="params">( Context &amp; context, NodeAllocator * code )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> vec4f <span class="title">eval</span> <span class="params">( Context &amp; )</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> SimNode * <span class="title">visit</span> <span class="params">( SimVisitor &amp; vis )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> *      <span class="title">evalPtr</span> <span class="params">( Context &amp; context )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span>        <span class="title">evalBool</span> <span class="params">( Context &amp; context )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span>       <span class="title">evalFloat</span> <span class="params">( Context &amp; context )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span>      <span class="title">evalDouble</span> <span class="params">( Context &amp; context )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int32_t</span>     <span class="title">evalInt</span> <span class="params">( Context &amp; context )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">uint32_t</span>    <span class="title">evalUInt</span> <span class="params">( Context &amp; context )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int64_t</span>     <span class="title">evalInt64</span> <span class="params">( Context &amp; context )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">uint64_t</span>    <span class="title">evalUInt64</span> <span class="params">( Context &amp; context )</span></span>;</span><br><span class="line">    LineInfo debugInfo;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">rtti_node_isSourceBase</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>;  &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">rtti_node_isBlock</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">rtti_node_isInstrument</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">rtti_node_isInstrumentFunction</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">rtti_node_isJit</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~SimNode() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>У Sim-ноды есть универсальная функция <code>eval</code>, и частные случаи <code>evalXXX</code> для того, чтобы не делать лишние касты. <code>vec4f</code> в данном случае можно рассматривать не только как конкретный тип (очень полезный именно в геймдеве), но и как 128-битный “передатчик” данных, который в случае необходимости кастится в другим типам с помощью библиотеки <a href="https://github.com/GaijinEntertainment/vecmath" target="_blank" rel="noopener">vecmath</a>, в которой реализован быстрый каст для различных архитектур (HAL) вызовом интринсик-функций.</p><p>Сравнение дерева симуляции и байт-код представления:</p><ul><li>Ноды лежат в памяти плоско в линейном аллокаторе, как и байт-код</li><li>Обход дерева не требует интерпретации. Т.е. 1) не нужно сопоставлять байт-коду функцию, и 2) связь между нодами осуществляется по указателям, а не байт-кодом команд передачи управления/через регистры/стек</li><li>Типы данных хранятся также, как и в нативном коде, нет кодирования/декодирования аргументов, результатов</li><li>Нет ограничения на количество типов нод, когда bind-ится функция, то создаётся кастомная нода, за счёт чего вызов функций быстрый</li></ul><p>С таким дизайном возможны оптимизации добавлением частных случаев новых типов нод:</p><ul><li>Упомянутые выше уникальные типы нод для вызова функции</li><li>Специализированные версии нод для отдельных типов для чуть более быстрой математики, конкретных специализаций контейнеров (<a href="https://github.com/GaijinEntertainment/daScript/blob/master/include/daScript/simulate/sim_policy.h" target="_blank" rel="noopener">SimPolicy</a>)</li><li>Из-за того, что можно не экономить на типах нод, можно в полную силу использовать fusion нескольких нод в одну специализированную</li></ul><p>Цена большого количества специализированных версий нод — увеличение размера бинарника приложения, поэтому уровень “сплава” нескольких нод в одну регулируется через дефайн <code>DAS_FUSION</code>. 0 - не включать fusion-движок, 1 - “нормальный” уровень слияния, 2 - максимальное количество специализированных нод.</p><p>Пример работы fusion-движка:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">options log_nodes=<span class="literal">true</span>, optimize=<span class="literal">false</span></span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>] <span class="comment">//оставляем, чтобы оптимизатор не выбросил функцию</span></span><br><span class="line">def test(a, b)</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br></pre></td></tr></table></figure></p><p>Если изменить значение <code>optimize=true</code>, можно увидеть разницу в количестве нод:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; неоптимизированная версия, 6 нод</span><br><span class="line">(Return (Add_TT&lt;int&gt; (Ref2Value_TT&lt;int&gt; (GetArgumentRef #0)) (Ref2Value_TT&lt;int&gt; (GetArgumentRef #1))))</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; оптимизированная версия, 2 ноды</span><br><span class="line">(Return (AddArgArg_TT&lt;int&gt; #0 #1))</span><br></pre></td></tr></table></figure><p>Резюмируя — на скорость в режиме симуляции тут влияют:</p><ul><li>линейное расположение в памяти</li><li>отсутствие оверхеда интерпретации байт-кода</li><li>быстрый интероп с хост-языком - отсутствие конвертации аргументов, быстрые вызовы функций</li><li>уменьшение количества нод - проходы оптимизации, специализированные и объединённые ноды</li></ul><p>В сумме это позволяет в режиме интерпретации (без jit, и aot) обогнать самые быстрые интерпретаторы байт-кода с jit-компиляцией.</p><p>Опционально ещё:</p><ul><li>возможность с помощью макросов обработать AST и изменить семантику объявлений для более оптимального расположения в памяти</li><li>переопределить для своих типов кастомный <code>simulate</code> для генерации кастомного быстрого кода для их обработки</li></ul><h2 id="daJIT"><a href="#daJIT" class="headerlink" title="daJIT"></a>daJIT</h2><p>Кроме режима интерпретации, daScript тоже немного умеет jit-титься:<br><a href="https://github.com/borisbat/dasXbyak" target="_blank" rel="noopener">dasXbyak</a> - для x84/x64 (приостановлен, можно допилить при наличии энтузиазма)<br><a href="https://github.com/borisbat/dasLLVM" target="_blank" rel="noopener">dasLLVM</a> - для всего что может llvm (пока на начальной стадии, перспективнее)<br>jit-компиляция разрешена на PC/Unix/Mac/Web, запрещена на телефонах и консолях (везде, где разрешен запуск только подписанного кода)</p><p>А также хорошо AoT транспилироваться в C++-код. Перегонка “руками”:<br><code>daScript.exe -aot test.das test.das.cpp</code><br>или на уровне <a href="https://github.com/GaijinEntertainment/daScript/blob/master/examples/tutorial/CMakeLists.txt#L36" target="_blank" rel="noopener">cmake сборки</a>, настройки AoT кастомизируется на уровне отдельных модулей, функций и типов.<br><a href="/blog/1160489034/" title="daScript in imaginery world">daScript in imaginery world</a> - немного про прирост скорости от AoT-прекомпиляции. В отличие от jit, этим можно воспользоваться на всех платформах.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Устройство виртуальных машин для самых быстрых скриптовых языков — &lt;a href=&quot;https://luajit.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;lua-jit&lt;/a&gt; и &lt;a href=&quot;https://dascript.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;daScript&lt;/a&gt;.&lt;br&gt;Более развёрнутое продолжение беглой заметки &lt;a href=&quot;/blog/1067581840/&quot; title=&quot;daScript - скорость&quot;&gt;daScript - скорость&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="lua" scheme="http://spiiin.github.io/tags/lua/"/>
    
      <category term="dascript" scheme="http://spiiin.github.io/tags/dascript/"/>
    
      <category term="llvm" scheme="http://spiiin.github.io/tags/llvm/"/>
    
  </entry>
  
  <entry>
    <title>Важность простых языков</title>
    <link href="http://spiiin.github.io/blog/3121981810/"/>
    <id>http://spiiin.github.io/blog/3121981810/</id>
    <published>2022-10-09T16:52:06.000Z</published>
    <updated>2022-10-09T21:44:57.290Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Про важность использования простых языков в геймдеве и не только.</p><a id="more"></a><p><a href="https://kristoff.it/blog/why-go-and-not-rust/" target="_blank" rel="noopener">Why Go and not Rust?</a> - статья вообще про преимущества простого go перед более сложным rust в блоге про zig :) Но в ней есть развернутый ответ на вопрос “почему обычно в корпоративном мире качество кода оставляет желать лучшего. В мире геймдева (там где я видел, во всяком случае), ситуация такая же — длительные в разработке проекты с большим количеством кода и широкой предметной областью, в которой эксперты предметной области слабо разбираются в технологии, а программисты — в особенностях предметной области, поэтому необходим <em>процесс</em>.</p><h2 id="Процесс"><a href="#Процесс" class="headerlink" title="Процесс"></a>Процесс</h2><p>Разработка больших систем — это всегда про масштаб. Понятие масштаба касается не количества данных или пользователей, а количества фич (scope) и процесса разработки. Опыт масштабирования как его понимают программисты часто неприменим к такому типу сложности, нетехнические трудности перевешивают технические.</p><p>Чтобы разобраться с масштабированием, менеджеры пытаются настроить процесс разработки, и привлекают экспертов и аналитиков, которые “знают как правильно” побороть сложности масштабирования.</p><p>Ссылки про “процессы” в геймдеве:<br><a href="https://sim0nsays.livejournal.com/38168.html" target="_blank" rel="noopener">Древние логи из IRC</a>, про то, как в геймдеве в принципе приходили к тому, чтобы разработка стала хоть как-то предсказуемее (если не ошибаюсь, обсуждается <code>Midway</code>).<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[09:17] &lt;look4awhile&gt; когда технические сложности - это всего-лишь технические сложности</span><br><span class="line">[09:17] &lt;look4awhile&gt; а оценивается работа продюсера</span><br><span class="line">[09:18] &lt;look4awhile&gt; наглядный пример, из последнего - дум-3.</span><br></pre></td></tr></table></figure><br>При этом забавно, что описанный там подход, начало 2000х — как будто попытка адаптировать к геймдеву методы, разработанные еще в 80х.</p><p><a href="/blog/1687824628/" title="Паттерны организации разработки уровней игр">Паттерны организации разработки уровней игр</a> — мои попытки обнаружить интересные идеи среди принятых сейчас Agile/Lean подходов.</p><p>Из этого взаимодействия бизнеса/управления/команды возникает несколько хорошо известных “причуд” корпоративной разработки.</p><h2 id="Джуниоры"><a href="#Джуниоры" class="headerlink" title="Джуниоры"></a>Джуниоры</h2><p>В командах всегда много джуниоров, которые учатся программировать на работе. И большинству из них не повезло найти работу, где они действительно могут научиться полезным практикам. Код больших систем далёк от того, что они видели в универе, или в своих в своих пет-проджектах.</p><p>Бывает, что джуниор вынужден реализовывать фичу, вообще впервые сталкиваясь с какой-либо технологией. Примеры из мобильной разработки — интеграция sdk с использованием нативных языков (java/kotlin/obj c/swift) в C++ код, программирование на gpu, скриптовые языки.</p><h2 id="Код-быстро-становится-запутанным"><a href="#Код-быстро-становится-запутанным" class="headerlink" title="Код быстро становится запутанным"></a>Код быстро становится запутанным</h2><p>Причин множество.</p><p>Для создания сложных систем требуется время, за которое приходят и уходят разработчики или целые команды. Постоянно рефакторить или переписывать код невозможно, так как время на разработку сильно ограниченно, так что разные части системы всегда будут находиться в очень разном состоянии по качеству и стилю кода.</p><p>Команды, работающие независимо, неизбежно будут создавать избыточный код.</p><p>Из-за сжатых сроков также кривой код попадает в релиз. “Когда-нибудь перепишем”.</p><p>С течением времени предметная область меняется, что неизбежно делает недействительными старые предположения и, следовательно, приводит к утечке абстракций. Чем сложнее абстракция, тем выше риск того, что она станет проблемой, когда гейм-дизайнер вернется с серьезным запросом на изменение. Проект никогда не может быть достаточно гибким, чтобы учесть все возможные пожелания и фантазии. Бизнес может прийти с запросами вроде “ситуация на рынке изменилась, меняем жанр/платформу/удваиваем количество фич”.</p><h2 id="Пайплайн-устаревший-жуткий"><a href="#Пайплайн-устаревший-жуткий" class="headerlink" title="Пайплайн устаревший/жуткий"></a>Пайплайн устаревший/жуткий</h2><p>Большое количество старого кода привязывает к определенным подходам, серьёзные технологические решения по улучшению принимать сложно, и не все менеджеры готовы вообще на это идти. Многие избегают рисков, результате чего происходят попытки копирования действий успешных конкурентов (или того, что, по утверджениям аналитиков, делают успешные конкуренты).</p><h2 id="Что-с-этим-делать"><a href="#Что-с-этим-делать" class="headerlink" title="Что с этим делать"></a>Что с этим делать</h2><p>Что может предоставить язык программирования, чтобы бороться с перечисленными проблемами?</p><p>Краткий ответ — быть максимально <strong>простым</strong> (только не примитивным, а именно незапутанным), <strong>гибким</strong> (не настраиваемым на все случаи жизни, а готовым к быстрым изменениям), и позволяющим мгновенно <strong>проверять гипотезы</strong>. </p><p>Именно возможность писать код так, чтобы он соответствовал этим критериям стоит использовать при сравнении языков между собой — они влияют на конечную продуктивность команды (продуктивность это не просто скорость, с которой можно делать фичи, а способность сделать продукт, который будет приносить деньги). Язык стимулирует писать код определенным способом — и этот способ может быть общепринятым для одного языка, но контр-интуитивным для другого. </p><p>Идти “против языка” при этом достаточно сложно в перспективе. Как в рамках одного проекта, так и распространяя паттерны работы — создание библиотек/тулзов/общепринятных подходов к разработке. Несколько случайных примеров не прижившихся или экспериментальных идей на C++ из русского геймдева (это не какие-то особенно продвинутые идеи, просто как пример подхода “против языка”, отчасти не прижившихся из-за необычности, отчасти из-за того, что это “не касается” языка, не выразимо на языке == будет отброшено, программист навряд ли наткнётся на такие подхода, если будет искать “как реализовать XXX”; старые ссылки выбраны отчасти потому, что я видел развитие каких-то из этих идей в движках, отчасти потому что, в современной геймдев культуре менее принято делиться интересными подходами, во всяком случае, если мониторить конференции и доклады, отчасти потому, что сохранились в коллекции ссылок):<br><a href="https://gamedev.ru/code/articles/?id=4234" target="_blank" rel="noopener">Compile-time vs run-time: назад в будущее</a> — генерация кода из данных в “build-time”<br><a href="https://sim0nsays.livejournal.com/27342.html" target="_blank" rel="noopener">Component-oriented design на консолях, лобзиком по шаблонам</a> — распиливание классов на компоненты на шаблонах<br><a href="https://plakhov.livejournal.com/201698.html" target="_blank" rel="noopener">Data structures baking</a> — чтение структур языка с диска без кода инициализации (еще <a href="https://probablydance.com/2015/12/19/quickly-loading-things-from-disk/" target="_blank" rel="noopener">пара</a> <a href="https://www.gamedeveloper.com/programming/delicious-data-baking" target="_blank" rel="noopener">ссылок</a>)<br><a href="https://plakhov.livejournal.com/101443.html" target="_blank" rel="noopener">Дзен-3, скрипт</a> — триггеры с минимальным функционалом вместо скриптов, создание минимального интерпретатора dsl на стороне игры. Хех, ну и почти <a href="https://twitter.com/YarKravtsov/status/1566004371044827137" target="_blank" rel="noopener">блюпринты</a> в движке SkyForge</p><p>При этом, почти любые современные языки дают возможность писать код, используя различныме парадигмы, так что команда должна уметь использовать язык именно так, чтобы эти свойства реально проявлялись.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Про важность использования простых языков в геймдеве и не только.&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="dev_method" scheme="http://spiiin.github.io/tags/dev-method/"/>
    
  </entry>
  
  <entry>
    <title>LLVM - обзор</title>
    <link href="http://spiiin.github.io/blog/315556844/"/>
    <id>http://spiiin.github.io/blog/315556844/</id>
    <published>2022-10-09T12:41:32.000Z</published>
    <updated>2022-11-11T13:44:20.326Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Попытка очень бегло пройтись по тому, что можно найти в LLVM.<br><a id="more"></a></p><h2 id="Инфраструктура-для-авторов-языков-программирования"><a href="#Инфраструктура-для-авторов-языков-программирования" class="headerlink" title="Инфраструктура для авторов языков программирования"></a>Инфраструктура для авторов языков программирования</h2><p>LLVM - это огромный проект. Чаще всего, когда говорят о нём - имеют ввиду возможность написать только фронтэнд для какого-нибудь языка - из языка в биткод llvm. Дальше автоматом можно получить следующие стадии трансформации: из <code>ir llvm -&gt; оптимизации различные -&gt;mir под конкретные платформы -&gt; бинарный код под платформы</code>.</p><p>Биткод может быть представлен в 3х формах: текстовый псевдоассемблер, бинарный формат, и in-memory api, с помощью которого можно нагенерить всё с помощью кода, в том числе сделать jit-компилятор.</p><p>В теории, jit быстрее статической компиляции, потому что:</p><ul><li>может задействовать динамические данные о том, какой код “горячее” (статическому компилятору тоже можно передать эту инфу, полученную уже после запуска приложения, при повторной компиляции/линковке)</li><li>может инлайнить больше, чем статический - например, библиотечные функции, которые иначе нельзя</li><li>может подстроиться под особенностью архитектуры или ос</li></ul><p>Java vm, .net или js-двики чаще всего jit так или иначе делают, быстрые версии интерпретаторов тоже. Jit-компиляция большая отдельная тема.<br><a href="https://github.com/borisbat/dasLLVM" target="_blank" rel="noopener">dasLLVM</a> — пример jit-компиляции из <a href="https://spiiin.github.io/tags/dascript/">daScript</a> на LLVM, пока на начальной стадии.</p><p>Если хочется погрузиться в теорию компиляции, можно читать что-нибудь типа:</p><ul><li>Learn LLVM 12</li><li>Классическую “Компиляторы: принципы, технологии и инструменты”</li><li><a href="http://craftinginterpreters.com/" target="_blank" rel="noopener">Crafting Interpreters</a></li></ul><p>Последняя интересна тем, что нацелена на практику, от автора <code>Game Programming Patterns</code>, а также нескольких скриптовых языков: <a href="https://wren.io/" target="_blank" rel="noopener">wren</a>, <a href="https://magpie-lang.org/" target="_blank" rel="noopener">magpie</a>. В его блоге также много <a href="https://journal.stuffwithstuff.com/category/language/" target="_blank" rel="noopener">статей</a> об устройстве языков программирования. В третьей части много продвинутого материала об оптимизации вызовов функций, замыканий и методам ускорения интерпретатора байт кода.</p><p>Несколько нестандартных применений:</p><ul><li><a href="https://andrewkelley.me/post/jamulator.html" target="_blank" rel="noopener">Statically Recompiling NES Games into Native Executables with LLVM and Go</a> - попытка перекомпилировать байт-код для NES в LLVM-биткод, без эмуляции от автора языка <code>Zig</code>, не очень успешная, так как в NES ассемблере очень много трюков, которые требуют реальной эмуляции особенностей железа (синхронизация с процессором, прыжки в середину инструкции, самомодифицирующийся код).</li><li>“Компиляция данных” — создание микроязыков для того, чтобы добавить возможность “положить” в игровые ресурсы код.</li></ul><p><a href="https://www.youtube.com/watch?v=3QQuhL-dSys" target="_blank" rel="noopener">2019 LLVM Developers’ Meeting: J. Paquette &amp; F. Hahn “Getting Started With LLVM: Basics”</a> — доклад про IR LLVM<br><a href="https://llvm.org/docs/WritingAnLLVMPass.html" target="_blank" rel="noopener">Writing an LLVM Pass</a> — как написать свой проход LLVM</p><h2 id="Clang-фронтэнд-компилятор-C"><a href="#Clang-фронтэнд-компилятор-C" class="headerlink" title="Clang - фронтэнд компилятор C++"></a>Clang - фронтэнд компилятор C++</h2><p>Отдельный проект — фронтэнд для С++ (а также С и  Objective C/C++) - <code>clang</code>. Собственно, у него есть несколько ключей, чтобы получать промежуточные представления кода, но это тоже прикладным разработчикам не особо надо чаще всего. Один из вариантов его использования - написание своих проходов при компиляции. Cобирается плагин в dll/dylib/a и компилятору clang ключом передаётся, чтобы он дёргал функции-колбека из этого плагина при каждой компиляции кода.</p><p>Apple в xcode clang не совсем из стандартной репы собирала, поэтому он у них с такими плагинами не работает, но в принципе пересобрав самому из исходников можно и им под ios код генерить. Вот <a href="https://railsware.com/blog/creation-and-using-clang-plugin-with-xcode/" target="_blank" rel="noopener">“hello world”</a> с плагинами. Таким способом можно решать что-то типа “хочу, чтобы если в лямбду кто-то захватил this неявно, то компиляция крешилась с сообщением, потому что в половине случаев автор забыл проверить время жизни this и упадёт в рантайме” (или другие правила, обычно написанные кровью в code convention проекта, которые невозможно выразить семантикой C++).</p><p>Так редко кто делает, но вот примеры проектов с набором плагинов, дополнительно проверяющих код:<br><a href="https://github.com/LibreOffice/core/tree/master/compilerplugins/clang" target="_blank" rel="noopener">libreoffice</a><br><a href="https://chromium.googlesource.com/chromium/src.git/+/master/docs/clang.md#using-plugins" target="_blank" rel="noopener">chrome</a> + <a href="https://ehsanakhgari.org/blog/2015-12-07/c-static-analysis-using-clang/" target="_blank" rel="noopener">Статья</a><br><a href="https://hg.mozilla.org/mozilla-central/file/tip/build/clang-plugin/" target="_blank" rel="noopener">firefox</a></p><p>Более основательный туториал про то, как писать плагины, и что с их помощью можно делать<br><a href="https://github.com/banach-space/llvm-tutor" target="_blank" rel="noopener">https://github.com/banach-space/llvm-tutor</a></p><h2 id="API-для-работы-с-Clang"><a href="#API-для-работы-с-Clang" class="headerlink" title="API для работы с Clang"></a>API для работы с Clang</h2><p>Особенность компилятора Clang — он предоставляет несколько API для того, чтобы можно было получать информацию о коде программы.</p><p>К примеру, можно пропарсить заголовочный файлы и автоматом нагенерить привязок к другим языкам. Из особенностей - не очень быстро работает (поэтому некоторые предпочитают велосипедить свои парсеры, передавая мета-информацию комментариями), и не очень хорошо работает с сложным шаблонным кодом. Но в целом можно целиком какую-нибудь либу привязать им к другому языку с небольшим количеством ручной работы.</p><p>Один из интерфейсов - <code>libclang</code>, библиотека на C++, к которой есть привязки на других языках.</p><p>Примеры использования <strong><code>генерации привязок</code></strong>:<br><a href="/blog/4090909622/" title="daScript: C++ auto-bindings, msgpack">daScript: C++ auto-bindings, msgpack</a> — генерация из daScript привязок к <code>msgpack</code><br><a href="/blog/500729544/" title="daScript: C++ auto-bindings, assimp">daScript: C++ auto-bindings, assimp</a> — генерация из daScript привязок к <code>assimp</code>, без написания кода (почти)<br>(с помощью <a href="https://github.com/GaijinEntertainment/daScript/tree/master/modules/dasClangBind" target="_blank" rel="noopener">dasClangBind</a>)<br><a href="https://floooh.github.io/2020/08/23/sokol-bindgen.html" target="_blank" rel="noopener">Automatic Language Bindings</a> — генерация из Python привязок к <code>solol</code> для различных языков (zig/nim/odin)</p><p><strong><code>Интерактивное получение данных из кода</code></strong><br><a href="https://root.cern/cling/" target="_blank" rel="noopener">Cling</a> - интерактивная комплиляция С++ кода, для использования с инструментами типа <code>Jupyter</code><br><a href="https://cppyy.readthedocs.io/en/latest/examples.html" target="_blank" rel="noopener">cppyy</a> - привязка cling к python, работает в том числе и под windows</p><p><strong><code>Написание тулзов для IDE</code></strong><br><a href="https://github.com/def-/ycmd" target="_blank" rel="noopener">ycmd</a> - сервер автодополнения кода для различных IDE<br><a href="https://marketplace.visualstudio.com/items?itemName=RamonViladomat.StructLayout" target="_blank" rel="noopener">StructLayout</a> - расширение для VS code, которое может показать то, как компилятор будет размещать структуру в памяти (надо помнить, что libclang, который использует это расширение, должен быть той же версии, что и сам компилятор, который будет генерировать код).</p><p>Можно также решать всякие задачи вроде “отсортировать функции по количеству байт и напечатать 10 самых больших”.</p><p><strong><code>Туториалы, как научиться пользоваться</code></strong><br><a href="https://jonasdevlieghere.com/understanding-the-clang-ast/" target="_blank" rel="noopener">Understanding the Clang AST</a> - 3 API для работы с AST в clang<br><a href="https://clang.llvm.org/docs/IntroductionToTheClangAST.html" target="_blank" rel="noopener">Introduction to the Clang AST</a> - ссылки на диаграммы классов AST, во что трансформируется код на C++<br><a href="https://clang.llvm.org/docs/RAVFrontendAction.html" target="_blank" rel="noopener">How to write RecursiveASTVisitor based ASTFrontendActions</a> - пример того, как сделать свой визитор для AST<br><a href="https://clang.llvm.org/docs/LibASTMatchersTutorial.html" target="_blank" rel="noopener">Tutorial for building tools using LibTooling and LibASTMatchers</a> - использование других интерфейсов для написания визиторов<br><a href="https://www.youtube.com/watch?v=VqCkCDFLSsc" target="_blank" rel="noopener">The Clang AST - a Tutorial</a> - доклад всё про то же<br><a href="http://www.goldsborough.me/c++/clang/llvm/tools/2017/02/24/00-00-06-emitting_diagnostics_and_fixithints_in_clang_tools/" target="_blank" rel="noopener">Emitting Diagnostics in Clang</a> — вывод своих сообщений об ошибках</p><p>В каком-то смысле, интерфейс для того, чтобы иметь доступ к AST языка, необходим из-за того, что этого не умеет сам C++ - шаблоны умеют заставить компилятор произвести эффекты, но не имеют доступа к самому коду. В языках вроде <code>daScript</code> аналогичную плагинам компилятора работы могут выполнять макросы.<br><a href="https://github.com/GaijinEntertainment/daScript/blob/master/daslib/jobque_boost.das#L142" target="_blank" rel="noopener">Пример</a> макроса в daScript, применяемого к замыканию и выполняющего дополнительную работу, если в замыкание передаются примитивы синхронизации <code>Channel</code> или <code>Job</code>.<br><a href="/blog/1547564887/" title="daScript macro">daScript macro</a> — пример генерации AST daScript из кода<br><a href="/blog/4046309382/" title="daScript macro - 2">daScript macro - 2</a> — пример работы с DSL, упрощающим написание AST</p><p>Также, для Clang, чтобы упростить работу с C++ AST, существует DSL для составления запросов - <strong><code>clang query</code></strong><br><a href="https://www.youtube.com/watch?v=yqi8U8Q0h2g" target="_blank" rel="noopener">2019 EuroLLVM Developers’ Meeting: S. Kelly “The Future of AST Matcher-based Refactoring</a> - использование запросов clang query для визуальной работы с кодом, расширение godbolt + интерфейс к qt контролам<br><a href="https://www.youtube.com/watch?v=38tYYrnfNrs" target="_blank" rel="noopener">Extending clang-tidy in the Present and in the Future - Stephen Kelly</a> - и для модификации кода/рефакторинга</p><p>Ещё один способ использования — глубже изучить, как устроена какая-либо абстракция в языке<br><a href="https://www.youtube.com/watch?v=8C8NnE1Dg4A" target="_blank" rel="noopener">CppCon 2016: Gor Nishanov “C++ Coroutines: Under the covers”</a> — реализация корутин в новом стандарте C++<br><a href="https://llvm.org/docs/LangRef.html" target="_blank" rel="noopener">LLVM Language Reference Manual</a> - справка по псевдо-ассемблеру LLVM</p><h2 id="Исходный-код-и-архитектура-LLVM"><a href="#Исходный-код-и-архитектура-LLVM" class="headerlink" title="Исходный код и архитектура LLVM"></a>Исходный код и архитектура LLVM</h2><p><a href="http://rus-linux.net/MyLDP/BOOKS/Architecture-Open-Source-Applications/Vol-1/llvm.html" target="_blank" rel="noopener">Глава в книге “Архитектура приложений с открытым исходным кодом”</a><br><a href="https://blog.regehr.org/archives/1453" target="_blank" rel="noopener">A Tourist’s Guide to the LLVM Source Code</a> - обзор исходников<br><a href="https://llvm.org/docs/ProgrammersManual.html" target="_blank" rel="noopener">Обзор используемых структур данных</a> + <a href="https://llvm.org/devmtg/2014-04/PDFs/LightningTalks/data_structure_llvm.pdf" target="_blank" rel="noopener">Ещё один</a></p><h2 id="LLDB"><a href="#LLDB" class="headerlink" title="LLDB"></a>LLDB</h2><p>Отладчик, также использующий инфраструктуру llvm. Одна из интересных возможностей — наличие <a href="https://lldb.llvm.org/python_reference/" target="_blank" rel="noopener">python api</a>.</p><p>Пример использования API:<br><a href="/blog/1170009669/" title="Расположение объектов C++ в памяти. Часть 2">Расположение объектов C++ в памяти. Часть 2</a> — рекурсивный обход структур, для запроса из отладчика выравнивания их в памяти, с отображением “дырок”</p><h2 id="Общие-ссылки"><a href="#Общие-ссылки" class="headerlink" title="Общие ссылки"></a>Общие ссылки</h2><p><a href="https://llvm.org/devmtg/" target="_blank" rel="noopener">https://llvm.org/devmtg/</a> + <a href="https://www.youtube.com/c/LLVMPROJ/playlists" target="_blank" rel="noopener">https://www.youtube.com/c/LLVMPROJ/playlists</a><br><a href="https://blog.llvm.org/" target="_blank" rel="noopener">https://blog.llvm.org/</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Попытка очень бегло пройтись по тому, что можно найти в LLVM.&lt;br&gt;
    
    </summary>
    
    
    
      <category term="dev" scheme="http://spiiin.github.io/tags/dev/"/>
    
      <category term="dascript" scheme="http://spiiin.github.io/tags/dascript/"/>
    
      <category term="cpp" scheme="http://spiiin.github.io/tags/cpp/"/>
    
      <category term="llvm" scheme="http://spiiin.github.io/tags/llvm/"/>
    
  </entry>
  
  <entry>
    <title>Git. ссылки</title>
    <link href="http://spiiin.github.io/blog/1186660544/"/>
    <id>http://spiiin.github.io/blog/1186660544/</id>
    <published>2022-09-29T19:04:35.000Z</published>
    <updated>2022-09-29T19:10:22.235Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Различные доки по git<br><a id="more"></a><br>  <a href="https://fabiensanglard.net/git_code_review/index.php" target="_blank" rel="noopener">https://fabiensanglard.net/git_code_review/index.php</a> - коллекция доков по гиту<br>  <a href="https://learngitbranching.js.org/?locale=ru_RU&amp;demo=" target="_blank" rel="noopener">https://learngitbranching.js.org/?locale=ru_RU&amp;demo=</a> - игра-практика<br>  <a href="https://github.com/pluralsight/git-internals-pdf/releases" target="_blank" rel="noopener">https://github.com/pluralsight/git-internals-pdf/releases</a> - книжка git internals<br>  <a href="https://gitimmersion.com/index.html" target="_blank" rel="noopener">https://gitimmersion.com/index.html</a> - практические команды<br>  <a href="http://marklodato.github.io/visual-git-guide/index-en.html" target="_blank" rel="noopener">http://marklodato.github.io/visual-git-guide/index-en.html</a> - туториал с картинками<br>  <a href="https://www.atlassian.com/git/tutorials" target="_blank" rel="noopener">https://www.atlassian.com/git/tutorials</a> - набор туториалов, advanced<br>  <a href="https://git-scm.com/book/en/v2" target="_blank" rel="noopener">https://git-scm.com/book/en/v2</a> - Pro Git ещё одна книжка</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Различные доки по git&lt;br&gt;
    
    </summary>
    
    
    
      <category term="dev" scheme="http://spiiin.github.io/tags/dev/"/>
    
      <category term="link" scheme="http://spiiin.github.io/tags/link/"/>
    
  </entry>
  
  <entry>
    <title>Файберы, диспетчеры, асинки</title>
    <link href="http://spiiin.github.io/blog/2826376146/"/>
    <id>http://spiiin.github.io/blog/2826376146/</id>
    <published>2022-09-04T16:11:33.000Z</published>
    <updated>2022-10-16T12:59:17.785Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><a href="/blog/2550823652/" title="Итераторы, колстеки, корутины">Итераторы, колстеки, корутины</a> -- первая часть статьи про итераторы и асинхронное программирование. В ней были перечислены особенности абстракций обхода коллекций в нескольких языках, а также описана связь между ними и возобновляемыми функциями. В конце статьи рассмотрено представление возобновляемых функций в различных языках и различная терминология для их обозначений. Дальше можно постепенно перейти к способам управления этими функциями.<a id="more"></a><h2 id="Ссылки"><a href="#Ссылки" class="headerlink" title="Ссылки"></a>Ссылки</h2><p>(также см. ссылки из первой статьи)<br>[1] Иван Чукич - Функциональное программирование на C++ — глава 7 Диапазоны<br>[2] Alex Davies - Async in C# 5.0<br>[3] <a href="https://www.researchgate.net/publication/220802950_The_F_Asynchronous_Programming_Model" target="_blank" rel="noopener">Don Syme - F Asynchronous Programming Model</a><br>[4] <a href="http://www.kegel.com/c10k.html" target="_blank" rel="noopener">The C10K problem</a><br>[5] <a href="https://www.youtube.com/watch?v=i0RB7UqxERE" target="_blank" rel="noopener">Async await in Nim A demonstration of the flexibility metaprogramming can bring to a language</a>. Еще несколько ссылок про async в Nim - <a href="https://nim-lang.org/blog/2014/04/21/version-094-released.html" target="_blank" rel="noopener">1</a>, <a href="https://nim-lang.org/docs/asyncdispatch.html" target="_blank" rel="noopener">2</a>, <a href="https://peterme.net/asynchronous-programming-in-nim.html" target="_blank" rel="noopener">3</a><br>[6] <a href="https://cpratt.co/async-tips-tricks/" target="_blank" rel="noopener">C# async tips and tricks</a> -  sequence tasks vs parallel. Tasks return “hot”<br>[7] <a href="https://docs.python.org/3/library/asyncio-task.html" target="_blank" rel="noopener">Python asyncio-task</a><br>[8] <a href="https://www.youtube.com/watch?v=OE45F3iKtv4" target="_blank" rel="noopener">Павел Новиков — Учимся готовить C++ корутины на практике</a><br>[9] <a href="https://developer.apple.com/videos/play/wwdc2021/10132/" target="_blank" rel="noopener">Meet async/await in Swift</a><br>[10] <a href="https://marek-g.github.io/posts/projects/archive/nemerle_async_await/" target="_blank" rel="noopener">Nemerle macro async/await</a>, еще одна реализация через <a href="https://habr.com/ru/post/108184/" target="_blank" rel="noopener">монады</a><br>[11] <a href="https://www.youtube.com/watch?v=yJxFPoxqzWE" target="_blank" rel="noopener">“Clojure core.async” by Rich Hickey (2013)</a><br>[12] <a href="http://hueypetersen.com/posts/2013/08/02/the-state-machines-of-core-async/" target="_blank" rel="noopener">The State Machines of core.async</a><br>[13] <a href="https://www.youtube.com/watch?v=R3PZMIwXN_g" target="_blank" rel="noopener">Core Async Go Macro Internals - Part I</a> - реализация goroutine-макроса в closure<br>[14] <a href="https://github.com/scylladb/seastar/blob/master/doc/tutorial.md" target="_blank" rel="noopener">Scylla DB Tutorial</a> - туториал по библиотеке c++, интенсивно использующий корутины. Еще больше статей - <a href="https://www.scylladb.com/2020/03/26/avi-kivity-at-core-c-2019/" target="_blank" rel="noopener">1</a>, <a href="https://www.scylladb.com/2020/05/05/how-io_uring-and-ebpf-will-revolutionize-programming-in-linux/" target="_blank" rel="noopener">2</a></p><h2 id="Асинхронность"><a href="#Асинхронность" class="headerlink" title="Асинхронность"></a>Асинхронность</h2><p>Если рассматривать итераторы как абстракцию способов обхода коллекции, то в первую очередь они напоминают “умный” индекс в коллекции, который может пропускать какие-либо элементы, менять направление, или даже управляться элементами самой коллекции (например, можно описать вектором цепь Маркова, и сделать итератор, который реализует переключение состояний в этой цепи).</p><p>Есть ещё одно важное свойство отделения итерации от вызывающего её кода — на момент запроса следующего элемента коллекции сама коллекция не обязана существовать целиком. Процесс создания следующих элементов коллекции может быть описан в виде функции — коллекция всех натуральных чисел, передача запроса на получение элемента из файла/от внешнего устройства/по сети (само чтение данных может происходит в других потоках, которые каким-либо образом вернут данные итератору).</p><h2 id="Описание-коллекции-в-виде-функции"><a href="#Описание-коллекции-в-виде-функции" class="headerlink" title="Описание коллекции в виде функции"></a>Описание коллекции в виде функции</h2><p>Простейший пример на <code>daScript</code> — бесконечная коллекция натуральных чисел, заданная в виде генератора:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var natural &lt;- generator&lt;<span class="keyword">int</span>&gt;() &lt;| $()</span><br><span class="line">  var i = <span class="number">1</span></span><br><span class="line">  <span class="keyword">while</span> <span class="literal">true</span></span><br><span class="line">    yield i</span><br><span class="line">    i++</span><br></pre></td></tr></table></figure></p><p>Мы не можем использовать её в цикле foreach напрямую, потому что этот цикл пытается пройти по всем элементам коллекции. Но можно сделать другой генератор, который возьмёт несколько элементов из бесконечной коллекции и остановится.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">take</span><span class="params">(var src:iterator&lt;<span class="keyword">auto</span>(TT)&gt;; count:<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">  unsafe</span></span><br><span class="line">    var gen &lt;- generator&lt;TT&gt;() &lt;| $()</span><br><span class="line">      var aValue : TT-&amp;</span><br><span class="line">      <span class="function"><span class="keyword">for</span> i in <span class="title">range</span><span class="params">(count)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">if</span> <span class="title">next</span><span class="params">(src, aValue)</span></span></span><br><span class="line"><span class="function">          yield aValue</span></span><br><span class="line"><span class="function">        <span class="keyword">else</span></span></span><br><span class="line"><span class="function">          <span class="keyword">return</span> <span class="literal">false</span></span></span><br><span class="line"><span class="function">      <span class="keyword">return</span> <span class="literal">false</span></span></span><br><span class="line">    return &lt;-gen</span><br><span class="line"><span class="keyword">for</span> num in natural |&gt; take(<span class="number">3</span>)</span><br><span class="line">  print(<span class="string">"&#123;num&#125; "</span>)</span><br><span class="line"><span class="comment">//Output: "1 2 3"</span></span><br></pre></td></tr></table></figure><h2 id="Композиция-функций-и-ленивые-вычисления"><a href="#Композиция-функций-и-ленивые-вычисления" class="headerlink" title="Композиция функций и ленивые вычисления"></a>Композиция функций и ленивые вычисления</h2><p>Попробуем “просеять” натуральные числа, оставив только простые. Пример реализации функции <a href="https://github.com/spiiin/dascript_trivial_examples/tree/main/primes/primes_mix_compile_runtime.das" target="_blank" rel="noopener">prime</a> (самая быстрая реализация, без учёта потребляемой памяти — просто посчитать первые n чисел заранее в compile-time :) ).</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> num in natural |&gt; filter(@@is_prime) |&gt; take(<span class="number">10</span>)</span><br><span class="line">  print(<span class="string">"&#123;num&#125; "</span>)</span><br><span class="line"><span class="comment">//Output: 2, 3, 5, 7, 11, 13, 17, 19, 23, 29</span></span><br></pre></td></tr></table></figure><p>Можно заметить, что не существует вычисленной промежуточной коллекции <code>natural |&gt; filter(@@is_prime)</code>, которая представляла бы собой бесконечный список всех простых чисел). Вычисление следующего элемента коллекции, описанного композицией этих функций, вычисляется только по запросу этого элемента или <strong>лениво</strong> (lazy) — <code>take</code> запрашивает следующий элемент из <code>filter</code>, которая может запросить и вычислить один или несколько элементов из коллекции <code>natural</code>.</p><p>Если попробовать реализовать такую композицию на C++ с помощью итераторов и алгоритмов STL, окажется, что они не годятся для этого, функция <a href="https://en.cppreference.com/w/cpp/algorithm/copy" target="_blank" rel="noopener">std::copy_if</a>, с помощью которой можно было бы провести фильтр элементов, ожидает на вход итераторы <strong>существующей</strong> коллекции, что требует создания временной копии и её заполнения элементами. Но вместо итераторов можно воспользоваться библиотекой <code>ranges</code> - <a href="https://en.cppreference.com/w/cpp/algorithm/ranges/copy" target="_blank" rel="noopener">стандарт C++20</a>, <a href="https://github.com/ericniebler/range-v3" target="_blank" rel="noopener">range-v3</a>, она позволяет строить ленивые итераторы (<code>std::views</code>) или инплейсно изменять коллекции (<code>std::actions</code>).</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::views;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : iota(<span class="number">1</span>) | filter(is_prime) | take(<span class="number">10</span>)) &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2 3 5 7 11 13 17 19 23 29</span></span><br></pre></td></tr></table></figure><h2 id="Коллекция-как-данные-из-внешнего-источника"><a href="#Коллекция-как-данные-из-внешнего-источника" class="headerlink" title="Коллекция как данные из внешнего источника"></a>Коллекция как данные из внешнего источника</h2><p>В отличие от всех предыдущих случаев, при получении данных от внешнего источника мы не всегда знаем когда именно данные будут получены, что приводит к следующей проблеме — что делать, если все данные готовые данные обработаны, а новых ещё нет? Как и с итераторами, возможны два основных подхода — либо вызывающий код регулярно опрашивает источник данных, есть ли новые данные для обработки, либо же источнику данных передаётся колбек, который будет вызван, когда появятся новые данные для обработки.</p><h2 id="Опрос-источника-данных"><a href="#Опрос-источника-данных" class="headerlink" title="Опрос источника данных"></a>Опрос источника данных</h2><p>Игрушечная симуляция длительно выполняющейся задачи — счётчик до 100, который позволяет информировать внешний код о прогрессе каждые 10 итераций<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> </span><br><span class="line">  ValueOrReady = variant&lt;value:<span class="keyword">int</span>; ready:<span class="keyword">bool</span>&gt;</span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line"><span class="function">def <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  <span class="comment">//создаём генератор, который может возвращать значение или флаг "значение не готово"</span></span></span><br><span class="line">  var gen &lt;- generator&lt;ValueOrReady&gt;() &lt;| $()</span><br><span class="line">    var i = <span class="number">1</span></span><br><span class="line">    var answer: ValueOrReady</span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="number">100</span></span><br><span class="line">      unsafe</span><br><span class="line">        <span class="comment">//каждый 10 шагов выдаём значение</span></span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">10</span> == <span class="number">0</span></span><br><span class="line">          answer = [[ValueOrReady value = i]]</span><br><span class="line">        <span class="comment">//иначе выдаём флаг "работа в процессе", данных пока нет</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          answer = [[ValueOrReady ready = <span class="literal">false</span>]]</span><br><span class="line">      yield answer</span><br><span class="line">      i++</span><br><span class="line">    <span class="comment">//задача выполнена</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> num in gen</span><br><span class="line">    unsafe</span><br><span class="line">      <span class="keyword">if</span> num is value</span><br><span class="line">        print(<span class="string">"&#123;num.value&#125; "</span>)</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        print(<span class="string">"x "</span>)</span><br><span class="line">  print(<span class="string">"\ndone"</span>)</span><br><span class="line"><span class="comment">//Output: x x x x x x x x x 10 x x x x x x x x x 20 x x x x x x x x x 30 x x x x x x x x x 40 x x x x x x x x x 50 x x x x x x x x x 60 x x x x x x x x x 70 x x x x x x x x x 80 x x x x x x x x x 90 x x x x x x x x x</span></span><br><span class="line"><span class="comment">//done</span></span><br></pre></td></tr></table></figure></p><p>Видно, что опрос генератор требует двух специальных флагов — выполнена ли задача полностью, и готовы ли данные. Для возврата признака, готовы ли данные, использован тип <code>variant&lt;value:int; ready:bool&gt;</code> (задача возвращает либо данные, либо флаг неготовности, но не их одновременно).</p><p>Вместо такой искусственной задержки генератор может совершать реальную работу — например опрос сокетов операционной системы, и предоставлять не результат, а интерфейс для чтения данных, когда они будут готовы (один из подходов к решению проблемы 10000 соединений к серверу [2])</p><p>Такое примитивное описание асинхронной выполняемой задачи оставляет сразу серию вопросов и возможных улучшений:</p><ul><li>пока что наш “опрос” источника внешних данных заключался в том, чтобы проверить какой-то флаг, выставляемый этим источником, в основном потоке. Реальное получение данных после того, как был получен сигнал о готовности, требует синхронизации при чтении данных из источника, что можно выразить в виде паттерна с использованием примитивов синхронизации.</li><li>в программе может существовать несколько выполняемых задач, ожидающих данных. Где-то может существовать диспетчер, опрашивающий все ожидающие задачи, чтобы не писать цикл их опроса вручную. Диспетчер может даже раскидывать выполнение задач на несколько потоков выполнения.</li><li>различные ожидающие задачи могут требовать результатов других ожидающих задач. Какие-то результаты могут потребоваться раньше, какие-то позже. Есть различные способы выражения того, что в конкретном месте выполнения программа должна дождаться данных от одной или нескольких подзадач.</li><li>если задача полностью зависит от внешнего источника, недоступного для управления из программы, логично предусмотреть возможность её завершения не дожидаясь окончания</li></ul><h2 id="Ожидание-колбеков"><a href="#Ожидание-колбеков" class="headerlink" title="Ожидание колбеков"></a>Ожидание колбеков</h2><p>Можно переписать задачу вычисления чисел так, чтобы она информировала вызывающий код о прогрессе сама (аналог внутреннего итератора):<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">makeLongCalculation</span><span class="params">(blk)</span></span></span><br><span class="line"><span class="function">  var i </span>= <span class="number">1</span></span><br><span class="line">  <span class="keyword">while</span> i &lt; <span class="number">100</span></span><br><span class="line">    unsafe</span><br><span class="line">      <span class="keyword">if</span> i % <span class="number">10</span> == <span class="number">0</span></span><br><span class="line">        invoke(blk, [[ValueOrReady value = i]], <span class="literal">false</span>)</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        invoke(blk, [[ValueOrReady ready = <span class="literal">false</span>]], <span class="literal">false</span>)</span><br><span class="line">    i++</span><br><span class="line">  invoke(blk, [[ValueOrReady ready = <span class="literal">false</span>]], <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//использование функции</span></span><br><span class="line">makeLongCalculation &lt;| $(num: ValueOrReady; done: <span class="keyword">bool</span>)</span><br><span class="line">  <span class="keyword">if</span> !done</span><br><span class="line">    unsafe</span><br><span class="line">      <span class="keyword">if</span> num is value</span><br><span class="line">        print(<span class="string">"&#123;num.value&#125; "</span>)</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        print(<span class="string">"x "</span>)</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    print(<span class="string">"\ndone"</span>)</span><br><span class="line"><span class="comment">//Output: x x x x x x x x x 10 x x x x x x x x x 20 x x x x x x x x x 30 x x x x x x x x x 40 x x x x x x x x x 50 x x x x x x x x x 60 x x x x x x x x x 70 x x x x x x x x x 80 x x x x x x x x x 90 x x x x x x x x x</span></span><br><span class="line"><span class="comment">//done</span></span><br></pre></td></tr></table></figure></p><p>Таким способом часто выглядят функции запроса данных по сети — в колбек приходит информация о массиве частично-скачанных данных, и флаги — ожидать ли ещё данных, и были ли ошибки.</p><p>Рассмотрим эволюцию паттернов работы с колбеками на примере .Net, в дань тому, что в F# и затем в C# впервые ушли от них к более свежим подходам. Microsoft в C# называет паттерны асинхронного вызова с использованием колбеков умными аббревиатурами <code>EAP</code> и <code>APM</code>. Примеры кода:</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//.NET 1, APM (Asynchronous Programming Model)</span></span><br><span class="line">file.BeginCall(buffer, <span class="number">0</span>, maxLength, asyncResult =&gt; &#123;</span><br><span class="line">  <span class="comment">//вызовется через какое-то время</span></span><br><span class="line">  <span class="keyword">int</span> numBytesRead = file.EndRead(asyncResult);</span><br><span class="line">&#125;, <span class="literal">null</span>)</span><br></pre></td></tr></table></figure><p>В некоторых вызовах неочевидно, в каком контексте будет вызван колбек (из какого потока, нужно ли синхронизироваться и передавать результат обратно в поток, в котором будет обработан результат)<br>Если же нужно из колбека вызвать еще несколько вложенных операций, получается колбек-хелл, с жутким синтаксисом и смутным представлением контекста выполнения каждого из колбеков.</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//.NET 2, APM (Asynchronous Programming Model)</span></span><br><span class="line">webClient.DownloadStringCompleted += (sender, args) =&gt; &#123;</span><br><span class="line">  <span class="keyword">string</span> html = args.Result;</span><br><span class="line">&#125;</span><br><span class="line">webClient.DownloadStringAsync(<span class="keyword">new</span> Uri(<span class="string">"http://example.com"</span>));</span><br></pre></td></tr></table></figure><p>Примерно то же самое, но с необходимостью явно оторвать колбек от вызова (и возможностью навесить несколько обработчиков) — чуть меньше “лесенок” в коде</p><h2 id="Future-async-await"><a href="#Future-async-await" class="headerlink" title="Future, async/await"></a>Future, async/await</h2><p>Future (или Task в C#) — обёртка для результата, которая запускает задачу, и возвращает управление вызывающему коду. Код сам может решить что ему делать с объектом задачи, когда остановиться, чтобы дождаться результата, или как скомбинировать полученный объект с другими задачами.</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//.NET 4</span></span><br><span class="line">Task&lt;<span class="keyword">string</span>&gt; htmlTask = webClient.DownloadStringTaskAsync(url);</span><br><span class="line"><span class="comment">//тот можно выполнить код, которому не требуется результат hmtlTask</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">string</span> html = htmlTask.Result; <span class="comment">//тут блокировка до ожидания результата</span></span><br><span class="line"><span class="comment">//или прикрепить к задаче продолжение</span></span><br><span class="line">htmlTask.ContinueWith(task=&gt; &#123;</span><br><span class="line">  <span class="keyword">string</span> html = task.Result;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Следующий шаг, сделанный в F# и перенятый в других языках — продвинутый синтаксический сахар, который позволяет записать <code>ContinueWith</code> не в виде лямбда-функции, а кодом, который выглядит, ка<br><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//.NET 5</span></span><br><span class="line">Task&lt;<span class="keyword">string</span>&gt; htmlTask = webClient.DownloadStringTaskAsync(url);</span><br><span class="line"><span class="keyword">string</span> html = <span class="keyword">await</span> htmlTask; <span class="comment">//то же что и в прошлом примере с ContinueWith</span></span><br><span class="line">doSomething(html)             <span class="comment">//строки ниже await также "переписываются" внутрь ContinueWith</span></span><br></pre></td></tr></table></figure></p><p>Другие языки с async/await в похожем виде адаптируют эти идеи из C#</p><ul><li>[5] - вкручивание их в Nim синтаксическими макросами.</li><li>[8] приводится пример разбора устройства Task в стандарте C++</li><li>[9] Swift. Достаточно подробное объяснение, тайминги<br>22:14 — трансформация кода на колбеках в async код<br>22:53 — про “цвета” функций<br>30:38 — continuation pattern cc/resume<br>32:19 — сохранение continuation %)</li><li>[10] Nemerle</li><li>[11] Closure, [12]<br> 8:24 C# async, linear code -&gt; callbacks + state machine, обзор подходов async и channel</li></ul><p>Проще говоря, <code>co_await</code> в C++ позволяет записать:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">task&lt;&gt; <span class="title">tcp_echo_server</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> data[<span class="number">1024</span>];</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> n = <span class="keyword">co_await</span> socket.async_read_some(buffer(data));</span><br><span class="line">    <span class="function"><span class="keyword">co_await</span> <span class="title">async_write</span><span class="params">(socket, buffer(data, n))</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"resended\n"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>вместо чего-то типа:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">socket.async_read_some(buffer(data)).continueWith([&amp;](<span class="keyword">auto</span> task)&#123;</span><br><span class="line">  n = task.result();</span><br><span class="line">  async_write(socket, buffer(data, n)).continueWith([&amp;](<span class="keyword">auto</span> task)&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"resended\n"</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>(специально не хочу вникать в особенности именно С++ реализации переписывания из-за её вырвиглазности, при желании можно покопаться в этом в [8]).</p><p>Можно рассматривать оператор <code>co_await</code> как возможность приостановить выполнение и “подписаться” на уведомление о завершении или приостановке выражения-аргумента.</p><p>Разбор некоторых проблем сочетания синхронных функций с асинхронными в статье <a href="http://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/" target="_blank" rel="noopener">What Color is Your Function?</a>. Библиотечные функции для синхронной и асинхронной работы “разных цветов”, и необходимо иметь 2 версии функций для того, чтобы вызывающий код мог выбирать из них (к примеру, синхронный <a href="https://github.com/redis/redis-py" target="_blank" rel="noopener">redispy</a> и его асихронный двойник <a href="https://github.com/aio-libs/aioredis-py" target="_blank" rel="noopener">aioredis</a>, или асинхронная копия <a href="https://pypi.org/project/asynctkinter/" target="_blank" rel="noopener">tkinter</a>, <a href="https://github.com/aio-libs" target="_blank" rel="noopener">десятки их</a>). Язык <code>Zig</code> кажется, один из немногих, в котором реализована поддержка универсальных бесцветных функций, которые могут работать синхронно или асинхронно, решение переносится на вызывающий кода (см ссылки [26], [27] в первой части статьи).</p><p>Интересно, насколько просто добавляются подобные операторы в языки с поддержкой синтаксических макросов. Например, модуль <a href="https://github.com/GaijinEntertainment/daScript/blob/138f625c7f95943341a5e96cca114ae7d0772ba6/daslib/coroutines.das" target="_blank" rel="noopener">coroutine</a> в <code>daScript</code>, реализующий макрос <code>co_await</code>, и примеры его использования <a href="https://github.com/GaijinEntertainment/daScript/blob/138f625c7f95943341a5e96cca114ae7d0772ba6/examples/test/misc/coroutines_example_2.das" target="_blank" rel="noopener">1</a> и <a href="https://github.com/GaijinEntertainment/daScript/blob/110bb4313fa479d7b837413700ed7f6c68601e24/examples/test/misc/coroutines_example.das" target="_blank" rel="noopener">2</a>.</p><p>Первый пример — последовательная передача управления между двумя функциями:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[coroutine]</span><br><span class="line"><span class="function">def <span class="title">subcr</span><span class="params">(name:<span class="built_in">string</span>)</span></span></span><br><span class="line"><span class="function">  <span class="title">print</span><span class="params">(<span class="string">"&#123;name&#125; sub 1\n"</span>)</span></span></span><br><span class="line"><span class="function">  <span class="title">co_continue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  <span class="title">print</span><span class="params">(<span class="string">"&#123;name&#125; sub 2\n"</span>)</span></span></span><br><span class="line"><span class="function">  <span class="title">co_continue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  <span class="title">print</span><span class="params">(<span class="string">"&#123;name&#125; sub 3\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">[coroutine]</span><br><span class="line"><span class="function">def <span class="title">coroutine_example</span><span class="params">(name:<span class="built_in">string</span>;count:<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">  <span class="title">print</span><span class="params">(<span class="string">"&#123;name&#125; step 1\n"</span>)</span></span></span><br><span class="line"><span class="function">  <span class="title">co_continue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  <span class="title">print</span><span class="params">(<span class="string">"&#123;name&#125; step 2\n"</span>)</span></span></span><br><span class="line"><span class="function">  <span class="title">co_continue</span><span class="params">()</span></span></span><br><span class="line">  co_await &lt;| subcr(name)</span><br><span class="line">  co_continue()</span><br><span class="line">  print(<span class="string">"&#123;name&#125; step 3\n"</span>)</span><br><span class="line">  co_continue()</span><br><span class="line">  <span class="function"><span class="keyword">for</span> i in <span class="title">range</span><span class="params">(<span class="number">4</span>,<span class="number">4</span>+count)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;name&#125; step &#123;i&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">co_continue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">[export]</span><br><span class="line">def main</span><br><span class="line">    var crs &lt;- [&#123;<span class="keyword">auto</span></span><br><span class="line">        coroutine_example(<span class="string">"co1"</span>,<span class="number">1</span>);</span><br><span class="line">        coroutine_example(<span class="string">"co2"</span>,<span class="number">2</span>)</span><br><span class="line">    &#125;]</span><br><span class="line">    cr_run_all(crs)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Output:</span></span><br><span class="line"><span class="comment">//co2 step 1</span></span><br><span class="line"><span class="comment">//co1 step 1</span></span><br><span class="line"><span class="comment">//co2 step 2</span></span><br><span class="line"><span class="comment">//co1 step 2</span></span><br><span class="line"><span class="comment">//co2 sub 1</span></span><br><span class="line"><span class="comment">//co1 sub 1</span></span><br><span class="line"><span class="comment">//co2 sub 2</span></span><br><span class="line"><span class="comment">//co1 sub 2</span></span><br><span class="line"><span class="comment">//co2 sub 3</span></span><br><span class="line"><span class="comment">//co1 sub 3</span></span><br><span class="line"><span class="comment">//co2 step 3</span></span><br><span class="line"><span class="comment">//co1 step 3</span></span><br><span class="line"><span class="comment">//co2 step 4</span></span><br><span class="line"><span class="comment">//co1 step 4</span></span><br><span class="line"><span class="comment">//co2 step 5</span></span><br></pre></td></tr></table></figure></p><p>Второй пример — это внутренний итератор по дереву из первой части статьи (раздел <strong><code>Файберы</code></strong>), оформленный в виде корутины:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[coroutine]</span><br><span class="line"><span class="function">def <span class="title">each_async</span><span class="params">(tree : Tree?)</span> : <span class="keyword">int</span></span></span><br><span class="line">  if tree.left != null</span><br><span class="line">    <span class="keyword">co_await</span> &lt;| each_async(tree.left)</span><br><span class="line">  yield tree.data</span><br><span class="line">  <span class="keyword">if</span> tree.right != null</span><br><span class="line">    <span class="keyword">co_await</span> &lt;| each_async(tree.right)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> t in each_async(tree)</span><br><span class="line">  print(<span class="string">"&#123;t&#125;\n"</span>)</span><br></pre></td></tr></table></figure></p><p>Макрос corountine превращает функцию в генератор, который может быть приостановлен и возобновлён. Как показывает пример, асинхронные значения могут возвращаться в том числе и из рекурсивной функции. Теперь можно как в <code>ruby</code>, возвращать управление из вложенных функций!</p><h2 id="Каналы"><a href="#Каналы" class="headerlink" title="Каналы"></a>Каналы</h2><p>Отойдём ненадолго от асинхронных функций, и посмотрим на работу с потоками. В <code>daScript</code> функции для работы с ними собраны в модуле <a href="https://github.com/GaijinEntertainment/daScript/blob/d60f0a310086458d28bf4726e93aa0e6c1e06abe/daslib/jobque_boost.das" target="_blank" rel="noopener">jobque_boost</a>. Примеры использования - <a href="https://github.com/GaijinEntertainment/daScript/blob/fdc48d4d4cfc46f08f0ca2fd8938a05896b973a6/examples/test/unit_tests/test_job_que.das" target="_blank" rel="noopener">test_job_que</a> и <a href="https://github.com/GaijinEntertainment/daScript/blob/master/examples/test/misc/producer-consumer.das" target="_blank" rel="noopener">produser-consumer</a>.</p><p>Новый поток создаётся функцией <code>new_thread</code>, а передача данных осуществляется через каналы (<code>channel</code>), которые объединяют примитив синхронизации (мьютекс) и результат, который может быть отправлен в канал из одного потока и принят из другого.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Answer</span></span></span><br><span class="line"><span class="class">    <span class="title">text</span>:</span><span class="built_in">string</span></span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">work_in_thread</span><span class="params">(var channel)</span></span></span><br><span class="line"><span class="function"><span class="comment">//создаём потока (в реальном коде нужно обернуть в job, чтобы иметь возможность дождаться завершения)</span></span></span><br><span class="line">new_thread &lt;| @</span><br><span class="line">    print(<span class="string">"in thread\n"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">for</span> i in <span class="title">range</span><span class="params">(<span class="number">3</span>)</span></span></span><br><span class="line">      channel |&gt; push_clone([[Answer text="work in progress &#123;i&#125;"]])  //передаём данные в канал</span><br><span class="line">      sleep(<span class="number">1000u</span>)</span><br><span class="line">    channel |&gt; notify_and_release                                    <span class="comment">//закрываем канал</span></span><br><span class="line">    <span class="comment">//completion |&gt; notify_and_release</span></span><br><span class="line">    print(<span class="string">"done thread\n"</span>)</span><br><span class="line">  print(<span class="string">"work_in_thread done\n"</span>)</span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main</span><br><span class="line">  with_channel(<span class="number">1</span>) &lt;| $(channel)</span><br><span class="line">    work_in_thread(channel)</span><br><span class="line">    print(<span class="string">"thread created\n"</span>)</span><br><span class="line">    for_each(channel) &lt;| $(ans:Answer#)              <span class="comment">//принимаем данные из канала</span></span><br><span class="line">        print(<span class="string">"result from thread: &#123;ans.text&#125;\n"</span>)</span><br><span class="line">    print(<span class="string">"done"</span>)</span><br><span class="line"><span class="comment">//Output</span></span><br><span class="line"><span class="comment">//work_in_thread done</span></span><br><span class="line"><span class="comment">//thread created</span></span><br><span class="line"><span class="comment">//in thread</span></span><br><span class="line"><span class="comment">//result from thread: work in progress 0</span></span><br><span class="line"><span class="comment">//result from thread: work in progress 1</span></span><br><span class="line"><span class="comment">//result from thread: work in progress 2</span></span><br><span class="line"><span class="comment">//done thread</span></span><br><span class="line"><span class="comment">//done</span></span><br></pre></td></tr></table></figure><p>Каналы по интерфейсу похожи на итераторы, однако в <code>dascript</code> не встроены в язык, поэтому работают не с встроенной функцией <code>for</code>, а с функцией из модуля joque_boost <code>for_each</code>, которая на очередной итерации достаёт из канала очередное значение или блокирует поток до тех пор, пока канал пуст. Итерация заканчивается после того, как канал будет закрыт (<code>release/notify_and_release</code>).</p><p>Но можно попробовать переписать код так, чтобы работа выполнялась в потоке, но была спрятана внутри асинхронной функции-корутине, которая предоставляет интерфейс в виде стандартного итератора. Используем предыдущий игрушечный пример с асинхронным счётчиком.<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">require daslib/coroutines</span><br><span class="line">require daslib/jobque_boost</span><br><span class="line">require fio</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> </span><br><span class="line">    ValueOrReady = variant&lt;value:<span class="keyword">int</span>; ready:<span class="keyword">bool</span>&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Answer</span></span></span><br><span class="line"><span class="class">    <span class="title">value</span>:</span><span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">work_in_thread</span><span class="params">(var channel: Channel?)</span></span></span><br><span class="line">    new_thread &lt;| @</span><br><span class="line">        <span class="function"><span class="keyword">for</span> i in <span class="title">range</span><span class="params">(<span class="number">100</span>)</span></span></span><br><span class="line">            if i % 10 == 0</span><br><span class="line">                channel |&gt; push_clone([[Answer value=i]])</span><br><span class="line">            sleep(<span class="number">10u</span>)</span><br><span class="line">        channel |&gt; append(<span class="number">1</span>) <span class="comment">//create buffer to inform that channel finish send data increase size to satisfy assert inside channel::release </span></span><br><span class="line">        channel |&gt; release   <span class="comment">//we need to call release satisfy the condition of the ChannelAndStatusCapture macro </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//completion |&gt; notify_and_release //for thread completion logic</span></span><br><span class="line"></span><br><span class="line">[coroutine]</span><br><span class="line"><span class="function">def <span class="title">makeLongCalculationInThread</span><span class="params">(work)</span> : ValueOrReady</span></span><br><span class="line">    var channel : Channel?</span><br><span class="line">    unsafe &#123; channel = channel_create(); &#125;</span><br><span class="line">    invoke(work, channel)</span><br><span class="line">    <span class="keyword">while</span> channel.size == <span class="number">0</span> <span class="comment">// channel.size==1 is a signal to stop receiving</span></span><br><span class="line">        sleep(<span class="number">10u</span>)</span><br><span class="line">        var answer: ValueOrReady</span><br><span class="line">        <span class="keyword">if</span> !channel.isEmpty</span><br><span class="line">            let void_data = _builtin_channel_pop(channel)</span><br><span class="line">            unsafe</span><br><span class="line">                let typed_data = reinterpret&lt;Answer?#&gt; void_data</span><br><span class="line">                answer = [[ValueOrReady value = typed_data.value]]</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            answer = [[ValueOrReady ready = <span class="literal">false</span>]]</span><br><span class="line">        yield answer</span><br><span class="line">    unsafe &#123; channel_remove(channel); &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main</span><br><span class="line">    <span class="function"><span class="keyword">for</span> num in <span class="title">makeLongCalculationInThread</span><span class="params">(@@work_in_thread)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">if</span> num is value</span></span><br><span class="line"><span class="function">            <span class="title">print</span><span class="params">(<span class="string">"&#123;num as value&#125; "</span>)</span></span></span><br><span class="line"><span class="function"><span class="comment">//Output (async):</span></span></span><br><span class="line"><span class="function"><span class="comment">//0 10 20 30 40 50 60 70 80 90</span></span></span><br></pre></td></tr></table></figure></p><p><em>channel_create и channel_remove тут - функции, добавленные в библиотеку работы с каналами, потому что стандартное и безопасное api каналов daScript (with_channel) предоставляет доступ к созданному каналу только внутри блока, а из блока нельзя возвращать значение с помощью yield</em></p><p>Теперь внешний интерфейс — это асинхронная функция,  которая запускает вычисление в потоке и возвращает управление, но сохранит результат вычислений из потока в канале, как только он будет готов. Основной поток при этом не блокируется и может продолжать выполнение, до тех пор пока этот результат не потребуется. Когда результат потребуется — функция main либо приостановится, чтобы его дождаться, либо сразу прочитает его из канала, если он уже готов.</p><h2 id="Communicating-sequential-processes"><a href="#Communicating-sequential-processes" class="headerlink" title="Communicating sequential processes"></a>Communicating sequential processes</h2><p>Каналы повсеместно используются в <code>Go</code>, примитивы и паттерны работы с ними рассмотрены в [22] и [23] по ссылкам в первой части статьи (теорию по работе с каналами можно гуглить по аббревиатуре <a href="https://en.wikipedia.org/wiki/Communicating_sequential_processes" target="_blank" rel="noopener">CSP</a>). Поиграться с примерами в браузере в можно <a href="https://go.dev/tour/concurrency/1" target="_blank" rel="noopener">тут</a>. Go позволяет создавать буферизированные и небуферизированные каналы. Отличие в том, что при попытке отправить второе сообщение в канал, пока не прочитано первое, тред блокируется до тех пор, пока сообщение не будет прочитано. Каналы в <code>daScript</code> буферизированы, так что можно отправить сразу несколько сообщений без блокировки отправителя, даже если читатель ещё не принял эти сообщения.</p><p>В <code>Go</code> есть удобные примитивы для соединения выходов нескольких каналов:<br><img src="/blog/2826376146/dataflow.png" alt=""><br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Funnel_receiveOrTimeout</span><span class="params">(c &lt;- <span class="keyword">chan</span> <span class="keyword">int</span>, duration time.Duration)</span> <span class="params">(data <span class="keyword">int</span>, more, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> data, more = &lt;- c :       <span class="comment">//канал с данными</span></span><br><span class="line">      <span class="keyword">return</span> data, more, <span class="literal">true</span></span><br><span class="line">    <span class="keyword">case</span> &lt;- time.After(duration):  <span class="comment">//канал таймаута, выдаёт сообщение после указанного времени</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>, <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fanout</span><span class="params">(in &lt;- <span class="keyword">chan</span> <span class="keyword">int</span>, out1, out2 <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> data := <span class="keyword">range</span> in &#123; <span class="comment">//получает новые данные</span></span><br><span class="line">    <span class="keyword">select</span> &#123;             <span class="comment">//отправляет в первый попавшийся незаблокированный канал</span></span><br><span class="line">      <span class="keyword">case</span> out1 &lt;- data</span><br><span class="line">      <span class="keyword">case</span> out2 &lt;- data</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>select</code> в первом случае позволяет либо получить сообщение с данными из канала, либо сообщение из канала таймаута, если данных не поступило в течение определенного времени. Во втором — отправить данные в первый свободный канал из списка.</p><p><code>Go</code> также отличается тем, что имеет встроенный диспетчер горутин, который распределяет выполнений по нескольким потокам. Таким образом горутины в го — это корутины, которые могут быть выполнены или перенесены в другой поток. Выполнение горутины приостанавливается при ожидании при ожиданнии данных из канала.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;a href=&quot;/blog/2550823652/&quot; title=&quot;Итераторы, колстеки, корутины&quot;&gt;Итераторы, колстеки, корутины&lt;/a&gt; -- первая часть статьи про итераторы и асинхронное программирование. В ней были перечислены особенности абстракций обхода коллекций в нескольких языках, а также описана связь между ними и возобновляемыми функциями. В конце статьи рассмотрено представление возобновляемых функций в различных языках и различная терминология для их обозначений. Дальше можно постепенно перейти к способам управления этими функциями.
    
    </summary>
    
    
    
      <category term="dev" scheme="http://spiiin.github.io/tags/dev/"/>
    
      <category term="link" scheme="http://spiiin.github.io/tags/link/"/>
    
      <category term="dascript" scheme="http://spiiin.github.io/tags/dascript/"/>
    
      <category term="cpp" scheme="http://spiiin.github.io/tags/cpp/"/>
    
  </entry>
  
</feed>
