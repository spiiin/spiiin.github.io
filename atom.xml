<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Spiiin&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://spiiin.github.io/"/>
  <updated>2024-12-17T19:23:52.396Z</updated>
  <id>http://spiiin.github.io/</id>
  
  <author>
    <name>spiiin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>241712-hexo-comments-5</title>
    <link href="http://spiiin.github.io/blog/911241759/"/>
    <id>http://spiiin.github.io/blog/911241759/</id>
    <published>2024-12-17T19:23:52.000Z</published>
    <updated>2024-12-17T19:23:52.396Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"Ov23liG1mZbiQOIdi91X","clientSecret":"e05812685eb741a752982b89dcf6f5b58dc10251","repo":"spiiin.github.io","owner":"spiiin","admin":["spiiin"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;
&lt;div id=&quot;git
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Про изучение английского-2</title>
    <link href="http://spiiin.github.io/blog/566935799/"/>
    <id>http://spiiin.github.io/blog/566935799/</id>
    <published>2024-12-16T23:54:04.000Z</published>
    <updated>2024-12-17T00:50:46.023Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p><a href="/blog/2455145615/" title="Про изучение английского">Про изучение английского</a> — первая часть</p><p>Из работающих для меня методов изучения заметил два. Первый — <code>найти человека, с которым можно выстроить свой микро-язык</code>, изначально вообще слабо похожий на тот, который изучаешь, и постепенно развивать его, добавляя правила. Так, как происходит между ребёнком и матерью, или между мужем и женой, говорящими на разных языках (или совместно изучающих один язык). С учителем так сложно, из-за того, что ему придётся не учить, а учиться этому микро-языку самому. Возможно, хорошим партнёром может стать ИИ, но пока заставить его говорить по выдуманным правилам сложнее, чем может показаться (подозреваю, что он не очень любит агглютинативные языки).</p><p>Второй — <code>найти модель, на которую можно опереться, что понять грамматические правила совсем без привязки к словам</code>. Собственно, доступная модель одна — уже известный язык. Т.е. попробовать представить, как работало бы правило из чужого языка на твоём языке. Это наиболее естественный и понятный способ “пробовать” язык, который зачем-то любят запрещать делать в школах.</p><p>Наверное, появляются дополнительные инструменты, когда знаешь несколько языков. Например, если бы я знал сербский с его перфектами, то понимание их в английском не понадобилось бы. Но учить промежуточный или искусственный язык выглядит непрактичным, если только он не нужен сам по себе.</p><p><strong><code>Строить свой язык круче, чем зубрить чужой</code></strong></p><p>Ну а дальше, кроме правил — нужно наполнение содержимым.<br>Слова — из толкового словаря, плюс из материалов на темы увлечений.<br>Фразы — фразовые глаголы, идиомы, коллокации, вылавливать в речи.</p><h2><span id="audirovanie">Аудирование</span><a href="#audirovanie" class="header-anchor">#</a></h2><p>Для меня есть три уровня аудирования:</p><ul><li>Понимаешь учебные материалы. </li></ul><p>То есть текст с экзаменов типа IELTS начитанный специально упрощённо.</p><ul><li>Понимаешь речь актёров или профессиональных дикторов </li></ul><p>Где-то посередине этого уровня большинство и застревает. Кроме чисто аудирования здесь уже часть непереводимого материала есть, который будешь пропускать больше в сериалах, меньше в книге, если от переводчиков есть сноски с объяснениями. Нейронки тоже иногда могут помочь восстановить, на что намекал автор (не переводческие, а general). В качестве известного примера – щенок бульдога доктора Ватсона.</p><ul><li>Понимаешь зашумленную произвольную речь нейтивов, разговаривающих между собой. </li></ul><p>Ну, или когда актёры/дикторы начинают говорить как будто не на камеру. Примеры - bloopers из сериалов, шотландский акцент (хотя бы примерно о чём речь), эмоциональный спор с перебиванием друг друга в подкастах.<br>Между каждым из уровней пропасть.</p><p>По идее, еще 4-й уровень – когда понимаешь культуру и можешь переключаться на ментальность носителей, но я не знаю, можно ли так с английским, кажется, максимум для славянских языков возможно.</p><h2><span id="kak-ya-sinhroniziroval-vlastelina-kolec-s-ego-perevodom-i-audioversiey">Как я синхронизировал Властелина Колец с его переводом и аудиоверсией</span><a href="#kak-ya-sinhroniziroval-vlastelina-kolec-s-ego-perevodom-i-audioversiey" class="header-anchor">#</a></h2><p>В ходе попыток прокачать навыки аудирования захотел попробовать собрать себе аналог <a href="https://www.amazon.com/Whispersync-for-Voice/b?ie=UTF8&amp;node=12527156011" target="_blank" rel="noopener">WhysperSync</a>.</p><p>Т.е. синхронизировать текст книги с её аудиоверсией, и добавить рядом еще литературный перевод. Но локально, без необходимости покупать книги в определенных сторах и отдавать задачи на чужие сервера с LLM.</p><p>Для теста выбрал <code>&quot;Властелина Колец&quot;</code> – он сложный с точки зрения грамматики, и <a href="https://disgustingmen.com/reading/lord-of-the-rings-tolkien-translations" target="_blank" rel="noopener">известен фантазией переводчиков</a>. Для начала проверил, что chat-gpt справляется с задачей синхронизации двух переводов средне, с какого-то момента начинает галлюцинировать, и вдобавок быстро отказывается работать с защищенным авторскими правами текстом (хотя если владеешь двуми книгами и одной аудиокнигой – нет ничего криминального в том, чтобы просто читать и слушать их синхронно). Но где не справляется одна нейронка, справятся 3-4 других вместе.</p><p>Сначала задача не показалась сложной. <code>Whisper</code> от OpenAI запускается локально, и если скормить ему текст книги и аудио, выдаёт хорошие результаты.<br><a href="https://github.com/kanjieater/SubPlz" target="_blank" rel="noopener">SubPlz</a> - неплохая обёртка для него от фанатов аниме. Немного программерской магии с версиями Python и Cuda (а также <a href="https://github.com/spiiin/ATS" target="_blank" rel="noopener">фиксов</a> их core lib с кодировками и английским языком вместо японского) – и он отлично работает на локальной видеокарте. На выходе получаются субтитры на английском. Из приятных бонусов – Whisper работает с любыми языками.</p><p>Дальше оказалось сложнее. Сопоставить английскую фразу русской из перевода совсем нетривиально. В теории – с этим должны справляться мультиязыковые модели <code>BERT</code>. На практике почему-то не справлялись. Изначальная задумка была попробовать сопоставить английскую фразу всем вариантам различной длины на русском и выбрать лучшую.</p><p><a href="/blog/566935799/awesome_align.png"><img src="/blog/566935799/awesome_align_small.png" alt></a></p><p>Стабильного результата таким образом добиться не удалось даже с разными метриками и вариациями алгоритма – очистка токенов, динамическое программирование с попыткой предсказать несколько следующих фраз, хитрое нормирование по длине фраз, и прочая магия-вуду не помогли. Вдобавок, работа с фразами из субтитров, а не целыми предложениями, сильно усложняет работу (модель на такое не тренирована, да и в принципе структура языков не всегда позволяет сопоставить части предложения). Хотя может я просто не научился их правильно готовить.</p><p>Лучший результат таким способом – это AI-подсказки, каким может быть следующая фраза. Но даже так, с 80-90% точностью, оставшиеся 10-20% для всей книги – долгая работа, вдобавок иногда взрывающая мозг несоотвествием русского литературного перевода оригиналу. Вот пара примеров (на всю трилогию их тысячи):</p><p><a href="/blog/566935799/1.png"><img src="/blog/566935799/1_small.png" alt></a><br><a href="/blog/566935799/2.png"><img src="/blog/566935799/2_small.png" alt></a><br><em>кричите во всю мочь и палите всё вокруг?</em></p><p>Поэтому тут я вернулся назад к работе с предложениями, чтобы попробовать сопоставить хотя бы их. Разбить текст на предложения – не такая элементарная задача, как может показаться программисту. Можно сильно удивиться, как много в языках нестандартных способов использовать знаки препинания, и как много всего интересного в юникоде. В общем, для токенизации текстов на предложения лучше не морочить себе голову и тоже воспользоваться натренированными моделями. Я брал <a href="https://spacy.io/models/" target="_blank" rel="noopener">spaCy</a> – у них есть модели для 25 языках, натренированные на википедии и новостях, в принципе справляются хорошо. На выходе получаются отдельные предложения на русском и английском. Например, для 12-й главы – 503 и 588 предложений.</p><p>Лучшее, что нашлось для сопоставления предложений – <a href="https://github.com/bitextor/hunalign" target="_blank" rel="noopener">hunalign</a>. Один из плюсов, что программе можно скормить словарь из соотвествий отдельных слов, чтобы подсказать, что <em>Strider</em> это <em>Бродяжник</em>, а <em>Glorfindel</em> – <em>Всеславур</em>.</p><p>Это сильно проще, чем разбираться, как наложить патч с дообучением или кастомными весами слов, или еще какими-нибудь методами запихнуть эту информацию под несколько слоёв нейронов. Но даже из и без словаря, hunalign строит его для непонятных ей слов сама.</p><p>В принципе, дальше дело техники. Если есть английские сабы с фразами, и пары выровненных предложений, то можно написать скрипт, который заменит фразу этой парой предложений, причём подсветит саму фразу (как в караоке). Это, собственно, то чего я и хотел добиться – видеть целое предложение и фразу внутри него, чтобы иметь возможность разобрать грамматику (иначе к концу уже забываешь начало).</p><p>В этом плане я считаю, что книги для активной работы с языком лучше фильмов, так как содержат больше новых слов и конструкций, а предложения – меньше сокращений, свойственных устной речи (если специально не занимаешься изучением сокращений в устной речи).</p><p><a href="/blog/566935799/snatch.png"><img src="/blog/566935799/snatch_small.png" alt></a><br><em>пример: первая же сцена из Snatch – кто кого keeps?</em></p><p>В книге скорее было бы что-то из этого:<br><em>I give him a hard time to keep him in check</em><br><em>I give him a hard time. It keeps him in check</em></p><p>Последним штрихом – отобразить не только сабы, но и подсветить проговариваемый текст в PDF. Тут тоже немного заковыристо, встроенные в браузер просмотрщики отключили хуки для отображения текста (почему-то это посчитали несекьюрным и Firefox и в Chrome), сторонние читалки тоже не имеют API для динамической работы с текстом (подсветка по таймингам), а парсить PDF на лету – достаточно сомнительное занятие, так как это чисто output-формат. Проще всего предварительно сконвертировать ему в HTML и грузить/подсвечивать уже его.</p><p>Получилось примерно так:<br><a href="https://www.youtube.com/watch?v=reYonqGCU8Q" target="_blank" rel="noopener">https://www.youtube.com/watch?v=reYonqGCU8Q</a></p><p>С английским – работает с любой книгой. По идее и с другими парами языков, все используемые нейронки либо мультиязычные, либо имеют модели для двух-трёх десятков языков.</p><p><a href="/blog/566935799/morty.jpg"><img src="/blog/566935799/morty_small.png" alt></a></p><p><a href="https://github.com/spiiin/mp3_srt_pdf_highlight_subtitles" target="_blank" rel="noopener">https://github.com/spiiin/mp3_srt_pdf_highlight_subtitles</a></p><p><em>Дальше письмо и говорение</em></p><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"Ov23liG1mZbiQOIdi91X","clientSecret":"e05812685eb741a752982b89dcf6f5b58dc10251","repo":"https://github.com/spiiin/spiiin.github.io","owner":"spiiin","admin":["spiiin"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;&lt;a href=&quot;/
      
    
    </summary>
    
    
    
      <category term="longread" scheme="http://spiiin.github.io/tags/longread/"/>
    
      <category term="english" scheme="http://spiiin.github.io/tags/english/"/>
    
  </entry>
  
  <entry>
    <title>Много всего, чего я не знаю</title>
    <link href="http://spiiin.github.io/blog/505778653/"/>
    <id>http://spiiin.github.io/blog/505778653/</id>
    <published>2024-12-16T21:45:03.000Z</published>
    <updated>2024-12-16T22:25:57.393Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Технические темы, c которыми я знаком поверхностно, но хотел бы больше.</p><p><code>ui</code> — как общие парадигмы/паттерны/идиомы организации (всякие MVVM/MVU xaml/elmish, RX, способы binding-ов к данным), так и ui/ux приёмы.<br><code>rust</code> — в частности, ownership и его влияние на асинхронный/многопоточный код. Академически скорее.<br><code>vulkan/dx12</code> — попробовать mesh shaders. И просто десяток-другой алгоритмов в todo.<br><code>нижние уровни сетевой модели OSI</code>.<br><code>быстрое прототипирование</code> — правильное использование тулзов, чтобы быстро собирать игровые механики. Разобраться хотя бы, в тулзах проблема или в майндсете. Идеи Bret Victor и Alan Kay.<br><code>программирование звука</code> — чё-то так и не касался серьёзно ни разу.<br><code>интерпретатор lisp</code> — make a list на чём-нибудь.<br><code>ассемблер</code> — вроде и могу читать, но не так хорошо, как хотел бы.<br><code>call/cc</code> — идиомы использования.<br><code>racket</code> — потыкать на предмет кривизны learning curve, сколько усилий нужно вложить, чтобы быстро собирать dsl под задачу на нём.</p><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"Ov23liG1mZbiQOIdi91X","clientSecret":"e05812685eb741a752982b89dcf6f5b58dc10251","repo":"https://github.com/spiiin/spiiin.github.io","owner":"spiiin","admin":["spiiin"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;Технически
      
    
    </summary>
    
    
    
      <category term="dev" scheme="http://spiiin.github.io/tags/dev/"/>
    
  </entry>
  
  <entry>
    <title>Визуальные языки программирования</title>
    <link href="http://spiiin.github.io/blog/3414198781/"/>
    <id>http://spiiin.github.io/blog/3414198781/</id>
    <published>2024-07-04T11:15:42.000Z</published>
    <updated>2024-12-17T16:46:18.750Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Коллекции скриншотов визуальных языков программирования<br><a href="http://blog.interfacevision.com/design/design-visual-progarmming-languages-snapshots/" target="_blank" rel="noopener">http://blog.interfacevision.com/design/design-visual-progarmming-languages-snapshots/</a><br><a href="https://docs.google.com/presentation/d/1MD-CgzODFWzdpnYXr8bEgysfDmb8PDV6iCAjH5JIvaI/edit#slide=id.g1e0352b8bc_1_0" target="_blank" rel="noopener">https://docs.google.com/presentation/d/1MD-CgzODFWzdpnYXr8bEgysfDmb8PDV6iCAjH5JIvaI/edit#slide=id.g1e0352b8bc_1_0</a></p><p>Две большие категории<br><a href="https://x.com/iamwil/status/1807126903377256474" target="_blank" rel="noopener">https://x.com/iamwil/status/1807126903377256474</a></p><h2><span id="dataflow-programming">Dataflow programming</span><a href="#dataflow-programming" class="header-anchor">#</a></h2><p>aka “блюпринты”. Ноды + грани их соединяющие. Традиционные области использования:</p><ul><li>Скриптовые системы в играх (Unreal Blueprints)</li><li>Процедурная генерация текстур/материалов (Blender nodes)</li><li>Синтезаторы музыка (PureData)</li><li>Workflow-менеджменты (IFTTT)</li></ul><p><a href="https://www.tumblr.com/blueprintsfromhell" target="_blank" rel="noopener">https://www.tumblr.com/blueprintsfromhell</a><br><a href="https://en.wikipedia.org/wiki/Pure_Data" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Pure_Data</a></p><p>Табличные 2d-редакторы как частный случай dataflow?<br><a href="https://youtu.be/gSFrBFBd7vY?si=oPkR1cmMqFPmW1FW" target="_blank" rel="noopener">ORCA - A 2D Visual programming language for creating synth music</a><br><a href="https://www.youtube.com/watch?v=jTG8-WlCMOY" target="_blank" rel="noopener">Sassy, the Audio Spreadsheet</a></p><h2><span id="block-based-programming">Block-based programming</span><a href="#block-based-programming" class="header-anchor">#</a></h2><p>aka “структурное редактирование”. Создание управляющих структур из блоков со слотами. Традиционно:</p><ul><li>Обучение программированию (Blocky, Scratch)</li><li>Программирование “умных” игрушек/роботов/конструкторов (MakeCode)</li><li>NoCode бизнес-логика, конфигурации, автоматизация (Codejig)</li><li>Альтернативные подходы к редактированию кода<br>(продвинутый рефакторинг, сохранение синтаксической корректности во время редактирования)</li></ul><p><a href="https://github.com/yairchu/awesome-structure-editors" target="_blank" rel="noopener">https://github.com/yairchu/awesome-structure-editors</a><br><a href="https://developers.google.com/blockly/" target="_blank" rel="noopener">https://developers.google.com/blockly/</a><br><a href="https://scratch.mit.edu/" target="_blank" rel="noopener">https://scratch.mit.edu/</a><br><a href="https://developer.apple.com/swift-playgrounds/" target="_blank" rel="noopener">https://developer.apple.com/swift-playgrounds/</a><br><a href="https://youtu.be/jabe532HFXA?si=uw6zXJWR4oaEgqbS&amp;t=569" target="_blank" rel="noopener">https://youtu.be/jabe532HFXA?si=uw6zXJWR4oaEgqbS&amp;t=569</a><br><a href="https://makecode.mindstorms.com/" target="_blank" rel="noopener">https://makecode.mindstorms.com/</a><br><a href="http://legoengineering.com/alternative-programming-languages/index.html" target="_blank" rel="noopener">http://legoengineering.com/alternative-programming-languages/index.html</a><br><a href="https://stencyl.com/" target="_blank" rel="noopener">https://stencyl.com/</a> (скорее экзотика в игровом движке)<br><a href="https://github.com/disconcision/fructure" target="_blank" rel="noopener">https://github.com/disconcision/fructure</a><br><a href="https://www.youtube.com/watch?v=CnbVCNIh1NA" target="_blank" rel="noopener">Andrew Blinn – Fructure: A Structured Editing Engine in Racket</a><br><a href="https://www.youtube.com/watch?v=NQ5h2Ibw6ck" target="_blank" rel="noopener">Inline: Efficient Source Code Editing and Manipulation with Code Portals</a></p><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"Ov23liG1mZbiQOIdi91X","clientSecret":"e05812685eb741a752982b89dcf6f5b58dc10251","repo":"https://github.com/spiiin/spiiin.github.io","owner":"spiiin","admin":["spiiin"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;Коллекции 
      
    
    </summary>
    
    
    
      <category term="dev_method" scheme="http://spiiin.github.io/tags/dev-method/"/>
    
      <category term="link" scheme="http://spiiin.github.io/tags/link/"/>
    
  </entry>
  
  <entry>
    <title>daScript AoT</title>
    <link href="http://spiiin.github.io/blog/368621422/"/>
    <id>http://spiiin.github.io/blog/368621422/</id>
    <published>2024-06-06T21:44:37.000Z</published>
    <updated>2024-06-06T10:55:18.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><h2><span id="ahead-of-time">Ahead-of-Time</span><a href="#ahead-of-time" class="header-anchor">#</a></h2><p>Пример сборки с поддержкой Ahead-of-Time скриптов.</p><p><strong><code>Сборка tutorial02_dasAot</code></strong></p><p>Программа компилирует скрипты на daScript, но полученное дерево симуляции не выполняет, а отдаёт в <a href="https://github.com/GaijinEntertainment/daScript/blob/master/src/ast/ast_aot_cpp.cpp#L3943" target="_blank" rel="noopener">visitor</a>, который генерирует c++-код, строящий аналогичное дерево симуляции (без парсинга, и компиляции). <code>tutorial02_dasAot</code> — пример кастомной утилиты генерации, в которой можно, например, дописать необходимые игре префиксы/постфиксы вроде путей к заголовочным файлам, инициализации или обёртки в неймспейсы. Собранный по умолчанию <code>daScript</code> с ключом <code>-aot</code> также может сгенерировать из das-файла соотвествующий ему c++-файл.</p><p><strong><code>Генерация из скриптов cpp-файлов</code></strong></p><p>Проект <code>tutorial02_dasAotStub</code> — шаг генерации. Вручную может быть вызван как </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tutorial02_dasAot.exe -aot tutorial02.das tutorial02_dasAotStub_tutorial02.das.cpp</span><br></pre></td></tr></table></figure><p>В настроенном через cmake проекте сгенерированный файл попадает в папку <code>\daScript\examples\tutorial\_aot_generated\tutorial02_dasAotStub_tutorial02.das.cpp</code></p><p><strong><code>Сборка игры с подключенной AoT-версией кода</code></strong></p><p>Следующий шаг — сборки хост-приложения с подключенной к нему AoT-версией кода (<code>tutorial02aot</code>).</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span>, <span class="keyword">char</span> * [] )</span> </span>&#123;</span><br><span class="line">    <span class="comment">//стандартный код инициализации/компиляция/запуска скриптов daScript</span></span><br><span class="line">    policies.aot = <span class="literal">true</span>; <span class="comment">//политика aot</span></span><br><span class="line">    <span class="keyword">auto</span> program = compileDaScript(getDasRoot() + TUTORIAL_NAME, fAccess, tout, dummyLibGroup, policies);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>При этом к программе прилинкован код файла <code>tutorial02_dasAotStub_tutorial02.das.cpp</code>. По коду в нём можно понять, что будет происходить внутри виртуальной машины daScript:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//aotLib - таблица заполняется ссылками на "скомпилированное" дерево симуляции функций.</span></span><br><span class="line"><span class="comment">// можно предположить, что в виртуальной машине daScript перед выполнением функции рассчитывается её хеш,</span></span><br><span class="line"><span class="comment">// и если он совпадает, то вызывается Ahead-of-Time версия. В случае изменения хеша -- вызывается новая функция</span></span><br><span class="line"><span class="comment">// (ну или точнее, выбор происходит на стадии построения дерева симуляции программы, </span></span><br><span class="line"><span class="comment">// ссылки на ноды-вызовы функций заменяются на aot-ноды)</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerAotFunctions</span> <span class="params">( AotLibrary &amp; aotLib )</span> </span>&#123;</span><br><span class="line"><span class="comment">// test_f5d22a771e42aa43</span></span><br><span class="line">aotLib[<span class="number">0x217a567e6e416cd0</span>] = [&amp;](Context &amp; ctx)&#123;</span><br><span class="line"><span class="keyword">return</span> ctx.code-&gt;makeNode&lt;SimNode_Aot&lt;<span class="keyword">void</span> (*) ( Context * __context__ ),&amp;test_f5d22a771e42aa43&gt;&gt;();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// [[ init script ]]</span></span><br><span class="line">aotLib[<span class="number">0xd9e9b0755c21f011</span>] = [&amp;](Context &amp; ctx)&#123;</span><br><span class="line">ctx.aotInitScript = ctx.code-&gt;makeNode&lt;SimNode_Aot&lt;<span class="keyword">void</span> (*)(Context *, <span class="keyword">bool</span>),&amp;__init_script&gt;&gt;();</span><br><span class="line"><span class="keyword">return</span> ctx.aotInitScript;</span><br><span class="line">&#125;;</span><br><span class="line">resolveTypeInfoAnnotations();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//глобальная переменная -- intrusive list, регистрирующий функции и хранящий ссылки на другие списки инициализации aot-функций</span></span><br><span class="line"><span class="function">AotListBase <span class="title">impl</span><span class="params">(registerAotFunctions)</span></span>;</span><br></pre></td></tr></table></figure><p><strong><code>Проверка</code></strong><br>В скрипт <code>tutorial2.das</code> можно добавить опцию <code>options log_aot=true</code>, чтобы в output проверить, что скрипт использует AoT версию функции<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test AOT&#x3D;0x217a567e6e416cd0  &lt;----- AoT!</span><br><span class="line">this tutorial utilizes basic builin module with constant and function</span><br><span class="line">sq2 &#x3D; 1.414213538 &#x2F;&#x2F; expecting sqrt(2), 1.41421</span><br><span class="line">a   &#x3D; 2   &#x2F;&#x2F; expecting var a initialized with 2</span><br><span class="line">xma &#x3D; 3.000000000 &#x2F;&#x2F; expecting 3</span><br></pre></td></tr></table></figure></p><p>(можно отключить aot — <code>policies.aot = false;</code>)</p><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"Ov23liG1mZbiQOIdi91X","clientSecret":"e05812685eb741a752982b89dcf6f5b58dc10251","repo":"https://github.com/spiiin/spiiin.github.io","owner":"spiiin","admin":["spiiin"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;h2&gt;&lt;span id=
      
    
    </summary>
    
    
    
      <category term="dascript" scheme="http://spiiin.github.io/tags/dascript/"/>
    
  </entry>
  
  <entry>
    <title>Template optimizations</title>
    <link href="http://spiiin.github.io/blog/4074204396/"/>
    <id>http://spiiin.github.io/blog/4074204396/</id>
    <published>2024-06-06T18:17:56.000Z</published>
    <updated>2024-06-08T02:27:43.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Редкая тема — ускорение compile-time вычислений.</p><p><a href="https://www.youtube.com/watch?v=ZpVPexZHYrQ" target="_blank" rel="noopener">code::dive 2017 – Odin Holmes – The fastest template metaprogramming in the West</a> — основные идеи<br><a href="https://www.youtube.com/watch?v=EtU4RDCCsiU" target="_blank" rel="noopener">C++Now 2017: Odin Holmes “Type Based Template Metaprogramming is Not Dead”</a> — использование в библиотеках<br><a href="https://www.youtube.com/watch?v=oNBnYhLxlTU" target="_blank" rel="noopener">CppCon 2019: Mateusz Pusz “Rethinking the Way We Do Templates in C++”</a><br><a href="https://odinthenerd.blogspot.com/p/index.html" target="_blank" rel="noopener">https://odinthenerd.blogspot.com/p/index.html</a> - блог автора, статьи с примерами</p><p><code>Rule of chiel</code>, список операций по времени с точки зрения компилятора:</p><ul><li>дорогое - SFINAE, инстанцирование функции, ~100-500x</li><li>чуть менее дорогое - инстанциирование типа, под капотом у компилятора зовёт аллокацию, ~100x</li><li>среднее - вызов алиаса, ~5x</li><li>добавление параметра типа, ~5x</li><li>добавление параметра в alias вызов, +1x</li><li>повторный поиск уже запомненного созданного типа - 0x</li></ul><p>Основная идея — отделять типы от алгоритмов, чтобы не создавать новые на каждый вызов алгоритма.</p><p>На основе замеров, идиомы:</p><ul><li>alias conditional</li><li>recursive alias</li><li>composition with continuations</li><li>fast tracking</li></ul><p><a href="https://odinthenerd.blogspot.com/2017/03/start-simple-with-conditional-why.html" target="_blank" rel="noopener">alias conditional</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">bool</span>&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_if</span> &#123;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> F&gt; <span class="comment">//`alias template`</span></span><br><span class="line"><span class="keyword">using</span> t = F;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_if</span>&lt;true&gt; &#123;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> F&gt;</span><br><span class="line"><span class="keyword">using</span> t = T;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">bool</span> B, <span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">F</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">using</span> <span class="title">result</span> = <span class="title">my_if</span>&lt;B&gt;:</span>:<span class="keyword">template</span> t&lt;T,F&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//using</span></span><br><span class="line"><span class="keyword">using</span> result1 = <span class="keyword">typename</span> my_if&lt;<span class="literal">true</span>&gt;::<span class="keyword">template</span> t&lt;<span class="keyword">int</span>,<span class="keyword">bool</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> result2 = <span class="keyword">typename</span> my_if&lt;<span class="literal">true</span>&gt;::<span class="keyword">template</span> t&lt;<span class="keyword">float</span>,<span class="keyword">char</span>&gt;; <span class="comment">//reuse my_if&lt;true&gt;</span></span><br><span class="line"></span><br><span class="line">другой быстрый вариант с <span class="keyword">template</span> variable:</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">U</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">constexpr</span> <span class="title">bool</span> <span class="title">is_same</span> = <span class="title">false</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">constexpr</span> <span class="title">bool</span> <span class="title">is_same</span>&lt;T,T&gt; = <span class="title">true</span>;</span></span><br></pre></td></tr></table></figure><p><a href="https://odinthenerd.blogspot.com/2017/03/recursive-alias-pattern-why-kvasirmpl.html" target="_blank" rel="noopener">recursive alias</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">unsigned</span>&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">loop</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">loop</span>&lt;0&gt; &#123;</span>  <span class="comment">//stop</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">template</span>&lt;<span class="keyword">typename</span>...&gt; <span class="class"><span class="keyword">class</span> <span class="title">F</span>, <span class="title">typename</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">using</span> <span class="title">f</span> = <span class="title">T</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">loop</span>&lt;1&gt; &#123;</span>  <span class="comment">//keep going</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">template</span>&lt;<span class="keyword">typename</span>...&gt; <span class="class"><span class="keyword">class</span> <span class="title">F</span>, <span class="title">typename</span> <span class="title">T</span>, <span class="title">typename</span> <span class="title">U</span>, <span class="title">typename</span>...<span class="title">Ts</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">using</span> <span class="title">f</span> = <span class="title">typename</span> <span class="title">loop</span>&lt;(sizeof...(Ts) &gt; 0)&gt;:</span>:<span class="keyword">template</span> f&lt;F,F&lt;T,U&gt;,Ts...&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//using</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> I&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">int_</span> &#123;</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> value = I;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">using</span> add = int_&lt;(T::value + U::value)&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> result = <span class="keyword">typename</span> loop&lt;<span class="number">1</span>&gt;::<span class="keyword">template</span> f&lt;add, int_&lt;<span class="number">1</span>&gt;, int_&lt;<span class="number">3</span>&gt;, int_&lt;<span class="number">4</span>&gt;, int_&lt;<span class="number">5</span>&gt;, int_&lt;<span class="number">6</span>&gt;&gt;;</span><br></pre></td></tr></table></figure><p>Не создаётся новый тип на каждый шаг алгоритма, переиспользуется уже существующий — разница на 2 порядка. Алгоритм <code>loop&lt;(sizeof...(Ts) &gt; 0)&gt;</code> и тип <code>f&lt;add, int_&lt;1&gt;, int_&lt;3&gt;, int_&lt;4&gt;, int_&lt;5&gt;, int_&lt;6&gt;&gt;;</code> разделены.</p><p><a href="https://odinthenerd.blogspot.com/2017/03/zero-const-composition-with.html" target="_blank" rel="noopener">composition with continuations</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//С - continuation</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">join</span> &#123;</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span>...Ts&gt;</span><br><span class="line">    <span class="keyword">using</span> f = join_impl&lt;C, Ts...&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> C&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">transform</span> &#123;</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span>...Ts&gt;</span><br><span class="line">    <span class="keyword">using</span> f = ucall&lt;C, <span class="keyword">typename</span> F::<span class="keyword">template</span> f&lt;Ts&gt;...&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//using</span></span><br><span class="line"><span class="keyword">using</span> result = ucall&lt; </span><br><span class="line">    flatten&lt; </span><br><span class="line">        filter&lt;predicate, </span><br><span class="line">            sort&lt;less, </span><br><span class="line">                remove_adjacent&lt; is_same,</span><br><span class="line">                    fold_left&lt;predicate&gt;&gt;&gt;&gt;&gt;, </span><br><span class="line">    Ts...&gt;;</span><br></pre></td></tr></table></figure><p>Элементы не собираются/разбираются в списки, а передаются по одному через композицию функций-продолжений (<a href="https://en.wikipedia.org/wiki/Tacit_programming" target="_blank" rel="noopener">tacit programming</a>/point free style, pipe) - сильно быстрее + чуть менее вырвиглазный синтакс.</p><p><a href="https://odinthenerd.blogspot.com/2017/03/fast-tracking-why-kvasirmpl-is-faster.html" target="_blank" rel="noopener">fast tracking</a></p><p>Кроме терминальной ветки и обработки следующего элемента дописываются ещё несколько веток обработки сразу серии элементов (у автора pow(2) до 256).</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">unsigned</span> <span class="title">next_fold_track</span><span class="params">(<span class="keyword">unsigned</span> size)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size &gt; <span class="number">10</span> ? <span class="number">2</span> : size &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">unsigned</span>&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fold_left_impl</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fold_left_impl</span>&lt;0&gt; &#123;</span>  <span class="comment">//stop</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">template</span>&lt;<span class="keyword">typename</span>...&gt; <span class="class"><span class="keyword">class</span> <span class="title">F</span>, <span class="title">typename</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">using</span> <span class="title">f</span> = <span class="title">T</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fold_left_impl</span>&lt;1&gt; &#123;</span>  <span class="comment">//keep going</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">template</span>&lt;<span class="keyword">typename</span>...&gt; <span class="class"><span class="keyword">class</span> <span class="title">F</span>, <span class="title">typename</span> <span class="title">T</span>, <span class="title">typename</span> <span class="title">U</span>, <span class="title">typename</span>...<span class="title">Ts</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">using</span> <span class="title">f</span> = <span class="title">typename</span> <span class="title">fold_left_impl</span>&lt;next_fold_track(sizeof...(Ts))&gt;:</span>:<span class="keyword">template</span> f&lt; </span><br><span class="line">        F,F&lt;T,U&gt;,Ts...&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fold_left_impl</span>&lt;2&gt; &#123;</span>  <span class="comment">//keep going</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">template</span>&lt;<span class="keyword">typename</span>...&gt; <span class="class"><span class="keyword">class</span> <span class="title">F</span>, <span class="title">typename</span> <span class="title">T0</span>, <span class="title">typename</span> <span class="title">T1</span>, <span class="title">typename</span> <span class="title">T2</span>,</span></span><br><span class="line"><span class="class">    <span class="title">typename</span> <span class="title">T3</span>, <span class="title">typename</span> <span class="title">T4</span>, <span class="title">typename</span> <span class="title">T5</span>, <span class="title">typename</span> <span class="title">T6</span>, <span class="title">typename</span> <span class="title">T7</span>, <span class="title">typename</span> <span class="title">T8</span>, </span></span><br><span class="line"><span class="class">    <span class="title">typename</span> <span class="title">T9</span>, <span class="title">typename</span> <span class="title">T10</span>, <span class="title">typename</span>...<span class="title">Ts</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">using</span> <span class="title">f</span> = <span class="title">typename</span> <span class="title">fold_left_impl</span>&lt;</span></span><br><span class="line"><span class="class">        next_fold_track(sizeof...(Ts))&gt;:</span>:<span class="keyword">template</span> f&lt;F,</span><br><span class="line">        F&lt;F&lt;F&lt;F&lt;F&lt;F&lt;F&lt;F&lt;F&lt;F&lt;T0,T1&gt;,T2&gt;,T3&gt;,T4&gt;,T5&gt;,T6&gt;,T7&gt;,T8&gt;,T9&gt;,T10&gt;,Ts...&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> C = identity&gt;</span><br><span class="line">struct fold_left&#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span>...Ts&gt;</span><br><span class="line">    <span class="keyword">using</span> f = <span class="keyword">typename</span> C::<span class="keyword">template</span> f&lt;</span><br><span class="line">        <span class="keyword">typename</span> fold_left&lt;next_fold_track(<span class="keyword">sizeof</span>...(Ts))&gt;::<span class="keyword">template</span> f&lt;</span><br><span class="line">        F::<span class="keyword">template</span> f, Ts...&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"Ov23liG1mZbiQOIdi91X","clientSecret":"e05812685eb741a752982b89dcf6f5b58dc10251","repo":"https://github.com/spiiin/spiiin.github.io","owner":"spiiin","admin":["spiiin"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;Редкая тем
      
    
    </summary>
    
    
    
      <category term="cpp" scheme="http://spiiin.github.io/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>Плюсовики в геймдеве + материалы по геймдеву</title>
    <link href="http://spiiin.github.io/blog/2794788536/"/>
    <id>http://spiiin.github.io/blog/2794788536/</id>
    <published>2024-05-25T20:03:31.000Z</published>
    <updated>2024-12-17T17:09:18.546Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Я давно писал про использование C++ как языка в геймдеве</p><ul><li><a href="/blog/1728194429/" title="С++ в геймдеве">С++ в геймдеве</a></li></ul><p>Тут о людях, которые пишут на С++, банальное, но немного наболевшее и скопившееся, наверное в последний раз на эту тему.</p><div class="toc"><!-- toc --><ul><li><a href="#specializacii-v-geymdeve">Специализации в геймдеве</a></li><li><a href="#problema-plyusovikov-v-geymdeve">Проблема плюсовиков в геймдеве</a></li><li><a href="#trebovanie-k-yazyku-tulzam-dlya-razrabotki-igr">Требование к языку/тулзам для разработки игр</a></li><li><a href="#razvitie-c">Развитие C++</a></li><li><a href="#materialy-po-geymdevu">Материалы по геймдеву</a></li></ul><!-- tocstop --></div><h2><span id="specializacii-v-geymdeve">Специализации в геймдеве</span><a href="#specializacii-v-geymdeve" class="header-anchor">#</a></h2><p>С какого-то доклада я стащил такое разделение программистов по специальностям в AAA-студиях:<br><code>Game - Gameplay/Generalist/AI</code><br><code>Game Tech - AI/Animation/Physics/Render/Network/Generalist/Tools</code><br><code>Core Tech Engine - Animation/Physics/Render/Network/Generalist/Tools</code></p><p>Я бы разделил всю пачку специализаций геймдева просто на <code>рендер/геймплей/технологии</code></p><p><code>Рендер</code><br>Вообще отдельный мир, постоянное изучение пейперов, куча математики, ковыряние с API программирования gpu и с архитектурой железок.</p><ul><li><a href="/blog/245490442/" title="Почему я недолюбливаю программирование графики">Почему я недолюбливаю программирование графики</a></li></ul><p><a href="https://www.elopezr.com/life-and-death-of-a-graphics-programmer/" target="_blank" rel="noopener">Life and Death of a Graphics Programmer</a><br><a href="https://c0de517e.com/014_future_engines.htm" target="_blank" rel="noopener">The engine of the future.The keynote nobody (quite literally) asked for</a></p><p><code>Геймплей</code><br>Взаимодействие с геймдизайнерами, артистами, продюсерами — изучение особенностей работы смежных дисциплин, быстрый фидбек — результаты своей работы видишь в игре. Бешеный драйв, горящие глаза, сроки, да и сам быстрее выгораешь. Требует быстрых итераций (как вначале, когда нужно прототипировать, искать фановые механики, так в конце при полишинге), и предсказуемости — игры-сервисы требуют регулярного выхода апдейтов.</p><p><code>Технологии</code><br>Не так весело, но зато и не так жгутся сроки. Задачи могут как требовать низкоуровневого кода (движки/компиляторы), так и высокоуровневого (редакторы, ui для артистов). Главный навык чаще всего — эмпатия и понимание образа мысли и действий юзеров. </p><ul><li><a href="/blog/2721099263/" title="Ещё о проектировании (движки и история)">Ещё о проектировании (движки и история)</a> - раздел про эмпатию “Имперсонификация и поиск паттернов вокруг”</li></ul><h2><span id="problema-plyusovikov-v-geymdeve">Проблема плюсовиков в геймдеве</span><a href="#problema-plyusovikov-v-geymdeve" class="header-anchor">#</a></h2><p>В не-топовых командах работают чаще просто <strong><code>&quot;программисты на C++&quot;</code></strong>.</p><p>По С++ много книг, конференций (в том числе на русском), курсов. Наверное, один из главных евангелистов языка на русском - Антон Полухин.</p><p>Из его докладов, где применяется С++ — браузеры/поисковые запросы/языки программирования/кодеки/торренты/игровые движки/космос/самолёты/автомобили/медицинское по/распознавание образов/обработки изображений/web фреймворки/web-страницы/базы данных/proxy/embedded/компиляторы/виртуальные машины/драйверы/биржа/офисные приложения/банкоматы/сапр/рендеры/химия/физика/машинное обучение. Все эти скоупы объединяет то, что в них может потребоваться писать код на низком уровне.</p><p>Тем не менее в каждой из областей есть и другие требования, и применяются также другие языки, которые лучше соответствуют этим требованиям. Например — надёжность (верифицируемость, работа в изолированной среде), простота использования, синтаксическая выразительность, простота работы в многопоточной среде, battery-included (соотвествие стандартной или вендорной библиотеки предметной области), скорость компиляции, скорость итерации разработки (hot-reload, repl, интерпретация). Об этом редко говорят на конференциях и в книгах по С++ (что в принципе и логично).</p><p>В то же время, геймдев, как индустрия, достаточно закрытая, и информации по разработке игр, как и книг и коференций, сильно меньше. Вдобавок, конференции освещают не только техническую сторону разработки, а ещё и представляют из себя шоу (как на уровне больших игр, так и инди), или обсуждение вопросов как лучше зарабатывать, что еще сильнее уменьшает их интересность для технарей. В книгах также редко удаётся передать современные проблемы геймдева по множеству причин — объём предметной области, более узкая специализация и более высокоуровневые темы относительно общих идиом и практик языка, устаревание информации с появлением новых поколений игровых устройств, закрытость информации (как от вендеров платформ, так и от ведущих студий).</p><p>Как результат открытости С++ и закрытости сферы разработки игр, приходящие в геймдев программисты имеют “C++-майндсет” — знают как принято писать на С++ “в общем”, но открывают для себя специфику разработки игр только в процессе работы.</p><p><strong>Способ писать на C++, нахватавшись знаний из разных областей его применения, находится далеко от того, что нужно конкретно для разработки игр</strong>.</p><p>Последствия этого — иногда “плюсовики в геймдеве”, сталкиваясь с какой-то проблемой, начинают решать её таким методом заново, не вникая в то, что наступают на те же грабли, по которым проходили их коллеги в индустрии разработки игр лет так 10-15 назад.</p><ul><li><a href="/blog/2721099263/" title="Ещё о проектировании (движки и история)">Ещё о проектировании (движки и история)</a> — одна из таких проблем, дизайн GameObject-а.<br><a href="https://www.gamearchitect.net/Articles/GameObjectRoundtable.html" target="_blank" rel="noopener">The GDC 2003 Game Object Structure Roundtable</a> — как делить игровые объекты между программистами, гейм-дизайнерами и артистами — <em>c++/scripts/visual-programming</em></li></ul><p><em>Иногда и примеры сложно разобрать более детально из-за NDA, но вот ещё несколько примеров дискуссий, касающихся того, что есть в каждой игре, т.е. с дизайном этого сталкиваются все разработчики игр</em></p><p><code>ui</code><br><a href="https://gist.github.com/bkaradzic/853fd21a15542e0ec96f7268150f1b62" target="_blank" rel="noopener">Why I think Immediate Mode GUI is way to go for GameDev tools</a> — gui для тулзов и игр, сильно шире, чем в названии. Immediate/Retained/Reactive, Native/Web, Foss/Proprietary </p><ul><li><a href="/blog/3145708234/" title="Push&#x2F;Pull&#x2F;Event model, Reactive GUI">Push&#x2F;Pull&#x2F;Event model, Reactive GUI</a></li></ul><p><code>containers/allocators/pointers</code><br><a href="https://www.jeremyong.com/c++/graphics/2018/11/17/best-practices-for-authoring-generic-data-structures/" target="_blank" rel="noopener">Best Practices for Authoring Generic Data Structures</a> — альтернативный дизайн интерфейсов для контейнеров, <a href="https://bitsquid.blogspot.com/2012/11/bitsquid-foundation-library.html" target="_blank" rel="noopener">Bitsquid Foundation Library</a>, дальше по обратным ссылкам дискуссии не только о дизайне контейнеров, но и базовых структур стандартной библиотеки, аллокаторах, указателях и сериализации/кодогенерации — <em>class-centric vs data centric design</em> (<a href="https://bitsquid.blogspot.com/2010/02/blob-and-i.html" target="_blank" rel="noopener">Blob and I</a>, <a href="https://github.com/SergeyMakeev/Zmeya" target="_blank" rel="noopener">Zmeya</a> + ссылки дальше).</p><ul><li><a href="/blog/1366632532/" title="Внутрь STL. Ссылки">Внутрь STL. Ссылки</a> — об альтернативных stl. Одна из фич C, унаследованная C++ — это возможность писать программы без использования стандартной библиотеки.</li></ul><p><code>engines</code><br><strong>Архитектура зависит от формата команды, платформы, развитости технологии, типа игр, и майндсета, поэтому подходы сильно разные</strong><br><a href="https://gamesfromwithin.com/writing-reusable-code" target="_blank" rel="noopener">Writing Reusable Code</a> — про паттерны <em>framework/layers/components</em> в игровых движках.<br><a href="https://www.jeremyong.com/game%20engines/2023/09/15/how-i-evaluate-game-engines/" target="_blank" rel="noopener">How I Evaluate Game Engines</a> — с точки зрения масштабирования.<br><a href="https://www.youtube.com/watch?v=VglTrU5YmRw" target="_blank" rel="noopener">Jonathan Blow on why C++ is a bad language for games</a> — вообщем-то, не C++, а о паттерне layers<br><a href="https://www.youtube.com/watch?v=GK7ntA7a2vk" target="_blank" rel="noopener">Your 1st, 2nd, 3rd, and Nth Game Engines</a> — о том, чем плох framework<br><a href="https://geometrian.com/programming/tutorials/write-games-not-engines/" target="_blank" rel="noopener">Write Games, Not Engines</a> — инди-подход<br><a href="https://gamearchitect.net/2008/04/15/an-anatomy-of-despair-introduction/" target="_blank" rel="noopener">An Anatomy of Despair: Introduction</a> — про выбор между low-level и abstractions (layers)</p><p><code>scripting</code><br><a href="https://enginearchitecture.org/downloads/reac2023_scripting_language.pdf" target="_blank" rel="noopener">Scripting language? Engine language?</a> — про границы между движком и игрой<br><a href="https://www.st.cs.uni-saarland.de/edu/seminare/2005/advanced-fp/docs/sweeny.pdf" target="_blank" rel="noopener">The Next Mainstream Programming Language: A Game Developer’s Perspective</a> — про баланс производительность/скорость разработки, надёжность, чистоту, многопоточность, развитие железа, ленивые вычисления и системы типов<br><a href="https://www.youtube.com/watch?v=TH9VCN6UkyQ" target="_blank" rel="noopener">Ideas about a new programming language for games</a> — Jai<br><a href="https://www.youtube.com/watch?v=IvHGczF6Go0" target="_blank" rel="noopener">Продуктивность и производительность в новых скриптовых языках</a> — скриптовый язык для программистов</p><ul><li><a href="/blog/770184585/" title="Скриптовые языки в Unreal Engine">Скриптовые языки в Unreal Engine</a> — про отличия в связывании текстового и визуального языка с движком</li></ul><p><code>ecs</code><br>дискуссии о вариантах ecs/cs и dod с точки зрения архитектуры и производительности<br><a href="https://spiiin.github.io/tags/ecs/">https://spiiin.github.io/tags/ecs/</a> — набор ссылок</p><h2><span id="trebovanie-k-yazyku-tulzam-dlya-razrabotki-igr">Требование к языку/тулзам для разработки игр</span><a href="#trebovanie-k-yazyku-tulzam-dlya-razrabotki-igr" class="header-anchor">#</a></h2><ul><li><a href="/blog/3601773065/" title="Рандомные мысли про код, дизайн, C++ и геймдев">Рандомные мысли про код, дизайн, C++ и геймдев</a> — тут немного про проблематику разработки игр.</li></ul><p>Язык для разработки игр должен быть:<br><code>- быстрый</code> (для определенной части кода)<br><code>- надёжный</code> (компилятор помогает находить проблемы)<br><code>- гибкий</code> (для итераций, прототипов, и тюнинга геймплея — иногда даже немного в ущерб первому требованию, <a href="https://youtu.be/IvHGczF6Go0?si=pWDCbiE2ccms_nP7&amp;t=1395" target="_blank" rel="noopener">“Парето-оптимальная производительность”</a>)<br><code>- простой</code> (чем проще описывать предметную область — игровую логику, тем лучше)</p><p>Требования скорости и надёжности более-менее пересекаются с общим направлением развития C++.</p><p>Хотя, кажется, насчёт <code>скорости</code>, полезное свойство языка в декларируемых zero-overhead рантайм-абстракциях, но не в абстракциях для лучшей работы с железом. Большая часть скорости получается даже не от легковесных рантайм-абстракций, а от лучшего соответствия данных и кода особенностям железа, на котором код выполняется, что достигается скорее использованием правильных библиотек, либо специфическим подходом к структурированию данных (Data oriented design).</p><p><img src="/blog/2794788536/desktop_power.png" alt><br><em>картинка из прошлой статьи про C++ в геймдеве, только 3-5% производительности связано с аккуратным использованием языка</em></p><p>Ну и понятно — о скорости можно забыть в debug-билдах<br><a href="https://vittorioromeo.info/index/blog/debug_performance_cpp.html" target="_blank" rel="noopener">The sad state of debug performance in c++</a></p><p>Насчёт <code>надёжности</code>, местами сколько не добавляй в язык нового, из-за обратной совместимости необходима скорее дисциплина программистов. Т.е в принципе, надёжность может обеспечиваться дисциплиной в C++ ИЛИ использованием другого языка.</p><p>С <code>гибкостью</code> — тут скорее необходимо брать другой язык, С++ для этого просто непригоден. Но так как о требованиях к гибкости редко говорят в мире C++, иногда бывает и так, что у программистов-плюсовиков просто не возникает ИДЕЙ, о том, что это приводит к ускорению разработки игр и созданию интересного геймплея.</p><blockquote><p>Меняя код запущенной игры, вы ускоряете весь процесс и проходите больше циклов в день, что, в свою очередь, повышает качество вашей игры. Раньше я использовал Scheme, Smalltalk и Python, но в целом подойдут любые языки программирования высокого уровня. Связать все воедино поможет Javascript<br>Jessie Schell, Геймдизайн. Как создать игру, в которую будут играть все.</p></blockquote><p><em>Очень</em> нестандартный набор с точки зрения программиста?</p><p><code>Простота</code> тоже не является чертой C++. Количество нововведений в язык с каждой версией требует обновления знаний к новой версии стандарта.</p><p><em>По разным причинам язык С++ иногда позволяет программисту сказать “I’ve only being doing C++ for 15 years. Can someone explain what is going on here?”</em></p><ul><li><a href="/blog/3121981810/" title="Важность простых языков">Важность простых языков</a></li></ul><p>Один из примеров разрастающейся сложности — решение о разрешении использования в проекте новой версии стандарта языка. С точки зрения программиста плюсовика основным аргументом становится поддержка его компиляторами.</p><p>При этом не всегда заранее учитывается, для каждой отдельной новой фичи:</p><ul><li>насколько будет увеличен размер бинарника при активном использовании фичи</li><li>время компиляции</li><li>насколько хорошо та или иная фича в принципе продумана, и насколько хорошо реализована на уровне компиляторов (“поддерживается” — не значит реализована оптимально)</li><li>дополнительная семантическая/когнитивная нагрузка — насколько в проекте станет больше различных идиом, приёмов, способов сделать что-то.<br>Т.е. “увеличится ли минимальное количество знаний, необходимое для того, чтобы программист игровой логики мог дописать код в произвольном месте” (ну, или в произвольном месте, отведённом для игрового кода). А также, сколько времени будет затрачено от абстрактного общего пула знаний, которые могут потребоваться игровому разработчику (вместо времени на получение дополнительных знаний по C++, он мог бы изучить что-то другое, настолько же или более полезное для разработки игр).</li></ul><p><em>иногда вообще кажется, что проще выучить язык, в котором уже хорошо реализована концепция, вводимая в стандартах C++, и только потом посмотреть, как перевести её на C++, чем изучать её на C++ сразу</em></p><p>При этом с точки зрения функциональности игры в проект скорее всего не будет добавлено ничего.</p><p><em>необходимый дисклеймер</em><br>Эта заметка про программистов, и про их взаимодействие с геймдизайнерами, как <strong>часть</strong> специфики предметной области.</p><p>Есть и другие части, про которые тоже нельзя забывать:<br><code>- Engineering</code> (как <strong>programming integrated over time</strong>) — общие практика разработки. Эта часть более схожа с практиками в других областях разработки программ, хотя тоже имеет свою специфику. Ключевой литературы, посвященной именно геймдеву я не встречал, но тут либо подходит общая литература (только не забывать идиому <strong>take everything with a pinch of salt!</strong>), либо доклады с профильных конференций.<br><code>- Геймдев как бизнес</code> — менее связанно с непосредственно с программированием, но необходимо для представления, что такое профессиональная разработка игр. Материалы (<strong>just a helicopter view on a problem</strong>):<br>   <strong><code>Алексей Савченко - Игра как бизнес. От мечты до релиза</code></strong> — разбор процесса создания игры, в основном про премиум-игры AA-класса. С начала и до конца. Из относительных недостатков — высокий входной порог для понимания, не всегда легко отделить написанные кровью правила от личного опыта, мало ссылок (“изучите пайплайн производства арта у Disney”)<br>   <strong><code>Development and Deployment of Multiplayer Online Games: from social games to MMOFPS, with stock exchanges in between</code></strong> — MMO и сервисные игры. Не закончена. Много технической информации, немного про оперирование.<br>   <strong><code>Lovell Nicholas - The Pyramid of Game Design. Designing, Producing and Launching Service Games</code></strong> — Free-to-play игры, геймдизайн и бизнес-модель.<br>   <strong><code>Jessie Schell - серия докладов про игровые студии</code></strong> — <a href="https://www.youtube.com/watch?v=y92-vkyHKbY" target="_blank" rel="noopener">Information Flow: The Secret to Studio Structure</a>, <a href="https://www.youtube.com/watch?v=O1zP6yJjc1o" target="_blank" rel="noopener">Game Studio Leadership: You Can Do It</a>, <a href="https://www.youtube.com/watch?v=-zRaFJHK0S4" target="_blank" rel="noopener">Game Studio Management: Making It Great</a></p><h2><span id="razvitie-c">Развитие C++</span><a href="#razvitie-c" class="header-anchor">#</a></h2><p>Куда двигался и двигается С++? (субъективно, не пересказ Committee’s subgroups)<br><code>- Борьба с наследием C и раннего C++</code> — спрятать сырые указатели, убрать касты (больше способов передать компилятору информацию о связях типов), заменить метапрограммирование by accident на by design (меньше трюков с шаблонами), добавить больше возможностей говорить о корректности части программы. <a href="https://youtu.be/x7fxeNqSK2k?si=egaG1Vew66GVtjoT&amp;t=308" target="_blank" rel="noopener">Sean Baxter @Bloomberg: Circle Fixes Defects, Makes C++ Language Safer &amp; More Productive</a> — C++ “bad defaults”. Ориентиры — Rust/D/Possible future C++ successor<br><code>- Синтаксический сахар</code> — добавления лямбд, deducing this, &lt;=&gt;, fold expressions, CTAD и прочее, сокращающее количество символов. Получается местами так себе (отчасти также из-за наследия <a href="https://www.youtube.com/watch?v=tsG95Y-C14k" target="_blank" rel="noopener">CppCon 2018: Timur Doumler “Can I has grammar?”</a>, <a href="https://brevzin.github.io/c++/2020/06/18/lambda-lambda-lambda/" target="_blank" rel="noopener">Lambda Lambda Lambda</a>, отчасти из-за того, что не любую синтаксическую “сладость” можно завернуть в zero-runtime overhead обёртку, в качестве примера можно пронаблюдать дискуссии про стандартизацию coroutines). Ориентиры — Python/Ruby.<br><code>- Возможности выразительности типов/функций</code> — концепты, ranges, функциональные возможности, вычисления над типами. Последователи Alexandresku и Stepanov — Sean Parrent, Odin Holmes, Louis Dionne/Ivan Cukic, Bartosz Milewski. <a href="https://www.youtube.com/watch?v=eRFKCsysOqk" target="_blank" rel="noopener">CppChat The Great Template Metaprogramming Library Debate</a> — иногда выглядит, что каждый тянет в свою сторону, как, собственно, должно выглядеть метапрограммирование на C++. Ориентиры — ML/Haskell/Lisp - очень разные идеи<br><code>- Рефлексия/Compile-time evaluations</code> — в принципе, то же, что и с предыдущим пунктом. <a href="https://www.youtube.com/watch?v=PJwd4JLYJJY" target="_blank" rel="noopener">Ben Deane &amp; Jason Turner “constexpr ALL the Things!”</a> / <a href="https://www.youtube.com/watch?v=NNU6cbG96M4" target="_blank" rel="noopener">Don’t constexpr All the Things - David Sankel</a> / <a href="https://www.youtube.com/watch?v=NWIsRFDaHhs" target="_blank" rel="noopener">Reflection in C++ Next - Anton Bikineev</a>. Ориентиры — D?. Хотя хотелось бы что-нибудь типа Haxe/Nemerle/Nim/Lisp/Smalltalk, или хотя бы Circle/LLVM.<br><code>- Расширение std</code> — Hazzard pointers, примитивы синхронизации, parallel stl, filesystem/networking/threading. Сложно, из-за большого scope С++ — из-за необходимости поиска “наименьшего общего знаменателя” могут не приниматься доступные <em>почти</em> на любом современном железе/операционной системе вещи. <a href="https://www.youtube.com/watch?v=g2iyNH2Gh1k" target="_blank" rel="noopener">C++ Siberia 2019: Антон Полухин, C++ на практике</a> — особенно интересная дискуссия в конце. Ориентиры — Java/C#.<br><code>- Game/Embedded/Low Latency</code> — я не особо знаю идеи, пришедшие в стандарт оттуда, только общие мысли. Идеи альтернативной EASTL. DOD — <a href="https://www.youtube.com/watch?v=yy8jQgmhbAU" target="_blank" rel="noopener">CppCon 2018: Stoyan Nikolov “OOP Is Dead, Long Live Data-oriented Design”</a> и <a href="https://www.youtube.com/watch?v=92KFSD3ObrY" target="_blank" rel="noopener">CppCon 2014 Mike Acton Data Oriented Design and C++</a>. Low latency — <a href="https://www.youtube.com/watch?v=EzmNeAhWqVs" target="_blank" rel="noopener">What is Low Latency C++? - Timur Doumler - CppNow 2023</a></p><p>Уже не совсем язык, но:<br><code>- Tooling</code> — статический анализ, fuzzing, sanitazers, flamegraphs. Наверное, ещё LLVM с его API к компилятору. <a href="https://www.youtube.com/watch?v=tISy7EJQPzI" target="_blank" rel="noopener">CppCon 2017: Titus Winters “C++ as a “Live at Head” Language”</a></p><p>В общем, хотя сам язык подходит для разработки игр, но развитие направлено <em>не совсем</em> в сторону упрощения решения проблем разработки игр. И не надо пытаться использовать для разработки игр только его.</p><h2><span id="materialy-po-geymdevu">Материалы по геймдеву</span><a href="#materialy-po-geymdevu" class="header-anchor">#</a></h2><p><em>пока просто свалены в одну кучу</em></p><p><code>~meta</code><br><a href="https://www.gamedevs.org/" target="_blank" rel="noopener">Gamedevs.org</a> — список презентаций и документов на различные темы в геймдеве. Почти все полезные.<br><a href="https://github.com/miloyip/game-programmer" target="_blank" rel="noopener">A study path for game programmer</a> — бесконечный список книг, местами для общего образования, а не необходимых каждому.<br><a href="https://www.gdcvault.com/" target="_blank" rel="noopener">GDC Vault</a> — огромный архив конференции, часть информации платная</p><p><code>~engines</code><br><a href="https://github.com/redorav/public_source_engines" target="_blank" rel="noopener">Game Engines with Source: Learning from the best</a> — список движков с исходниками. Как решаются возникающие в геймдеве проблемы в существующих движках. В отличие от других коллекций, здесь не все движки, которые удалось найти, а выборка приличного качества.<br>Блоги про разработку движков, старые, но не устаревшие. Часто содержат описание проблем и возможного пространства решений.<br><a href="https://bitsquid.blogspot.com/" target="_blank" rel="noopener">Bitsquid</a> — bitsquid/stingray<br><a href="https://ruby0x1.github.io/machinery_blog_archive/" target="_blank" rel="noopener">Our Machinery</a><br><a href="https://blog.molecular-matters.com/" target="_blank" rel="noopener">Molecular Matters</a><br><a href="http://gameangst.com/" target="_blank" rel="noopener">Despair</a> + <a href="https://gamearchitect.net/category/despair-engine/" target="_blank" rel="noopener">GameArchitect</a><br><a href="https://solid-angle.blogspot.com/" target="_blank" rel="noopener">https://solid-angle.blogspot.com/</a><br><a href="https://diligentgraphics.com/" target="_blank" rel="noopener">https://diligentgraphics.com/</a><br><a href="https://www.3dgep.com/" target="_blank" rel="noopener">https://www.3dgep.com/</a> / render<br><a href="https://engine-programming.github.io/" target="_blank" rel="noopener">https://engine-programming.github.io/</a></p><p><code>~solodev</code><br><a href="https://floooh.github.io/" target="_blank" rel="noopener">https://floooh.github.io/</a><br><a href="https://gist.github.com/bkaradzic" target="_blank" rel="noopener">https://gist.github.com/bkaradzic</a> (bgfx)<br><a href="https://www.gingerbill.org/article/" target="_blank" rel="noopener">https://www.gingerbill.org/article/</a> (odin)<br><a href="https://zylinski.se/" target="_blank" rel="noopener">https://zylinski.se/</a><br>jonathan blow, <a href="http://number-none.com/product/" target="_blank" rel="noopener">http://number-none.com/product/</a> + разное<br><a href="https://gamesfromwithin.com/category/game-tech" target="_blank" rel="noopener">https://gamesfromwithin.com/category/game-tech</a></p><p><code>~general</code><br><a href="https://aras-p.info/blog/" target="_blank" rel="noopener">https://aras-p.info/blog/</a> - Aras Pranckevičius, Unity<br><a href="https://randygaul.github.io/" target="_blank" rel="noopener">https://randygaul.github.io/</a><br><a href="https://probablydance.com/" target="_blank" rel="noopener">https://probablydance.com/</a><br><a href="https://gafferongames.com/" target="_blank" rel="noopener">https://gafferongames.com/</a><br><a href="https://journal.stuffwithstuff.com/" target="_blank" rel="noopener">https://journal.stuffwithstuff.com/</a><br><a href="https://www.tomlooman.com/" target="_blank" rel="noopener">https://www.tomlooman.com/</a> - unreal<br><a href="https://bronsonzgeb.com/" target="_blank" rel="noopener">https://bronsonzgeb.com/</a><br><a href="https://box2d.org/posts/" target="_blank" rel="noopener">https://box2d.org/posts/</a><br><a href="https://skypjack.github.io/" target="_blank" rel="noopener">https://skypjack.github.io/</a><br><a href="https://etodd.io/" target="_blank" rel="noopener">https://etodd.io/</a><br><a href="https://allenchou.net/blog/" target="_blank" rel="noopener">https://allenchou.net/blog/</a><br><a href="https://jobtalle.com/index.html" target="_blank" rel="noopener">https://jobtalle.com/index.html</a><br><a href="https://deepnight.net/tutorials/" target="_blank" rel="noopener">https://deepnight.net/tutorials/</a><br><a href="https://caseymuratori.com/contents" target="_blank" rel="noopener">https://caseymuratori.com/contents</a><br><a href="https://dyn4j.org/tags#game-development" target="_blank" rel="noopener">https://dyn4j.org/tags#game-development</a><br><a href="https://www.jeremyong.com/" target="_blank" rel="noopener">https://www.jeremyong.com/</a> - game dev general/graphics<br><a href="https://stoyannk.wordpress.com/" target="_blank" rel="noopener">https://stoyannk.wordpress.com/</a><br><a href="https://deplinenoise.wordpress.com/" target="_blank" rel="noopener">https://deplinenoise.wordpress.com/</a><br><a href="https://blog.demofox.org/" target="_blank" rel="noopener">https://blog.demofox.org/</a><br><a href="https://github.com/BobbyAnguelov/Esoterica" target="_blank" rel="noopener">https://github.com/BobbyAnguelov/Esoterica</a> - эксперименты Bobby Anguelov с системами анимации/ии.<br>mike acton<br>кармак</p><p><code>~render (немного)</code><br>Real-time rendering + ссылки оттуда на статьи/блоги/доклады<br><a href="https://diaryofagraphicsprogrammer.blogspot.com/" target="_blank" rel="noopener">https://diaryofagraphicsprogrammer.blogspot.com/</a> - Wolfgang Angel, The Forge, пачка книг ShaderX/GPU Pro/GPU Zen<br><a href="https://zeux.io/" target="_blank" rel="noopener">https://zeux.io/</a> - Arseny Kapoulkine, Roblox<br><a href="https://mynameismjp.wordpress.com/" target="_blank" rel="noopener">https://mynameismjp.wordpress.com/</a> - Matt Pettineo, Sony<br><a href="https://fgiesen.wordpress.com/" target="_blank" rel="noopener">https://fgiesen.wordpress.com/</a> - Fabian “ryg” Giesen, RAD game tools<br><a href="https://realtimecollisiondetection.net/blog/" target="_blank" rel="noopener">https://realtimecollisiondetection.net/blog/</a> Christer Ericson, Activision<br><a href="http://c0de517e.blogspot.com/" target="_blank" rel="noopener">http://c0de517e.blogspot.com/</a> - Angelo Peske, Roblox<br><a href="http://eelpi.gotdns.org/" target="_blank" rel="noopener">http://eelpi.gotdns.org/</a> - Tom Forsyth, Valve<br><a href="https://interplayoflight.wordpress.com/" target="_blank" rel="noopener">https://interplayoflight.wordpress.com/</a> - Kostas Anagnostou, Playground Games</p><p><a href="https://x.com/SebAaltonen" target="_blank" rel="noopener">https://x.com/SebAaltonen</a> - Sebastian Aaltonen, Unity, Ubisoft, mobile render in hype-hype<br><a href="https://x.com/mirror2mask" target="_blank" rel="noopener">https://x.com/mirror2mask</a> - Natalya Tatarchuk, Activision, Unity</p><ul><li><a href="/blog/2701222076/" title="Gamedev-ссылки">Gamedev-ссылки</a> — просто пачка разрозненных ссылок</li></ul><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"Ov23liG1mZbiQOIdi91X","clientSecret":"e05812685eb741a752982b89dcf6f5b58dc10251","repo":"https://github.com/spiiin/spiiin.github.io","owner":"spiiin","admin":["spiiin"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;Я давно пи
      
    
    </summary>
    
    
    
      <category term="cpp" scheme="http://spiiin.github.io/tags/cpp/"/>
    
      <category term="dev_method" scheme="http://spiiin.github.io/tags/dev-method/"/>
    
      <category term="gamedev" scheme="http://spiiin.github.io/tags/gamedev/"/>
    
      <category term="link" scheme="http://spiiin.github.io/tags/link/"/>
    
      <category term="longread" scheme="http://spiiin.github.io/tags/longread/"/>
    
  </entry>
  
  <entry>
    <title>Ctrl+N программисты</title>
    <link href="http://spiiin.github.io/blog/2055328082/"/>
    <id>http://spiiin.github.io/blog/2055328082/</id>
    <published>2024-05-25T10:24:26.000Z</published>
    <updated>2024-06-11T16:14:24.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p><a href="https://pigmeich.livejournal.com/3294.html" target="_blank" rel="noopener">Ctrl+C, Ctrl+X и Ctrl+Arrow программисты</a> — древнее полушуточное деление программистов по клавише, которую они чаще всего нажимают.</p><p>Я в этой схеме Ctrl+X программист.</p><ul><li>после Ctrl+X иногда можно не нажимать Ctrl+V. Код надо активно удалять, разросшаяся кодовая база — это самое страшное, что может случиться с проектом.</li><li>философия Ctrl+X наивно предполагает, что существующий код в хорошем состоянии. Каждое небольшое изменение, начиная с первого коммита в репозиторий делает его немного лучше. Не переиспользовать готовый хороший код — плохо. Даже если готовый код плохой, чтош, приходится переиспользовать плохой код. При таком подходе не годится только код, который вообще нельзя переиспользовать, его можно только выбросить и написать новый, который делает то же, но лучше подходит для переиспользования.</li><li>в большой кодовой базе редко возникает ситуация, когда новая задача требует абсолютно нового кода.</li><li>если необходимо заменить целую подсистему, возможно делать это инкрементально, а не большим куском (<a href="https://learn.microsoft.com/en-us/azure/architecture/patterns/strangler-fig" target="_blank" rel="noopener">Strangler Fig pattern</a>).</li></ul><p><img src="/blog/2055328082/strangler_fig_small.png" alt><br><a href="https://en.wikipedia.org/wiki/Strangler_fig" target="_blank" rel="noopener">Strangles fig</a> — тотемное дерево Ctrl-X программистов, в Тайланде много таких. Маленькие ростки сверхну вниз постепенно создают отдельные новые пути, замещая старое дерево</p><ul><li><a href="/blog/1257365288/" title="Хорошие качества программистов">Хорошие качества программистов</a> — умение решать задачу минимальным количеством изменений в коде</li></ul><h2><span id="ctrl-n-programmisty">Ctrl+N программисты</span><a href="#ctrl-n-programmisty" class="header-anchor">#</a></h2><p>Недавно я понял, что знаю ещё один тип программистов. Их любимое сочетание клавиш — Ctrl+N. Создать новый файл и начать писать туда код. Много кода. Типа <a href="https://x.com/Nekrolm/status/1792823888600314266" target="_blank" rel="noopener">такого</a>, 10к строк, насколько PR их не дели, остаются 10к строк за раз. “Там на 70% всё правильно” (это кажется одновременно и шутка, и серьёзная оценка). В хороших случаях — половина кода тесты. Но про этим, если верить эвристике, что число ошибок на 1к строк кода постоянно, то в тестах тоже будет несколько ошибок. Да и тесты — это не способ проверить сам добавляемый <strong>сейчас</strong> код, и тем более не способ проверить интеграцию этого кода в общую базу, они для проверки добавляемого кода к будущем его изменениям.</p><p>“Почему коллеги не захотели отревьюить мой код, у них был шанс, теперь придётся мерджить так” — реалистичный лимит на ревью - 100-500 строк, а в идеале 20-100 строк. Всё что больше просто монолит, гарантированно содержащий несколько ошибок, с большим количеством информации о коде в голове автора. Либо брать целиком как есть, либо выбрасывать целиком. Я встречал кейс, когда автор прочитал 1.5 часовую лекцию с обещанием потом записать всё в вики. Конспект и детальное расписывание примеров в этом случае займёт дополнительно часов 5 (в ходе написания документации обнаружатся пробелы в памяти автора и скорее всего ошибки в коде).</p><p>При интеграции возникает проблема <a href="https://ru.wikipedia.org/wiki/%D0%90%D1%85%D0%B8%D0%BB%D0%BB%D0%B5%D1%81_%D0%B8_%D1%87%D0%B5%D1%80%D0%B5%D0%BF%D0%B0%D1%85%D0%B0" target="_blank" rel="noopener">Ахиллеса и черепахи</a>, пока программист делает свою часть работы, проект уходит немного вперёд (или оказывается, что автор забыл, что его изменения требуют ещё каких-то дополнительных изменений в проекте или в коде автора), что требует дополнительных правок, за время которых проект уходит ещё немного вперёд.</p><p>Из хороших качеств Ctrl-N программистов — это умные и энергичные люди, способные быстро писать большое количество кода и держать в голове его структуру (пока не забудут). В хорошем случае, тратят больше времени на планирование на бумаге и тесты.</p><h2><span id="slozhnost-predmetnoy-oblasti">Сложность предметной области</span><a href="#slozhnost-predmetnoy-oblasti" class="header-anchor">#</a></h2><p>Иногда большой объём кода, который любят писать Ctrl+N программисты является отражением сложности предметной области. Например, для создания/рефакторинга библиотеки gui программисту потребовалось переписать разом 50 контролов, или при создании DSL — несколько десятков конструкций для своего доменного языка. Варианты решений, которые могут немного исправить такие ситуации — кодогенерация (кодогенератор десяти тысяч строк вполне может уложиться в 500 строк), или использование другого языка, который уже решает часть проблем.</p><p>Например каждая конструкция доменного языка скорее всего потребует описания не только своей структуры, а и нескольких действий на основе этой структуры:<br><strong><code>- верификации</code></strong> (валиден ли сгенерированный пользователем код?)<br><strong><code>- выполнения</code></strong> (как именно выполнять описанные пользователем dsl действия),<br><strong><code>- преобразований</code></strong> (может ли мы улучшить описанную пользователем структуру вместо выполнения)<br><strong><code>- хранения</code></strong> (как сохранить/восстановить структуру при перезапуске программы-хоста, включая версионирование при изменениях в самом DSL)<br><strong><code>- представления</code></strong> (как отображать dsl, визуальное представление для редактирования или отладки)<br>Эти действия в разных языкам могут быть выражены как тривиально, так и требовать ручной работы. Один из вариантов решения — не описывать это руками, а воспользоваться функционалом другого языка (с виртуальной машиной или другим способом встроить его в основной), который уже решает часть или все задачи. Тогда реализуемый dsl вместо описания того как выполнять каждое из этих действий превратится в описание того, как отобразить описание структур на исходном языке в описание для виртуальной машины (и, возможно, обратно).</p><h2><span id="ctrl-s-programmisty">Ctrl+S программисты</span><a href="#ctrl-s-programmisty" class="header-anchor">#</a></h2><p>Ходят легенды также о мифических Ctrl-S программистах, которые чаще всего сохраняют код, и благодаря hot-reload изучают результат в запущенном приложении.</p><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"Ov23liG1mZbiQOIdi91X","clientSecret":"e05812685eb741a752982b89dcf6f5b58dc10251","repo":"https://github.com/spiiin/spiiin.github.io","owner":"spiiin","admin":["spiiin"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;&lt;a href=&quot;h
      
    
    </summary>
    
    
    
      <category term="cpp" scheme="http://spiiin.github.io/tags/cpp/"/>
    
      <category term="fun" scheme="http://spiiin.github.io/tags/fun/"/>
    
      <category term="dev" scheme="http://spiiin.github.io/tags/dev/"/>
    
  </entry>
  
  <entry>
    <title>Виды сложности</title>
    <link href="http://spiiin.github.io/blog/4080907009/"/>
    <id>http://spiiin.github.io/blog/4080907009/</id>
    <published>2024-05-24T23:07:00.000Z</published>
    <updated>2024-09-23T07:32:58.172Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p><strong><code>- Сложность предметной области</code></strong><br>Поиск “серебрянной пули” — универсального подхода к проектированию чего угодно. Например, проектировать, исходя из того, что “всё есть объекты”, “используем шаблоны проектирования”, попытка натягивать на паттерны всё, даже там, где это не нужно. Или “запретить использование сырых указателей”. Иногда получается хорошо, иногда странно.  Идея с классами в геймдеве рождает GodObject (GameObject/GameLevel) + в конечных классах получаются очень неудобные иерархии наследования.</p><p>Другой подход — разработка фреймворков/DSL, с помощью которых можно смоделировать на высоком уровне (“на языке специалистов предметной области”) большую часть задач в какой-либо отрасли. Может размазываться в различных пропорциях между “системным языков” и “прикладным языком/программой”, со слоем склеивания в виде файлов с данными или API в коде.</p><ul><li><a href="/blog/2721099263/" title="Ещё о проектировании (движки и история)">Ещё о проектировании (движки и история)</a></li></ul><p>Сложность предметной области плохо устраняется, так как описывает не красивые абстрактные модели, а конкретные частные случаи. Важно не подмешать лишней сложности, напроектировав в голове машины Руба Голдберга. Меньше понятий, сущностей, уровней абстракции и связей. Если без чего-то можно обойтись — нужно это выбросить.</p><p><a href="https://caseymuratori.com/blog_0015" target="_blank" rel="noopener">Semantic compression</a> — статья о том, как выбрасывать сущности.</p><p><strong><code>- Сложность выполнения требований</code></strong></p><p><em>“Выбросить клоунов из машины”</em></p><p>Программы выполняются не на абстрактном компьютере, а на реальном железе. Существует разрыв между задачами, которым с головой хватает возможностей компьютера, и теми, которые упираются в ограничения. Кроме железа, могут вылезать и другие сложности окружения  — сборщик мусора, ограничения файловой системы или сети, с какого-то масштаба задач требуют учёта влияния этих факторов. “Common wisdom” про то, что можно начинать оптимизировать с момента, когда начнёт тормозить, работает далеко не всегда. Иногда решения по оптимизации должны быть заложены еще на уровне дизайна.</p><p>Отдельная сложность — предсказание ограничений, которые возникнут, но неизвестны заранее. С геймдевом — в индустрии не так много накопленного и обработанного опыта развития игр после выпуска по 5-10 и более лет.</p><p><strong><code>- Сложность старта</code></strong></p><p>Gui приложения, пустое окно OpenGL, настройка и разворачивание веб-сервера для странички — лет 15 назад требовали больше работы, чем сейчас. Более-менее решено с помощью open-source библиотек, бесплатного хостинга, доступного интернета, искусственного интеллекта. Если не поднимать вопрос о качестве этих библиотек (в разных отраслях разное), то можно сказать что стартовать и собирать прототипы стало сильно проще. Менее заметно в больших командах, чем при одиночной разработке.</p><p><a href="https://zylinski.se/posts/solodevs-and-the-trap-of-the-game-engine/" target="_blank" rel="noopener">Solodevs and the trap of the game engine</a> — про разницу разработки игр в одиночку и в больших командах</p><p><strong><code>- Сложность роста</code></strong></p><p>Серьёзная проблема, с частичными идеями решения. Некоторые практики могут работать для программ на 10к-100к строк, написанных 5 людьми, но ломаться после 100к строк, написанных в разное время 50 людьми. Один из приёмов — изолировать сложность на каком-то уровне, и выдать “наружу” зафиксированный интерфейс. Чем более отдельный компонент получается, тем проще с ним общаться извне, без риска поломки. Вариант изоляции более высокого уровня — виртуальные машины и сэндбоксы для приложений.</p><p>Второй подход — не изолировать сложность, а искать такие методы решения, которые позволяют избегать роста сложности (“сделать так, чтобы большая программа ощущалась как маленькая”). Отбросить принятые практики, ведущие к запутыванию, встроить что-то в “простой” язык/виртуальную машину (пожертвовав чем-то). Преимущество таких решений — надёжность, за счёт гарантий (даже если частичных) от компилятора. Чем проще система, тем больше шансов, что в ней будет возможно быстрое внесение изменений/добавлений функционала/исправление ошибок. Single responsibility из SOLID или KISS — кодифицированные отсылки к такому подходу, как и <a href="https://www.youtube.com/watch?v=LKtk3HCgTa8" target="_blank" rel="noopener">Simplicity</a> Рича Хики</p><p><strong>update 2024-09-23</strong><br><a href="https://mbuffett.com/posts/all-tacit-knowledge/" target="_blank" rel="noopener">Programming and Tacit Knowledge</a> - tacit-знания, которые невозможно передать через туториал, а только эмпирически.<br>Примеры в программировании — архитектура/дизайн/паттерны/парадигмы программирования. Навыки отладки, организации рабочего процесса, оценка стиля кода, контроль сложности, производительности и запутанности кода.</p><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"Ov23liG1mZbiQOIdi91X","clientSecret":"e05812685eb741a752982b89dcf6f5b58dc10251","repo":"https://github.com/spiiin/spiiin.github.io","owner":"spiiin","admin":["spiiin"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;c
      
    
    </summary>
    
    
    
      <category term="dev_method" scheme="http://spiiin.github.io/tags/dev-method/"/>
    
  </entry>
  
  <entry>
    <title>Game Engines with Source: Learning from the best</title>
    <link href="http://spiiin.github.io/blog/3139044644/"/>
    <id>http://spiiin.github.io/blog/3139044644/</id>
    <published>2024-05-22T22:32:26.000Z</published>
    <updated>2024-05-22T17:35:11.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p><a href="https://github.com/redorav/public_source_engines" target="_blank" rel="noopener">https://github.com/redorav/public_source_engines</a> — список исходников движков</p><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"Ov23liG1mZbiQOIdi91X","clientSecret":"e05812685eb741a752982b89dcf6f5b58dc10251","repo":"https://github.com/spiiin/spiiin.github.io","owner":"spiiin","admin":["spiiin"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;&lt;a href=&quot;h
      
    
    </summary>
    
    
    
      <category term="link" scheme="http://spiiin.github.io/tags/link/"/>
    
  </entry>
  
  <entry>
    <title>Рандомные мысли про код, дизайн, C++ и геймдев</title>
    <link href="http://spiiin.github.io/blog/3601773065/"/>
    <id>http://spiiin.github.io/blog/3601773065/</id>
    <published>2024-05-20T17:32:38.000Z</published>
    <updated>2024-05-28T07:38:45.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><ul><li><a href="/blog/1728194429/" title="С++ в геймдеве">С++ в геймдеве</a> — предыдущий пост на похожую тему</li></ul><p>Несколько общих статей от разработчиков игр:<br>[1] - <a href="https://loglog.games/blog/leaving-rust-gamedev/" target="_blank" rel="noopener">Leaving Rust gamedev after 3 years</a> — про то, что фичи Rust-а не особо помогают для геймдева, а периодически и мешают.<br>[2] - <a href="https://www.elopezr.com/life-and-death-of-a-graphics-programmer/" target="_blank" rel="noopener">Life and Death of a Graphics Programmer</a> — взгляд на геймдев со стороны графического разработчика. Достаточно высокий, чтобы быть интересным любому разработчику игр.</p><p>Важные моменты из статей:</p><blockquote><p>Generalized systems don’t lead to fun gameplay</p></blockquote><p>Программирование геймплея практически невозможно уложить в обобщенную систему или библиотеку на С++/Rust (как и иерархию классов), нужны другие строительные блоки.</p><blockquote><p>Making a fun &amp; interesting games is about rapid prototyping and iteration, Rust’s values are everything but that</p></blockquote><p>Строгие требования языка мешают прототипированию. Геймдев — не про выражение строгих требований, а про простые эксперименты и быстрые итерации.</p><blockquote><p>Rust gamedev ecosystem lives on hype</p></blockquote><p>Больше даже не про Rust, а про open-source библиотеки в принципе. Большая часть из них не готова к использованию в продакшене. Код в продакшене сильно сложнее за счёт того, что в нём заложено решения множества возникавших проблем.</p><blockquote><p>Упорная борьба с компилятором за то, чтобы заставить его сделать что-то конкретное, даёт чувство достижения. В одной кодовой базе была мощная функция рефлексии шейдеров с множеством метахакерских шаблонов и макросов, которая работала, если оставить ее в покое, но ее было невероятно сложно отлаживать, изменять и расширять. Оглядываясь назад, можно сказать, что такая альтернатива, как генерация кода, могла бы работать лучше.</p></blockquote><p>Касается и других систем рефлексии.</p><blockquote><p>Как графический программист я добавлял бесконечное количество чекбоксов, слайдеров и кнопок для множества редакторов объектов. И намного более важно в этом, чтобы элемент был добавлен в корректную категорию, имел правильные ограничения на ввод и понятные подсказки, что то, как выглядит код, это абсолютно неинтересно и неважно артисту.</p></blockquote><p>Как и с любыми тулзами. Невозмжно, что под капотом, важно что тот, как работает с программой (фактически, ДЕЛАЕТ игру) имел то, что удобно для него. Программисты типично пытаются делать тулзы для себя, а не для других. Один из симптомов такого перекоса — желание выбрать/создать скриптовый язык, похожий на C++.</p><h2><span id="proektirovanie-pod-komandu">Проектирование под команду</span><a href="#proektirovanie-pod-komandu" class="header-anchor">#</a></h2><p>Проектирование (в частности, выбор языка и инфраструктуры) в геймдеве сильно зависит состава команды. В [2] есть сравнение команд, в которых шейдеры могут трогать только программисты с теми, в которых к ним есть доступ у технических артистов, и просто артистов. Если в Doom шейдеры модифицируют только программисты, то в нём и будет около 100 типов шейдеров (и не будет серьёзного инструмента для работы с ними), тогда как в Unreal вышедшие проекты могут содержать до 10к материалов, но и тулзы, в которых делаются шейдеры, будет выглядеть сильно по разному.</p><p><strong>Если игру делают программисты, и хотят сделать редактор, важно понимать для кого они делают редактор — для себя или будущих гейм-дизайнеров, со старта.</strong></p><ul><li><a href="/blog/2721099263/" title="Ещё о проектировании (движки и история)">Ещё о проектировании (движки и история)</a> — одна из больших идей этой статьи, что проектирование (не только тулзов, но и архитектуры) изначально должно учитывать конфигурацию команды.</li></ul><h2><span id="geymdev-problematika">Геймдев проблематика</span><a href="#geymdev-problematika" class="header-anchor">#</a></h2><p>Программисты сталкиваются в первую очередь с техническими требованиями к игре — код должен быть быстрым и надёжным (больше ошибок ловит ловит компилятор). Но кроме этих требований у гейм-дизайнеров, создающих игровые механики, есть другие.</p><p><a href="https://www.youtube.com/watch?v=o5K0uqhxgsE" target="_blank" rel="noopener">This Problem Changes Your Perspective On Game Dev</a> — обзор процесса поиска в дизайне. Критична простота экспериментов, и скорость итерации. В видео нет никаких новых идей — это стандартные требования геймдизайнеров к инструментам, чтобы иметь возможность создавать интересный геймплей. Причём не только к инди или инновационным играм, а вообще к играм любого жанра.</p><p><a href="https://www.youtube.com/watch?v=72y2EC5fkcE" target="_blank" rel="noopener">Tomorrow Corporation Tech Demo</a> — небольшой пример хот-релоада<br><a href="https://www.youtube.com/watch?v=PUv66718DII" target="_blank" rel="noopener">Inventing on Principle</a> — еще пример<br><a href="https://youtu.be/-zc8LcDwVUc?si=1RkL-OX3RNfc6gk_&amp;t=132" target="_blank" rel="noopener">NimForUE 101: uStructs</a> — перезагрузка в vm unreal с помощью кода на nim<br><a href="https://www.youtube.com/watch?v=inGb9R1NowY" target="_blank" rel="noopener">Live Stream Coding on daScript - Breakoid</a> — Arcanoid на daScript с нуля без перезапуска игры</p><ul><li><a href="/blog/3309518526/" title="Системы поиска сокровищ">Системы поиска сокровищ</a> — системы поиска сокровищ в песочницах</li></ul><p>В общем, необходимо:<br><code>- возможность очень быстро проверить изменения</code> — быстрая сборка, в том числе с возможностью хот-релоада<br><code>- простая интроспекция</code> — в том числе визуальная, через редакторы и дополнительный gui<br><code>- возможность комбинировать объекты</code>. Особенность геймдева — наличие большого числа объектов, которые могут изменять поведение динамически (ECS подход об этом)</p><p>C++ как язык местами не помогает, а скорее мешает реализации систем, которые бы имели такие свойства.</p><p>Дополнительно, так как геймдев требователен к производительности:<br><code>- возможность оптимизации быстро написанного кода</code> — Just-in-Time, Ahead-of-Time</p><h2><span id="pro-volny-razvitiya-tehnologiy">Про волны развития технологий</span><a href="#pro-volny-razvitiya-tehnologiy" class="header-anchor">#</a></h2><p>C++ находится на достаточно поздней стадии развития — много лет использования, развитые компиляторы с оптимизациями, стандартная библиотека. Периодически предлагаются языки-наследники (Carbon, Cpp2, Val). Но при этом он плохо подходит для решения специфичный для современного геймдизайна проблем, перечисленных выше.</p><p><code>- долгая компиляция</code>. Заменить include на модули стоило бы лет 15 назад. Тем не менее, модули все ещё не используются.<br><code>- рефлексия в стадии &quot;обсуждаем, как стандартизовать&quot;</code>. Из-за особенностей C++ можно ждать возможности использовать то что настандартизируют ещё очень долго. Причём только рефлексию, без кодогенерации и полноценного compile-time выполнения, которые тоже нужны. Лучшее решение сейчас — внешний инструмент.<br><code>- менять код на лету можно очень ограниченно</code>. Интерпретации не планируется, hot-reload на уровне подмены динамической библиотеки (доступной не на всех платформах). Требуется внешнее решение.</p><p><em>Вообще ждать появления чего-то в стандарте — очень ненадёжно. Может быть отложено, принято криво, после принятия еще несколько лет до исправления багов во всех реализацией, и еще — на обновление библиотек</em></p><p>Как сделать разработку легче? </p><p><strong>Не пытаться использовать C++ там, где это неудобно, использовать другой язык или языки для описания игровой логики</strong>. Такой на котором проще решать проблемы гейм-дизайнеров, не программистов (этот язык даже скорее всего будет <em>менее</em> удобен программистам, во всяком случае вначале).</p><p><img src="/blog/3601773065/lobster_pre_small.png" alt><br><em>старая архитектура, много c++, немного в скриптах</em></p><p><img src="/blog/3601773065/lobster_small.png" alt><br><em>новый подход, что-то типа <a href="https://enginearchitecture.org/downloads/reac2023_scripting_language.pdf" target="_blank" rel="noopener">такого</a> (доклад сам по себе про похожие идеи). автор языка lobster, также flatbuffers и программист в нескольких AAA-проектах</em><br>(в unity — C#, в unreal — blueprints, в dagor engine — daScript)</p><p><a href="https://grimfandango.network/features/articles/lua-in-grim-fandango" target="_blank" rel="noopener">Lua in Grim Fandango</a> — история <a href="https://www.lua.org/doc/hopl.pdf" target="_blank" rel="noopener">первого</a> использования lua в качестве скриптового языка.</p><p>Телефоны/консоли также на поздней фазе развития — запаса мощности часто хватает для того, чтобы запихнуть “дорогие” абстракции, увеличивающие как время компиляции, так и время выполнения кода. Для казуальных и прочих “простых” игр — раз в 5-10. Т.е. в принципе можно вообще использовать в 5-10 раз более медленный язык для реализации всей логики, ради того, чтобы сделать удобнее гейм-дизайнерам.</p><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"Ov23liG1mZbiQOIdi91X","clientSecret":"e05812685eb741a752982b89dcf6f5b58dc10251","repo":"https://github.com/spiiin/spiiin.github.io","owner":"spiiin","admin":["spiiin"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;ul&gt;
&lt;li&gt;&lt;a h
      
    
    </summary>
    
    
    
      <category term="cpp" scheme="http://spiiin.github.io/tags/cpp/"/>
    
      <category term="dev_method" scheme="http://spiiin.github.io/tags/dev-method/"/>
    
      <category term="gamedev" scheme="http://spiiin.github.io/tags/gamedev/"/>
    
  </entry>
  
  <entry>
    <title>Трюки с сериализацией на clang от Valve</title>
    <link href="http://spiiin.github.io/blog/1495987502/"/>
    <id>http://spiiin.github.io/blog/1495987502/</id>
    <published>2024-05-19T23:02:00.000Z</published>
    <updated>2024-05-19T18:22:07.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Пара докладов с GDC ~2012<br><a href="https://www.gdcvault.com/play/1015586/" target="_blank" rel="noopener">Robustification Through Introspection and Analysis Tools (Avoiding Developer Taxes)</a><br><a href="https://www.gdcvault.com/play/1020065/Physics-for-Game-Programmers-Debugging" target="_blank" rel="noopener">Physics for Game Programmers: Debugging Physics</a></p><blockquote><p>“Налоги” — это то, что непосредственно не приносит пользу продукту, но упрощает жизнь. Примеры для геймдева — сериализация, статистика памяти, привязка к скриптам, версионирование</p></blockquote><p>Примеры того, что сделали, распарсив код с помощью Clang:</p><p><strong><code>Сериализация</code></strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A0</span> &#123;</span><span class="keyword">float</span> x; byte y;&#125;</span><br><span class="line"><span class="keyword">char</span>* A0_type[] = &#123;<span class="string">"FB"</span>&#125;; <span class="comment">//подставляется из сгенерированного типа</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_any</span><span class="params">(<span class="keyword">void</span>* obj, <span class="keyword">char</span>* type)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (*type) &#123; <span class="keyword">switch</span> (*type++) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'F'</span>: <span class="comment">//write(); obj += sizeof(float);</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">'B'</span>: <span class="comment">//write(); obj += sizeof(byte);</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">return</span>;</span><br><span class="line">  &#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Можно отследить по диффам изменения форматов и генерировать код сериализации/десериализации для разных версий структуры + отслеживать перемещение полей между структурами</p><p><strong><code>Slim bindings</code></strong></p><p>“Трамплины” для обвязок функций для скриптого языка</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*func_int__int_charptr)</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">char</span>* c)</span> <span class="comment">//для каждого типа сигнатур</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trampoline</span><span class="params">(<span class="keyword">void</span>** buf, func_int__int_charptr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>&amp; ret = *(<span class="keyword">int</span>*)buf[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">int</span>&amp; arg0 = *(<span class="keyword">int</span>*)buf[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">char</span>* arg1 = *(<span class="keyword">char</span>*)buf[<span class="number">2</span>];</span><br><span class="line">  ret = (*funcptr)(arg0,arg1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// и потом:</span></span><br><span class="line"><span class="comment">//call_in_lua() -&gt; lua_bridge-&gt; (на разные трамплины) trampoline_int__int_charptr-&gt;native(int, char*)</span></span><br></pre></td></tr></table></figure><p>В трамплин передаётся структура, описывающая сигнатуру функции. Делается ради экономии места в бинарнике на сгенерированных скриптовых lua-привязках — вместо создания кода привязки для каждой отдельной функции создаётся трамплин для каждой функции и описания данных для трамплина. Требует одной дополнительной индирекции на каждый вызов функции. Можно даже шарить трамплины между разными привязками к языкам (lua_bridge/python_bridge)</p><p><strong><code>Подсчёт используемой памяти в рантайме</code></strong></p><p>Если для каждого типа знаем его структуру и размер, то можем просуммировать и вывести отчёт с визуализацией</p><p><strong><code>Внешние тулзы для просмотра типов</code></strong></p><ul><li>можно просмотреть, какие типы POD и хорошо сериализуются, а какие требуют runtime-цикла с сериализацией отдельных членов</li><li>по json с описанием типов можно восстановить padding в структурах, визуально</li></ul><p>А также дифф этого из vcs</p><ul><li><a href="/blog/1170009669/" title="Расположение объектов C++ в памяти. Часть 2">Расположение объектов C++ в памяти. Часть 2</a> — другие попытки получить padding в структурах</li></ul><p><strong><code>Передача blob-а и десериализация в другом процессе</code></strong><br>Данные из игры выдёргиваются и передаются в программу отладки физики</p><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"Ov23liG1mZbiQOIdi91X","clientSecret":"e05812685eb741a752982b89dcf6f5b58dc10251","repo":"https://github.com/spiiin/spiiin.github.io","owner":"spiiin","admin":["spiiin"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;Пара докла
      
    
    </summary>
    
    
    
      <category term="cpp" scheme="http://spiiin.github.io/tags/cpp/"/>
    
      <category term="dev_method" scheme="http://spiiin.github.io/tags/dev-method/"/>
    
      <category term="link" scheme="http://spiiin.github.io/tags/link/"/>
    
      <category term="llvm" scheme="http://spiiin.github.io/tags/llvm/"/>
    
  </entry>
  
  <entry>
    <title>C++ computational quadrants</title>
    <link href="http://spiiin.github.io/blog/2220953486/"/>
    <id>http://spiiin.github.io/blog/2220953486/</id>
    <published>2024-05-19T20:11:42.000Z</published>
    <updated>2024-06-01T19:03:39.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><ul><li><a href="/blog/4174799834/" title="C++ Metaprogramming - ссылки">C++ Metaprogramming - ссылки</a> — ссылки по метапрограммированию в C++</li></ul><p>Увидел в доках <a href="https://boostorg.github.io/hana/" target="_blank" rel="noopener">boost.hana</a> разделение типов вычислений в C++ на 4 типа (я не понимаю, как Louis Dionne сложил их в квадранты). Ну и, соответственно, внутри C++ существует 4 языка для того, чтобы описывать эти типы вычислений.</p><p><strong><code>1. Runtime computations</code></strong> — “usual computations”. Примитивы для таких вычислений — рантайм контейнеры, функции и алгоритмы (std как пример базового фреймворка)</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [](<span class="keyword">int</span> i) -&gt; <span class="built_in">std</span>::<span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">std</span>::to_string(i * i);</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ints&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::transform(ints.begin(), ints.end(), <span class="built_in">std</span>::back_inserter(strings), f);</span><br></pre></td></tr></table></figure><p><strong><code>2. Constexpr computations</code></strong> — constexpr вычисления компилятором. Синтаксис для таких вычислений поддерживается максимально похожим на C++. Можно воспринимать их, как код для отдельной ограниченной платформы (компилятора), которая не поддерживает выделение памяти или исключения. (<a href="https://github.com/bolero-MURAKAMI/Sprout" target="_blank" rel="noopener">Sprout</a> — пример библиотеки контейнеров, функций и алгоритмов для таких вычислений)</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n == <span class="number">0</span> ? <span class="number">1</span> : n * factorial(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="built_in">std</span>::<span class="keyword">size_t</span> N, <span class="keyword">typename</span> F&gt;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="built_in">std</span>::<span class="keyword">invoke_result_t</span>&lt;F, T&gt;, N&gt;</span><br><span class="line">transform(<span class="built_in">std</span>::<span class="built_in">array</span>&lt;T, N&gt; <span class="built_in">array</span>, F f) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">constexpr</span> <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 4&gt; ints&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 4&gt; facts = transform(ints, factorial);</span><br></pre></td></tr></table></figure><p><strong><code>3. Heterogeneous computations</code></strong> — гетерогенные вычисления. Работа с суммами  и произведениями типов(<code>std::variant/std::tuple/std::any</code>). <a href="https://www.boost.org/doc/libs/1_80_0/libs/fusion/doc/html/" target="_blank" rel="noopener">Boost.Fusion</a> как пример библиотеки.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> to_string = [](<span class="keyword">auto</span> t) &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">stringstream</span> ss;</span><br><span class="line">  ss &lt;&lt; t;</span><br><span class="line">  <span class="keyword">return</span> ss.str();</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">fusion::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">float</span>&gt; seq&#123;<span class="number">1</span>, <span class="string">"abc"</span>, <span class="number">3.4f</span>&#125;;</span><br><span class="line">fusion::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;</span><br><span class="line">  strings = fusion::transform(seq, to_string);</span><br></pre></td></tr></table></figure><p><strong><code>4. Type-level computations</code></strong> — вычисления над типами. <a href="https://www.boost.org/doc/libs/1_85_0/libs/mpl/doc/index.html" target="_blank" rel="noopener">Boost.MPL</a> как пример библиотеки</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">add_const_pointer</span> &#123;</span></span><br><span class="line">  <span class="keyword">using</span> type = T <span class="keyword">const</span>*;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> types = mpl::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>, <span class="keyword">char</span>, <span class="keyword">float</span>, <span class="keyword">void</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pointers = mpl::transform&lt;types, add_const_pointer&lt;mpl::_1&gt;&gt;::type;</span><br></pre></td></tr></table></figure><h2><span id="optimizacii">Оптимизации</span><a href="#optimizacii" class="header-anchor">#</a></h2><p><a href="https://youtu.be/EtU4RDCCsiU?si=xZPfpHsV06l5B1gz&amp;t=570" target="_blank" rel="noopener">C++Now 2017: Odin Holmes “Type Based Template Metaprogramming is Not Dead”</a> — доклад про оптимизацию вычислений над типами (<code>Rule of Chiel</code>). Для compile-time вычислений таким заморачиваются редко, нужно хорошо представлять себе, что приблизительно должен сделать под капотом компилятор, раскрывая тот или иной шаблонный код. Без такого представления время компиляции и размер выходного кода становятся непредсказумыми (точнее, предсказумо большими).</p><p><a href="https://stackoverflow.com/questions/2351148/explicit-template-instantiation-when-is-it-used" target="_blank" rel="noopener">Explicit template instantiation - when is it used?</a> — явная специализация шаблонов как приём оптимизации.</p><ul><li><a href="/blog/1465137776/" title="Профилирование размера программы">Профилирование размера программы</a> — замеры и оптимизации размера бинарника (борьба с кодом шаблонов и инлайнгом).</li></ul><h2><span id="obshchee">Общее</span><a href="#obshchee" class="header-anchor">#</a></h2><p><a href="https://www.youtube.com/watch?v=NNU6cbG96M4" target="_blank" rel="noopener">Don’t constexpr All the Things - David Sankel CppNow 2021</a> — обзор ограничений constexpr computations. И идеи по замене ограниченного языка constexpr на полноценный язык времени компиляции равный языку времени выполнения (не C++).</p><p><a href="https://github.com/boostcon/2010_presentations/raw/master/mon/instantiations_must_go.pdf" target="_blank" rel="noopener">Matt Calabrese, Zachary Laine: Instantiations Must Go!</a> — слайды про то, как трансформировать синтаксис type-level computations в Heterogeneous computations (на 1 внутренний язык в c++ меньше), основная идея Boost.Hana.</p><p><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0633r0.pdf" target="_blank" rel="noopener">Exploring the design space of metaprogramming and reflection</a> — варианты дизайна рефлексии в C++ через Type syntax/Heterogeneous value/Homogeneous value syntax (2,3 и 4 “квадранты”)<br><a href="https://youtu.be/NWIsRFDaHhs?si=kwX_viciHp91AwK0&amp;t=850" target="_blank" rel="noopener">Reflection in C++ Next - Anton Bikineev - Meeting C++ 2017</a> — тайминг доклада с примерами реализаций этими способами</p><p><a href="https://youtu.be/tcyb1lpEHm0?si=PgwOTQ-cc_LkpIv5&amp;t=2367" target="_blank" rel="noopener">The next big Thing - Andrei Alexandrescu - Meeting C++ 2018 Opening Keynote</a> — (тайминг) Александреску рассказывает про интроспецию с видом человека, который её придумал. В его терминологии это генерация произвольного кода во время компиляции. Input - чтение любого кода (в proposals), processing - выполнение любого кода в compile-time (wip), output - генерация любого кода (отсутствует совсем).</p><h2><span id="za-predelami-c">За пределами C++</span><a href="#za-predelami-c" class="header-anchor">#</a></h2><ul><li><a href="/blog/4109146319/" title="daScript macro-3">daScript macro-3</a> — работа с AST языка, как базовый способ метапрограммирования без создания <a href="https://probablydance.com/2015/02/16/ideas-for-a-programming-language-part-3-no-shadow-worlds/" target="_blank" rel="noopener">теневых миров</a></li><li><a href="/blog/3121981810/" title="Важность простых языков">Важность простых языков</a> — маленькие языки проще и для работы с ними на мета-уровне</li></ul><p><a href="https://ikrima.dev/dev-notes/clang/clang-libtooling-ast/" target="_blank" rel="noopener">Clang/LibTooling AST Notes</a> — интерфейсы к Clang для работы с AST. Метапрограммирование не “на C++”, а “с использованием C++”, без ожидания принятия стандартов, их имплементации, и миграции библиотек.</p><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"Ov23liG1mZbiQOIdi91X","clientSecret":"e05812685eb741a752982b89dcf6f5b58dc10251","repo":"https://github.com/spiiin/spiiin.github.io","owner":"spiiin","admin":["spiiin"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;ul&gt;
&lt;li&gt;&lt;a h
      
    
    </summary>
    
    
    
      <category term="cpp" scheme="http://spiiin.github.io/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>Профилирование размера программы</title>
    <link href="http://spiiin.github.io/blog/1465137776/"/>
    <id>http://spiiin.github.io/blog/1465137776/</id>
    <published>2024-05-15T21:49:45.000Z</published>
    <updated>2024-05-19T15:09:36.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Старый, но местами по прежнему актуальный цикл статей от авторов Despair Engine (F.E.A.R. 3) (<a href="https://gamearchitect.net/2008/04/15/an-anatomy-of-despair-introduction/" target="_blank" rel="noopener">An Anatomy of Despair: Introduction</a>)</p><p>Автор выделяет 2 школы писателей игровых движков.</p><p><strong><code>Low-level Faction</code></strong> - работающие с ранними консолями типа PS1 и DreamCast, работающие close to metal, избегая лишних абстракций и ориентирующиеся больше на тюнинг кода игры, а не движка. Майк Актон с его “<strong>Software isn’t platofrm, hardware is platform!</strong>“ как представитель этой школы. <code>Halo</code> как пример.</p><p><strong><code>Abstraction Faction</code></strong> - автор приводит сюда Epic с их “отдадим 10% производительности за 50% ускорения в создании контекта” из доклада Тима Суини, и их блюпринты (хотя не совсем корректно считать такие небольшие отступления прямо согласием использовать абстракции, достаточно посмотреть на разницу их рендера для ios и android, <strong>hardware definitively is platform!</strong>). <code>Gear of War</code> как пример игры.</p><p><em>Выбор фракции частично зависит не от идеологии разработчиков, а от волн развития технологий — на ранних стадиях на платформах может не быть нормальной стандартной библиотеки, или нестандартное железо, а на поздних — можно позволить себе занять свободные ресурсы системы</em></p><p><em>Код у представителей обеих факций ОЧЕНЬ разный, но обвешать абстракциями low-level код сильно проще, чем выбросить abstraction, когда ими обмазано всё. Сложно вытащить клоунов из набитой ими машины, лучше их туда не пускать - <a href="https://youtu.be/p65Yt20pw0g?t=112" target="_blank" rel="noopener">ссылка</a></em></p><p>Сам движок <code>Despair</code> использовал шаблоны, контейнеры stl и куски boost. Отчасти последствие такого выбора — в блоге его коллеги, треть которого посвящена тому, как сделать, чтобы бинарник хоть как-то вмещался в память. Цикл статей полезен и сейчас, для таких же апологетов абстракций.</p><p><img src="/blog/1465137776/barbar_small.png" alt><br><em>если я заплатил за телефон с 4 гигабайтами оперативки, то моя программа должна использовать все 4</em></p><blockquote><p>Very few programmers, in my experience, really think about what the compiler and linker are doing with the code they write.  They design their code in C++, they write their code in C++, and of course they debug their code in C++.  Their view of the programs they write begins and ends at that level, which is certainly understandable since there is more than enough to worry about in C++ alone.</p></blockquote><p><a href="http://gameangst.com/?p=226" target="_blank" rel="noopener">http://gameangst.com/?p=226</a> Minimizing Code Bloat: Template Overspecialization<br><a href="http://gameangst.com/?p=212" target="_blank" rel="noopener">http://gameangst.com/?p=212</a> Minimizing Code Bloat: Excessive Inlining<br><a href="http://gameangst.com/?p=222" target="_blank" rel="noopener">http://gameangst.com/?p=222</a> Minimizing Code Bloat: Static Allocations<br><a href="http://gameangst.com/?p=224" target="_blank" rel="noopener">http://gameangst.com/?p=224</a> Minimizing Code Bloat: Incorrect Inlining<br><a href="http://gameangst.com/?p=246" target="_blank" rel="noopener">http://gameangst.com/?p=246</a> Minimizing Code Bloat: Redundant Template Instantiation (extern templates)</p><p>Чуть более поздние исследования и тулзы:<br><a href="https://aras-p.info/projSizer.html" target="_blank" rel="noopener">https://aras-p.info/projSizer.html</a> - лид-программист Unity<br><a href="https://github.com/MolecularMatters/raw_pdb" target="_blank" rel="noopener">https://github.com/MolecularMatters/raw_pdb</a> - от авторов мертвого уже движка <a href="https://blog.molecular-matters.com/" target="_blank" rel="noopener">Molecule Engine</a> (блог местами тоже хорош)</p><p><a href="https://github.com/google/bloaty" target="_blank" rel="noopener">https://github.com/google/bloaty</a> - гугловая мерялка (dwarf, экспериментально exe и wasm)<br><a href="https://github.com/microsoft/SizeBench" target="_blank" rel="noopener">https://github.com/microsoft/SizeBench</a> - и microsoft (по pdb)<br><a href="https://github.com/surma/wasmphobia" target="_blank" rel="noopener">https://github.com/surma/wasmphobia</a> - wasm build size viewer as flamegraph (<a href="/blog/2779627234/" title="Flamegraphs">Flamegraphs</a> — вообще везде хороши)</p><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"Ov23liG1mZbiQOIdi91X","clientSecret":"e05812685eb741a752982b89dcf6f5b58dc10251","repo":"https://github.com/spiiin/spiiin.github.io","owner":"spiiin","admin":["spiiin"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;Старый, но
      
    
    </summary>
    
    
    
      <category term="cpp" scheme="http://spiiin.github.io/tags/cpp/"/>
    
      <category term="dev_method" scheme="http://spiiin.github.io/tags/dev-method/"/>
    
      <category term="link" scheme="http://spiiin.github.io/tags/link/"/>
    
  </entry>
  
  <entry>
    <title>daScript - binding tricks 2</title>
    <link href="http://spiiin.github.io/blog/1528253159/"/>
    <id>http://spiiin.github.io/blog/1528253159/</id>
    <published>2024-04-03T12:35:05.000Z</published>
    <updated>2024-04-03T11:17:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><ul><li><a href="/blog/1908536621/" title="daScript - binding tricks">daScript - binding tricks</a></li></ul><p>Ещё несколько примеров байндингов типов из <code>C++</code> и <code>daScript</code>.</p><h2><span id="standart-layout-struktury">Standart-layout структуры</span><a href="#standart-layout-struktury" class="header-anchor">#</a></h2><p>Пустой базовый класс C++:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> hidden;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMyClass</span><span class="params">(<span class="keyword">const</span> MyClass&amp; a)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a.hidden &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>(переменная hidden — просто для проверок, что класс инициализирован)</p><p>Привязка его к daScript:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyClassAnnotation</span> <span class="title">final</span> :</span> ManagedStructureAnnotation&lt;MyClass&gt; &#123;</span><br><span class="line">    MyClassAnnotation(ModuleLibrary&amp; ml) : ManagedStructureAnnotation(<span class="string">"MyClass"</span>, ml) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">MAKE_TYPE_FACTORY(MyClass, MyClass);</span><br></pre></td></tr></table></figure><p>..и добавление в модуль</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Module_Tutorial</span> :</span> <span class="keyword">public</span> Module &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Module_Tutorial() : Module(<span class="string">"tutorial"</span>) &#123;   <span class="comment">// module name, when used from das file</span></span><br><span class="line">        <span class="function">ModuleLibrary <span class="title">lib</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">        lib.addBuiltInModule();</span><br><span class="line"></span><br><span class="line">        addAnnotation(make_smart&lt;MyClassAnnotation&gt;(lib));</span><br><span class="line">        addCtorAndUsing&lt;MyClass&gt;(*<span class="keyword">this</span>, lib, <span class="string">"MyClass"</span>, <span class="string">"MyClass"</span>);</span><br><span class="line">        addExtern&lt;DAS_BIND_FUN(printMyClass)&gt;(*<span class="keyword">this</span>, lib, <span class="string">"printMyClass"</span>, SideEffects::worstDefault, <span class="string">"printMyClass"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">REGISTER_MODULE(Module_Tutorial);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">//где-то в регистрации модулей</span></span><br><span class="line">NEED_MODULE(Module_Tutorial);</span><br></pre></td></tr></table></figure><p>определение <code>ManagedStructureAnnotation</code> выглядит как:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> OT,</span><br><span class="line">    <span class="keyword">bool</span> canNew = is_default_constructible&lt;OT&gt;::value,</span><br><span class="line">    <span class="keyword">bool</span> canDelete = canNew &amp;&amp; is_destructible&lt;OT&gt;::value</span><br><span class="line">&gt; struct ManagedStructureAnnotation ;</span><br></pre></td></tr></table></figure><p>Это структура разбирает данные о типе <code>OT</code> с помощью <code>std::type_traits</code> и устанавливает его свойства, на основе которых daScript знает, что можно/нельзя делать с типом.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">hasNonTrivialCtor</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !is_trivially_constructible&lt;OT&gt;::value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">hasNonTrivialDtor</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !is_trivially_destructible&lt;OT&gt;::value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">hasNonTrivialCopy</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span>  !is_trivially_copyable&lt;OT&gt;::value</span><br><span class="line">        ||  !is_trivially_copy_constructible&lt;OT&gt;::value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">isPod</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> is_standard_layout&lt;OT&gt;::value &amp;&amp; is_trivial&lt;OT&gt;::value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">canMove</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !hasNonTrivialCopy();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">canCopy</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !hasNonTrivialCopy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Пока всё тривиально, <code>MyClass</code> — standart layout структура, не требующая дополнительной инициализации.<br><figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//объявления на стеке</span></span><br><span class="line">var c1 = [[MyClass]] </span><br><span class="line">var c2 = MyClass()</span><br><span class="line">var c3 : MyClass</span><br><span class="line">printMyClass(c1) <span class="comment">//0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//или на хипе</span></span><br><span class="line">var c4 = <span class="keyword">new</span> MyClass()</span><br><span class="line">printMyClass<span class="comment">(*c4) //0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//или создание временного объекта с помощью идиомы using:</span></span><br><span class="line"><span class="comment">using() &lt;| $ ( var c5: MyClass# )</span></span><br><span class="line"><span class="comment">    printMyClass(c5) //0</span></span><br></pre></td></tr></table></figure></p><h2><span id="non-standart-layout-klassy">Non standart layout классы</span><a href="#non-standart-layout-klassy" class="header-anchor">#</a></h2><p>Попробуем добавить в класс что-нибудь, что потребует его инициализации:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> hidden = <span class="number">42</span>; <span class="comment">//инициализация члена</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> str; <span class="comment">//non-stardary layout член</span></span><br><span class="line">    MyClass(<span class="keyword">const</span> MyClass&amp; other) : str(other.str) &#123;&#125; <span class="comment">//copy-ctor</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">virtualFunction</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;&#125; <span class="comment">//virtual function</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    MyClass(<span class="keyword">const</span> <span class="keyword">char</span>* data): str(data) &#123;&#125;</span><br><span class="line">    MyClass() = <span class="keyword">default</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">//привязки</span></span><br><span class="line">addCtorAndUsing&lt;MyClass, <span class="keyword">const</span> <span class="keyword">char</span>*&gt;(*<span class="keyword">this</span>, lib, <span class="string">"MyClass"</span>, <span class="string">"MyClass"</span>)-&gt;args(&#123; <span class="string">"str"</span> &#125;);</span><br><span class="line">addCtorAndUsing&lt;MyClass, <span class="keyword">const</span> MyClass&amp;&gt;(*<span class="keyword">this</span>, lib, <span class="string">"MyClass"</span>, <span class="string">"MyClass"</span>)-&gt;args(&#123; <span class="string">"other"</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> _method_100 = das::das_call_member&lt; <span class="keyword">void</span>(MyClass::*)() <span class="keyword">const</span>, &amp;MyClass::virtualFunction &gt;;</span><br><span class="line">makeExtern&lt;DAS_CALL_METHOD(_method_100), SimNode_ExtFuncCall&gt;(lib, <span class="string">"virtualFunction"</span>, <span class="string">"das::das_call_member&lt; void(MyClass::*)(), &amp;MyClass::virtualFunction &gt;::invoke"</span>)</span><br><span class="line">    -&gt;addToModule(*<span class="keyword">this</span>, SideEffects::worstDefault);</span><br></pre></td></tr></table></figure><p>Байндинг класса при перекомпиляции “увидит”, что теперь класс нетривиальный, и правильно переопределит его свойства. Теперь класс не может быть локальным, не может быть скопирован или перемещён:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canCopy</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canMove</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLocal</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br></pre></td></tr></table></figure></p><p>Соотвественно, тот же код на daScript выдаст ошибки компиляции, при попытке создать класс без инициализации:<br><figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//можно создать класс на хипе:</span></span><br><span class="line">var a &lt;- <span class="keyword">new</span> MyClass(<span class="string">"hello heap"</span>)</span><br><span class="line">printMyClass( *a ) <span class="comment">//42</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//можно создать временный объект с помощью using:</span></span><br><span class="line">using(<span class="string">"hello temp"</span>) &lt;| $(var c5: MyClass explicit)</span><br><span class="line">    printMyClass(c5) <span class="comment">//42</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//можно создать временный объект на стеке и передать его в качестве параметра</span></span><br><span class="line"><span class="comment">//(конструктор класса ничем не отличается от обычной функции)</span></span><br><span class="line">printMyClass(MyClass(<span class="string">"hello temp"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//нельзя создать объект, требующий перемещения (массив из одного элемента)</span></span><br><span class="line">printMyClass([[MyClass()]])</span><br><span class="line"><span class="comment">//нельзя переместить объект</span></span><br><span class="line">var c1 &lt;- MyClass()</span><br><span class="line"></span><br><span class="line"><span class="comment">//нельзя скопировать объект</span></span><br><span class="line">var c1 = MyClass()</span><br></pre></td></tr></table></figure></p><p><code>daScript</code> достаточно консервативно определяет, что объект нельзя копировать/перемещать, вообще говоря, если у класса есть конструктор копирования, то его можно разрешить копировать, если просто явно переопределить функцию canCopy в аннотации-обёртке класса</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> isCopyConstructable = <span class="built_in">std</span>::is_copy_constructible&lt;MyClass&gt;::value;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canCopy</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> isCopyConstructable; &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canClone</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> isCopyConstructable; &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canMove</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> isCopyConstructable; &#125;</span><br><span class="line"><span class="comment">//но нельзя создавать локальный переменные, так как они позволяет не инициализировать класс</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLocal</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br></pre></td></tr></table></figure><p><em>Если можно построить объект из другого объекта, то можно и copy/clone/move?</em></p><figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//теперь можно copy/clone/move</span></span><br><span class="line">var a &lt;- <span class="keyword">new</span> MyClass(<span class="string">"hello heap"</span>)</span><br><span class="line">var b = <span class="keyword">new</span> MyClass()</span><br><span class="line">*b = *a</span><br><span class="line">*b := *a</span><br><span class="line">*b &lt;- *a</span><br></pre></td></tr></table></figure><p>Также в unsafe блоке теперь можно делать небезопасные, но интересные штуки:<br><figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> Params</span><br><span class="line">    a: MyClass</span><br><span class="line">unsafe</span><br><span class="line">    <span class="comment">//создаём локальную переменную на стеке</span></span><br><span class="line">    var m = MyClass(<span class="string">"hello_local"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//создаём контейнер неинициализированных объектов</span></span><br><span class="line">    <span class="comment">//  которые можно построить позже в этой памяти</span></span><br><span class="line">    <span class="comment">//  (аналог placement new в c++)</span></span><br><span class="line">    var n = [[MyClass(m)]]</span><br><span class="line"></span><br><span class="line">    <span class="comment">//создаём структуру из неинициализированных объектов</span></span><br><span class="line">    <span class="comment">//( аналог stackframe)</span></span><br><span class="line">    var s : Params</span><br><span class="line">    printMyClass(s.a)</span><br><span class="line">    <span class="comment">//s.a |&gt; virtualFunction() //пока нельзя обращаться к объекту</span></span><br><span class="line">    s.a &lt;- MyClass(<span class="string">"hello_local"</span>)</span><br><span class="line">    s.a |&gt; virtualFunction() <span class="comment">//vtable инициализирована</span></span><br><span class="line">    printMyClass(s.a) <span class="comment">//42</span></span><br></pre></td></tr></table></figure></p><h2><span id="argumenty-i-rezultaty">Аргументы и результаты</span><a href="#argumenty-i-rezultaty" class="header-anchor">#</a></h2><p>Если попытаться привязать такую функцию:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">functionWithClassArgument</span><span class="params">(MyClass a)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><br>компилятор начнёт ругаться на то, что не определён шаблон <code>cast_arg&lt;MyClass&gt;::to</code>. daScript-функции представляют свои аргументы и результаты в виде 128-битного типа <code>vec4f</code>, так что для кастомных типов необходимо описать способ преобразования с помощью частичной специализации этого шаблона.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">cast_arg</span>&lt;MyClass&gt; &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> __forceinline <span class="keyword">const</span> MyClass&amp; <span class="title">to</span><span class="params">(Context&amp; ctx, SimNode* node)</span> </span>&#123;</span><br><span class="line">        vec4f res = node-&gt;eval(ctx);</span><br><span class="line">        <span class="keyword">return</span> *cast&lt;MyClass*&gt;::to(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Другие примеры возможных способов определения преобразования:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//если тип standart-layout и меньше 128 байт -- можно просто скопировать память</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">cast_arg</span>&lt;const ImVec2 &amp;&gt; &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> __forceinline ImVec2 <span class="title">to</span> <span class="params">( Context &amp; ctx, SimNode * node )</span> </span>&#123;</span><br><span class="line">        vec4f res = node-&gt;eval(ctx);</span><br><span class="line">        ImVec2 v2;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;v2,&amp;res,<span class="keyword">sizeof</span>(ImVec2));</span><br><span class="line">        <span class="keyword">return</span> v2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//для типов-хэндлеров можно указать способ приведения хэндлера к какому-нибудь базовому типу</span></span><br><span class="line"><span class="comment">//  (каст указателей можно рассматривать как частный случай хэндлеров, уже определенных явно)</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">cast_arg</span>&lt;ax::NodeEditor::NodeId&gt; &#123;</span></span><br><span class="line">    <span class="keyword">static</span> __forceinline ax::<span class="function">NodeEditor::NodeId <span class="title">to</span> <span class="params">( Context &amp; ctx, SimNode * node )</span> </span>&#123;</span><br><span class="line">        vec4f res = node-&gt;eval(ctx);</span><br><span class="line">        <span class="keyword">return</span> ax::NodeEditor::NodeId(cast&lt;<span class="keyword">int32_t</span>&gt;::to(res));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">cast_res</span>&lt;ax::NodeEditor::NodeId&gt; &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> __forceinline vec4f <span class="title">from</span> <span class="params">( ax::NodeEditor::NodeId node, Context * )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cast&lt;<span class="keyword">int32_t</span>&gt;::from(<span class="keyword">int32_t</span>(node.Get()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//для типов-прокси можно определить способ построения прокси из базового типа/извлечения базового типа</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">cast_arg</span>&lt;const sf::String &amp;&gt; &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> __forceinline sf::String <span class="title">to</span> <span class="params">( Context &amp; ctx, SimNode * node )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> * pstr = node-&gt;evalPtr(ctx);</span><br><span class="line">        <span class="keyword">return</span> sf::String(pstr ? pstr : <span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">cast_res</span>&lt;sf::String&gt; &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> __forceinline vec4f <span class="title">from</span> <span class="params">( <span class="keyword">const</span> sf::String &amp; str, Context * context )</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> text = context-&gt;stringHeap-&gt;allocateString(str);</span><br><span class="line">        <span class="keyword">return</span> cast&lt;<span class="keyword">char</span> *&gt;::from(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Из пары примеров выше видно, что для привязки функций, возвращающих тип в качестве результата, необходимо определить специализацию шаблона <code>cast_res</code> с функцией <code>from</code>. Это верно для standard layout структур, но для сложного класса (с созданием временного объекта на хипе, по аналогии с sf::String) daScript бросает assert:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">addExtern(getMyClass_ExtFuncCall)::failed</span><br><span class="line">  this function should be bound with addExtern&lt;DAS_BIND_FUNC(getMyClass_ExtFuncCall), SimNode_ExtFuncCallAndCopyOrMove&gt;</span><br><span class="line">  likely cast&lt;&gt; is implemented for the return type, and it should not</span><br></pre></td></tr></table></figure><p>говорит этот ассерт о том, что вместо того, чтобы создавать временный объект, что тормознуто, лучше использовать специальную ноду языка, которая возвращает уже созданный объект. Такое себе принуждение к оптимизации.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">    <span class="function">MyClass <span class="title">getMyClass</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> _method_2 = das::das_call_member&lt; MyClass(MyClass::*)() <span class="keyword">const</span>, &amp;MyClass::getMyClass &gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//makeExtern&lt;DAS_CALL_METHOD(_method_2), SimNode_ExtFuncCall &gt;(lib, "getMyClass_ExtFuncCall", "das::das_call_member&lt; MyClass(MyClass::*)() const, &amp;MyClass::getMyClass &gt;::invoke")</span></span><br><span class="line"><span class="comment">//    -&gt;addToModule(*this, SideEffects::worstDefault); //work with pod type, but not if type has something not trivial</span></span><br><span class="line"></span><br><span class="line">makeExtern&lt;DAS_CALL_METHOD(_method_2), SimNode_ExtFuncCallAndCopyOrMove &gt;(lib, <span class="string">"getMyClass_ExtFuncCallAndCopyOrMove"</span>, <span class="string">"das::das_call_member&lt; MyClass(MyClass::*)() const, &amp;MyClass::getMyClass &gt;::invoke"</span>)</span><br><span class="line">    -&gt;addToModule(*<span class="keyword">this</span>, SideEffects::worstDefault);</span><br></pre></td></tr></table></figure><p>Теперь в daScript можно использовать эти функции:</p><figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">functionWithClassArgument(MyClass(<span class="string">"hello arg"</span>))</span><br><span class="line">MyClass(<span class="string">"hello res"</span>)|&gt; getMyClass_ExtFuncCallAndCopyOrMove()</span><br></pre></td></tr></table></figure><h2><span id="reflection-over-c">Reflection over C++</span><a href="#reflection-over-c" class="header-anchor">#</a></h2><p>Вся эта шаблонная магия привязок генерится не руками, а генератором привязок <a href="https://github.com/GaijinEntertainment/daScript/tree/master/modules/dasClangBind/bind" target="_blank" rel="noopener">dasClangBind</a>. Распознавание инфы о типах сделано на уровне самого кода daScript, а не генератора, чтобы сам код генератора и сгенерированный код был более простым и однообразным. Но все примеры обёрток, сделанные <code>dasClingBind</code>, сделаны для библиотек с C-интерфейсом, которые почти не требуют ручного вмешательства. Но как только дело доходит до реального C++ кода, вылезает всё и сразу. Описанные в статье приёмы позволяют побороть большую часть сложности, и нагенерировать что-нибудь серьёзное, типа привязок классов <code>Unreal Engine</code> (с небольшими доработками напильником).</p><p>Примеры привязок либ с c-интерфейсом через <code>dasClangBind</code>:</p><ul><li><a href="/blog/4090909622/" title="daScript: C++ auto-bindings, msgpack">daScript: C++ auto-bindings, msgpack</a></li><li><a href="/blog/500729544/" title="daScript: C++ auto-bindings, assimp">daScript: C++ auto-bindings, assimp</a></li></ul><p>Другие подходы:<br><a href="https://floooh.github.io/2020/08/23/sokol-bindgen.html" target="_blank" rel="noopener">Automatic Language Bindings</a> — размышления о способах генерации привязок к языкам от автора sokol gfx (тоже c-style, с помощью clang json)<br><a href="https://medium.com/@eddo2626/lets-learn-zig-4-using-c-libraries-in-zig-5fcc3206f0dc" target="_blank" rel="noopener">Using C Libraries in Zig</a> — прозрачный импорт C из zig. с Си (не С++) вообще все достаточно просто<br><a href="https://scripter.co/binding-nim-to-c-plus-plus-std-list/" target="_blank" rel="noopener">Binding Nim to C++ std::list</a> — читерский подход в nim, без интерпретации и с транспиляцией в C++ можно просто встраивать и использовать куски плюсового кода.<br><a href="https://github.com/seanbaxter/circle" target="_blank" rel="noopener">Circle</a> — “бэтменский” альтернативный компилятор с встроенными compile-time фичами, включая рефлексию. Автор публикует прогресс в <a href="https://twitter.com/seanbax" target="_blank" rel="noopener">твиттере</a><br><a href="https://cppyy.readthedocs.io/en/latest/" target="_blank" rel="noopener">cppyy: Automatic Python-C++ bindings</a> — хардкор с использованием интерактивного компилятора C++ cling, прозрачный парсинг, компиляция и генерация привязок на лету</p><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"Ov23liG1mZbiQOIdi91X","clientSecret":"e05812685eb741a752982b89dcf6f5b58dc10251","repo":"https://github.com/spiiin/spiiin.github.io","owner":"spiiin","admin":["spiiin"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;ul&gt;
&lt;li&gt;&lt;a h
      
    
    </summary>
    
    
    
      <category term="dascript" scheme="http://spiiin.github.io/tags/dascript/"/>
    
  </entry>
  
  <entry>
    <title>daScript macro-3</title>
    <link href="http://spiiin.github.io/blog/4109146319/"/>
    <id>http://spiiin.github.io/blog/4109146319/</id>
    <published>2024-03-30T17:45:51.000Z</published>
    <updated>2024-04-07T10:27:01.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><ul><li><a href="/blog/1547564887/" title="daScript macro">daScript macro</a></li><li><a href="/blog/4046309382/" title="daScript macro - 2">daScript macro - 2</a></li></ul><p>В большинстве языков с развитым мета-программированием существует 2 способа написания макросов — построение синтаксического дерева из кирпичиков (<code>ExprXXX</code>-блоки в daScript), и с помощью цитирования (<code>quote/qmacro_xxx</code>). Примеры генерации каждым из способов — в предыдущей заметке.</p><p>Второй способ более компактный, но приводит к появлению мета-языка для внедрения кусков сгенерённого кода в цитируемый код. Проблема этого языка в том, что он разрастаётся — постепенно появляются различные макросы для деклараций блоков/функций/переменных (<a href="https://dascript.org/doc/reference/language/reification.html#quote-macros" target="_blank" rel="noopener">qmacro macros</a>), различные способы внедрения кусков кода — подстановка выражений/идентификаторов/типа/списков аргументов (<a href="https://dascript.org/doc/reference/language/reification.html#escape-sequences" target="_blank" rel="noopener">escape sequences</a>). Этот встроенный язык (причём частично на низком уровне, в <a href="https://github.com/GaijinEntertainment/daScript/blob/master/src/parser/ds_parser.ypp#L289" target="_blank" rel="noopener">лексический парсер</a>) постепенно усложняется, в попытках охватить весь основной язык. </p><p><a href="https://probablydance.com/2015/02/16/ideas-for-a-programming-language-part-3-no-shadow-worlds/" target="_blank" rel="noopener">Ideas for a Programming Language Part 3: No Shadow Worlds</a> — тут это явление названо “теневыми мирами”.</p><p>Проблема менее заметна в языках с однородный синтаксисом, как в LISP, когда всё представлено в виде списков, или с динамической типизацией, в которых не жалко производительности на вызов полноценного <code>eval</code>, принимающий строку кода и возвращающий строку результата. Всякие движки подстановки (<a href="https://github.com/GaijinEntertainment/daScript/blob/fd5be7b1eabaa2499e362481aa5f5409e07901fc/daslib/templates_boost.das" target="_blank" rel="noopener">templates_boost</a>), которые работают на промежуточном уровне, решают проблему частично — они дают возможность заменять одни куски синтаксического дерева на другие, но своими правилами создают новые теневые миры.</p><p>Пример шаблона, который сейчас не осиливает разобрать <code>templates_boost</code>:</p><figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//PARAMS нельзя сгенерировать кодом и подставить на это место ни одним правилом системы шаблонов</span></span><br><span class="line">var myStruct = [[Struct PARAMS]]</span><br></pre></td></tr></table></figure><p><em>мета-язык ВСЕГДА требует ещё какое-нибудь мелкое расширение</em></p><p><a href="https://github.com/GaijinEntertainment/daScript/blob/master/daslib/spoof.das" target="_blank" rel="noopener">spoof</a> — более мощные текстовые подстановки в daScript с PEG-парсингом (создание ещё одного мета-языка, который тоже будет требовать расширения со временем).</p><p>Собственно, мой поинт в том, чтобы махнуть рукой на несовершенство теневых миров, требующих расширения, и просто часть задач с макросами решать на уровне построения синтаксического дерева “вручную”. Набросал макрос для daScript, который разбирает ast-функции и аннотирует каждую ноду текстом с названием Expr-блока, представляющего эту ноду, чтобы было проще “срисовывать” синтаксическое дерево (похожий на <a href="https://nim-lang.org/docs/macros.html#dumpTree.m%2Cuntyped" target="_blank" rel="noopener">dumpTree</a> в Nim).</p><p>Пример вывода:</p><figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">options optimize = <span class="keyword">false</span> <span class="comment">//отключаем оптимизации, если хотим посмотреть все AST-ноды</span></span><br><span class="line">require expr_print</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> SaySomethingParams</span><br><span class="line">    a, b : int</span><br><span class="line"></span><br><span class="line">def function1()</span><br><span class="line">    var params &lt;- <span class="keyword">new</span> [[SaySomethingParams() a = <span class="number">1</span>, b = <span class="number">2</span>]]</span><br><span class="line">    <span class="keyword">return</span> params</span><br><span class="line"></span><br><span class="line">[export]</span><br><span class="line">def main()</span><br><span class="line">    print_expression(@@function1)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Output:</span></span><br><span class="line">---------Annotated expression---------</span><br><span class="line"><span class="comment">// [nosideeffects]</span></span><br><span class="line">def function1 : SaySomethingParams?</span><br><span class="line">        ExprLet <span class="keyword">let</span> ExprLetVariable params : SaySomethingParams? &lt;- ExprAscend <span class="keyword">new</span> ExprMakeStruct [[SaySomethingParams ExprMakeStructField a = ExprConstInt <span class="number">1</span>, ExprMakeStructField b = ExprConstInt <span class="number">2</span>]]</span><br><span class="line">        ExprReturn <span class="keyword">return</span> ExprVar params</span><br><span class="line">--------------------------------------</span><br></pre></td></tr></table></figure><p>Красивее выглядит в терминале, который понимает цветовый коды:<br><img src="/blog/4109146319/screen_small.png" alt><br><a href="/blog/4109146319/screen.png">full-size</a></p><p>Код<br><a href="https://github.com/spiiin/dascript_print_expression" target="_blank" rel="noopener">https://github.com/spiiin/dascript_print_expression</a></p><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"Ov23liG1mZbiQOIdi91X","clientSecret":"e05812685eb741a752982b89dcf6f5b58dc10251","repo":"https://github.com/spiiin/spiiin.github.io","owner":"spiiin","admin":["spiiin"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;ul&gt;
&lt;li&gt;&lt;a h
      
    
    </summary>
    
    
    
      <category term="dascript" scheme="http://spiiin.github.io/tags/dascript/"/>
    
  </entry>
  
  <entry>
    <title>Push/Pull/Event model, Reactive GUI</title>
    <link href="http://spiiin.github.io/blog/3145708234/"/>
    <id>http://spiiin.github.io/blog/3145708234/</id>
    <published>2024-03-23T16:25:20.000Z</published>
    <updated>2024-03-23T18:18:47.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><h1><span id="push-pull-events-modeli">Push/Pull/Events модели</span><a href="#push-pull-events-modeli" class="header-anchor">#</a></h1><p>Регулярно повторяющаяся задача проектирования — выбор способа взаимодействия вызывающего и вызываемого кода.</p><p><strong><code>Pull-модель</code></strong> — “вам надо, вы и мучаетесь”. Часто реализовывается проще. Вызывающий код в том месте, в котором удобно, запрашивает данные.</p><p>Примеры<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">считывание настроек в стиле &#96;game::get_setting&lt;string&gt;(&quot;blabla&quot;)&#96;</span><br><span class="line">считывание 3D модели через render::load3dmodel(&quot;balbalb.xxx&quot;)</span><br><span class="line">опрос сервера клиентом для получения новых сообщений или обновлений</span><br><span class="line">игровой цикл, где игровой движок &quot;запрашивает&quot; состояние игрока или ввод данных в начале каждого кадра</span><br></pre></td></tr></table></figure><br>Все загрузки, всё определение конфигурации и т.п. - размазано по коду и делается ad hoc.  </p><p><strong><code>Push-модель</code></strong> — “то же самое, но вывернутое наизнанку”. Вам приходит callback/event/change propagation “blabla setting changed old-&gt;new”. В системе жёстко вшито, когда именно происходит событие, и имеется возможность добавить свою реакцию на него.</p><p>Примеры<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">системы реального времени, где сенсоры отправляют данные на сервер или обработчик событий немедленно, как только они доступны</span><br><span class="line">системы уведомлений, где сервер пушит уведомления на устройства клиентов без необходимости запроса со стороны клиента</span><br></pre></td></tr></table></figure></p><p>Все загрузки, конфигурации, управление ресурсами - вынесено наружу, делается более-менее централизованно. Вы регистрируетесь где попало и реагируете на обновления. Зато система без вас знает, когда, как и что делать.</p><p>Место определения колбека отделено от момента его вызова, вызывающий код должен понимать контекст, в котором будет вызван колбек — необходимо ли проверять на существование необходимые колбеку ресурсы, доступны ли они или заняты, безопасно ли создавать или удалять какие-либо типы объектов. Один из самых примитивных примеров — инвалидация итератора stl-контейнера в цикле в c++.</p><p><strong><code>Events-модель</code></strong></p><p>В push-моделях можно встретить элементы pull-модели:</p><ul><li>если объём данных для push большой и может быть не нужен клиентам полностью или сразу, система может только уведомить об изменившихся данных (послать сообщение) и предоставить pull-интерфейс для запроса этих данных, когда будет удобно клиенту</li><li>если удобно отложить обработку данных, коллбек может вместо выполнения работы положить сообщение в очередь. Дальше на клиента ложиться задача спуллить сообщения из очереди и обработать их. Удобно, если необходимо обработать все сообщения вместе. </li></ul><p>Примеры<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">отложенная обработка сгенерированных команд для подсистемы рендера</span><br><span class="line">отложенная обработка сообщений о столкновениях, чтобы проверить, что суммарные силы воздействии на физический объект не разрушат его</span><br></pre></td></tr></table></figure></p><p><a href="http://www.kegel.com/c10k.html" target="_blank" rel="noopener">The C10K problem</a> — взаимодействие большого количества сообщений в ОС.<br><a href="https://bitsquid.blogspot.com/2011/02/managing-decoupling-part-2-polling.html" target="_blank" rel="noopener">Managing Coupling Part 2 — Polling, Callbacks and Events</a> — о push/pull/events модели от дизайнеров движка Stingray</p><h2><span id="patterny-idiomy-uzory">Паттерны/идиомы/узоры</span><a href="#patterny-idiomy-uzory" class="header-anchor">#</a></h2><p>В различных языках или библиотеках идеи и модели могут быть:<br><strong><code>прозрачные для пользователя</code></strong> — доступны в виде примитивов языка<br><strong><code>выражаемые формально</code></strong> — для использования можно переопределить функцию для своего типа/отнаследоваться от языка/написать синтаксический макрос/воспользоваться принятым в языке способом<br><strong><code>выражаемые неформально</code></strong> — для использования необходимо каждый раз повторно реализовывать функционал</p><p>Когда-то паттернами считались процедуры (1957, <a href="https://www.norvig.com/design-patterns/design-patterns.pdf" target="_blank" rel="noopener">Design Patterns in Dynamic Programming</a>) и классы (1972, <a href="https://blog.plover.com/prog/design-patterns.html" target="_blank" rel="noopener">Design patterns of 1972</a>). Прозрачные для пользователя  практически не обсуждаются (или даже не называются!), формально выраженные также часто принимаются как правило хорошего программирования. Разве что когда кому-нибудь не нравится производительность или ограничения в интерфейсе. В этом случае даже прозрачные идиомы могут быть реифицированны и переделаны. Пример — <a href="/blog/1552834708/" title="Runtime-полиморфизм в C++">Runtime-полиморфизм в C++</a>, альтернативный полиморфизм.</p><p>Может показаться, что называть что-то очень простое и примитивное паттерном слишком сёрьзно, но это всего лишь ярлыки.</p><p><a href="https://probablydance.com/2015/06/16/ideas-for-a-programming-language-part-4-reactive-programming/" target="_blank" rel="noopener">Ideas for a Programming Language Part 4: Reactive Programming</a> — про поиск синтаксиса для того, чтобы ввернуть асинхронное программирование в язык прозрачно для пользователя</p><h2><span id="iteratory-kolsteki-korutiny-faybery-dispetchery-asinki-revisited">Итераторы, колстеки, корутины, файберы, диспетчеры, асинки — revisited</span><a href="#iteratory-kolsteki-korutiny-faybery-dispetchery-asinki-revisited" class="header-anchor">#</a></h2><ul><li><a href="/blog/2550823652/" title="Итераторы, колстеки, корутины">Итераторы, колстеки, корутины</a></li><li><a href="/blog/2826376146/" title="Файберы, диспетчеры, асинки">Файберы, диспетчеры, асинки</a></li></ul><p>Две большие статьи выше посвящены, по большому счёту, паттернам работы с коллекциями в различных языках (где-то эти “паттерны” уже вшиты в примитивы языка, где-то их нет и в стандартной библиотеке и приходилось писать самому).</p><p>Всё описанное в статьях можно классифицировать по 4 группам:<br><strong><code>операции с pull-итераторами в синхронных коллекциях</code></strong><br><strong><code>операции с push-итераторами в синхронных коллекциях</code></strong><br><strong><code>операции с pull-итераторами в асинхронных коллекциях</code></strong><br><strong><code>операции с push-итераторами в асинхронных коллекциях</code></strong></p><p>pull-итераторы — c++ stl-итераторы, <a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.ienumerator-1?view=net-8.0" target="_blank" rel="noopener">IEnumerator<t></t></a> C#<br>push-итераторы — колбеки<br>синхронные коллекции — контейнеры<br>асинхронные коллекции — генераторы (могут описывать как space-distributed коллекции, так и time-distributed)</p><p>Как и в общем для pull-моделей, pull-итераторы проще для использования/комбинирования — результаты, возвращаемый pull-итератором — стандартные типы языка, с которым учатся работать с самого начала знакомства с языком.</p><p>Push-итератор не возвращает ничего, и является отложенным вычислением (замыкания/указатели на функции/функциональные объекты). Отложенные вычисленя тоже можно комбинировать, но вместо привычных прикладному программисту на императивных языках способов требуются привычные математикам.</p><p><a href="https://aras-p.info/blog/2018/12/28/Modern-C-Lamentations/" target="_blank" rel="noopener">“Modern” C++ Lamentations</a> — про разницу в синтаксисе и времени компиляции между C++ и C# при работе с лямбдами.<br><a href="https://www.youtube.com/watch?v=6mTbuzafcII" target="_blank" rel="noopener">“Transducers” by Rich Hickey</a> — типичные проблемы комбинирования колбеков, как оторвать комбинирование вычислений от коллекций.</p><p>Даже просто запись цепочки выполняющихся друг за другом после окончания предыдущего колбеков превращается в анти-паттерн <code>callback hell</code> (синтаксический сахар async/await - количество скобок уменьшается)</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//.NET 4</span></span><br><span class="line">Task&lt;<span class="keyword">string</span>&gt; htmlTask = webClient.DownloadStringTaskAsync(url);</span><br><span class="line"><span class="comment">//тот можно выполнить код, которому не требуется результат hmtlTask</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">string</span> html = htmlTask.Result; <span class="comment">//тут блокировка до ожидания результата</span></span><br><span class="line"><span class="comment">//или прикрепить к задаче продолжение</span></span><br><span class="line">htmlTask.ContinueWith(task=&gt; &#123;</span><br><span class="line">  <span class="keyword">string</span> html = task.Result;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//.NET 5</span></span><br><span class="line">Task&lt;<span class="keyword">string</span>&gt; htmlTask = webClient.DownloadStringTaskAsync(url);</span><br><span class="line"><span class="keyword">string</span> html = <span class="keyword">await</span> htmlTask; <span class="comment">//то же что и в прошлом примере с ContinueWith</span></span><br><span class="line">doSomething(html)             <span class="comment">//строки ниже await также "переписываются" внутрь ContinueWith</span></span><br></pre></td></tr></table></figure><p>Паттерн <code>Task</code> (где-то встречается название <code>Future</code>) является обёрткой для асинхронной работы над примитивом. В статьях не хватает разбора способов асинхронной работы с коллекциями (синхронными и асинхронными).</p><h2><span id="obobshcheniya-patterna-task-v-c">Обобщения паттерна Task в C</span><a href="#obobshcheniya-patterna-task-v-c" class="header-anchor">#</a></h2><p><strong><code>pull-based работа синхронными коллекциями</code></strong> — если просто заменить <code>Task&lt;int&gt;</code> на <code>Task&lt;IEnumerable&lt;int&gt;&gt;</code>, то можно использовать <code>await</code> для коллекции, но при этом все элементы коллекции будут собираться синхронно за один вызов, в чём собственно нет особого смысла<br><strong><code>pull-based работа с асинхронными коллекциями</code></strong> — <a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.iasyncenumerable-1?view=net-8.0" target="_blank" rel="noopener"><code>IAsyncEnumerable&lt;T&gt;</code></a> и <code>await foreach</code> позволяет получать элементы коллекции асинхронно<br><strong><code>push-based работа с асинхронными коллекциями</code></strong> — push-вариант работы с асинхронными коллекциями — паттерн <code>Observer</code> (<a href="https://learn.microsoft.com/en-us/dotnet/api/system.iobserver-1?view=net-8.0" target="_blank" rel="noopener"><code>IObserver&lt;T&gt;</code></a> в C#). Если <code>Task</code> представляет собой одно асинхронное событие, то <code>Observable</code> — это асинхронная коллекция (источник) событий, на которые могут подписываться <code>Observer</code>-ы.</p><h2><span id="observable-observer">Observable/Observer</span><a href="#observable-observer" class="header-anchor">#</a></h2><p><code>Observer</code> — давно известный паттерн, популяризованный в GoF, и активно используемый в smalltalk-версии паттерна <code>MVC</code>.<br><a href="https://stlab.cc/tips/about-mvc.html" target="_blank" rel="noopener">How did MVC get so F’ed up?</a> — деградация MVC в языках с не-observable примитивами в качестве модели, мешает композиции.</p><p><code>Observable</code> в C# зовёт 3 метода <code>Observer</code> (<em>продолжение/окончание/ошибка</em>):<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OnCompleted() - последовательность закончилась</span><br><span class="line">OnError(exception) - при генерации данных произошла ошибка</span><br><span class="line">OnNext(value) - было сгенерированно следующее значение</span><br></pre></td></tr></table></figure></p><p><code>Observable</code> можно представить как обобщение примитивного обхода коллекции (синхронной или асинхронной). При этом, как и для примитивного foreach, так и любых более сложных реализаций, должно соблюдаться простое правило: OnCompleted/OnError — это последний колбек, после которого Observable не будет присылать других.</p><p>Паттерн сам по себе не защищен от возможностей кривой композиции, так что периодически появляются теоретические попытки сделать что-то более чистое (но не всегда более простое).<br><a href="https://core.ac.uk/download/pdf/147982753.pdf" target="_blank" rel="noopener">Deprecating the Observer Pattern with Scala.React</a> от Мартина Одерски, умершая либа. Вместо неё сейчас и сам Одерски <a href="https://stackoverflow.com/questions/21546456/what-happened-to-scala-react" target="_blank" rel="noopener">предлагает</a> JavaRx, надстроенную над observer-ами.</p><p><strong><code>Reactive-подход</code></strong><br>Observer имеет те же особенности композиции, что и push-итераторы — близкие математикам или функциональным программистам примитивы, в C# местами завёрнутые в linq-синтаксис.</p><p><a href="https://reactivex.io/" target="_blank" rel="noopener">ReactiveX</a> — библиотека реактивного программирования, набор примитивов для композиции и конвертеров между различными типами итераторов.<br><a href="https://kirkshoop.github.io/introductionToRxcpp" target="_blank" rel="noopener">Introduction to ReactiveX in C++ (rxcpp)</a> — презентация по С++ версии библиотеки, heavy templates-based.<br><a href="https://introtorx.com/chapters/foreword" target="_blank" rel="noopener">Introduction to RX.Net</a> — книга по C# версии.</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//kotlin example</span></span><br><span class="line">getDataFromNetwork()</span><br><span class="line">  .skip(<span class="number">10</span>)</span><br><span class="line">  .take(<span class="number">5</span>)</span><br><span class="line">  .map(&#123; s -&gt; <span class="keyword">return</span> s + <span class="string">" transformed"</span> &#125;)</span><br><span class="line">  .subscribe(&#123; println <span class="string">"onNext =&gt; "</span> + it &#125;)</span><br></pre></td></tr></table></figure><h1><span id="gui">GUI</span><a href="#gui" class="header-anchor">#</a></h1><p>Можно разделить GUI-библиотеки на <code>imperative/declarative</code> и <code>retained/immediate/reactive</code>.</p><h2><span id="imperative-declarative">Imperative/Declarative</span><a href="#imperative-declarative" class="header-anchor">#</a></h2><p><strong><code>Imperative</code></strong> — установка состояние контролов описывается в коде<br><strong><code>Declarative</code></strong> — установка состояния вынесена куда-нибудь в JSON/XML/HTML или в динамический язык (lua/squirrel — бестиповые таблицы + лямбды удобны для описания представления и кода) и загружается с помощью <code>control-&gt;loadFromFile</code>. Из преимуществ — gui можно менять без перекомпиляции, программиста и с помощью тулзы, которая позволяет менять состояние мышкой.</p><p><a href="https://habr.com/ru/articles/719908/" target="_blank" rel="noopener">WPF: контролы лишенные внешнего вида и неразрешимая задача выбора конфигурации темплейта</a> — более развернуто про то, что даёт декларативный подход<br><blockquote><p>Разработчики хотят, чтобы библиотека «угадала» их представление о том, как должен выглядеть и как должен работать тот или иной элемент визуального интерфейса. Соответственно, разработчики, как пользователи библиотеки, оказываются не готовы, что вместо того, чтобы искать готовые компоненты, надо научиться создавать их самому в парадигме того инструментария и тех концепций, которые реализованы в библиотеке.</p></blockquote></p><h2><span id="retained">Retained</span><a href="#retained" class="header-anchor">#</a></h2><p><strong><code>Retained</code></strong> — клиентский код не занимается рендером сам, а заполняет и обновляет модель. Push-модель, очень распространённая в GUI-библиотеках.</p><p>Пример, как может выглядеть код:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">&#125; state;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> window = GUI::createRootWindow();</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> label = GUI::createLabel(<span class="string">"Click counter %d"</span>, state.value);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> button = GUI::createButton();</span><br><span class="line">button-&gt;setText(<span class="string">"Increase counter"</span>);</span><br><span class="line">button-&gt;setClickCallback([]()&#123;</span><br><span class="line">    state.value++;</span><br><span class="line">    <span class="comment">//нужно не забыть руками обновить внутреннее состояние контрола, отображающего значение</span></span><br><span class="line">    label-&gt;updateText(<span class="string">"Click counter %d"</span>, state.value);</span><br><span class="line">&#125;);</span><br><span class="line">window-&gt;addChild(button);</span><br><span class="line"></span><br><span class="line"><span class="comment">//somewhere</span></span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">exit</span>) &#123;</span><br><span class="line">    GUI::updateRootWindow();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Минусы — код обновления состояния модели (всего, что вне GUI), нужно синхронизировать с состоянием GUI.</p><p>Примеры либ - <a href="https://github.com/cegui/cegui" target="_blank" rel="noopener">cegui</a></p><h2><span id="immediate">Immediate</span><a href="#immediate" class="header-anchor">#</a></h2><p><strong><code>Immediate</code></strong> — Pull-подход (“вам надо, вы и рисуйте”), <a href="https://caseymuratori.com/blog_0001" target="_blank" rel="noopener">родившийся</a> в головах гейм-девелоперов. Если “вывернуть” наизнанку логику, и отдать обязанность рисования контролов клиенту, то логика местами станет проще (вместо угадывания потребностей клиента сложность переезжает в клиентский код, и отпадает необходимость синхронизации состояния). Функции рисования не имеют своего состояния, а принимают указатели на данные, которые они могут изменить.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> value;</span><br><span class="line">&#125; state;</span><br><span class="line"></span><br><span class="line">Gui::Begin(<span class="string">"My window"</span>);</span><br><span class="line">Gui::Text(<span class="string">"Counter %d"</span>, state.value);</span><br><span class="line"><span class="keyword">if</span> (Gui::Button(<span class="string">"Increate counter"</span>)) <span class="comment">//without explicit callback function</span></span><br><span class="line">    state.value++;</span><br><span class="line">Gui::End();</span><br></pre></td></tr></table></figure><p>Примеры либ — <code>Unity Imgui, Dear Imgui, Nuklear</code>.</p><h2><span id="reactive">Reactive</span><a href="#reactive" class="header-anchor">#</a></h2><p>Если под рукой есть язык или библиотека, который может описать зависимости между данными, то можно было бы устранить недостаток retained gui без перехода к immediate.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    GUI::MagicObservable&lt;<span class="keyword">int</span>&gt; value; <span class="comment">//при изменении уведомлять всех наблюдателей</span></span><br><span class="line">&#125; state;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> window = GUI::createRootWindow();</span><br><span class="line"><span class="keyword">auto</span> label = GUI::createLabel(<span class="string">"Click counter %d"</span>, state.value);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> button = GUI::createButton();</span><br><span class="line">button-&gt;setText(<span class="string">"Increase counter"</span>);</span><br><span class="line">button-&gt;setClickCallback([]()&#123;</span><br><span class="line">    <span class="comment">//обновляем значение, observer уведомит об изменении все контролы. Прямого обновления label в коде больше нет</span></span><br><span class="line">    GUI::updateObservable(state.value); </span><br><span class="line">&#125;);</span><br><span class="line">window-&gt;addChild(button);</span><br></pre></td></tr></table></figure><p>Примеры либ — <code>knockout.js, rivets</code> для js, <a href="https://www.reactiveui.net/" target="_blank" rel="noopener">ReactiveUI</a> для C#,  <a href="https://github.com/tetsurom/rxqt" target="_blank" rel="noopener">rxqt</a> для C++.<br><a href="https://www.youtube.com/watch?v=_d65qS0GzWM" target="_blank" rel="noopener">MIX11 Knockout JS Helping you build dynamic JavaScript UIs with MVVM and ASP NET</a> — knockout.js demo<br><a href="https://knockoutjs.com/documentation/computed-dependency-tracking.html" target="_blank" rel="noopener">How dependency tracking works</a> — knockout.js how it works</p><p>Knockout.js использует тривиальный динамический метод ослеживания зависимостей.</p><ul><li>Когда объявляется observable, вычисляется его initial-значение.</li><li>В ходе вычисления, устанавливается подписка на любые другие observables (включая computed observables), значения которых читаются (язык должен поддерживать хук на чтение значений). Подписка означает, что будет вызвано вычисление этого observable (шаг 1), при этом любые старые подписки удаляются.</li><li>После завершения вычисления, вызываются все подписки о том, что новое значение этого observable доступно.<br>Так что зависимости не вычисляются при первом запуске и их не нужно объявлять, они просто перерасчитываются каждый раз при обновлении, и могут изменяться динамически. Если эвалуатор observable не читает ни одного другого observable, от которого он зависит, то повторное вычисление никогда не произойдёт, и сам эвалуатор может быть заменён на вычисленное значение.</li><li>Декларативные биндинги данных к состоянию контролов — это просто computed observables.</li></ul><p><a href="https://habr.com/ru/articles/303650/" target="_blank" rel="noopener">Введение в ReactiveUI: прокачиваем свойства во ViewModel</a> — В C# -&gt; WPF + XAML бекэнд + RX.Net для описания зависимостей + ReactiveUI.Fody для генерации</p><h2><span id="reactive-gui-na-c-i-geymdeve">Reactive Gui на C++ и геймдеве</span><a href="#reactive-gui-na-c-i-geymdeve" class="header-anchor">#</a></h2><p>Систему реактивного GUI можно разделить на 4 части:</p><ul><li>язык реализации (и, возможно, расширения) системы (C++)</li><li>язык для декларативного описания gui и байндингов контролов к данным</li><li>язык для описания скриптового поведения контролов (если хотим декларативно описывать поведение — в C++ сложно с рефлексией и интерпретацией кода)</li><li>тулза для визуального изменения декларативного описания</li></ul><p><a href="https://ru.wikipedia.org/wiki/Model-View-ViewModel" target="_blank" rel="noopener">Model-View-ViewModel</a><br><a href="https://guide.elm-lang.org/architecture/" target="_blank" rel="noopener">The Elm Architecture</a></p><p>Примеры Reactive GUI для геймдева встречаются не очень часто, но встречаются.</p><p><strong><code>imvue</code></strong><br><a href="https://github.com/Unix4ever/imvue/" target="_blank" rel="noopener">imvue</a> — минималистичный проект-пример</p><ul><li>sdl/glew/imgui в качестве бекэнда для рендера gui, плюс кодоген ооп-обёртки вокруг imgui</li><li>lua в качестве скриптового языка и reactive-системы</li><li>libcss — html/css декларативное описание, в стиле шаблонов vue.js</li><li>без визуального редактора, так как игрушечная либа</li></ul><p><strong><code>xui</code></strong><br><a href="https://github.com/JayDT/XUI" target="_blank" rel="noopener">XUI</a> — еще один демо-пример</p><ul><li>irrlicht в качестве бекэнда</li><li>C++ clang-based парсер для рефлексии, rxcpp и cpplinq для реактивности</li><li>xaml для декларативного описания, порт OmniXaml на C++</li></ul><p><strong><code>noesisengine</code></strong><br><a href="https://www.noesisengine.com/" target="_blank" rel="noopener">noesisengine</a> — коммерческий проект</p><ul><li>свой рендер-бекэнд, рефлексия, редактор (+ экспорт из microsoft blend)</li><li>xaml в качестве декларативного описания</li></ul><p><strong><code>daRg</code></strong><br><a href="https://github.com/GaijinEntertainment/DagorEngine/tree/d3499602af19410703e6248439916778231f3878/prog/gameLibs/daRg" target="_blank" rel="noopener">Dagor Reactive GUI</a> — гайдзиновский reactive gui</p><ul><li>своей рендер-бекэнд</li><li>quirrel (свой порт squirrel) в качестве декларативного описания, рефлексии и скриптового языка</li><li>свой визуальный редактор Dargbox</li></ul><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"Ov23liG1mZbiQOIdi91X","clientSecret":"e05812685eb741a752982b89dcf6f5b58dc10251","repo":"https://github.com/spiiin/spiiin.github.io","owner":"spiiin","admin":["spiiin"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;h1&gt;&lt;span id=
      
    
    </summary>
    
    
    
      <category term="cpp" scheme="http://spiiin.github.io/tags/cpp/"/>
    
      <category term="dev_method" scheme="http://spiiin.github.io/tags/dev-method/"/>
    
      <category term="dev" scheme="http://spiiin.github.io/tags/dev/"/>
    
      <category term="gamedev" scheme="http://spiiin.github.io/tags/gamedev/"/>
    
  </entry>
  
  <entry>
    <title>Game Engines - Rendering Abstraction Layer</title>
    <link href="http://spiiin.github.io/blog/1364570417/"/>
    <id>http://spiiin.github.io/blog/1364570417/</id>
    <published>2024-03-10T13:50:05.000Z</published>
    <updated>2024-03-17T21:36:15.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><ul><li><a href="/blog/2721099263/" title="Ещё о проектировании (движки и история)">Ещё о проектировании (движки и история)</a> — заметка о GameObject в движках</li></ul><h2><span id="scenegraph-false-start">SceneGraph (False start)</span><a href="#scenegraph-false-start" class="header-anchor">#</a></h2><p>GameObject-ы на сцене часто собраны в иерархию, которую нужно как-то отрисовывать на экране. Наивная идея — отрисовка дерева GameObject-ов в порядке обхода.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameObject</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preRender</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">render</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postRender</span><span class="params">()</span></span>;</span><br><span class="line">    TArray&lt;GameObject*&gt; children;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GameObject::preRender() &#123;</span><br><span class="line">    <span class="comment">//set render state</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GameObject::render() &#123;</span><br><span class="line">    <span class="comment">//render self</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//render children</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> child : children) &#123;</span><br><span class="line">        child-&gt;preRender();</span><br><span class="line">        child-&gt;render();</span><br><span class="line">        child-&gt;postRender();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GameObject::postRender() &#123;</span><br><span class="line">    <span class="comment">//restore render state</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Имеет множество проблем в реализации даже для старых render api — различные алгоритмы требуют различных способов обхода сцены, не укладывающихся в единый граф (как для 2D сцен, так и для 3D). Возникают альтернативные Visitor-ы, списки, флаги управления порядком. Примеры задач:</p><ul><li>для оптимизации выполнения команд рендера данные могут не отправляться на отрисовку сразу, а группироваться (batching) — добавляются хранимые списки данных для рендера и условия синхронизации этих списков с основным обходом объектов</li><li>опция рендера в текстуру - ещё один проход или альтернативное состояние рендера</li><li>трики с блендингом, для которых необходимо изменить порядок вывода на обратный (<a href="/blog/887709799/" title="daScript. SFML, dasBox и спайны">daScript. SFML, dasBox и спайны</a>)</li><li>другие методы отрисовки, требующие изменения порядка — полупрозрачные объекты (до OIT), тени, зеркала</li><li>композиция нескольких из этих приёмов. НЕ решается тем, чтобы ввести наследника GameObject, который бы переопределил preRender/postRender и втыкать его в нужные места графа. Если и решается, то прикручиваением колоссального количества хаков проверки и хранения текущего состояния.</li></ul><p>Тем не менее, подход был достаточно живучий (и оживший на какое-то время с приходом ранних OpenGL ES и WebGL), судя по количеству обсуждений его вредности:<br><a href="https://tomforsyth1000.github.io/blog.wiki.html#%5B%5BScene%20Graphs%20-%20just%20say%20no%5D%5D" target="_blank" rel="noopener">Scene Graphs - just say no</a><br><a href="http://diaryofagraphicsprogrammer.blogspot.com/2009/01/handling-scene-geometry.html" target="_blank" rel="noopener">Handling Scene Geometry</a><br><a href="https://www.stevestreeting.com/2009/01/05/spatialgraph-scenetree-renderqueue-sound-familiar/" target="_blank" rel="noopener">SpatialGraph, SceneTree, RenderQueue - sound familiar?</a><br><a href="https://solid-angle.blogspot.com/2009/01/animation-and-physics-sitting-in-tree.html" target="_blank" rel="noopener">The world is not a SceneTree</a>, <a href="https://solid-angle.blogspot.com/2009/01/world-is-not-scenetree.html" target="_blank" rel="noopener">The world is not a SceneTree</a>, <a href="https://solid-angle.blogspot.com/2009/01/characters-are-special-sort-of-tree-but.html" target="_blank" rel="noopener">Characters are a special sort of tree but not a SceneTree</a>, <a href="https://solid-angle.blogspot.com/2009/01/world-is-world.html" target="_blank" rel="noopener">The world is… the world</a></p><h2><span id="spiski-komand-otrisovki">Списки команд отрисовки</span><a href="#spiski-komand-otrisovki" class="header-anchor">#</a></h2><p>Дизайн способа передачи данных отрисовки от игровых объектов к API видеокарты эволюционировал вместе с дизайном самих API отрисовки. Вместо отдельных команд переключения состояний и создания графических ресурсов постепенно появлялись буферы с данными (вершины, индексы, команды отрисовки) и команды отрисовки использующие эти буферы (“вот указатель на блоб данных, вот описание раскладки этих данных, выведи их”). </p><p>Соответственно, со стороны игрового движка так или иначе возникало формирование списка команд на отрисовку. Чаще отдельным слоем над графическим API (с названиями вроде Rendering Hardware Interface). Причины, по которым удобнее иметь отдельный уровень команд:</p><ul><li><strong>возможность отсортировать команды оптимальным образом перед передачей в графический API</strong> (или же в Data-Oriented style — заранее иметь фиксированный набор списков, в которые можно добавить объекты):<br>  <a href="https://realtimecollisiondetection.net/blog/?p=86" target="_blank" rel="noopener">Order your graphics draw calls around!</a> — пример обоих вариантов<br>  <a href="https://bitsquid.blogspot.com/2017/02/stingray-renderer-walkthrough-4-sorting.html" target="_blank" rel="noopener">Stingray Renderer Walkthrough #4: Sorting</a></li><li><strong>кеширование</strong><br>  <a href="https://www.youtube.com/watch?v=UJ6f1pm_sdU" target="_blank" rel="noopener">Refactoring the Mesh Drawing Pipeline</a> — пайплайн в Unreal, добавляется ещё один этап кеширования команд отрисовки, статические меши могут не создавать команды каждый кадр повторно, чтобы не тратить время не повторное формирование команд<br>  <img src="/blog/1364570417/journey_of_draw.png" alt></li><li><strong>многопоточность</strong> — передачу состояния можно вынести в отдельный поток (а если потоков много, то ещё и отделить процесс декодирования из RHI-команд в списки команд графического API)<br>  <a href="https://bitsquid.blogspot.com/2016/09/state-reflection.html" target="_blank" rel="noopener">State reflection</a> — 2 класса, состояние и прокси для его передачи<br>  <a href="https://github.com/donaldwuid/unreal_source_explained/blob/master/main/rendering.md" target="_blank" rel="noopener">Unreal Source Explained, Rendering</a> — то же в Unreal, <code>UPrimitiveComponent-&gt;FPrimitiveSceneProxy-&gt;FPrimitiveSceneInfo</code> и другие</li><li><strong>разные стратегии на разных платформах</strong> — для различных платформ можно эмпирически настроить поведение, например, эмулировать устравшие immediate api,  подобрать оптимальный размер данных в очереди команд перед передачей на отрисовку (flush несколько раз за кадр), или настроить размер конвейера в зависимости от количества потоков (iOS - great single core/Android - many cores)<br>  <a href="https://github.com/donaldwuid/unreal_source_explained/blob/master/main/rendering_parallel.md" target="_blank" rel="noopener">Unreal Source Explained, Parallel Rendering</a> — настройки параллельного рендера в Unreal</li></ul><p>Получается API вроде такого:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameObject</span> &#123;</span></span><br><span class="line">    ResourceHandler resHandler;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initResources</span><span class="params">(RenderCommandList cmdList)</span> </span>&#123; resHandler = cmdList.addCommand(CreateSomeResource&#123;Parameters&#125;); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">freeResourses</span><span class="params">(RenderCommandList cmdList)</span> </span>&#123; cmdList.addCommand(FreeResourceAsync&#123; resHandler &#125;); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">render</span><span class="params">(RenderCommandList cmdList)</span> </span>&#123; cmdList.addCommand(DrawSomeResourceCommand &#123; resHandler &#125;); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RenderCommandList</span> &#123;</span></span><br><span class="line">    <span class="comment">//threading, commands optimization, and batching things</span></span><br><span class="line">    DelayedCommandListMT delayedCommands;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addCommand</span><span class="params">(Command cmd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (inRenderThread() &amp;&amp; allowImmediate()) &#123;</span><br><span class="line">            translateCommandToRenderDevice(cmd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//maybe not just add, but also pre-process</span></span><br><span class="line">            delayedCommands.addNew(MOVE(cmd))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> processDelayedCommands()&#123;</span><br><span class="line">        ENSURE_IN_RENDER_THREAD();</span><br><span class="line">        delayedCommands.preprocessCommands(); <span class="comment">//sort/optimize/fuse/batch</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> cmd: delayedCommands) &#123;</span><br><span class="line">            translateCommandToRenderDevice(cmd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://medium.com/realities-io/creating-a-custom-mesh-component-in-ue4-part-1-an-in-depth-explanation-of-vertex-factories-4a6fd9fd58f2" target="_blank" rel="noopener">Creating a Custom Mesh Component in UE4</a> — серия из 4х статей, про добавление в пайплайн своего компонента, и структур для его обработки.<br><a href="https://medium.com/@lordned" target="_blank" rel="noopener">Unreal Engine 4 Rendering</a> — ещё одна серия, небольшой обзор структур рендера.</p><h2><span id="intermediate-3d-api">Intermediate 3D API</span><a href="#intermediate-3d-api" class="header-anchor">#</a></h2><p>Так как графических API много и они разные, а движки часто хотят быть мультиплатформенными, то возникают попытки выделения нижнего уровня абстракции RHI в отдельные библиотеки-прослойки между DirectX 11/12/Vulkan/Metal/Opengl desktop/web/mobile. На этом уровне библиотека на заботится ни о чём, кроме быстрого формирования картинки из команд, не вникая в то, что представляют из себя эти команды (чем-то похоже на видеоплейеры).</p><p><a href="https://alain.xyz/blog/comparison-of-modern-graphics-apis" target="_blank" rel="noopener">A Comparison of Modern Graphics APIs</a><br><a href="https://alextardif.com/RenderingAbstractionLayers.html" target="_blank" rel="noopener">An Opinionated Post on Modern Rendering Abstraction Layers</a><br><a href="http://www.gijskaerts.com/wordpress/?p=98" target="_blank" rel="noopener">Musings on cross-platform graphics engine architectures</a> + <a href="https://www.gijskaerts.com/wordpress/?p=112" target="_blank" rel="noopener">Multi-threaded command recording and submission</a><br><a href="https://www.gamedeveloper.com/programming/designing-a-modern-cross-platform-low-level-graphics-library" target="_blank" rel="noopener">Designing a Modern Cross-Platform Low-Level Graphics Library</a><br><a href="https://bitsquid.blogspot.com/2017/02/stingray-renderer-walkthrough.html" target="_blank" rel="noopener">Stingray Renderer Walkthrough #5: RenderDevice</a></p><p><a href="https://dev.to/funatsufumiya/comparison-of-c-low-level-graphics-cross-platform-frameworks-and-libraries-58e5#llgl-low-level-graphics-library" target="_blank" rel="noopener">Comparison of C++ Low-Level Graphics, Cross-Platform Frameworks and Libraries</a> — обзор нескольких библиотек.</p><p><code>sokol</code><br><a href="https://github.com/floooh/sokol" target="_blank" rel="noopener">sokol-gfx</a> — thin-решение на C. Графическая обёртка отделена от всего, что только можно. Часто связанные с обёрткой решения выделены в отдельные библиотеки — <a href="https://github.com/floooh/sokol-tools/" target="_blank" rel="noopener">sokol-shdc</a> для кросс-платформенных шейдеров, транспилируемых в нативные языки (annotated GLSL -&gt; platform shaders + c header) и <a href="https://github.com/floooh/oryol" target="_blank" rel="noopener">oryol</a> для обёртки над окнами и IO.</p><p><code>bgfx</code><br><a href="https://github.com/bkaradzic/bgfx" target="_blank" rel="noopener">bgfx</a> — кроме составления списка команд, умеет их <a href="https://bkaradzic.github.io/bgfx/internals.html" target="_blank" rel="noopener">сортировать</a>, а также заполнять из нескольких потоков. Shaderc — компилятор шейдеров, надстройка на GLSL-like языком, транспилируемым в нативные языки.<br>Настраивается на использование с различными оконными обёртками (glfw/sdl/native os), имеет отдельные base-library <a href="https://github.com/bkaradzic/bx/" target="_blank" rel="noopener">bx</a> (обёртки над io/threads primitives/math/memory/hash) и <a href="https://github.com/bkaradzic/bnet" target="_blank" rel="noopener">bnet</a> (tcp protocol wrapper).</p><p><code>llgl</code><br><a href="https://github.com/LukasBanana/LLGL" target="_blank" rel="noopener">llgl</a> — еще одна thin-прослойка для большинства платформ, без window- и shader- слоёв (из-за чего в примерах 100500 вариантов шейдеров на всех языках). Многопоточный command buffer поддерживается только для OpenGL-wrapper (<a href="https://github.com/LukasBanana/LLGL/blob/master/docu/GettingStarted/Getting%20Started%20with%20LLGL.pdf" target="_blank" rel="noopener">не поддерживается</a> для DX12 и Vulkan). Имеет c-api для генерации привязок к языками (как и sokol/bgfx).</p><p><code>Diligent Engine</code><br><a href="https://github.com/DiligentGraphics/DiligentCore" target="_blank" rel="noopener">Diligent Engine Core</a> — декларирует полную поддержку новых API, и ограниченную поддержку старых. Поддерживает генерацию команд из нескольких потоков, и вшитую на низком уровне систему <a href="http://diligentgraphics.com/diligent-engine/architecture/cross-platform/reference-counting/" target="_blank" rel="noopener">Reference Counting</a>. Имеет C API для привязок к языкам (C++/C#). <a href="https://github.com/DiligentGraphics/DiligentFX" target="_blank" rel="noopener">DiligentFX</a> - high-level слой поверх Core. <a href="http://diligentgraphics.com/" target="_blank" rel="noopener">Блог</a> с обновлениями и описанием дизайна.</p><p><code>The Forge</code><br><a href="https://github.com/ConfettiFX/The-Forge" target="_blank" rel="noopener">The Forge</a> — open-source прослойка, industry-level качества, разработчики предлагают услуги по помощи в интеграции в существующие движки (примеры — Forza Motorspirt и Starfield). Больше оптимизаций, высокий порог для старта, постепенное обрастание необходимыми для движка системами, не связанными с прослойкой для рендера (скорее всего, связанное с потребностями компаний, интегрирующих библиотеку).</p><h2><span id="shader-abstraction">Shader abstraction</span><a href="#shader-abstraction" class="header-anchor">#</a></h2><p>Так как языки для описания шейдеров похожие, но чуть отличающиеся, и требуют описания соотвествующих им структур и кода на C++, то библиотеки используют мета-языки — надстройки над одним из базовых языков (GLSL/HLSL + транспиляция в другие базовые языки) и/или DSL/схемы данных, по которым генерируется код привязки параметров к шейдеру.</p><p>Также, шейдеры требуют оптимизаций, поэтому опциональные фичи рендера, которые могут присутствовать или отсутствовать в материале, генерируют различные варианты шейдеров (с включенным и выключенным вариантом фичи). Поскольку каждая новая опция вдвое увеличивает количество вариантов шейдеров, необходимо предусмотреть возможности заданий ограничений вариантов в тех частях движка, которые взаимодействуют с системой материалов (скомпилировать заранее все варианты быстро становится невозможным).<br><a href="https://aras-p.info/blog/2017/02/05/Every-Possible-Scalability-Limit-Will-Be-Reached/" target="_blank" rel="noopener">Every Possible Scalability Limit Will Be Reached</a> - эволюция системы материалов в Unity, от 5 вариантов шейдеров, до 100 миллиардов.</p><p>Идиомы систем материалов:</p><ul><li>code reuse (include-based)</li><li>uber-shader (substractive)</li><li>additive (nodes-based)</li><li>templates (material domain в unreal, surface shader в unity)</li></ul><p><img src="/blog/1364570417/destiny_shaders_small.png" alt><br><a href="https://www.gdcvault.com/play/1024231/-Destiny-Shader" target="_blank" rel="noopener">Destiny’ Shader Pipeline</a></p><p><a href="https://aras-p.info/blog/2014/05/05/shader-compilation-in-unity-4-dot-5/" target="_blank" rel="noopener">Shader compilation in Unity 4.5</a><br>GPU Pro 6 - Semantic-BasedShaderGenerationUsingShaderShaker</p><h2><span id="frame-graph">Frame Graph</span><a href="#frame-graph" class="header-anchor">#</a></h2><p>Отрисовка кадра игры состоит из большого количества этапов.</p><p>Примеры реверс-инжинирига пайплайна отрисовки кадра из различных игр:<br><a href="http://www.adriancourreges.com/blog/2016/09/09/doom-2016-graphics-study/" target="_blank" rel="noopener">DOOM (2016) - Graphics Study</a><br><a href="https://80.lv/articles/world-of-tanks-graphical-update-technical-overview/" target="_blank" rel="noopener">World of Tanks: Graphical Update Technical Overview</a><br><a href="https://astralcode.blogspot.com/2018/11/reverse-engineering-rendering-of.html" target="_blank" rel="noopener">Reverse engineering the rendering of The Witcher 3</a><br><a href="https://godotengine.org/article/godot-3-renderer-design-explained" target="_blank" rel="noopener">Godot 3’s Renderer Design Explained</a><br><a href="http://www.adriancourreges.com/blog/2015/11/02/gta-v-graphics-study/" target="_blank" rel="noopener">GTA V - Graphics Study</a><br><a href="https://interplayoflight.wordpress.com/2017/10/25/how-unreal-renders-a-frame/amp/" target="_blank" rel="noopener">How Unreal Renders a Frame</a><br><a href="https://c0de517e.blogspot.com/2020/12/hallucinations-re-rendering-of.html" target="_blank" rel="noopener">Hallucinations re: the rendering of Cyberpunk 2077</a><br><a href="https://mamoniem.com/behind-the-pretty-frames-god-of-war/" target="_blank" rel="noopener">Behind the Pretty Frames: God of War</a><br><a href="https://gamedev.ru/community/gamedev_lecture/articles/?id=718" target="_blank" rel="noopener">Oblivion</a><br><a href="https://gamedev.ru/community/gamedev_lecture/articles/r_e_n_de_r" target="_blank" rel="noopener">Stalker</a><br><a href="https://www.elopezr.com/" target="_blank" rel="noopener">https://www.elopezr.com/</a> — Mafia, Nanite, Jurassic World, Rise of Tomb Raider, Shadow of Mordor, Castlevania<br><a href="https://users.livejournal.com/--vortex--/" target="_blank" rel="noopener">https://users.livejournal.com/--vortex--/</a> — старенькое: Diablo 3, Starcraft 2, Jericho, Dirt, Company Of Heroes, Warhammer 40K: Dawn of War, Gothic 3, NFS Carbon, Painkiller, Flatout 2</p><p><a href="https://github.com/GaijinEntertainment/DagorEngine/blob/main/samples/skiesSample/prog/test_app.cpp" target="_blank" rel="noopener">skySample</a> - тестовый пример из DagorEngine, описание рендера кадра на ~2к строк.<br><a href="https://github.com/ConfettiFX/The-Forge/blob/master/Examples_3/Aura/src/Aura.cpp" target="_blank" rel="noopener">Aura</a> - аналогично из The-Forge, ~2к строк<br><a href="https://www.gdcvault.com/play/1024612/FrameGraph-Extensible-Rendering-Architecture-in" target="_blank" rel="noopener">FrameGraph: Extensible Rendering Architecture in Frostbite</a> - список проходов Battlefield 4<br><img src="/blog/1364570417/frame_graph_1_small.png" alt></p><p>В универсальных движках возможны также настраиваемые этапы или различные пайплайны для различных платформ, а также дополнительный отладочный вывод, что делает описание еще более сложным.</p><p><a href="https://logins.github.io/graphics/2021/05/31/RenderGraphs.html" target="_blank" rel="noopener">Why Talking About Render Graphs</a> — граф для описания этапов, и compile-time/runtime вычисления зависимостей используемых ресурсов меджу этапами.</p><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"Ov23liG1mZbiQOIdi91X","clientSecret":"e05812685eb741a752982b89dcf6f5b58dc10251","repo":"https://github.com/spiiin/spiiin.github.io","owner":"spiiin","admin":["spiiin"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;ul&gt;
&lt;li&gt;&lt;a h
      
    
    </summary>
    
    
    
      <category term="dev_method" scheme="http://spiiin.github.io/tags/dev-method/"/>
    
      <category term="dev_evolution" scheme="http://spiiin.github.io/tags/dev-evolution/"/>
    
      <category term="3d" scheme="http://spiiin.github.io/tags/3d/"/>
    
      <category term="unreal" scheme="http://spiiin.github.io/tags/unreal/"/>
    
  </entry>
  
  <entry>
    <title>Скриптовые языки в Unreal Engine</title>
    <link href="http://spiiin.github.io/blog/770184585/"/>
    <id>http://spiiin.github.io/blog/770184585/</id>
    <published>2024-03-02T22:02:18.000Z</published>
    <updated>2024-03-04T12:16:03.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><ul><li><a href="/blog/2721099263/" title="Ещё о проектировании (движки и история)">Ещё о проектировании (движки и история)</a> — про идею разделения игрового объекта на части “для программистов” и “для гейм-дизайнеров”.</li></ul><p>Схема создания разделённых типов в Unreal Engine выглядит приблизительно так:</p><h1><span id="c-lt-gt-blueprints">C++ &lt;—&gt; Blueprints</span><a href="#c-lt-gt-blueprints" class="header-anchor">#</a></h1><h2><span id="obshchaya-shema">Общая схема</span><a href="#obshchaya-shema" class="header-anchor">#</a></h2><p><img src="/blog/770184585/unreal1_small.png" alt><br><em><a href="/blog/770184585/unreal1.png">full size</a></em></p><ul><li>Исходный код обрабатывается препроцессором <code>Unreal Header Tool</code> (DSL), который генерирует метаинформацию для системы рефлексии</li><li>Код на C++ собирается в exe-файл редактора/игры</li><li>Код на С++ также может собираться в динамическую библиотеку, которая загружается уже после запуска редактора</li><li>После запуска редактор загружает мета-информацию о типах (Reflection data), и может использовать для визуального отображения и редактирования типов</li><li>Runtime geneated reflection data — новые типы могут быть созданы в рантайме, с помощью наследования от уже существующих типов и определения/переопределения новых полей, и кода из языка Blueprints (который компилируется в байткод виртуальной машины)</li></ul><p>Некоторые неотмеченные на схеме связи:</p><ul><li>Нативизация скриптов (вместо компиляции в байт-код происходит транспиляция в C++ код)</li><li>Типы могут использоваться не в качестве базовых для настройки и расширения из скриптов Blueprint, а ради расширения редактора (макросы) или самого языка Blueprint (регистрация новых типов нод)</li></ul><p><a href="https://www.youtube.com/watch?v=wJqOn88cU7o" target="_blank" rel="noopener">Building Tools Quickly: Blueprints, Menus, Utilities, and Widgets</a> — доклад про различные способы расширения редактора Unreal от Embark Studios</p><h2><span id="refleksiya">Рефлексия</span><a href="#refleksiya" class="header-anchor">#</a></h2><p>Поскольку C++ не имеет встроенных средств рефлексии, движки изобретают свои средства для описания метаинформации. Так как часто уже существует основа движка на C++, выбирается вариант с добавлением разметки в сам C++ код, и стадии препроцессинга перед компиляцией (<code>Unreal Header Tool</code> в случае с Unreal), на которой разбирается метаинформация и генерируется мета-класс и код работы с ним.</p><p>Кроме генерация мета-класса в виде C++-типа, необходим способ создания типов в ран-тайме — генерация кода регистрации типа в системе рефлексии времени выполнения.</p><p><a href="https://awforsythe.com/unreal/blueprints_vs_cpp/" target="_blank" rel="noopener">Blueprints vs C++</a> — статья с разбором системы рефлексии, а также способов ссылок на типы C++-&gt;Blueprint и Blueprint-&gt;C++<br><a href="https://www.tomlooman.com/unreal-engine-cpp-guide/" target="_blank" rel="noopener">Unreal Engine C++ Complete Guide</a> — гайд по DSL для описания метаинформации, а также других макросов Unreal (<code>Unrealisms</code>)</p><ul><li><a href="/blog/1728194429/" title="С++ в геймдеве">С++ в геймдеве</a> — раздел “Высокоуровневый C++”, про ограничения языка в рефлексии, кодогенерации, compile-time вычислениях</li><li><a href="/blog/4174799834/" title="C++ Metaprogramming - ссылки">C++ Metaprogramming - ссылки</a> — возможности мета-программирования</li></ul><h1><span id="privyazka-tekstovogo-skriptovogo-yazyka">Привязка текстового скриптового языка</span><a href="#privyazka-tekstovogo-skriptovogo-yazyka" class="header-anchor">#</a></h1><h2><span id="vybor-mezhdu-vizualnym-tekstovym-programmirovaniem">Выбор между визуальным/текстовым программированием</span><a href="#vybor-mezhdu-vizualnym-tekstovym-programmirovaniem" class="header-anchor">#</a></h2><ul><li><a href="/blog/2721099263/" title="Ещё о проектировании (движки и история)">Ещё о проектировании (движки и история)</a></li></ul><p>Выбор можно типом скриптового языка (визуальный/текстовый) зависит от конфигурации команды (кто будет пользоваться этим языком).</p><ul><li>По статистике от Epic — до 80% кода в больших проектах переписывается с Blueprint на C++ (<a href="https://www.youtube.com/watch?v=0YMS2wnykbc&amp;t=1276s" target="_blank" rel="noopener">линк</a>).</li></ul><p>Т.е. с визуальным языком вместо идеи “делаем игру без программистов” получается “программисты регулярно занимаются переписыванием логики игры на нативный язык”. Текстовые языки удобнее в плане того, что могут быть быстрее визуальных, и ближе к натуральному представлению программистов (переписывать с текстового скрипта на C++ проще, чем с Blueprint).</p><p>Скриптовый язык должен быть быстрым, или хотя бы иметь возможности для ускорения (транспиляция/jit/профайлер/управление памятью/быстрый интероп с C++/примитивные типы/опции оптимизаций компиляции), чтобы минимизировать необходимость переписывания.</p><ul><li>Дизайн некоторых игр может подразумевать наличие большого количества level one-offs (мест с кастомной логикой), что требует большого объёма кода. Объёмные Blueprint-скрипты нечитаемы.</li></ul><p>Из старых примеров игр, в которых уровней с кастомной логикой больше, чем основной — Earth World Jim 2, BattleToads, сборники мини-игр (Mario Party, Adventures in The Magic Kingdom, Tiny Toon 2, симуляторы олимпиад и многоборий). Из новых — <code>It Takes Two</code>. Разработчики выбрали для этого <a href="https://angelscript.hazelight.se/" target="_blank" rel="noopener">AngelScript</a>.</p><ul><li><p>Текстовый язык не заменяет полностью Blueprint, небольшие кусочки всё равно удобнее реализовывать в виде Blueprint-скриптов, чтобы сохранять возможность использовать уже накопленные Unreal-разработчиками приёмы. Т.е. язык должен быть интегрирован не только с C++, так и с системой рефлексии и виртуальной машиной Blueprint.</p></li><li><p>В идеале, язык должен быть не хуже Blueprint в том, в чем силён Blueprint, и не хуже C++ в том, в чём хорош C++</p></li></ul><h2><span id="gruppy-skriptovyh-yazykov">Группы скриптовых языков</span><a href="#gruppy-skriptovyh-yazykov" class="header-anchor">#</a></h2><p><code>Lua/AngelScript/Wren/Squirrel</code></p><p>Lightweight-языки с простой виртуальной машиной, и небольшой стандартной библиотекой, дополнительные фичи могут реализовываться дописыванием функционала на C++.<br><a href="https://www.angelcode.com/angelscript/sdk/docs/manual/doc_addon_script.html" target="_blank" rel="noopener">Аддоны AngelScript</a>, <a href="https://github.com/Hazelight/UnrealEngine-Angelscript/blob/6b9c9a776cd339ba2b44f175a3677106ef1c8dbe/Engine/Plugins/Angelscript/Source/AngelscriptCode/Private/Preprocessor/AngelscriptPreprocessor.cpp" target="_blank" rel="noopener">препроцессор UnrealAngelScript</a> на 4к строк.</p><p><code>C#/Python/JavaScript</code></p><p>Языки с тяжелой виртуальной машиной, развесистой стандартной библиотекой и большим количеством готовых 3rdParty библиотек.</p><p><code>Odin/Jai/daScript/Nim/Haxe</code></p><p>Языки с gamedev-related фичами. Рефлексия, настройка управления памятью, компайл-тайм eval и макросы, транспиляция в C++, выбор между исполнением байт-кода и компиляцией, jit-компиляция (полный набор не поддерживает ни один язык из списка, но все поддерживают хотя бы несколько).</p><p>Эта группа представляет наибольший интерес, потому что потенциально может заменить не только Blueprint, но и большую часть C++.</p><h1><span id="c-lt-gt-nim-lt-gt-blueprint">C++ &lt;—&gt; Nim &lt;—&gt; Blueprint</span><a href="#c-lt-gt-nim-lt-gt-blueprint" class="header-anchor">#</a></h1><p><a href="https://github.com/jmgomez/NimForUE" target="_blank" rel="noopener">NimForUE</a> — привязка Nim к Unreal Engine, в разработке.</p><h2><span id="obshchaya-shema">Общая схема</span><a href="#obshchaya-shema" class="header-anchor">#</a></h2><p><img src="/blog/770184585/unreal2_small.png" alt><br><em><a href="/blog/770184585/unreal2.png">full size</a></em></p><p>Макросы позволяют написать на Nim DSL описания метаинформации.</p><p>Код на Nim может компилироваться в статическую библиотеку, как и код на C++. Также существует возможность собрать код в DLL для хот-релоадинга и транспилировать в C++.<br>Для рантайм выполнения без компиляции существует формат интерпретации байт-кода виртуальной машиной NimVM.</p><h2><span id="zadachi-nimforue">Задачи NimForUE</span><a href="#zadachi-nimforue" class="header-anchor">#</a></h2><ul><li>Привязки методов C++ для динамического добавления типов в систему рефлексии Unreal (создание модуля, типа, полей и функций в нём, информирования рантайма о новых типах)</li><li>Привязки базовых типов Unreal, строк, указателей, контейнеров, делегатов и вспомогательных классов системы рефлексии (UObject, UClass, UFunction, TSubclassOf, TSoftObjectPtr)</li><li>Соответствие базовых типов языки типам системы рефлексии, идиоматические для nim хелперы вокруг unreal-типов</li><li>Обёртки вокруг конвенций Unreal - конструкторов, создания компонент, статических данных и связью с системой сборки мусора, Out-параметры для Blueprint-нод</li><li>Базовая инфраструктура Nim — виртуальная машина, мониторинг библиотеки для hot-reload, тесты и отладка</li><li>DSL для создания типов, похожий на тот, который используется Unreal Header Tool, прокидка типов и флагов описания метаинформации</li><li>Генерация привязок для всех типов системы рефлексии</li><li>Генерация привязок для типов C++ (и допривязка свойств/функций), которые не добавлены в систему рефлексии, но необходимы для удобной работы со скриптами</li><li>Override свойств и функций системы рефлексии (наследование от Blueprint-типов)</li><li>Override для C++ функций (генерацией c++-типа обёртки)</li><li>Разделение кода обёрток игры/редактора, поддержка всех платформ</li></ul><h2><span id="sposoby-svyazi-mezhdu-yazykami">Способы связи между языками</span><a href="#sposoby-svyazi-mezhdu-yazykami" class="header-anchor">#</a></h2><p><code>Nim &lt;--&gt; Cpp</code></p><p>Nim может описать используемый метод и тип из C++ из самого языка (pragma importcpp). Аналогично код на C++ может описать прототип extern функции, которая находится в lib-файле, собранном из nim-кода.<br>Для динамической привязки — стандартные для ОС методы вызова функций из библиотек (со стороны Nim — обмазанные макросами).</p><p><code>Nim &lt;--&gt; Blueprint</code></p><p>Связь через систему рефлексии (Emit Type + Broadcast Asset -&gt; Blueprint знает о типе).</p><p><a href="https://github.com/jmgomez/NimForUE/blob/17049537e0e92f2f796dfbc18c645939b0199629/Source/NimForUEBindings/Public/UFunctionCaller.h" target="_blank" rel="noopener">UFunctionCaller</a> — вызов зарестрированной функции по имени.</p><p>Пример сгенерённой привязки функции</p><figure class="highlight nim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">proc</span> getPingInMilliseconds*(self : <span class="type">APlayerStatePtr</span>): <span class="built_in">float32</span> =</span><br><span class="line">  <span class="keyword">var</span> call  = <span class="type">UECall</span>(self: <span class="number">0</span>, value: <span class="type">RuntimeField</span>(kind: <span class="type">FieldKind</span>(<span class="number">0</span>),</span><br><span class="line">      intVal: <span class="number">0</span>), kind: <span class="type">UECallKind</span>(<span class="number">0</span>), fn: <span class="type">UEFunc</span>(name: <span class="string">"GetPingInMilliseconds"</span>,</span><br><span class="line">      className: <span class="string">"APlayerState"</span>))</span><br><span class="line">  call.value = ().toRuntimeField()</span><br><span class="line">  call.self = <span class="keyword">cast</span>[<span class="built_in">int</span>](self)</span><br><span class="line">  <span class="keyword">let</span> returnVal <span class="meta">&#123;.used, inject.&#125;</span> = uCall(call)</span><br><span class="line">  <span class="keyword">when</span> <span class="built_in">float32</span> <span class="keyword">is</span> <span class="keyword">ptr</span>:</span><br><span class="line">    <span class="keyword">if</span> returnVal.get.intVal == <span class="number">0</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">nil</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">cast</span>[<span class="built_in">float32</span>](returnVal.get.intVal)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> returnVal.get.runtimeFieldTo(<span class="built_in">float32</span>)</span><br></pre></td></tr></table></figure><h2><span id="ustanovka">Установка</span><a href="#ustanovka" class="header-anchor">#</a></h2><p><a href="https://github.com/jmgomez/NimTemplate" target="_blank" rel="noopener">NimTemplate</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">choosenim devel # скачать nim</span><br><span class="line">nimble nue      # установка nue, утилиты для работы с NimForUE</span><br><span class="line">nue setup       # компиляция движка, плагина и генерация байндингов</span><br><span class="line">                # .Plugins&#x2F;NimForUE&#x2F;NimForUE.win.json - путь к движку</span><br><span class="line">...</span><br><span class="line">nue starteditor # запуск редактора</span><br><span class="line">nue game        # перекомпиляция game.dll, hot-reload библиотеки с nim-кодом</span><br><span class="line">                # .&#x2F;NimForUE&#x2F;config.nims - настройки путей</span><br><span class="line">                # .&#x2F;NimForUE&#x2F;game.nim - код примера</span><br></pre></td></tr></table></figure><p><img src="/blog/770184585/unreal3_small.png" alt><br><em><a href="/blog/770184585/unreal3.png">full size</a></em></p><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"Ov23liG1mZbiQOIdi91X","clientSecret":"e05812685eb741a752982b89dcf6f5b58dc10251","repo":"https://github.com/spiiin/spiiin.github.io","owner":"spiiin","admin":["spiiin"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;ul&gt;
&lt;li&gt;&lt;a h
      
    
    </summary>
    
    
    
      <category term="nim" scheme="http://spiiin.github.io/tags/nim/"/>
    
      <category term="unreal" scheme="http://spiiin.github.io/tags/unreal/"/>
    
  </entry>
  
  <entry>
    <title>Итоги второй половины 2023 года</title>
    <link href="http://spiiin.github.io/blog/978393967/"/>
    <id>http://spiiin.github.io/blog/978393967/</id>
    <published>2024-02-22T19:43:25.000Z</published>
    <updated>2024-03-05T15:10:01.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Предыдущие</p><ul><li><a href="/blog/307513906/" title="Итоги 2020">Итоги 2020</a></li><li><a href="/blog/2738337723/" title="Итоги 2021-2022">Итоги 2021-2022</a></li><li><a href="/blog/3525050862/" title="Итоги первой половины 2023">Итоги первой половины 2023</a></li></ul><p><strong><code>Личное/путешествия</code></strong><br>Когда-то отмечал 2022-й год, потом 5783-й, следующий будет 2567-й<br><img src="/blog/978393967/thai1_small.png" alt></p><p><strong><code>Музыка</code></strong></p><p><code>MNISHEK - Душко моя</code><br><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/8Ox2Sw9MX4Y" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></p><p><code>Мельница - Дороги</code><br><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/P_g3sYGuuEA" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></p><p><code>Friendship (feat.Lee Ritenour) - Let&#39;s Not Talk About It</code> (Super Mario Level 1-2)<br><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/ZX5ef_KAZlY" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></p><p><code>Atlantida Project - Круги</code><br><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/LTlH_BfwgrY" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></p><p><code>Антон Птушкін - Карпати без слів</code><br><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/tVBepI8elAA" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div><br>Видео без музыки, но с атмосферой, как будто первое погружение в <code>Breath of the Wild</code></p><p><strong><code>Игры</code></strong><br><code>Baldurs Gate 3</code> - прошёл за лесную-гномиху друида.<br><code>Fantasy Strike</code> - максимально простой файтинг, хорош для изучения проёмов гейм-дизайна в жанре.<br><code>Super Mario Bros Wonder</code>- Марио как всегда отличный, но, как и все 2d части, показался слишком коротким.<br><code>Hogwarts Legacy</code> - странное сочетание, гриндилка для фанатов с клёвым окружением, но стандартными open-world механиками, почти без отыгрыша школьной жизни.<br><code>Songs of conquest</code> - отличная инди-тактика.</p><p><strong><code>Книги</code></strong><br><code>Лекции Дыбовского про игры</code> на Страдающем Средневековье. Всегда интересно слушать.<br><code>Шрайдер</code> - книги про гейм-дизайн и баланс.<br><code>Крис Колер. Power Up! Как Япония вдохнула в игровую индустрию новую жизнь</code> - история.<br><code>Chris Solarski. Drawing Basics and Video Game Art + Interactive stories and video game art</code> - язык форм в геймдизайне.<br><a href="https://en.wikipedia.org/wiki/Pattern-Oriented_Software_Architecture" target="_blank" rel="noopener">Pattern-Oriented Software Architecture</a> - вполне себе timeless методы проектирования софта.<br><a href="https://en.wikipedia.org/wiki/List_of_cognitive_biases" target="_blank" rel="noopener">List of cognitive biases</a> - хорошая стартовая точка для подробного изучения<br><a href="http://ithare.com/contents-of-development-and-deployment-of-massively-multiplayer-games-from-social-games-to-mmofps-with-stock-exchanges-in-between/" target="_blank" rel="noopener">D&amp;D of MOGs</a> - серьёзный разбор вариантов дизайнна MMO.<br><a href="/blog/30406011/" title="Agner Fog&#39;s Optimization manuals">Agner Fog&#39;s Optimization manuals</a> - мануалы Агнера Фога по оптимизации.</p><p><strong><code>Развитие</code></strong><br>Занялся изучением <code>Unreal Engine</code>. Также немного — процедурной генерацией и генерацией изображений с помощью нейросетей.<br><a href="/blog/2455145615/" title="Про изучение английского">Про изучение английского</a> — наконец-то увлёкся английским. Минус - уходит много времени на практику.</p><p><img src="/blog/978393967/fox_2023_small.png" alt></p><p>YOLO, всё пройдёт, и это тоже.</p><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"Ov23liG1mZbiQOIdi91X","clientSecret":"e05812685eb741a752982b89dcf6f5b58dc10251","repo":"https://github.com/spiiin/spiiin.github.io","owner":"spiiin","admin":["spiiin"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;Предыдущие
      
    
    </summary>
    
    
    
      <category term="log" scheme="http://spiiin.github.io/tags/log/"/>
    
  </entry>
  
</feed>
