<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Spiiin&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://spiiin.github.io/"/>
  <updated>2024-01-01T12:30:20.363Z</updated>
  <id>http://spiiin.github.io/</id>
  
  <author>
    <name>spiiin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Блендинг анимаций</title>
    <link href="http://spiiin.github.io/blog/2762077600/"/>
    <id>http://spiiin.github.io/blog/2762077600/</id>
    <published>2024-01-01T12:17:29.000Z</published>
    <updated>2024-01-01T12:30:20.363Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/Jkv0pbp0ckQ" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div><p>Animation Programming Basics</p><p>В дополнение - глава <code>Системы анимации</code> из книги Джейсона Грегори “Игровой движок”</p><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/LNidsMesxSE" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div><p>Animation Bootcamp: An Indie Approach to Procedural Animation</p><p>О том, как использовать методы блендинга, чтобы собирать анимации из 2-3 фреймов</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;style&gt;.embed
      
    
    </summary>
    
    
    
      <category term="link" scheme="http://spiiin.github.io/tags/link/"/>
    
      <category term="3d" scheme="http://spiiin.github.io/tags/3d/"/>
    
  </entry>
  
  <entry>
    <title>Super Mario Факты</title>
    <link href="http://spiiin.github.io/blog/2382849215/"/>
    <id>http://spiiin.github.io/blog/2382849215/</id>
    <published>2023-12-27T10:22:36.000Z</published>
    <updated>2023-12-30T10:21:44.733Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><h2 id="Дизайн"><a href="#Дизайн" class="headerlink" title="Дизайн"></a>Дизайн</h2><p><a href="https://eggplant.show/into-the-depths-super-mario-world-part-1" target="_blank" rel="noopener">Into the Depth: Super Mario World</a> — разбор механик Super Mario World в 6 частях, от авторов инди-платформеров <code>Spelunky</code> и <code>Celeste</code>.</p><ul><li>Геймдизайн “Марио” (и “Зельды”) вплетён в днк современных геймдизайнеров (даже если кто-то больше играл в Соника)</li><li>Изначально была идея чтобы игра воспринималась как атлетическая - <a href="https://purenintendo.com/miyamoto-talks-about-the-original-super-mario-bros/" target="_blank" rel="noopener">https://purenintendo.com/miyamoto-talks-about-the-original-super-mario-bros/</a></li><li>Миямото описывает игру как challenge, чтобы всегда была “коробка с челленджами”</li><li>Туториал по механикам - <a href="https://www.youtube.com/watch?v=QpgPLsNv9uE" target="_blank" rel="noopener">https://www.youtube.com/watch?v=QpgPLsNv9uE</a>, для тренировки в kaizo-хаках</li><li>Цвета йоши и домиков соответствуют 4м кнопкам джойпада snes <a href="https://www.youtube.com/watch?v=zgtYV41yXbU" target="_blank" rel="noopener">https://www.youtube.com/watch?v=zgtYV41yXbU</a></li><li>Две кнопки для бега позволяют не переставая бежать выполнять действия, которые требуют нажать кнопку для бега (выпустить снаряд или ударить хвостом)</li></ul><p><a href="https://thegamedesignforum.com/features/RD_SMW_1.html" target="_blank" rel="noopener">Reverse game design SMW</a><br><a href="https://habr.com/ru/companies/plarium/articles/307428/" target="_blank" rel="noopener">Дополнение</a><br><a href="https://thegamedesignforum.com/features/GDH_2.html" target="_blank" rel="noopener">An Intro to Videogame Design History. Part2. The Composite Era</a> - Super Mario открыл эру игр с композитным дизайном (прыжки от аркады, выстрелы и борьба с врагами из экшенов)</p><h2 id="Tech-art"><a href="#Tech-art" class="headerlink" title="Tech-art"></a>Tech-art</h2><ul><li>Super Mario 64 - первая игра со скелетной анимацией</li><li>Модель Марио из Super Mario Wonder содержит множество мешей, которые включаются и отключаются динамически для создания мультяшных эффектов (<a href="https://twitter.com/DMeville/status/1740873118099661013" target="_blank" rel="noopener">link</a>) - 3 ноги, 18 мешей рта, 6 пар рук и 3 пары бровей.<br><img src="/blog/2382849215/smw_model.png" alt=""></li></ul><h2 id="Звук"><a href="#Звук" class="headerlink" title="Звук"></a>Звук</h2><p><a href="https://www.youtube.com/watch?v=KuyA12ezwS4" target="_blank" rel="noopener">Как устроен звук в Марио. Гармонизация. Секрет звукодизайна Nintendo</a><br><a href="https://www.youtube.com/watch?v=9H7B0n-Gk1A" target="_blank" rel="noopener">Как устроена музыка в играх Нинтендо</a></p><ul><li>В серии Марио звук встроен в мелодию, синхронизирован с ритмом, и иногда меняется вместе с музыкой. Анимации также могут быть подстроены под ритм музыки</li><li>Заимствования. Музыка из 1-2 - <a href="https://youtu.be/ZX5ef_KAZlY?si=WSnDh-Iw0hy-FrPF" target="_blank" rel="noopener">https://youtu.be/ZX5ef_KAZlY?si=WSnDh-Iw0hy-FrPF</a></li></ul><h2 id="Бонус"><a href="#Бонус" class="headerlink" title="Бонус"></a>Бонус</h2><p><a href="https://shedevr.org.ru/cgi-bin/parse.cgi?id=super_mario_bros_tas_review" target="_blank" rel="noopener">If you look hard enough…</a> — TAS игры<br><a href="https://www.youtube.com/watch?v=OPcV9uIY5i4" target="_blank" rel="noopener">Super Mario World “Arbitrary Code Execution”</a> — произвольное испольнение кода<br><a href="https://andrewkelley.me/post/jamulator.html" target="_blank" rel="noopener">Statically Recompiling NES Games</a></p><ul><li>Из-за оптимизаций игры применяются приёмы вроде jmp на середину инструкции</li></ul><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;h2 id=&quot;Дизай
      
    
    </summary>
    
    
    
      <category term="nes" scheme="http://spiiin.github.io/tags/nes/"/>
    
      <category term="link" scheme="http://spiiin.github.io/tags/link/"/>
    
      <category term="gamedesign" scheme="http://spiiin.github.io/tags/gamedesign/"/>
    
  </entry>
  
  <entry>
    <title>Design Review</title>
    <link href="http://spiiin.github.io/blog/2511486836/"/>
    <id>http://spiiin.github.io/blog/2511486836/</id>
    <published>2023-12-26T15:38:58.000Z</published>
    <updated>2023-12-26T15:55:27.750Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>В статье <a href="https://habr.com/ru/articles/774972/" target="_blank" rel="noopener">Вы точно хотите пойти программистом в gamedev?</a> и комментариях к ней попалась пара докладов с описанием проблем code review, и предложениями ревьюить дизайн, до написания кода</p><p><a href="https://www.youtube.com/watch?v=WQg_339CcBY" target="_blank" rel="noopener">Артём Титов - TDD WTF ?! Или как написать код геймплея без ошибок</a><br><a href="https://www.youtube.com/watch?v=4Y0XJXRZv6k" target="_blank" rel="noopener">Design Review и другие друзья разработчика, Дельгядо Филипп</a></p><p>Выглядит будто бы здраво — вынести важную часть проверки как можно раньше, и дать возможность непрограммистам читать/проверять.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;В статье &lt;
      
    
    </summary>
    
    
    
      <category term="dev_method" scheme="http://spiiin.github.io/tags/dev-method/"/>
    
      <category term="dev_evolution" scheme="http://spiiin.github.io/tags/dev-evolution/"/>
    
  </entry>
  
  <entry>
    <title>Про изучение английского</title>
    <link href="http://spiiin.github.io/blog/2455145615/"/>
    <id>http://spiiin.github.io/blog/2455145615/</id>
    <published>2023-12-23T20:40:52.000Z</published>
    <updated>2023-12-26T12:32:32.801Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Так случилось, что английский я изучал максимально лениво, ровно настолько насколько он был нужен на практике. Т.е. почти никак. Изучение большого количества слов (которых можно нахвататься откуда угодно) и трёх времён уже достаточно, чтобы ухватывать смысл текстов.</p><p>Для новостей — достаточно понять всего несколько предложений. Для программерских материалов, как книг, так и докладов, тоже необходимо на удивление мало. Ну и по сути, в технических материалах английский используется в служебных целях — максимально просто объяснить идею. Возможно, выраженную неносителями для неносителей. Помимо английского, там используются несколько других нотаций — примеры на языках и псевдоязыках программирования, математические формулы, несколько типов блок схем и графиков. И эти нотации часто важнее, пояснения нужны только там, где нотация оставляет пространство для неоднозначной трактовки. Помимо этого, большая часть важной литературы переводится, или <em>пересказывается</em> русскоязычными авторами. Не вся, часто с опозданием и некачественно, но недостатка в информации не было. Ну и понятно, что серьёзная часть технических знаний просто получается на практике.</p><p>Барьером были только фильмы/сериалы и игры с большим количеством текста, но как раз это достаточно быстро локализуется, так что никогда особо не мешало. Наверное, первый раз столкнулся с тем, что не могу понять книги, когда решил попробовать изучать материалы по геймдизайну, чтобы разобраться, как работают мобильные/социальные (ну и современные сессионные тоже) игры. Есть отличный перевод Джесси Шелла, но дальше — пустота, в которой находятся и некоторые профессиональные геймдизайнеры.</p><p>Ключевой автор — Николас Ловелл, на русский не переводился, и даже не смотря на то, что у него есть вполне доступные доклады и cheet-sheet (<code>The F2P Toolbox</code>), основная книга <code>The Pyramid of Game Design</code> не переведена. Сложности возникли от того, что автор, кроме профессионального сленга геймдева, использует экономический, а помимо этого больше использует британский, а не американский английский, а также, видимо, не особо старался адаптировать книгу для иностранных читателей. В общем, пришлось читать и переводить её со словарём, каждой отдельное предложение. Получилось выписать около 1500 слов. По итогу я даже зачем-то отправил Ловеллу мейл с благодарностью и рассказом, как я задолбался её переводить. Неожиданно, он даже ответил и сказал, что пообщался со своим издателем и разрешил выложить три главы перевода, если будет желание. Более лайтовый вариант — <code>Designing Virtual Worlds</code> Ричарда Бартла. Немного устаревшая в технической части, но по прежнему интересная и сейчас как исследование сообществ игроков MMO игр. Наверное, эти две книги (<em>ну,и эмиграция…</em>) подвели к мысли, что пора бы разобраться не только с переводом слов.</p><h2 id="Грамматика"><a href="#Грамматика" class="headerlink" title="Грамматика"></a>Грамматика</h2><p>До этого я пробовал заниматься на онлайн платформе skyeng (бонусом от работодателя), но без особой пользы, разговаривать на базовом уровне получалось уже и так, но особого прогресса в этом не наблюдалось. Хотелось найти что-то отличное от коммуникативного подхода. Ну и собственно, нашёл <a href="https://habr.com/ru/users/LeonidFirstov/publications/articles/" target="_blank" rel="noopener">CT-School</a>. Описанное сильно отличалось от стандартного подхода, и совпадало с тем, что мне казалось было нужно.</p><ul><li>разбор грамматики не минимально, а хорошо. Знание слов и выражений полезно (и легче даётся) поверх этого. Теория &gt; практика в начале</li><li>говорящий с тобой на одном языке преподаватель лучше носителя, так как может объяснить связи между языками</li><li>преподаватель нужен</li><li>ощутимый прогресс должен быть быстрее, чем за полгода-год, как на “разговорных” курсах</li><li>учиться лучше в короткий промежуток времени (<a href="https://ailev.livejournal.com/1130190.html" target="_blank" rel="noopener">Как зажечь мастерство</a>)</li></ul><p>Сама методика тоже сильно отличается от стандартного подхода:</p><ul><li>занятия “до талого”, пока не разобрана тема, иногда по 4 часа</li><li>небольшое количество точных формулировок, заучиваются за время занятий, нет требований учить что-то самостоятельно</li><li>курс начинается с самого начала, но достаточно быстро разгоняется. Полезно для заполнения пробелов в знаниях</li><li>пропускать занятия нельзя, домашние задания обязательны к выполнению и тщательно проверяются. Шанс не обучиться минимальный</li></ul><p>На занятиях разбираются упражнения из  <code>Grammar In Use</code> Мерфи, и <code>Round Up</code> 4 уровня.</p><p>В дополнение я занимался тем, что смотрел видео <a href="https://www.engvid.com/topic/grammar/" target="_blank" rel="noopener">engVid</a></p><p>Самое главное - <code>ChatGPT</code>, как “компилятор” естественного языка. Удобно скармливать ему грамматические конструкции и просить проверить “а можно ли так”, и просить генерировать примеры использования.<br>(Например <em>There lived a hobbit</em> vs <em>There lived the hobbit</em> — второе тоже возможно, но будет означать немного другое)<br><img src="/blog/2455145615/t2.png" alt=""><br><em>ии никогда не устанет, не накричит, не скажет что занят и ему некогда, он всегда будет рядом…</em></p><p>В какой-то момент ощутил “формульность” грамматического языка, какие-то слова или конструкции имеют <em>валентность</em>, и прикрепляют к себе другие готовые куски. Ну и понимание, с каким массивом информации вообще столкнулся, прошло ощущение, что нужно только немного заполнить пробелы.</p><p>Для практики перевода с русского на английский - <code>Современная английская грамматика</code> Комаровской. Там подобраны несколько типов предложений — коряво звучащие на русском, но “сворачивающиеся” в элегантные на английском, и наоборот, сложные русские, не имеющие буквального перевода. Полезно, чтобы научиться выбирать максимально близкий перевод слова на английский.</p><h2 id="Чтение"><a href="#Чтение" class="headerlink" title="Чтение"></a>Чтение</h2><ul><li>Толкиен как энциклопедия языка. Читаю с целью подмечать нестандартные предложения и разбирать их</li><li>Книжки по методу Франка. Вроде удобно иметь перевод без напряга, но читать особо некогда</li><li>Газеты и новости. Современный язык в плане слов, но грамматически часто свой отдельный стиль</li><li>Книжки с близким к разговорному языком. Примеры — <code>Sh*t my dad says</code> Justin Hulpers, <code>The lost continent, travels in small town America</code> Bill Bryson.</li><li>История английского языка. <code>Приключения английского языка</code> Брэгг М.</li></ul><h2 id="Аудирование"><a href="#Аудирование" class="headerlink" title="Аудирование"></a>Аудирование</h2><p><a href="https://www.youtube.com/@PhoneticFanatic" target="_blank" rel="noopener">PhoneticPhanatic</a> — для начала, можно научиться правильны <em>слышать</em> звуки. Безумно крутой дядька<br><a href="https://www.youtube.com/@dailydictation" target="_blank" rel="noopener">Daily Dictation</a> — упражнения<br><a href="https://www.languagereactor.com/m/yt_en_-" target="_blank" rel="noopener">Language Reactor</a> — ролики на ютубе с двойными субтитрами, и возможностью настроить паузы/хоткеи на отдельные фразы<br><a href="https://youglish.com/" target="_blank" rel="noopener">Youglish</a> — находит ролики на ютубе, в которых можно послушать варианты произношения слова или фразы</p><p>Для себя поставил целью научиться слушать профессиональные подкасты:<br><a href="https://eggplant.show/into-the-depths-super-mario-world-part-1" target="_blank" rel="noopener">Into the Depth: Super Mario World</a> — серия подкастов про <em>Super Mario World</em> от известных инди-разработчиков. Вот прямо очень хороший тест, у ведущих и гостей диалекты из Британии, США, Германии, Австралии и ЮАР.<br><a href="https://www.idlethumbs.net/designernotes" target="_blank" rel="noopener">Designer Notes</a> — не знаю автора, но регулярно зовёт к себе гостей типа Сида Мейера или Криса Авеллона<br><a href="https://www.youtube.com/@jblow888/videos" target="_blank" rel="noopener">Jonathan Blow</a> — стримы, или любые другие материалы, про программирование и инди-разработку</p><p>Из общего — можно слушать локальные радиостанции (non commercial national radio stations).</p><p>Там где было пока сложно, сделал для себя хаки:<br><a href="https://github.com/spiiin/eng_helpers/blob/main/AutoKeyPress.ipynb" target="_blank" rel="noopener">AutoKeyPress</a> — скрипт к плагину <a href="https://addons.videolan.org/p/1154027" target="_blank" rel="noopener">Subtitler lite mod</a>, для отображения одновременно двух субтитров для <code>VLC</code>. Плагин зачем-то требует регулярного нажатия кнопки для обновления вторых субтитров. Классическое “после сборки обработать напильником”.<br><a href="https://github.com/spiiin/eng_helpers/blob/main/Split%20subtitles%20from%20chrome.ipynb" target="_blank" rel="noopener">Split subtitles from chrome</a> — Chrome умеет преобразовывать в текст любой звук из браузера (Live Caption), но отрисовывает текст на отдельном канвасе, с которого нельзя скопировать. Это не очень подходит для учебных целей, но можно включить <a href="https://www.reddit.com/r/chrome/comments/mcw75z/is_there_a_way_to_copy_and_paste_the_text_that_is/" target="_blank" rel="noopener">логгирование событий</a>, в котором среди прочему пролетают и уведомления об изменении текста в этом канвасе. Скрипт позволяет собрать сообщения из этого лога и превратить в осмысленный текст (с некоторым шаманством в виде проверки расстояния Левенштейна и склейки строк после переносов).</p><h2 id="Слова"><a href="#Слова" class="headerlink" title="Слова"></a>Слова</h2><p>Куча приложений с карточками для изучения, но мне чё-то не очень нравится такой метод. Нужно будет какой-нибудь генератор майнд-карт замутить, что ли.<br>Из того, что +/- показалось полезным/интересным</p><ul><li>сканворды. Полно приложений, или просто сайтов с вопросами.</li><li>инструмент отслеживания списка слов в languagereactor. Интегрирован с другими инструментами сайта, окрашивает знакомые, незнакомые, изучаемые и редкие слова разными цветами. + тест, который определяет базовый уровень словарного запаса, чтобы не заполнять с нуля. Требует платной регистрации.</li><li>толковый словарь + chatgpt. Запрос типа “объясни происхождение слова, приведи примеры употребления, синонима и однокоренные слова”.</li></ul><h2 id="Разговор"><a href="#Разговор" class="headerlink" title="Разговор"></a>Разговор</h2><p><a href="https://www.youtube.com/@KirillsEnglish" target="_blank" rel="noopener">Kirill’s English</a> - конкретные фразы для диалогов, произношение звуков и фраз, методология</p><h2 id="Тесты"><a href="#Тесты" class="headerlink" title="Тесты"></a>Тесты</h2><p><a href="https://learnenglish.britishcouncil.org/english-levels/online-english-level-test" target="_blank" rel="noopener">https://learnenglish.britishcouncil.org/english-levels/online-english-level-test</a><br><a href="https://www.kaplaninternational.com/free-english-test-online" target="_blank" rel="noopener">https://www.kaplaninternational.com/free-english-test-online</a><br><a href="https://practicum.yandex.ru/english/placement_test/" target="_blank" rel="noopener">https://practicum.yandex.ru/english/placement_test/</a></p><p>Также у многих онлайн-школ есть бесплатное разговорное занятие с определением уровня.</p><p>Пока получается B1-B1+</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;Так случил
      
    
    </summary>
    
    
    
      <category term="english" scheme="http://spiiin.github.io/tags/english/"/>
    
  </entry>
  
  <entry>
    <title>Формат сжатия уровней в Jurassic Park [NES]</title>
    <link href="http://spiiin.github.io/blog/17440519/"/>
    <id>http://spiiin.github.io/blog/17440519/</id>
    <published>2023-12-19T12:37:09.000Z</published>
    <updated>2024-01-01T12:14:53.341Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Давно не затрагивал тему реверс-инжиниринга NES игр. После разбора блочного формата описания <a href="(https://spiiin.github.io/CadEditor/cadeditor-supported-games.html">уровней</a>), остались несколько игр, отмеченных как <em>comp</em> (уровень в ROM сжат). Сжатие уровней редко используется в играх NES, чаще сжимается текст или данные описания графики. Да и сам блочный формат уровня уже является формой экономии информации.</p><p>Тем не менее некоторые игры используют сжатие <a href="https://en.wikipedia.org/wiki/Run-length_encoding" target="_blank" rel="noopener">RLE</a>. В простых формах, как в <code>Contra</code>, или в более сложных, как в <a href="/blog/1486764983/" title="Felix The Cat">Felix The Cat</a> , где применяется гибрид RLE и словарного метода. Другие применяют формы <strong><code>&quot;описания на холсте&quot;</code></strong>, когда команды отрисовки задаются в виде “нарисуй что-то в координатах X,Y” (описание карты мира в играх <code>Capcom</code> или уровней в <code>Super Mario Bros</code>).</p><p>Это относительно простые алгоритмы. Но отдельные игры идут дальше и применяют более совершенные формы сжатия:</p><p><a href="https://romhack.github.io/doc/halCompression/" target="_blank" rel="noopener">Kirby</a> и другие игры <code>HAL</code> - гибрид LZ алгоритмов и RLE, с несколькими командами вроде “следующие биты развернуть”.<br><a href="https://github.com/romhack/codemastersMarkov" target="_blank" rel="noopener">Dizzy</a> и другие игры <code>Codemasters</code> - сжатие графики цепями Маркова.</p><p>Формат уровней этих игр описан. Однако, в моём списке игр, добавленных в <a href="https://github.com/spiiin/CadEditor/blob/master/CadEditor/cad_editor_supported_games.txt" target="_blank" rel="noopener">CadEditor</a> были ещё две — <code>Jurassic Park</code> и <code>James Bond Jr</code>. Я выбрал для разбора <code>Jurassic Park</code>, потому что знал, что в нём используется разновидность <a href="https://en.wikipedia.org/wiki/LZ77_and_LZ78" target="_blank" rel="noopener">LZ</a>, потому что хотел заодно прочитать про сам алгоритм и его разновидности.</p><a id="more"></a><h2 id="Вступление"><a href="#Вступление" class="headerlink" title="Вступление"></a>Вступление</h2><p>(оно же отступление)</p><p>При исследовании нового ты оказываешься перед уникальной задачей <strong>один на один</strong>. В CadEditor-е есть пара кусков кода, связанных с LZ-сжатием ( <a href="https://spiiin.github.io/CadEditor/cadeditor-using-lzkn.html">LZKN</a>, написанный <code>DrMephisto</code>, и <a href="/blog/1579894033/" title="карты FFTA">карты FFTA</a> авторства <code>DarcyMiles</code>), но я не касался этого алгоритма на NES.</p><p>Я не реверсил NES-игры на протяжении пяти лет, и успел забыть, что это скорее не навык, а состояние. </p><blockquote><p>“Глядя на мерцающие экраны и на безбрежный поток данных, поднятый моими алгоритмами и мчащийся в никуда по виртуальному пространству цифрового мира, я часто думаю: где я в этом потоке битов и байтов?”</p><footer><strong>ChatGPT который плагиатит Анонима который плагиатит Чингизхана</strong></footer></blockquote><p>Когда результат УЖЕ найден, алгоритм кажется тривиальным. Но до этого смотришь на матрицу байт, и бесконечный ассемблерный листинг, вообще без понятия, что перед тобой. Потом, когда нашёл свой Диснейленд (<a href="https://exsistencia.livejournal.com/3261.html" target="_blank" rel="noopener">Бодрийаровский</a>) в пещере, забываешь о состоянии, в котором был, пока смотрел в темноту. Поэтому я ценю описание состояния, а не откомментированный результат.</p><h2 id="Блоки"><a href="#Блоки" class="headerlink" title="Блоки"></a>Блоки</h2><p>Первое, что можно сделать — закинуть в темноту <a href="/blog/2598119234/" title="лидар">лидар</a> (<code>autocorrupter + blockfinder</code>), который покажет “общую форму пещеры”.</p><p>Он отлично работает и на сжатых картах, единственное, что запускать его нужно не на область ROM, а на область RAM, в которой находятся расжатые данные. Он показывает, что:</p><ul><li><p>описание карты уровня расположено по адресам 0x60C8-0x72CB, индексами блоков, по 2 байта на блок. 3 нибла кодируют номер блока, 4-й - физические свойства блока<br>(является ли блок выходом из уровня, препятствием, передним или задним фоном)</p></li><li><p>размер блока 2x2, описание которых асположено по адресам 0x76CC, блоков 352 штуки</p></li><li><p>слой бит палитры блоков описан отдельно от описания блоков. Т.е. любой блок можно окрасить в любую из 4х палитр<br><img src="/blog/17440519/jp_map0_small.png" alt=""></p></li></ul><p>Также обнаруживается интересная особенность — игра переключает активный банк видеопамяти блоков, когда игрок выходит из нижней или верхней трети экрана в центральную часть. Так что блоки с индексами &gt;0x80 могут распологаться только в нижней трети уровня (ими в первом уровне отрисованы здания).<br><img src="/blog/17440519/jp_map1_small.png" alt=""></p><p>(<a href="https://github.com/spiiin/CadEditor/blob/master/CadEditor/settings_nes/jurassic_park/Settings_JurassicPark_1.cs" target="_blank" rel="noopener">Конфиг для CadEditor-а</a>)</p><p>Область 0x1000-0x7FFF - это 6-кб CHR-RAM, память доступная для записи, располагается на картридже, в дополнение к 2кб памяти NES (это один из самых больших <a href="https://nescartdb.com/profile/view/1038/jurassic-park" target="_blank" rel="noopener">картриджей</a>)</p><h2 id="Декомпрессия"><a href="#Декомпрессия" class="headerlink" title="Декомпрессия"></a>Декомпрессия</h2><p>Если поставить брейкпоинт на запись в 0x60C8 (это значение прописано в игре хардкодом как область распаковки), можно выйти на адрес архива в ROM - 0x9D94 (адрес записан в ячейки памяти 95-96).</p><p>Также, изучай трейслог между чтением байта из ROM и записью в RAM, стоит запомнить все ячейки, которые изменяются походу — 6F, 70, 73, 74, 75.<br>(<em>меня восхищает, что трейслог команд на ассемблере 6502 может разобрать chatgpt, очень интересно было бы узнать, на каких входных данных он обучился</em>)</p><p>Первые байты архива в ROM и соответствующие им байты распакованных данных:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x9D94: 18 00 20 04 0C 84 00 64</span><br><span class="line">0x60C8: 30 00 30 00 06 84 00 84</span><br></pre></td></tr></table></figure></p><p>Пока что связь между сжатыми данными и расжатыми неочевидна. Просто изменять наугад байты архива в ROM (например 0x648C) бесполезно, меняется большая группа распакованных данных, на стенках нашей тёмной пещеры из байт оказывается калейдоскоп из зеркал, отражающих лучи по непредсказуемым траекториям<br><img src="/blog/17440519/jp3.png" alt=""></p><p>Более изящный способ — написать lua-скрипт для эмулятора, который будет трассировать в файл все чтения из архива и записи распакованных данных, а также состояние управляющих распаковкой ячеек.</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> logFile = <span class="built_in">io</span>.<span class="built_in">open</span>(<span class="string">"jp_unpack1.txt"</span>, <span class="string">"w"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">readMemoryValues</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        memory.readbyte(<span class="number">0x73</span>),</span><br><span class="line">        memory.readbyte(<span class="number">0x74</span>),</span><br><span class="line">        memory.readbyte(<span class="number">0x75</span>),</span><br><span class="line">        memory.readbyte(<span class="number">0x6F</span>),</span><br><span class="line">        memory.readbyte(<span class="number">0x70</span>)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">logMemoryOperation</span><span class="params">(operation, address, value)</span></span></span><br><span class="line">    <span class="keyword">local</span> values = readMemoryValues()</span><br><span class="line">    logFile:<span class="built_in">write</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">"%s %04X %s %02X --- 73: %02X, 74: %02X, 75: %02X, 6F: %02X, 70: %02X\n"</span>,</span><br><span class="line">                                operation, address, operation == <span class="string">"WRITE"</span> <span class="keyword">and</span> <span class="string">"-&gt;"</span> <span class="keyword">or</span> <span class="string">"&lt;-"</span>, value,</span><br><span class="line">                                <span class="built_in">table</span>.<span class="built_in">unpack</span>(values)))</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">onRead</span><span class="params">(address, size, value)</span></span></span><br><span class="line">    logMemoryOperation(<span class="string">"READ "</span>, address, value)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">onWrite</span><span class="params">(address, size, value)</span></span></span><br><span class="line">    logMemoryOperation(<span class="string">"WRITE"</span>, address, value)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">onWriteExt</span><span class="params">(address, size, value)</span></span></span><br><span class="line">    logMemoryOperation(<span class="string">"     "</span>, address, value)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">registerMemoryCallbacks</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> readRangeStart, readRangeEnd = <span class="number">0x9D94</span>, <span class="number">0xA4B1</span></span><br><span class="line">    <span class="keyword">local</span> writeRangeStart, writeRangeEnd = <span class="number">0x60C8</span>, <span class="number">0x72CB</span></span><br><span class="line">    <span class="keyword">local</span> extendedWriteAddresses = &#123;<span class="number">0x6F</span>, <span class="number">0x70</span>, <span class="number">0x73</span>, <span class="number">0x74</span>, <span class="number">0x75</span>&#125;</span><br><span class="line"></span><br><span class="line">    memory.registerread(readRangeStart, readRangeEnd - readRangeStart + <span class="number">1</span>, onRead)</span><br><span class="line">    memory.registerwrite(writeRangeStart, writeRangeEnd - writeRangeStart + <span class="number">1</span>, onWrite)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, address <span class="keyword">in</span> <span class="built_in">ipairs</span>(extendedWriteAddresses) <span class="keyword">do</span></span><br><span class="line">        memory.registerwrite(address, <span class="number">1</span>, onWriteExt)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">registerMemoryCallbacks()</span><br><span class="line"></span><br><span class="line">emu.registerexit(<span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">if</span> logFile <span class="keyword">then</span></span><br><span class="line">        logFile:<span class="built_in">close</span>()</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>)</span><br></pre></td></tr></table></figure><p>Получается такой лог (большая часть незначащей информации вырезана)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">READ  9D94 &lt;- 18    --- 73: 00, 74: 00, 75: 00, 6F: 00, 70: 00</span><br><span class="line">READ  9D95 &lt;- 00    --- 73: 00, 74: 02, 75: 00, 6F: 18, 70: 00</span><br><span class="line">   WRITE 60C8 -&gt; 30 --- 73: 00, 74: 00, 75: 00, 6F: 30, 70: 00</span><br><span class="line">READ  9D96 &lt;- 20    --- 73: 00, 74: 03, 75: 00, 6F: 00, 70: 00</span><br><span class="line">   WRITE 60C9 -&gt; 00 --- 73: 80, 74: 00, 75: 00, 6F: 00, 70: 00</span><br><span class="line">                 75 --- 73: 00, 74: 00, 75: 02, 6F: 02, 70: 00</span><br><span class="line">                 74 --- 73: 00, 74: 0A, 75: 02, 6F: 02, 70: 00</span><br><span class="line">                 73 --- 73: 00, 74: 0A, 75: 02, 6F: 02, 70: 00</span><br><span class="line">                 6F --- 73: 00, 74: 0A, 75: 02, 6F: 04, 70: 00</span><br><span class="line">                 70 --- 73: 00, 74: 0A, 75: 02, 6F: 04, 70: 00</span><br><span class="line">                 74 --- 73: 00, 74: 09, 75: 02, 6F: 04, 70: 00</span><br><span class="line">                 73 --- 73: 00, 74: 09, 75: 02, 6F: 04, 70: 00</span><br><span class="line">                 6F --- 73: 00, 74: 09, 75: 02, 6F: 08, 70: 00</span><br><span class="line">                 70 --- 73: 00, 74: 09, 75: 02, 6F: 08, 70: 00</span><br><span class="line">                 74 --- 73: 00, 74: 08, 75: 02, 6F: 08, 70: 00</span><br><span class="line">                 73 --- 73: 00, 74: 08, 75: 02, 6F: 08, 70: 00</span><br><span class="line">                 6F --- 73: 00, 74: 08, 75: 02, 6F: 10, 70: 00</span><br><span class="line">                 70 --- 73: 00, 74: 08, 75: 02, 6F: 10, 70: 00</span><br><span class="line">                 74 --- 73: 00, 74: 07, 75: 02, 6F: 10, 70: 00</span><br><span class="line">                 73 --- 73: 00, 74: 07, 75: 02, 6F: 10, 70: 00</span><br><span class="line">                 6F --- 73: 00, 74: 07, 75: 02, 6F: 20, 70: 00</span><br><span class="line">                 70 --- 73: 00, 74: 07, 75: 02, 6F: 20, 70: 00</span><br><span class="line">READ  9D97 &lt;- 04    --- 73: 00, 74: 07, 75: 02, 6F: 20, 70: 00</span><br><span class="line">   WRITE 60CA -&gt; 30 --- 73: 00, 74: 00, 75: 02, 6F: 01, 70: 00</span><br><span class="line">   WRITE 60CB -&gt; 00 --- 73: 00, 74: 00, 75: 01, 6F: 01, 70: 00</span><br><span class="line">READ  9D98 &lt;- 0C    --- 73: 00, 74: 08, 75: 00, 6F: 04, 70: 00</span><br><span class="line">   WRITE 60CC -&gt; 06 --- 73: 00, 74: 00, 75: 00, 6F: 06, 70: 00</span><br><span class="line">READ  9D99 &lt;- 84    --- 73: 00, 74: 01, 75: 00, 6F: 0C, 70: 00</span><br><span class="line">READ  9D9A &lt;- 00    --- 73: 00, 74: 01, 75: 00, 6F: 84, 70: 00</span><br><span class="line">   WRITE 60CD -&gt; 84 --- 73: 00, 74: 00, 75: 00, 6F: 84, 70: 00</span><br><span class="line">READ  9D9B &lt;- 64    --- 73: 00, 74: 02, 75: 00, 6F: 00, 70: 00</span><br><span class="line">   WRITE 60CE -&gt; 00 --- 73: C8, 74: 00, 75: 00, 6F: 00, 70: 00</span><br><span class="line">READ  9D9C &lt;- 01    --- 73: 00, 74: 09, 75: 03, 6F: 64, 70: 00</span><br><span class="line">READ  9D9D &lt;- 00    --- 73: 00, 74: 01, 75: 03, 6F: 01, 70: 64</span><br><span class="line">   WRITE 60CF -&gt; 84 --- 73: 00, 74: 00, 75: 03, 6F: 01, 70: 00</span><br><span class="line">   WRITE 60D0 -&gt; 00 --- 73: 00, 74: 00, 75: 02, 6F: 01, 70: 00</span><br><span class="line">   WRITE 60D1 -&gt; 84 --- 73: 00, 74: 00, 75: 01, 6F: 01, 70: 00</span><br><span class="line">READ  9D9E &lt;- A1    --- 73: 00, 74: 02, 75: 00, 6F: 00, 70: 00</span><br></pre></td></tr></table></figure><p>Из этого лога уже можно извлечь почти всё, что нужно для понимания распаковки.</p><p>Это очень важный момент! Можно реверс-инжинирить алгоритм в IDA, или долго играться с отладчиком. А можно и не делать этого и перечитать раздел “вступление” ещё раз. <strong>РЕВЕРС НЕ НАВЫК, А СОСТОЯНИЕ</strong>. Т.е. можно обнаружить, что ты уже знаешь решение, просто глядя на трейс-лог, или гуляя по улице — это не фигура речи. Для проверки правильности решения придётся, конечно, использовать листик и ручку, или отладчик, и скорее всего первичная идея будет содержать ошибки, на само понимание находится где-то до использования инструментов. Всё, что дальше — уже просто проверка, тривиальная часть.</p><ul><li><p>Байты на выход выдаются не сразу после команды чтения, а с задержкой на какие-то операции, т.е. скорее всего команды кодируются некратным 8 числом бит</p></li><li><p>в ячейке 75 хранится число байт, который будут скопированы из самого выходного потока. Так как это значение не зависит от других управляющих ячеек, вероятно, существуют специальные команды, в которых количество повторов кодируется самой командой. Это важный вывод, который можно и нужно перепроверить</p></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">07:D4B0: A9 02     LDA #$02 &#x2F;&#x2F;immediate set</span><br><span class="line">07:D4B2: 85 75     STA $75 repeats &#x3D; #$02</span><br></pre></td></tr></table></figure><ul><li>в ячейке 74 — количество оставшихся для считывания бит для текущей команды. Если при этом “заканчиваются” биты в очередном байте из входной последовательности, считывается следующий</li></ul><p>Осталось разобрать, как именно работают команды, выдающие в выходой поток значения, которые уже находились в нём ранее.<br>Можно поставить точки остановки на область записи распакованных данных и внимательно посмотреть на байты на выходе в тех случаях, когда они не читаются из входного архива.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WRITE 60C8 -&gt; 30  &lt;-----------\</span><br><span class="line">WRITE 60C9 -&gt; 00              |</span><br><span class="line">WRITE 60CA -&gt; 30 00 (2 байта) |</span><br><span class="line">WRITE 60CC -&gt; 06</span><br><span class="line">WRITE 60CD -&gt; 84  &lt;--------------\</span><br><span class="line">WRITE 60CE -&gt; 00                 |</span><br><span class="line">WRITE 60CF -&gt; 84 00 84 (3 байта) |</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>Это и есть основной принцип работы алгоритма <code>LZSS</code> — он умеет ссылаться на уже существующие в выходной последовательности цепочки байт.</p><p>Можно заодно обратить внимание на интересную особенность — цепочка байт 60CF-60D1 использует ссылку на 60CD-60CF - конец этой цепочки еще не существует в выходной последовательности к моменту использования ссылки на неё (<code>overlapping-lookingahead</code>).</p><p><code>LZSS</code> можно считать обобщением <code>RLE</code> — <code>RLE</code> умеет ссылаться лишь 1 последний символ в выходной последовательности, а <code>LZSS</code> — на любую уже встреченную цепочку символов. Различные разновидности <code>LZSS</code>, в зависимости от выделенных на кодирование бит, ограничены в том, насколько далеко назад они могут заглянуть (<strong><code>размер скользящего окна</code></strong>) и на длину цепочки повторяющихся байт.</p><p>Раз входной поток работает на уровне бит, а не байт, то удобно было бы представить его в трейслоге в виде бит. Можно или вписать дополнительную информацию в скрипт трейса (чаще всего работа с битами осуществляется через сдвиги + проверку флага, в который попадаёт сдвинутый бит). Ну или просто набросать скрипт, который парсит уже имеющийся лог, но следит при этом за накопленными битами:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract_byte_from_read_line</span><span class="params">(line)</span>:</span></span><br><span class="line">    hex_value = line.split(<span class="string">'&lt;-'</span>)[<span class="number">1</span>].strip()[:<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">return</span> format(int(hex_value, <span class="number">16</span>), <span class="string">'08b'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract_argument_from_74_line</span><span class="params">(line)</span>:</span></span><br><span class="line">    hex_argument = line.split(<span class="string">'74:'</span>)[<span class="number">1</span>].split(<span class="string">','</span>)[<span class="number">0</span>].strip()</span><br><span class="line">    <span class="keyword">return</span> int(hex_argument, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_write_command</span><span class="params">(accumulated_bits)</span>:</span></span><br><span class="line">    bit_string = <span class="string">''</span>.join(accumulated_bits)</span><br><span class="line">    print(<span class="string">f"<span class="subst">&#123;bit_string&#125;</span> (<span class="subst">&#123;len(accumulated_bits)&#125;</span> bits)"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_and_print_bits</span><span class="params">(lines)</span>:</span></span><br><span class="line">    current_byte = <span class="literal">None</span></span><br><span class="line">    bit_index = <span class="number">0</span></span><br><span class="line">    accumulated_bits = []</span><br><span class="line">    command_lengths = set()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        line = line.strip()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> line.startswith(<span class="string">'READ'</span>):</span><br><span class="line">            current_byte = extract_byte_from_read_line(line)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> line.startswith(<span class="string">'74 ---'</span>):</span><br><span class="line">            argument = extract_argument_from_74_line(line)</span><br><span class="line">            <span class="keyword">if</span> argument != <span class="number">0</span> <span class="keyword">and</span> current_byte <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                accumulated_bits.append(current_byte[bit_index])</span><br><span class="line">                bit_index = (bit_index + <span class="number">1</span>) % <span class="number">8</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> line.startswith(<span class="string">'WRITE'</span>):</span><br><span class="line">            <span class="keyword">if</span> accumulated_bits:</span><br><span class="line">                command_lengths.add(len(accumulated_bits))</span><br><span class="line">                process_write_command(accumulated_bits)</span><br><span class="line">                print(<span class="string">"  "</span> + line.split(<span class="string">"---"</span>)[<span class="number">0</span>])</span><br><span class="line">            accumulated_bits = []</span><br><span class="line">            </span><br><span class="line">    print(<span class="string">f"Commands lengths: <span class="subst">&#123;command_lengths&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"jp_unpack_60C8_72CB.txt"</span>, <span class="string">"rt"</span>) <span class="keyword">as</span> file:</span><br><span class="line">    lines = file.readlines()</span><br><span class="line">parse_and_print_bits(lines)</span><br></pre></td></tr></table></figure><p>(тривиальная логика, следим за состоянием 74 - ячейки которая контроллирует, сколько бит осталось прочитать в текущей команде)</p><p>Обнаруживаем, что есть всего 4 типа команд - из 9, 13, 15 и 23 бит:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">000110000 (9 bits)</span><br><span class="line">  WRITE 60C8 -&gt; 30</span><br><span class="line">100000000001 (12 bits)</span><br><span class="line">  WRITE 60CA -&gt; 30 </span><br><span class="line">  WRITE 60CB -&gt; 00</span><br><span class="line">110010000000001 (15 bits)</span><br><span class="line">  WRITE 60CF -&gt; 84 </span><br><span class="line">  WRITE 60D0 -&gt; 00 </span><br><span class="line">  WRITE 60D1 -&gt; 84</span><br><span class="line">11000000001100001011101 (23 bits)</span><br><span class="line">  WRITE 729F -&gt; 84 </span><br><span class="line">  WRITE 72A0 -&gt; 3A </span><br><span class="line">  WRITE 72A1 -&gt; 84 </span><br><span class="line">  WRITE 72A2 -&gt; 3A </span><br><span class="line">  WRITE 72A3 -&gt; 84 </span><br><span class="line">  WRITE 72A4 -&gt; 3A </span><br><span class="line">  WRITE 72A5 -&gt; 84 </span><br><span class="line">  WRITE 72A6 -&gt; 3A </span><br><span class="line">  WRITE 72A7 -&gt; 84 </span><br><span class="line">  WRITE 72A8 -&gt; 3A </span><br><span class="line">  WRITE 72A9 -&gt; 84 </span><br><span class="line">  WRITE 72AA -&gt; 3A </span><br><span class="line">  WRITE 72AB -&gt; 84 </span><br><span class="line">  WRITE 72AC -&gt; 34 </span><br><span class="line">  WRITE 72AD -&gt; 84</span><br></pre></td></tr></table></figure><p>Такого лога достаточно для расшифровки формата команд (в полном логе их сотни)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 00110000</span><br><span class="line">команда выдачи несжатого байта из входного потока, 0 - код команды</span><br><span class="line"></span><br><span class="line">10 0000000001</span><br><span class="line">команда копирования 2х байт (2 - константа, не закодировано в команде)</span><br><span class="line">Биты 10 - код команды</span><br><span class="line">Байты считываются по 10-битному смещению назад от текушей позиции выходного потока</span><br><span class="line"></span><br><span class="line">11000 00000110 0001011101</span><br><span class="line">команда копирования 9+X байт из выходного потока</span><br><span class="line">Биты 11000 - код команды</span><br><span class="line">Количество закодировано 8 битами (9+0b00000110 &#x3D; 15 байт)</span><br><span class="line">Смещение закодировано 10 битами</span><br><span class="line"></span><br><span class="line">11 001 0000000001</span><br><span class="line">команда копирования 2+X байт из выходного потока</span><br><span class="line">Количество закодировано 3 битами - (2+0b001 &#x3D; 3 байта)</span><br><span class="line">Смещение закодировано 10 битами</span><br></pre></td></tr></table></figure></p><p>Или в виде блок-схемы:<br><img src="/blog/17440519/diagram.png" alt=""></p><p>4612 байт карты сжимаются этим алгоритмом в 1822 байт архива.</p><h2 id="Семейство-LZSS"><a href="#Семейство-LZSS" class="headerlink" title="Семейство LZSS"></a>Семейство LZSS</h2><p>В отличие от классического <a href="https://ru.wikipedia.org/wiki/LZSS" target="_blank" rel="noopener">LZSS</a>, здесь использованы 3 типа команд копирования фразы разной длины, чтобы сэкономить немного места на более коротких повторяющихся последовательностях.</p><p>Алгоритм активно использовался еще как минимум 2 поколения консолей, так что похожие трюки и вариации можно найти в большинстве компрессоров для Sega Mega Drive или SNES:<br><a href="https://github.com/lab313ru/lzkn" target="_blank" rel="noopener">lzkn</a> — 3 варианта сжатия <code>Konami</code><br><a href="https://github.com/flamewing/mdcomp" target="_blank" rel="noopener">mdcomp</a> — компрессоры из <code>Sonic</code> (Kosinski, Nemesis, Saxman и другие). Generic код, с поддержкой нескольких вариантов алгоритма.</p><p>Отличия в вариациях алгоритмов:</p><ul><li>Часто биты команд сгруппированаы в отдельные байты (description fields), а не перемешаны с битами данных. Связано это с тем, что считывать и работать с целыми байтами быстрее — можно передать 8 несжатых байт выравненными блоками</li><li>С этим же связана подстройка размера команд и сжатых данных под выравнивание</li><li>Биты/байты команд могут вообще храниться в отдельном потоке, независимом от потока аргументов этих команд (смещений и длин цепочек). Опционально — в little или big-endian.</li><li>Некоторые вариации умеют брать данные не только из окна выходного буфера, а откуда-нибудь ещё (захардкоженные словари или просто нули)</li><li>Небольшие отличия в порядке хранения байт данных и байт команд из сжатого потока:<ul><li>пишется ли следующий байт команд сразу, как заканчиваются биты предыдущего, или только когда потребуются новые биты </li><li>необходим ли финальный байт команд (например, если в нём могут содержаться биты окончания потока)</li></ul></li></ul><p>В <strong><code>mdcomp</code></strong> эти настройки вынесены в шаблонный класс-адаптор <a href="https://github.com/flamewing/mdcomp/blob/26bfc205b96afe04e0941d3092865eaf6c972f81/include/mdcomp/lzss.hh#L223" target="_blank" rel="noopener">LZSSAdaptor</a></p><p>Кроме различий в кодировании команд могут отличаться также и алгоритмы компрессии. Большинство компрессоров реализуют примитивный алгоритм поиска подстроки в скользящем окне. Возможные оптимизации:</p><ul><li>использование структур для более быстрого поиска подстроки (<a href="https://github.com/flamewing/mdcomp/blob/26bfc205b96afe04e0941d3092865eaf6c972f81/include/mdcomp/lzss.hh#L223" target="_blank" rel="noopener">сравнение</a>).</li><li>проверка не только самой длинной подстроки, не и более коротких — с набором укороченных команд это может дать лучший результат (<a href="https://sonicresearch.org/community/index.php?threads/konami-compression-tools.5937/#post-84424" target="_blank" rel="noopener">пример</a> для Kosinki)</li><li>учёт самопересечения цепочки — байт начала цепочки, выданные в выходной буфер, могут служить концом этой же цепочки (<a href="https://stackoverflow.com/questions/31347593/matches-overlapping-lookahead-on-lz77-lzss-with-suffix-trees" target="_blank" rel="noopener">overlapping-lookahead</a>)</li></ul><p>Репо со скриптами и логами<br><a href="https://github.com/spiiin/nes_compression/tree/main/jurassic_park" target="_blank" rel="noopener">https://github.com/spiiin/nes_compression/tree/main/jurassic_park</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Давно не затрагивал тему реверс-инжиниринга NES игр. После разбора блочного формата описания &lt;a href=&quot;(https://spiiin.github.io/CadEditor/cadeditor-supported-games.html&quot;&gt;уровней&lt;/a&gt;), остались несколько игр, отмеченных как &lt;em&gt;comp&lt;/em&gt; (уровень в ROM сжат). Сжатие уровней редко используется в играх NES, чаще сжимается текст или данные описания графики. Да и сам блочный формат уровня уже является формой экономии информации.&lt;/p&gt;
&lt;p&gt;Тем не менее некоторые игры используют сжатие &lt;a href=&quot;https://en.wikipedia.org/wiki/Run-length_encoding&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;RLE&lt;/a&gt;. В простых формах, как в &lt;code&gt;Contra&lt;/code&gt;, или в более сложных, как в &lt;a href=&quot;/blog/1486764983/&quot; title=&quot;Felix The Cat&quot;&gt;Felix The Cat&lt;/a&gt; , где применяется гибрид RLE и словарного метода. Другие применяют формы &lt;strong&gt;&lt;code&gt;&amp;quot;описания на холсте&amp;quot;&lt;/code&gt;&lt;/strong&gt;, когда команды отрисовки задаются в виде “нарисуй что-то в координатах X,Y” (описание карты мира в играх &lt;code&gt;Capcom&lt;/code&gt; или уровней в &lt;code&gt;Super Mario Bros&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Это относительно простые алгоритмы. Но отдельные игры идут дальше и применяют более совершенные формы сжатия:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://romhack.github.io/doc/halCompression/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Kirby&lt;/a&gt; и другие игры &lt;code&gt;HAL&lt;/code&gt; - гибрид LZ алгоритмов и RLE, с несколькими командами вроде “следующие биты развернуть”.&lt;br&gt;&lt;a href=&quot;https://github.com/romhack/codemastersMarkov&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Dizzy&lt;/a&gt; и другие игры &lt;code&gt;Codemasters&lt;/code&gt; - сжатие графики цепями Маркова.&lt;/p&gt;
&lt;p&gt;Формат уровней этих игр описан. Однако, в моём списке игр, добавленных в &lt;a href=&quot;https://github.com/spiiin/CadEditor/blob/master/CadEditor/cad_editor_supported_games.txt&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CadEditor&lt;/a&gt; были ещё две — &lt;code&gt;Jurassic Park&lt;/code&gt; и &lt;code&gt;James Bond Jr&lt;/code&gt;. Я выбрал для разбора &lt;code&gt;Jurassic Park&lt;/code&gt;, потому что знал, что в нём используется разновидность &lt;a href=&quot;https://en.wikipedia.org/wiki/LZ77_and_LZ78&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LZ&lt;/a&gt;, потому что хотел заодно прочитать про сам алгоритм и его разновидности.&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="nes" scheme="http://spiiin.github.io/tags/nes/"/>
    
      <category term="hack" scheme="http://spiiin.github.io/tags/hack/"/>
    
  </entry>
  
  <entry>
    <title>Подсветка daScript для hexo</title>
    <link href="http://spiiin.github.io/blog/3460926079/"/>
    <id>http://spiiin.github.io/blog/3460926079/</id>
    <published>2023-09-28T10:21:41.000Z</published>
    <updated>2023-09-28T10:50:22.738Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>daScript в <code>vscode</code> для подсветки может использовать файл с описанием <a href="https://github.com/GaijinEntertainment/vscode-dascript/blob/master/syntaxes/dascript.tmLanguage.yaml" target="_blank" rel="noopener">синтаксиса</a>, или <a href="https://github.com/profelis/daScript-plugin" target="_blank" rel="noopener">language server</a> (само хост приложение знает больше о своих данных и коде, чтобы подсказывать редактору).</p><p>Формат описания синтаксиса языков подсветки для <code>hexo</code> отличается, поэтому всё время до этого я использовал для подсветки похожие на <code>daScript</code> языки — <code>c++, python, ml</code>. Я немного повозился с попытками перевода, но решил попробовать взять результаты от самой <code>vscode</code>. Она не предназначена для того, чтобы работать со сторонними скриптами в двустороннем режиме (принимать данные и отдавать обратно), но и не запрещает сделать это.</p><p><a href="https://github.com/spiiin/hexo_vscode_dascript_highlight/tree/main/highlight-server" target="_blank" rel="noopener">Наколенный плагин</a> - добавляет команду <strong><code>Start highlight server</code></strong>, которая стартует http-сервер и слушает порт, по которому можно передать текст для подсветки.<br>Для работы плагина необходимы:</p><ul><li>один из указанных выше <a href="https://marketplace.visualstudio.com/items?itemName=eguskov.dascript" target="_blank" rel="noopener">плагинов для подсветки в vscode</a></li><li>плагин <a href="https://github.com/d3v-one/vscode-paste-special" target="_blank" rel="noopener">Paste special</a>, который позволяет заменить подсвеченный код на его html эквивалент</li></ul><p><a href="https://github.com/spiiin/hexo_vscode_dascript_highlight/blob/main/highlight-client/hexo_search_all_post_snippets.py" target="_blank" rel="noopener">Клиент на python</a> - тоже наколенный скрипт, который проходит по всем постам моего блога, и заменяет сниппеты кода на их html эквивалент в сгенерированной статической версии (чтобы не потерять исходник). Криво и косо, но выполняет задачу, теперь код постом про <a href="https://spiiin.github.io/tags/dascript/">daScript</a> подсвечен красивее.</p><p><img src="/blog/3460926079/fix_small.png" alt=""></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;daScript в
      
    
    </summary>
    
    
    
      <category term="log" scheme="http://spiiin.github.io/tags/log/"/>
    
      <category term="hexo" scheme="http://spiiin.github.io/tags/hexo/"/>
    
      <category term="dascript" scheme="http://spiiin.github.io/tags/dascript/"/>
    
  </entry>
  
  <entry>
    <title>daScript. BGFX и WeightedBlended Order-Independent Transparency</title>
    <link href="http://spiiin.github.io/blog/3778037319/"/>
    <id>http://spiiin.github.io/blog/3778037319/</id>
    <published>2023-09-19T13:24:06.000Z</published>
    <updated>2023-09-28T08:50:10.252Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p><a href="https://github.com/bkaradzic/bgfx" target="_blank" rel="noopener">bgfx</a> - обёртка над низкоуровневыми графическими api (все основные под desktop, телефоны и web).<br><a href="https://github.com/borisbat/dasBGFX" target="_blank" rel="noopener">dasBGFX</a> - байндинги библиотеки к daScript.</p><p><code>bgfx</code> умеет использовать <code>glfw</code> или <code>sdl</code> для создания окна, <code>dasBGFX</code> использует <code>dasGlfw</code>. Также модуль содержит DSL для трансляции шейдеров с daScript-like языка на BGFX (glsl-like)</p><p>В качестве инструкции по сборке можно использовать заметки:<br><a href="/blog/3006126295/" title="daScript - live-режим">daScript - live-режим</a> - сборка с glfw<br><a href="/blog/4060902549/" title="daScript. SFML, dasBox и semi-transparent render target">daScript. SFML, dasBox и semi-transparent render target</a> - сборка байндингов для sfml</p><p>По аналогии:</p><ul><li>выкачиваем сабмодули из git</li><li>включаем дефайны в cmake</li><li>добавляем зависимости от модулей dasGlfw и dasBGFX в какой-нибудь из тестовых проектов</li><li>перегенерируем решение</li><li>проверяем, что настройках проекта добавились пути к include и lib от модулей</li><li>запускаем простые <a href="https://github.com/borisbat/dasBGFX/blob/main/examples/01_hello_triangle.das" target="_blank" rel="noopener">примеры</a></li></ul><h2 id="Независимая-от-порядка-рендера-полупрозрачность"><a href="#Независимая-от-порядка-рендера-полупрозрачность" class="headerlink" title="Независимая от порядка рендера полупрозрачность"></a>Независимая от порядка рендера полупрозрачность</h2><p>Попробуем портировать чуть более сложный пример - <code>Weighted Blended Order-Independent Transparency</code> с <code>bgfx</code> (иначе вообще зачем он нужен?)</p><p>Очень кратко об идее:<br>“Традиционный” рендер полупрозрачных полигонов чувствителен и порядку рендера, для корректного смешивания необходимо выводить объекты от дальнего к ближнему по отношению к наблюдателю. Это не всегда удобно, так как:</p><ul><li>объекты могут быть “сплетены”, из-за чего их невозможно отсортировать</li><li>трата времени на сортировку<br><em>непрозрачные объекты могут при определенных условиях требовать рендеринга как полупрозрачные - забор с дырками на большом отдалении может содержать прозрачный и непрозрачный полигон, и начать “просвечивать”</em></li></ul><p>Способы избавиться от необходимости сортировки:</p><ul><li>порезать объекты на части (требует сложной подготовки)</li><li>хранить не только цвет/альфу ближайшего к наблюдателю пикселя, а список из нескольких (требует расхода памяти)</li><li>переопределить оператор смешивания на коммутативный</li></ul><p>К третьей группе относится метод <code>Weighted Blended Order-Independent Transparency</code></p><p><a href="https://casual-effects.blogspot.com/2014/03/weighted-blended-order-independent.html" target="_blank" rel="noopener">пост</a> от автора, <a href="https://casual-effects.blogspot.com/2015/03/implemented-weighted-blended-order.html" target="_blank" rel="noopener">дополнение</a> и <a href="https://jcgt.org/published/0002/02/09/" target="_blank" rel="noopener">пейпер</a>. Также - [движок] с реализацией, и описание в книге <code>Computer graphics. Principles and practice</code> (всё - от него же).<br>Пара других примеров - имплементация в движке <a href="https://bagnell.github.io/cesium/Apps/Sandcastle/gallery/OIT.html" target="_blank" rel="noopener">cesium</a> (webgl) и пример на <a href="https://bkaradzic.github.io/bgfx/examples.html#oit" target="_blank" rel="noopener">bgfx</a></p><p>Собственно, спортить пример напрямую не получилось, поэтому реализация скорее не перевод примера, а из поста, “в лоб”, возможно некорректная, но вроде похожая не референсный скриншот из оригинала.</p><p>Других прямых референсов откопать не удалось, а сравнить с “традиционной” прозрачность нельзя, так как независимые от порядка методы содержат погрешности, конкретно <code>weighted blended</code>, как следует из названия, содержит “веса” объектов, в зависимости от их прозрачности и удаленности от камеры, так что для корректного использования необходимо представлять себе диапазоны возможных значений. Так что тут скорее “<strong><code>проба API</code></strong>“, а не нормальная реализация.</p><h2 id="Инициализация"><a href="#Инициализация" class="headerlink" title="Инициализация"></a>Инициализация</h2><p>После создания окна</p><p><strong><code>Создание двух view</code></strong><br>Один - для рендера в 2 текстуры, второй - для смешивания текстур с восстановлением альфы на экране<br><figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">var display_w, display_h : int</span><br><span class="line">glfwGetWindowSize(window, safe_addr(display_w), safe_addr(display_h))</span><br><span class="line">bgfx_reset(uint(display_w), uint(display_h), BGFX_RESET_VSYNC, bgfx_texture_format COUNT)</span><br><span class="line">bgfx_set_view_rect(<span class="number">0</span>u, <span class="number">0</span>u, <span class="number">0</span>u, uint(display_w), uint(display_h))</span><br><span class="line">bgfx_set_view_rect(<span class="number">1</span>u, <span class="number">0</span>u, <span class="number">0</span>u, uint(display_w), uint(display_h))</span><br></pre></td></tr></table></figure></p><p><strong><code>Создание 2х RT-текстур, в сумме 5 каналов 16-битных float-каналов - RGBA + модификатор</code></strong><br><figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">var fb_textures = [[auto </span><br><span class="line">    bgfx_create_texture_2d(<span class="number">1280</span>u, <span class="number">720</span>u, <span class="keyword">false</span>, <span class="number">1</span>u, bgfx_texture_format RGBA16F, BGFX_TEXTURE_RT, <span class="keyword">null</span>);</span><br><span class="line">    bgfx_create_texture_2d(<span class="number">1280</span>u, <span class="number">720</span>u, <span class="keyword">false</span>, <span class="number">1</span>u, bgfx_texture_format R16F, BGFX_TEXTURE_RT, <span class="keyword">null</span>)</span><br><span class="line">]]</span><br><span class="line"></span><br><span class="line"><span class="comment">//создаём фреймбуффер, к которому прикрепляем обе текстуры, и привязываем его к первому view</span></span><br><span class="line">var fbh = bgfx_create_frame_buffer_from_handles(<span class="number">2</span>u, safe_addr(fb_textures),<span class="keyword">true</span>)</span><br><span class="line">bgfx_set_view_frame_buffer(<span class="number">0</span>u, fbh)</span><br></pre></td></tr></table></figure></p><p><strong><code>Заливка текстур начальным значением</code></strong><br><figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> pal0 = [[float <span class="number">0.0</span>; <span class="number">0.0</span>; <span class="number">0.0</span>; <span class="number">0.0</span>]] <span class="comment">//для RGBA каналов</span></span><br><span class="line"><span class="keyword">let</span> pal1 = [[float <span class="number">1.0</span>; <span class="number">1.0</span>; <span class="number">1.0</span>; <span class="number">1.0</span>]] <span class="comment">//для канала с весами</span></span><br><span class="line">bgfx_set_view_frame_buffer(<span class="number">0</span>u, fbh)</span><br><span class="line">bgfx_set_palette_color(<span class="number">0</span>u, safe_addr(pal0))</span><br><span class="line">bgfx_set_palette_color(<span class="number">1</span>u, safe_addr(pal1))</span><br><span class="line">bgfx_set_view_clear_mrt(<span class="number">0</span>u , BGFX_CLEAR_COLOR|BGFX_CLEAR_DEPTH, <span class="number">1.0</span>f, <span class="number">0</span>u, <span class="number">0</span>u, <span class="number">1</span>u, <span class="number">0</span>u, <span class="number">0</span>u, <span class="number">0</span>u, <span class="number">0</span>u, <span class="number">0</span>u, <span class="number">0</span>u)</span><br></pre></td></tr></table></figure></p><h2 id="Проход-1-рендер-полупрозрачных-объектов"><a href="#Проход-1-рендер-полупрозрачных-объектов" class="headerlink" title="Проход 1 - рендер полупрозрачных объектов"></a>Проход 1 - рендер полупрозрачных объектов</h2><p><em>(алгоритм позволяет использовать уже накопленный буфер глубины и совмещается с другими техниками рендера, но тут - наиболее простая референсная сцена с тремя полупрозрачными квадами)</em></p><p><strong><code>Шейдер</code></strong></p><figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">var [[<span class="keyword">in</span>]] a_position : float3</span><br><span class="line">var [[<span class="keyword">in</span>]] a_color0 : float4</span><br><span class="line">var [[inout, semantics=POSITION1]] v_pos : float4</span><br><span class="line">var [[inout]] v_color0 : float4</span><br><span class="line">var [[uniform]] v_ortho : float4x4</span><br><span class="line"></span><br><span class="line">[bgfx_vertex_buffer]</span><br><span class="line"><span class="keyword">struct</span> Vertex</span><br><span class="line">    position : float3</span><br><span class="line">    color0 : float4</span><br><span class="line"></span><br><span class="line">[bgfx_vertex_program]</span><br><span class="line">def vs_main</span><br><span class="line">    v_color0 = a_color0</span><br><span class="line">    gl_Position = v_ortho * float4(a_position, <span class="number">1.0</span>)</span><br><span class="line">    v_pos = gl_Position</span><br><span class="line"></span><br><span class="line">[bgfx_fragment_program]</span><br><span class="line">def fs_main</span><br><span class="line">    var color = v_color0</span><br><span class="line">    <span class="comment">//не важно для 2d референсной сцены</span></span><br><span class="line">    <span class="keyword">let</span> depth = v_pos.z/v_pos.w</span><br><span class="line">    <span class="comment">//не забыть alpha-premultiply</span></span><br><span class="line">    color.xyz *= color.w</span><br><span class="line">    <span class="comment">//настройка веса</span></span><br><span class="line">    <span class="keyword">let</span> weight = color.w * clamp(<span class="number">0.03</span> / (<span class="number">1e-5</span> + pow(depth, <span class="number">5.0</span>) ), <span class="number">0.01</span>, <span class="number">3000.0</span>)</span><br><span class="line">    <span class="comment">//запись в 1-ю rt текстуру RGBA, умноженного на вес</span></span><br><span class="line">    gl_FragData[<span class="number">0</span>] = color * weight</span><br><span class="line">    <span class="comment">//отдельное сохранение веса</span></span><br><span class="line">    gl_FragData[<span class="number">1</span>] = color.wwww</span><br></pre></td></tr></table></figure><p>Небольшое необходимое дополнение к <a href="https://github.com/GaijinEntertainment/daScript/blob/master/modules/dasGlsl/glsl/glsl_common.das#L121" target="_blank" rel="noopener">DSL-шейдеров</a>:<br><figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//объявление переменной для записи нескольких output-цветов (в несколько RT-текстур) в пиксельном шейдере</span></span><br><span class="line">var gl_FragData = [[float4[<span class="number">4</span>] float4(); float4(); float4(); float4()]]</span><br></pre></td></tr></table></figure></p><p><strong><code>Настройка смешивания и отрисовка</code></strong></p><figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">vs_main_bind_uniform()</span><br><span class="line">fs_main_bind_uniform()</span><br><span class="line">var stateNoDepth = ( uint64(<span class="number">0</span>)</span><br><span class="line">    | BGFX_STATE_CULL_CW</span><br><span class="line">    | BGFX_STATE_WRITE_RGB</span><br><span class="line">    | BGFX_STATE_WRITE_A</span><br><span class="line">    | BGFX_STATE_DEPTH_TEST_ALWAYS</span><br><span class="line">    | BGFX_STATE_MSAA</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//флажки для задания режима прозрачности (ONE, ONE) для первой RT1 и (ZERO, SRC_COLOR) для RT2</span></span><br><span class="line"><span class="comment">//separate blendState for RT2</span></span><br><span class="line"><span class="keyword">let</span> rt2_blendState =uint(</span><br><span class="line">    BGFX_STATE_BLEND_ZERO &gt;&gt; uint64(BGFX_STATE_BLEND_SHIFT) |</span><br><span class="line">    BGFX_STATE_BLEND_SRC_COLOR &gt;&gt; uint64(BGFX_STATE_BLEND_SHIFT) &lt;&lt; uint64(<span class="number">4</span>)</span><br><span class="line">)</span><br><span class="line">bgfx_set_state(</span><br><span class="line">    stateNoDepth | BGFX_STATE_BLEND_FUNC(BGFX_STATE_BLEND_ONE, BGFX_STATE_BLEND_ONE) | BGFX_STATE_BLEND_INDEPENDENT,</span><br><span class="line">    rt2_blendState</span><br><span class="line">)</span><br><span class="line">bgfx_submit(<span class="number">0</span>u, program, <span class="number">1</span>u, BGFX_DISCARD_NONE)</span><br></pre></td></tr></table></figure><p><em>В пейпере автора рассматривается этот подход и альтернативный, для gpu без поддержки задания раздельных режимов смешивания для различных render target. Они немного отличаются в коде шейдера и смешивании, важно не перепутать сочетание</em></p><p>Задание раздельных функций смешивания для render-target выглядят в BGFX страшно - в первый параметр передаётся флаг <code>BGFX_STATE_BLEND_INDEPENDENT</code>, а во второй (который 32-битный и называется _rgba) - битовая маска для описания режима смешивания второй RT. В c-api это спрятано за макросом для немного менее страшной записи.</p><p>На этой стадии можно попробовать отрисовать сцену и подключиться к приложению через графический отладчик, чтобы проверить состояние RT-текстур (например, <strong><code>RenderDoc</code></strong>):<br><img src="/blog/3778037319/bgfx_renderdoc_small.png" alt=""><br><em>текстура развёрнута по y</em></p><h2 id="Проход-2-восстановление-альфа-канала-по-текстуре-с-весами"><a href="#Проход-2-восстановление-альфа-канала-по-текстуре-с-весами" class="headerlink" title="Проход 2 - восстановление альфа канала по текстуре с весами"></a>Проход 2 - восстановление альфа канала по текстуре с весами</h2><p><strong><code>Шейдер</code></strong></p><figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">[bgfx_vertex_buffer]</span><br><span class="line"><span class="keyword">struct</span> VertexTex</span><br><span class="line">    position : float3</span><br><span class="line">    color0 : float4</span><br><span class="line">    [[<span class="class"><span class="keyword">type</span></span>=FLOAT, size=<span class="number">2</span>, semantics=TEXCOORD0, normalized=<span class="keyword">false</span>, as_int=<span class="keyword">false</span>]] uv : float2</span><br><span class="line"></span><br><span class="line">var [[uniform, stage=<span class="number">0</span>]] s_texColor0 : sampler2D</span><br><span class="line">var [[uniform, stage=<span class="number">1</span>]] s_texColor1 : sampler2D</span><br><span class="line"></span><br><span class="line">[bgfx_vertex_program]</span><br><span class="line">def vs_quad</span><br><span class="line">    v_texcoord0 = a_texcoord0</span><br><span class="line">    gl_Position = v_ortho * float4(a_position, <span class="number">1.0</span>)</span><br><span class="line"></span><br><span class="line">[bgfx_fragment_program]</span><br><span class="line">def fs_quad</span><br><span class="line">    <span class="keyword">let</span> accum   = texture2D(s_texColor0, v_texcoord0)</span><br><span class="line">    <span class="keyword">let</span> opacity = texture2D(s_texColor1, v_texcoord0).x</span><br><span class="line">    <span class="comment">//восстановление и ограничение диапазона</span></span><br><span class="line">    gl_FragColor  = float4(accum.xyz / clamp(accum.w, <span class="number">1e-4</span>, <span class="number">5e4</span>), opacity)</span><br></pre></td></tr></table></figure><p><strong><code>Настройка смешивания и отрисовка</code></strong></p><figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//привязка текстур к сэмплерам</span></span><br><span class="line">s_texColor0 := fb_textures[<span class="number">0</span>]</span><br><span class="line">s_texColor1 := fb_textures[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">//цвет фона и настройка смешивания</span></span><br><span class="line">bgfx_set_view_clear(<span class="number">1</span>u, BGFX_CLEAR_COLOR | BGFX_CLEAR_DEPTH, RGBA_TO_BGFX_UCOLOR(<span class="number">0.75</span>, <span class="number">0.75</span>, <span class="number">0.75</span>, <span class="number">1.0</span>), <span class="number">1.0</span>f, <span class="number">0</span>u)</span><br><span class="line">bgfx_set_state(BGFX_STATE_WRITE_RGB | BGFX_STATE_BLEND_FUNC(BGFX_STATE_BLEND_INV_SRC_ALPHA, BGFX_STATE_BLEND_SRC_ALPHA), <span class="number">0</span>u)</span><br><span class="line"></span><br><span class="line"><span class="comment">//вывод fullscreen квада</span></span><br><span class="line">vs_quad_bind_uniform()</span><br><span class="line">fs_quad_bind_uniform()</span><br><span class="line">bgfx_submit(<span class="number">1</span>u, program_quad, <span class="number">1</span>u, BGFX_DISCARD_NONE)</span><br></pre></td></tr></table></figure><p><strong><code>Результат</code></strong></p><p><img src="/blog/3778037319/bgfx_oit_small.png" alt=""><br><a href="https://github.com/spiiin/dascript_trivial_examples/blob/main/das_bgfx_hello_wboit/das_bgfx_hello_wboit.das" target="_blank" rel="noopener">Код</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;&lt;a href=&quot;h
      
    
    </summary>
    
    
    
      <category term="opengl" scheme="http://spiiin.github.io/tags/opengl/"/>
    
      <category term="dascript" scheme="http://spiiin.github.io/tags/dascript/"/>
    
  </entry>
  
  <entry>
    <title>daScript - binding tricks</title>
    <link href="http://spiiin.github.io/blog/1908536621/"/>
    <id>http://spiiin.github.io/blog/1908536621/</id>
    <published>2023-09-05T15:15:38.000Z</published>
    <updated>2023-09-28T09:06:04.888Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Несколько примеров дополнительно к <a href="https://dascript.org/doc/reference/embedding/modules.html" target="_blank" rel="noopener">Modules and C++ bindings</a></p><p><strong><code>Привязка метода класса</code></strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//структура с методами</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">42</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//тип-обёртка, описание структуры для daScript</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStructTypeAnnotation</span> :</span> ManagedStructureAnnotation &lt;MyStruct&gt; &#123;</span><br><span class="line">    MyStructTypeAnnotation(ModuleLibrary&amp; ml) : ManagedStructureAnnotation(<span class="string">"MyStruct"</span>, ml) &#123;</span><br><span class="line">        <span class="comment">//тут может быть описание полей</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">MAKE_TYPE_FACTORY(MyStruct, MyStruct)</span><br><span class="line"></span><br><span class="line"><span class="comment">//описание модуля</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Module_Tutorial02</span> :</span> <span class="keyword">public</span> Module &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Module_Tutorial02() : Module(<span class="string">"tutorial_02"</span>) &#123;   <span class="comment">// module name, when used from das file</span></span><br><span class="line">        ModuleLibrary lib;</span><br><span class="line">        lib.addModule(<span class="keyword">this</span>);</span><br><span class="line">        lib.addBuiltInModule();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//описание структуры</span></span><br><span class="line">        addAnnotation(make_smart&lt;MyStructTypeAnnotation&gt;(lib));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//регистрация метода</span></span><br><span class="line">        <span class="keyword">using</span> method_test = DAS_CALL_MEMBER(MyStruct::test);</span><br><span class="line">        addExtern&lt;DAS_CALL_METHOD(method_test)&gt;(*<span class="keyword">this</span>, lib, <span class="string">"mystruct_test"</span>, SideEffects::none,</span><br><span class="line">            DAS_CALL_MEMBER_CPP(MyStruct::test));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//возможный вызов метода в daScript</span></span><br><span class="line">var c: MyStruct</span><br><span class="line">print(<span class="string">"&#123;c |&gt; mystruct_test()&#125;"</span>)</span><br></pre></td></tr></table></figure><p><strong><code>Привязка перегруженных и шаблонных функций с явным указанием сигнатуры</code></strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test2</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123; <span class="keyword">return</span> a; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">test3</span><span class="params">(T a)</span> </span>&#123; <span class="keyword">return</span> a; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//явное указание сигнатуры функции для привязки</span></span><br><span class="line">addExtern&lt;<span class="keyword">int</span>(*)(<span class="keyword">int</span>),test2&gt;(*<span class="keyword">this</span>, lib, <span class="string">"test2"</span>, SideEffects::none, <span class="string">"test2"</span>);</span><br><span class="line">addExtern&lt;<span class="keyword">int</span>(*)(<span class="keyword">int</span>), test3&gt;(*<span class="keyword">this</span>, lib, <span class="string">"test3"</span>, SideEffects::none, <span class="string">"test3"</span>);</span><br></pre></td></tr></table></figure><p><strong><code>Возврат ссылки</code></strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> gValue = <span class="number">111</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">getRef</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> gValue; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span>&amp; <span class="title">getRefInline</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> gValue; &#125;</span><br><span class="line"></span><br><span class="line">addExtern&lt;DAS_BIND_FUN(getRef), SimNode_ExtFuncCallRef&gt;(*<span class="keyword">this</span>, lib, <span class="string">"getRef"</span>, SideEffects::accessExternal, <span class="string">"getRef"</span>);</span><br><span class="line">addExternTempRef&lt;DAS_BIND_FUN(getRefInline), SimNode_ExtFuncCallRef&gt;(*<span class="keyword">this</span>, lib, <span class="string">"getRefInline"</span>, SideEffects::accessExternal, <span class="string">"getRefInline"</span>);</span><br><span class="line">```</span><br></pre></td></tr></table></figure><figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">getRef() = <span class="number">333</span></span><br><span class="line">print(<span class="string">"&#123;getRef()&#125;\n"</span>) <span class="comment">//333</span></span><br><span class="line"></span><br><span class="line">var v4&amp; = getRefInline()</span><br><span class="line">v4 = <span class="number">444</span></span><br><span class="line">print(<span class="string">"&#123;getRefInline()&#125;\n"</span>) <span class="comment">//444</span></span><br></pre></td></tr></table></figure><p><strong><code>Возврат ссылки по значению</code></strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//returns a ref type by value,</span></span><br><span class="line">addExtern&lt;DAS_BIND_FUN(float4x4_translation), SimNode_ExtFuncCallAndCopyOrMove&gt;(*<span class="keyword">this</span>, lib, <span class="string">"translation"</span>,</span><br><span class="line">        SideEffects::none, <span class="string">"float4x4_translation"</span>)-&gt;arg(<span class="string">"xyz"</span>);</span><br></pre></td></tr></table></figure><p><strong><code>Привязка других типов нод AST</code></strong><br>Способы привязать семантику вызова функции на стороне daScript к генерации других типов нод</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">__forceinline <span class="keyword">float</span> <span class="title">dot3</span><span class="params">(vec4f a, vec4f b)</span></span>&#123;<span class="keyword">return</span> v_extract_x(v_dot3_x(a, b));&#125;</span><br><span class="line">addExternEx&lt;<span class="keyword">float</span>(float3,float3),DAS_BIND_FUN(dot3)&gt;(*<span class="keyword">this</span>, lib, <span class="string">"dot"</span>, SideEffects::none, <span class="string">"dot3"</span>)-&gt;args(&#123;<span class="string">"x"</span>,<span class="string">"y"</span>&#125;);</span><br><span class="line"></span><br><span class="line">addFunction(make_smart&lt;BuiltInFn&lt;SimNode_MatrixCtor&lt;float3x3&gt;,float3x3&gt;&gt;(<span class="string">"float3x3"</span>,lib));</span><br></pre></td></tr></table></figure><p><strong><code>Хинты для аргументов</code></strong></p><p>//TODO<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TT&gt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">registerVectorFunctions</span>&lt;TT&gt; &#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    addExtern&lt;DAS_BIND_FUN(das_vector_pop&lt;TT&gt;)&gt;(*mod, lib, <span class="string">"pop"</span>,</span><br><span class="line">        SideEffects::modifyArgument, <span class="string">"das_vector_pop"</span>);</span><br><span class="line">    <span class="comment">//permanentArgFn</span></span><br><span class="line">    addExtern&lt;DAS_BIND_FUN(das_vector_clear&lt;TT&gt;),SimNode_ExtFuncCall,permanentArgFn&gt;(*mod, lib, <span class="string">"clear"</span>,</span><br><span class="line">        SideEffects::modifyArgument, <span class="string">"das_vector_clear"</span>);</span><br><span class="line">    <span class="comment">//explicitConstArgFn</span></span><br><span class="line">    addExtern&lt;DAS_BIND_FUN(das_vector_each&lt;TT&gt;),SimNode_ExtFuncCallAndCopyOrMove,explicitConstArgFn&gt;(*mod, lib, <span class="string">"each"</span>,</span><br><span class="line">        SideEffects::none, <span class="string">"das_vector_each"</span>);</span><br><span class="line">    <span class="comment">//temporaryArgFn</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong><code>Симуляция walk</code></strong></p><p>Создание своего типа-хендла, который в dascript будет обрабатываться как примитивный тип uint64</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyHandle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> id;</span><br><span class="line">    <span class="comment">//другие методы и свойства handle</span></span><br><span class="line">&#125;;</span><br><span class="line">MAKE_TYPE_FACTORY(MyHandle, MyHandle)</span><br><span class="line"></span><br><span class="line"><span class="comment">//описываем методы каста к примитивному типу и обратно</span></span><br><span class="line"><span class="keyword">namespace</span> das</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;&gt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cast</span>&lt;MyHandle&gt;</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> __forceinline MyHandle <span class="title">to</span><span class="params">(vec4f x)</span> </span>&#123; <span class="keyword">return</span> MyHandle&#123; (<span class="keyword">uint64_t</span>)v_extract_xi64(v_cast_vec4i(x)) &#125;; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> __forceinline vec4f <span class="title">from</span><span class="params">(MyHandle x)</span> </span>&#123; <span class="keyword">return</span> v_cast_vec4f(v_splatsi64(x.id)); &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//описываем аннотацию типа с перегруженным методом walk</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyHandleAnnotation</span> <span class="title">final</span> :</span> ManagedStructureAnnotation&lt;MyHandle&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyHandleAnnotation(ModuleLibrary&amp; ml) : ManagedStructureAnnotation(<span class="string">"MyHandle"</span>, ml) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasNonTrivialCtor</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125; <span class="comment">//trivial type</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canClone</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">(DataWalker&amp; walker, <span class="keyword">void</span>* data)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!walker.reading)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">const</span> MyHandle* t = (MyHandle*)data;</span><br><span class="line">            <span class="keyword">uint64_t</span> eidV = t-&gt;id;</span><br><span class="line">            walker.UInt64(eidV);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> SimNode* <span class="title">simulateClone</span><span class="params">(das::Context&amp; context, <span class="keyword">const</span> das::LineInfo&amp; at, das::SimNode* l, das::SimNode* r)</span> <span class="keyword">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> GenCloneNode&lt;MyHandle&gt;::simulateClone(context, at, l, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><code>Симуляция итератора</code></strong><br>Для кастомного контейнера можно задать прямой способ обращения к элементам (для простоты — нешаблонная версия кода)</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//кастомный вектор из элементов MyHandle</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyVector</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;MyHandle&gt; vec;</span><br><span class="line">&#125;;</span><br><span class="line">MAKE_TYPE_FACTORY(MyVector, MyVector)</span><br><span class="line"></span><br><span class="line"><span class="comment">//создаём вектор в C++ и делаем функцию доступа к нему из daScript</span></span><br><span class="line">MyVector gVector = &#123; &#123;MyHandle&#123;<span class="number">1</span>&#125;, MyHandle&#123;<span class="number">3</span>&#125;, MyHandle&#123;<span class="number">5</span>&#125;&#125; &#125;;</span><br><span class="line"><span class="function"><span class="keyword">auto</span>&amp; <span class="title">getArrayRef</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> gVector; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//кастомный итератор</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyIterator</span> :</span> Iterator</span><br><span class="line">&#123;</span><br><span class="line">    MyIterator(MyVector* ar) : <span class="built_in">array</span>(ar) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">first</span><span class="params">(das::Context&amp;, <span class="keyword">char</span>* _value)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">array</span>-&gt;vec.size())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        iterator_type* value = (iterator_type*)_value;</span><br><span class="line">        *value = <span class="built_in">array</span>-&gt;vec.begin(); <span class="comment">//пишем в память, выделенную в daScript под итератор</span></span><br><span class="line">        end = <span class="built_in">array</span>-&gt;vec.end();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">next</span><span class="params">(das::Context&amp;, <span class="keyword">char</span>* _value)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        iterator_type* value = (iterator_type*)_value;</span><br><span class="line">        ++(*value); <span class="comment">//сдвигаем курсор на следующий элемент</span></span><br><span class="line">        <span class="keyword">return</span> *value != end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(das::Context&amp; context, <span class="keyword">char</span>* _value)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//освобождаем итератор, по хорошему нужно еще занулить value</span></span><br><span class="line">        context.heap-&gt;<span class="built_in">free</span>((<span class="keyword">char</span>*)<span class="keyword">this</span>, <span class="keyword">sizeof</span>(MyIterator));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MyVector* <span class="built_in">array</span> = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(<span class="built_in">array</span>-&gt;vec.begin())</span> iterator_type</span>;</span><br><span class="line">    iterator_type end;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//в аннотации типа вектора говорим:</span></span><br><span class="line"><span class="comment">//"при обращении к итератору контейнера из daScript будет создан кастомный класс итератора и вызываться его методы"</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyVectorAnnotation</span> <span class="title">final</span> :</span> ManagedStructureAnnotation&lt;MyVector, <span class="literal">false</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    TypeDeclPtr vecType;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    MyVectorAnnotation(das::ModuleLibrary&amp; ml) : ManagedStructureAnnotation(<span class="string">"MyVector"</span>, ml)</span><br><span class="line">    &#123;</span><br><span class="line">        cppName = <span class="string">"MyVector"</span>;</span><br><span class="line"></span><br><span class="line">        vecType = makeType&lt;MyHandle&gt;(ml);</span><br><span class="line">        vecType-&gt;ref = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">isIterable</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> das::TypeDeclPtr <span class="title">makeIteratorType</span><span class="params">(<span class="keyword">const</span> das::ExpressionPtr&amp;)</span> <span class="keyword">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> das::make_smart&lt;das::TypeDecl&gt;(*vecType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//используем наш итератор для обхода</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> das::SimNode* <span class="title">simulateGetIterator</span><span class="params">(das::Context&amp; context, <span class="keyword">const</span> das::LineInfo&amp; at,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> das::ExpressionPtr&amp; src)</span> <span class="keyword">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> rv = src-&gt;simulate(context);</span><br><span class="line">        <span class="keyword">return</span> context.code-&gt;makeNode&lt;das::SimNode_AnyIterator&lt;MyVector, MyIterator&gt;&gt;(at, rv);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//не забываем добавить в модуль аннотации</span></span><br><span class="line">addAnnotation(make_smart&lt;MyHandleAnnotation&gt;(lib));</span><br><span class="line">addAnnotation(make_smart&lt;MyVectorAnnotation&gt;(lib));</span><br><span class="line">addExtern&lt;DAS_BIND_FUN(getArrayRef), SimNode_ExtFuncCallRef&gt;(*<span class="keyword">this</span>, lib, <span class="string">"getArrayRef"</span>,</span><br><span class="line">    SideEffects::accessExternal, <span class="string">"getArrayRef"</span>);</span><br></pre></td></tr></table></figure><figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//теперь можно пройти по C++-контейнеру из daScript без дополнительных затрат на итерации</span></span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> getArrayRef()</span><br><span class="line">    print(<span class="string">"&#123;v&#125;\n"</span>)</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;Несколько 
      
    
    </summary>
    
    
    
      <category term="dascript" scheme="http://spiiin.github.io/tags/dascript/"/>
    
  </entry>
  
  <entry>
    <title>Turtletoy и dittytoy</title>
    <link href="http://spiiin.github.io/blog/421834894/"/>
    <id>http://spiiin.github.io/blog/421834894/</id>
    <published>2023-09-03T10:33:37.000Z</published>
    <updated>2023-09-03T10:37:56.602Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>javascript-api для черепашьей графики и для генерации звуки<br><a href="https://turtletoy.net/" target="_blank" rel="noopener">https://turtletoy.net/</a><br><a href="https://dittytoy.net/" target="_blank" rel="noopener">https://dittytoy.net/</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;javascript
      
    
    </summary>
    
    
    
      <category term="link" scheme="http://spiiin.github.io/tags/link/"/>
    
      <category term="procgen" scheme="http://spiiin.github.io/tags/procgen/"/>
    
  </entry>
  
  <entry>
    <title>AI фантазии</title>
    <link href="http://spiiin.github.io/blog/2491875181/"/>
    <id>http://spiiin.github.io/blog/2491875181/</id>
    <published>2023-08-27T17:15:45.000Z</published>
    <updated>2023-08-27T17:25:23.245Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Пока изучал природные материалы, пролистал советский учебник по природоведению для 4-го класса. Простенький список материалов — песок с серой, гранит (полевой шпат, слюда, кварц), соль, торф, известняк (мел, мрамор, обыкновенный), каменный уголь, антрацит, нефть, чугун, сталь, железо, аллюминий, растворы порошков в воде. Кроме рисования текстур, фантазиями и галлюцинациями нейронок весело и просто проиллюстрировать текст (а google earth - с прогулками по описанным местам) =)</p><p><img src="/blog/2491875181/1_small.png" alt=""><br><img src="/blog/2491875181/2_small.png" alt=""><br><img src="/blog/2491875181/3_small.png" alt=""><br><img src="/blog/2491875181/4_small.png" alt=""><br><img src="/blog/2491875181/5_small.png" alt=""><br><img src="/blog/2491875181/6_small.png" alt=""><br><img src="/blog/2491875181/7_small.png" alt=""><br><img src="/blog/2491875181/8_small.png" alt=""><br><img src="/blog/2491875181/9_small.png" alt=""></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;Пока изуча
      
    
    </summary>
    
    
    
      <category term="ai" scheme="http://spiiin.github.io/tags/ai/"/>
    
  </entry>
  
  <entry>
    <title>AI - Stable Diffusion и процедурная генерация. Ссылки</title>
    <link href="http://spiiin.github.io/blog/3923038774/"/>
    <id>http://spiiin.github.io/blog/3923038774/</id>
    <published>2023-08-27T15:24:22.000Z</published>
    <updated>2023-09-03T10:35:52.461Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><h2 id="Stable-Diffusion"><a href="#Stable-Diffusion" class="headerlink" title="Stable Diffusion"></a>Stable Diffusion</h2><a href="/blog/1596814086/" title="AI prompts">AI prompts</a><p>Известные ИИ модели для рисования — <code>Dall-E</code>, <code>Midjourney</code> и <code>Stable Diffusion</code>. Stable Diffusion хороша тем, что код открыт, и доступно большое количество плагинов и моделей.</p><p>Первый способ “обращаться” к модели за картинкой — запросом из кода.</p><p><a href="https://habr.com/ru/companies/selectel/articles/712316/" target="_blank" rel="noopener">SD – это Linux, а Midjourney – Mac: краткое полное руководство по Stable Diffusion</a> - терминология<br><a href="https://habr.com/ru/articles/688204/" target="_blank" rel="noopener">Шерудим под капотом Stable Diffusion - python код для теста частей модели</a> - еще, вникнуть в термины vae/clip/unet<br><a href="https://habr.com/ru/articles/693298/" target="_blank" rel="noopener">Как работает Stable Diffusion: объяснение в картинках</a><br><a href="https://habr.com/ru/companies/ruvds/articles/706406/" target="_blank" rel="noopener">Как оптимизировать работу Stable Diffusion при помощи текстовой инверсии</a></p><p>Второй способ — генерация с помощью GUI: <a href="https://github.com/artmamedov/artroom-stable-diffusion/releases" target="_blank" rel="noopener">ArtRoom</a>, <a href="https://github.com/AUTOMATIC1111/stable-diffusion-webui" target="_blank" rel="noopener">Automatic1111 webui</a>, <a href="https://github.com/invoke-ai/InvokeAI" target="_blank" rel="noopener">InvokeAI</a>.</p><p>Третий, кажется, наиболее интересный, составление пайплайна вызовов с помощью нодового редактора - <a href="https://github.com/comfyanonymous/ComfyUI" target="_blank" rel="noopener">ComfyUI</a>. (Нодовый редактор также есть в InvokeAI)</p><p><a href="https://comfyanonymous.github.io/ComfyUI_examples/" target="_blank" rel="noopener">ComfyUI examples</a> - примеры построения пайплайнов. <code>Inpaint</code> и <code>img2img</code> — два базовых способа доработки изображения.</p><p><a href="https://comfyanonymous.github.io/ComfyUI_examples/controlnet/" target="_blank" rel="noopener">ControlNet</a> - группа моделей для “снятия” с изображения параметров и использования их — <code>поза</code>, <a href="https://www.youtube.com/watch?v=_xHC3bT5GBU" target="_blank" rel="noopener">освещение</a>, <code>карта глубины</code>, <a href="https://www.youtube.com/watch?v=GF2vIgyn4Qo" target="_blank" rel="noopener">форма лица</a>, <code>силуэт</code>, <a href="https://github.com/comfyanonymous/ComfyUI/issues/65" target="_blank" rel="noopener">стиль</a> и т.п.<br><a href="https://comfyanonymous.github.io/ComfyUI_examples/area_composition/" target="_blank" rel="noopener">Area Composition</a> - работа с изображением в виде группы текстовых запросов и шагов для различных областей.<br><a href="https://www.youtube.com/watch?v=dVjMiJsuR5o" target="_blank" rel="noopener">LoRA vs Dreambooth vs Textual Inversion vs Hypernetworks</a> - разбор нескольких способов применения “дообучения” моделей.<br><a href="https://www.youtube.com/watch?v=OdMtJMzjNLg" target="_blank" rel="noopener">LATENT Tricks - Amazing ways to use ComfyUI</a> - различные способы генерации вариаций изображений, интересно само по себе, и как объяснение внедрения в различные шаги пайплайна<br><a href="https://github.com/adieyal/sd-dynamic-prompts/blob/main/docs/tutorial.md" target="_blank" rel="noopener">SD dynamic promts</a> - промт-хакинг, генерация вариаций за счет изменений текста запроса<br><a href="https://youtu.be/EmA0RwWv-os" target="_blank" rel="noopener">ControlNet 1.1 Tiles Tutorial</a> - один из способов апскейла изображений (существует много других моделей и методов для апскейла)<br><a href="https://github.com/biegert/ComfyUI-CLIPSeg" target="_blank" rel="noopener">ClipSeg</a> - кастомный плагин для comfyui для текстового запроса выделения объекта с картинки<br><a href="https://www.reddit.com/r/StableDiffusion/comments/zgfbj1/i_used_stable_diffusion_to_create_360_degree/" target="_blank" rel="noopener">360 degree</a> - генерация панорамных изображений в несколько шагов - генерация панорамы сферической карты (бесшовной по одной из осей, и с нужными пропорциями, и правильным текстов запросом), затем разворачивание в cube-map, для того, чтобы с помощью inpaint дорисовать бесшовность у полюсов.</p><p>Базовые модели для рисования с помощью StableDiffusion - <code>sd1.4, sd2.0, sdxl</code>. Вторая не лучше первой, а альтернативная, <a href="https://huggingface.co/stabilityai/stable-diffusion-xl-base-1.0" target="_blank" rel="noopener">sdxl</a> - лучше обеих. Плагины постепенно апдейтятся для использования с ней.</p><h2 id="Процедурная-генерация-текстур"><a href="#Процедурная-генерация-текстур" class="headerlink" title="Процедурная генерация текстур"></a>Процедурная генерация текстур</h2><p>Книга по программной генерации текстур — <code>Texture and modeling: procedural approach</code>.</p><p>Софт для программной генерации:<br><a href="http://www.darksim.com/html/download_darktree2.shtml" target="_blank" rel="noopener">Dark tree</a> - древний, но хороший как референс<br><a href="https://kayv.artstation.com/projects/ww3ow" target="_blank" rel="noopener">Adobe substance designer 3d</a> - пример графа генерации царапин<br><a href="https://www.youtube.com/playlist?list=PLsGl9GczcgBs6TtApKKK-L_0Nm6fovNPk" target="_blank" rel="noopener">Blender nodes</a> - плейлист на ютубе генерации материалов в Blender<br><a href="https://www.shadertoy.com/view/4sXXW2" target="_blank" rel="noopener">Shadertoy</a> - пример шейдера генерации фрактального шума <a href="https://www.kenmusgrave.com/vision.html" target="_blank" rel="noopener">Масгрейва</a></p><p><a href="https://github.com/ASTex-ICube/semiproctex/" target="_blank" rel="noopener">Semi-Procedural Textures</a> - реализация сразу нескольких интересных идей.</p><ul><li>Point Process Texture Basis Functions - rule-them-all шум, позволяющий сгенерировать множество форм для природных материалов</li><li>“снятие” параметров для этого шума с входного изображения</li><li>выделение понятия “структуры” материала (контуров) и “текстуры” (расцветки)</li><li>генерация по структуре и входной текстуре изображения</li></ul><p>Последняя стадия у авторов делается с помощью патентованного алгоритма <code>Parallel controllable texture synthesis</code>.<br>Можно попробовать подменить её на то, чтобы скормить “структуру” как controlnet контур для Stable Diffusion вместе с текстовым описанием материала (<em>пусть нейронка разукрашивает мультифракталы!</em>), получается что-то типа <code>Semi-procedural stable diffusion</code>, материал часто сохраняет визуальные свойства и бесшовность:</p><p><img src="/blog/3923038774/proc_wood.png" alt=""><br><em>(процедурные кирпичи)</em></p><p><img src="/blog/3923038774/proc_marble.png" alt=""><br><em>(и мрамор)</em></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;h2 id=&quot;Stabl
      
    
    </summary>
    
    
    
      <category term="link" scheme="http://spiiin.github.io/tags/link/"/>
    
      <category term="3d" scheme="http://spiiin.github.io/tags/3d/"/>
    
      <category term="procgen" scheme="http://spiiin.github.io/tags/procgen/"/>
    
      <category term="ai" scheme="http://spiiin.github.io/tags/ai/"/>
    
  </entry>
  
  <entry>
    <title>Магистерский курс C++ МФТИ</title>
    <link href="http://spiiin.github.io/blog/1964756683/"/>
    <id>http://spiiin.github.io/blog/1964756683/</id>
    <published>2023-08-27T14:53:01.000Z</published>
    <updated>2023-08-27T16:29:25.315Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p><a href="https://www.youtube.com/playlist?list=PL3BR09unfgcgf7R88ZQRQqWOdLy4pRW2h" target="_blank" rel="noopener">https://www.youtube.com/playlist?list=PL3BR09unfgcgf7R88ZQRQqWOdLy4pRW2h</a></p><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/mDajl0pIUjQ" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div><p>Отличный курс по стандарту C++, у автора получается разбирать сложные и запутанные проблемы относительно простыми примерами.</p><p>Часто материалы затрагивают последние стандарт или то, что еще не вошло (hazzard pointers, facebook libunifex -  std::executor для диспетчеров асинхронных задач в стандарте (из gpu или потоков на cpu)). Доступно и подробно разобраны корутины.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;&lt;a href=&quot;h
      
    
    </summary>
    
    
    
      <category term="cpp" scheme="http://spiiin.github.io/tags/cpp/"/>
    
      <category term="link" scheme="http://spiiin.github.io/tags/link/"/>
    
  </entry>
  
  <entry>
    <title>Итоги первой половины 2023</title>
    <link href="http://spiiin.github.io/blog/3525050862/"/>
    <id>http://spiiin.github.io/blog/3525050862/</id>
    <published>2023-07-30T14:31:15.000Z</published>
    <updated>2023-08-27T13:00:32.591Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Предыдущие<br><a href="/blog/307513906/" title="Итоги 2020">Итоги 2020</a><br><a href="/blog/2738337723/" title="Итоги 2021-2022">Итоги 2021-2022</a></p><p><strong><code>Работа</code></strong></p><p>С начала года вернулся работать в “Gaijin”, теперь пишу на <a href="https://spiiin.github.io/tags/dascript/">daScript</a>. Нашёл несколько своих коммитов девятилетней давности со старого аккаунта, а также фотографии с корпоративных мероприятий.<br><img src="/blog/3525050862/egypt_small.png" alt=""></p><p>Днем отмечаешь релиз и катаешься на квадроциклах по дюнам Шарм-Эль-Шейха, а вечером узнаешь о “зеленых человечках”, и о том, что возвращаться придётся в совсем другой Крым. Опционально — не возвращаться совсем. Необычный опыт погружения в воспоминания из прошлого. Пора уже окончательно попрощаться с этими воспоминаниями.</p><p>Начало новой работы — сложное, за годы кодовая база и тулзы сильно меняются, предыдущее знания устаревают. Побочный эффект накопленного компанией software capital — необходимость в нём осваиваться. В геймдеве так или иначе, почти постоянно учишься, и обновляешь знания. Не успел закончить на прыдущем месте работы изучение геймдизайнерских/продюссерских материалов, как на новом снова вникать в новые темы. Заодно - привет нейронкам, они с нами всерьёз и надолго, и хорошо бы уметь ими пользоваться. Наверное, необходимость изучения — это логичная цена за то, чтобы оставаться на фронтире.</p><p>Хочется скорее выйти в режим своей нормальной производительности.</p><p><img src="/blog/3525050862/krit_ai.png" alt=""><br><em>(из книги Ричарда Бира “Мозг фирмы”) Как-то так, всегда в зоне критического решения и поиска/изучения технологии B</em></p><p>Ещё в этом году двое бывших коллег старше 30 ушли из программистов игр, один - в монетизационные менеджеры, другой в вайт-хакеры. Оба частично из-за того, что стало сложно учиться новому. Хех, мне пока наоборот, в кайф изучать что-то новое, было б еще времени побольше. В этом смысле сильно лучше, когда в окружении есть много крутых ребят. Хотелось бы когда-нибудь отметить свое 25-летие в геймдеве, возможно, тоже на каком-нибудь корпоративе у моря.</p><p><strong><code>Личное/путешествия</code></strong></p><p>Чё-то накрыло с головой от количества событий с начала года. Перебрался из Еревана в Хайфу. Много времени ушло на оформление различных бумажек, много сил на адаптацию в новой среде — Армения намного ближе по культуре к России или Украине, Израиль сильно другой, во всём.</p><p><img src="/blog/3525050862/yerevan_small.png" alt=""><br><em>Фонтаны ночного Еревана</em><br><img src="/blog/3525050862/tree_small.png" alt=""><br><em>Хайфовские бинарные деревья</em></p><p>В какой-то момент, сидишь на холме, смотришь на порт и понимаешь, что всё, нет пути обратно, и уже давно. Представляешь себя где-то на барже в океане</p><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/XTPGpBBwt1w" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div><p>Новости слушаешь только по радио, они важны, но далеко, временно важнее то, что происходит рядом. Такая вот чистка информационного фона.</p><p>Иногда ныряешь, чтобы что-то вспомнить.</p><p>Например, детство. Когда попал в “переход между поколениями”, братья и сестры старше на 10 лет, и на чердаке можно найти их старые игрушки. Забытые и отличающиеся от того, что рекламируется и во что играют все. Когда-то дядя и тетя ездили за границу, и привозили оттуда диковинки, которых не было у нас (я не верил в деда мороза, но верил, что их курица несет шоколадные яйца, откуда ж было знать, что существуют киндер-сюрпризы). Игры в комнате с этими игрушками, попытки генерировать сюжеты, вроде книги правил для построения города для игрушек из киндеров, или перестрелки между замками. Дальше - тамагочи, “ну погоди”, чэпсы, альбомы с наклейками, и прочие атрибуты 90х. Денди и сега, и желание делать игры. Кажется, что компьютерных играх есть что-то от дворовых развлечений, игрушек и математических формул.</p><p>Или позднее, универ и студенческие развлечения, вылазки на природу. Караби и турбаза “точка” на Чатыр Даге (там иногда проводили лан-пати по “контр-страйку”, “героям” и “варкрафту”), около-ролевые движухи, Джанк Пати (такой крымский Burning Man), Генуэзская крепость, фестивали в Коктебеле и под Щёлкино, ночёвки с палатками на Инжире (идешь туда по тропинкам на скале над морем, как будто из второй “готики”, и где ночью летом светится вода, как будто запускаешь фаербол в “мортал комбате”),  деревни на ЮБК.</p><p>Или какой-то момент на работе, когда пытался понять гейм-дизайнеров. Раньше, кажется, многие начинали с редакторов карт. Следующее поколение приходило больше из сценаристов, или игроков/авторов настольных игр. Следующее, вероятно, будет уже начинать с книг по гейм-дизайну или профессионального образования.</p><p>Потом выныриваешь, и возвращаешься.</p><p><em>в общем, путешествия за эти полгода в основном, такие</em></p><p>Необходимо учиться планировать не на короткий срок, когда чаще всего правильной стратегией будет двигаться туда, куда все, и когда завтра будет то же самое, что и сегодня, с небольшими изменениями (которые можно понять, если сравнить вчера и сегодня), а на длинный. Когда необходимо хотя бы попытаться собрать какую-то информацию, относящуюся к решению, и сделать вывод на основе этой информации, даже если он будет противоречить тому, что было вчера и тому, что есть сегодня. <code>Вообще говоря, так наверное надо планировать всегда</code>, а не только когда кажется, что ничего не понятно.</p><p><strong><code>Музыка</code></strong></p><p><code>- Balkan Beat Box + AWA</code><br><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/RT7p9JCoVmI" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></p><p><code>- Balkan Beat Box + Hadag Nahash</code><br><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/wvwHnjhxz0o" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></p><p><code>- Q2A</code><br><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/hcjBogMoX9g" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></p><p><strong><code>Фильмы</code></strong><br><code>- Банши Инеширина</code><br>Нелепый сюжет, но классная игра актёров, природа, и просто атмосфера. Также “играет” акцент, если смотреть в оригинале.</p><p><code>- The Super Mario Bros Movie</code><br>Шикарно. Особенно круто смотреть в 3d с раскачивающимися креслами, весь фильм по сути - экшен над пропастями.</p><p><code>- Дети СССР</code><br>Израильский фильм о эмигрантах 90х. Несколько раз обманывает с сюжетом, сначала ожидаешь рассказа об упавших на дно подростках, затем спортивного фильм, а на самом деле хорошая социальная драма.</p><p><code>- Горячая жевательная резинка</code><br>Еще один израильский фильм по формуле, по которой сделан Американский Пирог, но 1978 года.</p><p><strong><code>Приобретения</code></strong></p><p><code>- Steam deck</code><br>После покупки Ninntendo Switch понял, насколько удобнее играть с портативной платформы. Попробовал эмуляторы (<a href="https://www.emudeck.com/" target="_blank" rel="noopener">Emu Deck</a> - отличная сборка, чтобы не возиться с настройкой слишком много), много инди-игр, и пару экшенов. Безумно крутая вещь.</p><p><img src="/blog/3525050862/steamdeck_small.png" alt=""></p><p>Собрал уже коллекцию портативных приставок, Switch Lite<br><img src="/blog/3525050862/switch_lite_small.png" alt=""></p><p>И рука из Ikea, которая держит провода<br><img src="/blog/3525050862/hand_small.png" alt=""></p><p><strong><code>Игры</code></strong><br>Протыкал на свитче и стимдеке по несколько часов кучу игр.</p><p><code>- Fire Emblem Fates/Awakening/Three Houses/Engage (3ds/switch)</code><br>Достаточно простая, по тактике, но завлекательная, игра. Three Houses прикольна тем, что отношения вынесены из дополнительной механики в основную, большой кусок геймплея завязан на построение отношений с учениками, а не только бои.</p><p><code>- Symfony of War (pc)</code><br>Крутецкая по возможностям тактика.</p><p><code>- Legend of Zelda: Tears of the Kingdoom (switch)</code><br>Новая Зельда - как обычно нестандартная, с кучей новых механик и загадок на применение на механики, игра</p><p><code>- It takes Two (switch)</code><br>Отличная игра для прохождения с напарником</p><p>Еще разные по чуть-чуть<br><code>- Persona 5, Monster Hunter Stories, Kirby Forgotten Land, Fantasy Strike, Elden Ring, Ori and Blind Forest, Age of Calamity, Oxygen not included</code></p><p>Интересные инди (раньше мало играл совсем)<br><code>- Journey, Don&#39;t Starve, Slay the Spire, Subnautica, Oxygen not Included</code></p><p><strong><code>Книги</code></strong></p><p><code>Зубек. Элементы гейм-дизайна</code> - хорошее описание множества приёмов и техник.<br><code>Галенкин. Маркетинг игр</code> - основные приемы и возможности для инди и небольших команд, в большинстве устаревшие цифры.<br><code>Гилберт. Спотыкаясь о счастье</code> - описание множества экспериментов о том, как мы оцениваем будущее, и какие механизмы психики при этом действуют. Наравне с книгами по поведенческой психологии, необходимая книга для понимания действий людей.<br><code>Дневник художника-натуралиста</code> - как зарисовывать животных и растения.<br><code>Больше не мастерю и другое вранье</code> - книга по организации LARP, интересные главы про “модели” — выбор механик и правил. Когда-то ездил на пару ролёвок, но сейчас заинтересовался именно организацией, в рамках расширения знаний по геймдизайну.<br><code>Game feel</code> - устройство управления в играх. О том, как ощущение контроля персонажа помогает созданию погружения в мир игры.<br><code>Designing emergency + Advanced game mechanics</code> - по большей части, описание фреймворка для того, чтобы проектировать игровые механики в виде интерактивных схем.<br><code>Карта культурных различий</code> - в общем вместо книги хватило бы и статьи. О том, что разные команды отличаются в подходах, от количества необходимого общения, до взаимодействий с начальством.</p><p><strong><code>Развитие</code></strong></p><p>Допишу наверное когда-нибудь во второй половине года.</p><p><img src="/blog/3525050862/obsidian_2_small.png" alt=""><br><em>Граф заметок в Obsidian</em></p><p><img src="/blog/3525050862/foxy.jpg" alt=""></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;Предыдущие
      
    
    </summary>
    
    
    
      <category term="log" scheme="http://spiiin.github.io/tags/log/"/>
    
  </entry>
  
  <entry>
    <title>AI in imaginery world</title>
    <link href="http://spiiin.github.io/blog/3605719908/"/>
    <id>http://spiiin.github.io/blog/3605719908/</id>
    <published>2023-04-09T19:40:43.000Z</published>
    <updated>2023-04-10T20:47:39.875Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Попробовал решить <a href="/blog/1160489034/" title="задачу Джеймса Бонда-младшего">задачу Джеймса Бонда-младшего</a> с помощью <code>openai</code>.</p><p>Из интереса, где-то с 30 запросов (притом на русском языке) к 3-й версии ChatGPT получилось объяснить условие задачи. Часть запросов “отладочные”, чтобы понять, то, что пытается делать ИИ с моделью.</p><p>Примеры:<br><em>“Попробуй выполнить операции - сдвиг вправо 2-й строки, сдвиг вправо 3-й строки, сдвиг вправо 4-й строки. Примени каждую из них к начальной позиции”</em><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Конечно, вот результаты применения операций к начальной позиции квадрата чисел:</span><br><span class="line"></span><br><span class="line">Сдвиг вправо 2-й строки на одну позицию:</span><br><span class="line"></span><br><span class="line">Copy code</span><br><span class="line">11 12 13 14</span><br><span class="line">24 21 22 23</span><br><span class="line">31 32 33 34</span><br><span class="line">41 42 43 44</span><br><span class="line">Сдвиг вправо 3-й строки на одну позицию:</span><br><span class="line"></span><br><span class="line">Copy code</span><br><span class="line">11 12 13 14</span><br><span class="line">21 22 23 24</span><br><span class="line">34 31 32 33</span><br><span class="line">41 42 43 44</span><br><span class="line">Сдвиг вправо 4-й строки на одну позицию:</span><br><span class="line"></span><br><span class="line">Copy code</span><br><span class="line">11 12 13 14</span><br><span class="line">21 22 23 24</span><br><span class="line">31 32 33 34</span><br><span class="line">44 41 42 43</span><br><span class="line">В каждом случае соответствующая строка сдвинулась на одну позицию вправо, и последний элемент строки перешел на первое место.</span><br></pre></td></tr></table></figure></p><p><em>“Теперь попробуй выполнить операцию «сдвиг 4го столбца вверх» по шагам”</em></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Конечно! Вот пошаговое описание:</span><br><span class="line"></span><br><span class="line">Выделяем 4-й столбец:</span><br><span class="line">(11 12 13 14) (21 22 23 24) (31 32 33 34) (41 42 43 44)</span><br><span class="line"></span><br><span class="line">14 24 34 44</span><br><span class="line"></span><br><span class="line">Сдвигаем 4-й столбец вверх:</span><br><span class="line">(11 12 13 14) (21 22 23 24) (31 32 33 34) (41 42 43 44)</span><br><span class="line"></span><br><span class="line">14 24 34 44</span><br><span class="line">11 21 31 41</span><br><span class="line"></span><br><span class="line">Вставляем 4-й столбец обратно на своё место:</span><br><span class="line">(11 12 13 14) (21 22 23 24) (31 32 33 34) (41 42 43 44)</span><br><span class="line"></span><br><span class="line">12 13 14 44</span><br><span class="line">22 23 24 21</span><br><span class="line">32 33 34 31</span><br><span class="line">42 43 11 41</span><br><span class="line"></span><br><span class="line">Таким образом, получаем следующую конечную позицию.</span><br></pre></td></tr></table></figure><p><em>Во втором шаге ошибка — столбец 14 24 34 44 при сдвиге вверх станет 24 34 44 14</em><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Извините за ошибку в предыдущем ответе. Правильно будет так:</span><br><span class="line"></span><br><span class="line">Выделяем четвертый столбец: (14, 24, 34, 44)</span><br><span class="line">Сдвигаем его вверх: (24, 34, 44, 14)</span><br><span class="line">Вставляем сдвинутый столбец обратно в исходный квадрат:</span><br><span class="line">(11, 12, 13, 24)</span><br><span class="line"></span><br><span class="line">(21, 22, 23, 34)</span><br><span class="line"></span><br><span class="line">(31, 32, 33, 44)</span><br><span class="line"></span><br><span class="line">(41, 42, 43, 14)</span><br></pre></td></tr></table></figure></p><p>Ощущения — как от объяснения не очень умному школьнику, 4-я версия наверное быстрее уловит смысл. Но с момента, когда просишь переписать решение на Python, “школьник” безошибочно пишет функцию применения всех операций к исходной позиции, и поиск в ширину.</p><p>Дальше — интересней, ИИ может дописать оптимизацию с сортировкой с помощью функции оценки — предлагает эвклидово расстояние, а также манхеттенское расстояние и расстояние чебышева. C расстоянием эвклида он доходит до хорошей скорости выполнения. ИИ использовал для хранения списка открытых вершин <a href="https://docs.python.org/3/library/queue.html#queue.PriorityQueue" target="_blank" rel="noopener">PriorityQueue</a>. Это даёт отличающийся от моей самой первой программы (которая использует для хранения list и сортирует его каждые N шагов) результат — находит путь в 10 шагов, а не 9.</p><p>ИИ предложил добавить в код замену функции оценки с эвклидова расстояния на манхеттенское (при этому утверждает, что для “пятнашек”, за которые он принял эту задачу, эта функция гарантированно даёт лучшую оценку, хотя я не стал бы ему доверять в таких утверждениях). С <code>jupyter notebook</code> обращение к ИИ за переписыванием кода может выглядеть примерно так:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">//cell1, тут недописанный код</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_astar_path</span><span class="params">(start, end, operations)</span>:</span></span><br><span class="line">    queue = PriorityQueue()</span><br><span class="line">    queue.put((<span class="number">0</span>, [start]))</span><br><span class="line">    visited = set()</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> queue.empty():</span><br><span class="line">        _, path = queue.get()</span><br><span class="line">        vertex = path[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span> vertex == end:</span><br><span class="line">            print(<span class="string">"hash "</span>, len(visited), <span class="string">" queue "</span>, queue.qsize())</span><br><span class="line">            <span class="keyword">return</span> path</span><br><span class="line">        <span class="keyword">if</span> tuple(vertex) <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">            <span class="keyword">for</span> operation <span class="keyword">in</span> operations:</span><br><span class="line">                possible_path = path + [operation(vertex)]</span><br><span class="line">                queue.put((len(path) + euclide_distance(possible_path[<span class="number">-1</span>], target), possible_path))</span><br><span class="line">            visited.add(tuple(vertex))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">//cell2</span><br><span class="line">ss = <span class="string">"Rewrite function find_astar_path for using manhattan distance instead of euclide distance:\n"</span></span><br><span class="line">ss += _i1 <span class="comment">#обращение к тексту cell1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os, openai</span><br><span class="line"></span><br><span class="line">openai.api_key = os.getenv(<span class="string">"OPENAI_API_KEY"</span>)</span><br><span class="line"></span><br><span class="line">response = openai.Completion.create(</span><br><span class="line">  model=<span class="string">"text-davinci-003"</span>,</span><br><span class="line">  prompt=ss,</span><br><span class="line">  temperature=<span class="number">0.7</span>,</span><br><span class="line">  max_tokens=<span class="number">256</span>,</span><br><span class="line">  top_p=<span class="number">1</span>,</span><br><span class="line">  frequency_penalty=<span class="number">0</span>,</span><br><span class="line">  presence_penalty=<span class="number">0</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>Это позволило ИИ дойти до решения в 9 шагов, однако увеличило время выполнения с 2 до 10 секунд. Дальнейшие предложенные ChatGPT методы оптимизации — распараллеливание работы, построение предпросчитанной базы решений и переход на С++.</p><p>Ни одним из них он не справился сам. Мне не удалось заставить его реализовать свою наивную идею, или предложить её — <em>“если мы знаем, что функции оценки не очень хорошие, то вместо использования очереди приоритетов на каждом шаге, проверим заодно еще группу решений с немного худшей оценкой и посмотрим, не нашлось ли там решения лучше”</em>. Скорее всего, я просто не знаю “правильного” названия этого метода, поэтому пришлось дописать эту логику самому.</p><p>Интересно, что при этом я случайно обнаружил, что существует решение не в 9, а 8 шагов:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">source = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">2</span>]</span><br><span class="line">target = [<span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">path:</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span> ,<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">2</span>] source</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">2</span>] Right(<span class="number">2</span>)</span><br><span class="line">    [<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">2</span>] Left(<span class="number">0</span>)</span><br><span class="line">    [<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">1</span>] Down(<span class="number">3</span>)</span><br><span class="line">    [<span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>] Up(<span class="number">1</span>)</span><br><span class="line">    [<span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>] Left(<span class="number">0</span>)</span><br><span class="line">    [<span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>] Left(<span class="number">2</span>)</span><br><span class="line">    [<span class="number">4</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>] Down(<span class="number">2</span>)</span><br><span class="line">    [<span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>] Up(<span class="number">1</span>) == target</span><br></pre></td></tr></table></figure></p><p><strong>Когда есть возможность быстро попробовать много вариантов, среди них больше шансов обнаружить лучший</strong></p><p>Код: <a href="https://github.com/spiiin/james_bond_jr_problem/blob/main/james_bond_jr_openai.ipynb" target="_blank" rel="noopener">https://github.com/spiiin/james_bond_jr_problem/blob/main/james_bond_jr_openai.ipynb</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;Попробовал
      
    
    </summary>
    
    
    
      <category term="python" scheme="http://spiiin.github.io/tags/python/"/>
    
      <category term="ai" scheme="http://spiiin.github.io/tags/ai/"/>
    
  </entry>
  
  <entry>
    <title>AI prompts</title>
    <link href="http://spiiin.github.io/blog/1596814086/"/>
    <id>http://spiiin.github.io/blog/1596814086/</id>
    <published>2023-04-08T13:02:32.000Z</published>
    <updated>2023-09-03T10:36:07.262Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Потестил немного, что умеют нейронки.</p><p><a href="https://github.com/f/awesome-chatgpt-prompts" target="_blank" rel="noopener">Awesome ChatGPT Prompts</a> - примеры запросов к <code>ChatGPT</code><br><a href="https://trello.com/b/4BPkSY1w/100-ai-prompts-resources-prompt-lovers" target="_blank" rel="noopener">100+ AI Prompts &amp; Resources</a> - еще один список чит-кодов</p><p>Можно попросить ChatGPT сгенерировать развёрнутое описание личности по простому описанию, которое которое можно применить к другому диалогу с ней же. <code>&quot;Act as English translator&quot;</code> — для корректирования своих же запросов на английском, <code>&quot;Act as photographer&quot;</code> — для более красивого описания сцены для генератора изображений. Можно попросить действовать в стиле “Акинатора” — задавать наводящие вопросы по тому, как должна выглядеть описываемая сцена.</p><p>Трюки для <code>Midjourney</code>:<br><a href="https://www.youtube.com/watch?v=NBT7hJEZw4k" target="_blank" rel="noopener">The Ultimate MidJourney Prompting Guide</a> — гайд по фичам midjourney<br><a href="https://medium.com/mlearning-ai/an-advanced-guide-to-writing-prompts-for-midjourney-text-to-image-aa12a1e33b6" target="_blank" rel="noopener">An advanced guide to writing prompts for Midjourney</a> - список стилей<br><a href="https://docs.midjourney.com/docs/explore-prompting" target="_blank" rel="noopener">Explore Prompting</a> — дока, тоже список стилей<br><a href="https://www.youtube.com/watch?v=Asg1e_IYzR8" target="_blank" rel="noopener">GPT-4 + Midjourney V5 = A New Era of Photography?</a> — chat-gpt4 для генерации запросов (act as photograph)<br><a href="https://www.youtube.com/watch?v=N90yjO0bm_w" target="_blank" rel="noopener">Midjourney AI Tutorial | Get AMAZING Midjourney Prompts</a> — генератор в виде опросника (free trial)<br><a href="https://www.youtube.com/watch?v=_7eH8ugjQtg" target="_blank" rel="noopener">I Found the Ultimate CHEAT CODE in Midjourney!</a> — чит с подготовкой фона, на котором будет нарисован следующий промт</p><p>Трюки — детальное описание сцены, подсказки по стилю, “улучшающие” слова вроде hires, best quality, попытки сохранения стиля с повторением сида, дорисовки по исходной картинке, смешивание картинок.</p><p>Одна из фич — позволяет получить несколько детальных описаний из загруженной картинки, чтобы поэкспериментировать с перегенерацией картинки по этому описанию.</p><p>Midjourney рисует лучше Dall-E и StableDiffussion, но платный. Лучше знает названия мест, животных и растений. Для примера сгенерил запросы по местам в Крыму, знает форму дворца Ласточкино Гнездо:<br><img src="/blog/1596814086/gnezdo_small.png" alt=""></p><p><code>StableDiffusion</code> — бесплатный, рисует хуже, обучен на открытых базах, существуют различные модели, заточенные под различные стили или задачи, а также множество инструментов под различные задачи. Можно поставить локально (нужна видеокарта с 6-8 гб памяти). Можно использовать как библиотеку, либо поставить webgui:<br><a href="https://github.com/artmamedov/artroom-stable-diffusion/releases" target="_blank" rel="noopener">Artroom</a><br><a href="https://github.com/AUTOMATIC1111/stable-diffusion-webui" target="_blank" rel="noopener">Stable Diffustion web UI</a><br><a href="https://huggingface.co/models?other=stable-diffusion" target="_blank" rel="noopener">Модели</a></p><p>Примеры работы:<br><a href="https://www.youtube.com/watch?v=PUFlt4JVlvI" target="_blank" rel="noopener">Гравировка за 10 минут в Stable Diffusion для любой 3D МОДЕЛИ</a> - генерация по маске<br><a href="https://www.youtube.com/watch?v=Ffl8b_GfJ-M" target="_blank" rel="noopener">Stable Diffusion Consistent Character Animation Technique - Tutorial</a> - дорисовка по маске позы<br><a href="https://huggingface.co/blog/controlnet" target="_blank" rel="noopener">Ultra fast ControlNet with Diffusers</a> - генерация по драфту, определение позы, <a href="https://huggingface.co/docs/diffusers/main/en/api/pipelines/stable_diffusion/controlnet" target="_blank" rel="noopener">ещё пример</a><br><a href="https://www.youtube.com/watch?v=FLaics4IT-w" target="_blank" rel="noopener">Interactive Map Generation using Stable Diffusion</a> - итеративная дорисовка (если использовать как библиотеку, а не webui, можно было бы вызывать повторения одной функцией)</p><p>Модели плагина <a href="https://www.youtube.com/watch?v=vFZgPyCJflE&amp;list=PLXS4AwfYDUi7zeEgJRM-PfB6KKhXt1faY" target="_blank" rel="noopener">ControlNet</a> для StableDiffusion:<br>    <code>canny</code> - дорисовка по силуэту<br>    <code>depth</code> - дорисовка по карте глубины, эту модель использует также расширение Blender Dream Texture, для проекции текстуры на 3d модель. метод depth-leres позволяет настраивать освещение<br>    <code>openpose</code> - захват позы в виде скелета, openpose editor - редактирование скелета<br>    <code>scribble</code> - по грубому черновику картинки</p><p>Попробовал скормить midjourney скриншот из Botw-ы с узором на дереве, сгенерировал похожие текстуры:<br><img src="/blog/1596814086/wood1_small.png" alt=""></p><p>Так как и Midjourney и Stable Diffusion позволяют сгенерировать тайлящиеся текстуры, то можно пойти дальше и попросить CharGPT написать скрипт, разрезающий результат на части, и отобразить результат сшитой текстуры:<br><img src="/blog/1596814086/gpt1_small.png" alt=""></p><p><img src="/blog/1596814086/wood2_tiled.png" alt=""></p><p>(вместо общения через чат проще использовать <a href="https://github.com/openai/openai-python" target="_blank" rel="noopener">openai</a>)</p><p>Из полученной текстуры можно с помощью ещё одной модели нейронки <a href="https://github.com/HugoTini/DeepBump" target="_blank" rel="noopener">DeepBump</a> получить карту нормалей и высот. <code>DeepBump</code> можно использовать как плагин для Blender или из командной строки:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cli.py color.jpg normals.jpg color_to_normals</span><br><span class="line">cli.py normals.png height.png normals_to_height</span><br></pre></td></tr></table></figure><p>Чтобы посмотреть результат, можно снова попросить ChatGpt написать программу для отображения результата (проще всего выбрать <a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a>):</p><p><em>“Provide code to show plane with diffuse texture and normal map”</em> +<br><em>“provide minimal html page to show this example”</em> +<br><em>“how to run server in python to show this html page?”</em> +<br><em>“change example to rotate not a plane, but light source”</em> +<br><em>“change rotating light from timer to rotating by user with mouse”</em> =<br>Код примера, и напутствие:<br>And that’s it! With this code, you can display a plane with a diffuse texture and normal map. Keep in mind that this is just a simple example and there are many ways to improve and extend it.</p><p><img src="/blog/1596814086/ans2_small.png" alt=""><br><img src="/blog/1596814086/ans1_small.png" alt=""><br><img src="/blog/1596814086/ans3_small.png" alt=""></p><p>Код нагенерированных примеров, 0 строк ручного кода (кроме тыкания параметров материала для бампа — roughness/metalness)<br><a href="https://github.com/spiiin/openai_threejs_bump" target="_blank" rel="noopener">https://github.com/spiiin/openai_threejs_bump</a></p><p>Местами уже может сильно упростить жизнь — собрать несколько простых примеров вместе, напрототипить, выполнить рутинную задачу (иногда с захватом корнер кейсов), получить саммари знаний по теме. С риском галлюцинаций и обмана, но быстрее, чем делать руками.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;Потестил н
      
    
    </summary>
    
    
    
      <category term="procgen" scheme="http://spiiin.github.io/tags/procgen/"/>
    
      <category term="ai" scheme="http://spiiin.github.io/tags/ai/"/>
    
  </entry>
  
  <entry>
    <title>C++ Metaprogramming - ссылки</title>
    <link href="http://spiiin.github.io/blog/4174799834/"/>
    <id>http://spiiin.github.io/blog/4174799834/</id>
    <published>2023-03-19T00:30:26.000Z</published>
    <updated>2023-03-19T20:26:15.820Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Список книг и ресурсов по метапрограммированию в C++. Грубая карта небольшой части огромной территории.</p><p>Желание разобраться с очередным трюком с шаблонами в C++ приходит после обнаружения какой-либо библиотеки или кода, который непонятно как работает, но вроде что-то ловко делает. И заканчивается мыслью “это ж ебануться можно, так писать”.</p><a id="more"></a><p>Такие мысли приходят в голову всем практикующим и работающим в командах программистам. Пара примеров лютых исходников — <a href="https://github.com/lewissbaker/cppcoro" target="_blank" rel="noopener">cppcoro</a>, <a href="https://github.com/ericniebler/range-v3" target="_blank" rel="noopener">range-v3</a> (<a href="https://aras-p.info/blog/2018/12/28/Modern-C-Lamentations/" target="_blank" rel="noopener">“Modern” C++ Lamenations</a>).<br><img src="/blog/4174799834/spiderman.jpg" alt=""></p><p><a href="/blog/2297379949/" title="Заметки о языках программирования">Заметки о языках программирования</a> — про использование различных языков для решения задач различных уровней, а также подходы к борьбе с возрастающей сложностью при масштабируемости.<br><a href="/blog/1728194429/" title="С++ в геймдеве">С++ в геймдеве</a> — “высокоуровневый” С++ - часть задач решаемых метапрограммированием.</p><h2 id="Общий-обзор-возможностей-шаблонов-и-списки-примеров-использования"><a href="#Общий-обзор-возможностей-шаблонов-и-списки-примеров-использования" class="headerlink" title="Общий обзор возможностей шаблонов и списки примеров использования:"></a>Общий обзор возможностей шаблонов и списки примеров использования:</h2><p><strong><code>Vandervoorde D. Josuttis N. Gregor D. - C++ Templates: The Complete Guide</code></strong> - полный обзор возможностей языка, второе издание — по C++17<br><strong><code>Александреску А. - Современное проектирование на C++</code></strong> - pre-C++11, но классические идеи<br><strong><code>Di Genaro D. - Advanced Metaprogramming in Classic C++</code></strong> - много небольших примеров<br><a href="https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms" target="_blank" rel="noopener">More C++ idioms</a> - еще больше примеров, не только с шаблонами<br><a href="https://www.boost.org/" target="_blank" rel="noopener">Boost</a> - лучший учебник</p><h2 id="Generic-типы"><a href="#Generic-типы" class="headerlink" title="Generic-типы"></a>Generic-типы</h2><p>Часто первое столкновение с шаблонами — обобщенные контейнеры, итераторы и умные указатели из <code>stl</code><br>Более продвинутые примеры — стратегии Александреску, задание отношений между типами, CRTP, template template параметры</p><p><a href="https://github.com/skypjack/entt/blob/master/src/entt/container/dense_set.hpp" target="_blank" rel="noopener">EnTT dense set</a> - пример кода контейнера и итератора не из stl<br><a href="https://github.com/tamasmeszaros/libnest2d/blob/master/include/libnest2d/libnest2d.hpp" target="_blank" rel="noopener">libnest2d</a> - небольшая библиотека для паковки многоугольников, использующая стратегии для выбора вариантов оптимизации, паковки и математического бекэнда</p><h2 id="Задание-ограничений-и-свойств-для-типов"><a href="#Задание-ограничений-и-свойств-для-типов" class="headerlink" title="Задание ограничений и свойств для типов"></a>Задание ограничений и свойств для типов</h2><p>Контракты, распознавание свойств типов (<code>std::is_XXX</code>), частичная специализация</p><p><strong><code>Stepanov A. - Elements of programming</code></strong> - математическое описание типов и структур, контракты<br><a href="https://sean-parent.stlab.cc/papers-and-presentations/" target="_blank" rel="noopener">Lecture and presentation Sean Parent</a> - и другие лекции Шона Парента, про value-oriented programming</p><p><a href="https://github.com/GaijinEntertainment/daScript/pull/472/files#diff-2a42eb62b92995bc578cc927dc871b66a1a00f003c819a108abd291e23b33bb1R150" target="_blank" rel="noopener">Пример из daScript</a> — частичная специализация с захватом новых шаблонных параметров<br><a href="https://stackoverflow.com/questions/4189945/templated-class-specialization-where-template-argument-is-a-template" target="_blank" rel="noopener">Templated class specialization where template argument is a template</a> - описание возможных подходов к созданию связи между шаблонными параметрами</p><h2 id="Работа-с-типами-как-с-данными"><a href="#Работа-с-типами-как-с-данными" class="headerlink" title="Работа с типами как с данными"></a>Работа с типами как с данными</h2><p>Типы не являются объектами первого класса, поэтому работы с ними, поэтому все действия выполняются во время компиляции. Один из ключевых приёмов — выбор того, или иного типа в зависимости от статически известного условия. При этом не определяется новый тип, а создаётся псевдоним для существуюшего, “слот”, в который можно сохранить любой тип (<code>typedef</code>). Типы используются не для создания экземпляров, а для вообще чего угодно, от управляющих конструкций и отправки сигналов в рантайм, до операций группировки других типов.</p><p><strong><code>Abrahams D. Gurtovoy A. - C++ Template Metaprogramming</code></strong> - одна из наиболее замороченных книг, pre-C++11. Частично описывает <a href="https://www.boost.org/doc/libs/1_43_0/libs/mpl/doc/index.html" target="_blank" rel="noopener">Boost.MPL</a><br><a href="https://www.boost.org/doc/libs/master/libs/mp11/doc/html/mp11.html" target="_blank" rel="noopener">Boost.Mp11</a> - C++11-версия библиотеки для манипуляции с типами, несколько статей сравнения новых подходов со старыми</p><h2 id="Domain-Specific-Language"><a href="#Domain-Specific-Language" class="headerlink" title="Domain Specific Language"></a>Domain Specific Language</h2><p>Следующая идея — пойти еще дальше: построить на специальных типах свой язык, с управляющими конструкциями. Примеры задач — парсинг команд и создание деревьев выражений для последующего вычисления в рантайме.</p><p><a href="https://www.youtube.com/watch?v=r_ZASJFQGQI" target="_blank" rel="noopener">Hana Dusíková — A state of сompile time regular expressions</a> — регулярные выражения в compile-time (<a href="https://github.com/hanickadot/compile-time-regular-expressions" target="_blank" rel="noopener">compile-time.re</a>)<br><a href="https://www.youtube.com/watch?v=PJwd4JLYJJY" target="_blank" rel="noopener">Ben Deane &amp; Jason Turner “constexpr ALL the Things!”</a> — парсинг json в compile-time</p><p><a href="/blog/1552834708/" title="Runtime-полиморфизм в C++">Runtime-полиморфизм в C++</a> - пост со ссылками на серию видео про построение в compile-time кастомных версий динамического полиморфизма. <a href="https://github.com/ldionne/dyno" target="_blank" rel="noopener">dyno</a> - библиотека Louis Dionne, автора Boost.Hana</p><h2 id="Выполнение-кода-в-compile-time"><a href="#Выполнение-кода-в-compile-time" class="headerlink" title="Выполнение кода в compile-time"></a>Выполнение кода в compile-time</h2><p>Изначально возможность выполнения кода во время компиляции в С++ была артефактом шаблонов (первая “программа” - вывод простых чисел в сообщении об ошибке). Со временем добавляются более серьёзные возможности, однако код времени компиляции серьёзно ограничен и отличается от среды выполнения.</p><p>Примеры задач в compile-time:</p><ul><li>заранее предпосчитать значение выражение, все части которого известны на момент компиляции</li><li>построить таблицу значений чистой функции, которая долго вычисляется</li></ul><p>Основная возможность в pre-C++11 - SFINAE и рекурсивные+терминальные пары функций, и дополнительно const-expr/if/eval в более поздних стандартах.</p><p><a href="https://www.youtube.com/watch?v=NNU6cbG96M4" target="_blank" rel="noopener">Don’t constexpr All the Things - David Sankel CppNow 2021</a> - обзор ограничений подъязыка времени выполнения<br><a href="https://www.circle-lang.org/" target="_blank" rel="noopener">Circle</a> - wip компилятор C++ Шона Бакстера, с возможностью выполнение кода на этапе компиляции без ограничений<br><a href="https://probablydance.com/2015/02/16/ideas-for-a-programming-language-part-3-no-shadow-worlds/" target="_blank" rel="noopener">Ideas for a Programming Language Part 3: No Shadow Worlds</a> - похожие рассуждения на тему того, что не полностью интегрированные в основной язык подмножества создают “теневые миры”, в которых приходится переизобреть заново возможности основного языка</p><p><em>В Circle меня настораживает, что код, кажется, должен компилироваться дважды, особенно с учетом того, что скорее всего выполнение кода в compile-time будет медленнее, чем в рантайм. Для nim выполнение кода в compile-time — раз в 10 медленее</em></p><h2 id="Доступ-к-данным-о-типах-в-рантайм"><a href="#Доступ-к-данным-о-типах-в-рантайм" class="headerlink" title="Доступ к данным о типах в рантайм"></a>Доступ к данным о типах в рантайм</h2><p>Отсутствует в C, и не zero-cost абстракция, так что в стандарте языка отсутствует механизм неявной передачи информации о типах в рантайм (можно откопать <a href="https://youtu.be/NWIsRFDaHhs?t=847" target="_blank" rel="noopener">пачку</a> предложений для будущих улучшений).</p><p>Поэтому задачи типа <code>рефлексии/инстроспекции</code> решаются либо явной декларацией полей и методов класса (как при создании врапперов для других языков), либо предварительным внешним парсингом кода — либо кастомной метаинформации, которую пропускает компилятор C++ (в комментариях), либо полноценным разбором кода (<code>clang</code>), с последующей генерацией по этой информации кода.</p><p>Аналогично, без явной интроспекции и вещи вроде <code>сериализации</code> или описания RPC не могут быть неявными — необходимо явно аннотировать типы. </p><p><code>Кодогенерация</code> выражений на C++ в рантайме также отсутствует в стандарте, и заменяется генерации во время компиляции — текста, либо бинарного кода (или промежуточного кода, вроде IR для LLVM).</p><p><a href="/blog/315556844/" title="LLVM - обзор">LLVM - обзор</a> — обзор тулзов из набора LLVM, для парсинга и генерации кода, в настоящий момент state-of-art для генерации кода на C++<br><a href="https://www.youtube.com/watch?v=aPTyatTI42k" target="_blank" rel="noopener">Automatic C++ source code generation with clang - Sergei Sadovnikov ACCU 2017</a> - доклад с обзором подходов, и способа генерации с помощью clang<br><a href="https://www.youtube.com/watch?v=NWIsRFDaHhs" target="_blank" rel="noopener">Reflection in C++ Next - Anton Bikineev - Meeting C++ 2017</a> - обзор пропозалов в стандарт, связанных с рефлексией<br><a href="https://www.boost.org/doc/libs/1_79_0/libs/serialization/doc/tutorial.html" target="_blank" rel="noopener">Boost.Serialization</a> - сериализация в Boost</p><h2 id="Функциональное-программирование"><a href="#Функциональное-программирование" class="headerlink" title="Функциональное программирование"></a>Функциональное программирование</h2><p>Обширная тема. Элементы функционального стиля программирования — <code>комбинирование функций</code> (функции высшего порядка, частичное применение, отложенные вычисления) и их <code>чистота</code>. Часть перечисленных выше методов метапрограммирования направлена на борьбу со возрастающей при масштабировании программ сложностью путем создания новых абстракций. Функциональное программирование также работает с абстракциями, но выбирает их со стороны математики, ради того, чтобы использовать свойства уже изученных объектов (с поправкой на то, что в языках программирования реализуются приближения к математическим объектам).</p><p><strong><code>Чукич И. - Функциональное программирование на языке С++</code></strong> — книга о том, как использовать элементы функционального программирования на C++, ссылки на библиотеки буста, реализующие концепции<br><a href="https://github.com/hmemcpy/milewski-ctfp-pdf/" target="_blank" rel="noopener">Milewski B. - Category Theory For Programmers</a> - серия статей (собранная в книгу), по теории категорий для программистов, с примерами на C++ и хаскелл. <a href="https://www.youtube.com/watch?v=I8LbkfSSR58&amp;list=PLbgaMIhjbmEnaH_LTkxLI7FMa2HsnawM_" target="_blank" rel="noopener">Видеолекции</a> на ту же тему<br><a href="https://www.gamedeveloper.com/programming/in-depth-functional-programming-in-c-" target="_blank" rel="noopener">In-depth: Functional programming in C++</a> - статья Кармака про бонусы, которые можно получить, если использовать функциональный подход, в частности, бонусы от чистоты функций</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Список книг и ресурсов по метапрограммированию в C++. Грубая карта небольшой части огромной территории.&lt;/p&gt;
&lt;p&gt;Желание разобраться с очередным трюком с шаблонами в C++ приходит после обнаружения какой-либо библиотеки или кода, который непонятно как работает, но вроде что-то ловко делает. И заканчивается мыслью “это ж ебануться можно, так писать”.&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="cpp" scheme="http://spiiin.github.io/tags/cpp/"/>
    
      <category term="книги" scheme="http://spiiin.github.io/tags/%D0%BA%D0%BD%D0%B8%D0%B3%D0%B8/"/>
    
      <category term="link" scheme="http://spiiin.github.io/tags/link/"/>
    
  </entry>
  
  <entry>
    <title>daScript - контексты</title>
    <link href="http://spiiin.github.io/blog/3298324261/"/>
    <id>http://spiiin.github.io/blog/3298324261/</id>
    <published>2023-03-08T11:57:37.000Z</published>
    <updated>2023-09-28T08:43:48.380Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>В заметке про <a href="/blog/3006126295/" title="live-режим">live-режим</a> для opengl-приложений в daScript я кратко описывал контексты (раздел <code>Архитектура приложения</code>). Здесь разберу их немного более подробно.</p><a id="more"></a><h2 id="Контекст"><a href="#Контекст" class="headerlink" title="Контекст"></a>Контекст</h2><p>Программы daScript выполняются в <a href="https://github.com/GaijinEntertainment/daScript/blob/master/include/daScript/simulate/simulate.h#L252" target="_blank" rel="noopener">контексте</a>, структуре, которая хранит окружение программы — выделенную память, в которой хранятся код и данные программы, загруженные модули, настройки виртуальной машины.</p><p><a href="https://github.com/GaijinEntertainment/daScript/blob/master/examples/tutorial/tutorial06.cpp" target="_blank" rel="noopener">tutorual06</a> показывает работу с контекстом в daScript:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//загружаем das-файл и компилируем его</span></span><br><span class="line"><span class="keyword">auto</span> program = compileDaScript(<span class="string">"dummy.das"</span>, fAccess, tout, dummyLibGroup);</span><br><span class="line"><span class="comment">//создаём контекст, в котором будет выполняться программа</span></span><br><span class="line">ContextPtr ctx = make_shared&lt;Context&gt;(program-&gt;getContextStackSize());</span><br><span class="line"><span class="comment">//симулируем выполнение программу (строит дерево симуляции для выполнения в виртуальной машине)</span></span><br><span class="line">program-&gt;simulate(*ctx, tout);</span><br><span class="line"><span class="comment">//находим в контексте скомпилированную функцию</span></span><br><span class="line">SimFunction *fni = ctx-&gt;findFunction(<span class="string">"test"</span>);</span><br><span class="line"><span class="comment">//тут могут быть опциональные стадии проверки сигнатуры функции</span></span><br><span class="line">verifyCall&lt;<span class="keyword">float</span>&gt;(fni-&gt;debugInfo, dummyLibGroup);</span><br><span class="line"><span class="comment">//выполняем функцию в контексте, тип результата -- 128-бит</span></span><br><span class="line">vec4f res = ctx-&gt;evalWithCatch(fni, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="comment">//приводим результат к C++-типу</span></span><br><span class="line"><span class="keyword">float</span> result = cast&lt;<span class="keyword">float</span>&gt;::to(res);</span><br></pre></td></tr></table></figure><p>(<a href="/blog/2115627465/" title="Устройство интерпретаторов lua-jit и daScript">Устройство интерпретаторов lua-jit и daScript</a> — немного более детально про симуляцию программы)</p><p>Создание и удаление контекстов в daScript дешёво, один из паттернов организации C++-приложения, использующего daScript — выделение нового контекста, выполнение в нём работы и уничтожение.</p><p>Контекст можно воспринимать как экземпляр выполняющейся программы. Программа на С++ может иметь несколько контекстов, каждый из которых может выполнять программу на daScript (как скомпилированную из различных das-файлов, так и из одного и того же).</p><h2 id="Создание-контекста-из-daScript"><a href="#Создание-контекста-из-daScript" class="headerlink" title="Создание контекста из daScript"></a>Создание контекста из daScript</h2><p>API для создания контекстов также доступно в самом daScript, так что скрипт сам может создавать новые контексты и выполнять в них программы.</p><p>Пример <a href="https://github.com/GaijinEntertainment/daScript/blob/master/examples/test/misc/eval_in_context.das" target="_blank" rel="noopener">eval_in_context</a>:</p><figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//создание текста программы</span></span><br><span class="line"><span class="keyword">let</span> text = build_string &lt;| $(st)</span><br><span class="line">    st |&gt; write(<span class="string">"[export]\n"</span>)</span><br><span class="line">    st |&gt; write(<span class="string">"def eval(var res:int?)\n"</span>)</span><br><span class="line">    st |&gt; write(<span class="string">"\tunsafe\n"</span>)</span><br><span class="line">    st |&gt; write(<span class="string">"\t\t*res = 42\n"</span>)</span><br><span class="line">    st |&gt; write(<span class="string">"\n"</span>)</span><br><span class="line"><span class="comment">//def eval(var res:int?)</span></span><br><span class="line"><span class="comment">//  unsafe</span></span><br><span class="line"><span class="comment">//      *res = 42</span></span><br><span class="line"></span><br><span class="line">access |&gt; set_file_source(<span class="string">"__dummy_file_name"</span>, text)</span><br><span class="line">  using &lt;| $(var mg:ModuleGroup)</span><br><span class="line">    using &lt;| $(var cop:CodeOfPolicies)</span><br><span class="line">      <span class="comment">//компилируем строку с текстом программы</span></span><br><span class="line">      compile_file(<span class="string">"__dummy_file_name"</span>,access,unsafe(addr(mg)), cop) &lt;| $(ok,program,errors)</span><br><span class="line">        <span class="comment">//строим дерево симуляции</span></span><br><span class="line">        simulate(program) &lt;| $ (sok; context; serrors )</span><br><span class="line">          unsafe</span><br><span class="line">            var res:int</span><br><span class="line">            <span class="comment">//выполняем функцию eval в контексте скомпилированной программы</span></span><br><span class="line">            context |&gt; invoke_in_context(<span class="string">"eval"</span>, addr(res))</span><br><span class="line">            print(<span class="string">"&#123;res&#125;\n"</span>)</span><br></pre></td></tr></table></figure><p>В примере выше в скомплированные программу передаётся адрес из другого контекста. Это небезопасно, так как один контекст ничего не знает про время жизни переменных другом, поэтому операция отмечена как <code>unsafe</code>.</p><h2 id="Форк-контекста"><a href="#Форк-контекста" class="headerlink" title="Форк контекста"></a>Форк контекста</h2><p>Кроме возможности иметь раздельные контексты, daScript позволяет склонировать существующий контекст — <a href="https://github.com/GaijinEntertainment/daScript/blob/cd448fdbd4c6aa81897d2a8543943af112e2cbeb/src/simulate/simulate.cpp#L1659" target="_blank" rel="noopener">fork_debug_agent_context</a>. Функция создаёт клон контекста, и выставляет флаг контекста <code>persistent</code>, а затем в этом клонированном контексте выполняет функцию инициализации, переданную аргументом. Обычно в этой функции регистрируется новый <code>DebugAgent</code> — обёртка над контекстом, которая позволяет найти указатель на склонированный контекст по имени (и опционально, изменить поведение с помощью хуков). Склонированный контекст имеет доступ к тому же окружению, что и основной (модули, функции, копии переменных).</p><p><strong>Склонированный контекст не копирует состояние из основного!</strong></p><p>Пример <a href="https://github.com/GaijinEntertainment/daScript/blob/726d440be7618fb431815b18e6f785c37a335d5d/examples/test/misc/agent_fork_sample.das" target="_blank" rel="noopener">agent_fork_sample.das</a></p><figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">require debugapi</span><br><span class="line"></span><br><span class="line">var test_value = <span class="string">"default"</span></span><br><span class="line"></span><br><span class="line">[export] def debug_context_set()</span><br><span class="line">    print(<span class="string">"&#123;this_context().name&#125;:&#123;test_value&#125;\n"</span>)</span><br><span class="line">    test_value = <span class="string">"debug_context"</span> <span class="comment">//изменить значение переменной в контексте debug_context</span></span><br><span class="line">    print(<span class="string">"&#123;this_context().name&#125;:&#123;test_value&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line">[export]</span><br><span class="line">def main</span><br><span class="line">    this_context().name := <span class="string">"my_context"</span></span><br><span class="line">    fork_debug_agent_context &lt;| @@(var new_context : Context)</span><br><span class="line">        <span class="comment">//вызывается в новом контексте, устанавливаем DebugAgent, который сохранит ссылку на новый контекст</span></span><br><span class="line">        install_new_debug_agent(<span class="keyword">new</span> DapiDebugAgent(), <span class="string">"debug_context"</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"&#123;this_context().name&#125;:&#123;test_value&#125;\n"</span>)</span><br><span class="line">    <span class="comment">//меняем значение глобальной переменной</span></span><br><span class="line">    test_value = <span class="string">"my_context"</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"&#123;this_context().name&#125;:&#123;test_value&#125;\n"</span>)</span><br><span class="line">    <span class="comment">//ждём создания контекста агента</span></span><br><span class="line">    <span class="keyword">while</span> !has_debug_agent_context(<span class="string">"debug_context"</span>)</span><br><span class="line">        pass</span><br><span class="line">    unsafe</span><br><span class="line">        <span class="comment">//изменяем значение переменной в контексте debug_context</span></span><br><span class="line">        get_debug_agent_context(<span class="string">"debug_context"</span>) |&gt; invoke_in_context(<span class="string">"debug_context_set"</span>)</span><br><span class="line">    </span><br><span class="line">    print(<span class="string">"&#123;this_context().name&#125;:&#123;test_value&#125;\n"</span>)</span><br></pre></td></tr></table></figure><p>Выведет:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">my_context:default                            &#x2F;&#x2F; в основном контексте test_value имеет значение по умолчанию</span><br><span class="line">my_context:my_context                         &#x2F;&#x2F; изменили значение в основном контексте</span><br><span class="line">debug agent debug_context:default             &#x2F;&#x2F; &lt;--в склонированном контексте test_value имеет значение по умолчанию</span><br><span class="line">debug agent debug_context:debug_context       &#x2F;&#x2F; изменили значение в склонированном контексте</span><br><span class="line">my_context:my_context                         &#x2F;&#x2F; в основном контексте значение test_value не изменилось</span><br></pre></td></tr></table></figure></p><p>Аннотация для функций <a href="https://github.com/GaijinEntertainment/daScript/blob/726d440be7618fb431815b18e6f785c37a335d5d/examples/test/misc/apply_in_context_example.das" target="_blank" rel="noopener">apply_in_context</a> позволяет вызывать функцию в другом контексте прозрачно для вызывающего кода. Пример выше можно переписать так:</p><figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">require daslib/apply_in_context</span><br><span class="line"></span><br><span class="line">[apply_in_context(debug_context)]</span><br><span class="line">def debug_context_set()</span><br><span class="line">    print(<span class="string">"&#123;this_context().name&#125;:&#123;test_value&#125;\n"</span>)</span><br><span class="line">    test_value = <span class="string">"debug_context"</span> <span class="comment">//изменить значение переменной в контексте debug_context</span></span><br><span class="line">    print(<span class="string">"&#123;this_context().name&#125;:&#123;test_value&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line">...<span class="comment">//тот же код создания агента</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> !has_debug_agent_context(<span class="string">"debug_context"</span>)</span><br><span class="line">    pass</span><br><span class="line">debug_context_set() <span class="comment">//функция будет вызвана в контексте debug_context</span></span><br></pre></td></tr></table></figure><p>Пример создания отдельного контекста — модуль <a href="https://github.com/GaijinEntertainment/daScript/blob/master/daslib/live.das#L189" target="_blank" rel="noopener">live</a>, пример клонирования — <a href="https://github.com/GaijinEntertainment/daScript/blob/5649b32e8b779ceb90b7eabd73f58b7d2077cff6/modules/dasOpenGL/opengl/opengl_cache.das#L56" target="_blank" rel="noopener">opengl_cache</a>.</p><h2 id="Переопределение-поведения-debug-агентов"><a href="#Переопределение-поведения-debug-агентов" class="headerlink" title="Переопределение поведения debug-агентов"></a>Переопределение поведения debug-агентов</h2><p>Можно вызвать функции, определённые в классе-наследнике debug-агента (<a href="https://github.com/GaijinEntertainment/daScript/blob/37b86881a8f4890913e2f80537708575c3441a3f/examples/test/misc/invoke_debug_agent_function.das" target="_blank" rel="noopener">invoke_debug_agent_function</a>), но намного более интересной возможностью является переопределения методов. Виртуальная машина daScript отслеживает наличие зарегистрированных отладочных агентов и передаёт им информацию в ходе выполнения программы — интерфейс <a href="https://github.com/GaijinEntertainment/daScript/blob/62f8b1b2ff4c873c9fc1b7ada61ed332fb349e4c/src/builtin/debugger.das#L10" target="_blank" rel="noopener">DapiDebugAgent</a>.</p><p>Простые примеры определения кастомных debug-агентов:<br><a href="https://github.com/GaijinEntertainment/daScript/blob/685f0415fc1cb2d52ae6c875f702eb7c09862e38/examples/test/misc/logger_and_logger_agent.das" target="_blank" rel="noopener">logger_agent</a> — добавление кастомного префикса при логгировании<br><a href="https://github.com/GaijinEntertainment/daScript/blob/eaa99142af33e7499137c4c7351d02075223cd5b/examples/test/misc/insturment_function.das" target="_blank" rel="noopener">insturment_function</a> — профилирование вызовов функций.<br><a href="https://github.com/GaijinEntertainment/daScript/blob/726d440be7618fb431815b18e6f785c37a335d5d/examples/test/misc/instrument.das" target="_blank" rel="noopener">instrument</a> — программный брейкпоинт и пошаговая трассировка</p><figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">options debugger = <span class="keyword">true</span>    <span class="comment">//настройка контекста для работы с хуками debug-агентов</span></span><br><span class="line">require debugapi           <span class="comment">//интерфейсы для кастомных debug-агентов</span></span><br><span class="line">require rtti               <span class="comment">//получение информации о контексте выполнения (доступные модули/функции/переменные/etc)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//программный брейкпоинт, вызывает хук onBreakpoint в debug-агенте</span></span><br><span class="line">breakpoint</span><br><span class="line"><span class="comment">//устанавливает номер строчки, для которой будет вызван хук onInstrument</span></span><br><span class="line">instrument_node </span><br><span class="line"><span class="comment">//устанавливает режим трассирования, хук onSingleStep будет вызван для каждой строчки выполнения до отключения</span></span><br><span class="line">set_single_step</span><br><span class="line"><span class="comment">//устанавливает фильтр на функции, для которых будет вызван хук onInstrumentFunction </span></span><br><span class="line">instrument_all_functions</span><br><span class="line"><span class="comment">//вызывает хук onLog</span></span><br><span class="line">to_log</span><br><span class="line"><span class="comment">//вызывает хук onCollect</span></span><br><span class="line">collect_debug_agent_state</span><br><span class="line"><span class="comment">//вызывает хук onVariable у установленного DapiStackWalker</span></span><br><span class="line">report_context_state</span><br></pre></td></tr></table></figure><p>Более сложные примеры:<br><a href="https://github.com/GaijinEntertainment/daScript/blob/726d440be7618fb431815b18e6f785c37a335d5d/examples/test/misc/stackwalk.das" target="_blank" rel="noopener">stackwalk</a> — более продвинутая версия <code>instrument</code>, устанавливает кастомный <code>DapiStackWalker</code> и <code>DapiDataWalker</code>, печатает значение локальных переменных на каждом шаге<br><a href="https://github.com/GaijinEntertainment/daScript/blob/66e627465d8aca7934c4b6a92f2fc0d16347c9f7/examples/test/misc/context_state_example.das" target="_blank" rel="noopener">context_state_example</a> — еще немного более полная версия информации о переменных, уже более похожая на информацию для отладчика<br><a href="https://github.com/GaijinEntertainment/daScript/blob/767ebf69143244c544dacdc2efed5a7410940ed5/modules/dasOpenGL/opengl/opengl_state.das" target="_blank" rel="noopener">opengl_state</a> — в хуке onCollect печатает информацию о состояниях OpenGL<br><a href="https://github.com/GaijinEntertainment/daScript/blob/62f8b1b2ff4c873c9fc1b7ada61ed332fb349e4c/daslib/decs_state.das" target="_blank" rel="noopener">decs_state</a> — собирает информацию из модуля <code>decs</code> (entity-component-system)<br><a href="https://github.com/GaijinEntertainment/daScript/blob/62f8b1b2ff4c873c9fc1b7ada61ed332fb349e4c/daslib/ast_debug.das" target="_blank" rel="noopener">ast_debug</a> — информация о состоянии expression tree, для отладки макросов</p><h2 id="Инструмнты-основе-debug-агентов"><a href="#Инструмнты-основе-debug-агентов" class="headerlink" title="Инструмнты  основе debug-агентов"></a>Инструмнты  основе debug-агентов</h2><p>Полноценный <strong><code>отладчик</code></strong> — <a href="https://github.com/GaijinEntertainment/daScript/blob/2695f756b17bc184016ea97973ef143a669a937e/daslib/debug.das" target="_blank" rel="noopener">debug</a> (debug-агент + сервер для связи с IDE) (<a href="https://marketplace.visualstudio.com/items?itemName=profelis.dascript-plugin" target="_blank" rel="noopener">плагин для vscode</a>):<br>(необходимо определить <code>#define DAS_DEBUGGER 1</code> если это по каким-то причинам не определилось в das_config.h автоматически)<br><img src="/blog/3298324261/debugger.png" alt=""></p><p>Более продвинутый <a href="https://borisbat.github.io/dascf-blog/2022/12/11/instruments/" target="_blank" rel="noopener">пример</a> <strong><code>instrument_function</code></strong> — обёртка, сохраняющая результат в файл, который можно посмотреть в виде флеймграфа.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;В заметке про &lt;a href=&quot;/blog/3006126295/&quot; title=&quot;live-режим&quot;&gt;live-режим&lt;/a&gt; для opengl-приложений в daScript я кратко описывал контексты (раздел &lt;code&gt;Архитектура приложения&lt;/code&gt;). Здесь разберу их немного более подробно.&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="dascript" scheme="http://spiiin.github.io/tags/dascript/"/>
    
  </entry>
  
  <entry>
    <title>daScript - мелочи</title>
    <link href="http://spiiin.github.io/blog/1728452067/"/>
    <id>http://spiiin.github.io/blog/1728452067/</id>
    <published>2023-03-05T18:25:54.000Z</published>
    <updated>2023-09-28T09:05:31.632Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Научился читать грамматику для bison, нашёл несколько новых для себя мелочей синтаксиса <a href="https://github.com/GaijinEntertainment/daScript/blob/master/src/parser/ds_parser.ypp" target="_blank" rel="noopener">daScript</a>.<br><a id="more"></a></p><p><strong><code>1. assume</code></strong><br>Аналог <code>#define</code> в си, текстовая подстановка выражений. Со всеми ее минусами.</p><figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">var a = <span class="string">"global_string"</span></span><br><span class="line"></span><br><span class="line">[export]</span><br><span class="line">def main</span><br><span class="line">    assume x = a <span class="comment">//not capture global var a, but only text name</span></span><br><span class="line">    var a = <span class="string">"local string"</span></span><br><span class="line">    x = <span class="string">"changed string"</span> <span class="comment">//change local, but not global a!</span></span><br><span class="line">    print(<span class="string">"&#123;a&#125;\n"</span>)</span><br><span class="line">    print(<span class="string">"&#123;::a&#125;\n"</span>)</span><br><span class="line"><span class="comment">//changed string</span></span><br><span class="line"><span class="comment">//global_string</span></span><br></pre></td></tr></table></figure><p><strong><code>2. =&gt;</code></strong></p><p>Символ стрелки используется для записи коротких блоков/лямбд/безымянных функций:</p><figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">def radd(var ext:int&amp;; b:block&lt;(var arg:int&amp;):int&gt;):int</span><br><span class="line">    <span class="keyword">return</span> invoke(b,ext)</span><br><span class="line">def radd(var ext:int&amp;; b:lambda&lt;(var arg:int&amp;):int&gt;):int</span><br><span class="line">    <span class="keyword">return</span> invoke(b,ext)</span><br><span class="line">def radd(var ext:int&amp;; b:<span class="keyword">function</span>&lt;(var arg:int&amp;):int&gt;):int</span><br><span class="line">    <span class="keyword">return</span> invoke(b,ext)</span><br><span class="line"></span><br><span class="line">[export]</span><br><span class="line">def main</span><br><span class="line">    var x = <span class="number">0</span></span><br><span class="line">    radd(x, $(a) =&gt; a++) </span><br><span class="line">    radd(x, @(a) =&gt; a++)</span><br><span class="line">    radd(x, @@(a) =&gt; a++) </span><br><span class="line">    print(<span class="string">"&#123;x&#125;\n"</span>)</span><br><span class="line">    <span class="comment">//Output: 3</span></span><br></pre></td></tr></table></figure><p>А также для записи создания кортежей и таблиц:</p><figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">var x &lt;- [[auto <span class="number">1</span>=&gt;<span class="string">"one"</span>]] <span class="comment">//работает также в массивах [[auto 1=&gt;"one"; 2=&gt;"two"]]</span></span><br><span class="line">print(<span class="string">"&#123;x&#125; &#123;typeinfo(typename x)&#125;\n"</span>)</span><br><span class="line"><span class="comment">//[[ 1; one]] tuple&lt;int;string&gt; - кортеж</span></span><br><span class="line">var y &lt;- &#123;&#123; <span class="number">1</span>=&gt;<span class="string">"one"</span>&#125;&#125;</span><br><span class="line">print(<span class="string">"&#123;y&#125; &#123;typeinfo(typename y)&#125;\n"</span>)</span><br><span class="line"><span class="comment">//[[ 1 : one]] table&lt;int;string&gt; - таблица</span></span><br></pre></td></tr></table></figure><p><strong><code>3. auto для инициализации</code></strong></p><p>auto при инициализации может выводить тип массивов (статических и динамических) и кортежей. Для структур — не может</p><figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">def printType(a) &#123; print(<span class="string">"&#123;typeinfo(typename a)&#125;\n"</span>); &#125;</span><br><span class="line">printType([[auto <span class="number">1</span>=&gt;<span class="number">2</span>]]) <span class="comment">//tuple&lt;int;int&gt; const</span></span><br><span class="line">printType([[auto <span class="number">1</span>,<span class="number">2</span>]])  <span class="comment">//tuple&lt;int;int&gt; const</span></span><br><span class="line">printType([[auto <span class="number">1</span>;<span class="number">2</span>]])  <span class="comment">//int const[2]</span></span><br><span class="line">printType([&#123;auto <span class="number">1</span>;<span class="number">2</span>&#125;])  <span class="comment">//array&lt;int&gt; const</span></span><br></pre></td></tr></table></figure><p><strong><code>4. сокращенная запись при обьявлении переменных ссылочных типов</code></strong><br><figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> ar&amp; = a <span class="comment">//let ar: int&amp; = a</span></span><br></pre></td></tr></table></figure></p><p><strong><code>5. if после выражений</code></strong><br>Условие может стоять после определённых выражений (с опциональной веткой else):</p><figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">def <span class="keyword">fun</span></span><br><span class="line">    print(<span class="string">"1"</span>) <span class="keyword">if</span> <span class="keyword">true</span> <span class="keyword">else</span> print(<span class="string">"2"</span>)  <span class="comment">//expr if</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">true</span></span><br><span class="line">        break <span class="keyword">if</span> <span class="keyword">true</span> <span class="keyword">else</span> continue <span class="comment">//break if</span></span><br><span class="line">        continue <span class="keyword">if</span> <span class="keyword">false</span> <span class="comment">//continue if</span></span><br><span class="line">    <span class="keyword">return</span> &lt;- generator&lt;int&gt;() &lt;| $() </span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">10</span>)</span><br><span class="line">            <span class="keyword">yield</span> t <span class="keyword">if</span> <span class="keyword">true</span> <span class="comment">//yield if</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span> <span class="keyword">if</span> <span class="keyword">true</span> <span class="comment">//return if</span></span><br></pre></td></tr></table></figure><p><strong><code>6. aka</code></strong><br>Синоним для имени переменной (как намного менее “злобный” вариант <code>assume</code>)<br><figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">var a aka b: int</span><br><span class="line">b = <span class="number">1</span></span><br><span class="line">print(<span class="string">"&#123;a&#125;\n"</span>) <span class="comment">//1</span></span><br></pre></td></tr></table></figure></p><p><strong><code>7. expect</code></strong></p><p>Ключевое слово для тестового фреймворка <a href="https://borisbat.github.io/dascf-blog/2023/02/25/wake-up-and-test-the-damn-thing/" target="_blank" rel="noopener">dasTest</a><br><figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">expect <span class="number">10003</span>:<span class="number">1</span>, <span class="number">20000</span>:<span class="number">1</span></span><br><span class="line"><span class="comment">//ожидается по одной ошибке компилятора типа 10003 и 20000 (незакрытая кавычка и неожиданный конец файла)</span></span><br><span class="line">[export]</span><br><span class="line">def test</span><br><span class="line">    print(<span class="string">"ok</span></span><br></pre></td></tr></table></figure><br>Для запуска теста нужно вызвать скрипт <a href="https://github.com/GaijinEntertainment/daScript/tree/master/dastest" target="_blank" rel="noopener">dastest</a> и передает в параметре <code>test</code> имя скрипт для тестирования (или директории с группой скриптов):<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">daScript dastest.das -- --test my_test.das</span><br></pre></td></tr></table></figure></p><p><strong><code>8. named arguments</code></strong></p><p>Функцию можно вызвать с <a href="https://dascript.org/doc/reference/language/functions.html?highlight=named#named-arguments-function-call" target="_blank" rel="noopener">явными именами</a> аргументов.</p><figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">def foo(a:int=<span class="number">13</span>; b: int)</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">foo([b = <span class="number">2</span>])  <span class="comment">// same as foo(13, 2)</span></span><br></pre></td></tr></table></figure><p>Также можно скомбинировать первые неименованные аргументы, или вызов через пайп:</p><figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">def func(a:int; b=<span class="number">1</span>; c=<span class="number">2</span>)</span><br><span class="line">  pass</span><br><span class="line"></span><br><span class="line">func([a=<span class="number">0</span>, c=<span class="number">2</span>]    <span class="comment">//ok</span></span><br><span class="line">func(<span class="number">0</span>, [c=<span class="number">2</span>])   <span class="comment">//error</span></span><br><span class="line"><span class="number">0</span> |&gt; func([c=<span class="number">2</span>]) <span class="comment">//error</span></span><br></pre></td></tr></table></figure><p><a href="https://github.com/GaijinEntertainment/daScript/blob/master/tests/language/named_call.das" target="_blank" rel="noopener">Больше примеров</a>. Логика выбора — именованные аргументы применяются после неименованных и могут “перекрывать” их.</p><p><strong><code>9. with</code></strong></p><p><a href="https://dascript.org/doc/reference/language/classes.html?highlight=class#implementation-details" target="_blank" rel="noopener">with</a> позволяет внутри блока обращаться к полям структуры без явного указания её имени:</p><figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> S</span><br><span class="line">    a, b: int</span><br><span class="line"></span><br><span class="line">var s = [[S a=<span class="number">1</span>, b=<span class="number">2</span>]]</span><br><span class="line"><span class="keyword">with</span> s</span><br><span class="line">    print(<span class="string">"&#123;a&#125;, &#123;b&#125;\n"</span>) <span class="comment">//s.a, s.b</span></span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Научился читать грамматику для bison, нашёл несколько новых для себя мелочей синтаксиса &lt;a href=&quot;https://github.com/GaijinEntertainment/daScript/blob/master/src/parser/ds_parser.ypp&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;daScript&lt;/a&gt;.&lt;br&gt;
    
    </summary>
    
    
    
      <category term="dascript" scheme="http://spiiin.github.io/tags/dascript/"/>
    
  </entry>
  
  <entry>
    <title>Книги и курсы</title>
    <link href="http://spiiin.github.io/blog/1567638407/"/>
    <id>http://spiiin.github.io/blog/1567638407/</id>
    <published>2023-02-25T14:07:24.000Z</published>
    <updated>2023-03-04T18:25:31.727Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>В январе, перед переходом на новую работу, успел немного почитать. Ориентировался на список из старого <a href="https://dtf.ru/gamedev/470-gaijin-interview" target="_blank" rel="noopener">интервью</a> А. Юдинцева</p><p><strong><code>Пенроуз Р. &quot;Новый ум короля&quot;</code></strong><br>Взгляд физика и математика Пенроуза из 1989 на искусственный интеллект. Пролистал бегло часть про математику, физику почти пропустил. Основная идея начала — сознание неалгоритмично, и часто неформализуемо. Плюс гипотеза о том, что раз мы еще не нашли объяснения сознания там, где искали, оно может быть спрятано там, где еще искали плохо.<br>Кажется, в книге не рассматривается, а скорее и отрицается эмерджентность, свойство возникновения нового уровня организации из более примитивных элементов. Хотя Пенроуз подходит к этому феномену в описании существования кристаллов с непериодической решеткой, математически описанных им самим (<a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%BE%D0%B7%D0%B0%D0%B8%D0%BA%D0%B0_%D0%9F%D0%B5%D0%BD%D1%80%D0%BE%D1%83%D0%B7%D0%B0" target="_blank" rel="noopener">мозаика Пенроуза</a>), для построения которых необходимо “знать” о том, как будет организована далеко отстоящая часть структуры.</p><p>Наверное, интересно для любителей истории развития идей про искусственный интеллект. Когда-то также бегло просматривал книги Минского <code>&quot;Вычисления: конечные и бесконечные машины&quot;</code> и <code>&quot;Общество разума&quot;</code>, но не особо связаны с тем, чем я занимаюсь, поэтому не вникал в них детально.</p><p>Одна из глав посвящена также фракталам, но про них лучше почитать отдельно у Мандельброта в <code>&quot;Фракталы и хаос&quot;</code> (тоже просматривал бегло), до этой книги почему-то считал их скорее математической диковинкой, чем структурой для описания объектов природы.</p><p>Собственно, разобрал только <a href="https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D0%BE%D1%80%D0%B5%D0%BC%D0%B0_%D0%93%D1%83%D0%B4%D1%81%D1%82%D0%B5%D0%B9%D0%BD%D0%B0" target="_blank" rel="noopener">теорему Гудстейна</a>, так как она связана с теоремой Гёделя о неполноте, которую очень часто любят упоминать по поводу и без. Разбор теоремы:<br>ЖЖ avva:<br><a href="https://avva.livejournal.com/244874.html" target="_blank" rel="noopener">Геркулес и гидра</a><br><a href="https://avva.livejournal.com/245918.html" target="_blank" rel="noopener">Геркулес и гидра (решение)</a><br><a href="https://avva.livejournal.com/248899.html" target="_blank" rel="noopener">Геркулес и гидра (что такое ординалы)</a><br>Канал маткульт-привет:<br><a href="https://www.youtube.com/watch?v=IS_PazHA2_0" target="_blank" rel="noopener">Теорема Гудстейна. Введение</a><br><a href="https://www.youtube.com/watch?v=0WLmiejT9vM" target="_blank" rel="noopener">Теорема Гудстейна. Формулировка</a><br><a href="https://www.youtube.com/watch?v=0SoydsEr0OA" target="_blank" rel="noopener">Теорема Гудстейна. Введение в ординалы</a><br><a href="https://www.youtube.com/watch?v=dEx5xlB9PTc" target="_blank" rel="noopener">Теорема Гудстейна. Доказательство и заключение</a></p><p>Интересно скорее для математиков, на любительский взгляд выглядит просто как определение набора правил, как именно можно оперировать неизвестными заранее, но конечными числами</p><p><strong><code>Прайор К. &quot;Не рычите на собаку&quot;</code></strong><br>Книга о практических методах дрессировки животных и людей, не делающая значительных отличий между ними. Собственно, все методы практичны, из серии “бери и делай”.</p><p>Когда-то увлекался популярными книгами про языки животных — <a href="/blog/14110/" title="Джон Лилли. Человек и Дельфин.">Джон Лилли. Человек и Дельфин.</a>. Недавно читал также про язык муравьев в <code>&quot;Планете муравьев&quot;</code> и <code>&quot;Superorganism&quot;</code> Уилсона.<br><a href="https://galicarnax.livejournal.com/39260.html" target="_blank" rel="noopener">Биосемиотика: молекулярные коды как основа жизни</a> — наука о том, что жизнь основана на знаках и кодах, а эволюция связана с возникновением новых систем кодирования. Наверное, если бы не занимался геймдевом, занимался б биоинформатикой.</p><p><strong><code>Даймонд Дж. &quot;Ружья, микробы и сталь&quot;</code></strong><br><a href="https://kobak.livejournal.com/73007.html" target="_blank" rel="noopener">Краткий конспект</a> содержания книги. Автор связывает развитие цивилизаций с экологическими условиями, в которых они оказывались. Сложнопроверяемо, но много интересных фактов. Похожие книги, про политические системы — <code>&quot;Почему одни страны богатые, а другие бедные&quot;</code> и <code>&quot;Русская модель управления&quot;</code> (хотя тут больше притягиваний фактов).</p><p><strong><code>Чалдини Р. &quot;Психология влияния&quot;</code></strong><br>Как и Доккинза, читал раньше. Считаю методы из Чалдини, Ариели, Канемана и Талера необходимыми и обязательными во фреймворке гейм-дизайнера (особенно для free-to-play) — <a href="/blog/3649678047/" title="Путь гейм-дизайнера">Путь гейм-дизайнера</a></p><p><strong><code>Курс лекций: &quot;Наукоёмкий подход к кулинарии&quot;</code></strong> [<a href="https://www.youtube.com/playlist?list=PLXOrZPAO2Ui021R3sKD5z0n9Qzeix9Kbj" target="_blank" rel="noopener">ссылка</a>]<br>Колоссальное количество фактов о кулинарии и способах приготовления еды. Лекции не о том, как правильно готовить, а о том, что можно в принципе делать с едой. Хорошо идёт в дополнении с книгой <code>Вкус</code> Боба Холмса.</p><p><strong><code>Системное программирование. Лаборатория Tarantool</code></strong> [<a href="https://www.youtube.com/playlist?list=PLrCZzMib1e9pOdLmE2qtMgL3QMEIrxyu7" target="_blank" rel="noopener">ссылка</a>]<br>Введение в Linux, вместе с книгой Таненбаума <code>&quot;Современные операционные системы&quot;</code> позволяет понять ос настолько, чтобы разбираться в более продвинутых материалах.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;В январе, 
      
    
    </summary>
    
    
    
      <category term="книги" scheme="http://spiiin.github.io/tags/%D0%BA%D0%BD%D0%B8%D0%B3%D0%B8/"/>
    
      <category term="link" scheme="http://spiiin.github.io/tags/link/"/>
    
  </entry>
  
  <entry>
    <title>Немного о проектировании</title>
    <link href="http://spiiin.github.io/blog/1337028819/"/>
    <id>http://spiiin.github.io/blog/1337028819/</id>
    <published>2023-02-19T11:40:56.000Z</published>
    <updated>2023-04-04T20:59:17.300Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Дамп мыслей про проектирование систем, как обычно, с уклоном в геймдев.<br><a id="more"></a></p><h2 id="Cohesion-and-Coupling"><a href="#Cohesion-and-Coupling" class="headerlink" title="Cohesion and Coupling"></a>Cohesion and Coupling</h2><p><a href="https://en.wikipedia.org/wiki/Cohesion_(computer_science%29" target="_blank" rel="noopener">Cohesion</a> — степень смысловой связи между сгруппированными элементами (функциями в классе или модуле).<br><a href="https://en.wikipedia.org/wiki/Coupling_(computer_programming%29" target="_blank" rel="noopener">Coupling</a> — степень запутанности связи между модулями.</p><p><img src="/blog/1337028819/coupling_small.png" alt=""><br>Хороший вариант дизайна — высокая cohesion и низкая coupling.</p><p>Примеры модулей, в которых скорее всего окажется <code>низкий cohesion</code>:</p><ul><li>Utils - сгруппировано все небольшие функции</li><li>GameObject - в котором при ООП дизайне рано или поздно собирается весь функционал, который может потребоваться потомкам (анти-паттерны GodObject/Blob)</li></ul><p>Примеры модулей, которые скорее всего могут быть связаны с другими (<code>высокий coupling</code>) - системы логгирования, профилирования.<br>Подсистемы также связываются на уровне реализации игровой логики — звук шагов задействует подсистемы анимации, звука, физики. Сильно лучше, если подсистемы связаны не между собой, а на отдельном слое связывания.</p><h2 id="Компоненты"><a href="#Компоненты" class="headerlink" title="Компоненты"></a>Компоненты</h2><p>Для подсистем с высокой cohesion и низкой coupling встречается название <strong><code>компоненты</code></strong>, за счет того, что они изолированы друг от друга и могут переиспользоваться.<br>Один из приемов проектирования — строить программу из компонентов.</p><p>Между слоем компонентов и логики приложения могут лежать и промежуточные слои библиотек:</p><p><img src="/blog/1337028819/components_levels_small.png" alt=""><br><em>(картинка из книги John Lacos - Large-Scale C++ )</em></p><p>Однако при этом часто на среднем уровне библиотека не оформлена в виде компонентов или даже компоненты на спроектированы так, чтобы использоваться вне библиотеки очень высокого уровня.</p><p>Примеры библиотек:<br>В которых сложно “оторвать компоненты” для использования вне библиотеки (в плане coupling, иногда заниматься отрыванием может мешать и лицензия библиотеки): <code>Qt</code><br>Средний уровень сложности: <code>boost</code> (зависит от конкретной библиотеки, некоторые отрываются неплохо, некоторые тянут за собой в зависимостях половину библиотеки), <code>entt</code> (для примера — оторвать basic_sparse_set/basic_storage можно, но требует усилий)<br>Легко отделить компоненты: <a href="https://github.com/tamasmeszaros/libnest2d" target="_blank" rel="noopener">libnest2d</a> - надстроена над <code>clipper/nlopt/boost.geometry</code>, вполне позволяет подменить любую из этих библиотек</p><h2 id="Software-Capital"><a href="#Software-Capital" class="headerlink" title="Software Capital"></a>Software Capital</h2><p><a href="https://youtu.be/ta3S8CRN2TM?t=572" target="_blank" rel="noopener">CppCon 2016: David Sankel “Building Software Capital: How to write the highest quality code and why”</a> — software capital как противоположность техническому долгу.</p><p>Необходимые условия для создания software capital:</p><p><code>Code review</code></p><ul><li>позволяет получить не только собственную оценку качества кода</li><li>поиск багов</li><li>проверка соотвествия стандартам компании (взаимодействие позволяет создать стандарты!)</li><li>социализация -&gt; распространение знаний</li><li>отчётность качества кода - проверка наличия документации, юнит тестов, отвественность за код на двух людях</li></ul><p>О ревью кода часто говорят, но мало кто делает полноценно. У автора есть ещё несколько докладов на тему того, как бороться с менеджерами, которые запрещают не пропускать плохой код. Основной аргумент для менеджеров — “мы знаем, что данные правила позволяют уменьшить time to market в перспективе”. Не пропускать плохой код в мастер, иначе он там и останется (технический долг — антипод sofware capital). Каждый коммит должен проходить ревью.</p><p><em>Интересно проверить на практике, насколько эта идея работает</em></p><p><code>Стандарты</code><br>(форматирование, идиомы, организация компонентов, лучшие практики, требования к документации)</p><ul><li>уменьшение вариативности даёт увеличение продуктивности</li><li>профессионализм</li><li>чем более похожа структура, тем проще навигация</li><li>и обработки кода тулзами (clang-format, refactor, codegen)</li></ul><p><code>Unit testing</code></p><ul><li>безопасный рефакторинг</li><li>ранее вычищение некоторых багов</li><li>хинты: для gui — modularized gui, для io - dependency injections, против “i need ship” - код должен иметь тесты, чтобы пройти код-ревью!, против “я знаю что код работает” — нам нужно уметь поймать момент, когда из-за изменений в ходе добавления других фич он сломается. Требует CI.</li></ul><p><code>Контракты</code></p><ul><li>Спецификация ожидаемого поведения (in/out), не деталей реализации</li><li>Позволяет абстрагироваться от реализации, экономит время</li><li>Плохие интерфейсы видны по их контрактам</li><li>Подсказка для того, как написать unit-тесты</li></ul><p><em>Я не встречал, чтобы это применяли на практике</em></p><p><code>Хорошие интерфейсы</code></p><ul><li>форма искусства</li><li>простые контракты</li><li>управляемые части</li><li>организация кода: разделение на уровни “компонент/пакет/группа пакетов”. Функции класса, не требующие доступа к приватным членам отделяются в ClassUtil</li><li>не должно быть взаимных зависимостей между двумя компонентами</li></ul><p><code>Инновации</code></p><ul><li>инновации имеют стоимость - code rot (существующий код становится устравшим), добавление сложности</li><li>плата - освоение книг, курсов, конференции</li></ul><p><code>Инфраструктура</code></p><ul><li>vcs, ci, build system, core libraries, standards</li><li>кто-то должен отвечает за всю картину, эта задача требует высокой квалификации</li></ul><p><em>неочевидное свойство software capital — новые разработчики обязаны отказываться от своих привычек программирования и используемых инструментов, и переходить/изучать то, что использует и создала компания</em></p><h2 id="Зависимости-от-компонентов-и-свойства-API"><a href="#Зависимости-от-компонентов-и-свойства-API" class="headerlink" title="Зависимости от компонентов и свойства API"></a>Зависимости от компонентов и свойства API</h2><p>По субъективному опыту — для open-source библиотек можно найти качественные компоненты более “низкого” уровня (то, что можно забросить в 3rdPartyLibs), библиотеки среднего уровня чаще всего (если не считать движения свободного кода) — проприетарная собственность компаний (1stPartyLibs), так как требуют серьёзного уровня поддержки, который сложно поддерживать небольшой группе разработчиков, а также могут быть заточены под нужды конкретной компании. В Large-Scale C++ такие компоненты, накопленные компаниями, упоминаются, как <code>software capital</code>. Большие open-source библиотеки компонентов часто появляются как открытие накопленного корпорацией software capital (<code>abseil</code>, <code>folly</code>).</p><p>Еще одно интересное свойство компонент, которое влияет на простоту их использования — компактность их API. Так как библиотеки “среднего” уровня могут быть достаточно объёмными, Эрик Реймонд в книге “Искусство программирования для UNIX” вводит термин <code>полукомпактность</code> для систем, которые позволяет решать с их помощью большинство задач, используя только небольшую и наиболее используемую компактную часть их API. В качестве примеров полукомпактных систем он приводит <code>html</code> или язык <code>c</code> (не c++).</p><p><a href="https://www.youtube.com/watch?v=ZQ5_u8Lgvyk" target="_blank" rel="noopener">Designing and Evaluating Reusable Components - 2004</a> — доклад Casey Muratori (соавтор библиотек <a href="http://www.radgametools.com/granny.html" target="_blank" rel="noopener">Granny 3D</a>, которая изолирует нижний уровень компонет - “лист” на графе), про дизайн компонентов и виды зависимостей, которые они могут добавлять на уровне, который их использует. На скриншоте с графом уровней компонент выше рёбра — это абстрактное “использование” компонент, доклад разбирает виды и характеристики этих соединений.</p><p><img src="/blog/1337028819/reuse_small.png" alt=""></p><p>Свойства API:</p><p><code>Разделяемость (Granularity)</code><br>Возможность установить/изменить параметры за несколько вызовов — вставить действие между между ними.<br>Гибкость VS простота</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Orientation = GetOrientation(Object)</span><br><span class="line">Change = GetOrientationChange(Object)</span><br><span class="line">Change += <span class="number">3.14f</span>                <span class="comment">//</span></span><br><span class="line">RunSomeOtherUnrelatedTthing()  <span class="comment">// возможность поменять отложенно</span></span><br><span class="line">SetOrientation(Object, Orientation + Change)</span><br></pre></td></tr></table></figure><p><code>Избыточность (Redundancy)</code><br>Возможность выполнить действия несколькими способами<br>Удобство VS ортогональность</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//установка направления с помощью матрицы</span></span><br><span class="line">SetOrientation3x3(Object, Matrix)</span><br><span class="line"><span class="comment">//то же самое с помощью кватерниона</span></span><br><span class="line">SetOrientationQ(Object, Quat)</span><br><span class="line"><span class="comment">//то же самое с помощью заготовленных разработчиками методов/констант</span></span><br><span class="line">IdentityOrientation(Object)</span><br><span class="line">FaceForward(Object)</span><br></pre></td></tr></table></figure><p><code>Cвязанность (Coupling)</code><br>Зависимости между частями системы (почти всегда плохо, не часто неизбежно)<br>Несвязанность VS запутанность (<a href="https://www.youtube.com/watch?v=SxdOUGdseq4 -- более детально" target="_blank" rel="noopener">“Simple Made Easy” - Rich Hickey (2011)</a>)</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//неразделяемый апдейт всего (к примеру, физики)</span></span><br><span class="line">UpdateEverything(World)</span><br><span class="line"></span><br><span class="line"><span class="comment">//нужно установить состояние, прежде чем сделать что-то,</span></span><br><span class="line"><span class="comment">//  возможно скрыто</span></span><br><span class="line">SetTime(GlobalTime) </span><br><span class="line">UpdateObject(Object)</span><br><span class="line"></span><br><span class="line"><span class="comment">//возможность настройки только внутри пары вызовов</span></span><br><span class="line"><span class="comment">// часто подразумевает "не должно быть вложенности"</span></span><br><span class="line">BeginObjectSpecification()</span><br><span class="line">SetObjectState(Param1, Value1)</span><br><span class="line">Object = EndObjectSpecification()</span><br><span class="line"></span><br><span class="line"><span class="comment">//Использование скрытого общего буфера</span></span><br><span class="line"><span class="comment">// на который могут указывать String1 и String2</span></span><br><span class="line">String1 = GetMungedName(Name1)</span><br><span class="line">String2 = GetMungedName(Name2)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Нельзя сказать "у меня уже есть выделенная память, на которой нужно построить объект"</span></span><br><span class="line"><span class="comment">// или "выдели объект, но я инициализирую его, у меня кастомные инициализаторы из архивов"</span></span><br><span class="line">Object = AllocateAndInitialize()</span><br><span class="line"></span><br><span class="line"><span class="comment">//нужно обязательно создавать кастомный тип, хотя клиент может иметь тип для представления</span></span><br><span class="line"><span class="comment">// пример - QString для апи QT</span></span><br><span class="line">Matrix = MakeMatrixFrom(FloatPointer)</span><br><span class="line">SetOrientation(Object, Matrix)</span><br><span class="line"></span><br><span class="line"><span class="comment">//связь с форматом файла, нельзя создать самому,</span></span><br><span class="line"><span class="comment">//  зависимость от формата и I/O функций</span></span><br><span class="line">Object = ReadObject(filename)</span><br></pre></td></tr></table></figure><p><code>Запоминание (Retention)</code><br>Сохранение переданной ранее информации<br>Ведет к дублирование описания мира “внутри” библиотеки и в пользовательском коде<br>Сложность синхронизации состояний (комбинаторный рост от количества параметров) VS автоматизация работы после настройки</p><p>Immediate mode API (<a href="https://github.com/ocornut/imgui" target="_blank" rel="noopener">imgui</a> как пример) — одна из идея отказа от запоминания</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Настройка значений, которые повлияют на последующие вычисления</span></span><br><span class="line">SetTime(GlobalTime)</span><br><span class="line">SetPi(<span class="number">3.14f</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//изменение положение потомка также зависит от родителя</span></span><br><span class="line">SetParent(ChildObject, ParentObject)</span><br><span class="line">UpdateOrientation(ChildObject)</span><br></pre></td></tr></table></figure><p>Возможно, к “запоминанию” состояния можно отнести также некоторые идеи, которые предлагаются паттернами и парадигмами программирования:</p><ul><li>Асинхронное программирование с запоминанием точек продолжения программы (async/await)</li><li>Реактивное программирование, с запоминаем настроенных потоков данных</li><li>Декларативное программирование, с выполнением кода на какой-либо настроенной или заполненной ранее модели/системе</li></ul><p>В системах, в которых настройка может осуществляться гибко, императивное описание может быть лучше декларативного — явно указываем последовательность операций вместо того, чтобы извращаться с тем, чтобы оставалась возможность точно настроить декларативное описание.</p><p>Примеры:</p><ul><li>Декларативные системы сборки в Java Ant и Maven проиграли императивному способу gradle.</li><li><a href="https://github.com/spiiin/CadEditor/tree/master/CadEditor/settings_nes" target="_blank" rel="noopener">CadEditor</a> — мой редактор уровней для NES игр. “Стандартный” путь для редакторов уровней — декларативные конфигурационные файлы. Императивный — скриптовый язык, позволяющий описать, как загружать уровни, за счёт чего можно добавлять в редактор сотни игр, несильно отличающихся между собой, но всё же отличающихся настолько, что сложно предугадать в декларативной системе заранее.</li></ul><p><code>Порядок вызовов (Flow Control)</code><br>Вызывает ли библиотека колбеки приложения или приложение функции библиотеки (и зовут ли функции библиотеки колбеки из приложения). Чем чаще необходимо осуществлять передачу управления, тем сложнее отслеживать это пользователю библиотеки.<br>Контроль на стороне приложения (почти всегда лучше) VS на стороне библиотеки</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Для открытия файла будет вызван колбек Open</span></span><br><span class="line">SetFileCallbacks(Open, Read, Close)</span><br><span class="line">File = OpenFile(Filemame)</span><br><span class="line"></span><br><span class="line"><span class="comment">//То же самое, но спрятано за ООП,</span></span><br><span class="line"><span class="comment">// где-то скрыто сохранён указатель на функцию открытия</span></span><br><span class="line">class MyHandler: <span class="keyword">public</span> LibraryHandler &#123;</span><br><span class="line">  <span class="keyword">virtual</span> <span class="keyword">void</span> Open(<span class="keyword">char</span>* Filename)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Ещё про свойства библиотек — <a href="/blog/1152347544/" title="Хорошие библиотеки">Хорошие библиотеки</a></p><h2 id="Копирование-лучших"><a href="#Копирование-лучших" class="headerlink" title="Копирование лучших"></a>Копирование лучших</h2><p>Вместо написания чего-то с нуля нужно использовать или копировать лучших (смысл не пользоваться накоплненным software capital?).</p><ul><li>Черновая реализация на несколько оптимизаций отстает от оптимальной</li><li>Часто оптимальная может так сильно отличаться от наивной, что переделать станет сложно/невозможно</li><li>Для понимания оптимальной версии может потребоваться больше времени, и знаний для сравнения, чем для написания наивной</li></ul><p>Кроме оптимизаций, готовый код содержит фиксы множества ошибок, найденные за время его использования. Джоэл Спольски в эссе <a href="https://www.joelonsoftware.com/2000/04/06/things-you-should-never-do-part-i/" target="_blank" rel="noopener">Things You Should Never Do</a> расписывает печально известную проектировщикам истину — простой код, написанный с чистого листа, сильно отстаёт от давно написанного сложного, но отлаженного.</p><p>При этом копирование плохо работает в чём-то, отличном от кода. <a href="https://vadzimv.dev/2020/03/07/childs-illusions.html" target="_blank" rel="noopener">Книжки не заменяют опыта</a>, но обещают успех в случае повторения внешних признаков (чтобы понять границы применимости общих техник, необходимо колоссальное количество опыта).</p><p><code>Создание инструментов</code></p><p>Использование и создание лучших инструментов даёт <a href="https://borisbat.github.io/dascf-blog/2023/03/20/a-matter-of-multipliction/" target="_blank" rel="noopener">мультипликативный эффект</a>.</p><p>Раздел “Инструменты” — <a href="/blog/3652741154/" title="10 лет в геймдеве">10 лет в геймдеве</a></p><p><em>Примеры инструментов для профилирования программ на C++</em></p><p>Изучение memory layout для C++-структур — <a href="/blog/1170009669/" title="Расположение объектов C++ в памяти. Часть 2">Расположение объектов C++ в памяти. Часть 2</a><br>Отображение информации от профайлера xcode (cpu и memory) и xperf в виде флеймграфа — <a href="/blog/2526702897/" title="Flamegraph. Windows&#x2F;iOS&#x2F;Android">Flamegraph. Windows&#x2F;iOS&#x2F;Android</a></p><p>Новый инструмент для создания кода (и не только) сейчас — нейронные сети.</p><h2 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h2><p><strong><code>Data oriented</code></strong></p><ul><li>сначала кажется непривычным</li><li>так как (в случае, если мы думаем о локальности данных в памяти) подстраивается под данные, иногда требует дублирования кода под новые данные<br>(редко встречается достаточно генерик код, который может работать с кастомными структурами)</li><li>когда подстроишься под то, чтобы думать о расположении данных в памяти, становится сильно проще</li></ul><blockquote><p>Архитектура - это искусство проектировать и конструировать структуры</p><footer><strong>Sean Parent</strong></footer></blockquote><p>В геймдеве часто производительность имеет значение:</p><ul><li>там где ограниченные ресурсы - <a href="http://ru.esotericsoftware.com/" target="_blank" rel="noopener">Spine</a>-анимации для мобильных игр начинают тормозить уже на тех телефонах, но которых запускается Fortnite, при этом разработчиков не особо волнует эта проблема. <a href="https://youtu.be/rX0ItVEVjHc?t=4645" target="_blank" rel="noopener">Ответ</a> Mike Acton на позицию “We want not care about this stuff” - “из-за вас я должен ждать 2 минуты, пока открывается word”.</li><li>там где конкуренция, кто может выдать круче результат (точнее рассчёт физики, освещения, анимаций, ии)</li><li>там где платишь за сервера. <a href="https://youtu.be/KxQpDIKwGUw?t=2399" target="_blank" rel="noopener">Ответ</a> Максима Барышникова про то, зачем WoT сохраняется поддержка распределенных между серверами арен — на одном сервере помещается 3 арены, но за счёт того, что движок поддерживает разбиение, можно разместить 7 арен на 2х серверах (по 3.5 на сервер), а не на 3х, плюс можно динамически балансировать рассчёты, если все 4 арены одновременно становятся максимально нагруженными.</li></ul><p><strong><code>Performance if a feature</code></strong></p><ul><li>там где количество может переходить в качество, давать новые фичи. Например, без оптимизаций можем сделать RTS, в которых у игрока будет только 100 юнитов, а оптимизациями - как 100, так и 10000 - геймдизайнеры могут сделать фичей огромные армии, или более быстрая обработка позволяет “запихнуть” в освободившееся время ещё что-нибудь интересное.</li></ul><p>Кроме производительности конечной программы, немаловажно <strong><code>время сборки/пересборки и производительность дебажного билда</code></strong> (отлаживать не небажный билд добровольно — не очень весело).</p><p><a href="https://aras-p.info/blog/2018/12/28/Modern-C-Lamentations/" target="_blank" rel="noopener">“Modern” C++ Lamentations</a> — важная и большая статья о состоянии этого в современном C++ с большим количеством ссылок и сравнениями (<em>серьёзно, тот случай, когда стоит изучить каждую ссылку из статьи</em>). Кто-то пишет на ограниченном С++ (<code>Orthodox C++</code>), переучивая коллег и новичков, кто-то выбирает и создаёт альтернативные библиотеки (<code>EASTL</code>), кто-то переходит на другие языки (<code>Rust, Jai, Burst C#, daScript</code>).</p><ul><li><a href="/blog/1728194429/" title="С++ в геймдеве">С++ в геймдеве</a> — мой обзор применения C++ для разработки игр</li></ul><p><a href="https://www.youtube.com/watch?v=NAVbI1HIzCE" target="_blank" rel="noopener">Practical Optimizations</a> — доклад Jason Booth c измерениями производительности DoD кода. Важный тезис — <strong><code>optimization is a DESIGN time problem</code></strong>. Если не организовать данные в памяти сразу, переделать будет сложно. В докладе есть нестандартные примеры оптимизаций.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Дамп мыслей про проектирование систем, как обычно, с уклоном в геймдев.&lt;br&gt;
    
    </summary>
    
    
    
      <category term="dev_method" scheme="http://spiiin.github.io/tags/dev-method/"/>
    
      <category term="dev_evolution" scheme="http://spiiin.github.io/tags/dev-evolution/"/>
    
  </entry>
  
</feed>
