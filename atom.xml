<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Spiiin&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://spiiin.github.io/"/>
  <updated>2022-05-30T13:00:51.332Z</updated>
  <id>http://spiiin.github.io/</id>
  
  <author>
    <name>spiiin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>daScript: C++ bindings</title>
    <link href="http://spiiin.github.io/blog/4090909622/"/>
    <id>http://spiiin.github.io/blog/4090909622/</id>
    <published>2022-05-30T10:36:23.000Z</published>
    <updated>2022-05-30T13:00:51.332Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Ещё один “подход” к языку daScript от Gaijin. В последней заметке про использование <a href="/blog/4232971949/" title="байндингов к OpenGL">байндингов к OpenGL</a> в daScript, я упоминал про наличие скрипта <a href="https://github.com/GaijinEntertainment/daScript/issues/231" target="_blank" rel="noopener">dasClangBind</a>, позволяюшего генерировать байндинги к библиотекам на C и C++. Так как из документации к скрипту только совет автора <code>Use it, abuse it</code>, то неплохо попробовать его в деле, чтобы разобраться, что он умеет/не умеет.</p><p>С помощью этого генератора байндингов сделаны обёртки над: <a href="https://github.com/VasiliyRyabtsev/dasRequests" target="_blank" rel="noopener">dasRequests</a>, <a href="https://github.com/VasiliyRyabtsev/dasPhys2d" target="_blank" rel="noopener">dasPhys2d</a>, а также добавленные в основной репозиторий <strong><code>dasGLFW, dasBGFX, dasImgui, dasOpenGL, dasClangBind</code></strong> (привязки для генератора байндингов тоже сгенерированы им самим).</p><p><code>dasClangBind</code> не собирается с дефолтными настройками cmake, поэтому сначала необходимо включить его сборку. В файле <a href="https://github.com/GaijinEntertainment/daScript/blob/master/modules/dasClangBind/CMakeLists.txt" target="_blank" rel="noopener">CMakeLists.txt</a> видим настройку пути с <code>libclang</code>:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET(PATH_TO_LIBCLANG $&#123;PROJECT_SOURCE_DIR&#125;&#x2F;..&#x2F;libclang)</span><br></pre></td></tr></table></figure></p><p>Можно скачать скомпилированные библиотеки <a href="https://github.com/llvm/llvm-project/releases/tag/llvmorg-14.0.0" target="_blank" rel="noopener">LLVM</a> (yay, даже для windows!), и указать путь к скачанной библиотеке с cmake-файле. Дальше перегенерируем решение с помощью команды <code>generate_msvc_XXX.bat</code> и компилируем проект <code>libDasModuleClangBind</code>.</p><p>Получаем библиотеку <code>libDasModuleClangBind.lib</code>, которую можно подключить для статической линковки из проекта, который будет использовать этот модуль (командой <code>TARGET_LINK_LIBRARIES</code>). В сгенерированном решении убеждаемся в том, что линкер подключает библиотеки <code>libDasModuleClangBind.lib</code> и <code>libclang.lib</code>:<br><img src="/blog/4090909622/lib.png" alt="lib"></p><p>Далее в коде подключаем заголовочный файл и макрос добавления модуля в daScript:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../modules/dasClangBind/src/dasClangBind.h"</span></span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span>, <span class="keyword">char</span> * [] )</span> </span>&#123;</span><br><span class="line">    NEED_ALL_DEFAULT_MODULES;</span><br><span class="line">    NEED_MODULE(Module_dasClangBind); <span class="comment">//&lt;---</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Теперь в das-скрипте можно импортировать модуль <code>cbind</code>, который предоставляет функции-обёртки над библиотекой <code>clang</code>, а главное — <code>cbind_boost</code>, классы, с помощью которых можно настроить поведение генераторы, без низкоуровневого обращения к c-апи clang-а:<br><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">require</span> cbind</span><br><span class="line"><span class="keyword">require</span> cbind_boost</span><br></pre></td></tr></table></figure></p><h2 id="libclang"><a href="#libclang" class="headerlink" title="libclang"></a>libclang</h2><p>Для начала лучше бегло ознакомиться с тем, что умеет <code>libclang</code>:<br><a href="https://shaharmike.com/cpp/libclang/" target="_blank" rel="noopener">Using libclang to Parse C++</a><br><a href="https://habr.com/ru/post/439270/" target="_blank" rel="noopener">Пример разбора C++ кода с помощью libclang на Python</a><br><a href="https://clang.llvm.org/docs/Tooling.html" target="_blank" rel="noopener">Choosing the Right Interface for Your Application</a></p><h2 id="DasGenBind"><a href="#DasGenBind" class="headerlink" title="DasGenBind"></a>DasGenBind</h2><p>У генератор привязок <code>dasClangBind</code>, есть 2 режима: генерация обёрток над функциями в виде daScript (с помощью ffi-интерфейса <code>dasbind</code>) — <code>DasGenBind</code>, и более мощная генерация “обвязочного” c++-кода библиотеки — <code>CppGenBind</code>. С помощью <code>DasGenBind</code> <a href="https://github.com/GaijinEntertainment/daScript/blob/master/modules/dasClangBind/bind/bind_opengl.das" target="_blank" rel="noopener">сгенерированы</a> байндинги к <a href="https://github.com/GaijinEntertainment/daScript/blob/master/modules/dasOpenGL/opengl/opengl_func.das" target="_blank" rel="noopener">OpenGL</a>, так как сама библиотека language-agnostic, и её обвязки тривиальны — используются только функции и примитивные типы.</p><h2 id="CppGenBind"><a href="#CppGenBind" class="headerlink" title="CppGenBind"></a>CppGenBind</h2><p>Более интересно посмотреть на байндинги к <a href="https://github.com/GaijinEntertainment/daScript/blob/master/modules/dasClangBind/bind/bind_glfw.das" target="_blank" rel="noopener">glfw</a>, по которым можно приблизительно понять, что генерируется автоматически, а что необходимо добавлять в исключения и дописывать руками. <code>dasClangBind</code> в ходе своей работы пишет, какие объявляния функций он пропускает (<a href="https://github.com/GaijinEntertainment/daScript/blob/master/modules/dasClangBind/cbind/cbind_boost.das" target="_blank" rel="noopener">код</a> - поиск по ключевому слову <code>skip</code>):</p><ul><li>шаблоны</li><li>функции с аргументами-указателями на функции (к примеру, колбеки)</li><li>чисто виртуальные функции</li><li>глобальные операторы<br>Также генерируются, но вызывают последующие ошибки компиляции, функции (в лучших традициях текстов ошибок шаблонов C++), получающие аргументы POD-типов по значению.</li></ul><p>Для таких функций предполагается добавление их в список пропускаемых при автоматической генерации и последующее написания обработчика в ручную:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//переопределение метода AnyGenBind</span></span><br><span class="line"> <span class="function">def <span class="keyword">override</span> <span class="title">skip_anyFunction</span> <span class="params">( var c : CXCursor; isMethod : <span class="keyword">bool</span> )</span></span></span><br><span class="line">        if AnyGenBind`skip_anyFunction(self, c, isMethod)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        <span class="comment">//свои проверки, нужно или нет генерировать обёртку для функции</span></span><br></pre></td></tr></table></figure></p><p>Для дописывания несгенерированных автоматически функций предусмотрен файл <code>MODULENAME.main.cpp</code>. На выходе генератор байндингов выдаёт <a href="https://github.com/borisbat/dasGlfw/tree/48f2715f0fe4cb8076866365a4bf0a29b7104765/src" target="_blank" rel="noopener">пачку</a> и кусок cmake-файла в stdout, с помощью которого можно собрать их в модуль. На практике почему-то у меня не создавались файлы <code>MODULE.func.reg.inc</code> и <code>MODULE.func.decl.,inc</code>, их для теста заполнил руками.</p><h2 id="CmakeList-txt"><a href="#CmakeList-txt" class="headerlink" title="CmakeList.txt"></a>CmakeList.txt</h2><p>В качестве шаблона cmake-файла можно взять готовый из других модулей, основная логика:</p><ul><li>собрать модуль из сгенерированных файлов (это за нас выводит сам <code>dasClangBind</code>)</li><li>подключить lib-файл самой C++ библиотеки, для которой делается обвязка</li><li>определить переменные сборки daScript, позволяющие отключить модуль по желанию пользователя</li></ul><h2 id="Генерация-байндингов-для-библиотеке-MessagePack"><a href="#Генерация-байндингов-для-библиотеке-MessagePack" class="headerlink" title="Генерация байндингов для библиотеке MessagePack"></a>Генерация байндингов для библиотеке MessagePack</h2><p>Исходя из ограничений генератора, для учебного примера проще всего выбрать для примера максимально простую библиотеку, имеющую C, а не С++-интерфейс. Например - <a href="https://github.com/msgpack/msgpack-c/tree/c_master" target="_blank" rel="noopener">MessagePack</a>.</p><p>Стартовый код генератора:</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">require cbind/cbind_boost</span><br><span class="line">require daslib/safe_addr</span><br><span class="line">require daslib/strings</span><br><span class="line">require daslib/defer</span><br><span class="line">require daslib/fio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MsgpackGen</span> :</span> CppGenBind</span><br><span class="line">    override func_to_stdout = false</span><br><span class="line">    unique_functions : table&lt;string; bool&gt;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">MsgpackGen</span></span></span><br><span class="line">        bind_root = "&#123;get_das_root()&#125;/modules/dasMsgpack/src"</span><br><span class="line">        bind_module = <span class="string">"msgpack"</span></span><br><span class="line">        bind_das_module = <span class="string">"msgpack"</span></span><br><span class="line">        let pfn = <span class="string">"msgpack.h"</span></span><br><span class="line">        let pfp = <span class="string">"&#123;get_das_root()&#125;/modules/dasMsgpack/msgpack-c/include/"</span></span><br><span class="line"></span><br><span class="line">        let args &lt;- [&#123;string</span><br><span class="line">            <span class="string">"-xc++-header"</span>;</span><br><span class="line">            <span class="string">"-std=c++1z"</span>;</span><br><span class="line">            <span class="string">"-I&#123;get_full_file_name(pfp)&#125;"</span></span><br><span class="line">        &#125;]</span><br><span class="line"></span><br><span class="line">        func_per_chunk = <span class="number">20</span></span><br><span class="line">        init_args(pfn,pfp,args)</span><br><span class="line">        setDefaultFiles()</span><br><span class="line">        //init_skip_func()</span><br><span class="line">        openAllFiles()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">override</span> <span class="title">namespace_name</span><span class="params">(name:string; dash:string=<span class="string">"::"</span>)</span> :</span> string</span><br><span class="line">        <span class="keyword">return</span> AnyGenBind`namespace_name(self, name, dash)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">override</span> <span class="title">skip_struct</span><span class="params">(name : string)</span></span></span><br><span class="line"><span class="function">        <span class="title">return</span> <span class="title">false</span></span></span><br><span class="line"><span class="function">        //<span class="title">return</span> <span class="title">AnyGenBind</span>`<span class="title">skip_struct</span><span class="params">(name)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">def</span> <span class="title">override</span> <span class="title">skip_anyFunction</span><span class="params">(var c : CXCursor; isMethod:bool)</span> :</span> bool</span><br><span class="line">        let funcname = string(clang_getCursorSpelling(c))</span><br><span class="line">        //не генерировать обвязку для повторно встречаемой функции (не совсем понимаю, почему встречаются повторы)</span><br><span class="line">        <span class="keyword">if</span> unique_functions |&gt; find(funcname) != null</span><br><span class="line">            <span class="keyword">return</span> true</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            unique_functions[funcname] = true</span><br><span class="line">            <span class="keyword">return</span> AnyGenBind`skip_anyFunction(self, c, isMethod)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //генерируем код для файлов, подходящих по шаблону msgpack/*.h</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">override</span> <span class="title">skip_file</span><span class="params">(fname:string)</span> :</span> bool</span><br><span class="line">        <span class="keyword">if</span> fname |&gt; find(<span class="string">"msgpack/"</span>) != <span class="number">-1</span></span><br><span class="line">            <span class="keyword">return</span> false</span><br><span class="line">        <span class="keyword">return</span> ! fname |&gt; ends_with(PARSE_FILE_NAME)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">override</span> <span class="title">generateModuleHPrefix</span></span></span><br><span class="line"><span class="function">        <span class="title">module_h_file</span> |&gt; <span class="title">fwrite</span><span class="params">(<span class="string">"#include \"need_msgpack.h\"\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">[<span class="title">export</span>]</span></span><br><span class="line"><span class="function"><span class="title">def</span> <span class="title">main</span></span></span><br><span class="line">    var cgb = new MsgpackGen()</span><br><span class="line">    defer &lt;|</span><br><span class="line">        unsafe</span><br><span class="line">            delete cgb</span><br><span class="line">    cgb-&gt;generate()</span><br><span class="line">    cgb-&gt;genCMakeDecl("DAS_MSGPACK_BIND")</span><br></pre></td></tr></table></figure><p>Такой скрипт генерирует привязки к библиотеке, однако при её компиляции возникают несколько ошибок вида:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">использование неопределенного типа &quot;das::cast&lt;TT&gt;&quot; libDasModuleMsgpack \daScript\include\daScript\simulate\simulate.h</span><br></pre></td></tr></table></figure></p><p>Необходимо добавить эти функции в список исключаемых из генерации:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;передача в качестве аргумента POD-объекта по значению</span><br><span class="line">msgpack_object_print</span><br><span class="line">msgpack_object_print_buffer</span><br><span class="line">msgpack_object_equal</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;какие-то непонятки с передачей некоторых из базовых типов из C++ в daScript?</span><br><span class="line">msgpack_pack_char</span><br><span class="line">msgpack_pack_long</span><br><span class="line">msgpack_pack_unsigned_long</span><br></pre></td></tr></table></figure></p><p>Убрав их из генерации, получаем компилирующийся модуль daScript <code>dasMsgpack</code>.</p><h2 id="Тестовый-скрипт"><a href="#Тестовый-скрипт" class="headerlink" title="Тестовый скрипт"></a>Тестовый скрипт</h2><p>Попытаемся портировать тестовый <a href="https://github.com/msgpack/msgpack-c/blob/c_master/example/simple_c.c" target="_blank" rel="noopener">пример</a> библиотеки с <code>MessagePack</code> с языка C на daScript:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">require msgpack</span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main</span><br><span class="line">    var sbuf : msgpack_sbuffer</span><br><span class="line">    var pk : msgpack_packer</span><br><span class="line">    var mempool: msgpack_zone</span><br><span class="line">    var deserialized: msgpack_object</span><br><span class="line"></span><br><span class="line">    unsafe</span><br><span class="line">        var ptrBuf = addr(sbuf)</span><br><span class="line">        var ptrPk = addr(pk)</span><br><span class="line">        var ptrMempool = addr(mempool)</span><br><span class="line">        var ptrDeserialized = addr(deserialized)</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* msgpack::sbuffer is a simple buffer implementation. */</span></span><br><span class="line">        msgpack_sbuffer_init(ptrBuf)</span><br><span class="line">        <span class="comment">/* serialize values into the buffer using msgpack_sbuffer_write callback function. */</span></span><br><span class="line">        msgpack_packer_init(ptrPk, ptrBuf)</span><br><span class="line"></span><br><span class="line">        msgpack_pack_array(ptrPk, <span class="number">4u</span>l)</span><br><span class="line">        msgpack_pack_int(ptrPk, <span class="number">1</span>)</span><br><span class="line">        msgpack_pack_true(ptrPk)</span><br><span class="line">        msgpack_pack_float(ptrPk, <span class="number">3.0</span>)</span><br><span class="line">        msgpack_pack_str(ptrPk, <span class="number">7u</span>l)</span><br><span class="line">        msgpack_pack_str_body(ptrPk, <span class="string">"example"</span>, <span class="number">7u</span>l);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//print("&#123;sbuf.data&#125;, &#123;sbuf.size&#125;")</span></span><br><span class="line"></span><br><span class="line">        msgpack_zone_init(ptrMempool, <span class="number">2048u</span>l)</span><br><span class="line"></span><br><span class="line">        var data = <span class="number">0u</span>l;</span><br><span class="line">        var ptrData = addr(data)</span><br><span class="line">        msgpack_unpack(sbuf.data, sbuf.<span class="built_in">size</span>, ptrData, ptrMempool, ptrDeserialized);</span><br><span class="line">        msgpack_object_print(ptrDeserialized);</span><br><span class="line"></span><br><span class="line">        msgpack_zone_destroy(ptrMempool);</span><br><span class="line">        msgpack_sbuffer_destroy(ptrBuf)</span><br></pre></td></tr></table></figure><p>Некоторые функции из примеры не попали в автоматическую обвязку, поэтому необходимо дописать обвязку для них вручную в файле <code>msgpack.main.cpp</code>:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//передаём 3-й параметр по умолчанию</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">das_msgpack_packer_init</span><span class="params">(msgpack_packer* pk, <span class="keyword">void</span>* data)</span> </span>&#123;</span><br><span class="line">msgpack_packer_init(pk, data, msgpack_sbuffer_write);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//передаём параметр по указателю, не по значению</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">das_msgpack_object_print</span><span class="params">(msgpack_object* o)</span> </span>&#123;</span><br><span class="line">msgpack_object_print(<span class="built_in">stdout</span>, *o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//меняем тип второго указателя на const char* вместо неизвестного генератору void *</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">das_msgpack_pack_str_body</span><span class="params">(msgpack_packer* pk, <span class="keyword">const</span> <span class="keyword">char</span>* b, <span class="keyword">size_t</span> l)</span> </span>&#123;</span><br><span class="line">msgpack_pack_str_body(pk, b, l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Module_msgpack::initMain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//добавляем функции в модуль</span></span><br><span class="line">addExtern&lt;DAS_BIND_FUN(das_msgpack_packer_init)&gt;(*<span class="keyword">this</span>,lib,<span class="string">"msgpack_packer_init"</span>,</span><br><span class="line">            SideEffects::worstDefault,<span class="string">"das_msgpack_packer_init"</span>);</span><br><span class="line">addExtern&lt;DAS_BIND_FUN(das_msgpack_object_print)&gt;(*<span class="keyword">this</span>, lib, <span class="string">"msgpack_object_print"</span>,</span><br><span class="line">SideEffects::worstDefault, <span class="string">"das_msgpack_object_print"</span>);</span><br><span class="line">addExtern&lt;DAS_BIND_FUN(das_msgpack_pack_str_body)&gt;(*<span class="keyword">this</span>, lib, <span class="string">"msgpack_pack_str_body"</span>,</span><br><span class="line">SideEffects::worstDefault, <span class="string">"das_msgpack_pack_str_body"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Теперь скрипт работает и выдаёт корректный результат десериализации объекта:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1, true, 3.000000, &quot;example&quot;]</span><br></pre></td></tr></table></figure></p><p>Дальнейшая работа над модулем может предполагать:</p><ul><li>возможность устанавливать daScript колбеки (<a href="https://github.com/borisbat/dasGlfw/blob/48f2715f0fe4cb8076866365a4bf0a29b7104765/src/cb_dasGLFW.h" target="_blank" rel="noopener">пример из dasGlfw</a>)</li><li>daScript-обвязка над POD-структурой msgpack_object и корректная передача исключенных типов(?)</li><li>написание “daScript-ивизирующей” обёртки msgpack_boost, для перехода от с-апи к более удобной работы с библиотекой</li></ul><p><a href="https://github.com/spiiin/dasClangBind_modules" target="_blank" rel="noopener">Репозиторий с примерами кода</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;Ещё один “
      
    
    </summary>
    
    
    
      <category term="gamedev" scheme="http://spiiin.github.io/tags/gamedev/"/>
    
  </entry>
  
  <entry>
    <title>Хорошие качества программистов</title>
    <link href="http://spiiin.github.io/blog/1257365288/"/>
    <id>http://spiiin.github.io/blog/1257365288/</id>
    <published>2022-05-23T12:00:48.000Z</published>
    <updated>2022-05-29T08:48:18.949Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Качества программистов, которые мне нравятся:</p><ul><li>умение держать в голове большое количество информации</li><li>понимание, как использовать язык программирования в своих целях</li><li>умение решать задачу минимальным количеством изменений в коде</li><li>умение искать причины трудновоспроизводимых багов</li><li>слежение за качеством кодовой базы</li><li>умение ставить эксперименты</li><li>любовь к “тинкерингу”</li><li>умение довести решение сложной задачи до конца</li></ul><a id="more"></a><h2 id="Умение-держать-в-голове-большое-количество-информации"><a href="#Умение-держать-в-голове-большое-количество-информации" class="headerlink" title="Умение держать в голове большое количество информации"></a>Умение держать в голове большое количество информации</h2><p><img src="/blog/1257365288/demoman.png" alt="demoman"><br>Часто в большом проекте приходится переключаться между разными контекстами (исправление багов в различных подсистемах на разных уровнях, участие в обсуждениях будущих фич, базовое слежение за тем, что вообще происходит во всём проекте). Также это умение связано с навыками пользоваться системами структурирования информации — за осознанием, как мало на самом деле можно удерживать информации в голове (по сравнению с потоком информации в проекте), следует желание найти и пользоваться удобной системой задач, организовывать и расшаривать информацию, оптимизировать потоки информации там, где ощущается бардак. То есть, вытащить контекст из головы, и создать “паутину” вспомогательной информации, в которой можно будет найти то, что забылось.</p><p>Также связано с умением распространять информацию — рассказывать о том, как пользоваться готовыми решениями, реагировать на то, как используют библиотеку, документировать код. Другой связанный навык — упрощение работы с большим количеством информации путём автоматизации каких-либо процессов (не нужно знать о том, что обязательно запустить скрипт, если он запускается по расписанию сам).</p><h2 id="Понимание-как-использовать-язык-программирования-в-своих-целях"><a href="#Понимание-как-использовать-язык-программирования-в-своих-целях" class="headerlink" title="Понимание, как использовать язык программирования в своих целях"></a>Понимание, как использовать язык программирования в своих целях</h2><p><img src="/blog/1257365288/soldier.png" alt="soldier"><br>Каждый язык программирования имеет свои плюсы и минусы. Часто о них не говорят, но принимают как должное вместе с языком (библиотекой, фреймворком, движком). Минусы языка могут быть не абсолютными, а проявляться только при использовании языка в определенной области — при решении определенного типа задач, для которых определенные свойства языка становятся критичными.</p><p>Например, требование к скорости выполнения программ при разработке игр. Вот <a href="https://aras-p.info/blog/2009/11/14/improving-cmono-for-games/" target="_blank" rel="noopener">рассуждения</a> о недостатках C# в качестве языка для описания игровой логики и способов борьбы с этими ограничениями — как обойти минусы языка и платформы, чтобы воспользоваться его преимуществами, что было сделано в <code>Unity</code>. Если оценивать язык и пользоваться им только “как принято” и “как пишут в книжках”, то можно просто пропустить то, что возможно сделать с его помощью.</p><p>Хорошее понимание особенностей предметной области позволяет формулировать цели, с которыми можно подходить к выбору языков. Часто целью самого языка или фреймворка является стать “дефолтным выбором” в определенной нише, для тех, кто не задумывается о своих целях. Это может стать опасным в случаях, когда от инструмента автоматически ожидают, что его использование приведёт к тому, что продукт автоматически будет обладать нужными свойствами. За тем, чтобы желаемое свойство не потерялось, нужно следить, никакой язык не будет делать это за вас. Возможность писать быстрый код обеспечивает не язык, а понимание, как писать быстрый код (возможно, отличающиеся для различных языков).</p><p>Чем осознанние цель, с которой выбираешь инструмент, тем проще его выбрать (или даже решиться допилить в своих нуждах), а также отбросить/исправить/запретить “мусорные” вещи, которые, мешают достижению поставленной цели, и не заниматься вещами, которые никак не относятся к поставленным целям.</p><p>Интересный ретроспективный <a href="https://youtu.be/KxQpDIKwGUw" target="_blank" rel="noopener">доклад</a> от <code>Wargaming</code> про выбор движка <code>BigWorld</code> для танков с рассуждениями о важности понимания целей выбора технологии (5-я минута, оценка качеств движка на рынке).</p><h2 id="Умение-решать-задачу-минимальным-количеством-изменений-в-коде"><a href="#Умение-решать-задачу-минимальным-количеством-изменений-в-коде" class="headerlink" title="Умение решать задачу минимальным количеством изменений в коде"></a>Умение решать задачу минимальным количеством изменений в коде</h2><p><img src="/blog/1257365288/spy.png" alt="spy"><br>Первый уровень данного качества — банальное понимание, что количество возможных багов пропорционально количеству измененных строк, больше шанс “зацепить” что-то не относящееся к решаемой задачи, сложнее процесс чтения кода. Во многих гайдах к написанию коду в существующие проекты одним из первых упоминается правило — “старайтесь писать код, используя тот стиль, который уже используется, даже если он противоречит другим правилам”.</p><p>Менее очевидна корреляция небольшого количества изменений с тем, насколько решение вписывается в общую архитектуру системы. Меньшее количество строк также связано с тем, что используется более высокий уровень абстракции, решение собрано из высокоуровневых примитивов, и не дублирует/переделывает существующий код.</p><p>Так что желание решать задачу теми средствами, которые уже есть, стимулирует искать и создавать такие инструменты, которые расширяются и комбинируются между собой. Это важнее на более высоких уровнях астракции — легко увидеть код, который дублирует функционал стандартной библиотеки или какую-нибудь мелкую функцию-хелпер, но сложнее заметить, что не нужно писать целый редактор с нуля там, где есть почти готовый, который можно допилить под себя.</p><h2 id="Умение-искать-причины-трудновоспроизводимых-багов"><a href="#Умение-искать-причины-трудновоспроизводимых-багов" class="headerlink" title="Умение искать причины трудновоспроизводимых багов"></a>Умение искать причины трудновоспроизводимых багов</h2><p><img src="/blog/1257365288/sniper.png" alt="sniper"><br>Под слоем логики современной игры лежит множество других, которые являются для неё чёрным ящиком — код движка, вызовы функций операционной системы, обращение с сервером, слой графического API, взаимодействие множества 3rdParty библиотек, код которых также может обновляться по сети через пакетные менеджеры, особенности компилятора и реализаций стандартной библиотеки, особенности железа. Связи в собственном коде отследить просто, но какое-нибудь хитрое взаимодействие API между собой, без возможности посмотреть, что под капотом у этого API (относительно простой <a href="https://aras-p.info/blog/2007/07/25/can-you-set-opengl-states-independently/" target="_blank" rel="noopener">пример</a> с opengl) — отдельное искусство, которое иногда основывающется на рассуждениях “как бы я реализовал это, будь я разработчиком библиотеки” или на информации о похожих ошибках, собранной по крупицам из разных мест (в хорошем случае — прямым вопросом авторам библиотеки, в плохом — “о, это уже ломалось у них 3 версии назад, снова сломали”).</p><p>Хорошо развитый навык поиска таких ошибок развивает умение писать самому максимально простой код, который с наименьшей вероятностью создаст ошибки, которые трудно обнаружить.<br><a href="/blog/1807815468/" title="Философия поиска ошибок">Философия поиска ошибок</a> — более развёрнутое описание этой связи.</p><p>Пример сложных в решении багов — исправление ANR для мобильных приложений, <a href="https://blog.embrace.io/solve-anrs-with-flame-graphs/" target="_blank" rel="noopener">заметка</a> о причинах сложностей, и описание альтернативного подхода к поиску.</p><h2 id="Слежение-за-качеством-кодовой-базы"><a href="#Слежение-за-качеством-кодовой-базы" class="headerlink" title="Слежение за качеством кодовой базы"></a>Слежение за качеством кодовой базы</h2><p><img src="/blog/1257365288/pyro.png" alt="pyro"><br><a href="https://cs8.pikabu.ru/images/big_size_comm_an/2016-04_4/146100495418031426.webm" target="_blank" rel="noopener">Пуш в мастер.gif</a><br>Качество, которое, кажется, практически невозможно привить, и сложно организовать через рабочие процессы и постановку задач. Либо человек проходит мимо “грязи” в кодовой базе спокойно, либо раздражается, до тех пор, пока не решит исправить. Ответственность за качество кода зависит а от желания работать в комфорте, а не от уровня отвественности или способностей программиста.<br><a href="/blog/1363625753/" title="Мотивация честного программиста">Мотивация честного программиста</a> — повышение качества кода связано с желанием работать в комфортных условиях.</p><h2 id="Умение-ставить-эксперименты"><a href="#Умение-ставить-эксперименты" class="headerlink" title="Умение ставить эксперименты"></a>Умение ставить эксперименты</h2><p><img src="/blog/1257365288/medic.png" alt="medic"><br>Сильно коррелирует с обязательно необходимыми для каждого программиста навыками — умением проверить, надёжно ли работает собственный код, выявить причину ошибки. Код, написанный для эксперимента, вполне может оставаться реюзабельным для регрессивных тестов, или упрощения проверки различных сценариев.</p><p>Особенно необходимо для реализации различных оптимизаций в коде — есть много теоретически работающих трюков, которые не работают на практике. Для отдельных замеров необходимо написание кода, который в несколько раз по объёму больше, чем сам проверяемый код, или написание отдельных программ, позволяющих изучить качества кода, не проверяемые стандартными средствами.<br><a href="/blog/854775037/" title="Расположение объектов C++ в памяти">Расположение объектов C++ в памяти</a> — способы увидеть расположение объектов C++ классов в памяти, с целью улучшения cache locality.</p><p>В более общем случае умение ставить эксперименты позволяет организовать проверки гипотез о продукте — элемент <a href="/blog/2486671624/" title="Lean Development">Lean Development</a>.</p><h2 id="Любовь-к-тинкерингу"><a href="#Любовь-к-тинкерингу" class="headerlink" title="Любовь к тинкерингу"></a>Любовь к тинкерингу</h2><p><img src="/blog/1257365288/engineer.png" alt="engineer"><br>“Тинкерить” — мастерить что-то, изучать, хакать, исследование без особой цели. Попробовать поиграться с новым движком, изучить новый алгоритм или библиотеку. Часто в таком случайном изобретении приобретается полезная экспертиза, на стыке дисциплин можно найти интересные и необычные идеи, нестандартные способы решения задач.</p><p><a href="/blog/2537188794/" title="Прототипирование в геймдеве">Прототипирование в геймдеве</a> — возможно, результат тинкеринга станет прототипом большого проекта. <a href="https://www.igromania.ru/article/31609/Istoriya_Minecraft_i_eyo_sozdatelya._Kto_i_kogda_sdelal_legendarnuyu_igru.html" target="_blank" rel="noopener">Майнкрафт</a> тоже начинался с тинкеринга с воксельной песочницей.</p><h2 id="Умение-довести-решение-сложной-задачи-до-конца"><a href="#Умение-довести-решение-сложной-задачи-до-конца" class="headerlink" title="Умение довести решение сложной задачи до конца"></a>Умение довести решение сложной задачи до конца</h2><p><img src="/blog/1257365288/scout.png" alt="scout"><br>Есть два типа программистов, которые не могут справиться с задачей — те, у которых код настолько плох, что его дольше исправлять, чем написать заново (чаще всего в попытках внести в него улучшения, ломают то, что уже “залатали” во время предыдущего этапа исправлений, исправления никогда не “сходятся” к нормальному решению) и те, которые вообще не понимают, что от них хотят. Никаких уточняющих вопросов или чернового варианта решения дождаться от них невозможно, а в перед дед-лайном наступает какая-нибудь катастрофа, которая уничтожает их решение, существующее только на их машине. Бывают ещё программисты, которые делают часть работы, но не заканчивают её по каким-либо причинам, не хватает фантазии, инициативы, желания связать созданные части в одно целое. В этом случае чаще всего их код не собирается и требует для проверки внесения в него изменений проверяющим.</p><p>В хороших случаях человек способен сам разобраться с тем, чтобы задать уточняющие вопросы и найти того, кто может помочь с решением. В особо хороших случаях — при невозможности  найти полноценное решение, может придумать и реализовать частичное, с пометками, что в нём можно улучшить. В самых хороших — проявить дальнейшую инициативу по поиску ресурсов для полноценного решения.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Качества программистов, которые мне нравятся:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;умение держать в голове большое количество информации&lt;/li&gt;
&lt;li&gt;понимание, как использовать язык программирования в своих целях&lt;/li&gt;
&lt;li&gt;умение решать задачу минимальным количеством изменений в коде&lt;/li&gt;
&lt;li&gt;умение искать причины трудновоспроизводимых багов&lt;/li&gt;
&lt;li&gt;слежение за качеством кодовой базы&lt;/li&gt;
&lt;li&gt;умение ставить эксперименты&lt;/li&gt;
&lt;li&gt;любовь к “тинкерингу”&lt;/li&gt;
&lt;li&gt;умение довести решение сложной задачи до конца&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="dev" scheme="http://spiiin.github.io/tags/dev/"/>
    
  </entry>
  
  <entry>
    <title>Города, которые мы выбираем</title>
    <link href="http://spiiin.github.io/blog/1152742413/"/>
    <id>http://spiiin.github.io/blog/1152742413/</id>
    <published>2022-05-09T20:28:27.000Z</published>
    <updated>2022-05-14T12:24:11.728Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Пол Грем в своих статьях <a href="http://paulgraham.com/cities.html" target="_blank" rel="noopener">Cities and Ambition</a> и <a href="http://www.paulgraham.com/gh.html" target="_blank" rel="noopener">Great Hackers</a> (легко ищутся на русском) развёрнуто рассказывает о том, что города определяют образ мышления людей. Города посылают <a href="/blog/649/" title="сообщения">сообщения</a>, можно научиться слушать их и расшифровывать.</p><p>Сообщения эти выражаются в качестве разговоров, которые слышишь вокруг, в потоке поступающей информации. Разговоры за соседними столами в кафе, бизнес-ланч с коллегами, подсмотренная история вечером в окне чьей-то квартиры, ссора соседей за стеной, сцена в электричке, радио в такси, билборд на улице, баннер на сайте или рекомендуемая новость в соцсети (которые тоже зависят от твоей геолокации). Это не что-то, что нужно специально искать, а скорее информация, от которой невозможно уклониться — город говорит тебе, что хочет, чтобы ты делал. Какие-то города тихо нашептывают тебе свои идеи, какие-то кричат так, что становится страшно. Важно понять, что эти сообщения воспринимаются как собственные мысли (ведь если у тебя в голове чужие голоса и мысли — то ты не совсем нормальный, так?).</p><p>Город — не какая-то мистическая сущность, а <code>&quot;масса людей + среда их обитания&quot;</code>. В современном мире “городом” может быть и более маленькая или большая структура. Кембридж — часть города, Кремниевая Долина — не город совсем, какой-нибудь специфический офис крупной компании вполне может быть отдельным пространством, формирующим мышление сотрудников.</p><p>Некоторые игровые студии умеют работать с пространством офиса. Valve использует столы на колесиках — можно переместиться в другой кабинет, и внутренний сайт, который отображает местонахождение сотрудника, за счет чего возможны различные конфигурации потоков информации между сотрудниками необходимыми для эффективной работы в текущий момент. Джесси Шелл рассказывает о том, что структура игровой студии зависит от того, каким образом распространяется информация, а это зависит в том числе от структуры офиса, ссылаясь на “Язык шаблонов” Кристофера Александера.<br><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/y92-vkyHKbY" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></p><p>Вот <a href="https://youtu.be/-zRaFJHK0S4?t=1355" target="_blank" rel="noopener">таймкод</a> из второго его доклада (лучше смотреть весь). Если объединить эту информацию и <a href="https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%BA%D0%BE%D0%BD_%D0%9A%D0%BE%D0%BD%D0%B2%D0%B5%D1%8F" target="_blank" rel="noopener">Закон Конвея</a>, можно сказать, что структура пространства определяет не только структуру компании, но и продукты, которые она производит.</p><p>В снг-шном обществе программистов (не знаю, как в других), как-то принято считать, что профессиональное развитие зависит в первую очередь от самого специалиста, а не от его окружения (офиса+коллег, города+граждан вокруг).</p><p>С начала года ощутил для себя нехватку <em>чего-то</em>, что было при работе в офисе, но потерялось при работе из дома. Собрал немного <a href="https://vas3k.club/post/11435/" target="_blank" rel="noopener">фоток и историй</a> (пост закрытый, чтобы людям проще было откровенничать с историями — это намного важнее картинок) про особенности офисов айтишников — что именно ценят люди в офисах, что им запоминается, влияет на их настроение, работоспособность. И самое главное — отделить мух от котлет, а точнее печеньки и плюшки для заманивания работников, от того, что реально помогает работать.</p><p><img src="/blog/1152742413/of1_small.png" alt="of1"><br><img src="/blog/1152742413/of2_small.png" alt="of2"><br><img src="/blog/1152742413/of3_small.png" alt="of3"></p><p>Я вижу необходимость наличия офиса как пространства для разработки игр в том, чтобы существовала среда общения и среда отдыха.</p><h2 id="Среда-общения"><a href="#Среда-общения" class="headerlink" title="Среда общения"></a>Среда общения</h2><p>Разработка игр — творческий процесс. Игры как медиа передают что-то игроку. Гейм-дизайнер через эстетику хочет вызвать какие-то чувства. К примеру, последняя игра, которую я проходил, <code>Divinity: Original Sin 2</code>,  по жанру вроде как тактическая рпг и про передвижение “пешек” по полю и механику. Но при этом я иногда удивлялся, что некоторые локации вызывают желание рассматривать их под разными углами и любоваться — видовая лавочка рядом с кладбищем с плакучей ивой, на которой хочется посидеть и подумать, или лежанка, на которую можно взобраться по лестнице в подземной таверна в Дрифтвуда с курящим друдену ящером, заставляющая задуматься о том, что ему там находиться должно быть очень уютно. Чтобы передать это ощущение, нужно взаимодействие нескольких человек, пробы и попытки. Нельзя просто описать задачу и ждать результата, живое взаимодействие и общение может привести к нахождению способа задать нужное “настроение” игры.</p><p>Это один из элементов магии игр — возможность разработчику или дизайнеру передать в игре что-то, что он пережил и прочувствовал сам. А между желанием передать какое-то чувство и ощущение, и геймплеем, который вызовет это ощущение у игрока, лежит общение между людьми, которые делают игру. Чем сложнее и глубже ощущение, которое хочет создать команда разработчиков, тем более выразительным должно быть общение в команде. Удаленное взаимодействие здесь сильно проигрывает живому. Инженеры также сталкиваются с задачами, требующими творческого подхода — задачи с серьёзными техническими ограничениями, или такие, которые до них не решал никто, просто описывать такие задачи не так красочно, как задачи артистов/геймдизайнеров.</p><p>С этой точки зрения игра создаёт для игрока целый мир, в котором он может испытать что-то новое, пережить фантастическую историю, задуматься о чём-то, возможно в исключительных случаях даже решиться жить так, как хочется на самом деле.</p><p>Если стараться делать игры так, то кроме взаимодействия команды, необходимо еще и постоянное стремление к развитию себя и команды, желание делать последующие игры круче предыдущих (“Ведьмак 3” был бы невозможен без “Ведьмака 2” и “Ведьмака 1”), общаться, чтобы 1) находить ядро команды, которое способно делать следующую игру масштабнее и сложнее предыдущих, и находить идеи таких игр 2) создавать инструменты такого качества, чтобы их можно было реюзать в следующих проектах 3) делать текущие игры такого качества, чтобы получить ресурсы для разработки более продвинутых следующих игр. “Найти коннект” намного проще в живом общении, чем в удаленном, как и обмениваться идеями и информацией.</p><p>Если не стараться — уровень формулирования задач будет на уровне “делаем как у конкурентов, у них то как-то работает”. Либо же вообще без формулирования задач внутри команды — слепой набор исполнителей поставленных извне задач.</p><p>Высококлассным специалистам больше хочется работать над интересными и сложными задачами в группе таких же высококлассных специалистов. Во-первых, можно обмениваться опытом, во-вторых, легче получить признание своих заслуг от коллег, в-третьих, суммарный результат за единицу времени будет выше, если все в группе приносят больше условной пользы продукту. А узнать, что специалист высококлассный, при живом общении намного быстрее — легче отделить “сигнал” от “шума” (этот пункт актуальнее в больших или растущих командах, когда ядро формируется в существующей команде, а не на этапе найма новых сотрудников).</p><h2 id="Среда-отдыха"><a href="#Среда-отдыха" class="headerlink" title="Среда отдыха"></a>Среда отдыха</h2><p>Для продуктивной работы необходимо переключать состояния сосредоточения и расслабления. Сосредоточенно работать удобно из дома, а вот организовать периоды отдыха сложнее (отвлекают бытовые дела, семья - требуется смена места, которую в доме или квартире организовать сложнее, плюс надо приложить усилия, чтобы вытолкнуть себя из работы в эту зону). В офисе организовать режим и распорядок проще, а главное, проще вернуть смещенный или сбитый режим обратно — дома отсутствует ритм-ориентир, под который можно подстроиться.</p><p>Профессиональное общение с коллегами — тоже важная часть отдыха.</p><p>Ключевые моменты комфортной творческой работы для меня — свобода общения и исследования, и полноценный отдых. Там, где есть тревога, страх, запреты — не будет творчества. Там, где постоянно нужно думать о том, чтобы не нарушить какой-нибудь запрет, не остаётся времени думать о чём-то другом. Все равно, что пытаться ехать, не сняв машину с ручного тормоза. В 2020 многие остались из-за пандемии без комфортного офиса, в 2022 — из-за войны и связанных с ней рисков переместились из своих городов в другие. Сложно угадать, где будут “комфортные для геймдева города” теперь, но точно вне России. Сейчас там города говорят совсем о другом.Очень сложно переучиться в выборе с оценки ситуации “что есть сейчас” на оценку “что будет через несколько месяцев/лет”.</p><p>Кроме внешнего распорядка, для решения по настоящему сложных задач необходима возможность отдохнуть и отвлечься — интересная прогулка по окрестностям, место где можно спокойно посидеть или полежать, или какая-нибудь физическая активность, прогулка к водоему, возможность поиграть с собакой, повисеть на турнике, послушать живую музыку, заняться чем-то максимально отвлеченным (<a href="https://xkcd.ru/230/" target="_blank" rel="noopener">xkcd</a> на тему важности переключения).</p><p> Творческая часть работы — это где-то процентов 10 от общего времени, остальные 90% — это попытки понять, почему что-то работает не так, как задумано, и исправление ошибок. Такая работа даже сильнее требует возможности отдохнуть и отвлечься.</p><h2 id="Источники-вдохновения"><a href="#Источники-вдохновения" class="headerlink" title="Источники вдохновения"></a>Источники вдохновения</h2><p>Грег Костикян в статье <a href="http://www.costik.com/vidiot.html" target="_blank" rel="noopener">“Don’t be a vidiot”</a> (<a href="http://aushestov.ru/%D0%BD%D0%B5-%D0%B1%D1%83%D0%B4%D1%8C-%D0%B2%D0%B8%D0%B4%D0%B8%D0%BE%D1%82%D0%BE%D0%BC-%D0%B8%D0%BB%D0%B8-%D1%87%D0%B5%D0%BC%D1%83-%D0%B4%D0%B8%D0%B7%D0%B0%D0%B9%D0%BD%D0%B5%D1%80-%D0%BA%D0%BE%D0%BC/" target="_blank" rel="noopener">перевод</a>) в качестве поиска источников вдохновения рекомендует не останавливаться на видеоиграх, а исследовать другие области развлечений — настольные игры, варгеймы, ролевые и коллекционнык карточные игры, а также LARP-ы. Я бы добавил еще тематические развлекательные фестивали, комиконы, технологические фестивали, геймдев конференции, подобные бёрнинг-мэну мероприятия, парки развлечений, квест-румы, городские квесты, спортивные и киберспортивные шоу, внедорожное ориентирование (трофи-рейд). Часть из них можно найти локально, чтобы поучаствовать в других — нужно путешествовать. В этом плане главное — предолеть границы стран и языковые барьеры. Т.е. удобство путешествий и доступность таких развлечений вокруг может быть фактором для комфортной работы в городе.</p><h2 id="Рациональные-и-нерациональные-мотивы-выбора-места-работы"><a href="#Рациональные-и-нерациональные-мотивы-выбора-места-работы" class="headerlink" title="Рациональные и нерациональные мотивы выбора места работы"></a>Рациональные и нерациональные мотивы выбора места работы</h2><p>Все перечисленные мотивы выбора места для работы и жизни — от людей, ориентирующихся на профессиональный рост и возможности реализации своего потенциала, для таких же, как и они. Часто выбор проще и прагматичнее — где больше платят и заманчивее бонусы-печеньки, где больше востребованность специалиста, и где больше шансы, что бизнес останется прибыльным. Еще один тип гирек на весах выбора, это банальная привязанность к месту — дом, семья, иногда страх нового, или просто невозможность свободно выбирать, и иногда такие гирьки перевешивают всё остальное. Но если кажется, что никаких весов и выбора нет — значит, возможно, что кто-то спрятал от вас саму возможность, обманул, напугал, и сделал выбор за вас.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;Пол Грем в
      
    
    </summary>
    
    
    
      <category term="log" scheme="http://spiiin.github.io/tags/log/"/>
    
      <category term="tales" scheme="http://spiiin.github.io/tags/tales/"/>
    
      <category term="gamedev" scheme="http://spiiin.github.io/tags/gamedev/"/>
    
  </entry>
  
  <entry>
    <title>daScript ссылки</title>
    <link href="http://spiiin.github.io/blog/2371214813/"/>
    <id>http://spiiin.github.io/blog/2371214813/</id>
    <published>2022-02-23T13:07:49.000Z</published>
    <updated>2022-05-29T08:43:45.455Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Ссылки по библиотекам и примерам на daScript</p><a id="more"></a><p><a href="https://github.com/imp5imp5/dasbox" target="_blank" rel="noopener">dasbox</a> - среда для создания простых 2d-игр, <a href="https://www.youtube.com/playlist?list=PL6Ke-5R5eg2I7oVLR7TJIT5Q0ikGecVrT" target="_blank" rel="noopener">видео</a><br><a href="https://vk.com/gaijinjam" target="_blank" rel="noopener">gaijinjam</a> - группа вк, посвященная хакатону на daScript<br><a href="https://github.com/imp5imp5/daScript-plugin" target="_blank" rel="noopener">daScript language plugin</a> - плагин для работы с языком в VS code - отладчик, автокомплит кода, go to definition, подсветка etc<br><a href="https://github.com/olegus8/dasBinder" target="_blank" rel="noopener">dasBinder</a> - генератор байндингов в библиотекам на C</p><p>Модули<br><a href="https://github.com/VasiliyRyabtsev/dasCurl" target="_blank" rel="noopener">dasCurl</a> - байндинги и libcurl<br><a href="https://github.com/VasiliyRyabtsev/dasRequests" target="_blank" rel="noopener">dasRequests</a> - сгенерированная обёртка над curl<br><a href="https://github.com/VasiliyRyabtsev/dasPhys2d" target="_blank" rel="noopener">dasPhys2d</a> - сгенерированные байндинги к box2d<br><a href="https://github.com/olegus8/dasVulkan" target="_blank" rel="noopener">dasVulkan</a> - байндинги к Vulkan<br><a href="https://github.com/profelis/das-web" target="_blank" rel="noopener">das-web</a> - работа с сетью<br><a href="https://github.com/profelis/das-web-samples" target="_blank" rel="noopener">das-web-samples</a> - примеры работы с web<br><a href="https://github.com/profelis/das-test" target="_blank" rel="noopener">das-test</a> - testing framework</p><p>Примеры игр<br><a href="https://github.com/RikiChiki/asteroids" target="_blank" rel="noopener">asteroids</a> - клон игры с Atari<br><a href="https://github.com/AndreiPotapov/dasbox_survival_game" target="_blank" rel="noopener">survival</a> - survival game<br><a href="https://github.com/antonnikvl/DasTetris" target="_blank" rel="noopener">dastetris</a> - тетрис на daScript<br><a href="https://github.com/perneky/ikplus" target="_blank" rel="noopener">ikplus</a> - клон игры International Karate<br><a href="https://github.com/VasiliyRyabtsev/dasSokoban" target="_blank" rel="noopener">dasSocoban</a> - клон Sokoban<br><a href="https://github.com/RobertNagy1978/Wolfenstein3D/blob/main/Wolfenstein3D.das" target="_blank" rel="noopener">wolfenstein3d</a> - клон wolfenstein<br><a href="https://github.com/hpotamus/igger" target="_blank" rel="noopener">igger</a> - клон Digger<br><a href="https://github.com/kopariadam/LabyrinthThingy" target="_blank" rel="noopener">LabyrinthThingy</a><br><a href="https://github.com/Timai/dalaga" target="_blank" rel="noopener">dalaga</a><br><a href="https://github.com/BADxDI/dasTowerDefens" target="_blank" rel="noopener">dasTowerDefence</a><br><a href="https://github.com/IgnatVopilov/DAgario" target="_blank" rel="noopener">dasAgarIo</a><br><a href="https://github.com/AndreyMironenko/adventure-dascript" target="_blank" rel="noopener">adventureDaScript</a><br><a href="https://github.com/dmitrinosov/space-pressure-2d" target="_blank" rel="noopener">space-pressure-2s</a><br><a href="https://github.com/Thibaut-Fervenca/DaDefense" target="_blank" rel="noopener">DaDefense</a><br><a href="https://github.com/vmaluhin/battlecity" target="_blank" rel="noopener">battle city</a><br><a href="https://github.com/khupjan/WormsIn2daysPrototype" target="_blank" rel="noopener">worms2d</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Ссылки по библиотекам и примерам на daScript&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="gamedev" scheme="http://spiiin.github.io/tags/gamedev/"/>
    
  </entry>
  
  <entry>
    <title>daScript OpenGL</title>
    <link href="http://spiiin.github.io/blog/4232971949/"/>
    <id>http://spiiin.github.io/blog/4232971949/</id>
    <published>2022-02-20T16:45:39.000Z</published>
    <updated>2022-02-20T20:18:10.801Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Пример использования байдингов OpenGL для языка daScript<br><a id="more"></a></p><p>Попробовал разобраться с использованием байндингов библиотек к языку daScript. В качестве тестовой задачки решил портировать на daScript + OpenGL <a href="https://github.com/bkaradzic/bgfx/issues/1857" target="_blank" rel="noopener">эту демку</a>. Программа реализует алгоритм клиппинга модели несколькими плоскостями, с заполненнием отрезанных частей “крышками”, чтобы не было видно внутренней поверхности модели (<a href="https://github.com/daign/clipping-with-caps/blob/master/screenshot_01.png" target="_blank" rel="noopener">скрин</a>).</p><p>Алгоритм:</p><ul><li>Отрисовать модель с шейдером отсечения (с “дырками”)</li><li>Заполнить буфер трафарета значениями так, чтобы пометить пиксели, которые нужно закрыть:<br>— Отрисовать внутреннюю сторону модели, увеличивая значение в буфере трафарета<br>— Отрисовать внешнюю сторону модели, уменьшая значение в буфере трафарета<br>— Заполнять буфер трафарета в только в точках, в которых плоскость отсечения повернута к камере (для корректной работы нескольких плоскостей отсечения одновременно)</li><li>Отрисовать плоскости отсечения по полученной маске (получаются закрывающие “крышки”)</li></ul><h2 id="Каркас-приложения"><a href="#Каркас-приложения" class="headerlink" title="Каркас приложения"></a>Каркас приложения</h2><p>Для создания байндингов библиотек к daScript используется <a href="https://github.com/GaijinEntertainment/daScript/issues/231" target="_blank" rel="noopener">dasClangBind</a>, с помощью которого сделаны обёртки для <a href="https://github.com/GaijinEntertainment/daScript/tree/master/modules" target="_blank" rel="noopener">нескольких</a> библиотек, включая OpenGL. Последний из <a href="https://github.com/GaijinEntertainment/daScript/blob/master/modules/dasOpenGL/examples/09_hello_mesh.das" target="_blank" rel="noopener">примеров</a> демонстрирует загрузку и отображение модели из obj-файла. Этот пример можно взять за основу. Для задания настроек отсекающих плоскостей можно взять байндинг к <a href="https://github.com/borisbat/dasImgui/" target="_blank" rel="noopener">imgui</a>.</p><p>Эти модули также тащат за собой <code>glfw</code> для создания окна и <code>stbImage</code>. Шаблон C++ кода для подключения модулей:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../modules/dasGlfw/src/dasGLFW.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../modules/dasImgui/src/dasIMGUI.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../modules/dasStbImage/src/dasStbImage.h"</span></span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span>, <span class="keyword">char</span> * [] )</span> </span>&#123;</span><br><span class="line">    NEED_ALL_DEFAULT_MODULES;</span><br><span class="line">    NEED_MODULE(Module_dasGLFW)</span><br><span class="line">    NEED_MODULE(Module_StbImage)</span><br><span class="line">    NEED_MODULE(Module_dasIMGUI)</span><br><span class="line">    NEED_MODULE(Module_imgui_app)</span><br><span class="line">    Module::Initialize();</span><br><span class="line">    tutorial();</span><br><span class="line">    Module::Shutdown();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Пустое окно на glfw + imgui можно создать так:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">imgui_app</span><span class="params">(title:<span class="built_in">string</span>; blk : block)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">if</span> <span class="title">glfwInit</span><span class="params">()</span></span>==<span class="number">0</span></span><br><span class="line">panic(<span class="string">"can't init glfw"</span>)</span><br><span class="line">    defer &lt;|</span><br><span class="line">        glfwTerminate()</span><br><span class="line">    glfwInitOpenGL(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line">    var window = glfwCreateWindow(<span class="number">1280</span>, <span class="number">720</span>, <span class="string">"OpenGL - Hello shader clipping"</span>, null, null)</span><br><span class="line">    <span class="keyword">if</span> window==null</span><br><span class="line">panic(<span class="string">"can't create window"</span>)</span><br><span class="line">    defer &lt;|</span><br><span class="line">        glfwDestroyWindow(window)</span><br><span class="line">    glfwMakeContextCurrent(window)</span><br><span class="line"></span><br><span class="line">    CreateContext(null)</span><br><span class="line">    var io &amp; = unsafe(GetIO())</span><br><span class="line">    StyleColorsDark(null)</span><br><span class="line">    ImGui_ImplGlfw_InitForOpenGL(window, <span class="literal">true</span>)</span><br><span class="line">    ImGui_ImplOpenGL3_Init(<span class="string">"#version 330"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> glfwWindowShouldClose(window)==<span class="number">0</span></span><br><span class="line">        glfwPollEvents()</span><br><span class="line"></span><br><span class="line">        ImGui_ImplOpenGL3_NewFrame()</span><br><span class="line">        ImGui_ImplGlfw_NewFrame()</span><br><span class="line"></span><br><span class="line">        invoke(blk)</span><br><span class="line"></span><br><span class="line">        var display_w, display_h : <span class="keyword">int</span></span><br><span class="line">        glfwGetFramebufferSize(window, display_w, display_h)</span><br><span class="line">        let aspect = display_h!=<span class="number">0</span> ? <span class="keyword">float</span>(display_w)/<span class="keyword">float</span>(display_h) : <span class="number">1.</span></span><br><span class="line">        <span class="comment">// render</span></span><br><span class="line">        glViewport(<span class="number">0</span>, <span class="number">0</span>, display_w, display_h)</span><br><span class="line">        glClearColor(<span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">1.0</span>)</span><br><span class="line">        glClearDepth(<span class="number">1.0l</span>f)</span><br><span class="line">        glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT|GL_STENCIL_BUFFER_BIT)</span><br><span class="line"></span><br><span class="line">        ImGui_ImplOpenGL3_RenderDrawData(GetDrawData())</span><br><span class="line"></span><br><span class="line">        glfwMakeContextCurrent(window)</span><br><span class="line">        glfwSwapBuffers(window)</span><br><span class="line">    <span class="comment">//close app</span></span><br><span class="line">    DestroyContext(null)</span><br><span class="line">    glfwDestroyWindow(window)</span><br><span class="line">    glfwTerminate()</span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def test</span><br><span class="line">imgui_app(<span class="string">"imgui"</span>) &lt;|</span><br><span class="line">        NewFrame()</span><br><span class="line">        Begin(<span class="string">"Crop params"</span>);</span><br><span class="line">        End();</span><br><span class="line">        Render()</span><br></pre></td></tr></table></figure><ul><li>не забыли создать и очистить буфер трафарета (GL_STENCIL_BUFFER_BIT)</li><li><a href="https://dascript.org/doc/reference/language/blocks.html?highlight=block" target="_blank" rel="noopener">block</a> в daScript — безымянная функция, которая захватывает переменные по ссылке (более быстрая, чем лямбда-функции, которые могут управлять способом захвата)</li><li><code>defer</code> — макрос для добавления выражений в блок <a href="https://dascript.org/doc/reference/language/statements.html?highlight=defer#finally-statement" target="_blank" rel="noopener">finally</a></li></ul><p>Исходная демка использует библиотеки three.js и ColladaLoader.js для загрузки меша из dae файла, но можно <a href="https://products.aspose.app/3d/ru/conversion/dae-to-obj" target="_blank" rel="noopener">конвертировать</a> dae в obj, чтобы использовать код загрузки меша из примера daScript. Загрузка меша:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">require opengl/opengl_gen</span><br><span class="line"></span><br><span class="line">let mesh_file_name = <span class="string">"&#123;get_das_root()&#125;/house.obj"</span></span><br><span class="line">var mesh &lt;- load_obj_mesh(mesh_file_name) |&gt; create_geometry_fragment</span><br></pre></td></tr></table></figure><h2 id="Отрисовка-меша"><a href="#Отрисовка-меша" class="headerlink" title="Отрисовка меша"></a>Отрисовка меша</h2><p>Задание стандартных шейдеров:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">require glsl/glsl_common</span><br><span class="line">require glsl/glsl_internal</span><br><span class="line"></span><br><span class="line">var [[in, location=<span class="number">0</span>]] v_position : float3</span><br><span class="line">var [[in, location=<span class="number">1</span>]] v_normal   : float3</span><br><span class="line">var [[in, location=<span class="number">2</span>]] v_texcoord : float2</span><br><span class="line">var [[uniform]] v_model : float4x4</span><br><span class="line">var [[uniform]] v_view : float4x4</span><br><span class="line">var [[uniform]] v_projection : float4x4</span><br><span class="line">var [[inout]] f_texcoord : float2</span><br><span class="line">var [[inout]] f_normal : float3</span><br><span class="line">var [[inout]] f_position : float3</span><br><span class="line">var [[inout]] f_worldpos : float3</span><br><span class="line"></span><br><span class="line">var [[uniform, stage=<span class="number">0</span>]] f_tex : sampler2D</span><br><span class="line">var [[out]] f_FragColor : float4</span><br><span class="line"></span><br><span class="line">[vertex_program]</span><br><span class="line">def vs_preview</span><br><span class="line">    f_texcoord = v_texcoord</span><br><span class="line">    f_normal = normalize ( float3x3(v_model) * v_normal )</span><br><span class="line">    let tpos = v_model * float4(v_position, <span class="number">1.0</span>)</span><br><span class="line">    f_position = tpos.xyz</span><br><span class="line">    f_worldpos = v_position</span><br><span class="line">    gl_Position = v_projection * v_view * tpos</span><br><span class="line"></span><br><span class="line">[fragment_program (version=<span class="number">400</span>)]</span><br><span class="line">def fs_preview</span><br><span class="line">    let pS = <span class="number">24.0</span></span><br><span class="line"></span><br><span class="line">    let light_dir = normalize(float3(<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">-3</span>))</span><br><span class="line">    let camera_dir = normalize(f_position)</span><br><span class="line">    let normal = normalize(f_normal)</span><br><span class="line">    let k = -dot(light_dir,normal)</span><br><span class="line">    let diffuse = float3(saturate(k))</span><br><span class="line">    let refl = normalize ( reflect(camera_dir,normal) )</span><br><span class="line">    let kS = saturate(dot(-light_dir,refl))</span><br><span class="line">    let kS1 = saturate(dot(-light_dir,refl))</span><br><span class="line">    let specular = float3(<span class="built_in">pow</span>(kS,pS)*kS)</span><br><span class="line">    f_FragColor.xyz = texture(f_tex,f_texcoord).xyz * diffuse + specular</span><br><span class="line">    f_FragColor.w = <span class="number">1.</span></span><br></pre></td></tr></table></figure><p>Интересная штука — DSL для работы с шейдерами (<a href="https://github.com/GaijinEntertainment/daScript/blob/master/modules/dasGlsl/glsl/glsl_internal.das" target="_blank" rel="noopener">glsl_internal</a>, набор макросов для того, чтобы писать шейдеры как обычные функции в daScript, а также работать с uniform переменными почти как с обычными переменными языка. Пример передачи uniform-ов в шейдер:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var [[uniform]] v_projection : float4x4                                     <span class="comment">//объявление uniform переменной для шейдера</span></span><br><span class="line"></span><br><span class="line">let aspect = display_h!=<span class="number">0</span> ? <span class="keyword">float</span>(display_w)/<span class="keyword">float</span>(display_h) : <span class="number">1.</span></span><br><span class="line">v_projection = perspective_rh_opengl( <span class="number">45.0f</span>*PI/<span class="number">180.</span>, aspect, <span class="number">0.1f</span>, <span class="number">10.0f</span>)   <span class="comment">//определяем матрицу проекции (daScript-структура)</span></span><br><span class="line">vs_preview_bind_uniform(program_front)                                      <span class="comment">//передаём uniform переменные в шейдер</span></span><br><span class="line">fs_preview_bind_uniform(program_front)                                      <span class="comment">// vs_preview_bind_uniform - сгенерированная макросом [vertex_program] функция!</span></span><br></pre></td></tr></table></figure><p>Помимо простой привязки функций библиотеки, сгенерированной с помощью <code>dasClangBind</code>, написаны также макросы для “daScript-ивизации” кода. Вместо императивного вызова функции <code>glUniformXXX</code>, программист декларирует намерение “эта переменная - uniform для шейдера” — аннотация <code>uniform</code>.</p><p><strong><code>За счёт этого скриптовый язык становится не &quot;условным бейсиком&quot; для императивного вызова функций, а способом приблизить библиотеку к предметной области, в терминах которой мыслит и работает программист</code></strong></p><p>Отрисовка:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">glUseProgram(program)</span><br><span class="line">vs_preview_bind_uniform(program)</span><br><span class="line">fs_preview_bind_uniform(program)</span><br><span class="line">draw_geometry_fragment(mesh)</span><br></pre></td></tr></table></figure><p><img src="/blog/4232971949/clip_1_small.png" alt="1"></p><h2 id="Клиппинг-плоскостями-отсечения"><a href="#Клиппинг-плоскостями-отсечения" class="headerlink" title="Клиппинг плоскостями отсечения"></a>Клиппинг плоскостями отсечения</h2><p>Изменим пиксельный шейдер отрисовки объекта:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[fragment_program (version=<span class="number">400</span>)]</span><br><span class="line">def fs_preview</span><br><span class="line">    <span class="comment">//если вершина отсекается плоскостями -- отбросить её</span></span><br><span class="line">    <span class="keyword">if</span> (f_worldpos.x &lt; f_crop_plane_x) || (f_worldpos.y &lt; f_crop_plane_y) || (f_worldpos.x &gt; f_crop_plane_x_max) || (f_worldpos.y &gt; f_crop_plane_y_max)</span><br><span class="line">        discard()</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">Установка uniform-переменных через панель imGui</span><br><span class="line">```cpp</span><br><span class="line">    Begin(<span class="string">"Crop params"</span>);</span><br><span class="line">    SliderFloat(<span class="string">"Crop plane X"</span>, safe_addr(f_crop_plane_x), <span class="number">-1.0f</span>, <span class="number">1.0f</span>)</span><br><span class="line">    SliderFloat(<span class="string">"Crop plane Xnax"</span>, safe_addr(f_crop_plane_x_max), <span class="number">-1.0f</span>, <span class="number">1.0f</span>)</span><br><span class="line">    SliderFloat(<span class="string">"Crop plane Y"</span>, safe_addr(f_crop_plane_y), <span class="number">-1.0f</span>, <span class="number">1.0f</span>)</span><br><span class="line">    SliderFloat(<span class="string">"Crop plane Ymax"</span>, safe_addr(f_crop_plane_y_max), <span class="number">-1.0f</span>, <span class="number">1.0f</span>)</span><br><span class="line">    End();</span><br></pre></td></tr></table></figure><br><img src="/blog/4232971949/clip_2_small.png" alt="2"></p><p>Сквозь отброшенные пиксели пока видны внутренние грани объекта.</p><h2 id="Заполнение-буфера-трафарета"><a href="#Заполнение-буфера-трафарета" class="headerlink" title="Заполнение буфера трафарета"></a>Заполнение буфера трафарета</h2><p>Исходная демка на three.js использует для описания состояния рендера концепцию <a href="https://github.com/daign/clipping-with-caps/blob/master/js/material.js" target="_blank" rel="noopener">материалов</a> этой библиотеки, но несложно сопоставить свойства материлов с параметрами OpenGL</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//упрощенный шейдер для вывода в буфер трафарета</span></span><br><span class="line">[fragment_program (version=<span class="number">400</span>)]</span><br><span class="line">def fs_preview_front</span><br><span class="line">    let not_inside_camera = (f_worldpos.x &lt; f_crop_plane_x) || (f_worldpos.y &lt; f_crop_plane_y) || (f_worldpos.x &gt; f_crop_plane_x_max) || (f_worldpos.y &gt; f_crop_plane_y_max)</span><br><span class="line">    <span class="keyword">if</span> not_inside_camera</span><br><span class="line">        discard()</span><br><span class="line">    f_FragColor = float4(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">//Включаем рендер в буфер трафарета, отключаем запись в буфера цвета и глубины</span></span><br><span class="line">glEnable(GL_STENCIL_TEST)</span><br><span class="line">glColorMask(<span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>)</span><br><span class="line">glDepthMask(<span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//установка шейдера</span></span><br><span class="line">glUseProgram(program_front)</span><br><span class="line">vs_preview_bind_uniform(program_front)</span><br><span class="line">fs_preview_front_bind_uniform(program_front)</span><br><span class="line"></span><br><span class="line"><span class="comment">//рендер только задних граней объекта с увеличением значения в буфере трафарета</span></span><br><span class="line">glEnable(GL_CULL_FACE);</span><br><span class="line">glCullFace(GL_FRONT);</span><br><span class="line">glStencilFunc(GL_ALWAYS, <span class="number">1</span>, <span class="number">0xFF</span>)</span><br><span class="line">glStencilOp(GL_KEEP, GL_KEEP, GL_INCR)</span><br><span class="line">draw_geometry_fragment(mesh)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Рендер только передних граней объекта с уменьшения значения в буфере трафарета</span></span><br><span class="line">glEnable(GL_CULL_FACE);</span><br><span class="line">glCullFace(GL_BACK);</span><br><span class="line">glStencilFunc(GL_ALWAYS, <span class="number">1</span>, <span class="number">0xFF</span>)</span><br><span class="line">glStencilOp(GL_KEEP, GL_KEEP, GL_DECR)</span><br><span class="line">draw_geometry_fragment(mesh)</span><br></pre></td></tr></table></figure><p>Вывод отсекающих граней:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;функция генерации прямоугольника заданного размера</span><br><span class="line">def gen_axis_rect(plt : GenDirection; x1, x2, y1, y2, coord: float)</span><br><span class="line">    var frag : GeometryFragment</span><br><span class="line">    frag.vertices &lt;- [&#123;GeometryPreviewVertex</span><br><span class="line">        xyz&#x3D;float3( x1, y1, coord), normal&#x3D;float3(  0, 0, 1),  uv&#x3D;float2(0,0);</span><br><span class="line">        xyz&#x3D;float3(x2, y1, coord), normal&#x3D;float3(  0, 0, 1),  uv&#x3D;float2(1,0);</span><br><span class="line">        xyz&#x3D;float3(x2,y2, coord), normal&#x3D;float3(  0, 0, 1),  uv&#x3D;float2(1,1);</span><br><span class="line">        xyz&#x3D;float3( x1,y2, coord), normal&#x3D;float3(  0, 0, 1),  uv&#x3D;float2(0,1)</span><br><span class="line">    &#125;]</span><br><span class="line">    apply_gen_direction_tm(plt, frag)</span><br><span class="line">    frag.indices &lt;- [&#123;int 0; 1; 2; 2; 3; 0 &#125;]</span><br><span class="line">    frag.prim &#x3D; GeometryFragmentType triangles</span><br><span class="line">    gen_bbox(frag)</span><br><span class="line">    return &lt;- frag</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">[fragment_program (version&#x3D;400)]</span><br><span class="line">def fs_preview_caps</span><br><span class="line">    f_FragColor &#x3D; float4(0.0, 1.0, 0.0, 1.0)</span><br><span class="line"></span><br><span class="line">glUseProgram(program_caps)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;отрисовка через полученную в буфере трафарета маску</span><br><span class="line">glStencilFunc(GL_EQUAL, 1, 0xFF)</span><br><span class="line">glStencilOp(GL_KEEP, GL_KEEP, GL_KEEP)</span><br><span class="line">vs_preview_bind_uniform(program_caps)</span><br><span class="line">fs_preview_caps_bind_uniform(program_caps)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;генерация отсекающих плоскостей</span><br><span class="line">var planeX &lt;- gen_axis_rect(GenDirection yz, 2.0, -2.0, f_crop_plane_y_max, f_crop_plane_y, -f_crop_plane_x) |&gt; create_geometry_fragment</span><br><span class="line">draw_geometry_fragment(planeX)</span><br><span class="line">var planeXMax &lt;- gen_axis_rect(GenDirection yz, 2.0, -2.0, f_crop_plane_y_max,f_crop_plane_y, -f_crop_plane_x_max) |&gt; create_geometry_fragment</span><br><span class="line">draw_geometry_fragment(planeXMax)</span><br><span class="line"></span><br><span class="line">var planeY &lt;- gen_axis_rect(GenDirection xz, f_crop_plane_x, f_crop_plane_x_max, 2.0, -2.0, f_crop_plane_y) |&gt; create_geometry_fragment</span><br><span class="line">draw_geometry_fragment(planeY)</span><br><span class="line">var planeYMax &lt;- gen_axis_rect(GenDirection xz, f_crop_plane_x, f_crop_plane_x_max, 2.0, -2.0, f_crop_plane_y_max) |&gt; create_geometry_fragment</span><br><span class="line">draw_geometry_fragment(planeYMax)</span><br></pre></td></tr></table></figure><p>Как отмечено в описании алгоритма <a href="https://github.com/daign/clipping-with-caps#clipping-with-caps" target="_blank" rel="noopener">референсной демки</a>, такой подход нормально работает с одной плоскостью отсечения, но с нескольими плоскостями даёт неверный результат (повёрнутые “от камеры” плоскости отсечения также вносят вклад в маску и портят результат в буфере трафарета — выводят лишние “дырки” или “крышки” в таких местах:</p><p><img src="/blog/4232971949/clip_3_small.png" alt="3"></p><h2 id="Коррекция-буфера-трафарета-для-граней-повернутых-от-камеры"><a href="#Коррекция-буфера-трафарета-для-граней-повернутых-от-камеры" class="headerlink" title="Коррекция буфера трафарета для граней, повернутых от камеры"></a>Коррекция буфера трафарета для граней, повернутых от камеры</h2><p>На этом этапе обнаруживаются отличия между демкой-референсом и примером из daScript. Позиция камеры в референсной демке попадает в шейдера “автоматически”, эта переменная <a href="https://threejs.org/docs/#api/en/renderers/webgl/WebGLProgram" target="_blank" rel="noopener">устанавливается</a> библиотекой three.js. Для примера на daScript нужно передать её вручную и учесть то, что системы координат в демках различаются. Поворот в примере daScript задаётся через матрицу <code>v_model</code>, так что для трансформации камеры в систему координат модели и плоскостей отсечения нужно также “довернуть” её, умножив на матрицу модели.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//позиция камеры в пространстве координат модели</span></span><br><span class="line">var [[uniform]] f_camera_position_rotated : float3</span><br><span class="line"></span><br><span class="line"><span class="comment">//шейдер для вывода в буфер трафарета</span></span><br><span class="line">[fragment_program (version=<span class="number">400</span>)]</span><br><span class="line">def fs_preview_front</span><br><span class="line">    <span class="comment">//let not_inside_camera =  (f_worldpos.x &lt; f_crop_plane_x) || (f_worldpos.y &lt; f_crop_plane_y) || (f_worldpos.x &gt; f_crop_plane_x_max) || (f_worldpos.y &gt; f_crop_plane_y_max)</span></span><br><span class="line">    let not_inside_camera = (f_worldpos.x &lt; f_crop_plane_x) &amp;&amp; (f_camera_position_rotated.x &gt; -f_crop_plane_x) || (f_worldpos.y &lt; f_crop_plane_y) &amp;&amp; (f_camera_position_rotated.y &lt; f_crop_plane_y) || (f_worldpos.x &gt; f_crop_plane_x_max) &amp;&amp; (f_camera_position_rotated.x &lt; -f_crop_plane_x_max) || (f_worldpos.y &gt; f_crop_plane_y_max) &amp;&amp; (f_camera_position_rotated.y &gt; f_crop_plane_y_max)</span><br><span class="line">    <span class="keyword">if</span> not_inside_camera</span><br><span class="line">        discard()</span><br><span class="line">    f_FragColor = float4(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">//поворот камеры в пространство координат модели</span></span><br><span class="line">let camPos = v_model * float4(camera_position, <span class="number">1.0</span>)</span><br><span class="line">f_camera_position_rotated = camPos.xyz</span><br></pre></td></tr></table></figure><p>Можно обратить внимание на идентичный синтаксис умножения вектора на матрицу в коде вершинного шейдера для трансфорфмации вершин меша,  и обычном скрипте на daScript.</p><p>Теперь наконец отсечения смотрятся корректно под любым углом.</p><p><img src="/blog/4232971949/clip_4_small.png" alt="4"></p><p><a href="https://github.com/spiiin/dascript_macro_tutorial/blob/master/clipping_with_caps/tutorial01.das" target="_blank" rel="noopener">Исходный код туториала</a></p><ul><li>daScript хорош, чтобы поиграться с демками графических эффектов :)</li><li>подход авторов к написанию байндингов — автоматическая обёртка на c/c++-функциями + “daScript-тификация” кода — создание макросов, упрощающих работу с библиотекой</li><li>вообще, демку стоило бы ещё перевести на режим <a href="https://github.com/borisbat/dasGlfw/blob/48f2715f0fe4cb8076866365a4bf0a29b7104765/dasglfw/glfw_live.das" target="_blank" rel="noopener">live-изменений</a>, тянет на отдельный туториал</li></ul><p>Ну и более глобальный вывод про совокупность всех фич языка — если большая часть кода на языке делает то, что сложно или долго делать на других языках, с какого-то момента разработки сама программа может получить какие-то свойства, которых нет у программ на других языках (потому что их было слишком долго или трудно реализовывать).</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Пример использования байдингов OpenGL для языка daScript&lt;br&gt;
    
    </summary>
    
    
    
      <category term="gamedev" scheme="http://spiiin.github.io/tags/gamedev/"/>
    
  </entry>
  
  <entry>
    <title>daScript macro</title>
    <link href="http://spiiin.github.io/blog/1547564887/"/>
    <id>http://spiiin.github.io/blog/1547564887/</id>
    <published>2022-02-06T18:04:42.000Z</published>
    <updated>2022-02-07T23:19:51.397Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p><a href="https://dascript.org/" target="_blank" rel="noopener">dacript</a> - скриптовый язык для игр от Gaijin Entertaiment.</p><p>После нескольких дней изучения понял, что испытываю интерес и хороший страх по отношению к этому языку. Такой, как если бы нашёл лазерную указку и решил поиграть с котом, но понял, что этой указкой можно легко резать металл. </p><p>Гайдзины делают не замену <code>Lua</code>, они делают замену <code>C++</code>! Точнее даже, не “делают”, а практически “сделали”, язык сейчас находится в версии 0.2, но полноценно используется ими в продакшене в <code>Warthunder</code>.</p><p>Доклад и документация акцентируют внимание на быстродействии языка и возможности серьёзных изменений без перезапуска игры, но только вскользь упоминают о мощных возможностях макросов. Так что я решил попробовать решить задачку, требующую их использования. Это моя первая программа на <code>daScript</code>, после трёх дней изучения, так что где-то возможны и неизбежны косяки.</p><a id="more"></a><h2 id="Задача"><a href="#Задача" class="headerlink" title="Задача"></a>Задача</h2><p>В качестве задачи выбрал такую, которую было бы нетривиально или сложно решить на C++:</p><blockquote><ul><li>Подсказка компилятору аллоцировать блок данных для структуры в линейном блоке памяти без явного написания кода работы с указателями в самой структуре</li></ul></blockquote><a href="/blog/1728194429/" title="C++ в геймдеве">C++ в геймдеве</a><p>Формулировка проблемы из видео про язык <a href="https://youtu.be/TH9VCN6UkyQ?t=4047" target="_blank" rel="noopener">Jai</a> — пример кода, в котором тривиальное объявление медленнее сложного, но быстрого.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Тривиальное объявление меша для моделей</span></span><br><span class="line"><span class="comment">//  2 аллокации, возможно в разных местах памяти</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Mesh</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Vector3&gt; positions;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; indexes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Более реальный вариант для продакшена</span></span><br><span class="line"><span class="comment">//  синтаксис сильно отличается от тривиального варианта </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Mesh</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span>* memblock = <span class="literal">nullptr</span>;</span><br><span class="line">    Vector3* positions = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">int</span>* indices = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">int</span> num_vertices = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> num_indices = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> positions_size = num_vertices * <span class="keyword">sizeof</span> (positions[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">int</span> indices_size = num_indices = <span class="keyword">sizeof</span>(indices[<span class="number">0</span>]);</span><br><span class="line">mesh-&gt;memory_block = <span class="keyword">new</span> <span class="keyword">char</span>[positions_size + indices_size];</span><br><span class="line">mesh-&gt;positions = (Vector3*)mesh-&gt;memblock;</span><br><span class="line">mesh-&gt;indices = (<span class="keyword">int</span>*)(mesh-&gt;memblock + positions_size);</span><br></pre></td></tr></table></figure><p>Второй вариант требует написания рутинного кода вручную при добавлении новых полей в структуру, а также ёмкий в плане количества переписывания кода из существующего. Если захочется переделать в таком стиле для ускорения несколько структур — для каждой потребуется ручная работа. Из-за этого большинство структур навсегда останутся описанными в первой, медленной форме.</p><p>Джонатан Блоу предлагает в качестве решения проблемы вариант синтаксиса своего языка, который позволит легко “переключить” структуру из медленной формы в быструю.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Mesh</span> &#123;</span></span><br><span class="line">    Vector3 []! positions;           <span class="comment">//[]! - семантика для указателя на память, которую должна выделить и освободить сама структура</span></span><br><span class="line">    <span class="keyword">int</span>[]! indices; @joint positions <span class="comment">//@joint - семантика для того, что попросить компилятор</span></span><br><span class="line">                                     <span class="comment">//    расположить данные в памяти одним блоком</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Я захотел попробовать реализовать подобную подсказку компилятору daScript с помощью макросов.</p><h2 id="Документация-к-daScript"><a href="#Документация-к-daScript" class="headerlink" title="Документация к daScript"></a>Документация к daScript</h2><p>Порядок изучения информации про язык:</p><ul><li>Доклад Антона Юдинцева<style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/IvHGczF6Go0" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></li><li>Инфа с оффициального сайта и <a href="https://dascript.org/doc/index.html" target="_blank" rel="noopener">документация</a></li><li><a href="https://youtu.be/inGb9R1NowY" target="_blank" rel="noopener">Live Stream Coding on daScript - Breakoid</a> - стрим с примером реализации арканоида, можно посмотреть на макросы и синтаксис системы ECS, реализованной с помощью макросов</li><li><a href="https://github.com/GaijinEntertainment/daScript/tree/073bc29145207b39180069ae60f00ed43fad6ea7/examples/tutorial" target="_blank" rel="noopener">Серия туториалов</a> - примеры привязки скриптов к C++, Ahead-of-Time компиляции, реализация генерации кода через cmake, архитектура игрового объекта с возможностью hot-reloading кода из скриптов.</li><li><a href="https://github.com/GaijinEntertainment/daScript/tree/073bc29145207b39180069ae60f00ed43fad6ea7/examples/test/misc" target="_blank" rel="noopener">Больше примеров кода</a>, в том числе несколько макросов</li><li><a href="https://github.com/GaijinEntertainment/daScript/tree/073bc29145207b39180069ae60f00ed43fad6ea7/daslib" target="_blank" rel="noopener">Стандартная библиотека</a> языка и <a href="https://github.com/GaijinEntertainment/daScript/tree/073bc29145207b39180069ae60f00ed43fad6ea7/modules" target="_blank" rel="noopener">модули</a>, можно использовать поиск по коду с гитхаба, чтобы найти пример использования той или иной фичи</li></ul><p>Макросы являются достаточно сложной темой, и освещены в документации daScript-а достаточно кратко, поэтому приведу несколько ссылок на туториалы из других языков:<br><a href="https://www.greghendershott.com/fear-of-macros/" target="_blank" rel="noopener">Fear of macros</a> - Racket<br><a href="https://rsdn.org/article/nemerle/NemerleStingFormating.xml" target="_blank" rel="noopener">Макросы в Nemerle</a> - Nemerle<br><a href="https://nim-lang.org/docs/tut3.html" target="_blank" rel="noopener">Nim Tutorial Part 3</a> - Nim</p><h2 id="Наивная-реализация"><a href="#Наивная-реализация" class="headerlink" title="Наивная реализация"></a>Наивная реализация</h2><p>Прежде, чем начинать шаманить с макросами, нужно набросать наивную реализацию “быстрой” версии класса, хранящего свои данные в одном блоке памяти. Для этого можно использовать <a href="https://tiorun.gaijin.team/##S0ksTi7KLCj5/z86taIgv6gklislNU0hNzEzj0sBCAqKMvNKNJQ8UnNy8nUUwvOLclIUlTS5/v8HAA" target="_blank" rel="noopener">онлайн компилятор tio</a>.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Memblock</span></span></span><br><span class="line"><span class="class">    <span class="title">mem</span> :</span> <span class="built_in">array</span>&lt;uint8&gt;</span><br><span class="line">    a: <span class="keyword">int</span>?</span><br><span class="line">    aCount: <span class="keyword">int</span></span><br><span class="line">    b: <span class="keyword">float</span>?</span><br><span class="line">    bCount: <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">initMemblock</span><span class="params">(var memblock: Memblock; aCount:<span class="keyword">int</span>; bCount:<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    let aSize </span>= typeinfo(<span class="keyword">sizeof</span> *memblock.a) * aCount</span><br><span class="line">    let bSize = typeinfo(<span class="keyword">sizeof</span> *memblock.b) * bCount</span><br><span class="line"></span><br><span class="line">    var arr: <span class="built_in">array</span>&lt;uint8&gt;</span><br><span class="line">    arr |&gt; resize(aSize + bSize )</span><br><span class="line">    memblock.mem &lt;- arr</span><br><span class="line"></span><br><span class="line">    memblock.aCount = aCount</span><br><span class="line">    memblock.bCount = bCount</span><br><span class="line">    unsafe</span><br><span class="line">        memblock.a = reinterpret&lt;<span class="keyword">int</span>?&gt; addr(memblock.mem[<span class="number">0</span>])</span><br><span class="line">        memblock.b = reinterpret&lt;<span class="keyword">float</span>?&gt; addr(memblock.mem[aSize])</span><br><span class="line"></span><br><span class="line">        memblock.a[<span class="number">0</span>] = <span class="keyword">int</span>(<span class="number">0x11223344</span>)</span><br><span class="line">        memblock.a[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">        memblock.a[<span class="number">2</span>] = <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        memblock.b[<span class="number">0</span>] = reinterpret&lt;<span class="keyword">float</span>&gt;(<span class="number">0x55667788</span>)</span><br><span class="line">        memblock.b[<span class="number">1</span>] = <span class="number">0.0</span></span><br><span class="line">        memblock.b[<span class="number">2</span>] = <span class="number">123.456</span></span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main</span><br><span class="line">    unsafe</span><br><span class="line">        var memblock: Memblock</span><br><span class="line">        memblock |&gt; initMemblock(<span class="number">5</span>,<span class="number">5</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Memblock = &#123;memblock&#125;"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Output:</span></span><br><span class="line"><span class="comment">//  Memblock = [[ [[0x44; 0x33; 0x22; 0x11; 0x0; 0x0; 0x0; 0x0; 0xff; 0xff; 0xff; 0xff; 0x0; 0x0;</span></span><br><span class="line"><span class="comment">//     0x0; 0x0; 0x0; 0x0; 0x0; 0x0; 0x88; 0x77; 0x66; 0x55; 0x0; 0x0; 0x0; 0x0; 0x79; 0xe9; 0xf6; </span></span><br><span class="line"><span class="comment">//     0x42; 0x0; 0x0; 0x0; 0x0; 0x0; 0x0; 0x0; 0x0]]; 287454020; 5; 15837566074880.000000000; 5]]</span></span><br></pre></td></tr></table></figure><p>Несколько замечаний про язык:</p><ul><li>Питоноподобный синтаксис с отступами. Для тех, кто не переносит такой формы синтаксиса, есть вариант без оступов, со скобочками и точками-с-запятыми.</li><li>Пайпы (<code>|&gt;</code> и <code>&lt;|</code>) как синтаксический сахар различных записи вызова функции (<a href="https://en.wikipedia.org/wiki/Uniform_Function_Call_Syntax" target="_blank" rel="noopener">UFCS</a>).</li><li>Более строгая типизация, чем в C/C++, из-за чего сложнее изучать язык и играться с ним — иногда приходится отвлекаться на то, чтобы разобраться, что именно компилятор от тебя хочет. По идее, должно помогать ловить в компайл-тайм больше того, что поймалось бы только в рантайме.</li><li><em>unsafe</em>, чтобы сказать компилятору “дай мне играться с указателями, как мне хочется, я знаю, что делаю”.</li><li>print умеет выводить внутренности структуры, можно убедиться, что данные действительно лежат в одном блоке памяти, как задумывалось.</li><li>Отсутствие семантики “=” для типов, для которых нет её однозначного определения. Вместо этого компилятор явно предлагает выбрать между клонированием (“:=”) и перемещением (“&lt;-“). В языке есть generic-функции, в них вроде можно попросить у компилятора данные о типах так, чтобы выбрать желаемое поведение.</li></ul><h2 id="Первый-макрос"><a href="#Первый-макрос" class="headerlink" title="Первый макрос"></a>Первый макрос</h2><p>Попробуем для начала написать простейший макрос, который выведет на экран список полей структуры. С этого момента не получится использовать онлайн компилятор, так как он не поддерживает загрузку кода из нескольких файлов, а макрос должен располагаться в отдельном модуле.</p><p>Причина того, что макрос не может находиться в том же модуле, что и структура, которую он обрабатывает, понятна — чтобы выполнить какой-либо код, обрабатывающий структуру на этапе компиляции, необходимо, чтобы сам этот код к этому моменту был уже скомпилирован.</p><p>В репозитории языка валяется готовый <a href="https://github.com/GaijinEntertainment/daScript/blob/073bc29145207b39180069ae60f00ed43fad6ea7/examples/test/misc/dump_fields.das" target="_blank" rel="noopener">пример</a> такого макроса, но в учебных целях немного перепишем его:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> macro_test</span><br><span class="line"></span><br><span class="line">require ast</span><br><span class="line">require daslib/ast_boost</span><br><span class="line"></span><br><span class="line">[structure_macro(name=memblock)]</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DumpFields</span> :</span> AstStructureAnnotation</span><br><span class="line">    <span class="function">def <span class="keyword">override</span> <span class="title">finish</span> <span class="params">( var st:StructurePtr; var group:ModuleGroup; args:AnnotationArgumentList; var errors : das_string )</span> : <span class="keyword">bool</span></span></span><br><span class="line"><span class="function">        <span class="title">print</span><span class="params">(<span class="string">"struct &#123;st.name&#125; \&#123;\n"</span>)</span></span></span><br><span class="line">        for field in st.fields</span><br><span class="line">            print(<span class="string">"\t&#123;describe_cpp(field._type)&#125; &#123;field.name&#125;;\n"</span>)</span><br><span class="line">        print(<span class="string">"\&#125;\n"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>Макрос наследуется от класса <code>AstStructureAnnotation</code>, определённого в модуле <a href="https://github.com/GaijinEntertainment/daScript/blob/073bc29145207b39180069ae60f00ed43fad6ea7/src/builtin/ast.das#L75" target="_blank" rel="noopener">ast</a>, который представляет собой шаблон для аннотации структуры. К самому классу также применяется аннотация <code>structure_macro</code>, которая регистрирует данный макрос для применения к каждой структуре, отмеченной аннотацией <code>memblock</code>.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AstStructureAnnotation</span></span></span><br><span class="line"><span class="class">    <span class="title">def</span> <span class="title">abstract</span> <span class="title">apply</span> ( <span class="title">var</span> <span class="title">st</span>:</span>StructurePtr; var group:ModuleGroup; args:AnnotationArgumentList; var errors : das_string ) : <span class="keyword">bool</span></span><br><span class="line">    <span class="function">def abstract <span class="title">finish</span> <span class="params">( var st:StructurePtr; var group:ModuleGroup; args:AnnotationArgumentList; var errors : das_string )</span> : <span class="keyword">bool</span></span></span><br><span class="line"><span class="function">    def abstract <span class="title">patch</span> <span class="params">( var st:StructurePtr; var group:ModuleGroup; args:AnnotationArgumentList; var errors : das_string; var astChanged:<span class="keyword">bool</span>&amp; )</span> : <span class="keyword">bool</span></span></span><br></pre></td></tr></table></figure><p>Интерфейс макроса позволяет переопределить три функции, чтобы “вклиниться” в процесс того, как компилятор обрабатывает определения структуры, на различных этапах. <a href="https://dascript.org/doc/reference/language/macros.html?highlight=macro#compilation-passes" target="_blank" rel="noopener">Документация по фазам компиляции</a>. <code>Apply</code> - наиболее подходящий момент, чтобы попробовать изменить поля структуры или сгенерировать код.</p><p>Если теперь отметить описание структуры аннотацией <code>memblock</code>, то компилятор “пропустит” её определение через макрос, который выведет названия полей на экран. В момент обработки информация о создаваемой структуре хранится в классе <code>StructurePtr</code>, определение которого можно найти поиском по C++ коду. На данном этапе макрос просто проходит по всем полям структуры и выводит информацию о каждом из них на экран. <code>describe_cpp</code> - это функция, которая выводит определения типа, как если бы он был объявлен в C++.</p><p>При запуске приложения на экран выведется:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct Memblock &#123;</span><br><span class="line">    TArray&lt;uint8_t&gt; mem;</span><br><span class="line">    int32_t * a;</span><br><span class="line">    int32_t aСount;</span><br><span class="line">    int32_t * b;</span><br><span class="line">    int32_t bCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Можно немного поиграться с определением макроса:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[structure_macro(name=memblock)]</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenMemblock</span> :</span> AstStructureAnnotation</span><br><span class="line">    <span class="function">def <span class="keyword">override</span> <span class="title">apply</span> <span class="params">( var st:StructurePtr; var group:ModuleGroup; args:AnnotationArgumentList; var errors : das_string )</span> : <span class="keyword">bool</span></span></span><br><span class="line">        var mkS &lt;- new [[ Structure() ]]         //создаём новую структуру</span><br><span class="line">        mkS.name := <span class="string">"MemblockTest"</span>               <span class="comment">//с именем MemblockTest</span></span><br><span class="line">        let fieldsLen = st.fields |&gt; length</span><br><span class="line">        mkS.fields |&gt; resize(fieldsLen)       </span><br><span class="line">        <span class="keyword">for</span> i in range(<span class="number">0</span>, fieldsLen)</span><br><span class="line">            mkS.fields[i] := st.fields[i]        <span class="comment">//копируем в неё все поля из обрабатываемой структуры</span></span><br><span class="line">        compiling_module() |&gt; add_structure(mkS) <span class="comment">//добавляем в компилирующийся сейчас модуль новый тип</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Скрипт, использующий модуль с макросом</span></span><br><span class="line">require macro_test</span><br><span class="line"></span><br><span class="line">[memblock]</span><br><span class="line">struct Memblock</span><br><span class="line">    mem : <span class="built_in">array</span>&lt;uint8&gt;</span><br><span class="line">    a: <span class="keyword">int</span>?</span><br><span class="line">    aCount: <span class="keyword">int</span></span><br><span class="line">    b: <span class="keyword">float</span>?</span><br><span class="line">    bCount: <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">var memblock1: Memblock</span><br><span class="line">var memblock2: MemblockTest <span class="comment">//ага, новый тип MemblockTest!</span></span><br><span class="line">print(<span class="string">"MemblockTest = &#123;memblock2&#125;"</span>)</span><br></pre></td></tr></table></figure><h2 id="Генерация-полей"><a href="#Генерация-полей" class="headerlink" title="Генерация полей"></a>Генерация полей</h2><p>Следующим шагом попробуем убрать поле <code>mem</code> из исходной структуры, и создать его из макроса.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[structure_macro(name=memblock)]</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenMemblock</span> :</span> AstStructureAnnotation</span><br><span class="line">    <span class="function">def <span class="keyword">override</span> <span class="title">apply</span> <span class="params">( var st:StructurePtr; var group:ModuleGroup; args:AnnotationArgumentList; var errors : das_string )</span> : <span class="keyword">bool</span></span></span><br><span class="line">        var mkS &lt;- new [[ Structure() ]]</span><br><span class="line">        mkS.name := <span class="string">"MemblockTest"</span></span><br><span class="line">        let fieldsLen = st.fields |&gt; length</span><br><span class="line">        mkS.fields |&gt; resize(fieldsLen+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//определение типа uint8, как это видит компилятор</span></span><br><span class="line">        var uint8Type &lt;- <span class="keyword">new</span> [[TypeDecl() baseType=Type tUInt8]]</span><br><span class="line">        <span class="comment">//определение array&lt;uint8&gt; </span></span><br><span class="line">        var uint8ArrayType &lt;- <span class="keyword">new</span> [[TypeDecl() baseType=Type tArray, firstType &lt;- uint8Type]]</span><br><span class="line">        <span class="comment">//декларация нового поля с именем mem и типом array&lt;uint8&gt; </span></span><br><span class="line">        mkS.fields[<span class="number">0</span>] := *<span class="keyword">new</span> [[ FieldDeclaration() name:=<span class="string">"mem"</span>, _type &lt;- uint8ArrayType]]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i in range(<span class="number">0</span>, fieldsLen)</span><br><span class="line">            mkS.fields[i+<span class="number">1</span>] := st.fields[i]</span><br><span class="line">        compiling_module() |&gt; add_structure(mkS)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Скрипт, использующий модуль с макросом</span></span><br><span class="line">[memblock]</span><br><span class="line">struct Memblock</span><br><span class="line">    <span class="comment">//mem : array&lt;uint8&gt;  //теперь поля нет в исходной структуре</span></span><br><span class="line">    a: <span class="keyword">int</span>?</span><br><span class="line">    aCount: <span class="keyword">int</span></span><br><span class="line">    b: <span class="keyword">float</span>?</span><br><span class="line">    bCount: <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">var memblock: MemblockTest</span><br><span class="line"><span class="comment">//у структуры MemblockTest появилось поле mem, сгенерированное макросом</span></span><br><span class="line">print(<span class="string">"MemblockTest = &#123;memblock.mem&#125;"</span>)</span><br></pre></td></tr></table></figure><ul><li>функция <code>resize</code> изменяет размер массива, <a href="https://dascript.org/doc/stdlib/builtin.html#containers" target="_blank" rel="noopener">документация</a> функций для работы с контейерами.</li><li>можно изменять поля определяемой структуры прямо на месте - макрос выполняется в сам момент её определения. Создание новой структуры с другим именем сделано для наглядности примера.</li><li>генерация структур компилятора для определения поля сперва выглядит немного “космически”, дальше будет пример использования функции <code>quote</code>, которая позволяет перевести код как его писал бы человек, в выражение, которое сгенерирует компилятор при парсинге этого кода. Но полезно разобраться с таким способом генерации кода, чтобы привыкнуть к нему. Также стоит найти определения <code>TypeDecl</code> и <code>FieldDeclaration</code> в исходном коде компилятора, это самая надёжная документация.</li><li>“оператор” обращения к конкретному значению перечисления — пробел (<code>Type tArray</code> - значение <code>tArray</code> перечисления <code>Type</code>). Очень необычное решение.</li><li>при кодогенерации необходимо заботиться о том, чтобы сгенерированное имя не пересекалось с тем, которое может захотеть использовать программист. В этом смысле <code>mem</code> — плохое имя для сгенерированного поля, в реальном коде необходимо было бы какое-либо соглашение об именах, авторы языка используют символ ‘`’ (гравис, backquote) для отметки генерированного кода.</li></ul><p>Таким же образом можно перенести поля <code>aCount</code> и <code>bCount</code> в генерирующий макрос:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[structure_macro(name=memblock)]</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenMemblock</span> :</span> AstStructureAnnotation</span><br><span class="line">    <span class="function">def <span class="keyword">override</span> <span class="title">apply</span> <span class="params">( var st:StructurePtr; var group:ModuleGroup; args:AnnotationArgumentList; var errors : das_string )</span> : <span class="keyword">bool</span></span></span><br><span class="line"><span class="function">        <span class="comment">//create "mem" field of type array&lt;uint8&gt;</span></span></span><br><span class="line">        var uint8Type &lt;- new [[TypeDecl() baseType=Type tUInt8]]</span><br><span class="line">        var uint8ArrayType &lt;- <span class="keyword">new</span> [[TypeDecl() baseType=Type tArray, firstType &lt;- uint8Type]]</span><br><span class="line"></span><br><span class="line">        let fieldsLen = st.fields |&gt; length</span><br><span class="line">        var ptrsCount = <span class="number">0</span></span><br><span class="line">        var ptrsTypeIndexes : <span class="built_in">array</span>&lt;<span class="keyword">int</span>&gt;</span><br><span class="line">        ptrsTypeIndexes |&gt; reserve(fieldsLen)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Проходим по списку всех полей и сохраняем индексы полей, тип которых -- указатель</span></span><br><span class="line">        <span class="keyword">for</span> i in range(<span class="number">0</span>, fieldsLen)</span><br><span class="line">            <span class="keyword">if</span> st.fields[i]._type.baseType == Type tPointer <span class="comment">//проверка типа поля</span></span><br><span class="line">                ptrsCount++</span><br><span class="line">                ptrsTypeIndexes |&gt; push(i)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//add one field for memblock and one field per pointer type to handle count of object per type</span></span><br><span class="line">        st.fields |&gt; resize(fieldsLen+ ptrsCount + <span class="number">1</span>)</span><br><span class="line">        st.fields[fieldsLen] := *<span class="keyword">new</span> [[ FieldDeclaration() name:=<span class="string">"mem"</span>, _type &lt;- uint8ArrayType]]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i in range(<span class="number">0</span>, ptrsCount)</span><br><span class="line">            <span class="comment">//генерируем имя поля - добавляем к нему постфикс `count</span></span><br><span class="line">            let fieldCountName = <span class="string">"&#123;st.fields[ptrsTypeIndexes[i]].name&#125;&#123;"</span>`count<span class="string">"&#125;"</span></span><br><span class="line">            <span class="comment">//генерируем новое поля типа int для каждого поля</span></span><br><span class="line">            st.fields[fieldsLen+<span class="number">1</span>+i] := *<span class="keyword">new</span> [[ FieldDeclaration() name:=fieldCountName, _type &lt;- <span class="keyword">new</span> [[TypeDecl() baseType=Type tInt]]]]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">[memblock]</span><br><span class="line"><span class="comment">//сама структура теперь содержит только определение полей</span></span><br><span class="line">struct Memblock</span><br><span class="line">    a: <span class="keyword">int</span>?</span><br><span class="line">    b: <span class="keyword">float</span>?</span><br><span class="line"></span><br><span class="line"><span class="comment">//вывод скрипта -- сгенерированные поля</span></span><br><span class="line">struct Memblock &#123;</span><br><span class="line">        <span class="keyword">int32_t</span> * a;</span><br><span class="line">        <span class="keyword">float</span> * b;</span><br><span class="line">        TArray&lt;<span class="keyword">uint8_t</span>&gt; mem;</span><br><span class="line">        <span class="keyword">int32_t</span> a`count;</span><br><span class="line">        <span class="keyword">int32_t</span> b`count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Разумеется, в реальном мире бывают структуры, которые могут содержать одновременно как указатели на память, которую должна выделять и освобождать сама структура, так и те, которые указывают на память, которую структура трогать не должна. Пока что мы считаем, что структура, отмеченная как <code>memblock</code>, содержит только указатели на память, которую выделяет и освобождает сама. Забегая наперёд, реализовать поддержку обоих типов указателей можно с помощью аннотаций типа (я не нашёл ссылок на аннотации в документации, но их можно найти в коде (<a href="https://github.com/borisbat/dasBGFX/blob/a1e10ab439e5996a0a4d8722689e2b0fab4e72d9/examples/01_hello_triangle.das#L7" target="_blank" rel="noopener">пример</a>)). Аннотации типа будут рассмотрены сильно дальше, при реализации наследования от memblock-структур.</p><p>На данном этапе мы получили возможность описать структуру с любым количеством полей, и с помощью макроса сгенерировать по этому описанию недостающие поля. К сожалению, функцию <code>initMemblock</code> (конструктор структуры), по прежнему необходимо писать руками, что очень неприятно.</p><h2 id="Подготовка-к-генерация-кода-конструктора"><a href="#Подготовка-к-генерация-кода-конструктора" class="headerlink" title="Подготовка к генерация кода конструктора"></a>Подготовка к генерация кода конструктора</h2><p>Для начала стоит немного переписать код <code>initMemblock</code>, чтобы отделить часть инициализации структуры, которую нужно сгенерировать. Также добавлено третье поле, для того, чтобы увидеть, какие изменения потребуется сейчас внести в код <code>initMemblock</code></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//аннотация того, что к структуре надо применить 2 макроса, добавляющий поля, и дебажный, отображающий все поля</span></span><br><span class="line">[memblock, dump_fields]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Memblock</span></span></span><br><span class="line"><span class="class">    <span class="title">a</span>:</span> <span class="keyword">int</span>?</span><br><span class="line">    b: <span class="keyword">float</span>?</span><br><span class="line">    c: <span class="keyword">int</span>?</span><br><span class="line"></span><br><span class="line"><span class="comment">//Шаблонный код инициализации, типовой для memblock-структур</span></span><br><span class="line"><span class="comment">//  необходимо научиться генерировать его, чтобы не писать руками для каждой структуры</span></span><br><span class="line"><span class="function">def <span class="title">initMemblock</span><span class="params">(var memblock: Memblock; aCount:<span class="keyword">int</span>; bCount:<span class="keyword">int</span>; cCount:<span class="keyword">int</span>)</span></span></span><br><span class="line">    memblock.a`count = aCount</span><br><span class="line">    memblock.b`count = bCount</span><br><span class="line">    memblock.c`count = cCount                                          <span class="comment">//новое</span></span><br><span class="line"></span><br><span class="line">    let aSize = typeinfo(<span class="keyword">sizeof</span> *memblock.a) * aCount</span><br><span class="line">    let bSize = typeinfo(<span class="keyword">sizeof</span> *memblock.b) * bCount</span><br><span class="line">    let cSize = typeinfo(<span class="keyword">sizeof</span> *memblock.c) * cCount                  <span class="comment">//новое</span></span><br><span class="line"></span><br><span class="line">    memblock.mem |&gt; resize(aSize + bSize + cSize)                      <span class="comment">//новое</span></span><br><span class="line"></span><br><span class="line">    unsafe</span><br><span class="line">        memblock.a = reinterpret&lt;<span class="keyword">int</span>?&gt; addr(memblock.mem[<span class="number">0</span>])</span><br><span class="line">        memblock.b = reinterpret&lt;<span class="keyword">float</span>?&gt; addr(memblock.mem[aSize])</span><br><span class="line">        memblock.c = reinterpret&lt;<span class="keyword">int</span>?&gt; addr(memblock.mem[aSize+bSize]) <span class="comment">//новое</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Пример использования структуры</span></span><br><span class="line">def fillMemblock(var memblock: Memblock)</span><br><span class="line">    unsafe</span><br><span class="line">        memblock.a[<span class="number">0</span>] = <span class="keyword">int</span>(<span class="number">0x11223344</span>)</span><br><span class="line">        memblock.a[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">        memblock.a[<span class="number">2</span>] = <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        memblock.b[<span class="number">0</span>] = reinterpret&lt;<span class="keyword">float</span>&gt;(<span class="number">0x55667788</span>)</span><br><span class="line">        memblock.b[<span class="number">1</span>] = <span class="number">0.0</span></span><br><span class="line">        memblock.b[<span class="number">2</span>] = <span class="number">123.456</span></span><br><span class="line"></span><br><span class="line">        memblock.c[<span class="number">0</span>] = <span class="keyword">int</span>(<span class="number">0xAABBCCDD</span>)</span><br><span class="line">        memblock.c[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">        memblock.c[<span class="number">2</span>] = <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Тест</span></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def test</span><br><span class="line">    unsafe</span><br><span class="line">        var memblock: Memblock</span><br><span class="line">        memblock |&gt; initMemblock(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>) <span class="comment">//кол-во аргументов конструктора, зависит от количества полей структуры</span></span><br><span class="line">        memblock |&gt; fillMemblock</span><br><span class="line">        print(<span class="string">"Memblock = &#123;memblock&#125;"</span>)</span><br></pre></td></tr></table></figure><p>Прежде, чем приступать к написанию макроса, генерирующего функцию <code>initMemblock</code>, стоит разобраться с парой примеров:</p><p><a href="https://github.com/GaijinEntertainment/daScript/blob/073bc29145207b39180069ae60f00ed43fad6ea7/examples/test/misc/gen_fields.das" target="_blank" rel="noopener">gen_field.das</a> — генерация функции, логгирующей создание полей структуры.</p><ul><li>Приведены два макроса <code>DumpFields</code> и <code>Dump2Fields</code>, работающие на различных стадиях (apply/finish), во время генерации структуры, и после окончания.</li><li>На момент написание заметки пример был сломан, для фикса необходимо убрать код, касающийся типа <code>EntityId</code> — видимо, пример выдран из какого-то более масштабного кода, и опредения то ли забыли перенести, то ли забыли добавить модуль, содержащий их.</li><li>флаг функции “<code>fn.flags |= FunctionFlags init</code>“ говорит компилятору о том, что функция должна быть вызвана сразу после генерации (я какое-то время тупил с тем, чтобы понять, на какой стадии компиляции, кто и почему её вызывает).</li></ul><p><a href="https://github.com/GaijinEntertainment/daScript/blob/073bc29145207b39180069ae60f00ed43fad6ea7/examples/test/misc/ast_print.das" target="_blank" rel="noopener">ast_print.das</a> - макрос, выводящий исходный текст на dascript переданного ему выражения на daScript.</p><ul><li>этот пример в репозитории тоже немного сломан (<a href="https://github.com/spiiin/dascript_macro_tutorial/blob/master/examples/ast_print.das" target="_blank" rel="noopener">Fixed version</a>)</li></ul><p>Теперь применим немного рекурсивной магии.</p><p>Этот макрос может быть очень полезным, если переделать его так, чтобы он печатал не исходный текст переданного ему выражения, а исходный текст МАКРОСА, генерирующего при выполнении само это выражение.</p><p>Это очень важная для упрощения метапрограммирования часть, поэтому повторю ещё раз. Вместо написания макроса, генерирующего функцию <code>initMemblock</code>, мы сначала напишем <strong><code>макрос ast_print_expression, который выведет на экран текст, который поможет нам написать макрос generateInitMemblockFunction, генерирующий функцию initMemblock</code></strong> (или любую другую функцию). Звучит запутанно, но это не так сложно, как кажется.<br>(всё, больше не буду повторять, язык сломать можно)</p><p>Модифицируем функцию <code>ast_print</code> так, чтобы она не просто печатала исходный текст переданного ей выражения, а дополнительно печатала тип каждого подвыражения (<code>Subexpression</code>) этого выражения.<br>Вот такая функция:<br><a href="https://github.com/spiiin/dascript_macro_tutorial/blob/master/examples/macro_print_ast.das" target="_blank" rel="noopener">ast_print_expression</a> (конечно, немного “наколенная”)</p><p>Теперь можно начать последовательно копировать типы подвыражений в макрос, генерирующий функцию <code>initMemblock</code>, постепенно модифицируя его так, чтобы добавлять параметры, позволяющие генерировать различные варианты этой функции.</p><p>Рабочий процесс на этом этапе удобно зациклить так:</p><ul><li>Модифицируем текст initMemblock</li><li>Перезапускаем компиляцию функции, чтобы макрос ast_print_expression применился к этой функции и вывел на экран выражение, в которое преобразуется функция</li><li>Копируем часть выражения в макрос generateInitMemblockFunction, который должен сгенерировать новую функцию initMemblock_generated, идентичную самой функции initMemblock</li><li>Модифицируем макрос generateInitMemblockFunction, чтобы добавить в него код, генерирующий переменную часть функции</li><li>Перекомпилируем функцию initMemblock_generated, чтобы применить к ней макрос ast_print, для того, чтобы получить исходный код функции и сверить его с исходный кодом initMemblock</li></ul><p>Выглядит запутанно, но это необходимо для того, чтобы иметь возможность выполнить шаг 4 - “переменная часть функции” — те строчки, которые изменяются в функции <code>initMemblock</code> после того, как мы изменяем какое-либо поле структуры <code>Memblock</code> (посмотрите исходный код функции <code>initMemblock</code> и отметки <code>//новое</code>, это строчки, которые добавились после добавления поля с именем <code>c</code> — это как раз эта “переменная часть функции”).</p><p>Самое интересное, что перевести программу в режим REPL практически элементарно, достаточно зациклить C++ часть самого первого туториала из репозитория daScript, перекомпилируя daScript-ы заново при вводе любого символа:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span>, <span class="keyword">char</span> * [] )</span> </span>&#123;</span><br><span class="line">    NEED_ALL_DEFAULT_MODULES;</span><br><span class="line">    Module::Initialize();</span><br><span class="line">    <span class="keyword">char</span> a = <span class="string">'x'</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        tutorial();</span><br><span class="line">        <span class="comment">//тут скорее всего надо не забыть очистить память, выделенную в цикле работы</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">    &#125;</span><br><span class="line">    Module::Shutdown();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Рабочий процесс выглядит примерно так:<br><img src="/blog/1547564887/memblock_example.png" alt="fox"><br>Слева код в <a href="https://marketplace.visualstudio.com/items?itemName=profelis.dascript-plugin" target="_blank" rel="noopener">Visual Studio Code</a>, справа программа, выполняющая этот код без необходимости перезапуска. После подготовки можно переходить и к генерации кода, с Repl-режимом это будет значительно проще.</p><h2 id="Генерация-функции-initMemblock"><a href="#Генерация-функции-initMemblock" class="headerlink" title="Генерация функции initMemblock"></a>Генерация функции initMemblock</h2><p>Макрос <code>ast_print_expression</code> применённый к функции initMemblock, выводит на экран:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">---das------------------<span class="comment">// [modifyExternal][modifyArgument]</span></span><br><span class="line"><span class="function">def <span class="title">initMemblock</span> <span class="params">( var memblock : Memblock -<span class="keyword">const</span>; aCount : <span class="keyword">int</span> <span class="keyword">const</span>; bCount : <span class="keyword">int</span> <span class="keyword">const</span>; cCount : <span class="keyword">int</span> <span class="keyword">const</span> )</span></span></span><br><span class="line">        ExprVar memblock. ExprField a`count ExprCopyRight = ExprVar aCount</span><br><span class="line">        ExprVar memblock. ExprField b`count ExprCopyRight = ExprVar bCount</span><br><span class="line">        ExprVar memblock. ExprField c`count ExprCopyRight = ExprVar cCount</span><br><span class="line">        ExprLet var  ExprLetVariable aSize : <span class="keyword">int</span> <span class="keyword">const</span> =  ExprOp2(ExprVar aCount ExprOp2Right * <span class="number">4</span>)</span><br><span class="line">        ExprLet var  ExprLetVariable bSize : <span class="keyword">int</span> <span class="keyword">const</span> =  ExprOp2(ExprVar bCount ExprOp2Right * <span class="number">4</span>)</span><br><span class="line">        ExprLet var  ExprLetVariable cSize : <span class="keyword">int</span> <span class="keyword">const</span> =  ExprOp2(ExprVar cCount ExprOp2Right * <span class="number">4</span>)</span><br><span class="line">        ExprCall __::builtin`resize( ExprCallArgument ExprVar memblock. ExprField mem, ExprCallArgument  ExprOp2( ExprOp2(ExprVar aSize ExprOp2Right + ExprVar bSize) ExprOp2Right + ExprVar cSize))</span><br><span class="line">        ExprVar memblock. ExprField a ExprCopyRight = ExprCast reinterpret&lt;<span class="keyword">int</span>?&gt;  VisitExprRef2Ptr addr(ExprVar memblock. ExprField mem ExprAtIndex[<span class="number">0</span>])</span><br><span class="line">        ExprVar memblock. ExprField b ExprCopyRight = ExprCast reinterpret&lt;<span class="keyword">float</span>?&gt;  VisitExprRef2Ptr addr(ExprVar memblock. ExprField mem ExprAtIndex[ExprVar aSize])</span><br><span class="line">        ExprVar memblock. ExprField c ExprCopyRight = ExprCast reinterpret&lt;<span class="keyword">int</span>?&gt;  VisitExprRef2Ptr addr(ExprVar memblock. ExprField mem ExprAtIndex[ ExprOp2(ExprVar aSize ExprOp2Right + ExprVar bSize)])</span><br><span class="line">        ExprCall init`struct`Memblock( ExprCallArgument ExprVar memblock, ExprCallArgument <span class="number">5</span>, ExprCallArgument <span class="number">5</span>, ExprCallArgument <span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>Здесь перед каждым daScript выражением показан тип этого выражения. Почти все типы выражений объявлены в заголовочных файлах <a href="https://github.com/GaijinEntertainment/daScript/tree/master/include/daScript/ast" target="_blank" rel="noopener">ast_*.h</a>.</p><blockquote><p>С определенного момента начинаешь ценить простые языки — вместо того, что изучать сложные и разрастающиеся правила языка, можно упростить их, чтобы ускорить изучение языка и сделать его более понятным, но при этом дать возможность задавать более сложные правила только в тех местах, где они действительно нужны программисту.</p></blockquote><p><strong><code>Работа с макросами сначала кажется сложной, но с какого-то момента понимаешь, что типичная программа содержит почти все распространённые типы выражений, и понимаешь, что вот они, все перед тобой, других, скрытых мелким шрифтом в примечаниях на 666-й странице стандарта, нет.</code></strong></p><p>Можно было бы пойти ещё дальше, и написать макрос, который выводит код, создающий выражение, но в образовательных целях можно попробовать для начала составить выражения вручную.</p><p>Для генерации функции нужно научиться генерировать строки 5 типов:</p><ul><li>Декларация функции <code>def initMemblock ( var memblock : Memblock, ...)</code></li><li>Присваивание  <code>memblock.a</code>count = aCount`</li><li>Объвление переменной <code>let aSize = typeinfo(sizeof *memblock.a) * aCount</code></li><li>Вызов функции <code>memblock.mem |&gt; resize(aSize + bSize + cSize)</code></li><li>Ещё одно присвание - <code>memblock.a = reinterpret&lt;int?&gt; addr(memblock.mem[0])</code></li></ul><p><strong><code>Декларация функции</code></strong></p><p>Практически готовый пример нужного кода есть в примерах из daScript-a <code>gen_field.das</code>.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">generateStructureFields</span><span class="params">(var st:StructurePtr)</span></span></span><br><span class="line"><span class="function">    <span class="comment">//create "mem" field of type array&lt;uint8&gt;</span></span></span><br><span class="line">    var uint8Type &lt;- new [[TypeDecl() baseType=Type tUInt8]]</span><br><span class="line">    var uint8ArrayType &lt;- <span class="keyword">new</span> [[TypeDecl() baseType=Type tArray, firstType &lt;- uint8Type]]</span><br><span class="line"></span><br><span class="line">    let fieldsLen = st.fields |&gt; length</span><br><span class="line">    var ptrsCount = <span class="number">0</span></span><br><span class="line">    var ptrsTypeIndexes : <span class="built_in">array</span>&lt;<span class="keyword">int</span>&gt;</span><br><span class="line">    ptrsTypeIndexes |&gt; reserve(fieldsLen)</span><br><span class="line">    <span class="keyword">for</span> i in range(<span class="number">0</span>, fieldsLen)</span><br><span class="line">        <span class="keyword">if</span> st.fields[i]._type.baseType == Type tPointer</span><br><span class="line">            ptrsCount++</span><br><span class="line">            ptrsTypeIndexes |&gt; push(i) <span class="comment">//сохраняем индексы полей-указателей</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//add one field for memblock and one field per pointer type to handle count of object per type</span></span><br><span class="line">    st.fields |&gt; resize(fieldsLen+ ptrsCount + <span class="number">1</span>)</span><br><span class="line">    st.fields[fieldsLen] := *<span class="keyword">new</span> [[ FieldDeclaration() name:=<span class="string">"mem"</span>, _type &lt;- uint8ArrayType]]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i in range(<span class="number">0</span>, ptrsCount)</span><br><span class="line">        let fieldCountName = <span class="string">"&#123;st.fields[ptrsTypeIndexes[i]].name&#125;&#123;"</span>`count<span class="string">"&#125;"</span></span><br><span class="line">        st.fields[fieldsLen+<span class="number">1</span>+i] := *<span class="keyword">new</span> [[ FieldDeclaration() name:=fieldCountName, _type &lt;- <span class="keyword">new</span> [[TypeDecl() baseType=Type tInt]]]]</span><br><span class="line">    <span class="keyword">return</span> &lt;-ptrsTypeIndexes</span><br><span class="line"></span><br><span class="line"><span class="comment">//--------------------------</span></span><br><span class="line"><span class="comment">// Генерация функции</span></span><br><span class="line">def generateStructureInitFunction(var st:StructurePtr; ptrsTypeIndexes:<span class="built_in">array</span>&lt;<span class="keyword">int</span>&gt;&amp;)</span><br><span class="line">    let ptrFieldsLen = ptrsTypeIndexes |&gt; length</span><br><span class="line"></span><br><span class="line">    let fnname = <span class="string">"init`struct`&#123;st.name&#125;"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//генерируем объявление функции с именем init`struct`ИмяСтрутуры</span></span><br><span class="line">    var fn &lt;- <span class="keyword">new</span> [[Function() at=st.at, atDecl=st.at, name:=fnname]]</span><br><span class="line">    fn.flags |= FunctionFlags generated</span><br><span class="line">    fn.flags |= FunctionFlags privateFunction</span><br><span class="line"></span><br><span class="line">    <span class="comment">//генерируем список аргументов и тип результата функции</span></span><br><span class="line">    unsafe</span><br><span class="line">        fn.arguments |&gt; emplace_new &lt;| <span class="keyword">new</span> [[Variable() at=st.at, name:= <span class="string">"memblock"</span>, _type &lt;- <span class="keyword">new</span> [[TypeDecl() baseType=Type tStructure, structType=addr(*st)]]]]</span><br><span class="line">    <span class="keyword">for</span> i in range(<span class="number">0</span>, ptrFieldsLen)</span><br><span class="line">        let argumentName = <span class="string">"&#123;st.fields[ptrsTypeIndexes[i]].name&#125;`count"</span></span><br><span class="line">        fn.arguments |&gt; emplace_new &lt;| <span class="keyword">new</span> [[Variable() at=st.at, name:= argumentName,  _type &lt;- <span class="keyword">new</span> [[TypeDecl() baseType=Type tInt]] ]]</span><br><span class="line">    fn.result &lt;- <span class="keyword">new</span> [[TypeDecl() baseType=Type tVoid, at=st.at]]</span><br><span class="line"></span><br><span class="line">    <span class="comment">//генерируем тело функции, пока просто вызов `print("Hello, world!")`</span></span><br><span class="line">    var blk &lt;- <span class="keyword">new</span> [[ExprBlock() at=st.at]]</span><br><span class="line">    var printF &lt;- <span class="keyword">new</span> [[ExprCall() name:=<span class="string">"print"</span>]]</span><br><span class="line">    printF.arguments |&gt; emplace_new &lt;| <span class="keyword">new</span> [[ExprConstString() value:=<span class="string">"Hello, world!\n"</span>]]</span><br><span class="line">    blk.<span class="built_in">list</span> |&gt; emplace(printF)</span><br><span class="line"></span><br><span class="line">    fn.body &lt;- blk</span><br><span class="line">    compiling_module() |&gt; add_function(fn)</span><br></pre></td></tr></table></figure><p>Теперь если сгенерировать макросом функцию, и передать эту функцию в макрос, который возвращает исходный текст функции, то получится такой результат:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">def init`<span class="class"><span class="keyword">struct</span>`<span class="title">Memblock</span> ( <span class="title">var</span> <span class="title">memblock</span> :</span> Memblock; var a`count : <span class="keyword">int</span>; var b`count : <span class="keyword">int</span>; var c`count : <span class="keyword">int</span> )</span><br><span class="line">    print(<span class="string">"Hello, world!"</span>,__context__)</span><br></pre></td></tr></table></figure><p><strong><code>Присваивание и объявление переменной</code></strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//-------------------------</span></span><br><span class="line"><span class="comment">//1. Make Expressions</span></span><br><span class="line"><span class="comment">//-------------------------</span></span><br><span class="line"><span class="comment">//memblock.a`count = aCount</span></span><br><span class="line"><span class="comment">//  ExprVar memblock. ExprField a`count ExprCopyRight = ExprVar aCount</span></span><br><span class="line">var exprVar_memblock &lt;- <span class="keyword">new</span> [[ExprVar() name:=<span class="string">"memblock"</span>]]</span><br><span class="line">var exprField_acount &lt;- <span class="keyword">new</span> [[ExprField() name:=<span class="string">"a`count"</span>, value &lt;- exprVar_memblock]]</span><br><span class="line">var exprVar_acount &lt;- <span class="keyword">new</span> [[ExprVar() name:=<span class="string">"a`count"</span>]]</span><br><span class="line">var exprCopy &lt;- <span class="keyword">new</span> [[ExprCopy() op:=<span class="string">"="</span>, left &lt;- exprField_acount, right &lt;- exprVar_acount]]</span><br><span class="line">blk.<span class="built_in">list</span> |&gt; emplace(exprCopy)</span><br></pre></td></tr></table></figure><p>Тут всё достаточно тривиально, пока составляем только первую строку “memblock.a`count = aCount”</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//-------------------------</span></span><br><span class="line"><span class="comment">//2. Quotes</span></span><br><span class="line"><span class="comment">//-------------------------</span></span><br><span class="line"><span class="comment">//let aSize = typeinfo(sizeof *memblock.a) * aCount</span></span><br><span class="line"><span class="comment">//  ExprLet var  ExprLetVariable aSize : int const =  ExprOp2(ExprVar aCount ExprOp2Right * 4)</span></span><br><span class="line">var exprLet_aSize_value &lt;- quote(</span><br><span class="line">    typeinfo(<span class="keyword">sizeof</span> * memblock.a) * a`count</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var exprLet_aSize &lt;- <span class="keyword">new</span> [[ExprLet()]]</span><br><span class="line">exprLet_aSize.variables |&gt; emplace_new() &lt;| <span class="keyword">new</span> [[Variable()</span><br><span class="line">    name := <span class="string">"aSize"</span>,</span><br><span class="line">    _type &lt;- <span class="keyword">new</span> [[TypeDecl() baseType=Type tInt]],</span><br><span class="line">    init &lt;- exprLet_aSize_value</span><br><span class="line">]]</span><br><span class="line">blk.<span class="built_in">list</span> |&gt; emplace(exprLet_aSize)</span><br><span class="line"></span><br><span class="line"><span class="comment">//prevent drop unused code</span></span><br><span class="line">var exprCall_printUnused &lt;- quote(</span><br><span class="line">    print(<span class="string">"&#123;aSize&#125;"</span>)</span><br><span class="line">)</span><br><span class="line">blk.<span class="built_in">list</span> |&gt; emplace(exprCall_printUnused)</span><br></pre></td></tr></table></figure><p>При генерации следующей строки можно заметить, что:</p><ul><li>макрос ast_print_expression не описал выражение “typeinfo(sizeof *memblock.a)”, а вместо этого вывел его результат. Это происходит потому, что макрос был применён к уже сгенерированной и оптимизированной функции, для которой часть выражений может быть вычислена компилятором.</li><li>макрос ast_print, применённый к сгенерированной функции, не показывает неиспользуемые переменные, так как они были выброшены компилятором, так что увидеть их можно, если добавить использование (print”{aSize}” в данном случае).</li></ul><p>Кроме генерации выражений, здесь показано использование макроса <code>quote</code>, который превращает код в выражение:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var exprLet_aSize_value &lt;- quote(</span><br><span class="line">    typeinfo(<span class="keyword">sizeof</span> * memblock.a) * a`count</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>Вот <a href="https://github.com/GaijinEntertainment/daScript/blob/726d440be7618fb431815b18e6f785c37a335d5d/examples/test/misc/template_example.das" target="_blank" rel="noopener">пример</a> (<a href="https://github.com/spiiin/dascript_macro_tutorial/blob/master/examples/template_example.das" target="_blank" rel="noopener">Fixed version</a>) более продвинутого использования цитирования, с возможностью задать правила переписывания выражения. Это можно использовать для того, чтобы перейти от явного указания названия поля структуры к переменной, в которую можно передать любое имя или выражение:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">require daslib/templates</span><br><span class="line">require daslib/templates_boost</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------</span></span><br><span class="line"><span class="comment">//2. Quotes and templates</span></span><br><span class="line"><span class="comment">//-------------------------</span></span><br><span class="line"><span class="comment">//let aSize = typeinfo(sizeof *memblock.a) * aCount</span></span><br><span class="line"><span class="comment">//  ExprLet var  ExprLetVariable aSize : int const =  ExprOp2(ExprVar aCount ExprOp2Right * 4)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">for</span> i in <span class="title">range</span><span class="params">(<span class="number">0</span>, ptrFieldsLen)</span></span></span><br><span class="line"><span class="function">    let argumentName </span>= <span class="string">"&#123;st.fields[ptrsTypeIndexes[i]].name&#125;"</span></span><br><span class="line">    var exprLet_aSize_value &lt;- quote(</span><br><span class="line">        typeinfo(<span class="keyword">sizeof</span> *ELEMENT) * ELEMENTS_COUNT</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    var exprVar_memblock2 &lt;- <span class="keyword">new</span> [[ExprVar() name:=<span class="string">"memblock"</span>]]</span><br><span class="line">    var exprField_acount2 &lt;- <span class="keyword">new</span> [[ExprField() name:=argumentName, value &lt;- exprVar_memblock2]]</span><br><span class="line"></span><br><span class="line">    var exprLet_rules : Template                                               <span class="comment">//правила переписывания выражения</span></span><br><span class="line">    exprLet_rules |&gt; replaceVariable(<span class="string">"ELEMENT"</span>, exprField_acount2)             <span class="comment">//подставляем выражение</span></span><br><span class="line">    exprLet_rules |&gt; renameVariable(<span class="string">"ELEMENTS_COUNT"</span>, <span class="string">"&#123;argumentName&#125;`count"</span>)  <span class="comment">//подставляем имя переменной</span></span><br><span class="line">    apply_template(exprLet_rules, exprLet_aSize_value.at, exprLet_aSize_value)</span><br><span class="line">    </span><br><span class="line">    var exprLet_aSize &lt;- <span class="keyword">new</span> [[ExprLet()]]</span><br><span class="line">    exprLet_aSize.variables |&gt; emplace_new() &lt;| <span class="keyword">new</span> [[Variable()</span><br><span class="line">        name := <span class="string">"&#123;argumentName&#125;Size"</span>,</span><br><span class="line">        _type &lt;- <span class="keyword">new</span> [[TypeDecl() baseType=Type tInt]],</span><br><span class="line">        init &lt;- exprLet_aSize_value</span><br><span class="line">    ]]</span><br><span class="line">    blk.<span class="built_in">list</span> |&gt; emplace(exprLet_aSize)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Временно руками добавляем код использования переменных, чтобы их не отбросил компилятор</span></span><br><span class="line">    var exprCall_printUnused &lt;- quote(</span><br><span class="line">        print(<span class="string">"&#123;aSize&#125;,&#123;bSize&#125;,&#123;cSize&#125;"</span>)</span><br><span class="line">    blk.<span class="built_in">list</span> |&gt; emplace(exprCall_printUnused)</span><br></pre></td></tr></table></figure><p>Половина кода генерации написана, нужно двигаться дальше.</p><p><strong><code>Вызов функции memblock.mem |&gt; resize(aSize + bSize + cSize)</code></strong></p><p>Здесь есть небольшая хитрость. Строка <code>aSize + bSize + cSize</code>, трансформируется в выражение:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ExprOp2( ExprOp2(ExprVar aSize ExprOp2Right + ExprVar bSize) ExprOp2Right + ExprVar cSize))</span><br></pre></td></tr></table></figure></p><p>У выражения есть определённый шаблон:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">((((a+b)+c)+d)+...)</span><br></pre></td></tr></table></figure></p><p>Подобные выражения удобно сгенерировать с помощью функции <a href="https://en.wikipedia.org/wiki/Fold_(higher-order_function" target="_blank" rel="noopener">свёртки</a>). Я зачём-то использовал правостороннюю свёртку, но для ассоциативных операторов конечный результат будет одинаковым (не нашёл готовой в стандартной библиотеке):</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">foldR</span><span class="params">(var a:<span class="built_in">array</span>&lt;ExpressionPtr&gt;; foldOp:function&lt;(arg1, arg2: ExpressionPtr) : ExpressionPtr&gt; )</span></span></span><br><span class="line"><span class="function">    let aLen </span>= a |&gt; length</span><br><span class="line">    var from &lt;- a[aLen<span class="number">-1</span>]</span><br><span class="line">    <span class="function"><span class="keyword">for</span> i in <span class="title">range</span><span class="params">(<span class="number">1</span>, aLen)</span></span></span><br><span class="line"><span class="function">        from :</span>= foldOp |&gt; invoke(a[aLen<span class="number">-1</span>-i], from)</span><br><span class="line">    <span class="keyword">return</span> from</span><br><span class="line"></span><br><span class="line">def makeSumExpr(a, b: ExpressionPtr <span class="keyword">const</span>): ExpressionPtr</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> [[ExprOp2() op:=<span class="string">"+"</span>, left := a, right := b]]</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------</span></span><br><span class="line"><span class="comment">// 3. Foldr</span></span><br><span class="line"><span class="comment">//-------------------------</span></span><br><span class="line"><span class="comment">//memblock.mem |&gt; resize(aSize + bSize + cSize)</span></span><br><span class="line"><span class="comment">//     ExprCall __::builtin`resize( ExprCallArgument ExprVar memblock. ExprField mem, ExprCallArgument  ExprOp2( ExprOp2(ExprVar aSize ExprOp2Right + ExprVar bSize) ExprOp2Right + ExprVar cSize))</span></span><br><span class="line"></span><br><span class="line">var sumArgumentsArray: <span class="built_in">array</span>&lt;ExpressionPtr&gt;</span><br><span class="line"><span class="keyword">for</span> i in range(<span class="number">0</span>, ptrFieldsLen) </span><br><span class="line">    let argumentName = <span class="string">"&#123;st.fields[ptrsTypeIndexes[i]].name&#125;"</span></span><br><span class="line">    let nameSize := <span class="string">"&#123;argumentName&#125;Size"</span></span><br><span class="line">    sumArgumentsArray |&gt; emplace(<span class="keyword">new</span> [[ExprVar() name:=nameSize]])</span><br><span class="line">var sumExpr &lt;- foldR(sumArgumentsArray, @@makeSumExpr) <span class="comment">//ага, свёртка массива в выражение</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//--------</span></span><br><span class="line">var exprLet_totalSize &lt;- <span class="keyword">new</span> [[ExprLet()]]</span><br><span class="line">exprLet_totalSize.variables |&gt; emplace_new() &lt;| <span class="keyword">new</span> [[Variable()</span><br><span class="line">    name := <span class="string">"totalSize"</span>,</span><br><span class="line">    _type &lt;- <span class="keyword">new</span> [[TypeDecl() baseType=Type tInt]],</span><br><span class="line">    init &lt;- sumExpr</span><br><span class="line">]]</span><br><span class="line">blk.<span class="built_in">list</span> |&gt; emplace(exprLet_totalSize)</span><br><span class="line"><span class="comment">//prevent drop unused code</span></span><br><span class="line">var exprCall_printUnused2 &lt;- quote(</span><br><span class="line">    print(<span class="string">"&#123;totalSize&#125;"</span>)</span><br><span class="line">)</span><br><span class="line">blk.<span class="built_in">list</span> |&gt; emplace(exprCall_printUnused2)</span><br><span class="line"></span><br><span class="line"><span class="comment">//сгенерирует код:</span></span><br><span class="line"><span class="comment">//let totalSize : int = (aSize + (bSize + cSize))</span></span><br><span class="line"><span class="comment">//__::builtin`resize(memblock.mem,totalSize)</span></span><br></pre></td></tr></table></figure><p>(__::builtin`resize здесь просто замангленное название встроенной функции resize)</p><p><strong><code>memblock.a = reinterpret&lt;int?&gt; addr(memblock.mem[0])</code></strong></p><p>Можно немного изменить функцию <code>foldr</code>, чтобы она могла генерировать частичные суммы для получения кода вида:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">memblock.a = reinterpret&lt;<span class="keyword">int</span>?&gt; addr(memblock.mem[<span class="number">0</span>])</span><br><span class="line">memblock.b = reinterpret&lt;<span class="keyword">float</span>?&gt; addr(memblock.mem[(aSize + <span class="number">0</span>)])</span><br><span class="line">memblock.c = reinterpret&lt;<span class="keyword">int</span>?&gt; addr(memblock.mem[(aSize + (bSize + <span class="number">0</span>))])</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//теперь можно задать, какую часть массива превратить в выражение</span></span><br><span class="line"><span class="function">def <span class="title">foldR_partial</span><span class="params">(var a:<span class="built_in">array</span>&lt;ExpressionPtr&gt;; foldOp:function&lt;(arg1, arg2: ExpressionPtr) : ExpressionPtr&gt;; initial: ExpressionPtr; endIndex:<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">    let aLen </span>= a |&gt; length</span><br><span class="line">    var from := initial</span><br><span class="line">    <span class="keyword">for</span> i in range(endIndex, aLen)</span><br><span class="line">        from := foldOp |&gt; invoke(a[aLen<span class="number">-1</span>-i], from)</span><br><span class="line">    <span class="keyword">return</span> from</span><br><span class="line"></span><br><span class="line">var exprCall_resize &lt;- quote(</span><br><span class="line">        memblock.mem |&gt; resize(totalSize)</span><br><span class="line">    )</span><br><span class="line">    blk.<span class="built_in">list</span> |&gt; emplace(exprCall_resize)</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------</span></span><br><span class="line"><span class="comment">// 4. castType</span></span><br><span class="line"><span class="comment">//-------------------------</span></span><br><span class="line"><span class="comment">//memblock.a = reinterpret&lt;int?&gt; addr(memblock.mem[0])</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i in range(<span class="number">0</span>, ptrFieldsLen)</span><br><span class="line">    let argumentName = <span class="string">"&#123;st.fields[ptrsTypeIndexes[i]].name&#125;"</span></span><br><span class="line">    var exprVar_memblock &lt;- <span class="keyword">new</span> [[ExprVar() name:=<span class="string">"memblock"</span>]]</span><br><span class="line">    var exprField_a &lt;- <span class="keyword">new</span> [[ExprField() name:=argumentName, value &lt;- exprVar_memblock]]</span><br><span class="line">    var exprAddr &lt;- quote(</span><br><span class="line">        addr(memblock.mem[START_ADDRESS])</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    var exprZero &lt;- <span class="keyword">new</span> [[ExprConstInt() value=<span class="number">0</span>]]</span><br><span class="line">    var exprStartAddress &lt;- foldR_partial(sumArgumentsArray, @@makeSumExpr, exprZero, ptrFieldsLen-i)</span><br><span class="line">    var exprAddr_rules : Template</span><br><span class="line">    exprAddr_rules |&gt; replaceVariable(<span class="string">"START_ADDRESS"</span>, exprStartAddress)</span><br><span class="line">    apply_template(exprAddr_rules, exprAddr.at, exprAddr)</span><br><span class="line"></span><br><span class="line">    var exprReinterpretCast&lt;- <span class="keyword">new</span> [[ExprCast() </span><br><span class="line">        castType := st.fields[ptrsTypeIndexes[i]]._type,</span><br><span class="line">        castFlags = ExprCastFlags reinterpretCast,</span><br><span class="line">        subexpr &lt;- exprAddr]]</span><br><span class="line">    </span><br><span class="line">    var exprUnsafe&lt;- <span class="keyword">new</span> [[ExprUnsafe() body &lt;- exprReinterpretCast]]</span><br><span class="line">    var exprCopy &lt;- <span class="keyword">new</span> [[ExprCopy() op:=<span class="string">"="</span>, left &lt;- exprField_a, right &lt;- exprUnsafe]]</span><br><span class="line">    blk.<span class="built_in">list</span> |&gt; emplace(exprCopy)</span><br></pre></td></tr></table></figure><p>Все части генерации, составленные вместе, генерируют теперь такую функцию:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">def init`<span class="class"><span class="keyword">struct</span>`<span class="title">Memblock</span> ( <span class="title">var</span> <span class="title">memblock</span> :</span> Memblock; var a`count : <span class="keyword">int</span>; var b`count : <span class="keyword">int</span>; var c`count : <span class="keyword">int</span> )</span><br><span class="line">        memblock.a`count = a`count</span><br><span class="line">        memblock.b`count = b`count</span><br><span class="line">        memblock.c`count = c`count</span><br><span class="line">        let aSize : <span class="keyword">int</span> = (a`count * <span class="number">4</span>)</span><br><span class="line">        let bSize : <span class="keyword">int</span> = (b`count * <span class="number">4</span>)</span><br><span class="line">        let cSize : <span class="keyword">int</span> = (c`count * <span class="number">4</span>)</span><br><span class="line">        let totalSize : <span class="keyword">int</span> = (aSize + (bSize + cSize))</span><br><span class="line">        __::builtin`resize(memblock.mem,totalSize)</span><br><span class="line">        memblock.a = reinterpret&lt;<span class="keyword">int</span>?&gt; addr(memblock.mem[<span class="number">0</span>])</span><br><span class="line">        memblock.b = reinterpret&lt;<span class="keyword">float</span>?&gt; addr(memblock.mem[(aSize + <span class="number">0</span>)])</span><br><span class="line">        memblock.c = reinterpret&lt;<span class="keyword">int</span>?&gt; addr(memblock.mem[(aSize + (bSize + <span class="number">0</span>))])</span><br></pre></td></tr></table></figure></p><p>Сгенерированная функция делает то же, что и написанная руками. Но разница в том, что для любых новых типов структур больше не нужно писать код объявления полей и инициализации руками совсем!</p><h2 id="Наследование"><a href="#Наследование" class="headerlink" title="Наследование"></a>Наследование</h2><p>Теперь можно использовать макрос, чтобы сгенерировать поля структуры и конструктор:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[memblock]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Memblock</span></span></span><br><span class="line"><span class="class">    <span class="title">a</span>:</span> <span class="keyword">int</span>?</span><br><span class="line">    b: <span class="keyword">float</span>?</span><br><span class="line">    c: <span class="keyword">int</span>?</span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def test</span><br><span class="line">    unsafe</span><br><span class="line">        var memblock: Memblock</span><br><span class="line">        memblock |&gt; init`<span class="class"><span class="keyword">struct</span>`<span class="title">Memblock</span>(5,5,5)</span></span><br><span class="line"><span class="class">        <span class="title">memblock</span> |&gt; <span class="title">fillMemblock</span></span></span><br><span class="line"><span class="class">        <span class="title">print</span>("<span class="title">Memblock</span> = &#123;</span>memblock&#125;\n<span class="string">")</span></span><br></pre></td></tr></table></figure></p><p>Всё работает как задумано (реальный код потребовал бы ещё некоторых доработок, вроде добавления паддинга для выравнивания полей в блоке памяти, а также обёрток для того, чтобы скрыть необходимость unsafe доступа к полям, раз уж границы массивов известны).</p><p>Но что будет, если отнаследоваться от такой структуры?</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vec2</span></span></span><br><span class="line"><span class="class">    <span class="title">x</span>, <span class="title">y</span> :</span> <span class="keyword">float</span></span><br><span class="line"></span><br><span class="line">[memblock, dump_fields]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Memblock</span></span></span><br><span class="line"><span class="class">    <span class="title">a</span>:</span> <span class="keyword">int</span>?</span><br><span class="line">    b: <span class="keyword">float</span>?</span><br><span class="line">    c: <span class="keyword">int</span>?</span><br><span class="line">    d: Vec2?</span><br><span class="line"></span><br><span class="line">[memblock, dump_fields]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MemblockInheritor</span> :</span> Memblock</span><br><span class="line">    e: <span class="keyword">int</span>?</span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def test</span><br><span class="line">    unsafe</span><br><span class="line">        var memblock: Memblock</span><br><span class="line">        memblock |&gt; init`<span class="class"><span class="keyword">struct</span>`<span class="title">Memblock</span>(5,5,5,1)</span></span><br><span class="line"><span class="class">        <span class="title">memblock</span> |&gt; <span class="title">fillMemblock</span></span></span><br><span class="line"><span class="class">        <span class="title">print</span>("<span class="title">Memblock</span> = &#123;</span>memblock&#125;\n<span class="string">")</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        var memblock2: MemblockInheritor</span></span><br><span class="line"><span class="string">        //memblock2 |&gt; fillMemblock</span></span><br><span class="line"><span class="string">        memblock2 |&gt; init`struct`MemblockInheritor(5,5,5,1,10)</span></span><br><span class="line"><span class="string">        print("</span>Memblock2 = &#123;memblock2&#125;\n<span class="string">")</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//out:</span></span><br><span class="line"><span class="string">struct Memblock &#123;</span></span><br><span class="line"><span class="string">        int32_t * a;</span></span><br><span class="line"><span class="string">        float * b;</span></span><br><span class="line"><span class="string">        int32_t * c;</span></span><br><span class="line"><span class="string">        Vec2 * d;</span></span><br><span class="line"><span class="string">        TArray&lt;uint8_t&gt; mem;</span></span><br><span class="line"><span class="string">        int32_t a`count;</span></span><br><span class="line"><span class="string">        int32_t b`count;</span></span><br><span class="line"><span class="string">        int32_t c`count;</span></span><br><span class="line"><span class="string">        int32_t d`count;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">struct MemblockInheritor &#123;</span></span><br><span class="line"><span class="string">        int32_t * a;</span></span><br><span class="line"><span class="string">        float * b;</span></span><br><span class="line"><span class="string">        int32_t * c;</span></span><br><span class="line"><span class="string">        Vec2 * d;</span></span><br><span class="line"><span class="string">        TArray&lt;uint8_t&gt; mem;</span></span><br><span class="line"><span class="string">        int32_t a`count;</span></span><br><span class="line"><span class="string">        int32_t b`count;</span></span><br><span class="line"><span class="string">        int32_t c`count;</span></span><br><span class="line"><span class="string">        int32_t d`count;</span></span><br><span class="line"><span class="string">        int32_t * e;</span></span><br><span class="line"><span class="string">        TArray&lt;uint8_t&gt; mem;</span></span><br><span class="line"><span class="string">        int32_t a`count;</span></span><br><span class="line"><span class="string">        int32_t b`count;</span></span><br><span class="line"><span class="string">        int32_t c`count;</span></span><br><span class="line"><span class="string">        int32_t d`count;</span></span><br><span class="line"><span class="string">        int32_t e`count;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>Ауч, все поля в наследнике продублированы. Обработка объявления наследования в языке реализована как копирование деклараций всех полей структуры-предка в дочернюю (можно порыться в документации, или написать макрос, который покажет, что происходит).</p><p>Возможно реализовать пару стратегий правильного размещения полей наследника в памяти:</p><ul><li>каким-либо образом пометить, что базовая структура имеет сгенерированные поля, и добавить только новые</li><li>каким-либо образом пометить поля структуры-предка, удалить их, и перестроить всю структуру заново</li></ul><p>Для пометки полей можно использовать аннотации типов (пример — <a href="https://github.com/borisbat/dasBGFX/blob/a1e10ab439e5996a0a4d8722689e2b0fab4e72d9/examples/01_hello_triangle.das#L7" target="_blank" rel="noopener">аннотации типов шейдеров</a>).</p><p>Простой макрос, который проверяет список аннотаций типа:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">checkFields</span><span class="params">(var st:StructurePtr)</span></span></span><br><span class="line">    for field in st.fields</span><br><span class="line">        var memblockAnnExist = find_arg(<span class="string">"in_memblock"</span>, field.annotation) ?as tBool ?? <span class="literal">false</span></span><br><span class="line">        <span class="keyword">if</span> memblockAnnExist</span><br><span class="line">            print(<span class="string">"\t[in_memblock]\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//можно добавить аннотацию типа</span></span><br><span class="line"> st.fields[i].annotation |&gt; add_annotation_argument(<span class="string">"in_memblock"</span>, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure></p><p>Теперь можно реализовать логику добавления новых полей в уже существующий мемблок, а также генерацию конструктора с правильным количестом полей:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vec2</span></span></span><br><span class="line"><span class="class">    <span class="title">x</span>, <span class="title">y</span> :</span> <span class="keyword">float</span></span><br><span class="line"></span><br><span class="line">[memblock, dump_fields]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Memblock</span></span></span><br><span class="line"><span class="class">    <span class="title">a</span>:</span> <span class="keyword">int</span>?</span><br><span class="line">    b: <span class="keyword">float</span>?</span><br><span class="line">    c: <span class="keyword">int</span>?</span><br><span class="line">    d: Vec2?</span><br><span class="line"></span><br><span class="line">[memblock, dump_fields]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MemblockInheritor</span> :</span> Memblock</span><br><span class="line">    e: <span class="keyword">int</span>?</span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">fillMemblock</span><span class="params">(var memblock: Memblock)</span></span></span><br><span class="line"><span class="function">    unsafe</span></span><br><span class="line">        memblock.a[0] = int(0x11223344)</span><br><span class="line">        memblock.a[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">        memblock.a[<span class="number">2</span>] = <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        memblock.b[<span class="number">0</span>] = reinterpret&lt;<span class="keyword">float</span>&gt;(<span class="number">0x55667788</span>)</span><br><span class="line">        memblock.b[<span class="number">1</span>] = <span class="number">0.0</span></span><br><span class="line">        memblock.b[<span class="number">2</span>] = <span class="number">123.456</span></span><br><span class="line"></span><br><span class="line">        memblock.c[<span class="number">0</span>] = <span class="keyword">int</span>(<span class="number">0xAABBCCDD</span>)</span><br><span class="line">        memblock.c[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">        memblock.c[<span class="number">2</span>] = <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def test</span><br><span class="line">    unsafe</span><br><span class="line">        var memblock: Memblock</span><br><span class="line">        memblock |&gt; init`struct`Memblock(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">1</span>)</span><br><span class="line">        memblock |&gt; fillMemblock</span><br><span class="line">        print(<span class="string">"Memblock = &#123;memblock&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line">        var memblock2: MemblockInheritor</span><br><span class="line">        <span class="comment">//memblock2 |&gt; fillMemblock</span></span><br><span class="line">        memblock2 |&gt; init`struct`MemblockInheritor(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line">        print(<span class="string">"Memblock2 = &#123;memblock2&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Вывод:</span></span><br><span class="line">struct Memblock &#123;</span><br><span class="line">        <span class="keyword">int32_t</span> * a;</span><br><span class="line">        <span class="keyword">float</span> * b;</span><br><span class="line">        <span class="keyword">int32_t</span> * c;</span><br><span class="line">        Vec2 * d;</span><br><span class="line">        TArray&lt;<span class="keyword">uint8_t</span>&gt; mem;</span><br><span class="line">        <span class="keyword">int32_t</span> a`count;</span><br><span class="line">        <span class="keyword">int32_t</span> b`count;</span><br><span class="line">        <span class="keyword">int32_t</span> c`count;</span><br><span class="line">        <span class="keyword">int32_t</span> d`count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MemblockInheritor</span> &#123;</span></span><br><span class="line">        <span class="keyword">int32_t</span> * a;</span><br><span class="line">        <span class="keyword">float</span> * b;</span><br><span class="line">        <span class="keyword">int32_t</span> * c;</span><br><span class="line">        Vec2 * d;</span><br><span class="line">        TArray&lt;<span class="keyword">uint8_t</span>&gt; mem;</span><br><span class="line">        <span class="keyword">int32_t</span> a`count;</span><br><span class="line">        <span class="keyword">int32_t</span> b`count;</span><br><span class="line">        <span class="keyword">int32_t</span> c`count;</span><br><span class="line">        <span class="keyword">int32_t</span> d`count;</span><br><span class="line">        <span class="keyword">int32_t</span> * e;</span><br><span class="line">        <span class="keyword">int32_t</span> e`count;</span><br><span class="line">&#125;</span><br><span class="line">Memblock = [[ <span class="number">287454020</span>; <span class="number">15837566074880.000000000</span>; <span class="number">-1430532899</span>; [[ <span class="number">0.000000000</span>; <span class="number">0.000000000</span>]]; [[ <span class="number">0x44</span>; <span class="number">0x33</span>; <span class="number">0x22</span>; <span class="number">0x11</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0xff</span>; <span class="number">0xff</span>; <span class="number">0xff</span>; <span class="number">0xff</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x88</span>; <span class="number">0x77</span>; <span class="number">0x66</span>; <span class="number">0x55</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x79</span>; <span class="number">0xe9</span>; <span class="number">0xf6</span>; <span class="number">0x42</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0xdd</span>; <span class="number">0xcc</span>; <span class="number">0xbb</span>; <span class="number">0xaa</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0xff</span>; <span class="number">0xff</span>; <span class="number">0xff</span>; <span class="number">0xff</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>]]; <span class="number">5</span>; <span class="number">5</span>; <span class="number">5</span>; <span class="number">1</span>]]</span><br><span class="line">Memblock2 = [[ <span class="number">0</span>; <span class="number">0.000000000</span>; <span class="number">0</span>; [[ <span class="number">0.000000000</span>; <span class="number">0.000000000</span>]]; [[ <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>; <span class="number">0x0</span>]]; <span class="number">5</span>; <span class="number">5</span>; <span class="number">5</span>; <span class="number">1</span>; <span class="number">0</span>; <span class="number">10</span>]]</span><br></pre></td></tr></table></figure><h2 id="Финал"><a href="#Финал" class="headerlink" title="Финал"></a>Финал</h2><p>С данным макросом можно продолжать играться, делая его всё круче, но примерно на этом этапе можно сказать, что исходная задача решена.</p><p>Макросы добавляют в язык способ серьёзно модифицировать код и данные по правилам, которые захочет реализовать программист. При этом разница между тривиальной структурой и “продвинутой” с точки зрения клиентского кода — всего одна аннотация.</p><p>Для сравнения с C++, например <a href="https://youtu.be/gVGtNFg4ay0" target="_blank" rel="noopener">доклад  Louis Dionne</a> про реализацию библиотеки, позволяющей переопределить способ реализации полиморфизма. Без макросов невозможно реализовать идею синтаксически так, чтобы это выглядело как наследование — в компиляторе жёстко прошиты правила того, что сгенерирует комплиятор при наследовании одной структуры от другой.</p><p>Естественно, что макросы — это не средство повседневного решения задач. Скорее это средство для того, чтобы лучше “подстроить” язык под предметную область, и уменьшить количество рукописного рутинного кода, не относящего непосредственно к решаемой задаче.</p><p>Для <code>daScript</code> предметная область — это разработка игр, и, возможно, макросы позволят ему уйти далеко вперед по сравнению с тем, что умели делать любые другие скриптовые языки для игр раньше.</p><p><a href="https://github.com/spiiin/dascript_macro_tutorial" target="_blank" rel="noopener">https://github.com/spiiin/dascript_macro_tutorial</a> - репозиторий с кодом из заметки:<br>    <code>/src_dirty</code> — можно посмотреть диффами между парами файлов эволюцию примера из статьи. Хостом для выполнения может послужить tutorial01 - базовый пример работы с языком из официального репозитория. В остальном — непричёсанный код.<br>    <code>/examples</code> — пофикшенные примеры макросов из официального репозитория.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://dascript.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;dacript&lt;/a&gt; - скриптовый язык для игр от Gaijin Entertaiment.&lt;/p&gt;
&lt;p&gt;После нескольких дней изучения понял, что испытываю интерес и хороший страх по отношению к этому языку. Такой, как если бы нашёл лазерную указку и решил поиграть с котом, но понял, что этой указкой можно легко резать металл. &lt;/p&gt;
&lt;p&gt;Гайдзины делают не замену &lt;code&gt;Lua&lt;/code&gt;, они делают замену &lt;code&gt;C++&lt;/code&gt;! Точнее даже, не “делают”, а практически “сделали”, язык сейчас находится в версии 0.2, но полноценно используется ими в продакшене в &lt;code&gt;Warthunder&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Доклад и документация акцентируют внимание на быстродействии языка и возможности серьёзных изменений без перезапуска игры, но только вскользь упоминают о мощных возможностях макросов. Так что я решил попробовать решить задачку, требующую их использования. Это моя первая программа на &lt;code&gt;daScript&lt;/code&gt;, после трёх дней изучения, так что где-то возможны и неизбежны косяки.&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="gamedev" scheme="http://spiiin.github.io/tags/gamedev/"/>
    
  </entry>
  
  <entry>
    <title>С++ в геймдеве</title>
    <link href="http://spiiin.github.io/blog/1728194429/"/>
    <id>http://spiiin.github.io/blog/1728194429/</id>
    <published>2022-01-30T13:58:23.000Z</published>
    <updated>2022-02-06T21:09:15.533Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Немного о том, почему в геймдеве используется C++, как именно он используется, и всё ли с этим правильно.<br><a id="more"></a></p><h1 id="Почему"><a href="#Почему" class="headerlink" title="Почему"></a>Почему</h1><p>Тут всё просто — потому что:</p><ul><li>Вендоры платформ предлагают некоторый готовый API на уже выбранном языке, использовать что-то альтернативное — дополнительные затраты</li><li>Игры часто портируют на различные платформы, C (или подмножество C++) - это подмножество, которое можно использовать, чтобы переписывать минимальное количество кода</li><li>Компиляторы C оптимизировались годами, на нём можно писать быстрый код, и использовать его как подмножество С++, там где нужна скорость</li></ul><h1 id="Как-используется"><a href="#Как-используется" class="headerlink" title="Как используется"></a>Как используется</h1><p>Я бы выделил в типичной игре, написанной на C++, три “стиля” кода - низкоуровневый, стандартный, и высокоуровневый.</p><p>(Тим Суини в презентации <a href="https://www.st.cs.uni-saarland.de/edu/seminare/2005/advanced-fp/docs/sweeny.pdf" target="_blank" rel="noopener">The Next Mainstream Programming Language</a> в презентации 2010 года, выделяет в отдельную группу так же код шейдеров на HLSL/GLSL, но это уже не C++).</p><h2 id="Низкоуровневый-C"><a href="#Низкоуровневый-C" class="headerlink" title="Низкоуровневый C++"></a>Низкоуровневый C++</h2><p>Используется там, где нужны какие-либо быстрые Numeric Computation - вычисления с большими объёмами данных. Примеры задач:</p><ul><li>Обход графа сцены</li><li>Симуляция физики, определений столкновений</li><li>Легковесная система задач для получения выгоды от использования нескольких процессоров</li><li>Системы анимации 3D персонажей</li><li>Куллинг, отправка данных на отрисовку</li><li>Системы частиц</li><li>Использование особенностей железа - повышение cache locality, пакинг данных в структуры</li><li>Тяжёлые алгоритмы рендеринга (частично решаются не на C++)</li></ul><p>Часто (но не всегда) является “инлайнингом си”, неотделимым от обычного кода. Это бывает как удобным (практически тот же синтаксис), так и не очень — сложнее не допустить в такой код низкоквалифицированного программиста, и почти невозможно запретить использование отдельных синтаксических возможностей языка.</p><p>Суини на примере <code>Gear of War</code> приводит такое разделение:<br><code>LoC</code> - 50%/50% - половина кода на “обычном c++” (стандартный + высокоуровневый по моему разделению), половина на низкоуровневом. Для менее требовательных к ресурсам игр (типа мобильных казуалок), я бы привёл цифру в 10-20% на низкоуровевый код.<br><code>Использование CPU</code> - 10% времени процессор выполняет код написанный на обычном уровне (игровая логика + скрипты), 90% - на требовательные к скорости рассчёты.<br><code>Производительность кода</code> - низкоуровневый код в среднем в 10 раз быстрее стандартного.</p><p>Код на C неидеален, но удобен в том плане, что не нужно переключаться на другой синтаксис или явно инлайнить его какой-либо директивой. Поэтому другие языки, которые стремятся стать “лучшим С”, иногда поддерживают транспиляцию в C — сгенерированный C код может быть быстрее, чем средний код, написанный человеком (так же, как компилятор может сгенерировать более быстрый машинный код, чем средний программист написать на ассемблере), и можно получить переносимость на все платформы, для которых есть компилятор C.</p><p>Минусы других языков в том, что они 1) не “инлайнятся” в C++-код 2) требуют особой обработки для фич, недоступных в C++, чтобы взаимодействовать с ним (что-то вроде отметок unsafe для такого кода). Ну и не имеют столь тесной интеграции с C++, низкоуровневый код — это не обязательно исключительно код на C, можно сочетать “С с элементами C++”/“С++ с элементами С” в любых пропорциях. Быстрый низкоуровневый код получается в случаях, когда программист более-менее представляет, во что он скомпилируется.</p><p>Вообщем, C++ - не столько быстрый язык, сколько язык с возможностью хорошо контроллировать производительность получаемого кода там, где это требуется.</p><h2 id="Стандартный-C"><a href="#Стандартный-C" class="headerlink" title="Стандартный C++"></a>Стандартный C++</h2><p>Это код, написанный “по заветам классиков”. Задачи, решаемые на “стандартном” уровне:</p><ul><li>“Связка” используемых библиотек и языков: ~10-20 middleware библиотек, связка с хост-языком операционной системы (Java с JNI, Objective C++ с “инлайном С++” для мобилок), вызовы скриптовых языков, для которых хостом является игра</li><li>Высокоуровневая архитектура приложения (Object Oriented Design, Data Oriented Design, паттерны проектирования)</li><li>Написание кода, устойчивого к ошибкам (утечки памяти, использование освобожденной памяти, разыменование кривых указателей, неинициализированные переменные, выходы за границы массивов и прочее прелести)</li><li>Описание игровой логики</li><li>Вызов кода API библиотек, предоставляющих интерфейс на этом языке</li></ul><p><code>Описание игровой логики</code></p><p>На этом уровне Суини выделяет такой момент:<br><blockquote><p>Мы с радостью пожертвуем 10% продуктивности ради того, чтобы получить 10% дополнительной производительности”</p></blockquote></p><p>(т.е. фактически, чтобы защититься от стандартных ошибок, которые позволяет совершить язык).</p><p>Распространённый вариант такого обмена — это использование каких-либо других языков, т.е. отказ от C++ в пользу чего-то более медленного, но устойчивого к ошибкам.</p><p>Традиционный для геймдева вариант — Lua. Во многом, идея такой привязки навеяна использованием <a href="https://www.osp.ru/os/1998/03/179470" target="_blank" rel="noopener">языков сценариев</a>. Минусы — производительность снижается далеко не на 10% (что компенсируется ростом производительности железа), и то, что некоторые программисты страдают от искусственного упрощения языка в целях “защиты от дурака”. По опыту, код на Lua, переписанный на C++, ускоряется раз в 5-10. Другие традиционно используемые для скриптования языки, не особо отличаются от Lua ни в плане производительности, ни в плане предоставляемых возможностей.</p><p>Ещё один минус — необходимость создания привязок C++ объектов для возможности использования их в скриптовом языке. Это задача требует использования “высокоуровневого” C++, и её особенности будут описаны в следующем разделе.</p><p>Плюсы — доступ к программированию непрограммистов (хотя их код в плане производительности теряет ещё больше, количество <a href="https://i.imgur.com/J1svNp7.jpg" target="_blank" rel="noopener">WTF в единицу времени</a> в коде гейм-дизайнера зашкаливает).</p><p>Но главный плюс, ради которого часто можно пожертвовать производительностью, это возможность изменить скрипт без перезапуска программы. Это не получается автоматом, а требует некоторой настройки работы с языком, зато в некоторых случаях позволяет повысить производительность программиста не на 10%, а на порядок (в 10 раз). Компиляция, перезапуск игры и прохождение до нужного места с воспроизведением ситуации займёт около минуты, перезагрузка скрипта может выполниться за несколько секунд.</p><p>Иногда, конечно, программист может предусмотреть необходимые читы, позволяющие подтюнить код без перезапуска, в случае использования определённых паттернов проектирования типа <a href="/blog/1488389622/" title="ECS">ECS</a> существенно, разница между таким подходом и использованием скриптов только в уровне радикальности возможных изменений без перезапуска игры.</p><p>Серьёзный шаг вперёд в направлении использования скриптовых языков сделала Unity, предоставляя программисту в качестве языка для скриптов C# — со статической типизацией (также пробовали Boo и JavaScript, но забили), выразительнее минималистичных “подрезанных” соперников, потенциально быстрый, с возможностью рефлексии, компилируемый в C++ с помощью ill2cpp, и с богатой стандартной библиотекой.</p><p>Небольшую проблему представляет запрет на использование виртуальных машин на платформах типа Apple, что обходится “нативизацией” скриптов в C++ код (AoT-компиляция). Таким образом, на устройстве игрока будет присутствовать только нативный код, а на машинах разработчиков — текстовый.</p><p><em>(Честно говоря, не очень понимаю смысл этого запрета, многие современные игры позволяют изменять поведение игры за счёт использования данных, полученных с серверов разработчика — вполне допускается загрузка, к примеру, нового главного меню с кнопкой, которая вызывает код, недоступный для проверки вендору. В одной китайской стратегии я находил использование чата на JavaScript - в котором разработчики теоретически могут хоть запустить игру в игре).</em></p><p><code>Визуальный скриптинг</code><br>Кроме текстовых языков применяется визуальный скриптинг, который ещё больше снижает когнитивную нагрузку при написании кода, и делает более сложным написание тормознутого или неработающего кода для непрограммистов. Как примеры <a href="https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/Blueprints/UserGuide/Types/ClassBlueprint/" target="_blank" rel="noopener">Blueprint classes</a> в Unreal, или <a href="https://habr.com/ru/company/playrix/blog/595385/" target="_blank" rel="noopener">VSO</a> от Playrix.</p><p>Из плюсов — такой язык почти не требует изучения и почти не подвержен ошибкам, по сути, позволяет создавать различные языки для решения различных задач, кроме описания игровой логики.<br>В Unreal с помощью визуального программирования можно описывать:</p><ul><li>Макросы конструирования объектов в редакторе (в том числе параметризированные), вообще не попадающие в игру</li><li>Материалы</li><li>Конечные автоматы поведения персонажей</li><li>Системы анимации</li></ul><p>Подготовка игрового контента чаще всего рассматривается как отдельная задача, не связанная с игрой, однако в некоторых случаях бывает полезна генерация С++ кода для работы с этими данными — задачу генерации такого кода можно отнести к области использования “высокоуровневого” C++.</p><p><code>Вызов кода API библиотек, предоставляющих интерфейс на этом языке</code><br>Часто какой-нибудь SDK представляет только C/C++ интерфейс для работы с ним (в качестве примера, можно взять OpenGL). Несмотря на то, что для многих библиотек существуют биндинги к популярным скриптовым языкам, особого преимущества при работе с ними не будет, если только биндинг каким-либо образом не добавляет библиотеке выразительности — какая разница, из какого языка вызывать сишные функции, по сути, по порядку? Возможно, определенные преимущества можно получить в языках, позволяющих менять семантику самого языка макросами, типа лиспа, но в рамках доступных для геймдева скриптовых языков особенных преимуществ не заметно.</p><p><code>Хардкорные C++-программисты</code><br>Отдельного упоминания заслуживают С++ программисты, которые противятся использованию скриптовых языков для описания игровой логики. Это труднообъяснимое явление, корни которого до конца я не понимаю, поэтому только приведу только те аргументы, которые от них слышал.</p><ul><li><del>С++ быстрый язык, а скрипты — медленные</del><br>С++ быстрый, если писать на низкоуровневом C++, в остальных случаях скрипт после AoT-компиляции может сконвертироваться в средний по качеству/скорости C++ код.</li><li><del>С++ выразительный язык, а скрипты — бейсикоподобные</del><br>Отчасти верно, но зависит от объектной модели, прокинутой в скрипты. Большинство кода в игровой логике на C++, наоборот, используют примитивы слишком низкого уровня там, где отлично было бы обойтись только высокоуровневыми абстракциями. Ну и, какая к чёрту разница, есть или нет какие-то фичи в скриптовом языке, если он позволяет достичь результата раз в 5 быстрее?</li><li><del>Я хочу учить C++, чтобы развиваться только как C++ программист</del><br>Один из самых трудных случаев. Человек верит в миф о самом лучшем языке, вдобавок подкрепив эту веру собственными усилиями, потраченными на изучения премудростей языка. Хз, если не помогают объяснения о том, что выгоднее развиваться не только в одном языке, то возможно, человеку лучше работать над компиляторами, а не в разработке игр.</li></ul><h2 id="Высокоуровневый-C"><a href="#Высокоуровневый-C" class="headerlink" title="Высокоуровневый C++"></a>Высокоуровневый C++</h2><p>Высокоуровневые задачи, с которыми сталкивается типичная игра:</p><ul><li>RTTI и рефлексия — сериализация данных, читы, статистика</li><li>Кодогенерация — введение удобного синтаксиса в язык, генерация типового кода</li><li>Compile/build-time вычисления</li></ul><p>Один из существенных минусов C++ - отсутствие рефлексии, из-за чего её постоянно переизобретают. Часто потому, что к готовой схеме рефлексии сложно “привязаться”, чтобы использовать её для других целей. Например, разметив код один раз, необходимо воспользоваться этой разметкой, чтобы сгенерировать код сериализации или генерации биндингов к скриптовому языку.</p><p>Другая задача, которая решается различными способами — генерация типов и кода десериализации по схеме данных. Если решать её средствами C++ — макросами и шаблонами, то достаточно нетривиально скрестить её со схемой аннотации типов и генерации биндингов.</p><p>Подходы, которые применяются для кодогенерации RTTI-информации:</p><ul><li>Использование схемы данных на отдельном языке (<a href="https://google.github.io/flatbuffers/" target="_blank" rel="noopener">flatbuffers</a>/protobuffers), с генерацией кода внешним компилятором</li><li>Использование языка, генерирующего данные и код работы с этими данными (<a href="https://youtu.be/oSmqbnhHp1c?t=1950" target="_blank" rel="noopener">DataCompiler</a> на Racket от Naughty Dogs)</li><li>Встраивание команд языка в описание данных (<a href="https://beautifulracket.com/jsonic-3/intro.html" target="_blank" rel="noopener">jsonic</a>)</li><li>Встраивание тегов в исходный язык, парсящихся языком, генерирующим данные по тегам (<a href="https://doc.qt.io/archives/qt-4.8/moc.html" target="_blank" rel="noopener">MOC</a>, <a href="https://habr.com/ru/company/playrix/blog/467827/" target="_blank" rel="noopener">CppHeaderParser</a>, парсинг с помощью libclang - половина либ <a href="https://github.com/fffaraz/awesome-cpp#reflection" target="_blank" rel="noopener">отсюда</a>)</li><li>Явное описание с помощью шаблонов C++ (<a href="https://github.com/rttrorg/rttr" target="_blank" rel="noopener">rttr</a>)</li></ul><p>Непосредственно генерация кода часто выполняется в текстовом виде, либо с помощью генерации текста по множеству условий в коде генератора (пример - <a href="https://github.com/GaijinEntertainment/daScript/blob/master/daslib/cpp_gen.das#L587" target="_blank" rel="noopener">dascript</a>), либо с помощью генерации текста с подстановкой по шаблону (чаще всего движки шаблонов изначально задумывались для генерации html-страниц, <a href="https://docs.racket-lang.org/fulmar-doc/index.html" target="_blank" rel="noopener">fulmar</a> — зачаточный генератор С++ на Racket, с удовольствием нашёл бы что-то лучше).</p><p>По идее, не особо сложно генерировать — сериализиацию, биндинги, rtti, типовой C++ код вроде клонирования (сначала всегда хочется пытаться решить эту задачу просто с помощью наследования от “правильного” базового класса :) ).</p><p>Сложнее в C++ с тем, чтобы генерировать синтаксис по уже существующему синтаксису, язык не особо приспособлен для этого. Примеры задач:</p><ul><li>Подсказка компилятору аллоцировать блок данных для структуры в линейном блоке памяти без явного написания кода работы с указателями в самой структуре, формулировка проблемы из <a href="https://youtu.be/TH9VCN6UkyQ?t=4047" target="_blank" rel="noopener">Jai</a></li><li>Смена AoS/SoA выравнивания в памяти</li><li>Регистрация функций в ECS (<a href="https://youtu.be/inGb9R1NowY" target="_blank" rel="noopener">атрибут EC для функций</a> с авто-выведением аргументов)</li></ul><p>Произвольные compile-time вычисления — чаще проще сделать на внешнем языке (экспериментальные попытки завести такое в C++ - <a href="https://youtu.be/NNU6cbG96M4?t=1065" target="_blank" rel="noopener">Circle</a>), и просто выстроить результат, чем пытаться выполнить что-то сложное компилятор.</p><p>Сейчас меня очень интересует в качестве скриптового языка <a href="https://youtu.be/IvHGczF6Go0" target="_blank" rel="noopener">DaScript</a>, доклад Антона Юдинцева сильно корреллирует с моим представлением о том, зачем нужны скриптовые языки на “стандартном” уровне, и замахивается на то, чтобы решать “высокоуровневые” задачи, для которых не всегда есть стандартные решения в самом C++. Пока не успел поиграться с языком, но мне очень нравятся начальные идеи, с которыми подходили к разработке, и заявленные результаты. Я достаточно знаком с использованием скриптовых языков в Gaijin в прошлом, чтобы примерно представлять уровень и объём кода, написанного ими на языке в продакшене и в тулзах, чтобы предварительно положительно отнестись к заявленному, но и без этого выглядит довольно круто. В докладе и стриме почти не освещаются возможности языка по написанию макросов, упоминаемые в <a href="https://dascript.org/doc/reference/language/macros.html" target="_blank" rel="noopener">документации</a>, а также в коде <a href="https://github.com/GaijinEntertainment/daScript/blob/master/daslib/decs_boost.das" target="_blank" rel="noopener">модулей</a> и <a href="https://github.com/borisbat/dasBGFX/blob/a1e10ab439e5996a0a4d8722689e2b0fab4e72d9/examples/01_hello_triangle.das#L12" target="_blank" rel="noopener">привязок</a> либ для реализации “высокоуровневых” фичи.</p><p>Интересно было бы прикинуть оценки пропорции использования C++ на каждом из уровней в различных играх.</p><h2 id="Ссылки"><a href="#Ссылки" class="headerlink" title="Ссылки"></a>Ссылки</h2><p><a href="/blog/1808122922/" title="Nim in imaginary world">Nim in imaginary world</a> — критерии выбора языка<br><a href="/blog/2297379949/" title="Заметки о языках программирования">Заметки о языках программирования</a> — сборник материалов по языкам<br><code>Джесси Шелл - Искусство Геймдизайна</code> — “Итерации делают игру лучше”. Совет использовать для прототипирования языки с возможностью быстрой проверки изменений - Smalltalk, Python, Scheme, JavaScript<br><code>Джейсон Грегори - Архитектура игрового движка</code> — 16.9.4 - Архитектуры для скриптования. Обзор возможных точек привязки скриптов к игре. 16.9.5 - Возможности игровых скриптов на этапе выполнения. Пример подхватывания изменённых данных игрой без перезапуска. 12.10.3 - Параметры состояния и дерева слияния - примеры анимационного клипа, описанного на языке Data Compiler, и Animation Blueprint для Unreal.<br><a href="https://youtu.be/UTqZNujQOlA" target="_blank" rel="noopener">Demo: Base language, compile-time execution</a> - пример запуска игры во время компиляции.<br><a href="https://fungos.github.io/cr-simple-c-hot-reload/" target="_blank" rel="noopener">cr.h: A Simple C Hot Reload Header-only Library</a> - трудности реализации hot code reload в C++. <a href="https://github.com/RuntimeCompiledCPlusPlus/RuntimeCompiledCPlusPlus/wiki/Alternatives" target="_blank" rel="noopener">Больше</a> статей и материалов.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Немного о том, почему в геймдеве используется C++, как именно он используется, и всё ли с этим правильно.&lt;br&gt;
    
    </summary>
    
    
    
      <category term="c++" scheme="http://spiiin.github.io/tags/c/"/>
    
      <category term="gamedev" scheme="http://spiiin.github.io/tags/gamedev/"/>
    
  </entry>
  
  <entry>
    <title>О книгах и самообразовании</title>
    <link href="http://spiiin.github.io/blog/37481721/"/>
    <id>http://spiiin.github.io/blog/37481721/</id>
    <published>2022-01-23T12:32:52.000Z</published>
    <updated>2022-01-30T12:57:25.689Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>В прошлом году я прочитал больше ста книг, а также посмотрел и изучил несколько сотен статей, лекций и докладов на темы, прямо или косвенно связанные с программированием, гейм дизайном, разработкой игр и развитием. Сам удивился получившейся цифре (основную массу материалов изучил с января по сентябрь), захотел немного расписать, зачем я занялся этим и как получилось разобрать такое количество материала за небольшой срок.</p><a id="more"></a><h2 id="Как-я-читаю-книги"><a href="#Как-я-читаю-книги" class="headerlink" title="Как я читаю книги"></a>Как я читаю книги</h2><p>Читать техническую литературу “от корки до корки”, на мой взгляд, не правильно и не эффективно — часто необходимо отвлекаться, делать заметки, изучать дополнительные материалы, прямо или косвенно упоминаемые в книге/статье/докладе, пробовать экспериментировать с кодом. На первый взгляд, такой способ работы увеличивает время изучения, но, в длительной перспективе, наоборот, ускоряет понимание материала.</p><p>Прежде, чем начать детально “прорабатывать” книгу, очень эффективно оказывается просмотреть её бегло по диагонали, чтобы примерно представить себе содержимое. Не знаю, есть ли у такого подхода официальное название, поэтому называю придуманным термином <code>&quot;метод спирали&quot;</code> (по аналогии с “спиральным методом разработки”):</p><ul><li>Сначала просматривается оглавление и пролистывается вся книга “по диагонали”, с рассматриванием картинок, можно понять про что вообще книга и её структуру</li><li>Если что-то сильно заинтересовало, можно сразу остановиться и изучить материал детальнее</li><li>Полезно затем поискать отзывы и краткие пересказы глав книги, если можно найти их, на популярные книги не представляет сложности, иногда также автор сам рассказывает о книге на каких-нибудь конференциях или докладах</li><li>Если что-то непонятно, или хочется глубже раскопать тему, то сразу стоит поискать дополнительную литературу. Это поначалу кажется очень большим увеличением объёма работы, но если изучать книги на какую-либо тематику, то понимешь, что они часто ссылаются на одну-две основные, после изучения которых все остальные станут или простыми и понятными, или вообще ненужными, так как не добавляют новой информации</li><li>Если нет подходящей литературы, можно поискать дополнительную информацию в других книгах того же автора, его сайте, докладах или в его соцсетях (иногда можно просто взять и спросить в e-mail или твиттере “а что вы тут имели ввиду ваще?” - это работает чаще, чем кажется). Если автор не оставил никаких следов, можно попробовать найти заинтересованных людей, и обсудить это с ними</li></ul><p>После такой базовой проработки книги уже можно понять для себя выгоду, которая будет получена от изучения книги:</p><ul><li>Насколько полезно будет изучить книгу, какие-то на этом этапе можно отбросить, какие-то заставят добавить в свой список для изучения дополнительные 2-3 книги</li><li>Если уже знаешь &gt;70-80% материала, который излагается в книге, то изучать её внимательно нет смысла, это будет просто скучно, можно просто пролистать, немного заполнив пробелы в знаниях или в поисках занимательных мелочей. Какие-либо новые навыки вы из такой книги не получить</li><li>Если знаешь менее 10-20% материала, изложенного в книге - скорее всего она окажется слишком сложной, придётся слишком часто отвлекаться на поиск дополнительной информации и практику, и будет читаться медленно.Лучше попробовать сначала изучить что-то проще</li><li>Идеально и наиболее быстро усваивается материал, которой получен из книги, известной где-то на 40-50%. В этом случае, скорее всего либо уже пробовал похожее на практике, либо обдумывал и приходил к схожим идеям, так что часто нет необходимости проверять и пробовать каждую изложенную идею</li></ul><p>Нетехнические книги, или книги, информация в которых в основном справочная, часто может просто отложить на определенном этапе, просто оставив “закладку”, какую информацию в них можно найти.</p><p>Очень эффективно читать одновременно 3-4 книги. Как минимум 2 на исследуемую тему и 1 на отвлеченную. Пересекающиеся факты из двух книг улучшают запоминание материала, за счёт перекрёстных ссылок, а книга на другую тему позволяет “отдыхать” от однообразного материала, при этом продолжая изучение в одном из желаемых направлений.</p><p>Для улучшения запоминания материала полезно вести заметки, кратко конспектируя определенную тему, с перекрёстными ссылками на материалы (метод <a href="https://en.wikipedia.org/wiki/Zettelkasten" target="_blank" rel="noopener">Zettelkasten</a> и <a href="https://obsidian.md/" target="_blank" rel="noopener">Obsidian</a> как система ведения заметок — бесплатная, расширяемая плагинами, данные хранятся локально в виде текстовых файлов, обзор всей сети заметок в виде графа).</p><p>Этот же алгоритм можно применять не только к книгам, но и статьям, докладам, презентациям etc.</p><h2 id="Как-заставить-себя-изучать-такое-количество-материала"><a href="#Как-заставить-себя-изучать-такое-количество-материала" class="headerlink" title="Как заставить себя изучать такое количество материала"></a>Как заставить себя изучать такое количество материала</h2><p>Естественно, чтобы выполнить такой большой объём работы, необходима сильная мотивация. Например, заставить себя поверить в то, что от изучения зависит твоя карьера/успешность. Как в универе, когда нужно быстро подготовиться к сессии ненормальными темпами. Без этого мозг тупить будет, и учиться не получится.</p><p>Совмещать изучение с работой практически невозможно, лучше посвятить этому длинный отпуск. <a href="https://ailev.livejournal.com/1130190.html" target="_blank" rel="noopener">Как зажечь мастерство</a> — объяснение, почему так эффективнее. В какой-то момент происходит “метанойа”, прорыв в понимании нового материала, и чтобы прийти к этому состоянию, необходимо тратить в день на занятия как минимум определенное количество часов. Поэтому, условные 1000 часов, потраченные на получения навыка, будут более эффективны, если сжать их в короткий срок, чем если размазаны на длинный.</p><p>Есть естественное следствие такого подхода — организм получит в сжатые сроки такое же количество стресса от перегрузки, как получил бы за длительный промежуток времени слабоинтенсивного обучения. Поэтому не очень хорошо получать такие перегрузки, когда и так измотан, болеешь, или есть другие серьёзные отвлекающие факторы (я сам немного неудачно начал изучение, пока был на больничном, в итоге получил более серьёзные осложнения от болезни, чем мог бы, и пришлось потом делать паузу, чтобы дать организму восстановиться). Так что стоит заранее продумать, как и когда расслабляться и отдыхать, в моём случае помогали близкие люди, а также паузы на тренировки по жонглированию и медитацию.</p><p>Ещё один важный момент — необходимо поставить чёткую цель изучения материалов, один или несколько вопросов, на которые хочешь найти ответ. Нет смысла просто сканировать всю доступную информацию, её слишком много. Конечно, может быть множество причин, зачем ты что-то изучаешь, но среди них всегда должна выделяться одна цель, один вопрос, на который хочешь узнать ответ. Заодно это позволит вовремя остановиться — достаточно просто задать себе те же вопросы и понять, можешь ли ответить на них, и насколько ответы отличаются от тех, которые были бы в начале исследования.</p><p>Основной вопрос, который я задал себе — <strong><code>&quot;Как делать игры быстрее, качественнее и успешнее?&quot;</code></strong>. Основной стимул, чтобы спросить себя об этом — желание понять, почему разные компании делают игры различного уровня, и как получается, что команда из 100 человек может сделать за тот же период больше, чем команда из 1000 человек (разницу в 10 раз сложно списать на то, что в более производительных компаниях каждый сотрудник в 10 раз лучше, чем у конкурентов). А также осознание собственных пробелов в знаниях в разработке игр, несмотря на то, что я занимаюсь этим уже много лет, вариант синдрома самозванца. </p><p>Ещё одно желание - лучше понять рынок, на котором зарабатывают деньги компании, в которых я работал и работаю (<strong>и, вероятно, буду работать</strong>). Вопрос об уровне понимания рынка также можно сформулировать более прагматично, “Если я буду делать то же, что и сейчас, где я окажусь через 10 лет?”, или, более правильно, <strong><code>&quot;Что я должен сделать сегодня, чтобы через 10 лет оказаться там, где я планирую оказаться?&quot;</code></strong>.</p><p>Я понял, что люди боятся задавать себе такие вопросы по банальной причине, у них нет ответа на намного более простой вопрос - “Хочу ли я заниматься тем, чем занимаюсь, через 10 лет”. Если скрываемый ответ на него - “нет, я мечтаю совсем о другом”, то любые попытки планировать на длительный срок провалятся. Очень сложно планировать то, чего втайне пытаешься избежать. Из-за этого люди так редко могут заниматься планированием собственной смерти, хочется увиливать от этого вопроса, обманывая себя тем, что ещё не время думать о том, чего не желаешь. И, наоборот, уважение других к тем, кто планирует собственную смерть, базируется на предположении других людей о том, что человек, занимающийся планированием, или хочет умереть, или не боится смерти настолько, чтобы не прятать свои мысли и планы об этом.</p><p>Мы все немного боимся неизвестности будущего, но каждый из нас окажется в точке “через 10 лет”, просто кто-то придёт туда с закрытыми глазами, а кто-то — с предположениями о том, через что ему предстоит пройти. Тот, чьи предположения более качественны, будет в лучшем положении, чем тот, кто идёт вслепую, или тот, чьи догматические представления устарели, потому что мир изменился. Это не какие-то высокие красивые пафосные речи, а простое желание жить и работать качественно и комфортно.</p><p>Все люди умеют мыслить, но мышление происходит только в рамках усвоенного понятийного аппарата — рассуждения о заработке денег закончившего 9 классов классов выпускника будут отличаться от успешного 23-летнего сениора-программиста (хотя их рассуждения о политике, например, или о прививких от коронавируса, могут находится на одном уровне). Нейронная сеть, обученная на неверных данных, будет давать неправильные результаты. Обучение, во многом - это усвоение новых понятий, чтобы позволить себе производить операции над новыми данными. Однако, с чем пока не справляются искусственные нейронные сети, это осмысление полученного ранее материала, и отброс “мусора”, хранимого в голове. Иногда цель обучения — позволить себе обнаружить мусор в собственной голове.</p><h2 id="Зачем-заниматься-самообразованием"><a href="#Зачем-заниматься-самообразованием" class="headerlink" title="Зачем заниматься самообразованием"></a>Зачем заниматься самообразованием</h2><p>Кроме перечисленных выше идей, полезно расширять знания, чтобы:</p><ul><li>Изучить прошлое, почему какая-либо вещь сделана так, а не иначе, и какие были альтернативные варианты решения</li><li>Изучить настоящее — разобраться с тем, какие вообще решения есть на рынке, чтобы иметь возможность аргументировано выбирать из доступных вариантов, а не пользоваться теми, которые “выбирают все” (если используешь решение, которое выбирают 99%, то навряд ли сможешь обогнать 99% участников рынка)</li><li>Изучить будущее. Понять, что сейчас обсуждают лучшие, и почему они обсуждают именно это. Отчасти, чтобы понять, “куда дует ветер”, и куда будут вкладываться ресурсы, отчасти чтобы понять, правильно ли то, что делаешь ты (если ты собираешься идти по альтернативной дороге, то нужно понимать, собираешься ли ты идти по ней, потому что знаешь что-то, чего не знают другие, или потому, что не знаешь чего-то, что уже знают все)</li><li>Прокачать мозг. Если давно не изучал ничего нового, есть риск того, что мозг просто отвыкнет это делать. В этом случае полезнее учить что-то максимально отличающееся от того, что уже знаешь</li><li>Расширить кругозор. Во многих трудоемких производствах специалисты узкоспециализированы настолько, что могут плохо понимать друг друга. Иногда настолько, что для налаживания контактов между ними нанимается отдельный человек. Пример из геймдева: технический артист, как посредник между 3д-артистами и программистами. В разработке игр иногда программист — слепой исполнитель идей геймдизайнера, что не всегда приятно как для дизайнеров (== проектировщиков игры), так и для программистов</li><li>“Выйти” на идеи действительно крутых людей, которые не будешь понимать без определенной базы. Примеры: по цепочке “Nim-&gt;Smalltalk” я обнаружил идеи Алана Кея, а по цепочке “Архитектура движков от Naughty Dog -&gt; Scheme -&gt; Racket” - эссе Пола Грэма. И Кей, и Грэм — культовые персонажи в мире IT, однако шанс понять, о чём они пишут, а не просто принимать на веру их идеи, немного больше, если имеешь некоторый фундамент</li><li>Нафаршировать голову полезными сведениям. Иногда не знаешь заранее, какие знания могут понадобиться, и где можно найти ответ на интересующие вопросы. Изредка получается, что ответ находится случайно (“серендипные” открытия), так что общая эрудированность может оказаться полезной для решения узкоспециализированных проблем. Отличие самообразования от фаршировки головы в универе — полезные знания не требуется зазубривать, иногда достаточно просто того, чтобы они сидели где-то в подсознании</li><li>Систематизировать знания. Программисты часто являются самоучками, из-за чего часто даже опытные могут иметь пробелы в определенных областях, особенно в тех, которые напрямую не касаются специализации. Особенно много пробелов встречается там, где встречается много Rule-of-thumb, превращающихся со временем в мифы (к примеру, оптимизация кода). Самоучкам тяжелее пересмотреть собственные взгляды из-за того, что исследованное самостоятельно воспринимается более “правильным”, чем чужие идеи</li><li>Оставаться конкурентоспособным. Если ваша команда/компания использует технологии, которые позволяют делать что-то, что не могут конкуренты, то скорее всего ваш продукт будет иметь фичи, которых не будет у конкурентов</li></ul><p><strong><code>&quot;Саморазвитие&quot;</code></strong></p><p>Желание саморазвития само по себе — дурацкий стимул для самообразования. Попробую объяснить, почему так считаю. Во-первых, “саморазвитие” — часто просто эвфемизм для желания стоить больше, как специалист. Это неплохо само по себе, но сейчас возводится в культ в различных компаниях. Я не до конца понимаю, почему компании воспитывают взаимоотношения с программистами, как к наёмниками. Возможно, просто подстройка под моду на самоидентификацию свободного человека (<em>“я свободен, потому что не привязан, и в любой момент могу уйти работать туда, где предложат лучшую зарплату”</em>), или же удобнее для компаний (найм стоит дешевле, чем формы совладения).</p><p>Со стороны компаний — ни разу не видел, чтобы “бюджет на саморазвитие”, или “ценим и поддерживаем стремление к саморазвитию” выражалось в том, что предлагали оплату за изученный материал. Максимум подразумевается компенсация за прохождение курсов начального уровня или возмещение поездок на конференции (но тогда лучше так и писать в объявлениях о найме, будет понятнее и привлекательнее). Часто также со стороны компании под саморазвитием подразумевается прокачка только софт-, а не хард-скиллов.</p><p>Главная проблема — с определенной фазы роста, возможно ли, что программиста или руководителя удержит только его зарплата? Нужны ли компании руководители, выросшие с идеей и привыкшие к тому, что их взаимоотношения с компаниями строятся по принципу “работаю там, где больше платят”?</p><p>В эссе Пола Грэма <a href="http://is.ifmo.ru/reflections/_hackers.pdf" target="_blank" rel="noopener">“Первоклассные хакеры”</a>, есть много тезисов о том, что денег недостаточно, чтобы привлекать высококлассных специалистов (так же, как недостаточно фразы “у нас есть бесплатный кофе и печеньки”). Более привлекательными являются возможность решать интересные задачи, а также работать в коллективе таких же высококлассных специалистов (про это — эссе <a href="https://ideanomics.ru/articles/923" target="_blank" rel="noopener">Города и амбиции</a>). Ценит ли самый лучший специалист возможность саморазвития в таких условиях? Вообще нет, ценится качество общения с коллегами и возможность решения таких задач как самоцель. Хакер подсознательно избегает решения скучных задач, как манекенщица избегает употребления чизбургеров, но возможность решения сложных задач для него — это жажда удовлетворять собственное любопытство, он не думает о саморазвитии, так как это отдаёт тщеславием, которое отупляет не меньше, чем решение скучных задач (“скучные” тут — задачи, решение которых настолько несистематическое, что не даёт возможность сделать каких-либо обобщений). В какой-то степени, для лучших специалистов, качество решаемых ими задач является мерой качества их жизни. Нет какого-либо “развития” в вакууме, есть уровень сложности и количество сложных задач, решённых специалистом. То есть, если приобретение знаний нужно для поиска решения какой-либо сложной задачи (или же, для правильного переформулирования сложной задачи) — это достойная для хакера цель (это не “саморазвитие”, это естественная потребность искателя решения), если же поглощение информации используется как самоцель — это пустая трата времени.</p><p>Другое личное и, возможно, надуманное, наблюдение — хакеры обычно нон-конформисты, при этом западная культера поощряет индивидуализм, а восточная — коллективизм. Выделяющиеся из массовой культуры западные хакеры при этом чаще умеют и любят работать в группе себе подобных, их ценности ближе к коллективистским. Хакеры из восточных культур, наоборот, стремятся к индивидуализму, и меньше любят работать в группах, и “саморазвитие” как ценность только усиливает их желание выделяться, и мешает продуктивной совместной работе.</p><p>В русской IT-культуре происходили процессы, сформировавшие определённое мировоззрение “олдфагов” (хорошо описаны в докладе Евгения Кота, <a href="https://youtu.be/MscM6ciVFdA?t=1532" target="_blank" rel="noopener">Мама, мы все тяжело больны</a>, ссылка на тайминг, другие его доклады тоже неплохи, сборник по <a href="https://vas3k.club/post/11586/" target="_blank" rel="noopener">ссылке</a>). Одна из проблем, которую он описывает в докладе — культ роста, о котором я пишу тут, но я хочу сослаться на описание того, как формировалась IT-отрасль. Какое-то время в IT не было случайных людей, и работать программистами приходили фанатики. Это ещё более актуально для геймдева, где по большей части зарплаты ниже, чем “в среднем по больнице”. Сама специфика разработки игр привлекает фанатиков, и программисты чаще — не наёмники, а творцы, одержимые результатом. Часто в разработке игр именно это творческое желание сделать отличную игру является необходимым условием для того, чтобы игра получилась хорошей. Если взять какую-нибудь книгу типа <code>&quot;Кровь, пот и пиксели&quot;</code>, то, даже, с поправкой на небольшую художественность, видна тенденция к легкой маниакальности творцов (что ближе к саморазрушению, чем к саморазвитию), необходимой для создания шедевров. Индустрия ищет пути создания хитов без боли, но пока не нашла.</p><p>Ещё один аргумент против “саморазвития” как цели — с возрастом всё меньше людей мотивируются именно этим. Я не считаю, что у молодости или зрелости как возраста самого по себе есть какие-либо преимущества, но если данный стимул совсем не работает для людей определенного возраста, то, возможно, это маячок о том, что это ложная ценность. Чем обычно заменяется желание саморазвиваться у более взрослых программистов? Более прагматичным желанием больше зарабатывать, комфортом (иметь возможность больше отдыхать, беречь здоровье, проводить время с семьёй, заниматься хобби). Возможно, самообразование на перспективу 10-15 лет должно быть стимулировано чем-то, что в перспективе приводит именно к таким возможностям.</p><p>Так что, вместо абстрактного и бессмысленного саморазвития, я бы выделил более честные и работающие стимулы образования — <code>возможность решать интересные задачи, возможность выражать себя, и возможность работать максимально комфортно</code></p><p><strong><code>Гигиена</code></strong></p><p>Про желание работать комфортно я расписывал подробнее в посте <a href="/blog/1363625753/" title="Мотивация &quot;честного&quot; программиста">Мотивация &quot;честного&quot; программиста</a>. Во всех компаниях достаточно различного треша, связанного с тем, что всё нужно было сделать быстро, а денег вначале мало, но с какого момента в некоторых компаниях волшебным образом всё становится немного лучше, чем в других. Все хотят работать там, где хорошо, но кто и в какой момент превращает “плохо” в “хорошо”?<br>(если кратко, то порядок трансформации мышления с моей точки зрения такой: <code>честность с собой -&gt; гигиена -&gt; экономия времени -&gt; работа на результат -&gt; икигай</code>)<br>Такая трансформация тоже требует работы над собой и самообразования, и служит одним из главных стимулов становиться лучше в личном и профессиональном плане — что может быть лучше, чем повысить качество жизни и работы себе и окружающим?</p><h2 id="Список-книг-по-темам"><a href="#Список-книг-по-темам" class="headerlink" title="Список книг по темам"></a>Список книг по темам</h2><p>Понятно, что для такого объема материала написать рецензии по отдельным книгам займёт слишком много места, кроме того, если читать книги через призму поиска ответа на определённые вопросы, то и найденная в них информация будет отличаться. Но хотя бы размечу для себя темы, в которых ковырялся в поисках информации.</p><p><code>Гейм дизайн</code></p><p>Сборник книг и материалов - <a href="/blog/3649678047/" title="Путь гейм-дизайнера">Путь гейм-дизайнера</a></p><p>Большая тройка книг по “классическому” гейм-дизайну:</p><p>“Джесси Шелл - Геймдизайн” - самая крутая книга по гейм дизайну, меняющая отношение к разработке игр. У автора есть также несколько очень интесных докладов на различные тематики, от будущего разработки игр, до организации игровых компаний.<br>“Костер Р. - Разработка игр и теория развлечений” + блог автора<br>“Cильвестр Т. - Геймдизайн. Рецепты успеха лучших компьютерных игр”</p><p>“Lovell N. - F2PToolbox”, “The Pyramid of Game Design Designing” - очень важные книги по Free-to-Play геймдизайну.<br><a href="/blog/1402387497/" title="Суперфанаты">Суперфанаты</a> - небольшая выдержка одной из глав, а также несколько статей на схожую тематику.</p><p>“Роджер С. - Новый уровень!”,<br>“Game Design Vocabulatory”,<br>“Adams E. Dormans J. - Fundamentals of Game Design”, “Game mechanics - Advanced game design”,<br>“Fullerton T - Game Design Workshop”,</p><p>“Salen K., Zimmerman E. - Rules of Play Game Design Fundamentals/Anthology” - большая пачка статей с различных сайтов</p><p><code>Языки</code><br>На всякий случай, оговорка - по темам связанным с разработкой и программированием - это далеко не первые книги, которые стоит читать, а дозаполнение некоторой инфы из прошлого. </p><p>“Коплиен Дж. - Программирование на C++” - книга об идиомах раннего C++, можно почитать для фанатов истории.<br>“Страуструп Б. - Дизайн и эволюция C++” - история о том, почему C++ такой, какой он есть, и как работает комитет по стандартизации.<br>“Реймонд Э. - Искусство программирования для Unix”<br><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines" target="_blank" rel="noopener">C++ Core Guidelines</a><br><a href="https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms" target="_blank" rel="noopener">More C++ Idioms</a> - сборник идиом на C++, много устаревшних, но некоторые полезны для понимания кода из STL и Boost.</p><p>“Lippman - Inside the C++ Object Model” - устарело, лучше почитать что-нибудь типа <a href="https://itanium-cxx-abi.github.io/cxx-abi/abi.html" target="_blank" rel="noopener">Itanium C++ ABI</a><br>“Scott Meyers - Effective STL” - по большей части устаревшие советы Мейерса по STL, в дополнение к его более известным книгам из серии “Effective”.</p><p>Доки по Nim, Racket<br>“Stanford LISP 1.6 Manual” - классический мануал по старому лиспу, ради примера на 13-й странице (интерпретатор лиспа на лиспе)<br><a href="/blog/2297379949/" title="Заметки о языках программирования">Заметки о языках программирования</a> - сборник материалов по языкам</p><p><code>Многопользовательские игры</code><br><a href="/blog/1123790904/" title="Шпаргалка по разработке MMO">Шпаргалка по разработке MMO</a> - различные материалы<br>Доклады и интервью Максима Барышникова из Wargaming по устройству их игровых серверов<br>Доклады по устройству серверов Toontown от Disney, сетевому коду файтингов Mortal Kombat/Injustice, Overwatch<br>Документация к <a href="https://www.photonengine.com/pun" target="_blank" rel="noopener">Photon</a></p><p><code>Программирование игр</code><br>“Джейсон Грегори - Игровой движок” - азбука для того, чтобы начать разбираться в движках. Пара тем освещены более детально (скелетная анимация, система задач для игр). Must read, если ещё нет опыта ковыряние с 1-2 движками, иначе — полезно как сборник доп ссылок или для систематизации знаний. Также несколько инсайдов об тулзах, используемых Naugty Dogs. Интересно посмотреть доклады про внутреннее устройство самой компании, а также несколько докладов про использование ими Lisp в играх, и тулзах (Data compiler).</p><p>“Robert Nystrom - Game programming patterns” - хороший сборник паттернов в геймдеве, так или иначе встречающихся почти в каждой игре/движке, уникальная по тематике книга.</p><p>Cборник статей на различные темы - <a href="/blog/2701222076/" title="Gamedev-ссылки">Gamedev-ссылки</a> </p><p><code>Разработка ПО</code><br>“Физерс М. - Эффективная работа с унаследованным кодом” - на мой взгляд более общая и полезная книга о рефакторинге, чем известные книги о шаблонах (которые, вообщем-то, азбука для разрботчиков, которые много работали с различным кодом).<br>“Фаулер М. - Рефакторинг - улучшение существующего кода” - классика, пролистал немного вспомнить содержимое.</p><p>Немного покопался в идеях XP, Scrum, Agile и прочих не очень любимых некоторыми программистами слов в поисках полезных методов.</p><p>“Кент Бек - Экстремальное программирование” - устаревший материал, историческая ценность посмотреть, с каких идей всё начиналось.<br>“Кент Бек - Экстремальное программирование. Разработка через тестирование” - более новый подход, больше о важности тестов и невозможности безопасно изменить старый код и внедрять практики CD без него.<br>“Книберг Х. Скаррин М. - Scrum и Канбан - Выжимаем максимум” - сборник подходов из различных методологий.<br>“Мартин Р. - Идеальный программист. Как стать профессионалом разработки ПО” - скорее сборник эссе том, как применять XP. “Чистый код”, “Чистая архитектура” и “Чистый agile” - все о том же, рассказы с расмазанными по ним общими полезными идеями.</p><p>“Эванс Эрик - Предметно-ориентированное проектирование (DDD)”, “Вон Вернон - Предметно-ориентированное проектирование” - кажется, немного банальные вещи о том, как проектировать программы.<br>“David W. - Object Thinking” - рекомендованная книга по Object Oriented Design.<br>“Fabian R. - Data-Oriented Design” - подход к ECS.</p><p>Cборник материалов - <a href="/blog/2537188794/" title="Прототипирование в геймдеве">Прототипирование в геймдеве</a><br>Cборник материалов - <a href="/blog/381238762/" title="ECS. Ссылки">ECS. Ссылки</a></p><p><code>Бизнес</code><br>“Эрик Рис - метод стартапа”, “Бланк С. - 4 шага к озарению”, “Рис Эрик - Бизнес с нуля.  Метод Lean Startup” - много полезной информации по методу развития продукта Lean development.<br>“Nicholas Lovell - The Curve - How Smart Companies Find High-Value Customers” - понимание бизнес-модели free-to-play и freemium, есть дополнительные доклады и сайт.<br>Ещё немного о командах:<br>“Кэтмелл Э. Уоллес Э. - Корпорация гениев”, доклады про устройство Valve, Supercell, Unity, про бирюзовые организации.<br>“Клейтон М. - Дилемма инноватора”.</p><p>“Коллинз Дж - От хорошего к великому”, “Построенные навечно”, “Великие по собственному выбору” - попытка выделить правила для руководителей успешных компаний. Также иногда просто полезные правила для жизни.<br>“Erika Hall - Just Enough Research”, есть доклады от автора по книге</p><p>Cборник материалов - <a href="/blog/2486671624/" title="Метод Lean Startup">Метод Lean Startup</a></p><p><code>Проектирование, дизайн</code></p><p>“Кристофер Александер - Язык шаблонов”</p><p>“Купер К. - Психбольница в руках пациентов” - взаимоотношение программистов и проектировщиков программ.<br>“Норман Д. - Дизайн привычных вещей” - про то, как дизайн продуктов влияет на то, как их используют пользователи.<br>“Круг С - Не заставляйте меня думать!” - сборник советов по дизайну интерфейсов (на примере веб-страниц).<br>“Stephen P. - Seductive Interaction Design”<br>“Arnheim R. - Visual Thinking” - баловство с тем, чтобы рисовать вместо схем картинки. Скорее вредно, в том виде как подаётся в книге (не поддаётся критике или обработке, в отличие от нормальных схем), но может быть полезным на ранних этапах проектирования.<br>“Эдвард Де Боно - 6 шляп мышления” - способ различного обсуждения идей, кроме критики.<br><a href="/blog/1687824628/" title="Паттерны организации разработки уровней игр">Паттерны организации разработки уровней игр</a> - сборник материалов</p><p><code>Компьютерные науки</code><br>“Александр Степанов - Начала программирования”, “Alexander Stepanov - Notes on Programming” - математический формальный подход к описанию системы типов c++. Полезно, если хочется понять, почему std такой, а не другой, или как туториал к пониманию концептов, ну или просто упороться по формальным описаниям (на мой взгляд, с++ не самый лучший язык для такого).</p><p><code>Пачки советов, интервью</code><br>“97 этюдов для архитекторов программных систем”, “97 этюдов для программистов” - занимательное чтиво, некоторые советы интересны, некоторые смелы, возможно найти что-нибудь интересное для себя.<br>“Сейбел П. - Кодеры за работой”</p><p><code>Психология</code><br>Интересны три приложения - возможность изучить собственные когнитивные искажения, для того, чтобы повысить профессиональные качества, изучить способы взаимодействия команд, и понять психологию геймеров.</p><p>“Чалдини Р. - Психология влияния” - книга, которую важно понять, и на которую часто ссылаются.<br>“Чалдини Р. - Психология убеждения. 50 доказанных способов быть убедительным” - больше примеров к предыдущей книге.<br>“Грин Р. - 48 законов власти и обольщения”<br>“Дэн Ариели - Предсказуемая иррациональность” - объяснение логики потребителя. У Ариэли много докладов и дополнительных материалов с объяснениями различных неосознанных привычек.<br>“Дэниел Канеман - Думай медленно, решай быстро” - понимание того, что у нас 2 системы мышления.<br>“Дернер Д. - Логика неудачи” - старая книга о том, что люди плохо умеют быть рациональными в сложных решениях. Полезна руководителям. Из самых интересных экспериментов — вредность состояния потока при решении сложных задач (поток неосознанно уводит внимание от самой задачи к более простой и увлекающей подзадаче).<br>“Нир Эяль - На крючке” - способ пошагового формирования привычек. <a href="/blog/1891455403/" title="ATARI: Модель крючка">ATARI: Модель крючка</a><br>“Чиксентмихайи М. - Поток”, так есть много доклады и другие книги, по большей части повторяющие основную идею.</p><p>“Bartle R. - Designing Virtual Worlds” - дизайн виртуальных MUD-миров и психология поведения игроков в них.</p><p>“Madigan J. - Getting gamers”</p><p><code>Арт</code><br>“Betty Edwards - The New Drawing on the Right Side of the Brain”<br>“Mccloud S - Understanding Comics”</p><p><code>Литература</code><br>“Кэмпбелл Дж. - Мифический образ”, “Тысячеликий герой”, “Мифы, в которых мы живём”<br>“Пропп В. - Морфология волшебной сказки”, “Народные русские сказки”<br>“Воглер К. - Путешествие писателя”<br>“Даль В. - О поверьях, суевериях и предрассудках русского народа”</p><p><code>История игр</code><br>“Кушнер Д. - Властелины Doom”<br>“Ramsay M., Molyneux P. - Gamers at Work”,<br>“Kent S. - The ultimate history of video games”,<br>“Донован Т. - Играй! История видеоигр”,<br>“Шрейер Дж. - Кровь, пот и пиксели”</p><p><code>Не по темам</code><br>“Минский М. - Вычисления и автоматы”, “Сообщество разума”, “Герберт С - науки об искусственном”, “Armstrong J. Making reliable distributed systems in the presence of sodware errors”, “Адитья Бхаргава - Грокаем алгоритмы”.<br>“Hampden-Turner C. - Maps of the Mind”<br>“Мандельброт Б. - Фрактальная геометрия природы” - крутое введение во фракталы для тех, кому это нужно.</p><p><code>Доклады/статьи</code><br>Devgamm, White Nights, GDC - просто смотрел всё интересное лет за 5 :)<br>CppCon, Accu<br>Отдельно искал информацию про организацию работы в компаниях Wargaming, Playrix, CD Project Red, Pixonic, студий Disney, Naughty Dog, Blizzard, Bethesda, о движках Unity и Unreal (доступные инструменты, причины выбранных решений, формирование взаимоотношений с клиентами, устройство компаний), е-спорт.</p><p>Entitas - Entity System Architecture with Unity - Unite Europe 2015<br>Unite Europe 2016 - ECS architecture with Unity by example<br>Кирилл Надеждин (Kumo Kairo) - ECS в разработке игр — хорошая архитектура приложений для всех<br>Overwatch Gameplay Architecture and Netcode<br>itCppCon19 - ECS back and forth (Michele Caini)<br>Wargaming.net: Архитектура современных 3D движков (DevGAMM Minsk 2014)<br>CppCon 2014: Mike Acton “Data-Oriented Design and C++”<br>Entity system architecture with Unity - Unite Europe 2015<br>Building a Data-Oriented Future - Mike Acton<br>Unity at GDC - ECS for Small Things<br>Unity at GDC - C# to Machine Code<br>Unity at GDC - A Data Oriented Approach to Using Component Systems<br>Entitas ECS Unity Tutorial - Setup &amp; Basics<br>Maxim Zaks - Entity Component System - A Different Approach to Game / Application Development<br>RustConf 2018 - Closing Keynote - Using Rust For Game Development by Catherine West<br>CppCon 2018: Stoyan Nikolov “OOP Is Dead, Long Live Data-oriented Design”<br>Pixonic DevGAMM Talks: Как ECS, C# JS и SRP меняют подход к архитектуре (Валентин Симонов, Unity)</p><p>CppCon 2016: Chandler Carruth “High Performance Code 201: Hybrid Data Structures”<br>Game Development with SDL 2.0 (Steam Dev Days 2014)<br>Painting a Selfie Girl, with Maths<br>Evolution of Torque 3D Engine Games 2001-2016<br>Evolution of Avalanche Engine Games 2006-2019</p><p>Архитектура сервисов Wargaming.net / Максим Барышников / WGDC 13.12.2014<br>Бэкенд-разработка в геймдеве – Максим Барышников, Wargaming<br>Максим Барышников, «WoT: Geographically distributed cluster of clusters»<br>Online Feedme::Meetup #1: Максим Барышников (Wargaming, Head of Platform)</p><p>Photogrammetry w/PhotoScan &amp; Unity - Bring your Photos to Life! (Oculus Rift &amp; Touch)<br>Лекция 9. C10K problem.<br>Threads are an illusion - asynchronous programming with boost::asio - Chris Kohlhoff<br>Witcher Combat part 4 - Hit reaction by body part - UE4 Advanced Blueprints Tutorial<br>8 Frames in 16ms: Rollback Networking in Mortal Kombat and Injustice 2<br>Unite Europe 2016 - Building a PvP focused MMO<br>Balancing Cards in Clash Royale<br>Making a Standard (and Trying to Stick to it!): Blizzard Design Philosophies<br>Интерактивная геометрия на примере кривых Безье<br>Андрей Давыдов — Концепты: упрощаем реализацию классов std utility<br>Custom Editor Window for 4.22 UE4 / Unreal Engine 4<br>КДИ - 172. Unreal Engine<br>КДИ - 248. Польский геймдев<br>Unreal Engine 5 Revealed! | Next-Gen Real-Time Demo Running on PlayStation 5<br>КДИ - 289. Unreal Engine 5<br>КДИ - 280. Naughty Dog, необязательность менеджмента и построение будущего с Promethean AI<br>КДИ - 261. Продюсирование игр<br>КДИ - 172. Unreal Engine<br>КДИ - 206. Playrix про рост, распределенные команды и хиты<br>КДИ - 212. 2D-движки для разработки игр Defold и Corona<br>Психотерапия для геймдева: вопросы, инструменты, практики / DevGAMM Stream<br>От артиста до арт-директора. Путь роста специалиста в геймдеве / Александр Данилов (Playgendary)<br>Илья Крутихин (DigitalForms.info) – Создание игровых персонажей на основе 3D сканов<br>Оптимизация анимационного пайплайна для ААА проектов / Евгений Молоцкий (1C Entertainment)<br>Ты не выгораешь, если ты - огонь! / Вера Величко (Owl Studio)<br>Jonathan Blow, цикл про Jai<br>Дмитрий Гладилин - Проблемы и решения при создании графики для мобильного шутера Guns of Boom<br>Tutorial: extracting textures and 3D models from Android games (part 1: simple example)<br>HOW RIP from OPENGL APPLICATIONS_GAMES<br>Free software, free society: Richard Stallman at TEDxGeneva 2014<br>Animation driven locomotion<br>Сергей Гиммельрейх (GDCuffs) - Паттерны Игровых Механик<br>Pitfalls of Object Oriented Programming, Revisited - Tony Albrecht (TGC 2017)<br>Keynote: CMake: One Tool To Build Them All - Bill Hoffman [ CppNow 2021 ]</p><p>Илья Степанов - пачка лекций по психологии</p><p>LISA13 - Blazing Performance with Flame Graphs<br>Improve app performance with Android Studio Profilers (Google I/O ‘18)<br>Flame graph новый взгляд на привычное профилирование, Кирилл Борисов, Яндекс<br>CppCon 2016: Nicholas Ormrod “The strange details of std::string at Facebook”<br>The Performance Price of Dynamic Memory in C++ - Ivica Bogosavljevic - [CppNow 2021]<br>Classes With Many Fields - Stanisław J. Dobrowolski [CppNow 2021]<br>Keynote: SOLID, Revisited - Tony Van Eerd - [CppNow 2021]</p><p>An Approach to Holistic Level Design<br>Мастер-класс The Art of Legend of Zelda<br>Создание The Legend of Zelda: Breath of the Wild — Начало (часть 1)</p><p>Как создать реалистичную модель города. Проектирование игровых городов<br>Jonathan Blow: Indie Prototyping<br>Game Studio Management: Making It Great<br>When Games Invade Real Life<br>Jesse Schell Keynote: “Information Flow: The Secret to Studio Structure”<br>The Curve - Nicholas Lovell<br>DICE 2010: “Design Outside the Box” Presentation<br>You Don’t Need a F-ing Publisher<br>DYK: Hideo Kojima has built Metal Gear Solid with LEGO<br>Intrinsic vs Extrinsic - Designing Good Rewards in Games - Extra Credits<br>Chris Anderson - Free: The Future of a Radical Price<br>Jesse Schell Keynote at SIEGE2017: Game Studio Management<br>Jesse Schell Keynote: “Information Flow: The Secret to Studio Structure”<br>Game Studio Leadership: You Can Do It<br>КДИ - 310. Геймджемы<br>КДИ -  Дыбовский и Гуро про эволюцию возможностей<br>КДИ - 129. Геймдизайн<br>Stan Just (CD Projekt RED)- Better, Faster, Smarter, Witcher.<br>Создание пользовательской карты для Dota 2<br>Stan Just (CD Projekt Red) - Creating Amazing Art in The Witcher 3: Wild Hunt<br>Creation Kit Tutorial Series - Episode 3: Basic Layout II<br>How Modding Made Bethesda Better<br>How We Used Iterative Level Design to Ship Skyrim and Fallout 3<br>Fallout 4’s Modular Level Design<br>Основы левел-дизайна ярослав кравцов<br>How One Gameplay Decision Changed Diablo Forever | War Stories | Ars Technica<br>Grzegorz Mazur (11 bit studios) - This War of Mine: Under the hood</p><p>How Forza’s Drivatar Actually Works | AI and Games<br>Exploring the AI of Command &amp; Conquer | AI and Games</p><p>Working at the Heart of the Team Part TWO!<br>Give Up Control: Zen and the Art of Leadership<br>Classic Game Postmortem: Sid Meier’s Civilization<br>Absolutely No Pressure: Continuing a Successful Game Series with Civilization VI<br>Ten Principles for Good Level Design<br>Денис Арманд про дизайн уровней War Thunder, Heroes 7 и Destroy All Humans<br>Prototype Based Design<br>Can we Improve Tutorials for Complex Games?<br>GlitchCon 2014: Level Design by Joel Burgess</p><p>CRESSTCon ‘16 Alan Kay Keynote - The Best Way to Predict the Future is to Invent It<br>Алан Кэй делится яркой идеей об идеях<br>Будете гореть, горите! — Евгений Кот, Wrike<br>Евгений Кот | Мама, мы все тяжело больны: 5 проблем в IT, которые вас сломают<br>Евгений Кот — Почему разрабы несчастны — Мы обречены #19<br>Теперь я - тимлид, но почему мне так плохо? Практические советы / Евгений Кот (Wrike)<br>Про инженерный шовинизм: отвратительно быть менеджером / Евгений Кот (Wrike)<br>Lean gamedev<br>Rovio: Angry Birds: Behind The Scenes (Flash GAMM Kyiv 2012)</p><p>Just Enough Research<br>Just Enough Research / Erika Hall - UX Salon 2016<br>Love your Freeloaders, Love your Fans | Nicholas Lovell | TEDxBrum<br>Don’t Call Them Whales: F2P Spenders and Virtual Value<br>Visions of the Gamepocalypse | Jesse Schell</p><p>Алексей Мерсон — Domain-driven design: рецепт для прагматика<br>What is DDD - Eric Evans - DDD Europe 2019<br>Чистая архитектура и Domain-Driven Design</p><p>How Minecraft Changes the Future of Games - Minecraft Generation - Extra Credits<br>Doing Free to Play Wrong - How Bad Monetization Harms F2P Games - Extra Credits</p><p>Дмитрий Алексеев, Евгений Шумаков — Есть ли автотестирование в мобильных видеоиграх?<br>Self control: Dan Ariely at TEDxDuke<br>Cursed Problems in Game Design<br>Александр Штаченко (Playbeat) - Три главных фокуса продюсера<br>Predictably Irrational - basic human motivations: Dan Ariely at TEDxMidwest<br>“Что делать программисту, которого жизнь заставляет заниматься менеджментом?”<br>Level Design in a Day: Level Design Histories and Futures<br>Level Design: Modular Levels in Nier<br>Play Early, Play Often: Prototyping Civilization 4 (GDC 2006)</p><p>CppCon 2019: Andrei Alexandrescu “Speed Is Found In The Minds of People”<br>Bjarne Stroustrup: Why you should avoid Linked Lists<br>Give me 15 minutes and I’ll change your view of Linux tracing<br>Sean Parent - Polymorphic Task - Secret Lightning Talks @ Meeting C++ 2017<br>CppCon 2019: Herb Sutter “De-fragmenting C++: Making Exceptions and RTTI More Affordable and Usable”<br>John Bandela “Polymorphism != Virtual: Easy, Flexible Runtime Polymorphism Without Inheritance”<br>Better Code: Runtime Polymorphism - Sean Parent<br>Dynamic Polymorphism with Metaclasses and Code Injection - Sy Brand - CppCon 2020<br>CppCon 2018: Sean Parent “Better Code: Human Interface”<br>CppCon 2015: Sean Parent “Better Code: Data Structures”<br>Pacific++ 2018: Sean Parent “Generic Programming”</p><p>Gamelab2018 - Jon Blow’s Design decisions on creating Jai a new language for game programmers<br>C++ as Assembly 2.0 - Hello Nim - Viktor Kirilov - code::dive 2019<br>Nim - First natively compiled language w/ hot code-reloading at runtime - Viktor Kirilov [ACCU 2019]<br>RacketCon 2013: Dan Liebgold - Racket on the Playstation 3? It’s Not What you Think!<br>Lambda World 2019 - Language-Oriented Programming with Racket - Matthias Felleisen<br>CLRium #3: Язык программирования Nemerle (Влад Чистяков)<br>Thinking in Immediate: ImGUI - Zhihao Yuan [ ACCU 2021 ]<br>Why Isn’t Functional Programming the Norm? – Richard Feldman<br>Modern C and What We Can Learn From It - Luca Sas [ ACCU 2021 ]<br>Interactive C++: Meet Jupyter / Cling - Neil Horlock [ACCU 2019]<br>Haxe: An understated powerhouse for software development - George Corney [ACCU 2019]<br>CppCon 2016: “WG21-SG14 – Making C++ better for games, embedded and financial developers”<br>The Road to Zig 1.0 - Andrew Kelley<br>Zig: A programming language designed for robustness, optimality, and clarity –  Andrew Kelley<br>Reflection: Compile-Time Introspection of C++ - Andrew Sutton [ ACCU 2021 ]<br>C++20 + Lua = Flexibility - James Pascoe [ ACCU 2021 ]<br>Nemerle pattern matching and algebraic data types<br>Async await in Nim A demonstration of the flexibility metaprogramming can bring to a language</p><p>Блоги:<br><a href="http://www.kostyushko.com/" target="_blank" rel="noopener">http://www.kostyushko.com/</a><br><a href="http://level-design.ru/" target="_blank" rel="noopener">http://level-design.ru/</a><br><a href="https://gdcuffs.com/category/articles/" target="_blank" rel="noopener">https://gdcuffs.com/category/articles/</a><br><a href="http://aushestov.ru/" target="_blank" rel="noopener">http://aushestov.ru/</a></p><p><a href="https://realtimecollisiondetection.net/blog/" target="_blank" rel="noopener">https://realtimecollisiondetection.net/blog/</a><br><a href="https://aras-p.info/" target="_blank" rel="noopener">https://aras-p.info/</a><br><a href="https://floooh.github.io/" target="_blank" rel="noopener">https://floooh.github.io/</a><br><a href="https://www.gameenginebook.com/coursemat.html" target="_blank" rel="noopener">https://www.gameenginebook.com/coursemat.html</a><br><a href="https://solid-angle.blogspot.com/" target="_blank" rel="noopener">https://solid-angle.blogspot.com/</a><br><a href="http://ithare.com/" target="_blank" rel="noopener">http://ithare.com/</a><br><a href="https://cpp-optimizations.netlify.app/" target="_blank" rel="noopener">https://cpp-optimizations.netlify.app/</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;В прошлом году я прочитал больше ста книг, а также посмотрел и изучил несколько сотен статей, лекций и докладов на темы, прямо или косвенно связанные с программированием, гейм дизайном, разработкой игр и развитием. Сам удивился получившейся цифре (основную массу материалов изучил с января по сентябрь), захотел немного расписать, зачем я занялся этим и как получилось разобрать такое количество материала за небольшой срок.&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="книги" scheme="http://spiiin.github.io/tags/%D0%BA%D0%BD%D0%B8%D0%B3%D0%B8/"/>
    
      <category term="dev" scheme="http://spiiin.github.io/tags/dev/"/>
    
      <category term="gamedev" scheme="http://spiiin.github.io/tags/gamedev/"/>
    
  </entry>
  
  <entry>
    <title>Суперфанаты</title>
    <link href="http://spiiin.github.io/blog/1402387497/"/>
    <id>http://spiiin.github.io/blog/1402387497/</id>
    <published>2021-09-21T22:21:21.000Z</published>
    <updated>2021-09-22T07:47:33.658Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Тезисы заметки:</p><ul><li>Не нужно называть фанатов игры “китами”</li><li>Для free-to-play игр самыми важными игроками являются преданные фанаты<a id="more"></a></li></ul><h2 id="Не-называйте-их-“китами”"><a href="#Не-называйте-их-“китами”" class="headerlink" title="Не называйте их “китами”"></a>Не называйте их “китами”</h2><p>Термин “киты” <a href="https://www.bestuscasinos.org/high-rollers-whales/" target="_blank" rel="noopener">пришёл</a> в геймдев из индустрии гэмблинга. Китом там считается игрок, который приходит в казино с банкроллом от 1 миллиона долларов (т.е. может позволить себе оставить эту сумму, когда уйдёт), с разовой ставкой от 25 тысяч долларов. Игроки с банкроллом в 100к-1м$ - всего лишь хайроллеры. В мире около 200 мегакитов (с банкроллом от 10м$), и лучшие казино охотятся на них, стремясь выделиться специальными условиями для того, чтобы завлечь их к себе (бесплатное элитное жильё, персональные бонусы и компенсации за проигрыши).</p><p>Типичные образы самых известных китов — удачливые аферисты (продавец оружия, сверхвезучий игрок, национальная мафия, замешанный в наркоторговле владелец химической компании, мошенник), магнаты (владелец текстильной и химической компании, нефтяник, султан), лудоманы.</p><p>Слова имеют силу (попробуйте не думать о белом медведе). Описанный выше образ игрока в казино приравнивается к величественным животным, которые плавают в мировом океане. Охотники за китами на время охоты отказываются от своей человечности и используют их как мишени для своих <a href="https://ru.wikipedia.org/wiki/%D0%93%D0%B0%D1%80%D0%BF%D1%83%D0%BD%D0%BD%D0%B0%D1%8F_%D0%BF%D1%83%D1%88%D0%BA%D0%B0" target="_blank" rel="noopener">гарпунных пушек</a>. Коммерческая охота на китов <a href="https://ria.ru/20190630/1556003880.html" target="_blank" rel="noopener">запрещена</a> во всем мире, кроме Исландии, Норвегии и Японии.<br><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/JNRz_uG-1Cg" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></p><p>Термин “киты” также используется для обозначения владельцев криптовалют, которые владеют внушительной долей монет. Там он лишён отрицательной коннотации. Однако, в геймдеве подразумевается именно негативное отношение к игроку.</p><p>Рассматривая своих игроков как потенциальных китов, мы дегуманизируем их. Мы создаём образ “лоха”, который настолько глуп, что не заметит “хитрости” нашей системы монетизации. Это оправдывает хищническую тактику “выживает сильнейший”, которая подразумевает охоту за китами до того, как их заманят к себе конкуренты.</p><p>Даже если вы понимаете, что это всего лишь метафора, существует риск того, что кто-то в вашей команде сознательно или бессознательно начнёт использовать эту тактику, либо вы сами подсознательно и незаметно для самого себя переключитесь на такое отношение к своим игрокам. Кроме того, термин просачивается в прессу и в сообщество игроков, на которых навешивается неприятный ярлык.</p><p>Одно дело называть себя Фанатом Игры, другое — признать себя глупым китом, закинувшим денег разработчикам.</p><h2 id="Суперфанаты"><a href="#Суперфанаты" class="headerlink" title="Суперфанаты"></a>Суперфанаты</h2><p>Но дело не только в том, чтобы провести “ребрендинг” плохого слова. Отношение разработчиков к игрокам как к фанатам поможет построить правильное эмпатическое понимание своих пользователей, что в конечном счёте поможет создать коммерчески успешную игру. Т.е. <strong><code>игру, в которую игроки будут продолжать играть так долго, как захотят сами, и в которой они будут покупать вещи, которые действительно ценят, без огорчений по поводу своих покупок</code></strong>.</p><p>Такое поведение игроков отличается от китов в казино. Они не сорят деньгами, а тратят деньги на своё хобби, которому посвящают своё свободное время. Статистика показывает, что поведение игроков, тратящих суммы сильно выше среднего в free-to-play играх — это не поведение азартных игроков, а поведение фанатов, увлечённых чем-либо (аналогично тому, как люди тратят время на хобби, на то что ценят — музыкальные инструменты, спортивные увлечения, путешествия). В русскоязычных книгах/сайтах/конференциях я пока не нашёл дискуссий, исследований или выступлений об этике free-to-play игр, поэтому ссылки на английском.<br><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/P7SDByLlCHw" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div><br><em>Статистика трат игроков и объяснение поведения от CEO Kongregate</em></p><p>Суперфанаты — это не богатые игроки, которые приходят в игру чтобы сорить деньгами, а фанаты, которые давно играют в игру и хотят продолжать покупать вещи, которые им действительно нравятся. <strong><code>Суперфанаты вырастают из фанатов, а фанаты из игроков, играющих бесплатно, поэтому разработчики должны любить всех своих игроков</code></strong>.</p><p>Николас Ловелл в книге <code>The Pyramid of Game-Design</code> пишет об этом детально в главе 7 (<code>The Superfan Layer</code>). Собственно, он автор термина <strong><code>Суперфанаты</code></strong>, и вообще ВСЯ его книга о сервисных играх (большинство из которых сейчас именно free-to-play) с объяснением того, как работает эта бизнес модель и почему она лучше, чем продуктовая или freemium.</p><p>Он разделяет игроков на 3 группы:</p><ul><li>Халявщики (freeloaders) - ~70-90% игроков, которые не будут тратить деньги в вашей игре никогда, и это нормально (сложнее всего разработчикам привыкнуть к тому, что они должны раздавать качественный контент бесплатно, и не мешать игрокам играть бесплатно и без ограничений).</li><li>Фанаты - 90% от платящих игроков, дают около 50% от общей прибыли игры. Обычные игроки, которые могут позволить себе купить что-либо в вашей игре.</li><li>Суперфанаты - 10% от платящих игроков, дают около 50% от общей прибыли игры. Самые преданные фанаты, которые любят вашу игру и проводят за ней много времени.</li></ul><p>Цифры приблизительны, но показывают примерное распределение доходов от различных групп игроков.</p><p>Распространённым мифом среди разработчиков игр (во всяком случае, программистов, с которыми я общался), не знакомых с цифрами, является существенная недооценка доли доходов от суперфанатов. Почему-то считается, что free-to-play модель похожа на freemium, и что распределение доходов от платящих игроков более-менее равномерное, а суперфанаты просто чуть-чуть переплачивают. Хорошее и простое объяснение бизнес-модели от Ловелла:</p><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/iDG4QXb5Yqk" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div><p><em>Ваще, Ловелл выглядит как типичный разработчик Evil-Free-to-Play игр, который хочет получить все деньги игроков, однако внешность обманчива — по его книгам видно, что он самый настоящий гик, который любит игры и много играет сам</em></p><p>Разработчики являются монополистами на все товары в игре для фанатов (только вы можете продать нужный игроку товар в вашей игре), поэтому даже игры одного жанра не конкурируют напрямую друг с другом.</p><p><a href="http://aushestov.ru/%d0%ba%d0%b8%d1%82%d1%8b-%d0%bd%d0%b5-%d0%b2%d0%be%d0%b4%d1%8f%d1%82%d1%81%d1%8f-%d0%b2-%d0%bf%d1%83%d1%81%d1%82%d1%8b%d0%bd%d0%b5/" target="_blank" rel="noopener">Киты не водятся в пустыне</a> — перевод краткой заметки о том, что никто толком не умеет делать правильный free-to-play. Сама заметка ни о чём, намного важнее первая её часть 2012 года - <a href="https://www.gamedeveloper.com/business/next-generation-monetization-supremacy-goods" target="_blank" rel="noopener">Next Generation Monetization: Supremacy Goods</a>, с примерами разбора двух неплохих free-to-play экономик - <code>Worlds of Tanks</code> и <code>League of Legends</code>.</p><p><a href="https://youtu.be/Mhz9OXy86a0" target="_blank" rel="noopener">Doing Free to Play Wrong - How Bad Monetization Harms F2P Games</a> — небольшое видео о типичных ошибках систем монетизации в F2P играх.</p><p><a href="https://www.raphkoster.com/2010/03/18/what-core-gamers-should-know-about-social-games/" target="_blank" rel="noopener">What core gamers should know about social games</a> — важная заметка о социальных играх 2010 года, актуальная и сейчас. Показывает стереотипы разработчиков кор-игр о социальных и казуальных играх, а также степень неприятия ими таких игр (на GDC 2010 представителю Zynga на сцене кричали “вы делаете НЕ игры”). Впрочем, Ловелл в своей книге приводит дальнейшую историю Zynga. Они создали (вероятно вымышленную) <a href="https://techcrunch.com/2009/09/10/zynga-accuses-playdom-of-stealing-trade-secrets-judge-issues-temporary-restraining-order/" target="_blank" rel="noopener">Playbook</a> со списком работающих правил завлечения, и пытались использовать их в других своих играх. Игроки устали обманываться, и популярность игр компании упала, а вместе с тем и доходы компании (с 1.3 миллиарда долларов в 2012, до 700 миллионов долларов в 2014 году).</p><h2 id="Это-не-просто-игра"><a href="#Это-не-просто-игра" class="headerlink" title="Это не просто игра"></a>Это не просто игра</h2><p>Преданные фанаты хорошо знают вашу игру и, скорее всего, уже давно докачались до конца. Они захотят найти в вашей игре что-нибудь, чем можно заняться опытному игроку. Зачастую это различные формы социальной активности — гильдии, кланы, соревнования. Подобный опыт уже давно накоплен в MMO-играх. Игра становится частью социальной жизни игрока.</p><p>Пара примеров возникновения мета-игры (под этим термином сейчас что только не понимают, в данном случае речь идёт об активности в реальном мире, связанной с игрой и влияющей на игру).</p><p><a href="https://www.raphkoster.com/games/essays/a-story-about-a-tree/" target="_blank" rel="noopener">A Story About a Tree</a> — история из текстовой MUD-игры  <code>LegendMUD</code> о Саде Памяти, добавленном разработчиками после смерти Karyn, норвежской девушки, главе одной из игровых гильдий. Родители девушки знали, что она играла в онлайн-игру, и оставили сообщение на её веб-сайте, которое обнаружили фанаты, и распространили в игре. “Сад и дерево Карин напоминают не только о потере известного и любимого человека, но служат маркером момента, когда игроки поняли, что они не просто играли в игру. Социальные связи, которые они чувствовали в игре, были реальными”. Эта история может показаться банальной сейчас (особенно, если учесть, что Karyl оказалась <a href="https://en.wikipedia.org/wiki/LegendMUD#cite_ref-spaight_6-0" target="_blank" rel="noopener">троллем</a>), но впечатляла в 1998 году.</p><p>В <code>EVE Online</code> в игре разрешено воровство, шпионаж и предательство. Самый могущественный альянс в игре был <a href="https://m.igromania.ru/article/14814/Analitika_Kto_predal_Band_of_Brothers.html" target="_blank" rel="noopener">разрушен</a> с помощью предательства. Один из игроков, Mittani, сумел завербовать лидера вражеского альянса. Он отыгрывал в игре роль шпиона, практически на заходя в игру. Игра попадала в реальные <a href="https://www.bbc.com/news/technology-25944837" target="_blank" rel="noopener">новости</a> из-за стоимости потерь в реальных деньгах в ходе игровой войны. Затеявшего эту войну игрока на фестивале Eve Fanfest из-за угроз физической расправы (вероятно) <a href="https://ru.wikipedia.org/wiki/EVE_Online#%D0%A1%D0%BA%D0%B0%D0%BD%D0%B4%D0%B0%D0%BB%D1%8B" target="_blank" rel="noopener">подменили</a> нанятым косплейером.</p><p>Множество историй перехода социальных связей из игры в реальный мир менее драматичны, и даже обыденны, просто потому, что они даже не воспринимаются игроками как что-то необычное.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Тезисы заметки:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Не нужно называть фанатов игры “китами”&lt;/li&gt;
&lt;li&gt;Для free-to-play игр самыми важными игроками являются преданные фанаты
    
    </summary>
    
    
    
      <category term="gamedev" scheme="http://spiiin.github.io/tags/gamedev/"/>
    
  </entry>
  
  <entry>
    <title>ATARI: Модель крючка</title>
    <link href="http://spiiin.github.io/blog/1891455403/"/>
    <id>http://spiiin.github.io/blog/1891455403/</id>
    <published>2021-09-20T14:24:02.000Z</published>
    <updated>2021-09-20T15:00:03.065Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Выдержки из книги Нира Эяля: <code>Hooked. На крючке: как создавать продукты, формирующие привычки</code>.<br><a id="more"></a></p><p>Автор рассматривает модель формирования привычки <strong><code>ATARI - “A Hook: Trigger, Action, Reward, and Investment”</code></strong>.</p><p>Модель крючка состоит из четырех этапов:</p><ul><li>триггер</li><li>действие</li><li>переменное вознаграждение</li><li>инвестиция</li></ul><p>Для того, чтобы сформировалась привычка, данные действия должны совершиться определённое количество раз.</p><p>Нейробиологи считают, что благодаря привычкам мы получаем возможность сконцентрировать свое внимание на других вещах, поскольку сохраняем автоматические реакции в базальных ганглиях — области мозга, отвечающей за непроизвольные действия.</p><blockquote><p>Гурвилл утверждает: шанс у новых игроков появляется тогда, когда они в девять раз лучше прежних. Почему именно на столько? Потому что старые привычки очень живучи, и, чтобы изменить сложившийся порядок вещей, новые продукты должны предложить пользователям радикальные улучшения. По мнению ученого, продукты, требующие значительных изменений в поведении, обречены на провал даже в том случае, когда выгода от их использования очевидна и велика.</p></blockquote><p><strong><code>Триггеры</code></strong> делятся на внешние и внедрённые.</p><blockquote><p>Внедренные триггеры занимают устойчивое место в окружении пользователя. Они постоянно попадаются ему на глаза, хотя именно потребитель решает, стоит ли впускать их в свою жизнь. Например, иконка на экране мобильного телефона, новостная рассылка по электронной почте или уведомление об обновлении приложения появляются лишь в том случае, если пользователь этого хочет.</p></blockquote><p><strong><code>Действие (поведение)</code></strong> -&gt; мотивация, возможность совершения/завершения, триггер (<strong><code>П=МВТ</code></strong>).</p><p>Вы можете не ответить на звонок, если нет мотивации (думаете, что звонит спаммер/мошенник), нет возможности ответить (вы очень заняты или телефон находится далеко), нет триггера для действия (вы просто не услышали звонок).</p><p>Мотивация:</p><ul><li>получение удовольствия/избегание боли</li><li>избегание страха/получение надежды</li><li>получение социального признания/избегание социального неприятия</li></ul><p><code>6 элементов простоты по Фоггу</code>.</p><ul><li>Время на совершение действия.</li><li>Деньги - затраты на совершение действия.</li><li>Физические усилия</li><li>Умственные усилия</li><li>Социальная приемлемость</li><li>Необычность - соотвествие привычному поведению</li></ul><p>Чтобы повысить вероятность совершения действия, Фогг рекомендует разработчикам сфокусироваться на упрощении как функции самого ограниченного в данный момент ресурса пользователя. Что затрудняет потребителю выполнение требуемого действия?</p><blockquote><p>Необходимо понять причину, по которой люди используют продукт. Затем — описать шаги, необходимые потребителю, чтобы получить результат. А когда последовательность задач от намерения до реализации станет понятной, советует начать удалять звенья цепочки до тех пор, пока она максимально не упростится.</p></blockquote><p><code>Эффект дефицита</code> — если осталось всего несколько единиц продукта, его ценность повышается.<br><code>Эффект фрейминга</code> — если давать испытаемым одну и то же вино, но говорить им, что оно по разному стоит, то их восприятие будет отличаться. Они будет не только говорить, что одно и то же вино нравится им больше, но и физиологически это ощущать (измеряли кровоток на томографе). Мало кто из участников эксперимента понял, что каждый раз они пробовали один и тот же напиток. Удовольствие от прослушивание концерта больше, если отдал за билет больше денег, чем если музыканты выступают в метро.<br><code>Эффект якорения</code> — если искусственно повысить цену товара, а потом демонстративно снизить её перед покупателем, то “дорогой” товар со скидкой в 50% или по схеме “два по цене одного” будет продаваться лучше.<br><code>Эффект значительного прогресса</code> — карты с бонусами для получения бесплатного товара всегда выдаются уже частично наполненными. Покупатель намного сильнее хочет заполнить частично заполненную шкалу, чтобы получить подарок. (Пример: большинство квестов в <code>Witcher 3</code> начинаются с некоторого уровня прогресса).</p><p><strong><code>Переменное вознаграждение</code></strong><br><blockquote><p>Результаты их поразили: прилежащее ядро активизировалось не в момент получения вознаграждения (в данном случае — денежной выплаты), а в процессе его ожидания. Исследование показало: побуждает к действию не удовлетворение, получаемое от вознаграждения, а стремление избавиться от страстного желания его получить. Похоже, что нас, как и мышь в экспериментах Олдса и Милнера, толкает вперед стресс, вызванный желанием.</p></blockquote></p><p>Типы вознаграждения</p><ul><li>Вознаграждение племенем (бесплатное желание помочь на сайтах типа stackoverflow, хакерские ценности, экономика фестиваля Burning Man)</li><li>Вознаграждение добычей</li><li>Внутреннее вознаграждение (чувство компетентности + элемент тайны)</li></ul><p>Несколько слов в конце просьбы в 2 раза увеличивают процент согласившихся игроков - <code>&quot;но вы вольны как согласиться, так и отказать&quot;</code>. Исследователи считают: фраза «но вы вольны» лишает человека возможности не задумываясь отказать в просьбе.</p><p><code>Ограниченная изменчивость</code><br><blockquote><p>Неслучайно и Голливуд, и производители видеоигр используют одну и ту же модель «портфеля активов»: обладающая большими финансовыми ресурсами студия занимается производством и дистрибуцией целой линейки кинофильмов или видеоигр, никогда не зная, что из них станет следующим мегахитом. Это отличается от ситуации с продуктами, обладающими «неограниченной изменчивостью» и способными поддерживать к себе постоянный интерес.</p></blockquote></p><blockquote><p>Например, игры, которые играются до завершения, предлагают меньшую изменчивость, чем те, где участвует множество игроков. Участвующие в них люди сами меняют сюжет. Самая популярная в мире многопользовательская ролевая игра <code>World of Warcraft</code> до сих пор (спустя восемь лет после появления) привлекает внимание свыше 10 миллионов пользователей</p></blockquote><p><code>Эскалация обязательств</code> — психологическое явление. Обязательства, которые мы берем на себя, оказывают большое влияние на то, что мы делаем, какие покупаем продукты и формируем привычки. Мы иррационально переоцениваем свои усилия.</p><p><a href="https://ru.wikipedia.org/wiki/%D0%98%D1%80%D1%80%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5_%D1%83%D1%81%D0%B8%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5" target="_blank" rel="noopener">Эффект IKEA</a> — мы начинаем больше ценить продукт, который частично создали сами. Более того, нам начинает казаться, что <strong>другие</strong> люди тоже сильнее ценят этот продукт. Например, собственные дети “ценятся” выше других, потому что на их воспитание было потрачено много сил.</p><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/wfcro5iM5vw" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div><p><em>Predictably Irrational - basic human motivations: Dan Ariely at TEDxMidwest</em></p><p>Ден Ариэли в книге <code>Предсказуемая иррациональность</code> описывают множество законов нашего поведения, которые иррациональны, но предсказуемы, в том числе численно (название не обманывает :)).</p><p>Его способ дизайна экспериментов веселит и вызывает желание попробовать проверить его выводы самостоятельно. Выводы в стиле “Мы нашли способ абсолютно уничтожить склонность людей собирать роботов из Лего”, или “Самым сложным было убедить бухгалтеров MIT, что счёт за пиво в 1400 долларов был связан с расходами по проведению исследования”.</p><p>Мы стремимся вести себя так же, как раньше, и также избегать когнитивного диссонанса. Эти три тенденции влияют на наши будущие действия.</p><p><strong><code>Чем больше усилий мы к чему-то прикладываем, тем сильнее это ценим</code></strong>.<br><strong><code>Мы склонны поступать так же, как в прошлом</code></strong>.<br>И наконец, <strong><code>мы меняем наши предпочтения, чтобы избежать когнитивного диссонанса</code></strong>.</p><p>Если суммировать, эти тенденции приводят к психическому процессу, известному как <code>рационализация</code>: мы меняем свое отношение и убеждения ради психологического комфорта. Рационализация помогает нам находить причины нашего поведения, даже если они созданы кем-то другим.</p><blockquote><p>Тратя на что-то время, вы начинаете верить, что “это стоящая вещь. Почему? Потому что я трачу на это время!” Следовательно, стоит вложить двадцать долларов, потому что потрачена масса времени! А теперь, после вложения двадцати долларов, это точно что-то стоящее, ведь только дурак выбросит такие деньги на ветер».</p></blockquote><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/nG_PbHVW5cQ" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div><p><em>DICE 2010: “Design Outside the Box” Presentation</em><br>На 9:34 пример использования подкрепления “Я могу стать лучше, чем мой настоящий друг в игре, если потрачу 20 долларов”, с переходом через “20 долларов доказывают всем, что я лучший”, на “игра ценна для меня, потому что я потратил на неё деньги и время”.</p><blockquote><p>Как говорил мне Джош Илман, бывший старший менеджер компании по продукту, «если вы смогли убедить пользователя добавить хоть чуть-чуть данных, вероятность его возвращения на сайт намного увеличивается». Небольшие усилия, связанные с предоставлением информации о себе, создают мощный стимул для повторного обращения к сервису.</p></blockquote><p><strong><code>Инвестиция</code></strong></p><p>Пользователи могут инвестировать:</p><ul><li>заполнение профиля</li><li>указание собственных предпочтений</li><li>кастомизация внешнего вида продукта</li><li>собственный список подписок на контент</li><li>усилия по созданию репутации</li><li>усилия, потраченные на изучение продукта</li></ul><p>Инвестиция может быть разбита на мелкие шаги — пользователю предоставляются простые задачи на первых этапах, и более сложные на последующих циклах формирования привычки.</p><p><strong><code>Главное, не забывать об этике!</code></strong><br>Если вдруг забудете, не следует считать, что вы тут же станете злым гением, <code>пользователи быстро вас раскусят и уйдут к конкурентам</code>. Кроме того, вы испортите репутацию не только себе, но и своему продукту, компании, жанру, и социальным играм вообще.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Выдержки из книги Нира Эяля: &lt;code&gt;Hooked. На крючке: как создавать продукты, формирующие привычки&lt;/code&gt;.&lt;br&gt;
    
    </summary>
    
    
    
      <category term="книги" scheme="http://spiiin.github.io/tags/%D0%BA%D0%BD%D0%B8%D0%B3%D0%B8/"/>
    
      <category term="dev" scheme="http://spiiin.github.io/tags/dev/"/>
    
  </entry>
  
  <entry>
    <title>Метод Lean Startup</title>
    <link href="http://spiiin.github.io/blog/2486671624/"/>
    <id>http://spiiin.github.io/blog/2486671624/</id>
    <published>2021-09-19T22:02:21.000Z</published>
    <updated>2021-09-20T14:17:06.202Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Выдержки из книг Эрика Риса <code>Lean Startup</code> и Стива Бланка <code>Четыре шага к озарению</code> с комментариями.</p><p>В русском варианте она называется <code>Бизнес с нуля: Lean startup</code>, что сбивает с толку. В книге разбираются случаи как запуска нового бизнеса, так и создания нового продукта в рамках существующих компаний. Кроме того, книга не про <em>Стартапы</em> (у этого слова уже давно образовалось самостоятельное значение в русском языке), а про <em>Запуск новых продуктов</em>. Так что корректнее было бы перевести название как <code>Способ экономного запуска новых продуктов</code>. С таким переводом читатели скорее заинтересуются методикой, которая может быть адаптирована для различных типов проектов. Например, Николас Ловелл в книге <code>The Pyramid of Game-Design</code> описывает использование элементов методологии в разработке игр.<br><a id="more"></a></p><h2 id="Любая-игра-—-инновация"><a href="#Любая-игра-—-инновация" class="headerlink" title="Любая игра — инновация"></a>Любая игра — инновация</h2><blockquote><p>Почти все, с кем мне приходится общаться, считают, что по крайней мере в их отрасли проекты терпят неудачу по серьезным причинам: они всегда рискованны, состояние рынка непредсказуемо, а сотрудники крупных компаний не могут похвастаться творческими способностями. Некоторые полагают, что если мы просто будем действовать не спеша, с большей тщательностью, то сможем избежать многих неудач, реализуя меньше проектов, но делая это более качественно.</p><footer><strong>ries</strong></footer></blockquote><p>Ага, геймдев — экстремально hit-driven отрасль разработки, в которой нормальным считается успех 1-2 проектов из 10. <code>Supercell</code>, которые являются эталоном и лучшими, запустили 4 успешных проекта, закрыли 13 на этапе софт-ланча, и неизвестно сколько ещё на более ранних непубличных этапах.</p><p>Для игры на ранней стадии разработки не всегда понятно, где же обнаружится фан, и какой она станет в итоге. Некоторые примеры серьёзной трансформации жанров игр в ходе прототипирования я собирал в заметке о прототипировании игр (раздел <code>Путь от прототипа к результату</code>) - <a href="/blog/2537188794/" title="Прототипирование в геймдеве">Прототипирование в геймдеве</a></p><p>(Кроме трансформации жанра естественно происходит и трансформация аудитории игры)</p><p>Игры на рынке не могут быть просто более дешёвой версией другой качественной игры, как это могло бы быть с другими типами товаров, поэтому любая игра — это инновация, со своим уникальным рыночным предложением(<code>Unique Selling Point</code>). Тайнан Сильвестр в книге <code>Гейм-дизайн. Рецепты успеха лучших игр</code> использует для описания уникального предложения концепцию <strong><code>Кривая ценности</code></strong>. Примеры относительного сравнения нескольких игр<br><img src="/blog/2486671624/usp_small.png" alt="usp"></p><p>Смысл графика кривой ценности — AAA-игры должны обладать несколькими уникальными особенностями, чтобы выделяться на фоне других по их совокупности, в то время как инди-игры могут сосредоточиться на чём-то одном, проигрывая по другим параметрам. Тем не менее, любая игра делает предположение о том, нужно ли что-то игрокам (например, “Чокнутая креативность”, за счёт которой популярна <code>Garry&#39;s Mod</code>).</p><p>Задача бережливого запуска — найти способ проверить гипотезу о том, настолько ли нужно игрокам то, в чём игра будет лучше других, как это ожидают разработчики, до окончания полного цикла разработки и вывода игры на рынок.</p><h2 id="Minimum-awesome-product"><a href="#Minimum-awesome-product" class="headerlink" title="Minimum awesome product"></a>Minimum awesome product</h2><blockquote><p>Другие считают, что есть люди, обладающие врожденным даром понимать, что нужно делать, а что - нет. Если нам удастся найти достаточно таких магов и волшебников, это решит все наши проблемы. Но такой подход мог бы быть оправдан разве что в XIX веке, когда о современном менеджменте еще никто не слышал. Мир меняется все быстрее, и такие древние подходы давно потеряли эффективность. При этом вина за неудачу проекта и провал бизнеса часто возлагается на высшее руководство, от которого ждут невозможного.</p></blockquote><p>Есть такое, менеджеры хотят найти супер-таланты, если что-то не получилось - виноват продюссер, суперчеловек, который должен нутром чувствовать, как надо всё делать.</p><blockquote><p>Многие опасаются, что конкуренты, особенно крупные корпорации, украдут идею стартапа. Но если бы хорошую идею было так легко украсть! Ведь это и есть одна из основных проблем стартапов: почти невозможно добиться того, чтобы вашу идею, компанию или продукт заметил хоть кто-нибудь, а тем более конкуренты. Иногда предпринимателям, которые этого боятся, я даю такое задание: возьмите какую-нибудь свою идею (например, одну из ваших последних разработок), выясните, как зовут продукт-менеджера какой-нибудь крупной корпорации из той сферы, к которой относится ваша идея, и попытайтесь заставить эту компанию украсть ее. Позвоните этому менеджеру, напишите ему письмо, отправьте пресс-релиз - давайте, попробуйте!</p></blockquote><p>У каждой второй компании есть <em>сверхсекретный прототип игры</em>, которые нельзя показывать никому, особенно игрокам, пока их официально не анонсируют (например, чтобы не склонировали по быстрому китайцы)</p><blockquote><p>Но если конкуренты смогут опередить стартап, как только увидят его идею, он обречен. Создавать команду, чтобы реализовать новую идею, нужно лишь в том случае, если вы уверены, что сможете пройти цикл обратной связи «создать-оценить-научиться» быстрее всех остальных. Если это так, не имеет значения, что знают о вашей идее конкуренты. А если нет, значит, у стартапа есть очень серьезные проблемы, и секретность их не решит. И стартовое преимущество, полученное за счет работы в режиме секретности, вдали от клиентов, едва ли тут поможет. Единственный путь к победе - учиться быстрее всех.</p></blockquote><p>Идея метода — не создавать большой и дорогой продукт, а попробовать продавать клиентам полуготовый, просто чтобы понять, нужен ли он им вообще в задуманном виде, или же какие-то первоначальные предпосылки были ошибочными и их нужно менять.</p><blockquote><p>Чаще всего предприниматели сначала создают продукт, а потом проверяют, как отреагируют на него клиенты. Но я предлагаю поступать как раз наоборот и таким образом избегать ненужных трат.</p></blockquote><p>Рис — автор широко известной сейчас концепции <strong><code>Minimum valuable product</code></strong> (MVP) — продукт, который уже можно продать пользователям для того, чтобы понять, нужен ли он им. Этим продуктом может быть вообще не программа, а просто форма предзаказа на сайте, группа в соцсети или кампания на Kickstarter.</p><blockquote><p>Да, иногда клиенты считают, что MVP- продукт недостаточного качества. Если так, это нужно использовать для того, чтобы понять, какие опции важны для клиентов. Такой подход гораздо результативнее, чем теоретические размышления о стратегиях, потому что он дает прочные эмпирические основания для создания будущих продуктов.</p><p>Будьте готовы к тому, что MVP может принести дурные вести.<br>В отличие от традиционного тестирования концепции или опытных образцов, MVP предназначен для того, чтобы проверить весь спектр вопросов, а не только те из них, что связаны с дизайном или технологиями.</p></blockquote><p>Применительно к геймдеву, пара замечаний от Ловелла:</p><p>Часто компании бояться выпустить игру прохого качества. Некоторые запускают тестовые игры под другим брендом. Такой способ позволяет без шумного запуска проводить исследования на небольших группах игроков без риска привлечь лишнее внимание, которое не нужно проектам на этапе исследований.</p><p>Программисты часто плохо понимают концепцию MVP, не так, как дизайнеры или бизнес, поэтому Ловелл <a href="https://www.gamesbrief.com/2014/04/make-a-minimum-awesome-product/" target="_blank" rel="noopener">выделяет</a> отдельные прототипы:<br><strong><code>Minimum Feasible Product</code></strong> — техно-демо, прототип того, что команда может реализовать задуманное.<br><strong><code>Minimum Desirable Product</code></strong> — минимальный продукт, в который захотят поиграть пользователи.<br><strong><code>Minimum Viable Product</code></strong> — минимальный продукт, который продаётся для проверки того, рентабельно ли делать игру.<br>В сумме необходимо получить <strong><code>Minimum Awesome Product</code></strong>, который можно тестировать и развивать.</p><blockquote><p>Если мы не знаем, кто наш клиент, мы не знаем, что такое качество.</p></blockquote><h2 id="Что-такое-качество"><a href="#Что-такое-качество" class="headerlink" title="Что такое качество"></a>Что такое качество</h2><blockquote><p>Концепция бережливого производства определяет ценность как создание преимуществ для клиента, а все остальное - затраты. Если речь идет о сфере производства, клиента не волнует, как сделан продукт, - ему нужно, чтобы он как следует работал. Но стартап еще не знает, кто его клиент и что для него ценно. Это одно из проявлений той самой неопределенности, с которой постоянно сталкиваются стартапы. </p><p>Но все наши действия, не помогавшие нам учиться, приводили к потерям. Так можно ли было учиться, не тратя столько усилий? Конечно, можно.</p></blockquote><p>Звучит, как будто Рис нашёл очевидное простое решение. На самом деле вроде и очевидное, но не простое — изучать клиентов итеративно вместе с итерациями развития продукта.</p><blockquote><p>Вот мысль, не дававшая мне спать по ночам: нужно ли нам было тратить время и силы на разработку ненужной фичи? Что, если бы мы выяснили, насколько некорректны наши предположения, вообще не создавая продукт? Например, предложили бы клиентам испытать продукт исключительно на основании его возможных опций, еще до того, как приступить к созданию полной версии?<br>Все эти терзавшие меня мысли не имели отношения к моим должностным обязанностям. Я был руководителем отдела разработки и должен был обеспечивать своевременное создание качественных продуктов и опций. Но если многие из этих опций - пустая трата времени, то что мне оставалось делать? Как избежать этих трат?</p></blockquote><p>Угу, программисты программируют, дизайнеры дизайнят, артисты создают красивый арт — все делают всё хорошо, что же может пойти не так?</p><blockquote><p>Но теперь мое взаимодействие с пользователями изменилось. Внезапно у меня возникли вопросы, на которые нужно было срочно ответить: почему клиенты не реагируют на «совершенствование» продукта? Почему все наши усилия ни к чему не приводят?</p><p>Во время встречи я задал членам команды простой вопрос, который всегда задаю основателям стартапа: «Становится ли ваш продукт лучше?» Они всегда отвечают: «Да». Тогда я спрашиваю: «Откуда вы об этом знаете»?<br>И каждый раз получаю один и тот же ответ: «Ну, мы занимаемся разработкой и в этом месяце ввели множество изменений, нам кажется, что нашим клиентам они понравятся, и наши общие показатели в этом месяце улучшились. Должно быть, мы на верном пути». И еще важнее: как мы узнаем, что правильно понимаем и интерпретируем эти изменения?</p></blockquote><p>Нет инструментов для измерений — нет никакой точной информации, станет ли игрокам нравиться играть больше, или нет. Более того, неправильные измерения могут являться <code>метриками тщеславия</code>, улучшающим настроение разработчиков, но не популярность игры у игроков.</p><blockquote><p>Инженеры, дизайнеры и маркетологи - мастера оптимизации. Скажем, специалисты по директ-маркетингу проводят сплит-тестирование, чтобы выяснить мнение потребителей о ценности нового продукта. Они отправляют разные предложения двум одинаковым группам клиентов, а потом оценивают различия в реакции этих двух групп. Инженеры, конечно же, умеют повышать производительность продукта, а дизайнеры делают его удобным в использовании. Все эти действия в стабильной традиционной организации дают постепенные преимущества при постепенных усилиях.<br>До тех пор, пока мы хорошо выполняем план, наш труд приносит результат. Однако в случае со стартапом такие инструменты совершенствования продукта не работают. Если вы создаете ненужный продукт, его оптимизация или маркетинг ни к чему не приведут</p></blockquote><h2 id="Опасность-создания-хорошего-ненужного-продукта"><a href="#Опасность-создания-хорошего-ненужного-продукта" class="headerlink" title="Опасность создания хорошего ненужного продукта"></a>Опасность создания хорошего ненужного продукта</h2><blockquote><p>Неприятная особенность нежелания разбираться в причинах неудач заключается в том, что все участники молча признают невозможность спрогнозировать успех, считая, что в индустрии высоких технологий все зависит лишь от удачи и случая. Это явление, в свою очередь, положило начало подходу к инвестированию, которое инвесторы называют spray-and-pray («стреляй куда придется и молись, чтобы попало»): небольшие суммы денежных средств вкладываются во множество предприятий, а затем остается лишь надеяться на то, что хотя бы одно из них окажется успешным.</p><footer><strong>Алан Купер</strong><cite>Психбольница в руках пациентов</cite></footer></blockquote><p>Дороже разработки программ может быть только разработка плохих программ</p><blockquote><p>Главный вопрос нашего времени не в том, можно ли это сделать, а в том, нужно ли. Мы переживаем необычный исторический момент: наше будущее процветание зависит от коллективного воображения человечества. </p><p>«Конечно же, нет ничего более бесполезного, чем эффективно делать то, что вообще делать не нужно». </p></blockquote><h2 id="Где-искать-знания-о-клиентах"><a href="#Где-искать-знания-о-клиентах" class="headerlink" title="Где искать знания о клиентах?"></a>Где искать знания о клиентах?</h2><p><strong><code>Постоянно собирать с помощью экспериментов</code></strong></p><p><a href="https://youtu.be/5WtB5FRn-Sc" target="_blank" rel="noopener">Just Enough Research / Erika Hall - UX Salon 2016</a></p><ul><li>Если хотите знать, кто в действительности владеет знаниями о клиентах в вашей организации - это не кто-то на высоком посту, а часто люди из службы поддержки.</li><li>Никогда не просите людей что-то предсказать. Вы не заработаете денег если поймёте, что люди считают о себе, вы заработаете их если поймёте что люди реально делают.</li><li>Поставьте вопросы -&gt; соберите данные для ответа на ваши вопросы -&gt; проанализируйте данные</li><li>Data-&gt;Meaning-&gt;Useful insights</li></ul><p><strong><code>Поставить вопросы, собрать данные от клиентов, понять смысл собранных данных, затем, возможно, получить инсайты</code></strong></p><p><strong><code>Генти Генбуцу</code></strong> - “Иди и посмотри сам”.<br><blockquote><p>In a startup no facts exist inside the building, only opinions. для стартапа в офисе не существует никаких фактов, только мнения.</p><p>Нельзя решить проблему, если ты её не понимаешь, а чтобы понять, нужно её увидеть. Недопустимо полагать что-то само собой разумеющимся или полагаться на рассказы других. Стив Бланк уже много лет убеждает предпринимателей в том, что информацию, которую нужно собрать о клиентах, рынках, поставщиках и каналах сбыта, можно найти только «на улице». Так что вставайте из-за стола и отправляйтесь знакомиться с ними! </p><footer><strong>blank</strong></footer></blockquote></p><p><a href="https://en.wikipedia.org/wiki/Five_whys" target="_blank" rel="noopener">Метод пяти почему</a> - кроме устранения очевидной неисправности находить её первопричину.</p><p><a href="https://netology.ru/blog/karty-empatii-v-marketinge" target="_blank" rel="noopener">Карта эмпатии</a> — способ описать накопленные знания о клиентах, используемый маркетологами.</p><p>Алан Купер в <code>Психбольница в руках пациентов</code> предлагает немного похожий <a href="https://habr.com/ru/post/248063/" target="_blank" rel="noopener">метод персон</a>, больше ориентированный на дизайнеров/проектировщиков, описывающий взаимодействия и сценарии использования клиентами продукта.</p><h2 id="Проблемы-традиционного-планирования"><a href="#Проблемы-традиционного-планирования" class="headerlink" title="Проблемы традиционного планирования"></a>Проблемы традиционного планирования</h2><blockquote><p>Одна из причин - в «сокрушительном обаянии» хорошего плана, основательной стратегии и всесторонних исследований рынка. Прежде они служили надежными индикаторами вероятности успеха, и потому очень соблазнительно применять их к стартапам. Но это не срабатывает, потому что стартапы действуют в условиях почти что полной неопределенности. Еще не известно, кто их клиенты или каким должен быть их продукт.</p><p>Планирование и прогнозирование точны только тогда, когда они основаны на долгой, стабильной истории деятельности и только в относительно стабильной окружающей среде. А у стартапов нет ни того, ни другого.</p><p>Предприниматели и инвесторы видят: традиционные методы менеджмента не в состоянии решить эту проблему. И зачастую они пускают все на самотек и действуют по принципу «просто сделай это». Согласно этому принципу, если управлять процессом сложно, то лучшая стратегия - хаос. К сожалению, мой личный опыт свидетельствует о том, что это тоже не работает.</p></blockquote><p>“Просто сделай это (хорошую игру), и игроки придут” — игра слов с <a href="https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D0%BB%D0%B5_%D0%B5%D0%B3%D0%BE_%D0%BC%D0%B5%D1%87%D1%82%D1%8B" target="_blank" rel="noopener">мотто фильма</a>, к сожалению почти никогда не работает в реальном мире на тесном рынке.</p><blockquote><p>Проблема многих планов не в том, что они упускают из виду важные стратегические принципы, но в том, что факты, на которых основаны эти планы, не соответствуют действительности. К сожалению, это невозможно обнаружить в теории - такие промахи можно заметить только в процессе взаимодействия продукта и пользователей.</p></blockquote><blockquote><p>Что бы вы сделали по-другому, если бы знали, что только одна из десяти попыток создания нового продукта приводит к рождению прибыльного бизнеса? Стали бы вы продолжать вести дела так же, как сейчас, неделя за неделей, год за годом? Вы, вероятно, удивитесь, но факты таковы, что и крупные, и небольшие компании, и огромные корпорации, и новорожденные стартапы проваливают девять из десяти попыток запуска нового продукта. Для этого не обязательно прожечь миллиарды долларов, продвигая новинку на рынок, где покупатели вовсе не ждут ее.</p><footer><strong>blank</strong></footer></blockquote><p>Мотивирующее предисловие из книги Стива Бланка.</p><p><a href="https://studref.com/417544/ekonomika/strategiya_lanchester" target="_blank" rel="noopener">Стратегия New Lanchester</a> - военная стратегия, используемая и для прикидок в бизнесе. Чтобы конкурировать с монополией/дуополией, нужно тратить на маркетинг в 3 раза больше ресурсов, чем лидер.</p><h2 id="Развитие-знаний-о-клиентах"><a href="#Развитие-знаний-о-клиентах" class="headerlink" title="Развитие знаний о клиентах"></a>Развитие знаний о клиентах</h2><blockquote><p>Развитие понимания клиентов это процесс, параллельный развитию продукта. Мы не отказываемся от видения продукта на каждом шаге экспериментов, но делаем всё возможное, чтобы подтвердить и уточнить его.</p><footer><strong>blank</strong></footer></blockquote><p>Отсюда Бланк делает вывод об удобстве использования Agile-методологии разработки — в короткие итерации цикла разработки удобно вставить пустые “слоты”, в которые будет вставлена информация, полученная в ходе параллельного процесса изучения клиентов.</p><blockquote><p>Разница между победителями и проигравшими проста. Когда топ-менеджмент компании с самого начала выходит из офиса и много и часто общается с потребителями, развитие продукта завершается успехом. Когда судьба продукта отдается полностью в руки департаментов по продажам и маркетингу, которые не вовлечены напрямую собственно в процесс разработки нового продукта, компанию ждет поражение. Здесь нет ничего сложного. В настоящее время большинство компаний предпочитают сосредоточиться на деятельности, не выходя из офиса, чтобы обеспечить представление своего нового продукта рынку.</p><p>Вывод очевиден: внимание к мнению будущих покупателей, умение выйти из офиса и исследовать потенциальных потребителей и рынок до того, как окончательно выбрать свой путь и определить характеристики продукта, — вот константа, которая определяет разницу между победителями и побежденными, вот в чем заключается идея процесса развития потребителей.</p></blockquote><p>Ошибки в стандартной схеме “разработки продукта”: <code>концепция/посев--&gt;разработка--&gt;альфа/бета тест--&gt;запуск/первая поставка</code>:</p><ul><li>Название “модель разработки продукта” - не описывает “не-разработочные” процессы: маркетинг, продажи, найм, обретение клиентов, финансирование.</li><li>Где потребители? Причина неудач - не в развитии нового продукта, а в развитии клиентов и рынков. Недостаточное количество потребителей и отсутствие выверенной финансовой модели.</li><li>Зацикленность на дате получения первой версии продукта покупателем. В действительности факт запуска не означает, что компания понимает своих клиентов и знает, как следует подавать и продавать им продукт.</li><li>Акцент на исполнении плана в ущерб процессам обучения и изучения</li><li>Отсутствие значимых ориентиров для отделов маркетинга, продаж и развития бизнеса</li><li>Использование схемы разработки продукта для измерения продаж</li><li>Использование методологии разработки продукта для измерения успеха маркетинга</li><li>Преждевременное масштабирование</li><li>Смертельная спираль: цена ошибок при запуске продукта.</li><li>Не все стартапы одинаковы (могут сегментировать существующий рынок или создавать новый)</li><li>Нереалистичные ожидания</li></ul><blockquote><p>Однако, даже если нам удалось поднять маркетологов из-за столов и отправить «в поля», карты все равно крапленые и честного выигрыша не получится. Посмотрите на схему разработки продукта. Когда маркетологи могут выяснить, работают ли на самом деле позиционирование, «ажиотаж» и создание спроса? После даты начала продаж первым клиентам. Неумолимый марш к этой дате не предполагает итеративного цикла, который бы говорил: «Если наши предположения неверны, возможно, мы должны попробовать что-то другое».</p><p>Информация и данные о потребителях собираются постепенно, шаг за шагом. Иногда эти шаги могут повести вас в неправильном направлении или заманить в тупик. Вы будете искать неправильных клиентов, не понимая мотивации потребителей и степени важности различных характеристик продукта. Именно способность учиться на своих ошибках отличает успешный стартап от тех, что исчезли без следа.</p></blockquote><h2 id="Кросс-функциональные-команды"><a href="#Кросс-функциональные-команды" class="headerlink" title="Кросс-функциональные команды"></a>Кросс-функциональные команды</h2><blockquote><p>При благоприятных экономических условиях компания может позволить две или три итерации вокруг неудачного запуска продукта или плохих показателей продаж. В более жесткие времена инвесторы менее щедры и считают каждую копейку, прежде чем профинансировать очередной транш.</p></blockquote><p>Совпадает с моими ощущениями по количеству выдаваемых попыток исправить что-то крупными переделками при “традиционной” разработке.</p><blockquote><p>Предприниматель - это должность. Предпринимательство может стать для новаторов хорошим способом развития карьеры в крупных организациях. Тогда менеджерам, способным возглавлять команды и работать по системе «экономичный стартап», не придется покидать компанию, чтобы самореализоваться, или пытаться вписаться в жесткую иерархию традиционных функциональных подразделений. Вместо этого на их визитных карточках будет написано: «Такой-то. Предприниматель». И все. Такие менеджеры могут отчитываться перед руководством, используя систему учета инноваций, и получать вознаграждение в соответствии с достигнутыми результатами. </p></blockquote><p>А также решает проблемы некоторых разработчиков игр, сталкивающихся с недостатком творческой реализации и желанием делать свои инди-проекты по вечерам.</p><blockquote><p>Если мы начнем определять продуктивность команды не как успешное выполнение узкофункциональных обязанностей - в сфере маркетинга, продаж или разработки продукта, а как получение фактических данных, возникнут проблемы. Как мы уже говорили, функциональные специалисты привыкли оценивать свою эффективность в соответствии с тем, сколько времени они тратят на работу. Например, программисты считают, что весь день должны писать коды. Именно поэтому традиционная рабочая атмосфера их так раздражает, ведь им все время приходится отвлекаться: встречи, кросс-функциональные задачи и бесконечные совещания с начальством - все это снижает эффективность. </p><p>Однако эффективность отдельных специалистов не является целью «Экономичного стартапа». Вместо этого нужно создавать кросс-функциональные команды, позволяющие получать подтверждение фактами. Многие методы - действенные показатели, непрерывное развертывание и полный цикл обратной связи «создать-оценить-научиться» - предназначены для того, чтобы побуждать команду оптимизировать отдельные функции. Не так важно, как быстро мы можем создать продукт. Не так важно, как быстро мы можем его оценить. Важнее всего то, как быстро мы можем пройти весь цикл.</p></blockquote><p>Как хочет работать программист полный рабочий день:<br><img src="/blog/2486671624/kot.gif" alt="kot"></p><blockquote><p>Инновации всегда начинаются с видения. Важнее всего то, что происходит дальше. Как мы видели, команды инноваций часто начинают заниматься «пантомимой успеха» и вместо того, чтобы проверять элементы своего видения с помощью настоящих экспериментов, обращают внимание лишь на то, что позволяет подтвердить свою правоту. Или, что еще хуже, они работают «тайно», пытаясь создать зону, свободную от данных, где можно «экспериментировать, не получая никакой обратной связи от потребителей и без всякой ответственности. Каждый раз, когда такая команда пытается продемонстрировать кому-то причинно-следственные связи, рисуя красивые графики общих показателей, она занимается псевдонаукой. Как узнать, что эти причинно-следственные связи соответствуют реальности? Каждый раз, когда команда пытается использовать «желание учиться» в качестве оправдания, она также занимается псевдонаукой. Если в одном цикле итерации мы чему-то научились, давайте подтвердим эти данные в следующем цикле. Только создав модель поведения потребителей, а затем подтвердив, что мы способны использовать наш продукт или сервис, чтобы менять это поведение, можно выяснить, насколько обосновано наше видение.</p></blockquote><p><a href="https://www.businessthink.unsw.edu.au/articles/Angry-Birds-fly-high-again-with-data-analytics" target="_blank" rel="noopener">Отзывы пользователей изменили культуру и игровой дизайн Rovio</a> - статья про то, как сбор данных о клиентах изменил культуру и организацию компании Rovio.</p><h2 id="Переход-на-методы-Lean-Startup"><a href="#Переход-на-методы-Lean-Startup" class="headerlink" title="Переход на методы Lean Startup"></a>Переход на методы Lean Startup</h2><p>“Песочница” инноваций:<br><blockquote><p>Работать в «песочнице» инноваций - все равно что тренировать мышцы. Сначала команда проводит небольшие эксперименты. Возможно, первые из них не дадут ничего для обучения и окажутся не слишком успешными.<br>Но со временем команда будет работать все лучше и лучше и в итоге благодаря подходу небольших партий и действенным показателям начнет получать постоянную обратную связь. При этом обучение будет все более эффективным.</p><p>Я обучаю других своей системе уже много лет и постоянно сталкиваюсь с тем, что переход к концепции подтверждения фактами сначала вызывает отторжение и только потом люди начинают видеть, в чем заключается ее суть. Дело в том, что проблемы, вызванные старой системой, часто бывают неосязаемыми, а проблемы новой системы слишком очевидны. Но тут нужно знать теорию. Если все понимают, что временное снижение продуктивности в переходном периоде неизбежно, то этим процессом можно активно управлять.</p></blockquote></p><p>Кривая жизненного цикла, поиск ранних клиентов:<br><blockquote><p>Новый продукт последовательно принимается 5 категориями - техноэнтузиасты, провидцы, прагматики, консерваторы, скептики.<br>Форма рынка - гауссова кривая, причём между провидцами и массовым рынком - пропасть (мелкие пропасти также и между другими группами.</p></blockquote></p><p>Признаки раннеевангелиста (находятся на 4-5 стадиях)</p><ul><li>Имеет проблему</li><li>Осознаёт наличие проблемы</li><li>Активно ищут решение</li><li>Состряпал решение на коленке</li><li>Имеет или может привлечь средства</li></ul><blockquote><p>Задача развития потребителей — это сделать так, чтобы знания компании о клиентах шли в ногу с разработкой продукта, а также обеспечить уверенность в том, что у продукта, когда он появится на рынке, будут платежеспособные покупатели. идентифицировать ключевую группу провидцев, определить их потребности и убедиться, решает ваш продукт проблему, которую нужно и за которую они готовы заплатить, или нет.</p></blockquote><h2 id="Пивот"><a href="#Пивот" class="headerlink" title="Пивот"></a>Пивот</h2><p><a href="https://ru.wikipedia.org/wiki/%D0%9F%D0%B8%D0%B2%D0%BE%D1%82" target="_blank" rel="noopener">Пивот</a> (вираж?).</p><p>Стартап должен иметь возможность “разворота”, если собранные данные о клиентах показывают такую необходимость. Нашли что-то неожиданное, что любят клиенты — этим стоит попробовать воспользоваться. Также, если не удаётся обнаружить клиентов, стоит попробовать что-то радикально новое. Успешность обучения и виражей определяется тем, что каждая итерация проходит быстрее предыдущей — приближает к конечной цели нахождения своих клиентов и работы с ними.</p><blockquote><p>Чрезвычайно важен сдвиг в сознании. Если это первый продукт, который производит стартап, ваша главная задача, идя навстречу потребителям, — не собрать пожелания в отношении характеристик и расширить их набор впоследствии, а найти потребителей на продукт, который вы уже создаете. Только в том случае, если ваше решение не устраивает никаких потребителей, познакомьте группу разработки продукта с дополнительными пожеланиями клиентов.</p></blockquote><h2 id="Темпы-роста"><a href="#Темпы-роста" class="headerlink" title="Темпы роста"></a>Темпы роста</h2><blockquote><p>Темпы роста зависят прежде всего от трех показателей: прибыльности каждого клиента, стоимости привлечения новых клиентов и количества повторных покупок, совершенных существующими клиентами. Чем выше эти цифры, тем быстрее будет расти компания и тем более прибыльной она будет. Это и есть драйверы модели роста компании. По контрасту у компании, которая знакомит между собой покупателей и продавцов, например у еВау, - другая модель роста. Ее успех зависит в первую очередь от сетевых эффектов, повышающих ее популярность и среди покупателей, и среди продавцов.</p></blockquote><p>Три механизма роста - <code>оплаченный, вирусный, липкий</code>.<br>В отношении жизнеспособного роста действует одно простое правило: Новые клиенты приходят благодаря действиям клиентов, которые пришли раньше. Клиенты, которые пришли раньше, содействуют жизнеспособному росту четырьмя способами:</p><ul><li>Сарафанное радио</li><li>Побочный эффект использования продукта. “Вирусность” продукта (facebook, paypal)</li><li>Затраты на рекламу (затраты на рекламу оплачиваются с доходов, полученных от предыдущих пользователей)</li><li>Повторные покупки или повторное обращение (подписки и сменные/расходуемые компоненты - от электрических лампочек до кристаллов в играх)</li></ul><blockquote><p>Если у нас есть продукт, популярный среди ранних последователей, теоретически его разработку можно остановить. Рост будет продолжаться до тех пор, пока этот первоначальный рынок не исчерпает себя. Затем он замедлится или даже полностью остановится. Проблема в том, что такое  замедление может длиться месяцами или даже годами. </p><p>Некоторые неудачливые компании опрометчиво следуют привычной стратегии. Они используют «показатели тщеславия» и традиционную систему отчетности, и им кажется, что они делают успехи, когда видят, что их показатели растут. Они ошибочно полагают, что улучшают продукт, хотя на самом деле изменение его опций не оказывает никакого влияния на поведение потребителей. Рост происходит только благодаря механизму, который эффективно работает и привлекает новых клиентов, а не благодаря усовершенствованиям в разработке продукта. Поэтому, когда рост внезапно замедляется, начинается кризис. Та же проблема возникает у крупных компаний. Их прошлые успехи были основаны на точно настроенном механизме роста. Если он замедляется или перестает работать, а у компании нет новых инновационных проектов, способных обеспечить новые источники роста, возникает кризисная ситуация. И это может произойти с компанией любого размера. Поэтому нужно одновременно настраивать механизм роста и развивать новые источники роста на тот случай, когда этот механизм перестанет работать.</p></blockquote><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Выдержки из книг Эрика Риса &lt;code&gt;Lean Startup&lt;/code&gt; и Стива Бланка &lt;code&gt;Четыре шага к озарению&lt;/code&gt; с комментариями.&lt;/p&gt;
&lt;p&gt;В русском варианте она называется &lt;code&gt;Бизнес с нуля: Lean startup&lt;/code&gt;, что сбивает с толку. В книге разбираются случаи как запуска нового бизнеса, так и создания нового продукта в рамках существующих компаний. Кроме того, книга не про &lt;em&gt;Стартапы&lt;/em&gt; (у этого слова уже давно образовалось самостоятельное значение в русском языке), а про &lt;em&gt;Запуск новых продуктов&lt;/em&gt;. Так что корректнее было бы перевести название как &lt;code&gt;Способ экономного запуска новых продуктов&lt;/code&gt;. С таким переводом читатели скорее заинтересуются методикой, которая может быть адаптирована для различных типов проектов. Например, Николас Ловелл в книге &lt;code&gt;The Pyramid of Game-Design&lt;/code&gt; описывает использование элементов методологии в разработке игр.&lt;br&gt;
    
    </summary>
    
    
    
      <category term="книги" scheme="http://spiiin.github.io/tags/%D0%BA%D0%BD%D0%B8%D0%B3%D0%B8/"/>
    
      <category term="dev" scheme="http://spiiin.github.io/tags/dev/"/>
    
  </entry>
  
  <entry>
    <title>Путь гейм-дизайнера</title>
    <link href="http://spiiin.github.io/blog/3649678047/"/>
    <id>http://spiiin.github.io/blog/3649678047/</id>
    <published>2021-09-08T21:09:19.000Z</published>
    <updated>2021-09-08T21:15:56.580Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Набросал схему изученных и частично прочитанных книг по гейм-дизайну.<br><a id="more"></a><br>(прочитал Джесси Шелла, и чё-то увлёкся)<br><img src="/blog/3649678047/game_design_path.png" alt="game-design-path"></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Набросал схему изученных и частично прочитанных книг по гейм-дизайну.&lt;br&gt;
    
    </summary>
    
    
    
      <category term="gamedev" scheme="http://spiiin.github.io/tags/gamedev/"/>
    
  </entry>
  
  <entry>
    <title>Паттерны организации разработки уровней игр</title>
    <link href="http://spiiin.github.io/blog/1687824628/"/>
    <id>http://spiiin.github.io/blog/1687824628/</id>
    <published>2021-08-22T15:38:12.000Z</published>
    <updated>2021-08-25T15:10:51.618Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Попытка обобщить принципы, которые применяют различные геймдев команды для улучшения организации разработки уровней, механик, контента. На основе компиляции и конспекта материалов из различных источников.<br><a id="more"></a></p><h1 id="Интро"><a href="#Интро" class="headerlink" title="Интро"></a>Интро</h1><p>Занимался сканированием различных материалов о разработке игр в поисках методов улучшения процесса. Общеизвестные частые и повторяющиеся проблемы различных команд – затягивание сроков разработки, отсутствие способов получить информацию о качестве геймплея на ранних этапах разработки, из-за чего части игры могут быть выброшены или сильно изменены. Общий вектор поиска: сбор информации о методах быстрого создания прототипов для игр, построения этапов пайплайна разработки, организации плейтестов и тестирования кода, а также организационных методах, позволяющих изменить подход к разработке на более аккуратный. Материалы в заметке в основном касаются улучшения пайплайна создания контента, остальное пока в очереди.</p><p>Большая часть этапов создания игры задействует усилия практически всех отделов разработки. Каждый отдел имеет собственный пайплайн, построенный тим-лидом, или иногда проджект-менеджером команды. К примеру, программисты часто применяют наработанные в других отраслях разработки ПО методики - элементы SCRUM, agile разработки, методы канбан, и бережливого производства. Эти же принципы разработки могут быть использованы и в построении пайплайна других отделов, но им необходима некоторая адаптация. Наиболее сложный уровень организации (и самый интересный!) – полный пайплайн разработки игры, с минимизацией простаивания каждого из отделов, и количества лишней работы.</p><p>У меня нет опыта управления всей командой разработки, но, кроме руководства небольшой командой программистов, есть некоторый опыт построения отдельных пайплайнов для различных отделов:</p><ul><li>Помощь в построении пайплайнов работы с ассетами, от переноса ассетов с shared disk в системы контроля версий, и создания системы неймингов, до координации процесса создания моделей, начиная с определения способов экспорта из DCC-приложений, до создания тулзов для компиляции анимаций и тестирования их в игре.</li><li>Создание пайплайна работы с игровыми сценами, начиная с ручной правки текстовых файлов программистами и до организации найма нескольких человек, отдельно для поддержки работы с редактором, и создания в ассетов в игровом редакторе (в ходе этого, организационная работа: трансформация понятий определённых должностей в проекте). Один программист тулзов + 2-3 дизайнера в итоге могут быть сильно дешевле, чем 5-6 “программистов данных”.</li><li>Внедрение в пайплайн разработки контента этапов технической оптимизации (создания необходимых инструментов, документации, инициатива по поиску ресурсов на регулярное проведение этого процесса).</li></ul><p>При этом я чётко понимаю, что оптимизация пайплайна – трудный процесс, который включает в себя не “оптимизацию циферок”, а создание тулзов, перестройку рабочих процессов людей, преодоление организационного сопротивления. Зачастую в ходе внедрения новых процессов появляются непредвиденные проблемы, которые нужно решить так, чтобы не получилось хуже, чем было раньше – нельзя просто “улучшить” и уйти в закат, требуется обучение людей, которые смогут поддерживать работу в новом формате, а не вернут всё назад. Это не самоцель, а вынужденная мера, горькое лекарство в тех случаях, когда работать становится тошно.</p><p>Создание и оптимизация пайплайнов для управления всей командой проекта, на мой взгляд, “следующий уровень” после налаживания таких отдельных пайплайнов, в которых замешаны несколько отделов (артисты - моделлеры, риггеры, аниматоры; технические артисты, программисты, сценаристы, нарративные дизайнеры и левел-дизайнеры, qa). В статье далее я не описываю собственной опыт, а просто компилирую чужой, основываясь на собственном понимании выстраивания пайплайнов и управления небольшими командами. Моя точка зрения – профдеформированное видение “непрограммерской” части разработки игры программистом.</p><p>Статья не о принципах <code>создания уровней</code>, а о принципах <code>организации создания уровней</code> (и другого контента игры). Акцент сделан на создании уровней, потому что 1) про это удалось собрать больше всего публично доступной информации (в основном, благодаря докладам Джоэла Бёрджесса) 2) сборка уровней с нуля – процесс, в который вовлечены различные отделы команды, каждый со своим отличающимся пайплайном производства, которые нужно уметь занять чем-либо, когда они ожидают результатов работы других отделов.</p><h2 id="Материалы"><a href="#Материалы" class="headerlink" title="Материалы"></a>Материалы</h2><p>[к1] <a href="http://level-design.ru/pro-ld-book-index/pro-ld-book-about/" target="_blank" rel="noopener">Михаил Кадиков - Проектирование виртуальных миров</a><br>[к2] <code>Роберт Мартин - Чистый Agile. Основы гибкости</code><br>[к3] <code>Кент Бек - Экстремальное программирование</code><br>[к4] <code>Кент Бек - Экстремальное программирование. Разработка через тестирование</code><br>[к5] <a href="http://scrum.org.ua/wp-content/uploads/ScrumAndKanbanRuFinal.pdf" target="_blank" rel="noopener">Хенрик Книбберг и Маттиас Скарин - Scrum и Канбан: выжимаем максимум</a><br>(использовалась в построении пайплайна <code>World of Tanks: Blitz</code>, <a href="https://gdcvault.com/play/1022375/World-of-Tanks-Blitz-Postmortem" target="_blank" rel="noopener">линк</a>)<br>[к6] <code>Джейсон Шрейер - Кровь, пот и пиксели</code>.</p><p>[д1] <a href="https://youtu.be/H-5m_KDCZdQ" target="_blank" rel="noopener">Prototype Based Design</a> - доклад лид-дизайнера <code>Gear of War 2</code> про прототипирование механик.<br>[д2] <a href="https://youtu.be/y7AV3tNYd5g" target="_blank" rel="noopener">Play Early, Play Often: Prototyping Civilization 4</a> - этапы прототипирования <code>Civilization 4</code>.<br>[д3] <a href="https://youtu.be/DjJoy3Zyk2A" target="_blank" rel="noopener">Stan Just (CD Projekt RED)- Better, Faster, Smarter, Witcher</a> - пайплайн <code>Witcher 3</code> и аддонов.<br>[д4] <a href="https://youtu.be/pzvkB3w1qXQ" target="_blank" rel="noopener">Stan Just (CD Projekt Red) - Creating Amazing Art in The Witcher 3: Wild Hunt</a> - этапы создания контента <code>Witcher 3</code>.<br>[д5] <a href="https://youtu.be/a9wSZ9L_Jk8" target="_blank" rel="noopener">Александр Штаченко (Playbeat) - Три главных фокуса продюсера</a> - или “о чём задумался продюсер”. В начале есть несколько хороших примеров организации команды/структуры проекта, <a href="https://www.slideshare.net/flashgamm/ss-79324254." target="_blank" rel="noopener">слайды</a><br>[д6] <a href="https://youtu.be/_jcvAGqBWzs" target="_blank" rel="noopener">“Что делать программисту, которого жизнь заставляет заниматься менеджментом?”</a> - про переход программистов в менеджеры. Описание организации команд с техническим лидеров в команде управления.<br>[д7] <a href="https://youtu.be/PhW8CY8XkFg" target="_blank" rel="noopener">How We Used Iterative Level Design to Ship Skyrim and Fallout 3</a> - принципы итеративного дизайна от разработчиков из <code>Bethesda</code>.<br>[д8] [Fallout 4’s Modular Level Design] - модульный подход к левел-двизайну <code>Fallout 4</code>.<br>[д9] <a href="https://youtu.be/GxthbWfSak8" target="_blank" rel="noopener">How Modding Made Bethesda Better</a> - как моддинг помогает улучшить качество и время жизни игры.</p><p>[с1] <a href="http://level-design.ru/2011/04/gow2-prototype-based-gameplay/" target="_blank" rel="noopener">Теория: прототипирование геймплея</a> - перевод и анализ доклада [д1].<br>[c2] <a href="https://osoco.es/thoughts/2020/06/notes-about-a-new-software-world/" target="_blank" rel="noopener">Notes about a new software world</a> - статья о Domain Driven Design.<br>[c3] <a href="https://tlroadmap.io/" target="_blank" rel="noopener">Teamlead Roadmap</a> - карта навыков и компетенций тимлидов (всё возможные и невозможные обязанности тимлида, составленные по коллективному опросу десятков российских компаний).<br>[c4] <a href="https://leaden.ru/2015/07/iterative-level-design-process/" target="_blank" rel="noopener">Итеративные процессы в левел-дизайне на опыте Fallout 3 и Skyrim</a> - перевод материалов из лекции [д7].<br>[c5] <a href="http://blog.joelburgess.com/2013/04/skyrims-modular-level-design-gdc-2013.html" target="_blank" rel="noopener">Skyrim’s Modular Approach to Level Design</a> - модульный подход к дизайну <code>Skyrim</code>.<br>[c6] <a href="https://habr.com/ru/post/259171/" target="_blank" rel="noopener">Устройство уровней в NES-играх</a> - описание тайловой системы уровней в старых консольных играх.</p><h1 id="Паттерны"><a href="#Паттерны" class="headerlink" title="Паттерны"></a>Паттерны</h1><h2 id="“Стандартный”-пайплайн"><a href="#“Стандартный”-пайплайн" class="headerlink" title="“Стандартный” пайплайн"></a>“Стандартный” пайплайн</h2><p>В качестве примера для того, чтобы показать способы изменения организации разработки, можно взять обобщённый <a href="http://level-design.ru/pro-ld-book-index/08-production-pipeline/" target="_blank" rel="noopener">стандартный пайплайн создания уровней</a>, приведённый в [к1].</p><blockquote><p>В каждой дисциплине, будь то создание анимаций, спецэффектов, материалов или моделей, существует свой собственный порядок производства контента. Разработка уровней также подразумевает особый цикл работ (в англ. терминологии — “pipeline”)…</p></blockquote><p>Эти этапы, в моём пересказе:</p><ul><li>Планирование<ul><li>Концептуализация (поиск идеи)</li><li>Визуализация (подбор референсов)</li><li>Планирование на бумаге</li><li>Создание технической документации</li></ul></li><li>Играбельный прототип<ul><li>Сборка уровня из коробок (gray boxes)</li><li>Настройка игрового функционала</li><li>Тестирование геймплея</li><li>Обычно - “заморозка” возможности радикальных изменений.</li></ul></li><li>Прототип геометрии<ul><li>Создание черновых моделей всех объектов (с учётом принятых стандартов, привязок/пивотов к сетке мира, модульности)</li><li>Сборка уровня из временных моделей (на основе прототипа), совместная работа художника по окружению и левел-дизайнера.</li><li>Приведение уровня в играбельное состояние (фиксы). Черновая логика диалогов и триггеров.</li></ul></li><li>Финальная сборка<ul><li>Замена временных ассетов на финальные</li><li>Оптимизация производительности</li><li>Тестирование финальной версии</li></ul></li></ul><p>Пара примеров внешнего вида уровней в играх. Стандии играбельного прототипа/прототипа геометрии/финальной сборки в <code>Uncharted 4</code>:<br><img src="/blog/1687824628/gray_box_uncharted.png" alt="gray_box_uncharted"><br>Играбельный прототип в <code>CS:GO</code> (использованы специальные текстуры с нанесёнными отметками размеров), <a href="http://level-design.ru/pro-ld-book-index/08-gameplay-prototype/" target="_blank" rel="noopener">отсюда</a>:<br><img src="/blog/1687824628/gray_box_csgo.png" alt="gray_box_csgo"></p><p>Такая модель последовательного перехода от одной стадии к другой напоминает <a href="https://ru.wikipedia.org/wiki/%D0%9A%D0%B0%D1%81%D0%BA%D0%B0%D0%B4%D0%BD%D0%B0%D1%8F_%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C" target="_blank" rel="noopener">каскадную модель</a> в разработке ПО (“сначала планируем, потом создаём, потом проверяем, потом считаем готовым”).</p><h2 id="Использование-готовой-модели-разработки"><a href="#Использование-готовой-модели-разработки" class="headerlink" title="Использование готовой модели разработки"></a>Использование готовой модели разработки</h2><p>Антипаттерн - “взять готовую модель и попробовать использовать в разработке игр”.</p><p>В качестве примера применения метода разработки на основе “стандартного” пайплайна, можно рассмотреть [д3] и [д4] – доклады об организации пайплайнов производства контента <code>Witcher 3</code> и собственно производства по выстроенному пайплайну, показывающие типичные проблемы такого подхода. Стэн Джаст, продюсер проекта, сертифицированный скрам-мастер, и пайплайн производства, естественно, максимально, “по скраму”.</p><p><em>Ведьмак 3 – моя любимая игра, и с уважением отношусь к продюсеру этого проекта – под его руководством были выпущены крутые игры, и создано колоссальное количество контента в Ведьмаке, скорее всего выбранный метод разработки принёс неоспоримые преимущества, но по каким-то причинам в докладе они не отмечены, а сюжет можно пересказать так: “В ведьмаке мы использовали скрам, это такая методология разработки, ведьмак у нас получился отличный, отака хуйня, малята!”</em></p><p>Пример плохого использования подхода – схема оптимизации процессов:<br><img src="/blog/1687824628/witcher_pipeline_optimization.png" alt="witcher_pipeline_optimization"><br>Максимально общие слова, которые могут быть вообще никак не связаны с процессом разработки (может как-то и связаны, но в докладе это не показано), а отнесены к абсолютно любому проекту: “Собрать данные, проанализировать данные, найти точки блокировки, улучшить дизайн, создать дизайн, поправить ожидаемую дату выхода, повторить”.</p><p>Улучшение показателей может быть достигнуто не за счёт общих слов, а за счёт изменения порядка выполнения каких-либо действий, причём это изменение - это не применение какого-нибудь незыблемого универсального закона, это подстраивание “ручками” существующего в команде процесса. Он зависит от имеющихся ресурсов, в том числе от самой команды - количества людей и их навыков. Например, наблюдение, что на ранних стадиях разработки дизайнерам уровней ещё особо нечего делать, кроме как составлять базовые документы, позволяет перенаправить их на работы с текстами или дизайн других систем.</p><p>Раскидывание задач по этапам - что стоит или не стоит делать на данном этапе, подстроено под сроки выполнения задач специалистов, и может корректироваться от проекта к проекту. Важная часть - сам факт разбиения на необходимое число итераций, каждая из которых несёт определённый смысл, а не придумана “для галочки”. Получить данные о бутылочном горлышке пайплайна, можно с помощью самой используемой системы (для управления временем прохождения этапов подходят, к примеру, “традиционные” для разработчиков доски канбан).</p><p>Для сравнения можно посмотреть на паттерн <code>Выделение стадий прототипирования для устранения взаимозависимостей</code>, который учитывает особенности выполняемых работ.</p><p>Другой настораживающий пример, <a href="https://youtu.be/DjJoy3Zyk2A?t=2207" target="_blank" rel="noopener">подход</a> к оценке финальных сроков - <em>“(стандартная оценка всех работ в проекте в часах + запланированные отгулы)/количество людей в проекте = необходимое на разработку игры количество часов”</em>.</p><p>Это так не работает! Но в мире “чистой методологии” могут применяться даже подобные абсурдные подходы к оценке. Проблема тут в том, что получение ошибок в рассчётах будет приводить к тому, что её адепт станет просто поправлять сроки стандартной оценки работ, а не задумается о том, что время может теряться где-то, кроме непосредственного выполнения работы исполнителем. Другая проблема - “средняя скорость выполнения задач” в мире геймдева это сферический конь в вакууме, сами задачи на разных этапах разработки сильно различаются, отдельные задачи могут зависеть друг от друга не только как этапы конвейера, но и так, что одна задача может создавать или удалять другие.</p><p>В качестве примеров проблем подхода:</p><ul><li>Большие проблемы с кросс-коммуникацией отделов, ежедневные планёрки не работают (<a href="https://habr.com/ru/post/456762/" target="_blank" rel="noopener">https://habr.com/ru/post/456762/</a>)</li><li>Из игры была выброшена половина квестов (<code>Кровь, вот и пиксели</code>, интервью с Матеушем Томашкевичем, <a href="https://cyber.sports.ru/tribuna/blogs/gamesherald/2926468.html" target="_blank" rel="noopener">https://cyber.sports.ru/tribuna/blogs/gamesherald/2926468.html</a>)</li><li>В [д4] приводятся примеры, когда “внезапно” всплывала необходимость создания неучтённого  контента объёмом в 200 человеко-дней (квестовые предметы для кастомизации стандартных NPC). Другой прмер – <a href="https://youtu.be/AweOAU3q8Fg" target="_blank" rel="noopener">ошибки в скорости звука в локализациях</a>, которые исправлять оказалось дорого.</li><li>Недопроверенные прототипы, в [д4] есть пример с разрубанием тел, которое прототипировали, но в игре оно не заработало как надо, из-за чего его пришлось маскировать арт-хаками.</li><li>Сам факт гигантомании игры, если рассматривать его не как заявленную фичу, а как организационную неспособность получить заявленные результаты и качество в установленные сроки.</li></ul><p><a href="https://youtu.be/DjJoy3Zyk2A?t=1120" target="_blank" rel="noopener">Заявленные способы оптимизации процессов</a>. На первом месте “оптимизация пайплайна”. В то же время, на слайдах приводятся, как отмечает Стэн, упрощённые (чтобы влезли на слайды) схемы их пайплайнов.<br><img src="/blog/1687824628/witcher-monsters-pipeline.png" alt="witcher-monsters-pipeline"><br><em>(отметка на слайде - предшествующие этапы пайплайна не показаны)</em> (<a href="https://www.slideshare.net/flashgamm/better-faster-smarter-witcher-production-tips-from-the-witcher-3-wild-hunt-hearts-of-stone" target="_blank" rel="noopener">ссылка</a> на слайды в нормальном разрешении)<br>Заявленная “оптимизация пайплайна” - это лишь то, что они использовали в дополнениях уже готовые ассеты из оригинальной игры в качестве базовых плейсхолдеров, другие отличия не показаны. Все остальные пайплайны максимально похожи на стандартную модель без всяких оптимизаций.</p><h2 id="Четыре-схемы-геймдев-команд"><a href="#Четыре-схемы-геймдев-команд" class="headerlink" title="Четыре схемы геймдев команд"></a>Четыре схемы геймдев команд</h2><p>Из обнаруженных работающих методов в докладе о “Ведьмаке”:<br><strong><code>- Построение руководства команды по схеме &quot;Продюсер + Лид&quot;</code></strong> (в подчинении: 3 2д-артиста, 10 3д-артистов, выделенный QA и тех.артист). Один отвечает за определение сроков, второй за качество. Эти две противоположных цели, и в случае, если руководит один человек, будет перекос в какую-либо сторону.</p><p>Два работающих подхода, “на пальцах”, приведены в [д5]. Там же более серьёзно рассмотрены зоны ответственности и задачи, которые по разному распределяются в различных форматах команды.</p><p>Это, на мой взгляд, важная характеристика структуры команды, соотношение её “вертикальности” (иерархии) и “горизонтальности” (плоских связей). Управленческие роли могут как быть сконцентрированы в одном человеке, так и размазаны между двумя лидерами, или большим количеством людей. Важно это потому, что список навыков и компетенций, которые требуются для руководства проектом, настолько широкий, что один человек не сможет прокачаться во всём. Помимо этого от типа команды зависит, кто в ней может инициировать применение перечисленных ниже паттернов перестройки пайплайна.</p><p><strong><code>Тип 1. Продюсер + линейная команда</code></strong><br><img src="/blog/1687824628/gd_type1_small.png" alt="gd-type1"><br>Сверху - заказчики, издатели, директора компании, стейкхолдеры. Лид-геймдизайнер и скрам-мастер организовывают работу отделов, но находятся на одном уровне с остальной командой. По сути, не один лидер, а три.<br><strong><code>Тип 2. Проджект менеджер + продакт менеджер</code></strong><br><img src="/blog/1687824628/gd_type2_small.png" alt="gd-type2"><br>Два управляющих, разделяющих ответственность. Один отвечает за процессы (результат должен был сделан в срок, качественно, минимальными ресурсами), другой – за продукт (чтобы соотвествовало “хотелкам” стейкхолдеров и рынка).<br><strong><code>Тип 3. Проджект менеджер + Продакт + Техлид</code></strong><br>Больше характерный не для игровых команд. <a href="https://youtu.be/_jcvAGqBWzs?t=3520" target="_blank" rel="noopener">Пример</a>:<br><img src="/blog/1687824628/gd_type3_small.png" alt="gd-type3"><br>Другой пример – <a href="https://tlroadmap.io/" target="_blank" rel="noopener">Teamlead Roadmap</a>, карта навыков тим-лида, обобщённое видение крупных российских компаний, список компетенций включает ветки, которые явно очень сильно перемешиваются с компетенциями других управляющих ролей в проекте.</p><p>Добавляется человек, который может оценивать организацию разработки, изучать её и улучшать, по сути не связан напрямую с продуктом, но имеет ресурсы и компетенции, чтобы улучшать качество работы для всех.<br><strong><code>Тип 4. Плоская команда</code></strong><br>Роли распределяются внутри команды по мере возникновения необходимости, а не “даются свыше”. Пример - <a href="http://media.steampowered.com/apps/valve/hbook-RU.pdf" target="_blank" rel="noopener">Valve</a> и прочие “бирюзовые” компании.</p><h2 id="Выбрасывание-лишних-этапов-пайплайна-разработки"><a href="#Выбрасывание-лишних-этапов-пайплайна-разработки" class="headerlink" title="Выбрасывание лишних этапов пайплайна разработки"></a>Выбрасывание лишних этапов пайплайна разработки</h2><p>Доклады [д1] и [д2], посвященные прототипированию механики, играбельного геймплея и уровней в <code>Gears of War 2</code> и <code>Civilization 4</code> объединяет общая идея – зачем нужны “традиционные” этапы пайплайна в тех случаях, когда они только замедляют время создания чего-то, что можно протестировать?</p><p><a href="https://youtu.be/H-5m_KDCZdQ?t=676" target="_blank" rel="noopener">Выброшенные этапы</a>:</p><ul><li>Дизайн в голове</li><li><del>Документирование</del></li><li><del>Дебаты с обсуждением идеи</del></li><li><del>Сбор команды прототипирования</del></li><li><del>Наигрывание и тюнинг, пока не станет интересно</del></li><li>Ревью перед отправкой в продакшн</li></ul><p>Условия, при которых возможно выбросить этапы пайплайна (в основном – ранние):</p><p><strong><code>- Опытная команда</code></strong><br>Один из авторов доклада [д2] подписан как <em>“Программист/Лид дизайнер”</em> – способен и придумывать идеи, и прототипировать их, без необходимости написания документации. </p><p>Дизайнеры GoW фактически рассказывают о том, что сами программируют достаточно продвинутые механики с помощью <code>Kismet</code> (предок <code>Blueprint-ов</code> в Unreal) и сравнивают <a href="https://youtu.be/H-5m_KDCZdQ?t=890" target="_blank" rel="noopener">два сценария</a> - 1) с документированием и обсуждением (по “традиционному” пайплайну, и 2) сразу визуально проверяя какую-либо идею, комбинируя готовые готовые ассеты с написанием тестовых скриптов.</p><p>Секрет ускорения - наличие “комбинированных” специалистов.</p><p><strong><code>- Наличие хорошего инструмента для прототипирования</code></strong><br>В обоих примерах разрабатывается не первая часть игры, разработчики имеют в наличии набор инструментов и ассетов, с помощью которых быстро могут проверять идеи, а также набор некоторых проверенных базовых механик. Дизайнеру не нужно просить программиста помочь с написанием простых вещей, вроде логики нажатия на кнопки, или способа создать игровой скрипт - таким образом снижаются требования к уровню квалификации дизайнера в программировании. В общем случае, для прототипа и реальной игры могут использоваться различные инструменты.</p><p><em>В статье [с2] описаны среды разработки программ, к которым, возможно, стремятся среды разработки Unity и Unreal в плане лёгкости прототипирования и совместной работы (хотя по многим параметрам редакторы универсальных игровых движков обгоняют чьё-то видение будущего программирования).</em></p><p><strong><code>- Небольшая команда</code></strong><br><a href="https://youtu.be/y7AV3tNYd5g?t=219" target="_blank" rel="noopener">Преимущества</a> работы небольшой команды из доклада [д2]:</p><ul><li>Дизайнер+программист - супер быстрое прототипирование без необходимости коммуникации</li><li>Хорошая коммуникация</li><li>Плоский процесс принятия решений</li><li>Меньшее давление из-за необходимости показывать качественные результаты</li></ul><p>Про размеры команды, конфигурация: в первый год разработки: 5 программистов, 2 артиста, 1 продюссер. Возможны и более мелкие команды.</p><p>“Традиционная” (по [к2]) гибкая методология разработки создана для небольших команд, решающих небольшие задачи. В случаях, когда необходимо взаимодействие больших разношёрстных команд, авторы рекомендуют использовать традиционные методы управления большими командами, которые проверены временем, но более расточительны.</p><p><code>Плюсы использования подхода с выбрасыванием итераций</code>, собраны в [с1]:</p><ul><li>Минимум задействованных в создании прототипа людей.</li><li>Быстрая реализация функционального прототипа.</li><li>Возможность сразу же оценить плюсы и минусы концепта и оперативно внести изменения.</li><li>Возможность сразу получить отзывы и видеть нравится ли людям концепт или нет.</li><li>Творческая свобода.</li><li>Использование существующих ассетов и возможность создать новое из старого.</li><li>Отличный способ продать свою идею людям, впечатлить и заинтересовать без каких-либо ощутимых затрат.</li></ul><p>Построение и распараллеливание ранних стадий пайплайна сложно, потому что затрагивается работа нескольких специалистов, зависящих друг от друга. Отдельные команды могут заниматься задачами параллельно, но без явного разбиения не небольшие черновые этапы может получиться так, что процесс “свернёт” в другую сторону и план работ отделов изменится. В этом случае полезно иметь разносторонне развитых разработчиков, которые могут заниматься всем. В небольших командах эти ребята сами найдут чем заняться на текущем этапе, в больших скорее всего без явных задач часть команды не сможет делать ничего.</p><h2 id="Выделение-стадий-прототипирования-для-устранения-взаимозависимостей"><a href="#Выделение-стадий-прототипирования-для-устранения-взаимозависимостей" class="headerlink" title="Выделение стадий прототипирования для устранения взаимозависимостей"></a>Выделение стадий прототипирования для устранения взаимозависимостей</h2><p>Пример описания процесса разбиения ранних стадий создания контента на несколько итераций с обоснованиями разделения - [д7], описание создания уровней для <code>Skyrim</code> и <code>Fallout 3</code>, [c4] - перевод-пересказ лекции на русском.</p><p>Гигантомания <code>Skyrim</code> сопоставима с гигантоманией <code>Witcher 3</code> - 5 больших городов, 300+ подземелий, 140+ точек интереса, 37 населенных пунктов – и 7 левел-дизайнеров.<br><img src="/blog/1687824628/giga_skyrim.jpg" alt="giga_skyrim"><br><img src="/blog/1687824628/giga_witcher.png" alt="giga_witcher"></p><p>Подход с итерациями основан на работе Nielsen 93 года <code>Iterative UI Design Study</code>.</p><p>Выделяют два различных процесса, которые действую на различных этапах создания уровня – структурные итерации (пока уровень делается), и итерации повышения качества (полировка). Первая стадия – структурная, от идеи до доведения уровня до этапа <em>“Можем выходить и так, но стыдно”</em> (<em>Ship with shame</em>).</p><p>Отмечают, что сам процесс создания итераций также может изменяться итеративно.</p><p>Особенности ситуации и цели создания процесса:</p><ul><li>Желание упростить работу с огромным массивом контента.</li><li>Улучшение качества дизайна.</li><li>Известные дедлайны.</li><li>Известные зависимости между отделами (!) - измерили в предыдущих проектах.</li><li>Известный состав команд - без планов донанимать людей в ходе разработки.</li><li>Желание хорошего качества жизни (!) - важно, что это заложено в цели, потому что это ведёт к реалистичному планированию.</li></ul><p>Выстроенный ими подход сильно похож на принципы <a href="https://ru.wikipedia.org/wiki/%D0%91%D0%B5%D1%80%D0%B5%D0%B6%D0%BB%D0%B8%D0%B2%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B8%D0%B7%D0%B2%D0%BE%D0%B4%D1%81%D1%82%D0%B2%D0%BE" target="_blank" rel="noopener">бережливого производства</a>, включая идею уважения людей.</p><p>Разработчики отмечают хаотичность процесса разработки игры:</p><ul><li>Множество меняющихся частей</li><li>Много взаимопересекающихся частей (неважно, сколько людей в команде, изменения в одном месте могут распространиться на десяток других мест)<br>Как вывод из предыдущего пункта:</li><li>Очень важно, в какие именно моменты что можно поменять безболезненно, а что уже нет.</li></ul><p>Следствием из этого является необходимость отслеживания, что на каких стадиях менять относительно безопасно.</p><blockquote><p>Т.е. итерации здесь не возникают из карго-культа каких-либо методологий разработки, не позаимствованы из других отраслей типа кино (предпродакшн/продакшн), это наблюдения за тем, сколько изменений повлечёт за собой то или иное изменение НА ТЕКУЩЕМ ЭТАПЕ разработки.</p></blockquote><p>Даже в случае отсутствия способа управления командой на ранних этапах можно попробовать разделять задачу на короткие итерации с постепенным наращиванием качества. Т.е. левел-дизайнеры делают максимально черновое описание локации -&gt; художники делают максимально черновой арт для набора блоков, левел-дизайнеры составляют из этих “серых ящиков” болванку уровня, затем на которой начинают составляться такие же черновые планы игровых систем. Какие-то системы могут отваливаться, какие-то части уровня могут выбрасываться, какие-то наборы будут переделываться - выбросить любой компонент всё ещё дёшево. Система Bethesda направлена лишь на то, чтобы не откатываться назад на целый этап. Однако у них к концу составления черновой версии есть способы избавиться от того, что не получилось.</p><p>Главное условие для возможности использования такого паттерна – <strong><code>собрать данные о том, какие изменения влекут за собой самое большое количество изменений, на каждом из этапов разработки</code></strong>. Это может быть сделано как неформальными способами (опросом специалистов), так и более формальными - составлением серии таблиц на каждый из существующих в пайплайне этапов, с отражением в таблицах численных оценок “вреда” какого-либо изменения, выраженного в виде суммы необходимых изменений в каждой из готовых к этому моменту частях.</p><p>Улучшение пайплайна здесь – это выбор такого порядка итераций, чтобы:</p><p><strong><code>- к началу этапа уже были выполнены необходимые для начала производства работы</code></strong><br><strong><code>- раньше других зафиксировать изменения, которые могут повлечь за собой большое число других переделок</code></strong><br><strong><code>- к моменту прохождения начальных итераций был расписан порядок, что делать, если не получилось достичь нужного качества. Гораздо важнее тратить время на доведений хорошего уровня до лучшего, чем посредственного до среднего. В дополнение на помошь может напрявляться &quot;команда решения проблем&quot;</code></strong><br><strong><code>- кросс-зависимости устраняются тем, что какой-либо отдел (кому проще) делает максимально быстро черновое качество ассетов, которое будет достаточно для реальной проверки геймплея</code></strong><br><strong><code>- не занятые отделы могут заняться чем-либо другим. На ранних стадиях левел-дизайнеры могут помогать в написании сюжета, геймдизайне механик (Layout, Gameplay, Markup, Scripting, Performance, Writing, Systems, Prototyping, Tools, more...)</code></strong><br><em>(список составлен мной, не дословный пересказ)</em><br><img src="/blog/1687824628/gd_choose.png" alt="gd_choose"><br><em>Геймдизайнер Betheda выбирает, чем ему заняться на раннем этапе разработке</em></p><blockquote><p>В моей концепции развития специалиста в геймдеве, точнее подходит модель профессий из <code>Final Fantasy Tactics</code> – возможны неожиданные комбинации профессий, дающие новую неожиданную специализацию. Например специализация “дизайнер-программист”, которая открывает возможность пропускать ранние этапы прототипирования, или “модульный дизайнера уровней” описанный далее в разделе “модульность” - по ссылке [с5] Джоэл пишет, что для создания модульных элементных уровней артист должнен обладать определёнными дополнительными инженерными навыками, которые часто отстуствуют у непрокачанных артистов. </p></blockquote><p>Основные этапы раннего периода разработки:<br><img src="/blog/1687824628/early_stages.png" alt="early_stages"><br><em>Начиная с beauty у них запускается другой процесс – полировка уровней</em></p><p>Каждая из стадий содержит определённые правила, что можно и что нельзя делать на этой стадии разработки. После перехода на следующую стадию вносить изменения предыдущего уровня нельзя, в том числе запрещается выбрасывание созданных частей и полная переделка (причина запрета – новое будет не лучше, как часто кажется дизайнеру, просто другое). Фидбеки, собранные во время плейтестов предыдущих стадий исправляются на следующей стадии-итерации.</p><p>Поздние стадии, в том числе и итерации полировки, также могут выглядеть по разному, в зависимости от того, что именно необходимо дорабатывать (по количеству фидбеков и изменений после плейтестов), т.е. предсказать изначально количество времени на этот процесс было бы невозможно.<br><img src="/blog/1687824628/third_stage.png" alt="third_stage"></p><p>Я не буду пересказывать, что именно они выделяют в конкретные стадии, можно посмотреть оригинальный доклад, это не важно в случае, если речь идёт о самом <code>паттерне устранения зависимостей за счёт создания итераций</code>.</p><h2 id="Раздельные-итерации"><a href="#Раздельные-итерации" class="headerlink" title="Раздельные итерации"></a>Раздельные итерации</h2><p><em>(Spaced iteration)</em></p><p>Другой паттерн из этого же доклада - <code>раздельные итерации</code>. После определения списка этапов создания уровня чаще всего команды начинают последовательное выполнение этих этапов для каждого из уровней.<br><img src="/blog/1687824628/iter_continue.png" alt="iter_continue"><br>В случае больших команд, при этом, получается немного распараллелить создание уровней, отдав разные уровни различным командам. Но можно пойти другим путём, и изменить приоритет выполнения задач. Вместо построения какого-либо из уровней целиком, можно сперва заняться самой ранней стадией для всех уровней, и только затем перейти к началу второго этапа работы.<br><img src="/blog/1687824628/iter_spaced.png" alt="iter_spaced"></p><p>Что от этого меняется? Разделение между выполнением итерации над одним из уровней даёт определённые преимущества.</p><ul><li>Дизайнер отдыхает от уровня и смотрит на него свежим взглядом, появляется время для переосмысления уровня.<br>В некоторых командах даже начинают разработку не с первых уровней, чтобы левел-дизайнеры могли натренироваться на менее важных уровнях, которые получатся хуже качеством, чем те, которые делаются последними.</li><li>Появляется время для сбора и обработки фидбеков, полученных во время плейтестов уровня, которые можно будет обработать на следующей итерации (в противном случае, фидбеки приходили бы в середине работы над следующей итерацией уровня).</li><li>Ожидание фидбеков перестают быть бутылочным горлышком в пайплайне (!)</li></ul><blockquote><p>Вместо “я закончил уровень/фичу в пятницу вечером, гляньте плиз к понедельнику”, можно сказать: “я закончил итерацию этого уровня, гляньте пожалуйста и отфидбечьте,ну, к началу июня”. Фидбеки можно группировать и анализировать, а не сразу добавлять в беклог/брать в работу.</p></blockquote><ul><li>Левел-дизайнеры фокусируются на текущей итерации, а не переключаются между задачами различной направленности (после финальной стадии уровня 1 тяжело вернутся к черновому формату работы над уровнем 2)</li><li>Позволяет запланировать время ожидания, когда левел-дизайнеру из-за изменившихся требований нужно что-то незадуманное изначально, у программистов и артистов появится время “до следующей итерации”.</li><li>Позволяет сгруппировать “простои” левел-дизайнеров во времени на ранних итерациях, чтобы они могли переключаться на другие задачи (один длинный простой удобнее, чтобы заняться другой задачей, чем небольшие “окошки” в начале работы над каждым уровнем). Как следствие, команда может обходиться меньшим количеством широкопрофильных специалистов вместо содержания большого штата узкопрофильных.</li><li>Исключает ситуации, когда к запланированной дате не готовы несколько уровней. Вместо этого с какого-то момента всегда будут готовы все уровни в определённой степени готовности.</li></ul><p>Что нужно для возможности применения? Практически ничего, кроме того, чтобы в каком-то виде <strong><code>провести декомпозицию разработки уровней на этапы</code></strong>.</p><h2 id="Зацикливание-этапов"><a href="#Зацикливание-этапов" class="headerlink" title="Зацикливание этапов"></a>Зацикливание этапов</h2><p>Самый известный и широко освещённый в литературе способ уменьшить риски неверного планирования – повторить основные этапы пайплайна несколько раз, добавив в конце каждой итерации этап проверки результатов, который позволит скорректировать цели следующей итерации. Для игр таким этапом являются плейтесты, организации которых нужно посвятить отдельный пост.</p><p>Если зациклить весь пайплайн, получится <a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%80%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F_%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C" target="_blank" rel="noopener">спиральная модель</a>. Более грамотное решение – начать использовать цикл <strong><code>&quot;полируем прототип -&gt; проводим плейтесты -&gt; собираем фидбеки. Повторяем многи раз&quot;</code></strong> тогда, когда готов прототип, чтобы избежать хаоса, связанного с большим количеством изменений при прототипировании.</p><blockquote><p>Последний этап создания прототипа в основном не про качество, а про уверенность. Уверенность, что все уровни будут готовы согласно плана. И, что более важно, уверенность в том, что можно повысить уровень качества за то время, что пройдет между концом последнего этапа создание прототипа и настоящим релизом.</p></blockquote><p>Оставшееся после создания прототипа время на полировку – <code>время возможностей</code> отполировать игру и сделать её действительно крутой.</p><p>Фактически, с момента начала полировки, игра должна быть готова к выходу в любой момент. Чтобы обеспечить это, в итерацию добавляют этапы тестирования и автоматической сборки/развёртывания. Для получения наиболее мощного результата от применения паттерна, циклы должны быть достаточно короткими. В общем случае, после каждого цикла должны быть заново протестированы все уже готовые фичи, чтобы полировка не сломала что-либо. В этом случае помимо ручного тестирования отделом QA, могут быть использованы какие-либо методы автоматического тестирования.</p><p>В каком-либо виде метод используется при разработке практически любой игры.</p><h2 id="Итерация-выбрасывания"><a href="#Итерация-выбрасывания" class="headerlink" title="Итерация выбрасывания"></a>Итерация выбрасывания</h2><p>Другие отрасли разработки ПО реже сталкиваются с тем, что приходится выбрасывать контент хорошего качества потому, что собранные вместе части оказываются неинтересными.</p><p>Программистам достаточно просто отключить неработающую фичу так, чтобы её было не видно, но дизайнерам отдельно полезно проработать итерацию грамотного выбрасывания контента, которая будет задействована, если итоговый уровень не прошёл “интеграционный плейтест”, и не попадёт в игру.</p><p>Что можно сделать с контентом, который не дотягивает до нужного качества? Не особо много (все по тому же докладу [д7]):</p><ul><li>Попробовать разобрать уровень, и растащить хорошие части в другие уровни</li><li>Попробовать сузить фокус и оставить только хорошую часть уровня</li><li>Собрать “ударную группу”, которая займётся доработкой уровня/фичи (пропадёт на месяц, но в итоге вернётся с чем-то интересным в плане геймплея)</li><li>Фичекат</li><li>Дать посмотреть продюсеру ещё раз, может разрешит оставить</li><li>Кранч (в случае, если дизайнер, который собрался кранчить, не делал этого всё время до того, как собрался закончить эту фичу)</li></ul><p>У программистов намного хуже проработаны методы вырезания какого-либо функционала, поэтому методологии разработки редко говорят о том, как правильно выстроить этап уничтожения ненужного кода. Неиспользуемый арт намного легче обнаружить, чем код, который не делает ничего полезного. Для обнаружения такого кода нужен профессиональный “нюх” у программиста, особое чувство <a href="https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%B4_%D1%81_%D0%B7%D0%B0%D0%BF%D0%B0%D1%88%D0%BA%D0%BE%D0%BC" target="_blank" rel="noopener">запаха кода</a>, и потребовалось много лет для формализации признаков этого чувства (и всё так же, как и раньше, программисты должны несколько лет постоянно нюхать код, чтобы выработать это чувство у себя).</p><blockquote><p>Лучше потратить доступное время на улучшение хорошего уровня до отличного, чем на улучшение плохого до среднего</p></blockquote><h2 id="Создание-комбинируемого-контента"><a href="#Создание-комбинируемого-контента" class="headerlink" title="Создание комбинируемого контента"></a>Создание комбинируемого контента</h2><p><em>(Модульность)</em></p><p><code>Небольшое отступление</code><br>Программисты используют понятие модульности, под этим понимается свойство системы не зависеть от своих частей (в плане надёжности и взаимной связности - один компонент может быть изменён независимо от других, а в идеале даже отключен или сломан так, чтобы другие компоненты могли продолжать работать). Свойство построения высоких уровней над более низкими не имеет отдельного названия, но “уровневость” проявляется в различных формах - от архитетуры системы (несвязанный с играми пример – <a href="https://ru.wikipedia.org/wiki/TCP/IP" target="_blank" rel="noopener">стек протоколов TCP/IP</a>), и отдельных рекомендаций использовать свои абстракции вместо базовых примитивов, и до создания отдельных от игрового движка способов описания игровой логики:</p><ul><li>Domain-specific языки (DSL - отдельные или встроенные языки описания игровой логики типа <code>GameMaker</code>, попытка создания отдельного языка для игр <code>Jai</code>, описание игровой логики в файлах с данными – паттерн <a href="https://gameprogrammingpatterns.com/bytecode.html" target="_blank" rel="noopener">Bytecode</a>)</li><li>Универсальные скриптовые языки (обвязка над объектами на базовом языке, пример – <code>Lua</code>, <code>C#</code> в Unity)</li><li>Использование визуальных языков (<code>Blueprint</code> в Unreal)</li></ul><p><code>Модульность в левел-дизайне</code> – это построение уровней из повторяющихся блоков. Это не новая идея левел-дизайнеров Bethesda (статья [c5] о <code>Skyrim</code>, и продолжающий её доклад [д8] о <code>Fallout 4</code>), можно посмотреть <a href="http://level-design.ru/pro-ld-book-index/03-modular-level-design/" target="_blank" rel="noopener">список других примеров</a> из [к1].<br><img src="/blog/1687824628/gow2_modular.png" alt="gow2_modular"><br><em>(подсвечены повторяющиеся части уровня <code>Gear of War 2</code>)</em></p><p>Принцип модульности использовался в создании уровней со времён первых консолей с тайловой графикой, там уровни часто строились из тайлов и мета-тайлов для экономии памяти и количества контента (я исследовал устройство NES и SMD <a href="https://spiiin.github.io/CadEditor/cadeditor-supported-games.html">множества</a> игр и писал небольшую обзорную <a href="https://habr.com/ru/post/259171/" target="_blank" rel="noopener">статью</a> о принципах такого подхода).</p><p>Основное преимущество использования данного метода – <code>существенное уменьшение работ по созданию уникального контента</code>. На скриншоте показан объём работ арт-отдела (жёлтым), левел-дизайна (тёмно-оранжевым), и серым – консервативная оценка объёма работ по созданию подземелий <code>Skyrim</code> без использования модульных элементов (скриншот из статьи [c5]).<br><img src="/blog/1687824628/module_content.png" alt="module_content"></p><ul><li>В первом приближении “модули” - это набор строительных блоков для уровня, которым пользуется левел-дизайнер (качество этого набора также может проходить итерации).</li><li>В более продвинутой версии – сами блоки составляются из набора отдельных поверхностей, слотов под соединения, отверствия и декали.</li><li>Модули могут иметь настраиваемые динамические свойства, вроде трансформаций при взрывах (<a href="https://youtu.be/QBAM27YbKZg?t=2823" target="_blank" rel="noopener">сломо</a>).</li><li>Значительно ускоряется скорость внесения изменений, модули позволяют легко вносить как небольшие, так и существенные правки (!) - <a href="https://youtu.be/QBAM27YbKZg?t=2570" target="_blank" rel="noopener">пример</a>.</li><li>Для маскировки повторяющихся элементов – <a href="https://youtu.be/QBAM27YbKZg?t=2852" target="_blank" rel="noopener">декали</a> и грамотный левел-дизайн без видимых повторов паттернов.</li><li>В конструкторе блоки 3х типов – универсальные, блоки-кастомизаторы и блоки-герои (которые используются только один раз). Предпочтения отдаются разработке первых двух типов.</li><li>Готовые наборы блоков могут быть использованы в открытых инструментах по созданию контента для игры сообществом игроков (доклад [д9]).</li></ul><p>Условия, при которых возможно использовать модульный дизайн уровней:<br><strong><code>- Особый склад ума у артиста, создающего модули</code></strong><br>Авторы отмечают, что у них всего два артиста, работающих над паками модулей, из-за того, что это сложная работа. Артист должен обладать как отличными художественными навыками, так и глубоким пониманием принципов работы редактора и пайплайна такой разрботки.<br><em>“..редкое сочетание работы правой и левой сторон мозга, которое редко встречается у профессиональных артистов”</em></p><p><strong><code>- Готовность продюсера использовать в игре такой тип контента</code></strong><br>Необходима проверка качества получающихся уровней. Это зависит от способности левел-дизайнеров творчески маскировать использование небольшого количества базовых элементов и необычную композицию так, чтобы игроки этого не заметили.</p><p><strong><code>- Наличие инструментария, поддерживающего удобную работу с модульными наборами</code></strong></p><h1 id="Резюме"><a href="#Резюме" class="headerlink" title="Резюме"></a>Резюме</h1><p>Паттерны улучшения пайплайна производства уровней:<br><strong><code>- Выбрасывание лишних этапов пайплайна разработки</code></strong><br><strong><code>- Выделение стадий прототипирования для устранения взаимозависимостей</code></strong><br><strong><code>- Раздельные итерации</code></strong><br><strong><code>- Зацикливание этапов (с плейтестами для оценки промежуточных результатов)</code></strong><br><strong><code>- Итерация выбрасывания (если уж пришлось - обдумать, как минимизировать потери)</code></strong><br><strong><code>- Создание комбинируемого контента</code></strong></p><p>Всё это – крупицы чужого опыта, который может помочь спасти разработчиков от выгорания и кранчей во время марафона создания игры.</p><p><code>Паттерн</code> – возможно, слишком смелое название для описанных принципов. Иногда это просто методы, которые применяли в конкретных играх, и стоит называть их так. Метод, в статье – это правило для решения конкретного типа задач. Паттерн – объединение нескольких методов в более общий принцип, позволяющий выводить новые методы, а также “деконструировать” метод, выделив в нём один или несколько паттернов.</p><p>Конечно, сравнение <code>модульности</code>, как её понимают в левел-дизайне и в программировании, это сверхобобщение и сравнение тёплого с мягким. Но пускай слово <code>паттерн</code> служит комплиментом разработчикам-изобретателям, которые сэкономили этим методом тысячи человеко-часов своей команде, и стёбом над теми карго-менеджерами, для которых деятельность по оптимизации процессов сводится к рисованию диаграмм различных форм – в их случае форма диаграммы действительно является хорошим обобщением того, что они делают.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Попытка обобщить принципы, которые применяют различные геймдев команды для улучшения организации разработки уровней, механик, контента. На основе компиляции и конспекта материалов из различных источников.&lt;br&gt;
    
    </summary>
    
    
    
      <category term="dev" scheme="http://spiiin.github.io/tags/dev/"/>
    
  </entry>
  
  <entry>
    <title>Скрытые игровые механики</title>
    <link href="http://spiiin.github.io/blog/1998861373/"/>
    <id>http://spiiin.github.io/blog/1998861373/</id>
    <published>2021-08-18T21:21:17.000Z</published>
    <updated>2021-09-19T22:03:50.259Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p><a href="https://twitter.com/Gaohmee/status/903510060197744640" target="_blank" rel="noopener">Твиттер-тред</a> 2017 года с описыванием скрытых от игрока механик в популярных играх.<br><a id="more"></a></p><p><a href="https://leaden.ru/2017/09/100-hidden-game-mechanics/" target="_blank" rel="noopener">100 скрытых игровых механик</a> - отличная выборка и перевод на русский.<br><a href="https://www.polygon.com/2017/9/2/16247112/video-game-developer-secrets" target="_blank" rel="noopener">Video game developers confess their hidden tricks at last</a> - выборка на английском.<br><a href="https://habr.com/ru/company/pixonic/blog/500930/" target="_blank" rel="noopener">Маленькие секреты геймдизайнеров, заставляющие игрока ненавидеть вашу игру чуточку меньше</a> - перевод ещё одной выборки.<br><a href="https://dtf.ru/gamedev/9890-razrabotchiki-rasskazali-o-skrytyh-mehanikah-populyarnyh-igr" target="_blank" rel="noopener">Разработчики рассказали о скрытых механиках популярных игр</a> - статья на DTF “по мотивам”.</p><p><a href="https://www.youtube.com/playlist?list=PLokhY9fbx05eq8SvcNOxYRquYMzMjF9Ok" target="_blank" rel="noopener">AI and Games</a> - плейлист с разбором поведения ИИ в играх.</p><p>Я разделил описанные механики на несколько групп.</p><h2 id="Твики-управления"><a href="#Твики-управления" class="headerlink" title="Твики управления"></a>Твики управления</h2><p>Многие шутеры содержат помощь в наведении прицела и управлении камерой, чтобы игроку было приятнее и проще - камера “притягивается” к линии горизонта, прицел немного “липнет” к ближайшему врагу. Если игрок близко к интерактивному предмету, то скорость движения камеры немного замедляется.</p><p>Платформеры позволяют прыгать в воздухе и из пропасти (<em>время койота</em>), чтобы компенсировать особенности восприятия игрока - он всегда будет думать, что упал “нечестно”.</p><h2 id="Твики-сложности"><a href="#Твики-сложности" class="headerlink" title="Твики сложности"></a>Твики сложности</h2><blockquote><p>Это скорее правила дизайна, а не исключения, забудьте о честности с игроком. Потому что если игра будет обращаться с игроком честно - он уйдёт играть в другие, которые его обманывают, зато не обижают. Главное – эти механики должны оставаться скрытыми от игрока.</p></blockquote><p>Последняя единица здоровья отнимается дольше остальных (и иногда даёт неуязвимость на некоторое время), последние секунды таймера медленнее, чем основное время.</p><p>Враги промахиваются в первый раз (предупредительный выстрел) и медленнее движутся и атакуют, находясь за спиной игрока. Иногда в начале боя они стреляют хуже, чтобы дать возможность добежать до укрытия.</p><p>Игра “подкручивает” параметры и силу врагов, если игрок часто проигрывает, и незаметно уменьшает их количество.</p><p>После нескольких промахов, определяемых вероятностью, игрок всегда попадает по сопернику. Также, часто, вы <strong>никогда</strong> не можете промахнуться, если вероятность попадания - 99%. После нескольких неудач в поиске сокровищ в сундуках со случайно генерируемым содержимым вас гарантировано будет ждать хорошая награда.</p><p>В стелс-играх после нескольких поражений у врагов случайно отключается одно из чувств (зрение/слух/обоняние), с помощью которых они обнаруживали игрока.</p><p>Враги не нападают на персонажа одновременно, а ждут, пока он рассправится с ними по очереди. Или не ждут, а делают вид, что заходят в тыл, или занимают тактическую позицию.</p><p>Если подойти к врагу близко, его точность и урон от огнестрельного оружия снижаются.</p><p>В ящиках и сундуках чаще оказываются те предметы, которые нужны игроку.</p><p>Игра подправляет хитбоксы в пользу игрока - попание по врагу засчитывается, если пуля пролетела чуть-чуть мимо, а враг в ответной ситуации промахивается, даже если “почти попал”.</p><p>Враги не могут убить игрока с одного удара – в некоторых играх у него всё равно останется последняя единица здоровья (<em>Death shield</em>), даже если он должен был умереть. Иногда при смерти игрок получает регенерацию или начинает лечиться от случайных объектов. Также с критическим уровнем здоровье игрок часто получает скрытые бонусы.</p><p>Пуля при рассчёте физики имеет два различных хит-бокса – первый небольшой для проверки пересечения с препятствиями (может легко пролететь мимо без застревания), второй больше – для проверок столкновений с врагами (легче попасть). Иногда даже для далёких врагов хитбокс пули становится ещё больше, чтобы попадать издалека было проще. Для некоторых пуль соперников же вообще отключают проверку попаданий, чтобы они даже случайно не задели игрока.</p><p>Самая последняя фаза битва с боссом может выглядеть более впечатляющей, но на самом деле иметь пониженную сложность, чтобы создать ощущение эпической победы.</p><p>Если долго тупить с решением загадки, игра может как-либо подсказать решение. Например, в <code>The Legend of Zelda: The Wind Waker</code> Линк посмотрит в сторону, куда должен смотреть игрок.</p><p>Сложность может зависеть просто от успешности прохождения нескольких предыдущих уровней, или настраивается по совокупности действий игрока.  В free2play играх всё может быть ещё жёстче – сложность подстраивается под игрока только на тех уровнях, которые не предназначены для расхода в них платных бустеров.</p><p>В играх с генерируемыми событиями игра может отслеживать, идёт ли игрок к цели по прямой, или исследует карту, и подбрасывать больше случайных событий тем, кто их ищет.</p><p>Иногда система сложности “ломает 4-ю стену”, меняя сложность в какую-либо сторону, если вы используете перезагрузку сохранения для попытки получить другой случайный результат. Игра может отслеживать долгое бездействие игрока. Она может запоминать действия и подстроиться под игрока в туториале (иногда кроме сложности подстраивается также управление).</p><p>Подстройка сложности присутствует даже в мультиплейерных играх.</p><p>В <code>Warcraft 3</code> способность наносить x4 урон с 15% шансом может сработать 3-4 раза подряд, за счёт чего бывает, что в финалах крупных турниров один игрок мгновенно убивает другого. Это также убивает и зрелищность – турниры созданы для того, что определить того, кто сможет показать лучшие навыки, случайность здесь только мешает. Поэтому в современных MOBA-х чаще всего “случайные” способности работают так - каждое срабатывание способности повышает шанс на следующий промах, и наоборот. Другой вариант - заранее прописанные результаты перемешиваются и выдаются игроку, так что среднее значение результата будет точно равно матожиданию.</p><p>В <code>Gears of War</code> обнаружили, что игрок, не набравший ни одного фрага в мультиплейерном матче, в 90% не будет играть второй матч. Поэтому, пока он не наберёт несколько очков, его оружие будет наносить дополнительный урон.</p><p>Хотя бы одна пуля из дробовика в <code>Team Fortress 2</code> всегда попадает в цель, чтобы им можно было надёжно пользоваться в случае, когда нужно нанести хотя бы одну единицу урона.</p><p>Игрок с наименьшим количеством здоровья в <code>Super Smash Bros</code> получает небольшие бонусы: случайные бустеры чаще появляются рядом с ним.</p><h2 id="Твики-зрелищности"><a href="#Твики-зрелищности" class="headerlink" title="Твики зрелищности"></a>Твики зрелищности</h2><p>Полёт пуль искривляется в направлении к взрывающимся или гремящим объектам, рэгдолл-трупы притягиваются к перилам и уступам, чтобы зрелищно упасть. После взрыва некоторые части разрушенного объекта обязательно летят в камеру ради эффектности.</p><p>В гонках применяются пост-эффекты (виньетка, изменение FoV камеры) для создания ощущения большой скорости. Во время аварии врезавшаяся машина “швыряется” системой физики в сторону других машин.</p><p>Напарники телепортируются к вам за спину, если отстали или застряли где-нибудь. </p><p>Если игрок не участвует в бою, то NPC и враги дерутся по другим законам – их урон может быть понижен или отключен совсем. Умирающие персонажи могут подождать, чтобы умереть только тогда, когда на них посмотрит игрок.</p><p>Важные для игрока подсказки или квестовые предметы могут быть продублированы несколько раз - до тех пор, пока игрок всё-таки не получит предназначенную ему информацию, тогда остальные копии пропадают.</p><p>Последняя пуля игрока мощнее предыдущих (возможно, в несколько раз), чтобы повысить шанс зрелищно убить врага сразу перед перезарядкой.</p><p>В глобальных стратегиях соперник может специально развиваться так, чтобы инициировать конфликт с игроком, или же играть не ради победы, а ради отыгрыша своей роли в партии.</p><p>В погонях иногда не удастся оторваться слишком далеко от преследователя, в гонках отстающие соперники “резинкой” подтягиваются к игроку (чем сильнее отставание, тем сильнее притяжение). Другой способ создания соревнования – соперники стартуют гонку с завышенными параметрами, и ослабевают со временем, чтобы игроку было проще догнать их.</p><p>В состязательных спортивных играх при большой разнице в счёте соперник начинает лучше играть - иначе “избивать слабых” игроку становится неинтересно. Спортивные игры увеличивают шансы на попадания в последние секунды.</p><p>В файтингах для зрелищности полоса здоровья сжата так, чтобы визуально к концу боя оба бойца оставались с небольшим количеством здоровья.<br>(<em>я подозреваю, некоторые производители мобильных телефонов поступают также с показателем заряда аккумулятора</em>)</p><p>Враги могут начать реагировать визуально (паниковать) и слабее сражаться, если вы убили их предводителя, чтобы вы могли прочувствовать влияние на поле боя.</p><p>Дробовик разбрасывает пули сильнее в горизонтальной плоскости, чем в вертикальной.</p><h2 id="Вранье-игроку"><a href="#Вранье-игроку" class="headerlink" title="Вранье игроку"></a>Вранье игроку</h2><p>Тут скорее  “Скрытое отсутствие механики”. Иногда маркетологи заявляют что-то вроде <em>“соперники запоминают ваши действия и мстят вам”</em>, хотя в игре этого нет. Или игра отображает характеристики поведения соперников, но они не влияют на геймплей – все соперники ведут себя одинаково. Иногда разработчики просто путают что-то в игровых формулах, или ошибки допускают переводчики.</p><p>Но враньё может быть замыслом разработчиков, в <code>Guitar Hero</code> игроку показывают шкалу оценки его результатов от одной до пяти звёзд, хотя в реальности наихудшая возможная оценка – три звезды.</p><p>В <code>Alien Versus Predator</code> в первые 10 минут вообще нет врагов – дизайнеры за это время несколько раз применяют значок автосейва для создания ощущения <em>“враги уже близко”</em>.</p><p>В <code>Dark Souls</code> в конце первого акта игрок звонит в колокол. Если у игры есть доступ к сети, то игра в случайные моменты времени проигрывает вдали звуки этого колокола (на самом деле, игра получает данные от других игроков в реальном времени, и проигрывает звук, когда они звонят в колокол).</p><p>Механика dark rod в <code>Hellblade</code>. Игра сообщает, что через какое-то количество неудачных попыток сотрёт сохранения игрока. Эта механика – <a href="https://3dnews.ru/956661" target="_blank" rel="noopener">блеф</a>, целью которого является повысить мотивацию игрока.</p><p>В <code>Surgeon Sim</code> игрок может набрать произвольный номер телефона, и виртуальный хирург позвонит на него в реальном мир. Это <a href="https://www.reddit.com/r/PSVR/comments/688xjj/i_phoned_myself_using_surgeon_sim_er/" target="_blank" rel="noopener">не вранье</a>, скорее пасхальное яйцо, но зато очень крутое.</p><p>Счётчики секунд в играх могут идти медленнее или быстрее реальных секунд, или даже менять скорость в зависимости от действий игрока.</p><p><em>Плацебо-дизайн</em> - выдача игроку уровней в ролевых играх, которые ничего не меняют в геймплее.</p><h2 id="Упрощение-реализации"><a href="#Упрощение-реализации" class="headerlink" title="Упрощение реализации"></a>Упрощение реализации</h2><p><code>F.E.A.R</code> - враги во время боя не переговариваются между собой, советуясь что делать. Если один из них <strong>уже</strong> бросает гранату куда-либо, второй может сказать ему пост-фактум <em>“Бросай гранату туда - он прячется за ящиками”</em>.</p><p><code>Witcher 3</code> – во время <a href="https://youtu.be/pzvkB3w1qXQ?t=1924" target="_blank" rel="noopener">разрубания врага на куски</a> уникальные части тел людей подменяются на стандартные модели отрубленных частей тела с другими текстурами, и вообще не соответствующими месту разрубания (на видео пропадает рука и меняется цвет одежды), игроки не замечают подмены.</p><p><code>Космические рейнджеры</code> - все диалоги составлены так, чтобы не упоминался пол игрока.</p><p>В <code>Jak and Dexter</code> игрок спотыкается и падает, чтобы за время проигрывания анимации вставания игра успела загрузить с диска данные о следующей части уровня.</p><p>В оригинальном <code>Space Invaders</code> пришельцы ускорялись по мере того, как игрок уничтожал их, не за счёт игровой логики, а за счёт того, что процессор <a href="https://en.wikipedia.org/wiki/Space_Invaders#Hardware" target="_blank" rel="noopener">быстрее обсчитывал логику</a> и выполнял отрисовку меньшего количества игровых объектов.</p><p><code>Skyrim</code> (и многие другие) - огромные горы на заднем плане чаше всего просто <a href="https://twitter.com/LxFrancis/status/903604737806786560" target="_blank" rel="noopener">маленькие холмики</a>.</p><p>VR-игры часто “замыкают пространство в кольцо” (хм, ну или просто подставляют в конец одной комнаты её же - программистам так понятнее), чтобы игрок мог бесконечно идти вперёд.</p><h2 id="Арт-хаки"><a href="#Арт-хаки" class="headerlink" title="Арт-хаки"></a>Арт-хаки</h2><p>Знаменитое создание поезда путем приделывания персонажу шлема-вагона в <code>Fallout 3</code>. У разработчиков даже есть термин для такого творчества - <em>кит-башинг</em> (<a href="https://youtu.be/PhW8CY8XkFg?t=1912" target="_blank" rel="noopener">тут</a>, и чуть дальше - с примером превращения шкафа в стол).</p><p>В <code>Fallout: New Vegas</code> на время синематиков персонажа помещают в специальную комнату, в которой стоит проектор, отбирают управление, и он <a href="https://www.reddit.com/r/Fallout/comments/9cxqgx/til_that_the_ending_cinematics_for_new_vegas_is/" target="_blank" rel="noopener">смотрит ролик с проектора</a>. Нарритивный рассказчик при этом – это настоящий NPC, который незаметно <a href="https://www.youtube.com/watch?v=LPb0qHjaPfc&amp;ab_channel=CoyoteWild" target="_blank" rel="noopener">стоит за проектором</a> и говорит.</p><p>В комментариях к “100 игровым механикам” разработчик <code>Аллоды онлайн</code> рассказывает, что механики преследующих заклинаний используют невидимых котят, на которых вешается какой-либо визуальный эффект. Дальше котёнок начинает преследовать жертву. Напомнает <a href="https://burrarum.livejournal.com/32707.html" target="_blank" rel="noopener">классику</a> с созданием в <code>Блицкриг</code> ракеты ФАУ-2 из самолёта.</p><h2 id="Скрытые-в-механике-фишки-игры"><a href="#Скрытые-в-механике-фишки-игры" class="headerlink" title="Скрытые в механике фишки игры"></a>Скрытые в механике фишки игры</h2><p>В <code>Dark Souls 3</code> тайминги атак боссов построены так, чтобы фазы анимации попадали в определённые такты музыки.</p><p><code>Firewatch</code> содержит защиту от “деск-джампинга” - если игрок не хочет выполнять сюжетное действие (говорить по рации), его отказ всё равно считается отдельным “вариантом ответа” в диалогах, на который реагируют NPC.</p><p>Искусственный интеллект <code>Left 4 Dead</code> направляет основные усилия врагов на игрока, отбившегося от группы, или на наименее агрессивного члена команды.</p><p>В <code>Pac-Man</code> у каждого призрака свои правила поведения. Также игрок едва ощутимо замедляется во время поедания точек, чтобы создать дополнительный риск во время охоты за ними.</p><p><code>Skyrim</code>, открытый для моддеров, честно симулирует физику даже в интро, поездке на повозке, из-за во время разработки часто происходили баги. Вот <a href="https://twitter.com/NPurkeypile/status/1427650365558857728" target="_blank" rel="noopener">история</a> о том, как повозка взлетала в воздух как ракета из-за того, что на её пути встречалась пчела, там же пара историй от моддеров.</p><p>Большинство дистанционных атак <code>League of Legend</code> имеют эффект “леденца на палочке” - если выпущенный снаряд ни в кого не попадает, то в конечной точке происходит проверка целей в небольшом радиусе, то есть форма области, в которой можно получить урон выглядит похожей на “чупа-чупс”. Разработчики отмечают, что в таком виде система попаданий больше нравится как стрелку, так и жертве - <strong>“промахиваться – не круто”</strong></p><p><code>Spelunky</code> не генерирует случайных затемнённых уровней, если игрок прошёл предыдущий меньше, чем за 30 секунд, чтобы игроки могли выполнять спидраны.</p><p>В оригинальном <code>Tetris</code> фигуры выпадают не рандомно, а выбираются из заготовленного буфера, который содержит все типы, чтобы игрок не ждал слишком долго определённую фигуру.</p><p><code>Enter the Gungeon</code> - искусственный интеллект “разогревается”, как и игрок. Чем дольше играешь, тем сложнее становится, даже на первом уровне.</p><p>В <code>Quake 3</code> сплеш урон от ракеты по самому себе снижен вдвое, чтобы безопаснее выполнять рокет-джампы (<em>навряд ли сейчас это скрытая от кого-то механика</em>).</p><p>В <code>Heroes of Might and Magic 3</code> одни из самых сильных заклинаний – воскрешения существ. Для того, чтобы соперник не смог воскресить погибший стек существ, нужно встать на труп другим юнитом, или другим способом заблокировать клетку (<em>“Герои” вообще наполнены скрытыми механиками, которые игроки открывали годами</em>).</p><blockquote><p>Такой тип механик скрыт от игрока не в целях защиты от разрушения иллюзии, а для создания глубины геймплея и поощрения исследования игры. Исследователи (Exporers) по Бартлу – игроки, которым нравится изучать мир игры и его законы.</p></blockquote><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://twitter.com/Gaohmee/status/903510060197744640&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Твиттер-тред&lt;/a&gt; 2017 года с описыванием скрытых от игрока механик в популярных играх.&lt;br&gt;
    
    </summary>
    
    
    
      <category term="dev" scheme="http://spiiin.github.io/tags/dev/"/>
    
      <category term="link" scheme="http://spiiin.github.io/tags/link/"/>
    
  </entry>
  
  <entry>
    <title>Мотивация &quot;честного&quot; программиста</title>
    <link href="http://spiiin.github.io/blog/1363625753/"/>
    <id>http://spiiin.github.io/blog/1363625753/</id>
    <published>2021-08-16T18:28:10.000Z</published>
    <updated>2021-08-17T11:25:46.818Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>В конце <a href="https://gdcvault.com/play/1022375/World-of-Tanks-Blitz-Postmortem" target="_blank" rel="noopener">доклада</a> <code>World of Tanks Blitz Postmortem: Building a AAA MMO for Mobile Devices</code> Виталий Бородовский рассказывает короткую историю о том, что за длительное время работы в индустрии люди часто забывают собственные стимулы и мотивы, с которыми пришли делать игры.</p><p>Я уже описывал собственные стимулы работы в геймдеве в разделе <code>Зачем</code> в заметке <a href="/blog/3652741154/" title="десять лет в геймдеве">десять лет в геймдеве</a>.</p><blockquote><p>К тому моменту я уже понял, что моя цель - <code>делать крутые игры</code>, про которые я мог бы сказать это сам, и про которые так говорили бы игроки.</p></blockquote><p>Через какое-то время я понял, что больше не горю именно такой мотивацией и задумался, что я делаю сейчас и зачем.<br><a id="more"></a></p><h2 id="1-Честность-с-собой"><a href="#1-Честность-с-собой" class="headerlink" title="1. Честность с собой"></a>1. Честность с собой</h2><p><strong><code>Познай самого себя</code></strong></p><p>Первое, что нужно сделать, чтобы разобраться - приготовиться не врать самому себе, и искать свою цель честно. Честно найти свои сильные и слабые стороны, и признать их. Без этого невозможно что-то изменить.</p><p>Без готовности найти ответ его невозможно увидеть. Скорее всего, придётся столкнуться с тем, что нужно быть честным с собой не только в работе, а в первую очередь – в жизни.</p><h2 id="2-Нежелание-жить-и-работать-в-грязи"><a href="#2-Нежелание-жить-и-работать-в-грязи" class="headerlink" title="2. Нежелание жить и работать в грязи!"></a>2. Нежелание жить и работать в грязи!</h2><p><strong><code>Правило бойскаутов - Оставь после себя лагерь чище, чем он был, когда ты пришел</code></strong></p><p>Важная особенность хороших программистов - не проходить мимо грязи, а убирать её. Я создал опрос в закрытом сообществе программистов: <em>Приходилось ли вам что-то глобально улучшать или менять в компании, в которой вы работаете?</em></p><p>Вопрос родился из такой цепочки рассуждений:</p><ul><li>В любой компании вначале всё делается максимально быстро и как попало - нужно как-то выйти на рынок, плюс вначале никто не знает, как делать правильно.</li><li>В дальнейшем переделывать нормально тоже почти всегда некогда, чаще всего делается по уже опробованной схеме - “если раз сработало, то сработает и дальше” и “работает – не трогай”.</li><li>В результате у всех всегда в коде бардак.</li><li>Тем не менее, степень бардака в разных компаниях разная, т.е. в какой-то момент находится кто-то, кто способен всё-таки привести какую-либо часть системы в порядок.</li><li>При этом чаще всего программисты хотят работать в компаниях, где всё хорошо (ну, хотя бы не полный хаос) - думаю, иногда это даже основная причина смена места работы.</li></ul><p>Из ответов составил для себя картину - ключевой мотивацией для глобальных улучшений является <code>нежелание прежде всего жить в грязи</code>. Если можешь и хочешь навести порядок в собственной жизни, то скорее всего сможешь сделать это и в работе. Причём не только для себя, но и для других тоже.</p><p>В книгах по Agile-разработке (Роберт Мартин) и экстремальному программированию (Кент Бек), встречал такие определения этой мотивации, как <code>&quot;Смелость&quot;</code> – храбрость действительно начать делать более удобным способом, а не проходить мимо; и <code>&quot;Правило бойскаутов&quot;</code> - требование оставлять после себя репозиторий проекта в лучшем виде, чем был до твоих коммитов.</p><h2 id="3-Ценить-своё-и-чужое-время-Личная-жизнь"><a href="#3-Ценить-своё-и-чужое-время-Личная-жизнь" class="headerlink" title="3. Ценить своё и чужое время (Личная жизнь)"></a>3. Ценить своё и чужое время (Личная жизнь)</h2><p><strong><code>Философия Убунту - &quot;Личность - это личность через другие личности&quot;</code></strong><br><code>&quot;Код - это код через чужой код&quot;</code> - мой хороший код делает ваш код лучше, а мой плохой код делает ваш код хуже, мы вместе владеем кодом проекта.</p><p>Ваш плохой код - причина того, что вы отнимаете время того, кто будет это исправлять. У нас всех кроме работы есть ещё и личное время, нужно ценить в первую очередь свое, а затем и чужое время.</p><p>Кроме этого стоит искать методы разработки, позволяющие даже немного сокращать потери рабочего времени.</p><p><code>Эмоции - вне работы</code><br>Эмоции мешают работе, любые. У всех бывают проблемы в жизни, но их нужно оставлять вне работы. Почему так? Наше мышление содержит множество багов (когнитивные искажения), и мы должны научиться относится к нему критически, а эмоции всегда только мешают критическому мышлению.</p><h2 id="4-Работа-на-конечный-результат"><a href="#4-Работа-на-конечный-результат" class="headerlink" title="4. Работа на конечный результат"></a>4. Работа на конечный результат</h2><p><strong><code>Совершенство достигнуто не тогда, когда нечего добавить, а тогда, когда нечего убрать.</code></strong><br>Если последовательно: начать быть честными с собой, стремиться к комфортной взаимной работе и принять ограниченность нашего времени работы над игрой, – то можно придти к следующему простому правилу: <code>убрать всё лишнее, что не требуется для достижения результата</code>.</p><p>Мы работаем не чтобы запилить максимальное количество фич, или чтобы развиваться и получать зарплату, а чтобы выпускать игры ДЛЯ ИГРОКОВ, и результат – их положительный опыт от игры.</p><h2 id="5-Икигай"><a href="#5-Икигай" class="headerlink" title="5. Икигай"></a>5. Икигай</h2><p>Если более развёрнуто сформулировать моё желание работать на результат, то в него будет входить не только желание <code>делать крутые игры</code> (по собственной оценке и оценке игроков), но и требование <code>делать успешные игры</code> - ценить результаты работы своей команды. Эта мотивация близка к тому, что часто любят упоминать всякие коучи, как <strong>икигай</strong>.</p><p><strong><code>Икигай</code></strong> - японский термин, обозначающий то:</p><ul><li>что я умею делать (сам считаю крутой игрой)</li><li>что я люблю делать (получаю удовольствие от процесса разработки)</li><li>что полезно другим (игроки считают игру крутой)</li><li>за что хорошо платят (игра успешна на рынке)</li></ul><p>Круто, если геймдев для вас – икигай.<br><img src="/blog/1363625753/ikigai_small.png" alt="ikigai"></p><p>Немного уточню своё понимание <em>крутости</em> и <em>успешности</em> игры:<br><code>1. Игра приносит фан (позитивный опыт и переживания) игрокам, даёт возможность игрокам получить их собственную историю</code><br><code>2. В идеале - игра может вызывать переживания, изменяющие игрока - игра несёт определённые ценности</code><br><code>3. Игра популярна среди игроков и нравится им</code><br><code>4. В идеале - игра становится для игроков культурным кодом, про неё знают и обсуждают все</code><br><code>5. Игра выглядит круто, &quot;сочно&quot;. За тем, как кто-то играет, интересно смотреть</code><br><code>6. Внутреннее состояние - игра работает стабильно, оптимизирована, в код не страшно смотреть, его можно поддерживать</code><br><code>7. В идеале, игра на максимум использует технические возможности железа, на котором работает</code><br><code>8. В ходе разработки игры разработчики не выгорели, не кранчили месяцами, и не ушли из отрасли</code><br><code>9. В игре есть что-то уникальное, чего нет ни в одной другой</code><br><code>10. Игра не является ящиком Скиммера, позволяет играть бесплатно</code></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;В конце &lt;a href=&quot;https://gdcvault.com/play/1022375/World-of-Tanks-Blitz-Postmortem&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;доклада&lt;/a&gt; &lt;code&gt;World of Tanks Blitz Postmortem: Building a AAA MMO for Mobile Devices&lt;/code&gt; Виталий Бородовский рассказывает короткую историю о том, что за длительное время работы в индустрии люди часто забывают собственные стимулы и мотивы, с которыми пришли делать игры.&lt;/p&gt;
&lt;p&gt;Я уже описывал собственные стимулы работы в геймдеве в разделе &lt;code&gt;Зачем&lt;/code&gt; в заметке &lt;a href=&quot;/blog/3652741154/&quot; title=&quot;десять лет в геймдеве&quot;&gt;десять лет в геймдеве&lt;/a&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;К тому моменту я уже понял, что моя цель - &lt;code&gt;делать крутые игры&lt;/code&gt;, про которые я мог бы сказать это сам, и про которые так говорили бы игроки.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Через какое-то время я понял, что больше не горю именно такой мотивацией и задумался, что я делаю сейчас и зачем.&lt;br&gt;
    
    </summary>
    
    
    
      <category term="dev" scheme="http://spiiin.github.io/tags/dev/"/>
    
  </entry>
  
  <entry>
    <title>Прототипирование в геймдеве</title>
    <link href="http://spiiin.github.io/blog/2537188794/"/>
    <id>http://spiiin.github.io/blog/2537188794/</id>
    <published>2021-08-08T12:21:12.000Z</published>
    <updated>2021-09-02T21:28:39.871Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Немного про прототипирование, плейтесты, итерации в разработке игр<br><a id="more"></a></p><p>Начитался книг по геймдизайну (<code>&quot;Искусство геймдизайна&quot;</code> Джесси Шелла, <code>&quot;Геймдизайн. Рецепты лучших&quot;</code> Тайнана Сильвестра, <code>&quot;Теория развлечений&quot;</code> Рэфа Костера), а также историй разработки (<code>&quot;Кровь, пот и пиксели&quot;</code> Джейсона Шрейера). Все они помимо прочего рассказывают о том, насколько сложно и долго делать хорошие игры.</p><p>Есть несколько основных предположений, почему так происходит.</p><p><strong><code>- Индустрия молодая, никто не выстроил процессы, по которым можно делать правильно</code></strong><br>Отчасти верно, каждая команда делает игры немного по своему, и то, что работает в одной команде, не будет в другой - практически невозможно адаптировать чужие процессы, приходится выстраивать собственные. Тем не менее, компании, которые работают в индустрии давно, тоже сталкиваются с кризисами или тем, что у них по какой-либо причине следующую игру делать ещё “больнее”, чем предыдущую.</p><p><strong><code>- Меняются технологии, следствие чего поднимается планка качества игр и требуются изменения в подходах к разработке</code></strong><br>Как пример - истории <code>&quot;Uncharted 4&quot;</code> и <code>&quot;Witcher 3&quot;</code> из “<em>Крови, пота и пикселей</em>“ - следующие игры серии масштабнее, сложнее и амбициознее предыдущих. Вполне может быть так, что для следующей игры нужны специалисты, разбирающиеся в следующем поколении технологии, а не той, на которой была сделана предыдущая игра.</p><p><strong><code>- Часто очень сложно сказать по неготовой игре, интересной она получится или скучной</code></strong><br>Проверять какие-либо гипотезы в незаконченной части игры сложно, а создавать полноценный контент просто ради проверки - дорого и долго. Пример с “<em>Ведьмаком 3</em>“ - проверка сценария романтической беседы Геральта с Йеннифер в саду в сумерках, вместо моделей персонажей были два уже готовых рыбака, вместо сада - “серые коробки”, а текст читал вслух сценарист. Как узнать, будет ли это смотреться с правильными декорациями, моделями и начитанным профессиональными актёрами текстом?</p><p>Из-за того, что неработающие как надо, скучные части приходится выбрасывать - увеличиваются сроки и возрастает бюджет. Неочевидная сразу проблема - выбрасывание результатов труда специалистов дизморалит их.</p><h2 id="Прототипирование"><a href="#Прототипирование" class="headerlink" title="Прототипирование"></a>Прототипирование</h2><p>Один из способов улучшить качество игры, известный в индустрии разработки программного обеспечения - использовать методологию, предусматривающую несколько итераций.</p><blockquote><p>В геймдизайне временное принятие некачественной работы в конечном итоге приводит к более качественной работе. Это ПАРАДОКС КАЧЕСТВА. Игры отличаются тем, что наиболее важным фактором, определяющим их качество, является количество итерационных циклов, через которые они проходят. Одержимость качеством на каждом этапе замедляет итерацию, что в конечном итоге ведет к ухудшению игры.</p><footer><strong>Тайнан Сильвестр</strong><cite>Геймдизайн. Рецепты лучших</cite></footer></blockquote><p>На ранних стадиях работать с контентом финального качества - значит уже зафиксировать их налачие в игре, лишив себя гибкости, поэтому важен скилл создания максимально черновых прототипов на выброс.</p><p>Почти устоявшееся название метода, встречающееся в перечисленных книгах - <code>Метод серых коробок</code>, названный так потому, что вместо реальных декораций дизайнер использует прямоугольники/параллелипипеды, представляющие у него в голове геометрию уровня.</p><p>Я не встречал больших компаний (YMMV), в которых грамотно поставлено прототипирование, чаще всего “прототип” это: дизайн-документ + “питч”-презентация + наброски художественного стиля и сюжета проекта. Затем следует большое количество работы и проверка только уже почти готового продукта, вместо тестов черновых версий. Ну и дальше - выбрасывание того, что не работает. Возможно, это связано с тем, что в больших компаниях чаще создают игры “проверенных временем” жанров, в которых компания уже имеет некоторую экспертизу. </p><p>В отличие от этого, для инди команд, ограниченных в ресурсах, намного важнее искать интересные идеи, поэтому там более ценятся и исследуются способы наиболее быстрой проверки идей.</p><p><a href="https://gamin.me/posts/5624" target="_blank" rel="noopener">Как сконструировать игровой прототип за 7 дней</a> - некоторые способы и работающие идеи для быстрого создания прототипов от авторов <code>World of Goo</code>. Конспект их правил и методов:</p><p><strong><code>Быстрота - Это состояние разума</code></strong>. Быстрое прототипирование это нечто большее, чем полезный инструмент в пред-производстве - оно может стать образом жизни.</p><p><strong><code>Ускоряйте циклы разработки (Больше времени != Больше качества)</code></strong> - всего несколько дней на тесты, до недели. Не было никакой взаимосвязи между потраченным на разработку временем и тем, насколько успешной игра стала в конечном итоге.</p><p><strong><code>Искусственно ограничивать идеи для прототипа</code></strong>. Без жестких тематических ограничений игры стали дольше разрабатываться, были менее направленными. Примеры тем для экспериментов: “гравитация”, “пружины”, “эволюция”, “звук”, “хищник и жертва”, “затягивающие игры”, “рисование”, “экспоненциальный рост”, “растительность”, “баланс” и некоторые другие.</p><p><strong><code>Соберите крутую команду и консультанта - мышление не менее важно, чем талант</code></strong>. В таком стиле разработки некогда учить инструмент или язык. (<em>Кстати, консультант у них всё тот же Джесси Шелл, автор “Искусство геймдизайна”, что лишний раз подтверджает практичность его идей</em>).</p><p><strong><code>Разрабатывайте параллельно для максимального эффекта</code></strong>. Интересная практика - создание внутренней конкуренции, и наличие нескольких отличающихся результатов. Каждый может больше рисковать, и как итог тема исследуется шире. Параллельно, не значит изолированно - авторы собирали концепции и методы в совместное хранилище знаний. Команда нужно в начале и конце каждого цикла разработки, но после старта можно было полностью погружаться в собственную работу. В конце цикла - добавляется полезное чувство конкуренции и ощущение поддержки.</p><p><strong><code>Обычный мозговой штурм не работает</code></strong> - нельзя заставить себя “думать по расписанию”. Иногда идеи приходят, когда лежишь в гамаке.<br><a href="https://youtu.be/jSPaG50FFVs" target="_blank" rel="noopener">Hammock Driven Development</a> - про этот метод есть отдельный хороший доклад Рича Хикки.</p><p><strong><code>Скапливайте концепт-арты и музыку, чтобы создать эмоциональный настрой</code></strong><br><blockquote><p>Идея “Tower of Goo” пришла ко мне, когда я (зачем-то) слушал вступление к “Tango Apasionado” Астора Пьяццоллы, придя домой, и в моей голове возникло видение – небольшой городок в лучах заката, и все жители покидают свои дома, забирая с собой столы, стулья, и все, что могут унести, чтобы построить гигантскую башню в центре города. Я не знаю почему, но они очень хотели лезть выше и выше – но они были не очень хорошими инженерами-строителями, поэтому вы должны были им помогать.</p><footer><strong>Кайл Гэблер</strong></footer></blockquote></p><p><strong><code>Симулируйте игру в своей голове – Пред-прототипируйте прототип</code></strong>. Не выходит в голове - бумага, песок, пластилин или детские конструкторы в помощь.<br><a href="https://vimeo.com/9479199" target="_blank" rel="noopener">Have Paper, Will Prototype</a> - примеры прототипирования с помощью бумаги.<br><a href="https://youtu.be/L6aPAncMHKA" target="_blank" rel="noopener">DYK: Hideo Kojima has built Metal Gear Solid with LEGO</a> - создание уровней <code>Metal Gear</code> из кубиков Lego.</p><p><strong><code>Разработка: Никто не знает, как ты это сделал, и никому до этого нет дела</code></strong>. Самая больная для меня, как программиста, часть. Всем плевать на ваши прекрасные навыки программирования. Надо делать не “правильно”, а быстро.<br><a href="/blog/19419/" title="2012 - Ускорение написания кода">2012 - Ускорение написания кода</a> - мои заметки о том, как писать код быстро и грязно.</p><p><strong><code>Сначала сделайте игрушку</code></strong>. До создания какого-либо геймплея делать просто приятную механику в чистом виде. Однако авторы дальше замечают, что, к сожалению, не из каждой игрушки можно потом сделать хорошую игру.</p><p><strong><code>Если что-то может занять слишком много времени, подделайте это</code></strong>. Это вообще очень полезный рецепт для разработки игр. Нам не важна корректная и точная симуляция, важно чтобы было весело и интересно. Не надо делать корректную систему освещения и затенения там, где вшитое в текстуру освещение будет выглядеть также. Не надо делать сложные сплайны с векторной графиков там, где подойдёт растягивающийся спрайт (<code>World of Goo</code>).</p><p><strong><code>Сокращайте потери и &quot;Знайте, когда стоит застрелить своего ребенка&quot;</code></strong>. Основная цель прототипа - он может быть неудачным, это нормально. <code>4F - Fail Faster - Follow the Fun</code> - принимайте возможность неудачи, это помогает пойти на творческий риск! Если не получится одно, то получится другое, более того, вы станете опытнее благодаря неудаче. Принимая возможность неудачи, мы открываем дорогу эксперементированию.<br>Ну, и вообще - “Plan to throw one version away; you will, anyhow” (из <code>Мифического Человекомесяца</code> Фредерика Брукса)</p><p><strong><code>Обильное оформление не спасет плохой гейм-дизайн (или &quot;Вам не удастся сделать конфетку из дерьма&quot;)</code></strong>. Если игра будет скучное - её не спасёт ничто. Но в целом оформление имеет значение! Используйте добротный набор изображений, звуков и музыки.</p><p><strong><code>Сложность концепции не обязательна для интересности</code></strong> “Экспериментальный” не значит “Запутанный”. Если все человечество на протяжении тысяч лет успешно развлекает себя вариациями на тему “мяч и плоская поверхность”, то мы, возможно, слишком уж сильно корячимся над всеми этими новомодными штучками для видеоигр. У игрока всегда должна быть простая и понятная ему цель.</p><p><strong><code>Создайте чувство собственности, чтобы игроки возвращались назад</code></strong>. Здесь авторы отмечают, что самые реиграбельные игры включают аспекты сохранения того, что создал игрок. Это не накопленные им запасы, а возможность выразить себя через кастомизацию игры (“построй СВОЮ башню”, “создай СВОЙ дом”).</p><p><strong><code>Делайте игру сочной!</code></strong><br><blockquote><p>“Сок” был нашим внутренним термином, означавшим постоянную и обильную связь игры с игроком. Сочный игровой элемент крутится и вертится, прыгает, качается и издает звуки, когда вы его касаетесь. Сочная игра кажется живой и реагирует на все, что вы делаете – огромное количество действий на экране при минимальном пользовательском вводе. Это помогает игроку почувствовать себя могущественным повелителем и учит его правилам игры, при каждом взаимодействии показывая, как у него идут дела с освоением геймплея.</p></blockquote></p><p>В дополнение, <strong><code>правила прототипирования</code></strong> из книги  <code>Искусство Геймдизайна</code> Джессси Шелла. Глава 8. Итерации делают игру лучше.</p><ul><li>Каждый прототип отвечает на конкретный вопрос.</li><li>Забудьте о качестве. Максимально черновой и быстрый.</li><li>Никаких привязанностей. Прототип делается на выброс.</li><li>Расположите прототипы в порядке их важности.</li><li>Совмещать прототипы эффективно. Если можно распараллелить, можно делать несколько прототипов одновременно.</li><li>Делайте нецифровые прототипы. Можно создать бумажную версию, воспользоваться метрономом для отмеры “шагов” в игре реального времени.</li><li>Вносите изменения максимально быстро. Автор рекомендует выбрать язык и движок со скриптами и поздним связыванием (Python, Scheme, Smalltalk, Javascript).</li><li>Сначала сделайте игрушку. Мяч - это игрушка, но футбол - игра. Мяч интересен сам по себе, и позволяет играть в разные игры. Маленькая фигурка, которая бегает и прыгает - это игрушка, а Donkey Kong - игра. Город в GTA или уровень в Lemmings без действий игрока - это игрушка.</li><li>Прототип не обязан быть интерактивным. Стиль анимации можно проверить интерактивным роликом - Prince of Percia: Sands of Time.</li><li>Если возможно, делайте несколько итераций прототипирования.</li></ul><p><strong><em>прим. обновлено 02.09.2021</em></strong><br>Ещё одно дополнение по прототипам, из книги <code>Ernest Adams - Fundamentals of Game Design</code>.<br>Список того, что скорее всего нужно прототипировать отдельно (от более раннего к более позднему):</p><ul><li>Техническое демо</li><li>Игровая экономика (возможно на бумаге)</li><li>Интерфейс и система управления</li><li>Туториалы (или FTUE)</li></ul><p>Кроме бумажных прототипов автор рекомендует, если возможно для создаваемой игры, устраивать “физические прототипы”, с беганием по офису. В качестве примеров идей для вдохновения приводятся <a href="https://ru.wikipedia.org/wiki/%D0%A0%D0%BE%D0%BB%D0%B5%D0%B2%D1%8B%D0%B5_%D0%B8%D0%B3%D1%80%D1%8B_%D0%B6%D0%B8%D0%B2%D0%BE%D0%B3%D0%BE_%D0%B4%D0%B5%D0%B9%D1%81%D1%82%D0%B2%D0%B8%D1%8F" target="_blank" rel="noopener">LARP-игры</a> и тематические парки развлечений.</p><p>Прототип должен отвечать на чётко поставленный вопрос, чтобы его было проще создать и оценить. В качестве примеров, список различных прототипов игры <strong><code>Spore</code></strong> с описанием целей их создания:<br><a href="http://www.spore.com/comm/prototypes" target="_blank" rel="noopener">http://www.spore.com/comm/prototypes</a></p><p>Во второй части книги (<code>Game mechanics. Advanced Game Design</code>) описывается графический язык <a href="https://machinations.io/" target="_blank" rel="noopener">Machinimations</a>. К схемам, созданным на этом языке, можно подключить ботов, реализующих различные стратегии использования нод (случайные, паттернами, регулярное использование одной стратегии), чтобы протестировать таким образом прототип игровой экономики или баланс.</p><h2 id="Путь-от-прототипа-к-результату"><a href="#Путь-от-прототипа-к-результату" class="headerlink" title="Путь от прототипа к результату"></a>Путь от прототипа к результату</h2><p>Несколько примеров трансформаций игр в ходе исследований (из книги <code>&quot;Геймдизайн. Рецепты лучших&quot;</code> Тайнана Сильвестера).</p><p><strong><code>Halo</code></strong> – изначально это была стратегическая игра с нисходящим методом проектирования. В процессе разработки дизайнеры обнаружили, что чем ближе они показывали происходящее, тем лучше становилась игра. Они все больше и больше приближали камеру, пока в конечном итоге главный герой не стал смотреть на происходящее собственными глазами. Этот странный путь развития не был ошибкой – он был необходим для того, чтобы игра стала успешной. Никто не мог запланировать полученный результат, и никто этого и не делал.</p><p><strong><code>BioShock</code></strong> – это исследование подводного города, построенного в стиле ар-деко. Игра прославилась богатым и уникальным нарративом о мире. Но с самого начала события игры происходили на космическом корабле. Позже они переместились в заброшенный нацистский бункер, кишащий мутантами. Дизайнеры не планировали этот мир на бумаге; они разработали его за годы работы над самой игрой.</p><p><strong><code>The Sims</code></strong> - начиналась как архитектурная игра. Изначально Уилл Райт не планировал помещать в дом семью. Игра была о строительстве и не более. Только добавив простого персонажа, Райт обнаружил, насколько сильно это понравилось игрокам. Райт следовал возможностям, которые он видел, и игра все больше и больше сосредоточивались на людях, и так до тех пор, пока они не стали ее центром. Он не планировал такой результат; он обнаружил его в процессе создания игры.</p><p><strong><code>Legend of Zelda - Breath of the Wild</code></strong> - <a href="https://youtu.be/5qMnBn0S4mM?t=258" target="_blank" rel="noopener">двухмерный прототип</a> в стиле первой “Зельды”, созданный для теста механики.</p><p><strong><code>Diablo</code></strong> - изначально была <a href="https://youtu.be/huPF3Gid7DE?t=616" target="_blank" rel="noopener">пошаговой</a>.</p><p><strong><code>Braid</code></strong> - доклад Jonathan Blow: Indie Prototyping с различными версиями прототипов игры, от самого первого в поисках идеи, к нескольким игровым, а также “пост-игровые”, в поисках способа применения найденной механики в других жанрах.<br><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/ISutk1mauPM" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></p><h2 id="Магия-итераций-и-плейтестов"><a href="#Магия-итераций-и-плейтестов" class="headerlink" title="Магия итераций и плейтестов"></a>Магия итераций и плейтестов</h2><p>Черновые прототипы - это только начальная часть процесса. Мы можем и должны прототипировать и проверять отдельные игровые механики регулярно. Каждая итерация разработки должна заканчиваться созданием прототипа, в который нужно играть (есть различные способы проведения плейтестов - от задействования разработчиков и их друзей, до набора случайных игроков на улице или в интернете).</p><p>Почему так важны исследования и сбор информации? Тайнан Сильвестр ссылается на книгу Дернера Дитриха <code>&quot;Логика неудачи&quot;</code>. В ней описываются особенности человеческого мышления, из-за которых нам очень сложно работать с запутанными системами с большим количеством неизвестных. Дитрих использовал компьютерные симуляции (почти игры, чтобы его испытуемые воспринимали эксперимент ближе к жизни, чем к математической модели). </p><p>Геймдизайнер, “жонглируя” параметрами игры в ходе разработки, находится в похожих условиях. Мы многого не знаем об игре во время разработки, из-за того, что мозг игрока - сложная штука, и предсказать его реакцию без проверок бывает практически невозможно.</p><blockquote><p>Первые несколько тестов спустили нас с  небес на землю, — говорит Дракманн. — Мы с Брюсом теперь их обожаем, потому что это позволяет посмотреть на то, что мы делаем, под новым углом. Ты получаешь от тестеров жесткую обратную связь, это обрубает тебе крылья. Дизайнерам часто тяжело смотреть, как люди проходят уровни, хочется буквально рвать на себе волосы. Да нет же, обернись, ну вон же ручка, да что ты делаешь-то? А помочь ты им не можешь.</p></blockquote><p>Плейтесты со случайными игроками показывают такие факты, о которых мы не знали заранее. Без этой информации мы можем исправить только те проблемы, о которых нам УЖЕ было известно. Особенность человеческого мозга, что он начинает думать, что известные проблемы - это ВСЕ проблемы, которые есть в игре. Это когнитивное искажение мышления <a href="https://psy.wikireading.ru/47999" target="_blank" rel="noopener">WYSIATI</a> - “что ты видишь, то и есть”, описанное в книге <code>&quot;Думай медленно... решай быстро&quot;</code> Канемана Даниэля.</p><p>Без исследования - решаются не те проблемы, которые нужно решить, а те, о которых известно. И среди них в первую очередь отбираются те, которые известно, как решить - это ещё одна особенность мозга, склонность решать задачи, которые доказывают испытуемому собственную компетентность. Такие задачи вводят мозг в состояние потока, которое <strong>мешает</strong> исследованию трудных проблем (показано ещё открывателем состояния потока Михаем Чиксентмихайи). Неизвестные проблемы при этом остаются вообще невидимыми и, естественно, нерешёнными.</p><blockquote><p>Нам хорошо, когда мы решаем задачу, решение которой знаем, но наше эмоциональное бессознательное не сигнализирует о том, что эта была задача была неактуальной. Таким образом, мы решаем одну задачу за другой, радостно, усердно, но не понимая, что выбрали неправильные задачи. Последствия таких ошибок проявляются намного позже, и проследить взаимосвязь между причиной и следствием часто невозможно. Именно поэтому мы можем  повторять одни и те же ошибки в течение многих лет или десятилетий.<br>…<br>Любому человеку легко говорить о необходимости подвергать сомнению убеждения. На деле это гораздо сложнее. Убеждения-убийцы – это те, которые заставят вас с головой уйти в решение сложных задач на полгода и пропустить первый день рождения вашего ребенка, это те убеждения, которые заложены настолько глубоко, что практически неприкасаемые. Они защищены толстым культурным слоем, привычками и личной выгодой. Они позволяют вам использовать все ваши старые навыки и инструменты и не требуют, чтобы вы изучали что-то новое или меняли привычки.</p></blockquote><p>Бывает обратная ситуация, когда во время игры в очередной прототип, находится не неизвестная проблема, а фича игры, которая не была запланирована - <a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%B5%D1%80%D0%B5%D0%BD%D0%B4%D0%B8%D0%BF%D0%BD%D0%BE%D1%81%D1%82%D1%8C" target="_blank" rel="noopener">серендипное</a> открытие. Доклад про “открытие” геймплея <code>Tetris</code> - <a href="https://gdcvault.com/play/1014442/Game-Design-by" target="_blank" rel="noopener">Game Design by Accidents</a>.</p><blockquote><p>Смирение позволяет принять то, как мало мы знаем. Так можно постичь не только маленькие берега понимания; смирение открывает перед нами непостижимые океаны неведения. Оно помогает нам поймать волну серендипности, когда мир пытается нас чему-то научить. Оно противостоит нашему природному заблуждению «что вижу, то и существует», делает нас наблюдательнее, вдумчивее и, возможно, даже немного мудрее. Нет человека глупее, чем тот, который считает, что знает все.</p></blockquote><h2 id="Закон-Конвея"><a href="#Закон-Конвея" class="headerlink" title="Закон Конвея"></a>Закон Конвея</h2><p>Игра, как и любой другой вид искусства, становятся отражением своих создателей.<br><code>The Legend of Zelda</code> родилась из воспоминаний Сигеру Миямото о том, как он в детстве занимался спелеологией.<br>Сатоши Тэджири, разработавший <code>Pokemon</code>, любил коллекционировать насекомых.<br><code>Doom</code> — из кампании в D&amp;D Джона Ромеро и Джона Кармак, в которой демоны захватили вымышленный мир.<br><code>Uncharted 4</code> — это история про человека, который слишком много работает.<br>Мрачные сюжеты и развязки квестов <code>Witcher 3</code> отражают переживания восточно-европейских народов после Второй Мировой.<br>Техническая точность в управлении самолётом <code>WarThunder</code>, скрывающаяся за казуальным управлением - результат увлечения разработчиков из Gaijin настоящими самолётами.</p><p>Но кроме этого, процесс разработки игр отражает культуру компании, которая их делает. Компания - это не личность, а скорее мем (по Доккинзу, <code>&quot;Эгоистичный ген&quot;</code>) - “ценности”, культурный код, который способен реплицировать процесс создания игр, даже если заменить всю команду разработки. Этот код может быть не прописан в каком-либо виде, и проявляться только в поведении различных людей, поэтому изменить его сложнее - сама структура подразумевает, чтобы задача выполнялась определённым образом.</p><p>Мелвин Конвей <a href="http://www.melconway.com/Home/Conways_Law.html" target="_blank" rel="noopener">сформулировал</a> следствие этого наблюдения так - <strong><code>&quot;Организации проектируют системы, которые копируют структуру коммуникаций в этой организации&quot;</code></strong>. Не только результат, но и сам <strong>процесс</strong> производства тоже подчинён этому закону. Компания будет делать новые игры так же, как делала их до этого. Следом за <code>Witcher 3</code>, который уже был слишком большим по объёму, последует ещё больший <code>Cyberpunk 2077</code>, который просто добьёт разработчиков; После затянувшегося <code>Uncharted 4</code> последует <code>The Last of Us 2</code>, который так же невозможно выпустить в обозримый срок.</p><blockquote><p>Игровая индустрия переполнена историями о кранчах, рабочих марафонах по 10 или 12 часов в день каждый день в течение месяцев или даже лет. Люди толстеют, скучают, не замечают, как вырастают их дети, или сгорают и вообще уходят из индустрии. Этот кошмар разрушает личность и тушит творческую энергию.</p><footer><strong>Джейсон Шрейер</strong><cite>Кровь пот и пиксели</cite></footer></blockquote><p>Наверное, самый сложный навык в управлении - умение видеть такие опасные особенности компании, и модифицировать процесс так, чтобы хотя бы в некоторой степени их изменить, иначе в перспективе компания начнёт сама ломать своих сотрудников.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Немного про прототипирование, плейтесты, итерации в разработке игр&lt;br&gt;
    
    </summary>
    
    
    
      <category term="dev" scheme="http://spiiin.github.io/tags/dev/"/>
    
  </entry>
  
  <entry>
    <title>Внутрь STL. Ссылки</title>
    <link href="http://spiiin.github.io/blog/1366632532/"/>
    <id>http://spiiin.github.io/blog/1366632532/</id>
    <published>2021-07-18T12:33:14.000Z</published>
    <updated>2021-07-18T13:33:26.812Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Ссылки на тему особенности реализации классов библиотеки STL и других библиотек контейнеров.</p><a id="more"></a><p>Основные источники вдохновения, когда стандартных контейнеров STL не хватает: <code>EASTL</code>, <code>LLVM containers</code>, <code>Folly</code>, <code>Boost</code>.</p><p><a href="https://github.com/electronicarts/EASTL" target="_blank" rel="noopener">EA Standard Template Library</a> - альтернативная стандартная библиотека от Electonics Arts, появившаяся ещё тогда, когда стандартные реализации были сомнительного качества и развивающаяся и сейчас.<br><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2271.html" target="_blank" rel="noopener">EASTL — Electronic Arts Standard Template Library</a> - описание классов, отличий от STL и принципов дизайна.<br><a href="https://eastl.docsforge.com/master/best-practices/#summary" target="_blank" rel="noopener">EASTL Best Practices</a> - сборник советов, как пользоваться.</p><p><a href="https://llvm.org/devmtg/2014-04/PDFs/LightningTalks/data_structure_llvm.pdf" target="_blank" rel="noopener">LLVM Data-structures overview</a> - доклад Marcello Maggioni о структурах данных, используемых в LLVM.<br><a href="https://llvm.org/docs/ProgrammersManual.html" target="_blank" rel="noopener">LLVM Programmer’s Manual</a> - более детальное описание</p><p><a href="https://github.com/facebook/folly" target="_blank" rel="noopener">Folly</a> - набор библиотек Facebook.<br><a href="https://youtu.be/kPR8h4-qZdk" target="_blank" rel="noopener">CppCon 2016: Nicholas Ormrod “The strange details of std::string at Facebook”</a> - доклад про реализию <code>folly::String</code></p><p><a href="https://www.boost.org/doc/" target="_blank" rel="noopener">Boost</a> - документация к библиотекам буст.<br>Многое из полезных буст библиотек уже и так в STL (нужно быть очень благодарным авторам Boost за это).<br><a href="https://cpp-optimizations.netlify.app/boost_flatmap/" target="_blank" rel="noopener">Optimizing using an exotic associative container</a> - Boost flat_map to the rescue</p><p><a href="https://github.com/SergeyMakeev/Zmeya" target="_blank" rel="noopener">Zmeya</a> - библиотека stl-like контейнеров для быстрой сериализации.<br><a href="https://tessil.github.io/2016/08/29/benchmark-hopscotch-map.html" target="_blank" rel="noopener">Benchmark of major hash maps implementations</a> - бенчмарк реализаций хеш-таблиц.</p><p><a href="https://stlab.adobe.com/" target="_blank" rel="noopener">Stlab</a> - стандартные библиотеки Adobe, расширяющие функционал STL. Подход немного отличается от стандартного ООП в сторону Value Oriented Programming, много материалов на <a href="https://sean-parent.stlab.cc/papers-and-presentations/" target="_blank" rel="noopener">странице</a> Шона Пэрента, с отсылками к Александру Степанову. Подход периодически разбирается на конференциях, пример - <a href="https://youtu.be/glYq-dvgby4" target="_blank" rel="noopener">Keynote: SOLID, Revisited - Tony Van Eerd - [CppNow 2021]</a></p><p>Доклад <code>The Performance Price of Dynamic Memory in C++ - Ivica Bogosavljevic</code> про различные аспекты оптимизации, часто ссылается на статьи из своего блога:<br><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/LC4jOs6z-ZI" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div><br><a href="https://johnysswlab.com/process-polymorphic-classes-in-lightning-speed/" target="_blank" rel="noopener">Process polymorphic classes in lightning speed</a> - статья со сравнением скорости обработки полиморфных объектов. Почти все статьи в блоге посвящены оптимизации, часто касаются структур данных и контейнеров из STL.</p><p><a href="https://github.com/ibogosavljevic/johnysswlab/blob/master/2020-08-polymorphism/polymorphic_vector.h" target="_blank" rel="noopener">Polymorphic Vector</a> - класс для обработки вариантов полиморфных объектов.<br><a href="https://howardhinnant.github.io/stack_alloc.html" target="_blank" rel="noopener">stack_alloc</a> - простая реализация кастомного аллокатора для STL-контейнеров.<br><a href="https://github.com/webcoyote/coho/blob/master/Base/Hash.h" target="_blank" rel="noopener">Intrusive hash</a> - быстрые хеш-таблицы.</p><p><a href="http://ithare.com/c-performance-common-wisdoms-and-common-wisdoms/" target="_blank" rel="noopener">C++ Performance: Common Wisdoms and Common “Wisdoms”</a> - много советов про выбор <code>STL</code> и <code>EASTL</code> контейнеров.</p><p><a href="https://youtu.be/35y3OrsKq8c?t=303" target="_blank" rel="noopener">Classes With Many Fields - Stanisław J. Dobrowolski</a> - по таймингу ссылки на решения для сокращения объема классов в в проектах - Chromium, Firefox, LLVM, VLC, GZDoom.</p><p><a href="https://cpp-optimizations.netlify.app/" target="_blank" rel="noopener">CPP Optimizations Diary</a> - блог со статьями по оптимизации C++-кода.<br><a href="https://cpp-optimizations.netlify.app/dont_need_map/" target="_blank" rel="noopener">Do you actually need to use std::map?</a> - сравнение производительности поиска в <code>std::map</code> и <code>std::vector&lt;std::pair&lt;KeyType, ValueType&gt;&gt;</code>.</p><p><a href="https://shaharmike.com/cpp/" target="_blank" rel="noopener">Shahar’s C++ posts</a> - серия постов Shahar Mike с разбором реализации некоторых STL-классов.</p><p>Книги<br><a href="https://www.aristeia.com/books.html" target="_blank" rel="noopener">Scott Meyers books</a> - суперполезная серия <code>Effective</code>, включая немного устаревшую <code>Effective STL</code> (лучше читать с пониманием, что изменилось в C++11/14/17).<br><a href="https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms" target="_blank" rel="noopener">More C++ Idioms</a> - Набор полезных материалов и ссылок с объяснениями идиом C++, в том числе используемых в библиотеках <code>STL</code> и <code>Boost</code>.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Ссылки на тему особенности реализации классов библиотеки STL и других библиотек контейнеров.&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="dev" scheme="http://spiiin.github.io/tags/dev/"/>
    
  </entry>
  
  <entry>
    <title>Flamegraph. Windows/iOS/Android</title>
    <link href="http://spiiin.github.io/blog/2526702897/"/>
    <id>http://spiiin.github.io/blog/2526702897/</id>
    <published>2021-07-18T09:45:41.000Z</published>
    <updated>2021-07-18T11:38:47.861Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>В прошлой заметке я писал, что флеймграфы можно генерировать из данных различных профайлеров, сейчас решил проверить, насколько это удобно на практике.<br><a href="/blog/2779627234/" title="Flamegraphs">Flamegraphs</a></p><a id="more"></a><p><code>Флеймграфы</code> позволяют детально изучить какие функции занимают время процессора (не только пару самых тяжёлых, но и относительное время выполнения любых функций в любой части программы).</p><p>С их помощью можно измерить время выполнения(точнее, количество сэмплов), <code>частей &quot;ядра&quot; приложения</code> (библиотеки, фреймворки, STL, системный вызовы ОС), <code>увидеть стоимость абстракций</code> (rtti/dynamic_cast, malloc/new), <code>исследовать горячие места программы</code> (не только самые тяжёлые места, с которыми иногда ничего нельзя сделать, но и “локальные” горячие точки), измерить, <code>на какие именно части программы влияет оптимизация</code> (как собственные, так и компилятора).</p><p>Также возможно сохранение отчётов для последующего изучения и дифференциальное сравнение (чтобы увидеть регрессию/оптимизацию при развитии программы).</p><h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><p>Сходу оказалось, что экспорт данных в csv формате, необходимый для анализа, из встроенного в студию профайлера в версии 2019 <a href="https://developercommunity.visualstudio.com/t/vs2019-profiling-report-is-missing-export-report-d/714378" target="_blank" rel="noopener">выбросили</a>, потому что “никому не нужно”.</p><p>Что ж, на офф-сайте Flamegraph упоминается, что можно экспортировать данные из отчёта, собираемого другим профайлером для Windows <code>XPerf</code>. Однако <a href="https://randomascii.wordpress.com/2013/03/26/summarizing-xperf-cpu-usage-with-flame-graphs/" target="_blank" rel="noopener">скрипт</a> для конвертации данных писался сторонним разработчиком и спустя 8 лет уже не работает, так что я забил на поиски и решил, что быстрее будет написать конвертер самому, чем искать и править чужие решения.</p><p>В качестве сборщика данных можно взять не сам <code>XPerf</code>, а open-source профайлер, использующий тот же API Event Tracing for Windows - <a href="https://github.com/Donpedro13/etwprof" target="_blank" rel="noopener">etfprof</a>. Он позволяет сразу отфильтровать события профилируемого приложения от других процессов, за счёт чего экономится размер собираемых данных.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;-t - id процесса или имя запущенного приложения</span><br><span class="line">etwprof profile -t&#x3D;418996 --output profile_result -m</span><br></pre></td></tr></table></figure><p>Профайлер создаёт файл <code>ИМЯ_ПРОЦЕССА_дата.etl</code>. Его можно открыть в программе <a href="https://www.microsoft.com/en-us/p/windows-performance-analyzer/9n0w1b2bxgnz#activetab=pivot:overviewtab" target="_blank" rel="noopener">Windows Performance Analyzer</a>, которая может <a href="https://randomascii.wordpress.com/2016/09/05/etw-flame-graphs-made-easy/" target="_blank" rel="noopener">отобразить результаты</a> в виде флеймграфа.</p><p>Но мне захотелось пойти дальше и экспортировать данные в текстовом виде для преобразования их оригинальными скриптами. Во первых, чтобы проверить понимание работы этих скриптов, имея референсную картинку от <code>Windows Performance Analyzer</code>, во-вторых, чтобы иметь возможность отфильтровать вывод и воспользоваться другими преимуществами оригинальных скриптов, например, построением диференциальных графов по результатам двух измерений.</p><p>Для этого нужно сконвертировать данные из бинарного etl формата в текстовый утилитой <code>xperf</code> (ставится вместе с <code>Windows Performance Analyzer</code>):</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xperf -i &quot;profile.etl&quot; -o perf.csv -target machine -symbols</span><br></pre></td></tr></table></figure><p>На выходе получается файл с записью о сэмплах, сделанных профайлером, примерно в таком виде:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SampledProfile,     508414, MyProc.exe (425204),     404904, 0xffff8563393bcd20,   0, MyProc.exe!$$Thunk@00002a54,   win32kbase.sys!ValidateHwnd,     1, Unbatched</span><br><span class="line">                  Stack,     508414,     404904, win32kbase.sys!ValidateHwnd, win32kfull.sys!xxxRealInternalGetMessage, win32kfull.sys!NtUserPeekMessage, ntoskrnl.exe!KiSystemServiceCopyEnd</span><br><span class="line">                  Stack,     508414,     404904, wow64win.dll!ZwUserPeekMessage, wow64win.dll!whNtUserPeekMessage, wow64.dll!Wow64SystemServiceEx, wow64cpu.dll!ServiceNoTurbo, wow64cpu.dll!BTCpuSimulate, wow64.dll!RunCpuSimulation, wow64.dll!Wow64LdrpInitialize, ntdll.dll!LdrpInitializeProcess, ntdll.dll!_LdrpInitialize, ntdll.dll!LdrpInitialize, ntdll.dll!LdrInitializeThunk, win32u.dll!NtUserPeekMessage, user32.dll!_PeekMessage, user32.dll!PeekMessageW, MyProc.exe!update, MyProc.exe!processEvents, MyProc.exe!loop, MyProc.exe!WinMain, MyProc.exe!invoke_main, MyProc.exe!__scrt_common_main_seh, MyProc.exe!__scrt_common_main, MyProc.exe!WinMainCRTStartup, kernel32.dll!BaseThreadInitThunk, ntdll.dll!__RtlUserThreadStart, ntdll.dll!_RtlUserThreadStart</span><br></pre></td></tr></table></figure></p><p>Этот файл необходимо распарсить и преобразовать в формат <code>folded stacks</code>, который выглядит так:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">win32kbase.sys!ValidateHwnd;win32kfull.sys!xxxRealInternalGetMessage;win32kfull.sys!NtUserPeekMessage;ntoskrnl.exe!KiSystemServiceCopyEnd 42</span><br></pre></td></tr></table></figure></p><p>То есть:</p><ul><li>“Разворачиваем” порядок вызова функций в стеке, и заменяем разделитель на “;”</li><li>Небольшая хитрость - нужно сосчитать все повторяющиеся стеки и в конце строки записать их количество</li><li>Манглинг имён - некоторые спецсимфолы нужно заэкранировать, чтобы на следующем этапе скрипты flamegraph не сломались</li></ul><p>Результат:<br><a href="https://github.com/spiiin/converters_to_flamegraph/blob/master/xperf_csv_to_collapsed_stacks.py" target="_blank" rel="noopener">https://github.com/spiiin/converters_to_flamegraph/blob/master/xperf_csv_to_collapsed_stacks.py</a></p><p>Дальше ставим <a href="https://strawberryperl.com/" target="_blank" rel="noopener">perl</a> и выполняем скрипт <a href="https://github.com/brendangregg/FlameGraph/blob/master/flamegraph.pl" target="_blank" rel="noopener">flamegraph.pl</a>, чтобы сконвертировать файл со свёрнутыми стеками, которые сгенерировал питоновский скрипт, в svg-файл для изучения.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flamegraph.pl perf.folded &gt; perf.svg</span><br></pre></td></tr></table></figure><p>На выходе получается файл svg (содержащий xml-данные и js-код), который можно открыть в любом браузере и изучить.<br><img src="/blog/2526702897/perf_win32_small.png" alt="perf_win32_smal"></p><h2 id="macOS-iOS"><a href="#macOS-iOS" class="headerlink" title="macOS/iOS"></a>macOS/iOS</h2><p>В Apple тоже решили, что экспорт в CSV никому не нужен и убрали его, потому тут тоже приходится искать обходные пути.</p><p>Самый простой найденный мной - собрать данные с помощью <code>Instruments -&gt; Time profile</code> и скопировать их в виде текста самому.<br>Также что порядок действий такой:<br><img src="/blog/2526702897/xcode-config_small.png" alt="xcode_config"></p><p><strong><code>1. Выделить промежуток времени, данные для которого хочется изучить</code></strong><br><strong><code>2. Настроить отображение колонок для экспорта</code></strong><br>Нужно отключить все, кроме количества сэмплов (символ “#”) и имён функций (<code>Symbol Name</code>). Не забыть выключить также отображение иконок функций (они создают дополнительный символ табуляции и пробела при экспорте).<br><strong><code>3. Выделить корневой (ТОЛЬКО корневой!) элемент для экспорта мышкой и в меню XCode выбрать пункт Edit-&gt;Deep Copy</code></strong></p><p>Дальше скопированные данные нужно вставить в текстовый файл и сохранить (под именем <code>sample.txt</code>, как ожидает скрипт конвертации).<br>Пример экспортированных данных<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># SamplesSymbol Name</span><br><span class="line">34532MyApp (637)</span><br><span class="line">28052 Main Thread  0x12daf</span><br><span class="line">28048  start</span><br><span class="line">28048   UIApplicationMain</span><br><span class="line">28048    GSEventRunModal</span><br><span class="line">28048     CFRunLoopRunSpecific</span><br><span class="line">28048      __CFRunLoopRun</span><br><span class="line">27796       __CFRunLoopDoSource1</span><br><span class="line">27789        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__</span><br><span class="line">27789         __CFMachPortPerform</span><br><span class="line">27787          IODispatchCalloutFromCFMessage</span><br><span class="line">27766           CA::Display::DisplayLink::dispatch_items(unsigned long long, unsigned long long, unsigned long long)</span><br><span class="line">27741            -[AppController doCaller:]</span><br></pre></td></tr></table></figure></p><p>Здесь чуть хитрее, чем в Windows версии, так как данные о глубине стека сохранены в виде количества пробелов относительно предыдущей строки. Зато уже подсчитано количество сэмплов.</p><p>Готовые скрипты типа <a href="https://github.com/brendangregg/FlameGraph/blob/master/stackcollapse-instruments.pl" target="_blank" rel="noopener">этого</a>, конечно, больше не работают- видимо формат экспорта данных немного сменился с обновлениями. Так что, как и для win-версии пришлось сделать свой на питоне:<br><a href="https://github.com/spiiin/converters_to_flamegraph/blob/master/instruments_to_collapsed_stacks.py" target="_blank" rel="noopener">https://github.com/spiiin/converters_to_flamegraph/blob/master/instruments_to_collapsed_stacks.py</a></p><p>Он не такой короткий, как оригинальный на перле (<a href="https://xkcd.ru/208/" target="_blank" rel="noopener">расступитесь, я знаю регулярные выражения!</a>), зато его проще понять и подправить, если формат экспорта снова изменится. </p><p>Последний шаг - конвертация:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flamegraph.pl perf.folded &gt; perf.svg</span><br></pre></td></tr></table></figure></p><p>И уииии, у меня есть флеймграф выполнения программы:<br><img src="/blog/2526702897/perf_ios_small.png" alt="perf_ios_smal"></p><h2 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h2><p>Здесь я не стал возиться с экспортом данных, потому что штатный профайлер Android Studio <a href="https://youtu.be/O5V9ZSL0BsM?t=86" target="_blank" rel="noopener">умеет</a> отображать флеймграфы. Данные можно экспортировать в виде .track-файла и загружать его для изучения в Android Studio.<br>Тем не менее, вроде бы, при большом желании, используя <a href="https://android.googlesource.com/platform/prebuilts/simpleperf/+/67b5f82a399fba110faf781a8be55aaaa0f21084/README.md#show-flamegraph" target="_blank" rel="noopener">simpleperf</a> из командной строки можно заставить сгенерировать данные в виде сжатых графов.</p><h2 id="Замечания"><a href="#Замечания" class="headerlink" title="Замечания"></a>Замечания</h2><p>Исследуя фреймграфы, стоит помнить о стандартных штуках при профилировании приложений и игр:</p><ul><li>Статистические профайлеры отмечают, в каком месте выполнения находится процессор, “”включаясь” с определенной заданной частотой, им нужно некоторое время (несколько секунд), чтобы собрать данные. Они не очень подходят для отображения пиков-фризов в определенном кадре.</li><li>Для регрессионного профилирования нужно подумать о хорошо воспроизводимых тестовых сценариях.</li><li>Флеймграфы показывают не абсолютное время работы конкретных функций, а сгруппированное количество сэмплов в ходе профилирования - этого достаточно, чтобы понять, чем “обычно” занят процессор в ходе выполнения программы.</li><li>Изредка слетает отображение имён символов. Нужно изучать документацию к конкретному профайлеру. Часто помогает просто провести повторное измерение.</li><li>Данные, относящиеся к вызовам графического API, показывают работу CPU по отправке команд на GPU - отрисовка этих данных начинает выполняться позже и выполняется параллельно с последующей работой CPU. То же самое касается работы со звуковым чипом. Профилирование сети и обращений к диску возможно и обычными профайлерами (Off-CPU profiling).</li><li>Придётся научиться читать и понимать STL-код, и расшифровывать замангленные имена функций компилятора (например, лямбда-функции).</li></ul><h2 id="Репозиторий-со-скриптами"><a href="#Репозиторий-со-скриптами" class="headerlink" title="Репозиторий со скриптами"></a>Репозиторий со скриптами</h2><p><a href="https://github.com/spiiin/converters_to_flamegraph" target="_blank" rel="noopener">https://github.com/spiiin/converters_to_flamegraph</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;В прошлой заметке я писал, что флеймграфы можно генерировать из данных различных профайлеров, сейчас решил проверить, насколько это удобно на практике.&lt;br&gt;&lt;a href=&quot;/blog/2779627234/&quot; title=&quot;Flamegraphs&quot;&gt;Flamegraphs&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="dev" scheme="http://spiiin.github.io/tags/dev/"/>
    
  </entry>
  
  <entry>
    <title>Flamegraphs</title>
    <link href="http://spiiin.github.io/blog/2779627234/"/>
    <id>http://spiiin.github.io/blog/2779627234/</id>
    <published>2021-07-14T06:53:59.000Z</published>
    <updated>2021-07-18T09:43:59.740Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p><a href="https://www.brendangregg.com/flamegraphs.html" target="_blank" rel="noopener">Флеймграфы</a> - удобный способ представления информации, собранной профайлером.</p><a id="more"></a><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/nZfNehCzGdw" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div><p>Видео с объяснением, зачем нужны, и примерами применения (на сайте есть более свежие версии, но в этой собрано всё сразу).</p><p>На вход тулзе подаётся текстовый файл с собранными профайлером данными. Чаще всего используются статистические профайлеры, которые генерируют сэмплы с определённой частотой и собирают информацию о стеках вызовов.</p><p>Однако текстовый вывод таких профайлеров громоздкий и малоинформативный, поэтому они преобразуются с помощью скриптов на перле в <code>CPU Samples Flamegraph</code>, который позволяет визуально увидеть, чем именно был занят процессор.</p><p>Граф представляет собой SVG-файл с JavaScript-кодом, который можно рассматривать и изучать в Google Chrome интерактивно. Размер файла - ~500кб, что позволяет хранить графы различных измерений программы (например, в системе задач, для передачи между програмистами, QA и инженерами по производительности) и сравнивать их между собой.</p><p>Получить данные в нужном для построения графа виде позволяет практически любой профайлер:<br><code>perf, eBPF, SystemTap, and ktap, DTrace, XCode instruments, XPerf - Linux/MacOSX/Windows</code><br>Также есть способы собрать данные для различных интерпретируемых языков и виртуальных машин.</p><p>Мобильные системы идут немного своим путём, но также можно получить данные для:<br><a href="https://blog.rhye.org/post/android-profiling-flamegraphs/" target="_blank" rel="noopener">Android</a> (<a href="https://aflame.rhye.org/" target="_blank" rel="noopener">онлайн-конвертер</a>)<br><a href="https://github.com/lennet/FlameGraph" target="_blank" rel="noopener">iOS</a> (<a href="https://schani.wordpress.com/2012/11/16/flame-graphs-for-instruments/" target="_blank" rel="noopener">ещё</a>)</p><p>Больше примеров - <a href="https://github.com/brendangregg/FlameGraph" target="_blank" rel="noopener">github</a>, <a href="https://www.brendangregg.com/flamegraphs.html" target="_blank" rel="noopener">сайт автора</a></p><p>Автор показывает способы, как профилировать не только CPU, но и память, обращения к диску и сетевые события.</p><p>Производные от Flamegraph способы представления профилируемых данных:<br><code>Facebook Icicle charts</code><br><code>Google Flame charts</code></p><p>Инструменты для Linux, которые представляют информацию в том числе в виде флеймграфов:<br><a href="https://github.com/KDAB/hotspot" target="_blank" rel="noopener">Hotspot</a> - CPU сэмплы<br><a href="https://github.com/KDE/heaptrack" target="_blank" rel="noopener">Heaptrack</a> - потребление памяти в куче</p><p>Для Windows:<br><a href="https://github.com/Donpedro13/etwprof" target="_blank" rel="noopener">etwprof</a></p><p>Применение в играх:<br><a href="https://technology.riotgames.com/news/profiling-measurement-and-analysis" target="_blank" rel="noopener">Profiling: Measuring and Analysis</a> - серия статей Tony Albrecht, на основе видео <a href="https://youtu.be/VAT9E-M-PoE" target="_blank" rel="noopener">Pitfalls of Object Oriented Programming, Revisited - Tony Albrecht (TGC 2017)</a>.<br><a href="https://johnysswlab.com/flamegraphs-understand-where-your-program-is-spending-time/" target="_blank" rel="noopener">FlameGraphs: Understand where your program is spending time</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.brendangregg.com/flamegraphs.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Флеймграфы&lt;/a&gt; - удобный способ представления информации, собранной профайлером.&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="dev" scheme="http://spiiin.github.io/tags/dev/"/>
    
  </entry>
  
  <entry>
    <title>Как разобраться в большой кодовой базе</title>
    <link href="http://spiiin.github.io/blog/1160101424/"/>
    <id>http://spiiin.github.io/blog/1160101424/</id>
    <published>2021-07-13T14:42:08.000Z</published>
    <updated>2021-07-18T12:00:50.316Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Как читать и изучать код в больших кодовых базах.<br><a id="more"></a></p><p><a href="https://solid-angle.blogspot.com/2015/08/tips-for-navigating-large-game-code.html" target="_blank" rel="noopener">Tips for Navigating Large Game Code Bases</a> - как начать, если устроился разработчиком игр.</p><ul><li>разобраться, как собрать проект и запустить игру</li><li>спросить, есть ли инструкция, документация, или туториалы</li><li>узнать, нет ли простой демки, показывающей возможности движка</li><li>найти часть кода, которая связана с первой задачей<br>(поиск связанных слов по всему коду, отладчик, спросить тим-лида или кого-нибудь)</li><li>воспользоваться редактором игры или тулзами</li><li>почитать историю коммитов</li><li>поискать, какие средства есть для решения задачи в движке, не решать с нуля</li><li>найти и изучить документ, описывающий Coding Style</li><li>разобраться с процессом добавления своего кода в репозиторий</li></ul><p>Позже:</p><ul><li>попробовать найти основной игровой цикл</li><li>изучить иерархию базовых игровых классов</li><li>изучить основные используемые в работе классы и модули</li><li>понять принцип разделения движка и игры на подсистемы/модули/etc</li><li>изучить пайплайн добавления ассетов</li><li>разобраться с используемыми скриптовыми языками</li><li>попробовать разобрать рендер игровой сцены</li><li>изучить используемые средства профилирования</li><li>изучить способы сборки игры под различные платформы</li></ul><p><a href="https://aras-p.info/texts/files/2018Academy%20-%20About%20Code.pdf" target="_blank" rel="noopener">Random Things About Code</a><br>Раздел <code>Navigating large codebases</code></p><p>Смириться с тем, что большие кодовые базы:</p><ul><li>содежат много legacy кода</li><li>плохо документированы</li><li>содержат места, про которые никто не знает как/зачем/почему они были добавлены<br>(но большая часть кода всё же была добавлена с определенной целью, и выбросить/переделать - часто плохая идея)</li></ul><p>Если что-то выглядит странно/непонятно/неправильно:</p><ul><li>30% что есть причина (неочевидная) почему сделано так</li><li>30% что когда-то БЫЛА причина</li><li>30% что причины нет, и код просто кривой</li><li>10% что Ктулху Рльех Фтагн</li></ul><p><a href="https://aras-p.info/blog/2013/07/07/reviewing-all-the-code/" target="_blank" rel="noopener">Reviewing ALL THE CODE</a> - как следить за всем, что происходит в кодовой базе, Aras Pranckevičius (Unity)<br>Средства, упрощающие изучение всех изменений в кодовой базе</p><p>Что изучать:<br><code>Unity</code><br><code>Unreal Engine</code><br><code>Godot</code><br><code>Doom 3</code><br><code>Cocos2d-x</code></p><p>Возможно:<br>(что-то не поддерживается, что-то сложно получить)<br><code>MonoGame</code><br><code>CryEngine</code><br><code>Unigine</code><br><code>Defold</code><br><code>GameMaker</code></p><p>Код в Doom 3<br><a href="https://kotaku.com/the-exceptional-beauty-of-doom-3s-source-code-5975610" target="_blank" rel="noopener">The Exceptional Beauty of Doom 3’s Source Code</a><br><a href="https://fabiensanglard.net/doom3/index.php" target="_blank" rel="noopener">Doom 3 source code review</a></p><p>Интервью с одним из лид-программистов Unreal<br><a href="https://youtu.be/bzHevRs-cd4" target="_blank" rel="noopener">Как Делают Игры 172. Unreal Engine</a><br><a href="https://youtu.be/Q-2Nf5j71m0" target="_blank" rel="noopener">Как Делают Игры 289. Unreal Engine 5</a></p><p>Про пайплайны:<br><a href="https://hookrace.net/blog/hana-cpp-development/" target="_blank" rel="noopener">HANA C++ Development Environment and Processes</a> - не относится к играм, но есть ссылки на пару интересных тулзов для работы с тяжёлой кодовой базой.<br><a href="https://aras-p.info/texts/files/201410-TUM-HobbyEngineToGameEngine.pdf" target="_blank" rel="noopener">Hobby engine to game engine</a> - отличия в пайплайне небольших движков и больших, на примере Unity.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Как читать и изучать код в больших кодовых базах.&lt;br&gt;
    
    </summary>
    
    
    
      <category term="dev" scheme="http://spiiin.github.io/tags/dev/"/>
    
  </entry>
  
</feed>
