<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Spiiin&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://spiiin.github.io/"/>
  <updated>2022-12-26T13:30:22.109Z</updated>
  <id>http://spiiin.github.io/</id>
  
  <author>
    <name>spiiin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Хеш-таблицы. Шпаргалка</title>
    <link href="http://spiiin.github.io/blog/847579411/"/>
    <id>http://spiiin.github.io/blog/847579411/</id>
    <published>2022-12-25T20:09:16.000Z</published>
    <updated>2022-12-26T13:30:22.109Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Небольшой обзор типов хеш-таблиц, которые чаще всего встречаются в языках программирования.</p><a id="more"></a><p>Материалы:<br>[1] - <a href="https://youtu.be/ncHmEUmJZf4" target="_blank" rel="noopener">Matt Kulukundis “Designing a Fast, Efficient, Cache-friendly Hash Table, Step by Step”</a><br>[2] - <a href="http://bannalia.blogspot.com/2022/06/advancing-state-of-art-for.html" target="_blank" rel="noopener">Advancing the state of the art for std::unordered_map implementations</a><br>[3] - <a href="http://craftinginterpreters.com/hash-tables.html" target="_blank" rel="noopener">Crafting Interpreters</a>. Глава “Hash tables”<br>[4] - <a href="https://www.sebastiansylvan.com/post/robin-hood-hashing-should-be-your-default-hash-table-implementation/" target="_blank" rel="noopener">Robin Hood Hashing should be your default Hash Table implementation</a><br>[5] - <a href="https://www.youtube.com/watch?v=M2fKMP47slQ" target="_blank" rel="noopener">You Can Do Better than std::unordered_map: New Improvements to Hash Table Performance</a> - доклад автора ska::flat_hash_map<br>[6] - <a href="https://pdimov.github.io/articles/unordered_dev_plan.html" target="_blank" rel="noopener">Development Plan for Boost.Unordered</a></p><p>Хеш-таблицы (наряду с массивами) — одна из основных структур данных стандартной библиотеки практически каждого языка программирования. Базовые понятия можно изучить из любой книги по алгоритмам и структурам данных, например, <code>Седжвик - Фундаментальные алгоритмы на C++</code>.</p><p>Теоретически, хеш-таблица (ассоциативный массив) — это контейнер, который хранит пары [ключ, значение] с быстрым доступом (амортизированно, O(1)). Практически, есть много интересных нюансов организации хранения.<br>Хеш-таблица логически организована как несколько корзин (bucket/slot), которые хранят данные (пары, значения, указатели на них). Место хранения (конкретная корзина) определяется с помощью хеш-функции, которая отображает ключ на номер корзины.</p><h2 id="Размер-таблицы"><a href="#Размер-таблицы" class="headerlink" title="Размер таблицы"></a>Размер таблицы</h2><p>Память компьютера не бесконечна, так что количество корзин очевидно должно быть меньше, чем все количество всех возможных значений ключей. Так как хеш-таблицы — очень общая структура данных, то баланс между размером таблицы и скоростью доступа является сложной задачей. Разные типы хеш-таблиц начинают просаживаться по скорости начиная с различной степени заполненности, так что оптимальный размер таблицы зависит от её внутреннего устройства. Бывают типы таблиц, которые “расширяются” начиная от 50%, 75% или даже 90-95%</p><h2 id="Хеш-функции"><a href="#Хеш-функции" class="headerlink" title="Хеш-функции"></a>Хеш-функции</h2><p>Идеальный случай — если каждый ключ отображается на уникальную корзину. Но когда хеш-функция для двух ключей возвращает одно и то же значение, происходит коллизия. Одно из фундаментальных различий организации хеш-таблиц — способ работы с коллизиями. От него же зависит от отклонение между теоретическим и практическим временем поиска элемента в таблице.</p><p>Тем не менее, перед рассмотрением способов работы с коллизиями, стоит сказать пару слов о хеш-функциях. Чем более равномерно будут “размазаны” входные значения по корзинам хеш-таблицы, тем лучше. Если входные данные неизвестны заранее, то хорошим способом будет максимально рандомизировать хеш-функцию. Огромная часть производительности хеш-таблиц зависит от того, насколько равномерно входные данные попадают в различные корзины, так что первый шаг в проверке производительности — проверить используемую функцию ([1], <a href="https://youtu.be/ncHmEUmJZf4?t=170" target="_blank" rel="noopener">тайминг</a>)</p><h2 id="Идеальное-хеширование"><a href="#Идеальное-хеширование" class="headerlink" title="Идеальное хеширование"></a>Идеальное хеширование</h2><p>В случае, если входные данные известны заранее и можно построить по ним таблицу до начала её использования, можно попробовать перебором подобрать такую хеш-функцию, которая вообще не вызовет коллизий на входных данных (<code>идеальное хеширование</code>). Отчасти расширением этого подхода можно назвать <a href="https://www.geeksforgeeks.org/cuckoo-hashing/" target="_blank" rel="noopener">хеширование кукушки</a>. В этом случае есть две отдельных хеш таблицы с разными хеш-функциями, и элемент может храниться в любой из двух таблиц. Если слот в одной из корзин занят, можно попробовать положить один из элементов в другую таблицу, и циклически переместить другие занятые в одной из таблиц слоты с другую. Если же найден цикл — можно попробовать или сменить пару хеш-функций и переложить все элементы в другую таблицу, или добавить третью таблицу с еще одной хеш-функцией.</p><h2 id="Separate-chaining"><a href="#Separate-chaining" class="headerlink" title="Separate chaining"></a>Separate chaining</h2><p>Один из простых случаев разрешения коллизий — хранить в корзинах не значения, а односвязный список, в который добавляются значения с одинаковым ключом. Такой подход могут называть раздельное хеширование или закрытая адресация (closed addressing, в значении “возможность положить значение не в свою корзину закрыта”). Минусы такого способа, как и самого связанного списка — необходимость динамического выделения памяти и дополнительный прыжок в памяти по указателю на элемент.</p><p>Тем не менее, практически в чистом виде встречается в C++ (<code>stl::unordered_map</code>), в <a href="https://github.com/mono/mono/blob/mono-3.0.3/mcs/class/corlib/System.Collections.Generic/Dictionary.cs#L66" target="_blank" rel="noopener">C#</a>, Java, <a href="https://medium.com/kalamsilicon/hash-tables-implementation-in-go-48c165c54553" target="_blank" rel="noopener">Go</a>.</p><p>Для C++, вдобавок, в стандарте прописана необходимость реализации API в виде связанного списка (<a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1456.html" target="_blank" rel="noopener">N1456</a>, комментарий в [1], <a href="https://youtu.be/ncHmEUmJZf4?t=549" target="_blank" rel="noopener">тайминг</a> — <em>when stl is starting to make sense, and that is never a good sign</em>).</p><p><code>boost::unordered_map</code><br>В [2] приводятся примеры нескольких реализаций такого API и возможных оптимизаций по производительности (<em>Time and memory performance of Boost 1.80 boost::unordered_map</em>).<br><img src="/blog/847579411/fca_small.png" alt=""></p><ul><li>bucket groups - бит-маска занятых элементов вместо указателей из одного слота в другой (на скрине выше), за счет экономии памяти лучше влезает в кеш</li><li>количество корзин при максимально допустимой загруженности таблицы растет не в 2 раза, а как последовательность простых чисел — способствует более равномерному распределению при плохом (non-uniform) выборе хеш-функции<br>(<a href="https://www.boost.org/doc/libs/develop/libs/unordered/doc/html/unordered.html#compliance" target="_blank" rel="noopener">бенчмарк</a>)<br>[6] - обзор альтернативных типов таблиц</li></ul><p>Одна из нераспространенных на практике идей из классических книг — сохранять упорядоченность списков для небольшого ускорения проверки наличия элемента в списке (<em>скорее всего, из-за потери возможности хранить указатели на элементы корзины</em>)</p><h2 id="Open-addressing"><a href="#Open-addressing" class="headerlink" title="Open addressing"></a>Open addressing</h2><p>Варианты названия:<br><code>Open addressing</code> (открытая адресация, в смысле, что возможность попадания элемента не свою корзину отрыта)<br><code>Closed hashing</code> (<a href="http://craftinginterpreters.com/hash-tables.html#open-addressing" target="_blank" rel="noopener">3</a>, закрытое хеширование в смысле что возможность элемента оказаться вне корзин закрыта)<br><code>Probing table</code>(<a href="https://youtu.be/ncHmEUmJZf4?t=943" target="_blank" rel="noopener">1</a>, для случая, если в корзинах хранятся не указатели, а значения)<br><code>Scatter tables</code>(<a href="https://book.huihoo.com/data-structures-and-algorithms-with-object-oriented-design-patterns-in-java/html/page231.html" target="_blank" rel="noopener">Data Structures and Algorithms with Object-Oriented Design Patterns in Java</a>, аналогично)<br><code>Flat map</code> (аналогично)</p><p>Зачем хранить элементы с повторяющимся хешем ключа в связанном списке, если можно положить их в другие корзины? Это сложнее в организации, возникает серия вопросов — как именно выбрать альтернативную корзину, как узнать, что в корзине находится “не родное” значение, как удалять элементы? Дальнейшую таксономию таблиц с открытой адресацией можно выстроить в зависимости от ответов на эти вопросы.</p><p>Варианты ответов:</p><p><strong><code>Как выбрать альтернативную корзину</code></strong></p><ul><li>Попробовать следующую (после последней заново проверить первую) — линейное пробирование.<br>Распространенный метод из-за того, что дружественный к кешу, элементы хранятся в памяти близко друг к другу.<br>Может вызывать проблемы при большой загруженности таблицы, но это можно решать различными способами — пересортировать элементы хранящиеся рядом, позаботиться о более качественном “размазывании”, см. раздел “Хеш-функции”), уменьшить коэффициент заполненности, при котором будет увеличено количество корзин. Эти решения проблем будут более детально рассмотрено далее</li><li>Увеличивать шаг не на 1, а по более сложным правилам — квадрат от номера попытки, другая хеш-функция от значения элемента, etc. Требует хорошего понимания вероятности, насколько выбор шага может действительно улучшить распределение ключей по корзинам (может зависеть от размера таблицы и хеш-функции).</li></ul><p>Встречаются экзотические комбинации стратегий - <a href="https://github.com/ktprime/emhash" target="_blank" rel="noopener">emhash</a> в режиме 3-way combined сначала делает несколько линейных проб, затем квадратичные, и дальше пробует втиснуть элемент поочередно в начало/конец таблицы.</p><p><strong><code>Удаление значений</code></strong></p><ul><li>Вместо удаления значений, заменить реальное значение в корзине на “надгробие” (tombstone), чтобы при поиске элемента по списку рассматривать его “за этим значением есть другие для проверки”, а при вставке нового элемента рассматривать надгробие как пустую корзину для вставки</li><li>В случае линейной вставки элементов в первую попавшуюся пустую корзину можно переместить последний элемент списка на освободившееся пустое место. Несмотря на кажущуюся тривиальность алгоритма, требует аккуратности в реализации (как пример, в книге Кнута алгоритм содержал ошибки)</li></ul><p><strong><code>Как отличить неродное значение</code></strong></p><ul><li>В случае линейного пробирования, проверять все соседние занятые элементы до нахождения пустого значения<br>В случае сильно заполненной корзины, даже без наличия коллизий, может оказаться для что вставки нового значения потребуется проверить по порядку множество уже занятых значений (кластеры из занятых корзин). Аналогичная проблема при поиске несуществующего элемента.</li></ul><p>Тривиальный подход слежения за тем, чтобы не образовывались кластеры — хорошая хеш-функция и низкие значение коеффициенты заполненности (~0.5-0.6) для того, чтобы таблица разрослась раньше, чем в ней образовались большие кластеры из заполненных корзин. Более сложный — переставлять элементы внутри кластеров так, чтобы уменьшить количество необходимых поисков (алгориты <code>Брента</code>, <code>Робин Гуда</code>, детальнее ниже)</p><h2 id="Линейное-пробирование-без-перестановок"><a href="#Линейное-пробирование-без-перестановок" class="headerlink" title="Линейное пробирование без перестановок"></a>Линейное пробирование без перестановок</h2><p>Почти чистый вариант линейного пробирования без дополнительных хитростей с перестановками элементов приведен в [3].</p><p>Вариант из <code>daScript</code>:</p><ul><li>Рост таблицы при кластеризации в 2 раза. Чем больше таблица, тем меньше <a href="https://github.com/GaijinEntertainment/daScript/blob/a0fcdfdbf134d3dfb8055c9218c6e57ff4ae925b/include/daScript/simulate/runtime_table.h#L61" target="_blank" rel="noopener">коеффициент заполненности</a> (при увеличение таблицы в 2 раза разрешаем в 6 раз больше промахов)</li><li>Раздельное хранение хешей, хеширование <a href="https://github.com/GaijinEntertainment/daScript/blob/master/include/daScript/misc/fnv.h" target="_blank" rel="noopener">fnv</a></li><li>Tombstone при удалении</li></ul><p><a href="https://abseil.io/docs/cpp/guides/container" target="_blank" rel="noopener">absl::flat_hash_map</a> + <a href="https://abseil.io/about/design/swisstables" target="_blank" rel="noopener">Swiss Tables Design Notes</a><br>[1] - доклад с пошаговым описанием идей дизайна flat_hash_map + <a href="https://www.youtube.com/watch?v=JZE3_0qvrMg" target="_blank" rel="noopener">дополнение</a></p><ul><li>Раздельное хранение метаинформации + simd инструкции для ускорения проверок</li></ul><p>Пример возможной проблемы с кластеризацией значений:<br><img src="/blog/847579411/cluster_small.png" alt=""></p><p>Даже если все элементы отмеченные красным, стояли на своих местах, может получиться, что новый элемент (зеленый), будет вставлен далеко от своего потенциального места (первая стрелка).</p><p>Одна из неочевидных проблем линейного пробирования — про последовательном обходе элементов из хеш-таблицы (неявно отсортированы по возрастанию хешей) и перекладывании их в другую таблицу они попадут туда в очень плохом порядке (при добавлении второй половины таблицы до роста хеши элементов по модулю будут совпадать с хешами из первой половины, которая будет уже плотно заполнена — зона заполненности “от 0.5 до коэффициент роста” будет содержать большое количество коллизий) — пример багов в <a href="https://habr.com/ru/post/282902/" target="_blank" rel="noopener">Delphi</a>, <a href="http://lemire.me/blog/2017/01/30/maps-and-sets-can-have-quadratic-time-performance/" target="_blank" rel="noopener">Swift</a>, <a href="https://accidentallyquadratic.tumblr.com/post/153545455987/rust-hash-iteration-reinsertion" target="_blank" rel="noopener">Rust</a>. Возможное решение — использовать хеш-функцию с возможностью задать стартовый сид и менять его для каждой новой таблицы. Или попробовать предсказать размер заполняемой таблицы заранее.</p><h2 id="Линейное-хеширование-с-перестановкой-Брента"><a href="#Линейное-хеширование-с-перестановкой-Брента" class="headerlink" title="Линейное хеширование с перестановкой Брента"></a>Линейное хеширование с перестановкой Брента</h2><p>На скриншоте выше все элементы представленные красным стоят на своих местах, и могут быть найдены за 1 запрос к таблице. Но при поиске красного элемента нужно будет проверить 9 элементов. При этом, если все красные элементы кластера сдвинуть на 1 вправо, то для поиска каждого из них потребовалось бы всего 2 запроса — среднее время поиска осталось бы таким же, но максимальное время поиска уменьшилось бы с 9 до 2, в 4.5 раза. Метод Брента — перед вставкой проверить сколько запросов будет при такой перестановке и выбрать самый оптимальный вариант (<a href="https://www.cs.umd.edu/class/fall2018/cmsc420-0301/lecnotes/Hashing-spring17.pdf" target="_blank" rel="noopener">описание и пример</a>, а также какое-то расширение метода в поиск по дереву Gonnet-Munro, <a href="https://github.com/ncilengir/brent-hashing" target="_blank" rel="noopener">другое описание</a> и <a href="http://www.minkhollow.ca/Courses/461/Notes/Hashing/HashBrentex1.html" target="_blank" rel="noopener">другой пример</a>).</p><p>Реализация метода Брента в таблицах <a href="https://www.lua.org/source/5.4/ltable.c.html" target="_blank" rel="noopener">lua</a> и <a href="https://poga.github.io/lua53-notes/table.html" target="_blank" rel="noopener">описание</a></p><h2 id="Линейное-хеширование-с-перестановкой-Робин-Гуда"><a href="#Линейное-хеширование-с-перестановкой-Робин-Гуда" class="headerlink" title="Линейное хеширование с перестановкой Робин Гуда"></a>Линейное хеширование с перестановкой Робин Гуда</h2><p><a href="https://cs.uwaterloo.ca/research/tr/1986/CS-86-14.pdf" target="_blank" rel="noopener">Пейпер</a> с описанием метода, там же есть сравнение с методом Брента (стр 51-53) — чуть более быстрая вставка, за счет немного медленного среднего времени поиска, но более быстрая проверка несуществующего элемента. Позволяет заполнять таблицы на 90% перед тем, как увеличивать объём.</p><p>Логика вставки — если для уже сохраненного в слоте элемента расстояние до его идеальной позиции меньше, чем для нового, то “выселяем” элемент из слота, и проверяем дальше, с кем можно переставить его (“забираем позицию у богатого элемента и отдаём бедному”). <a href="http://web.stanford.edu/class/archive/cs/cs166/cs166.1196/lectures/13/Slides13.pdf" target="_blank" rel="noopener">Пример вставки</a></p><p>Описание в <a href="https://cglab.ca/~abeinges/blah/robinhood-part-1/" target="_blank" rel="noopener">Rust</a>:</p><ul><li>Линейное хеширование с перестановкой Робин Гуда</li><li>Рост таблицы после заполненности 0.9 в 2 раза</li><li>Хеш-функция с уникальным сидом для каждой таблицы для защиты от неудачной вставки ключей в порядке увеличения хеш-значений</li></ul><p><a href="https://github.com/skarupke/flat_hash_map" target="_blank" rel="noopener">ska::flat_hash_map</a>:</p><ul><li>Линейное хеширование с перестановкой Робин Гуда</li><li>Рост таблицы при первом длинном неудачном пробировании, до следующего prime number</li></ul><p><a href="https://probablydance.com/2017/02/26/i-wrote-the-fastest-hashtable/" target="_blank" rel="noopener">I Wrote The Fastest Hashtable</a> - описание<br>Используются для внутренних структур данных в <a href="https://github.com/GaijinEntertainment/daScript/blob/dcecc6f126843fc0914b0be314542caa658fc8d6/include/daScript/das_config.h#L34" target="_blank" rel="noopener">daScript</a><br>[5] - доклад автора о влиянии отдельных приёмов оптимизации (крутое объяснение форм графиков, можно прикинуть свои паттерны и размеры таблиц), сравнение с различными реализациями хеш карт и хинты реализации</p><h2 id="Бенчмарки"><a href="#Бенчмарки" class="headerlink" title="Бенчмарки"></a>Бенчмарки</h2><p>Несколько бенчмарков различных C++ реализаций, с описанием типов таблиц:<br><a href="https://martin.ankerl.com/2016/09/15/very-fast-hashmap-in-c-part-1/" target="_blank" rel="noopener">https://martin.ankerl.com/2016/09/15/very-fast-hashmap-in-c-part-1/</a><br><a href="https://martin.ankerl.com/2019/04/01/hashmap-benchmarks-01-overview/" target="_blank" rel="noopener">https://martin.ankerl.com/2019/04/01/hashmap-benchmarks-01-overview/</a><br><a href="https://martin.ankerl.com/2022/08/27/hashmap-bench-01/" target="_blank" rel="noopener">https://martin.ankerl.com/2022/08/27/hashmap-bench-01/</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Небольшой обзор типов хеш-таблиц, которые чаще всего встречаются в языках программирования.&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="dev" scheme="http://spiiin.github.io/tags/dev/"/>
    
  </entry>
  
  <entry>
    <title>Making tools for big games</title>
    <link href="http://spiiin.github.io/blog/2767873544/"/>
    <id>http://spiiin.github.io/blog/2767873544/</id>
    <published>2022-12-25T14:57:07.000Z</published>
    <updated>2022-12-25T17:51:51.467Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Тезисы из доклада технического директора <code>Guerilla</code> Michiel van der Leeuw <a href="https://www.guerrilla-games.com/read/making-tools-for-big-games" target="_blank" rel="noopener">Making tools for big games</a></p><a id="more"></a><p><strong><code>Вступление</code></strong></p><ul><li>Технология в геймдеве перестала определять игру и её геймдизайн, а является одной из фич игры</li><li>Технология сейчас — это не только движок игры, а её тулсет</li><li>Тулсет позволяет поддерживать масштабирование количества контента игр, а также следить за качеством и процессом производства</li><li>Респект автора доклада <code>Naughty Dog</code>, часть идей оттуда</li></ul><p><strong><code>Идея 1. Сокращение &quot;зоны сумерек&quot;, когда QA находятся между игрой, таск-трекером, браузером, vcs, мессенджером и почтовым клиентом</code></strong></p><ul><li>Кастомный интерфейс к vcs, шаблоны для заполнения полей близкие к стандартам компании</li><li>Соединение перед пуллом с билд сервером для сверки, в порядке ли ревизия, которую собираешься получить</li><li>In-game gui для оформления задач в Jira — запись видео, логгирование игровых ресурсов в кадре</li><li>Редактор видео, в котором можно отметить тайминг бага/задачи, связанные ассеты, разметить зоны и отрезать лишнее. Ссылки на фрейм видео можно добавлять в задачи</li><li>Ассеты хранятся в базе данных с метаинформацией. Среди прочего, хранят обратные ссылки на баги, ссылающиеся на эти ассеты.</li></ul><p>Выявить точки, из которых удобнее всего совершать действия, и из этих точек с помощью api к другим приложениям дать возможность работать с этими приложениями без переключения контекста. Убрать рутину.<br>Пара бонусных идей не из доклада:</p><ul><li>В code-review вычислять, какие из прошлых коммитов/мердж реквестов затрагивает диф кода и выводить список этих коммитов (“чей код ты потенциально мог сломать”).</li><li>Подтягивать к багу в Jira данные из всех систем аналатики (доступ ко всей полезной инфе на одной страничке)</li></ul><p><strong><code>Идея 2. Слежение за здоровьем билда позволяет увеличить количество итераций</code></strong></p><ul><li>Бот-фермы из девкитов, которые выполняют скрипты телепортации по миру и сохраняют профилирование, телеметрию и игровую информацию в виде карты мира, отдельный редактор для визуализации и изучения этой карты</li><li>Примеры применения — визуализатор информации для гейм-дизайнеров и непосредственно отладка геометрических данных (карты рек, эрозии, нормалей, карты видимости неба), heat-map тормозящих мест, визуализация мест багов в jira. Всю информацию можно посмотреть в других местах, но такое картографирование позволяет оценить общую картину</li><li>Запросы к данным для отображения на карте исторических данных (диффы, графики, экспорт в json/csv)</li><li>Вьюер карты тесно связан с игрой (можно получать графики производительности с девайсов и кол-во потребляемой памяти, а также делать отметки на графиках и ссылаться на них)</li><li>Метрика — количество изменений, которое команда может позволить себе без страха делать в последние дни/недели перед релизом</li></ul><p><a href="/blog/1687824628/" title="Паттерны организации разработки уровней игр">Паттерны организации разработки уровней игр</a> - итерации делают игру лучше, упрощая процесс разработки<br><a href="/blog/3309518526/" title="Системы поиска сокровищ">Системы поиска сокровищ</a> - итерации кроме полировки могут позволить найти новые уникальные решения</p><p>Глобальная карта для отображения оверлеями различной информации — отличный инструмент, кажется, впервые видел идею с тепловой картой производительности еще в докладе про <code>starcraft 2</code>. Я такое тоже делал, чтобы отслеживать ассеты, которые артисты/геймдизайнеры забыли правильно разметить.</p><p><strong><code>Идея 3. Работу с ассетами всегда можно улучшить</code></strong></p><ul><li>Всё висит на сервере в памяти и стримится на девелоперские машины (10 Gb сеть в локалке)</li><li>Позволило серьёзно уменьшить размер дубликатов ресурсов</li><li>Можно сгенерить строковый айдишник, по которому другой человек может запустить в точности такую же версию игры</li><li>Самописный сервер на 650 строк, БД с парами ключ значение, быстрее шеринг через SMB, NFS, файловый сервер Apache, etc</li><li>Виртуальная файловая система, ОС не видит изменений</li><li>18 core cpu, 768 Gb ram, 80 Gb network, 16 tb ssd на 300 человек</li></ul><p>Наиболее радикальная идея, работать локально с исходными версиями ассетов, и стримить ресурсы через глобальный общий сервер. Доклад 2019 года, когда все сидели в одном офисе, но в <a href="https://twitter.com/MvdLeeuwGG/status/1606268200143970304" target="_blank" rel="noopener">твиттере</a> автор упоминает, что адаптировали и для домашней работы. Кроме блоба ассета хранится также метаинформация (например, ссылки, в каких тасках он задействован).</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Тезисы из доклада технического директора &lt;code&gt;Guerilla&lt;/code&gt; Michiel van der Leeuw &lt;a href=&quot;https://www.guerrilla-games.com/read/making-tools-for-big-games&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Making tools for big games&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="link" scheme="http://spiiin.github.io/tags/link/"/>
    
      <category term="dev_method" scheme="http://spiiin.github.io/tags/dev-method/"/>
    
  </entry>
  
  <entry>
    <title>daScript tiny renderer port</title>
    <link href="http://spiiin.github.io/blog/3563373441/"/>
    <id>http://spiiin.github.io/blog/3563373441/</id>
    <published>2022-12-25T14:02:28.000Z</published>
    <updated>2022-12-25T14:31:25.242Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Портировал первые несколько примеров <a href="https://github.com/ssloy/tinyrenderer/wiki" target="_blank" rel="noopener">Tiny renderer or how OpenGL works: software rendering in 500 lines of code</a> софт-рендера с C++ на daScript. Механически и неоптимально, но близко к коду оригинального туториала, для желающих потренироваться в базовых алгоритмах растеризации на daScript.<br><a href="https://github.com/spiiin/dascript_soft_render" target="_blank" rel="noopener">https://github.com/spiiin/dascript_soft_render</a></p><p>Растеризация отрезков, wireframe<br><img src="/blog/3563373441/1.png" alt=""><br>Растеризация треугольников line sweeping, flat shading, отсечение задних граней<br><img src="/blog/3563373441/2.png" alt=""><br>Z-буфер, наложение текстурных координат<br><img src="/blog/3563373441/3.png" alt=""><br>Перспективная проекция<br><img src="/blog/3563373441/4.png" alt=""><br>Камера, Gouraud shading<br><img src="/blog/3563373441/5.png" alt=""><br>Коррекция перспективных искажений текстурных координат, растеризация треугольника проверкой барицентрических координат точки, пиксельный и вершинный шейдеры<br><img src="/blog/3563373441/6.png" alt=""></p><p>В оригинале есть ещё детальный разбор матриц (model, view, projection), наложение карты нормалей, тени и ambient occlusion. Но, мне кажется где-то с этого уровня можно продолжать разбираться с графикой уже с помощью графического API.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;Портировал
      
    
    </summary>
    
    
    
      <category term="opengl" scheme="http://spiiin.github.io/tags/opengl/"/>
    
      <category term="3d" scheme="http://spiiin.github.io/tags/3d/"/>
    
      <category term="dascript" scheme="http://spiiin.github.io/tags/dascript/"/>
    
  </entry>
  
  <entry>
    <title>Итоги 2021-2022</title>
    <link href="http://spiiin.github.io/blog/2738337723/"/>
    <id>http://spiiin.github.io/blog/2738337723/</id>
    <published>2022-11-28T11:59:06.000Z</published>
    <updated>2022-12-16T18:39:17.161Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Сумбурная попытка собрать в кучу события в жизни за 2 года. В конце 2021 не успел, в начале 2022 уже как-то не до того было. Допишу понемногу как раз к новому году.</p><a id="more"></a><p>Предыдущая - <a href="/blog/307513906/" title="Итоги 2020">Итоги 2020</a></p><p><strong><code>Дисклеймер</code></strong></p><p>Очень не хочется писать про войну, слишком сложно и больно написать что-то коротко. Поэтому, в основном, просто списки из нескольких запомнившихся книг/игр/посещенных стран etc с небольшими заметками</p><p><strong><code>Личное/путешествия</code></strong></p><p>В начале 2021 года накрыло выгоранием от работы, одновременно с ощущением, “надо развиваться, иначе пиздец” и питерской простудой (это которая потом может привести к больному зубу и гаймариту). Ушёл в длинный отпуск, лечиться, читать книжки и медитировать над тем, где пропустил важный поворот. Попутно женился (снова с поездкой в Крым и отдыхом в Многоречье, Евпатории и Балаклаве), наконец продал старый дом в Бахчисарае, доставшийся в наследство много лет назад, и слетал отдохнуть в Калинград с коллегами.<br><img src="/blog/2738337723/photo1.png" alt=""></p><p>Охта-парк в последние выходные в Питере<br><img src="/blog/2738337723/ohta.png" alt=""></p><p>2022-й год — внезапный “развесёлый” трип (безвозвратная релокация) Самарканд-Стамбул-Ереван.<br><img src="/blog/2738337723/photo2.png" alt=""></p><p>Армения очень гостеприимная страна, с множеством как официальных достопримечательностей, так и <a href="https://www.wirade.ru/cgi-bin/wirade/YaBB.pl?board=stories;action=display;num=1086946148" target="_blank" rel="noopener">маленьких</a> мест и историй. Особенно порадовал Дилижан и окрестности. Успел слетать в Анталию в отпуск и в Дубаи и Пхукет в командировку. Так что год выдался богатым на поездки и ощущения.<br><img src="/blog/2738337723/photo3.png" alt=""></p><p>В конце года оказался в Израиле. Если Армения почти не отличалась по флоре и фауне от Украины и России, то тут на деревьях можно увидеть попугаев, ночью — больших летающих мышей (точнее, даже летающих лисиц), и кабанов, разгуливающих по городу. Бросаются в глаза и отличия в ценах и порядках. Другой мир со своими правилами.<br><img src="/blog/2738337723/photo4.png" alt=""></p><p><strong><code>Работа</code></strong></p><p>За пару лет побыл тим-лидом, разработчиком движка и техническим продюсером. Кроме плюсов в виде большого количества контактов и понимания процессов работы компании, существуют и минусы такого движения — “шлейф” переходов излишне расширяет зоны ответственности, необходимо явно “отвязываться” от прошлых обязанностей.</p><p>Снова запустили софт-ланч матч-3 игры - <a href="https://mytona.com/game/15" target="_blank" rel="noopener">Tasty Makeover</a><br><img src="/blog/2738337723/tmo.png" alt=""></p><p>Получил на память серебрянный значок<br><img src="/blog/2738337723/mytona.png" alt=""></p><p><strong><code>Музыка</code></strong><br><code>Piazzolla - Libertango</code><br><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/elYSQkTWfTw" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div><br>Пьяццолла удивительным образом стимулирует творческое настроение, подсмотрел у авторов “Worlds of Goo”</p><p><code>Dave Stewart, Boris Grebenshikov &amp; Serhii Babkin - Face to Face (feat. Stevie Nicks)</code><br><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/dRFIoyeU_bg" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div><br>Сергей Бабкин — это гитарно-дворовое регги из детства, а у Бориса Гребенщикова, кроме музыки, попадалась еще хорошая инструкция по медитации.</p><p><code>The Death Set - They Come to Get Us</code><br><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/dleV9-9xXsw" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div><br>Немного драйва десятилетней давности.</p><p><code>DakhaBrakha - Carpathian rap</code><br><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/OKhV3kLTTv8" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div><br>Видеоряд и мистика.</p><p><code>Selena Gomez, Rauw Alejandro - Baila Conmigo</code><br><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/h5WN3pkxPF0" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></p><p><strong><code>Игры</code></strong></p><p><code>- Divinity Original Sin 2 (Switch)</code><br>Красивая и интересная тактика, в которой можно позалипать в дизайн локаций. Очень много часов геймплея, хорошая адаптация управления под консоль. Рассчитана явно на пару прохождений (физическая и магическая партия). Много подготовки — обновление ассортимента оружия на каждый уровень партии, необходимость “пылесосить” локации, с возможностью полной зачистки лагерей или даже деревень.<br><code>- Monster Hunter: Rise (Switch)</code><br>Необычная смесь RPG с элементами файтинга (различные комбо для различного оружия), крутое взаимодействие с окружением (набор бустов перед боем, изучение фишек локаций). Не очень понравился переход из сингл-плейера в мульти-плейер — одиночный сюжет просто обрывается, без возможности посмотреть и победить самых сильных боссов.<br><code>- Civilization 6 (Switch/PC)</code><br>Эмерджентные механики, которые расширяют возможности геймплея в дополнительных правилах и нациях. Геймплей с дополнениями и без сильно отличается. Хорошая кривая обучения игре — интересно играть как в первый раз, так и в сотый, обучаясь нюансам механик.<br><code>- C&amp;C Rivals (iOS/Android)</code><br>Игра в жанре Clash Royale, тактическая RTS с элементами карточной игры. Юниты более-менее сбалансированы, большинство из них требует микроконтроля для полноценной реализации их в бою. Вызвала хейт фанатов серии из-за забивания на лор, но тем не менее, необычный и самобытный проект.<br><code>- Risen 3 (PC)</code><br>Моё первое знакомство с играми Pyranha Bytes и их подходу к разработке игр. Ну и пиратский сеттинг всегда приятно увидеть.<br><code>- Axie Infinity (PC/Android/iOS)</code><br>NFT-игра, притом не pay-to-win, скорее похожая по стратегии игры на покер (а вообще — безумная смесь тактики, кки и покемонов). Заодно и понятны опасности экономик подобного типа игр — баловство разработчиков с балансом, от нерфа карт в середине сезона, до выпуска новых типов предметов, или вообще выпуска альтернативной игры со сменой всех механик; взломы кошельков с хранилищем крипты, возможность общего обрушения игры; часть экономики, зависимая от привлечения новых игроков в игру. Тем не менее, в предыдущей версии — могла затянуть на несколько ночей в построение идеальных команд с тетрадкой, ручкой и экселем. Заслуживает отдельной статьи.<br><img src="/blog/2738337723/axie.png" alt=""><br><code>- Valheim</code><br>Хардкорная выживалка-песочница про викингов, с необычной графикой. Простые и низкодетализированные текстуры (если верить книге “Понимание комиксов” — менее детализированное окружение = меньшая враждебность в восприятии игрока) и прикольные эффекты и звук создают интересное восприятия локаций.<br><code>-TMNT: Shredder’s Revenge (PC/Switch)</code><br>Идеальный beat-them-up для игры на двоих и более черепашек.<br><code>- Candy Crush/Homescapes/Royal Match (iOS/Android)</code><br>Профессиональное изучение жанра<br><code>- Disco Elisium (PC)</code><br>Классный русский перевод и одна из лучших РПГ, в которых можно действительно отыграть поведение<br><code>- Hades (PC)</code><br>Отличный пример дизайна — встраивание механики развития и сюжета в рогалик, эмерджентные механики комбинаций оружия и бонусов, нарративная связь кор-геймплея и меты, сюжетный путь героя<br><code>- Witcher 1-2 (PC)</code><br>По прежнему крутые для фанатов, особенно в сочетании с книгами и третьей частью. В том числе и основной линией сюжета, которая продолжает историю из книг и дает возможность повлиять на судьбу персонажей.<br><img src="/blog/2738337723/witcher1.png" alt=""><br><img src="/blog/2738337723/witcher2.png" alt=""><br><a href="https://www.dropbox.com/sh/kwgasmi89f4su3q/AABinxk2WKfun6rNulXrX6Tka?dl=0" target="_blank" rel="noopener">Больше моих скриншотов</a> из всех трёх “ведьмаков”.</p><p>Традиционно заканчиваю год просмотром треда со скриншотами из игр на neogaf, <a href="https://www.neogaf.com/threads/2022-pc-screenshot-thread-of-no-compromises.1626951/" target="_blank" rel="noopener">2022 год</a> (и <a href="/blog/2486469456/" title="прошлые">прошлые</a>). Лучше всего характеризует этот год:<br><a href="https://live.staticflickr.com/65535/52090974365_3ec1d1b1db_o.jpg" target="_blank" rel="noopener"><img src="/blog/2738337723/jump.png" alt=""></a></p><p><strong><code>Книги</code></strong></p><p>Из нетехнического:</p><p><code>- Никулин Н., &quot;Воспоминания о войне&quot;</code><br>Реальность и ужасы войны.<br><code>- Нил Шубин, &quot;Внутренняя рыба&quot;</code><br>Про то, как млекопитающие выходили на сушу. И про то, что человек — перестроенная рыба, что до сих пор прослеживается в особенностях строения, и иногда в болезнях.<br><code>- Уилсон Э., &quot;Планета муравьев&quot;</code><br>Особенности муравьиного общества<br><code>- Даррелл Дж., &quot;Гончие Бафута&quot;, &quot;Под пологом пьяного леса&quot;</code><br><a href="https://vas3k.club/post/9639/" target="_blank" rel="noopener">Даррелл</a> — человек, который занимался своим делом, несмотря на происходящие в мире события — войны, революции. Что бы ни происходило вокруг, он собирал животных во всех уголках земли.<br><code>- Кристофер Александер, &quot;Язык шаблонов&quot;, &quot;Timeless way to building&quot;</code><br>Интересно было изучить как минимум потому, что на книги Александера часто ссылается в книге и докладах Джесси Шелл. Ну и как сам способ выделения паттернов из общего, что можно использовать не только в архитектуре, но в и программировании.</p><p>Из технического:</p><p><a href="/blog/37481721/" title="О книгах и самообразовании">О книгах и самообразовании</a> — много всякого. Старые книги о программировании, новых языках программирования, книги и доклады за последние годы по геймдеву, всё до чего удалось дотянуться по геймдизайну, немного о продюссировании игр и психологии.</p><p><strong><code>Фильмы</code></strong></p><p><code>- Эдди &quot;Орёл&quot;</code><br>Рассказ про отбитого прыгуна с трамплина на лыжах, который нашёл баг в правилах, и выступил на олимпиаде, не заморачиваясь общественным мнением. <a href="https://ru.wikipedia.org/wiki/%D0%AD%D0%B4%D0%B2%D0%B0%D1%80%D0%B4%D1%81,_%D0%AD%D0%B4%D0%B4%D0%B8" target="_blank" rel="noopener">Эдди Эдвардс</a>, много интересных фактов из биографии.<br><code>- Серьёзный человек</code><br>Черная комедия, нарушаюшая закон кино о том, что у совпадений должно быть какое-нибудь объяснение<br><code>- Душа</code><br>Мультик о поиске смысла и цели в жизни<br><code>- Терминал</code><br>Искренне сочувствуешь персонажу только в случае, когда понимаешь, что оказаться в подобной ситуации вполне реально<br><code>- Курс лекций Tymoty Snider по истории Украины</code><br>Бесплатные <a href="https://www.youtube.com/playlist?list=PLh9mgdi4rNewfxO7LhBoz_1Mx1MaO6sw_" target="_blank" rel="noopener">лекции</a> Йельского университета 2022 года. Интересно сравнить с российским и украинским видением истории страны.</p><p><strong><code>Приобретения</code></strong><br>iPad чтобы смотреть фильмы и читать комиксы и пачка low-end телефонов на андроиде для исследований багов и оптимизаций игр. Но в основном вспоминаются потери оставленного при переезде =\</p><p><strong><code>Развитие</code></strong><br>Изучил <code>историю C++</code> и <code>подхода ООП (в smalltalk)</code>, немного глубже вник в <code>STL</code> и библиотек <code>boost</code>, наконец посмотрел на относительно новые языки (<code>nim</code>, <code>go</code>, <code>racket</code>, <code>daScript</code>). Особенно заинтересовал <a href="https://spiiin.github.io/tags/dascript/">daScript</a> огромным потенциалом и заложенными в него идеями.</p><p>Прокачал немножко экспертизу в геймдеве в общем, занялся английским (с мотивацией делать это сильно проще, чем просто ради изучения), и прочитал несколько книг по истории.</p><p>Немного практиковался в жонглировании на скорость, получилось придумать, как прокачать каскад до <a href="https://youtu.be/VoyR2o0W5T8" target="_blank" rel="noopener">402 бросков в минуту</a> — не <a href="https://youtu.be/MDnMhMTekI0?t=128" target="_blank" rel="noopener">мировой рекорд</a>, но уже <a href="https://www.youtube.com/watch?v=Hd6Du2bYcRo" target="_blank" rel="noopener">быстрее всех</a> в России. Обнаружил у себя <a href="https://vas3k.club/post/1412/" target="_blank" rel="noopener">афантазию</a> (на самом деле, правильнее называть это “а-визуализацией”, с фантазией всё в порядке) — невозможность видеть образы с закрытыми глазами. Очень необычно осознать себя ощущающим мир не так, как большинство людей.</p><p><img src="/blog/2738337723/kfox.png" alt=""><br><em>Нейронные сети изображают играющих лис</em></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Сумбурная попытка собрать в кучу события в жизни за 2 года. В конце 2021 не успел, в начале 2022 уже как-то не до того было. Допишу понемногу как раз к новому году.&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="log" scheme="http://spiiin.github.io/tags/log/"/>
    
  </entry>
  
  <entry>
    <title>Уровень программирования: Senior++</title>
    <link href="http://spiiin.github.io/blog/1976052536/"/>
    <id>http://spiiin.github.io/blog/1976052536/</id>
    <published>2022-11-21T09:16:32.000Z</published>
    <updated>2022-12-21T13:26:37.211Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Предыдущая пачка:<br><a href="/blog/1048/" title="Как устроиться на работу программистом">Как устроиться на работу программистом</a><br><a href="/blog/15798/" title="Уровень программирования: Middle">Уровень программирования: Middle</a><br><a href="/blog/3652741154/" title="10 лет в геймдеве">10 лет в геймдеве</a><br><a href="/blog/258274191/" title="Уровень программирования: Senior">Уровень программирования: Senior</a></p><p>Качается всё то же, что и на предыдущем “уровне” — накопление критической массы знаний, и попытки их систематизировать.</p><p><img src="/blog/1976052536/fin.png" alt=""></p><h2 id="Миф"><a href="#Миф" class="headerlink" title="Миф"></a>Миф</h2><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/6_OUwXl8T_Y?start=981%2C" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div><p>Misha Nestor - Антропологический менеджмент и лидерство</p><p>Миф — не о поиске магии или мистике, а о совпадении ценностей и поиске смыслов.</p><img style="background-color:white;text-align:center;" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTg5IiBoZWlnaHQ9IjM0MSIgdmVyc2lvbj0iMS4xIiBiYXNlUHJvZmlsZT0iZnVsbCIgdmlld2JveD0iMCAwIDE4OSAzNDEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHhtbG5zOmV2PSJodHRwOi8vd3d3LnczLm9yZy8yMDAxL3htbC1ldmVudHMiIHN0eWxlPSJmb250LXdlaWdodDpib2xkOyBmb250LXNpemU6MTJwdDsgZm9udC1mYW1pbHk6J0NhbGlicmknLCBIZWx2ZXRpY2EsIHNhbnMtc2VyaWY7O3N0cm9rZS13aWR0aDozO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbGluZWNhcDpyb3VuZCI+PHBhdGggZD0iTTk1IDQ0LjUgTDk1IDY0LjUgTDk1IDg0LjUgTDk1IDg0LjUgIiBzdHlsZT0ic3Ryb2tlOiMzMzMyMkU7ZmlsbDpub25lO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTsiPjwvcGF0aD4KPHBhdGggZD0iTTg5LjcgNzEuMiBMOTUgNzcuOCBMMTAwLjMgNzEuMiBMOTUgODQuNSBaIiBzdHlsZT0ic3Ryb2tlOiMzMzMyMkU7ZmlsbDojMzMzMjJFO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTsiPjwvcGF0aD4KPHBhdGggZD0iTTk1IDExNS41IEw5NSAxMzUuNSBMOTUgMTU1LjUgTDk1IDE1NS41ICIgc3R5bGU9InN0cm9rZTojMzMzMjJFO2ZpbGw6bm9uZTtzdHJva2UtZGFzaGFycmF5Om5vbmU7Ij48L3BhdGg+CjxwYXRoIGQ9Ik04OS43IDE0Mi4yIEw5NSAxNDguOCBMMTAwLjMgMTQyLjIgTDk1IDE1NS41IFoiIHN0eWxlPSJzdHJva2U6IzMzMzIyRTtmaWxsOiMzMzMyMkU7c3Ryb2tlLWRhc2hhcnJheTpub25lOyI+PC9wYXRoPgo8cGF0aCBkPSJNOTUgMTg2LjUgTDk1IDIwNi41IEw5NSAyMjYuNSBMOTUgMjI2LjUgIiBzdHlsZT0ic3Ryb2tlOiMzMzMyMkU7ZmlsbDpub25lO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTsiPjwvcGF0aD4KPHBhdGggZD0iTTg5LjcgMjEzLjIgTDk1IDIxOS44IEwxMDAuMyAyMTMuMiBMOTUgMjI2LjUgWiIgc3R5bGU9InN0cm9rZTojMzMzMjJFO2ZpbGw6IzMzMzIyRTtzdHJva2UtZGFzaGFycmF5Om5vbmU7Ij48L3BhdGg+CjxwYXRoIGQ9Ik05NSAyNTcuNSBMOTUgMjc3LjUgTDk1IDI5Ny41IEw5NSAyOTcuNSAiIHN0eWxlPSJzdHJva2U6IzMzMzIyRTtmaWxsOm5vbmU7c3Ryb2tlLWRhc2hhcnJheTpub25lOyI+PC9wYXRoPgo8cGF0aCBkPSJNODkuNyAyODQuMiBMOTUgMjkwLjggTDEwMC4zIDI4NC4yIEw5NSAyOTcuNSBaIiBzdHlsZT0ic3Ryb2tlOiMzMzMyMkU7ZmlsbDojMzMzMjJFO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTsiPjwvcGF0aD4KPHJlY3QgeD0iMTMuNSIgeT0iMTMuNSIgaGVpZ2h0PSIzMSIgd2lkdGg9IjE2MyIgc3R5bGU9InN0cm9rZTojMzMzMjJFO2ZpbGw6I2VlZThkNTtzdHJva2UtZGFzaGFycmF5Om5vbmU7Ij48L3JlY3Q+Cjx0ZXh0IHg9IjIxLjUiIHk9IjM1IiBzdHlsZT0iIj7QvNC40YQg0L4g0YHQtdCx0LU8L3RleHQ+CjxyZWN0IHg9IjE1LjUiIHk9Ijg0LjUiIGhlaWdodD0iMzEiIHdpZHRoPSIxNjAiIHN0eWxlPSJzdHJva2U6IzMzMzIyRTtmaWxsOiNlZWU4ZDU7c3Ryb2tlLWRhc2hhcnJheTpub25lOyI+PC9yZWN0Pgo8dGV4dCB4PSIyMy41IiB5PSIxMDYiIHN0eWxlPSIiPtC+0LrRgNGD0LbQtdC90LjQuDwvdGV4dD4KPHJlY3QgeD0iMjMuNSIgeT0iMTU1LjUiIGhlaWdodD0iMzEiIHdpZHRoPSIxNDQiIHN0eWxlPSJzdHJva2U6IzMzMzIyRTtmaWxsOiNlZWU4ZDU7c3Ryb2tlLWRhc2hhcnJheTpub25lOyI+PC9yZWN0Pgo8dGV4dCB4PSIzMS41IiB5PSIxNzciIHN0eWxlPSIiPtC60L7QvNC/0LDQvdC40Lg8L3RleHQ+CjxyZWN0IHg9IjIzLjUiIHk9IjIyNi41IiBoZWlnaHQ9IjMxIiB3aWR0aD0iMTQ0IiBzdHlsZT0ic3Ryb2tlOiMzMzMyMkU7ZmlsbDojZWVlOGQ1O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTsiPjwvcmVjdD4KPHRleHQgeD0iMzEuNSIgeT0iMjQ4IiBzdHlsZT0iIj7QvtCx0YnQtdGB0YLQstC1PC90ZXh0Pgo8cmVjdCB4PSI1NS41IiB5PSIyOTcuNSIgaGVpZ2h0PSIzMSIgd2lkdGg9IjgwIiBzdHlsZT0ic3Ryb2tlOiMzMzMyMkU7ZmlsbDojZWVlOGQ1O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTsiPjwvcmVjdD4KPHRleHQgeD0iNjMuNSIgeT0iMzE5IiBzdHlsZT0iIj7QvNC40YDQtTwvdGV4dD48L3N2Zz4=" /><p><a href="/blog/1363625753/" title="Мотивация &quot;честного&quot; программиста">Мотивация &quot;честного&quot; программиста</a> — мои поиски профессионального личного мифа.</p><p>Основная идея — современное общество вокруг дисциплинарное, и “миф по умолчанию” для компаний — фабрика, серийное производство, в котором люди становятся похожи на механизмы. В таких условиях многим становится некомфортно, что не способствует ни творческой работе, ни выкладыванию на творческий максимум (в понятиях фабрики более ценится “средняя”, но предсказуемая работа). Один из способов работать в таких условиях — осознанное слежение за уровнем комфорта вокруг рабочих процессов.</p><p><a href="/blog/1152742413/" title="Города, которые мы выбираем">Города, которые мы выбираем</a> — миф о компании и обществе.<br>На нас сильно влияет среда вокруг — пространство и информационный фон. Люди с общей идеей собираются в определенных местах, и в таких местах возможна передача знаний и идей. Чтобы “загореться” разумом, необходимо чтобы кто-то из других людей вокруг уже горел. Ребёнок, воспитанный животными, после определенного возраста, не сможет интегрироваться в общество людей. Также и с более продвинутыми знаниями — не получив культурный импринт, невозможно рассуждать о сложных вещах, хотя возможно пытаться повторить их с помощью карго-ритуалов.</p><p>При повышении роли в компании часто отсутствует схема ритуала/инициации/личного кризиса, сопутствующего “переходу”. Из-за этого человек либо проходит это сам, либо за ним тянется “шлейф” предыдущих обязанностей/форм работы.</p><p><em>Материалы — Джесси Шелл, Кристофер Александер, Джозеф Кэмпбелл, Алан Кэй, Рич Хики, Пол Грем</em></p><h2 id="Карты-знаний"><a href="#Карты-знаний" class="headerlink" title="Карты знаний"></a>Карты знаний</h2><p>Прежде чем накапливать и систематизировать знания, можно “осмотреться”, как рассуждают о знаниях/скиллах другие.</p><p><strong>Примеры матрицы/графа/списка материалов и компетенций</strong><br><a href="https://github.com/miloyip/game-programmer" target="_blank" rel="noopener">A study path for game programmer</a> — материалы из нескольких областей для геймдев-программиста, разделены на основные и дополнительные.<br><a href="https://tlroadmap.io/guide.html" target="_blank" rel="noopener">Teamlead Roadmap</a> — роадпам тимлида. Сумма компетенций тимлида по опросам российских IT-компаний. Обязанностей где-то на 2-3 людей, упор на скиллы лида, менеджера, cto (как “директора программистов”), а не технические скиллы<br><a href="https://sijinjoseph.netlify.app/programmer-competency-matrix/" target="_blank" rel="noopener">Programmer Competency Matrix</a> — схема оценки навыков программиста. Очень странный выбор примеров знаний, но иллюстрирует экпоненциальный рост знаний с переходом на каждый новый уровень</p><p><strong>Списки книг</strong><br><a href="https://30minbooks.livejournal.com/11011.html" target="_blank" rel="noopener">Список книг от Алана Кея</a> — список рекомандаций для студентов CS. Часто, если смотреть выступления Кея, можно понять, что он рекомендует не книгу, а какую-то конкретную идею в ней.<br>Другие варианты — разобрать список интересной рекомендуемой литературы в любой серьёзной книге (одной-двух) — в качестве примеров: <strong><code>&quot;Книга линз&quot; Джесси Шелла</code></strong> и <strong><code>&quot;Архитектура Игрового движка&quot; Джейсона Грегори</code></strong>.<br><a href="/blog/3649678047/" title="Путь гейм-дизайнера">Путь гейм-дизайнера</a> — мой граф по Джесси Шеллу.</p><p><strong>Примеры вопросов на собеседованиях в геймдев-компании</strong><br><a href="https://web.archive.org/web/20191006063124/http://blog.gamedeff.com/?p=64" target="_blank" rel="noopener">Интервью глазами пострадавшего</a> — образец интервью из 2007, Midway Home Entertaiment<br><a href="Interviewing for Game Programming">Interviewing for Game Programming</a> — более свежий образец, примерно такого же уровня</p><p><strong>Варианты того, что можно и нужно изучать</strong><br>(список направлений для геймдева, навскидку)</p><ul><li>render</li><li>железо, особенности архитектуры, проц/память/видео</li><li>популярные движки unity/unreal/godot</li><li>dod/ecs</li><li>llvm/libclang и инфраструктура</li><li>multithreading/async программирование</li><li>unreal blueprints, визуальное программирование</li><li>скриптовые языки daScript/lua-jit</li><li>идеи в языках go/rust/closure/scala/nim/zig/racket</li><li>внутренности библиотек stl/boost, структуры данных</li><li>gamedev-specific математика и алгоритмы</li><li>тулзы git/серверы сборки/системы задач/cd-ci и прочее</li><li>пайплайны работы, устройство организаций, agile/lean/scrum</li><li>способы генерации арта</li><li>сеть, звук, системы анимаций, ии в играх, компрессия, форматы данных etc etc etc</li></ul><p><strong>Примеры видения сотрудников от компаний</strong><br><a href="http://media.steampowered.com/apps/valve/hbook-RU.pdf" target="_blank" rel="noopener">Valve</a>, <a href="https://www.dropbox.com/s/0z2p0qokdmm6eaw/Roblox%20Rendering%20-%20Career%20Guide%20v1.1public.pdf?dl=0" target="_blank" rel="noopener">Roblox</a>, <a href="https://www.gameenginebook.com/resources/SINFO.pdf" target="_blank" rel="noopener">Naughty Dog</a>, <a href="https://aras-p.info/texts/files/201410-TUM-HobbyEngineToGameEngine.pdf" target="_blank" rel="noopener">Unity</a>, разделение программистов в <a href="https://youtu.be/9nB_8LDaEVE?t=705" target="_blank" rel="noopener">IO Inreractive/Square Enix</a> от Bobby Anguelov.</p><p>Можно использовать для обнаружения пробелов в знаниях для того, чтобы их заполнять в свободное время, карьерного планирования, а также для обнаружения интересных “зацепок” в культуре других компаний.</p><h2 id="Как-и-зачем-заниматься-самообразованием"><a href="#Как-и-зачем-заниматься-самообразованием" class="headerlink" title="Как и зачем заниматься самообразованием"></a>Как и зачем заниматься самообразованием</h2><p><a href="/blog/37481721/" title="О книгах и самообразовании">О книгах и самообразовании</a> - про свой способ чтения книг, а также развернуто зачем заниматься самообразованием.</p><p>Соберу и дополню список возможных ответов “зачем”:</p><ul><li>несмотря на то, что на работе знания могут не понадобится сейчас или в ближайшем будущем, они попадут в список скиллов (“тебя не будут просить делать то, что ты умеешь плохо”)</li><li>над тобой всегда есть несколько уровней развития, которых ты не видишь с текущего (парадокс блаба)</li><li>шанс найти инсайты в соседних областях, которые не изучены в твоей области (либо получить синергию знаний от двух направлений)</li><li>возможность оценить компетенции коллег и руководства (или кандидатов при подборе команды), а также улучшить возможности профессионального взаимодействия</li><li>возможность делать новые для себя или более крутые вещи, которые не умел делать раньше</li><li>знание и понимание rocket-science решений</li><li>обнаружение готовых решений, умение их оценить, видеть весь спектр возможных решений (антибиблиотека Умберто Эко)</li><li>возможность учиться идеям у лучших (“поджечь свой факел разума от уже горящих”)</li><li>обойти грабли, на которые уже наступили десятки людей, понимание открытых проблем</li><li>обновление знаний и подходов (иначе когда случится очередная <a href="/blog/2786387393/" title="вомгла">вомгла</a>, работу сложно будет найти)</li><li>систематизация, даже неуклюжая, неплохо прокачивает понимание</li><li>шанс понять свои сильные и слабые стороны (а также, возможно, <a href="/blog/4256110900/" title="&quot;эволюционировать&quot;">&quot;эволюционировать&quot;</a> в другую геймдев-профессию)</li></ul><p><strong><code>&quot;Как заниматься&quot;</code></strong>.</p><p>“Традиционный путь в программисты” — это прочитать пару книг по языку и перейти от теории к практике (попутно нафаршировав голову в универе всяким computer scienсe, engeneering, math или еще чем-нибудь). Дальше обычно с некоторой периодичностью изучаются мануалы или best practices, но чаще всего ведущим способом изучения является практика. В такой схеме сильно страдают еще два способа набора знаний:</p><p><strong>Наблюдение</strong><br> Что делают другие и с какими целями:</p><ul><li>изучение докладов с профильных конференций</li><li>профессиональное общение</li><li>изучение open-source кода</li><li>использование различных middleware-инструментов</li><li>играть в игры конкурентов<br>Примеры задачек на наблюдение:</li><li>найти 10 субъективно наиболее интересных библиотек из boost (abseil/folly/eastl или еще какой-нибудь base library) и разобраться, с какой целью они сделаны и как устроены</li><li>найти 10 устаревших <a href="https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms" target="_blank" rel="noopener">идиом</a> C++ и посмотреть, почему они устарели, и что предлагает язык сейчас</li><li>изучить <a href="/blog/2826376146/" title="примитивы">примитивы</a> асинхронного программирования в 5-10 языках программирования (варианты — реализации хеш-таблиц/сборщиков мусора/конкретные оптимизации компилятора)</li><li>выбрать какую-нибудь популярную open-source библиотеку (например, <a href="https://github.com/bkaradzic/bgfx#who-is-using-it-madewithbgfx" target="_blank" rel="noopener">bgfx</a>) и пройтись по 5-10 примерам сделанным с её помощью проектам, изучить их фичи, а также изучить все 3rdParty библиотеки, которые используют эти проекты (или пройтись по уже собранным коллекциям, <a href="https://github.com/floooh/bookmarks" target="_blank" rel="noopener">пример</a>)</li><li>выбрать какую-нибудь фичу популярного движка, которую можно отделить, и попробовать реализовать её самому from scratch быстрее/удобнее/лучше чем то, что уже существует (например, реализация <a href="https://github.com/BobbyAnguelov/Esoterica" target="_blank" rel="noopener">системы анимаций</a> “как в трипл-эй движках” от Bobby Anguelov)<br><em>тут у него скорее наблюдение + тинкеринг + мышление</em></li><li>попробовать откопать максимум информации про устройство какой-нибудь фичи, которая понравилась в игре (к примеру, кастомизация персонажей в Sims)</li></ul><p><strong>Мышление</strong></p><ul><li>систематизация</li><li>придумывание</li><li>выводы</li><li>улучшение лучших решений</li></ul><p>Кажется, именно из-за пробелов в этих направлениях и возникает необходимость периодического заныривания в тонны материалов (в дальнейшем, систематизация позволяет значительно сократить время, просеивая эти объёмы). Так что, логично было бы более равномерно заниматься каждым из 4х способов прокачки:</p><p><img src="/blog/1976052536/scheme.png" alt=""></p><p><em>тинкеринг — то же, что и практика, свободные эксперименты с кодом</em></p><h2 id="Общение"><a href="#Общение" class="headerlink" title="Общение"></a>Общение</h2><p>От управления командой развитие общения идёт по пути расширения круга профессиональных знакомств, чтобы начинала работать “магия нетворкинга”, что в теории, иногда позволяет эффективно решать задачи типа таких:</p><ul><li>Нужен классный профильный специалист, разобраться с пачкой проблем, которые мы толком не понимаем как решить - затюнить андроид-порт движка, или выловить пачку мутных крешей где-то на границе мутных 3rdParty сдк и NDK (андроидщики в геймдеве, впрочем, кажется, всем нужны)<br>Или возможно, и в обратную сторону:</li><li>Фанатею от игр компании XXX и горю желанием там работать (или же “мечтаю сделать более крутую версию игры YYY, ищу единомышленников”)</li></ul><p>Примеры способов заявлять о себе</p><ul><li>совместная работа в прошлом</li><li>тематические онлайн или оффлайн тусовки (как участие, так и организация)</li><li>случайные знакомства (хех, в “правильных” городах шанс такого больше)</li><li>курсы/стажировки/лекции/конкурсы как платформа для общения и знакомств</li><li>медиа - подкасты, блоги</li></ul><p>Нетворкинг и взаимодействие с людьми разных скиллов также позволяет оценить важность diversity — группа людей с разным бекграундом и навыками может эффективнее решать сложные задачи.</p><p>Также, с какого-то момента приходит понимание, какие типы людей не могут нормально работать в командах — <a href="/blog/2316905704/" title="Про увольнения">Про увольнения</a><br></p><p>Отдельная, скорее субкультурная, тема — выстраивание “моста между поколениями”, изучение истории игр, а также эволюции компаний и методов разработки (<a href="https://app2top.ru/industry/10-knig-ob-istorii-igrovoj-industrii-126776.html" target="_blank" rel="noopener">пример подборки</a>). Не могу утверждать о конкретной пользе, но, кажется, это имеет и элементы медиа, и элементы объединяющего индустрию мифа.</p><p>Еще один способ взаимодействовать с командой — пропускать всё общение и код коллег через призму, “а возможно ли было бы переиспользовать решение в других местах/хотел бы я работать с этим человеком, если бы было нужно начинать новый проект и было необходимо собрать команду из тех, кто есть сейчас”.</p><p>Развитие себя при работе в команде — не личная, а общекомандная задача, можно вырасти выше команды на одну голову, но невозможно на три. Необходимо или тянуть команду вверх, или менять, или работать отдельно от группы.</p><h2 id="Жизненный-план"><a href="#Жизненный-план" class="headerlink" title="Жизненный план"></a>Жизненный план</h2><p>Обозначить цели и сроки, что хочется сделать и когда. Точно стоит обратить внимание на то, чтобы не терять здоровье и близких людей, а также на изучение языков. Полезно (и невероятно сложно!) попробовать обозначить собственные личные/профессиональные недостатки, и попробовать исправить один из них — хороший повод задуматься о себе.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;Предыдущая
      
    
    </summary>
    
    
    
      <category term="dev_evolution" scheme="http://spiiin.github.io/tags/dev-evolution/"/>
    
  </entry>
  
  <entry>
    <title>daScript. Brainfuck и оптимизации</title>
    <link href="http://spiiin.github.io/blog/621874082/"/>
    <id>http://spiiin.github.io/blog/621874082/</id>
    <published>2022-11-11T13:42:54.000Z</published>
    <updated>2022-11-11T19:59:01.184Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Попробовал портировать с <code>nim</code> на <code>daScript</code> <a href="https://howistart.org/posts/nim/1/" target="_blank" rel="noopener">интерпретатор</a> <code>brainfuck</code> кода. Брейфак предельно простой язык, и базовая реализация интерпретатора занимает полчаса, но на нём можно потренироваться в ускорении кода и продемонстрировать возможности daScript в оптимизации.</p><a id="more"></a><p>Самая первая, максимально наивная, построчно скопированная реализация:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">require strings</span><br><span class="line">require fio</span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">run</span><span class="params">(code: <span class="built_in">string</span>; var tape: <span class="built_in">array</span>&lt;uint8&gt;; var codePos, tapePos: <span class="keyword">int</span>&amp;; skip: <span class="keyword">bool</span>)</span>: <span class="keyword">bool</span></span></span><br><span class="line"><span class="function"><span class="keyword">while</span> tapePos &gt;</span>= <span class="number">0</span> &amp;&amp; codePos &lt; length(code)</span><br><span class="line"><span class="keyword">if</span> tapePos &gt;= length(tape) &#123; tape |&gt; push(uint8(<span class="number">0</span>)); &#125;</span><br><span class="line"></span><br><span class="line">let sym1  = code |&gt; character_at(codePos)</span><br><span class="line"><span class="keyword">if</span> sym1 == <span class="string">'['</span></span><br><span class="line">++codePos</span><br><span class="line">let oldPos = codePos</span><br><span class="line"><span class="keyword">while</span> run(code, tape, codePos, tapePos, tape[tapePos] == uint8(<span class="number">0</span>))</span><br><span class="line">codePos = oldPos</span><br><span class="line">elif sym1 == <span class="string">']'</span></span><br><span class="line"><span class="keyword">return</span> tape[tapePos] != uint8(<span class="number">0</span>)</span><br><span class="line">elif !skip</span><br><span class="line">let sym  = code |&gt; character_at(codePos)</span><br><span class="line"><span class="keyword">if</span> sym == <span class="string">'+'</span> &#123; tape[tapePos] = uint8(<span class="keyword">int</span>(tape[tapePos]) + <span class="number">1</span>); &#125;</span><br><span class="line">elif sym == <span class="string">'-'</span> &#123; tape[tapePos] = uint8(<span class="keyword">int</span>(tape[tapePos]) - <span class="number">1</span>); &#125;</span><br><span class="line">elif sym == <span class="string">'&gt;'</span> &#123; ++tapePos; &#125;</span><br><span class="line">elif sym == <span class="string">'&lt;'</span> &#123; --tapePos; &#125;</span><br><span class="line">elif sym == <span class="string">'.'</span> &#123; print(<span class="string">"&#123;int(tape[tapePos]) |&gt; to_char&#125;"</span>); &#125;</span><br><span class="line">elif sym == <span class="string">','</span> &#123; tape[tapePos] = uint8(getchar()); &#125;</span><br><span class="line"><span class="keyword">else</span> &#123; &#125;</span><br><span class="line">++codePos</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">def interpret(code: <span class="built_in">string</span>)</span><br><span class="line">let totalTime = ref_time_ticks()</span><br><span class="line">var tape: <span class="built_in">array</span>&lt;uint8&gt;</span><br><span class="line">var codePos, tapePos : <span class="keyword">int</span></span><br><span class="line">run(code, tape, codePos, tapePos, <span class="literal">false</span>)</span><br><span class="line">let totalDt = <span class="keyword">double</span>(get_time_usec(totalTime)) /<span class="number">1000000.0l</span>f</span><br><span class="line">to_log(LOG_INFO, <span class="string">"total &#123;totalDt&#125; sec\n"</span>)</span><br></pre></td></tr></table></figure><p>Если попытаться протестировать его на генераторе <a href="https://github.com/def-/nim-brainfuck/blob/master/examples/mandelbrot.b" target="_blank" rel="noopener">множества Мандельброта</a>, можно заметить серьёзные проблемы со скоростью, вычисления занимают около 5 часов. Стоит попробовать его разогнать!</p><h2 id="Отключение-проверок-границ-и-указателей"><a href="#Отключение-проверок-границ-и-указателей" class="headerlink" title="Отключение проверок границ и указателей"></a>Отключение проверок границ и указателей</h2><p>Код на brainfuck - это простая числодробилка, ускорить которую можно, отключив все дополнительные проверки обращений к памяти.</p><p><em>Как отключать проверки, мне рассказал <a href="https://github.com/borisbat" target="_blank" rel="noopener">Борис Баткин</a> (так как интерпретатор nim делал один основных контрибьютеров языка, то его подсказки не отменяют честности сравнения — авторы находятся в одной “весовой категории” знания своего языка).</em></p><p>В первую очередь, можно заменить функцию <code>charcter_at</code>, которая <a href="https://github.com/GaijinEntertainment/daScript/blob/e9f4c486848a8985e4126e0fc2d04afbc6abd883/src/builtin/module_builtin_string.cpp#L26" target="_blank" rel="noopener">проверяет</a>,что индекс меньше длины строки, на <code>character_uat</code>, которая не делает этой проверки.</p><p>Также отключается проверка ссылок на null макросом <code>[unsafe_deref]</code>.</p><p>Наконец, обращение к массиву можно выполнять не через разыменование ссылки, а через обращение по указателю:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">tape: <span class="built_in">array</span>&lt;uint8&gt;</span><br><span class="line">tape[index] <span class="comment">// tape[check_range(index)] //медленно</span></span><br><span class="line"></span><br><span class="line">var ptape: uint8? = addr(tape[<span class="number">0</span>])</span><br><span class="line">ptape[index] <span class="comment">//check_not_null(ptape)[index] //быстрее, обращение без проверок</span></span><br><span class="line"></span><br><span class="line">[unsafe_deref]</span><br><span class="line">ptape[index] <span class="comment">//ptape[index] //еще быстрее, обращение без перепроверок указателя на nullptr</span></span><br></pre></td></tr></table></figure><p>Переписанная версия кода:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[unsafe_deref]</span><br><span class="line"><span class="function">def <span class="title">run</span><span class="params">(code: uint8?; lengthOfCode:<span class="keyword">int</span>; var tape: uint8?; var codePos, tapePos: <span class="keyword">int</span>&amp;; skip: <span class="keyword">bool</span>)</span>: <span class="keyword">bool</span></span></span><br><span class="line"><span class="function">unsafe</span></span><br><span class="line"><span class="function"><span class="keyword">while</span> tapePos &gt;</span>= <span class="number">0</span> &amp;&amp; codePos &lt; lengthOfCode</span><br><span class="line">let sym1  = <span class="keyword">int</span>(code[codePos])</span><br><span class="line"><span class="keyword">if</span> sym1 == <span class="string">'['</span></span><br><span class="line">++codePos</span><br><span class="line">let oldPos = codePos</span><br><span class="line"><span class="keyword">while</span> run(code, lengthOfCode, tape, codePos, tapePos, tape[tapePos] == uint8(<span class="number">0</span>))</span><br><span class="line">codePos = oldPos</span><br><span class="line">elif sym1 == <span class="string">']'</span></span><br><span class="line"><span class="keyword">return</span> tape[tapePos] != uint8(<span class="number">0</span>)</span><br><span class="line">elif !skip</span><br><span class="line">let sym  = <span class="keyword">int</span>(code[codePos])</span><br><span class="line"><span class="keyword">if</span> sym == <span class="string">'+'</span> &#123; tape[tapePos] = uint8(<span class="keyword">int</span>(tape[tapePos]) + <span class="number">1</span>); &#125;</span><br><span class="line">elif sym == <span class="string">'-'</span> &#123; tape[tapePos] = uint8(<span class="keyword">int</span>(tape[tapePos]) - <span class="number">1</span>); &#125;</span><br><span class="line">elif sym == <span class="string">'&gt;'</span> &#123; ++tapePos; &#125;</span><br><span class="line">elif sym == <span class="string">'&lt;'</span> &#123; --tapePos; &#125;</span><br><span class="line">elif sym == <span class="string">'.'</span> &#123; print(<span class="keyword">int</span>(tape[tapePos]) |&gt; to_char); &#125;</span><br><span class="line">elif sym == <span class="string">','</span> &#123; tape[tapePos] = uint8(getchar()); &#125;</span><br><span class="line"><span class="keyword">else</span> &#123; &#125;</span><br><span class="line">++codePos</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">def interpret(code: <span class="built_in">string</span>)</span><br><span class="line">let totalTime = ref_time_ticks()</span><br><span class="line">var tape: <span class="built_in">array</span>&lt;uint8&gt;</span><br><span class="line">var codePos, tapePos : <span class="keyword">int</span></span><br><span class="line">tape |&gt; resize(<span class="number">1000000</span>)</span><br><span class="line">unsafe</span><br><span class="line">run(reinterpret&lt;uint8?&gt; code, length(code), addr(tape[<span class="number">0</span>]), codePos, tapePos, <span class="literal">false</span>)</span><br><span class="line">let totalDt = <span class="keyword">double</span>(get_time_usec(totalTime)) /<span class="number">1000000.0l</span>f</span><br><span class="line">to_log(LOG_INFO, <span class="string">"total &#123;totalDt&#125; sec\n"</span>)</span><br></pre></td></tr></table></figure><p>Такая версия интерпретатора всё ещё тормозная, но уже позволяет дождаться завершения выполнения кода:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">e:\src\daScript\bin\Release&gt;daScript.exe brainfuck_00.das</span><br><span class="line">AAAAAAAAAAAAAAAABBBBBBBBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDEGFFEEEEDDDDDDCCCCCCCCCBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB</span><br><span class="line">AAAAAAAAAAAAAAABBBBBBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDEEEFGIIGFFEEEDDDDDDDDCCCCCCCCCBBBBBBBBBBBBBBBBBBBBBBBBBB</span><br><span class="line">AAAAAAAAAAAAABBBBBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDEEEEFFFI KHGGGHGEDDDDDDDDDCCCCCCCCCBBBBBBBBBBBBBBBBBBBBBBB</span><br><span class="line">AAAAAAAAAAAABBBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDEEEEEFFGHIMTKLZOGFEEDDDDDDDDDCCCCCCCCCBBBBBBBBBBBBBBBBBBBBB</span><br><span class="line">AAAAAAAAAAABBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDEEEEEEFGGHHIKPPKIHGFFEEEDDDDDDDDDCCCCCCCCCCBBBBBBBBBBBBBBBBBB</span><br><span class="line">AAAAAAAAAABBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDEEEEEEFFGHIJKS  X KHHGFEEEEEDDDDDDDDDCCCCCCCCCCBBBBBBBBBBBBBBBB</span><br><span class="line">AAAAAAAAABBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDEEEEEEFFGQPUVOTY   ZQL[MHFEEEEEEEDDDDDDDCCCCCCCCCCCBBBBBBBBBBBBBB</span><br><span class="line">AAAAAAAABBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDEEEEEFFFFFGGHJLZ         UKHGFFEEEEEEEEDDDDDCCCCCCCCCCCCBBBBBBBBBBBB</span><br><span class="line">AAAAAAABBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDEEEEFFFFFFGGGGHIKP           KHHGGFFFFEEEEEEDDDDDCCCCCCCCCCCBBBBBBBBBBB</span><br><span class="line">AAAAAAABBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDEEEEEFGGHIIHHHHHIIIJKMR        VMKJIHHHGFFFFFFGSGEDDDDCCCCCCCCCCCCBBBBBBBBB</span><br><span class="line">AAAAAABBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDEEEEEEFFGHK   MKJIJO  N R  X      YUSR PLV LHHHGGHIOJGFEDDDCCCCCCCCCCCCBBBBBBBB</span><br><span class="line">AAAAABBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDEEEEEEEEEFFFFGH O    TN S                       NKJKR LLQMNHEEDDDCCCCCCCCCCCCBBBBBBB</span><br><span class="line">AAAAABBCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDEEEEEEEEEEEEFFFFFGHHIN                                 Q     UMWGEEEDDDCCCCCCCCCCCCBBBBBB</span><br><span class="line">AAAABBCCCCCCCCCCCCCCCCCCCCCCCCCDDDDEEEEEEEEEEEEEEEFFFFFFGHIJKLOT                                     [JGFFEEEDDCCCCCCCCCCCCCBBBBB</span><br><span class="line">AAAABCCCCCCCCCCCCCCCCCCCCCCDDDDEEEEEEEEEEEEEEEEFFFFFFGGHYV RQU                                     QMJHGGFEEEDDDCCCCCCCCCCCCCBBBB</span><br><span class="line">AAABCCCCCCCCCCCCCCCCCDDDDDDDEEFJIHFFFFFFFFFFFFFFGGGGGGHIJN                                            JHHGFEEDDDDCCCCCCCCCCCCCBBB</span><br><span class="line">AAABCCCCCCCCCCCDDDDDDDDDDEEEEFFHLKHHGGGGHHMJHGGGGGGHHHIKRR                                           UQ L HFEDDDDCCCCCCCCCCCCCCBB</span><br><span class="line">AABCCCCCCCCDDDDDDDDDDDEEEEEEFFFHKQMRKNJIJLVS JJKIIIIIIJLR                                               YNHFEDDDDDCCCCCCCCCCCCCBB</span><br><span class="line">AABCCCCCDDDDDDDDDDDDEEEEEEEFFGGHIJKOU  O O   PR LLJJJKL                                                OIHFFEDDDDDCCCCCCCCCCCCCCB</span><br><span class="line">AACCCDDDDDDDDDDDDDEEEEEEEEEFGGGHIJMR              RMLMN                                                 NTFEEDDDDDDCCCCCCCCCCCCCB</span><br><span class="line">AACCDDDDDDDDDDDDEEEEEEEEEFGGGHHKONSZ                QPR                                                NJGFEEDDDDDDCCCCCCCCCCCCCC</span><br><span class="line">ABCDDDDDDDDDDDEEEEEFFFFFGIPJIIJKMQ                   VX                                                 HFFEEDDDDDDCCCCCCCCCCCCCC</span><br><span class="line">ACDDDDDDDDDDEFFFFFFFGGGGHIKZOOPPS                                                                      HGFEEEDDDDDDCCCCCCCCCCCCCC</span><br><span class="line">ADEEEEFFFGHIGGGGGGHHHHIJJLNY                                                                        TJHGFFEEEDDDDDDDCCCCCCCCCCCCC</span><br><span class="line">A                                                                                                 PLJHGGFFEEEDDDDDDDCCCCCCCCCCCCC</span><br><span class="line">ADEEEEFFFGHIGGGGGGHHHHIJJLNY                                                                        TJHGFFEEEDDDDDDDCCCCCCCCCCCCC</span><br><span class="line">ACDDDDDDDDDDEFFFFFFFGGGGHIKZOOPPS                                                                      HGFEEEDDDDDDCCCCCCCCCCCCCC</span><br><span class="line">ABCDDDDDDDDDDDEEEEEFFFFFGIPJIIJKMQ                   VX                                                 HFFEEDDDDDDCCCCCCCCCCCCCC</span><br><span class="line">AACCDDDDDDDDDDDDEEEEEEEEEFGGGHHKONSZ                QPR                                                NJGFEEDDDDDDCCCCCCCCCCCCCC</span><br><span class="line">AACCCDDDDDDDDDDDDDEEEEEEEEEFGGGHIJMR              RMLMN                                                 NTFEEDDDDDDCCCCCCCCCCCCCB</span><br><span class="line">AABCCCCCDDDDDDDDDDDDEEEEEEEFFGGHIJKOU  O O   PR LLJJJKL                                                OIHFFEDDDDDCCCCCCCCCCCCCCB</span><br><span class="line">AABCCCCCCCCDDDDDDDDDDDEEEEEEFFFHKQMRKNJIJLVS JJKIIIIIIJLR                                               YNHFEDDDDDCCCCCCCCCCCCCBB</span><br><span class="line">AAABCCCCCCCCCCCDDDDDDDDDDEEEEFFHLKHHGGGGHHMJHGGGGGGHHHIKRR                                           UQ L HFEDDDDCCCCCCCCCCCCCCBB</span><br><span class="line">AAABCCCCCCCCCCCCCCCCCDDDDDDDEEFJIHFFFFFFFFFFFFFFGGGGGGHIJN                                            JHHGFEEDDDDCCCCCCCCCCCCCBBB</span><br><span class="line">AAAABCCCCCCCCCCCCCCCCCCCCCCDDDDEEEEEEEEEEEEEEEEFFFFFFGGHYV RQU                                     QMJHGGFEEEDDDCCCCCCCCCCCCCBBBB</span><br><span class="line">AAAABBCCCCCCCCCCCCCCCCCCCCCCCCCDDDDEEEEEEEEEEEEEEEFFFFFFGHIJKLOT                                     [JGFFEEEDDCCCCCCCCCCCCCBBBBB</span><br><span class="line">AAAAABBCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDEEEEEEEEEEEEFFFFFGHHIN                                 Q     UMWGEEEDDDCCCCCCCCCCCCBBBBBB</span><br><span class="line">AAAAABBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDEEEEEEEEEFFFFGH O    TN S                       NKJKR LLQMNHEEDDDCCCCCCCCCCCCBBBBBBB</span><br><span class="line">AAAAAABBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDEEEEEEFFGHK   MKJIJO  N R  X      YUSR PLV LHHHGGHIOJGFEDDDCCCCCCCCCCCCBBBBBBBB</span><br><span class="line">AAAAAAABBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDEEEEEFGGHIIHHHHHIIIJKMR        VMKJIHHHGFFFFFFGSGEDDDDCCCCCCCCCCCCBBBBBBBBB</span><br><span class="line">AAAAAAABBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDEEEEFFFFFFGGGGHIKP           KHHGGFFFFEEEEEEDDDDDCCCCCCCCCCCBBBBBBBBBBB</span><br><span class="line">AAAAAAAABBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDEEEEEFFFFFGGHJLZ         UKHGFFEEEEEEEEDDDDDCCCCCCCCCCCCBBBBBBBBBBBB</span><br><span class="line">AAAAAAAAABBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDEEEEEEFFGQPUVOTY   ZQL[MHFEEEEEEEDDDDDDDCCCCCCCCCCCBBBBBBBBBBBBBB</span><br><span class="line">AAAAAAAAAABBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDEEEEEEFFGHIJKS  X KHHGFEEEEEDDDDDDDDDCCCCCCCCCCBBBBBBBBBBBBBBBB</span><br><span class="line">AAAAAAAAAAABBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDEEEEEEFGGHHIKPPKIHGFFEEEDDDDDDDDDCCCCCCCCCCBBBBBBBBBBBBBBBBBB</span><br><span class="line">AAAAAAAAAAAABBBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDEEEEEFFGHIMTKLZOGFEEDDDDDDDDDCCCCCCCCCBBBBBBBBBBBBBBBBBBBBB</span><br><span class="line">AAAAAAAAAAAAABBBBBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDEEEEFFFI KHGGGHGEDDDDDDDDDCCCCCCCCCBBBBBBBBBBBBBBBBBBBBBBB</span><br><span class="line">AAAAAAAAAAAAAAABBBBBBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDEEEFGIIGFFEEEDDDDDDDDCCCCCCCCCBBBBBBBBBBBBBBBBBBBBBBBBBB</span><br><span class="line">[I] total 564.99929999999994834 sec</span><br></pre></td></tr></table></figure><p>564 секунды — в 30 раз быстрее первой версии, но всё ещё сильно медленнее интерпретатора на <code>nim</code>, который в релизной версии выполняется за 40 секунд.</p><h2 id="Ahead-of-Time"><a href="#Ahead-of-Time" class="headerlink" title="Ahead-of-Time"></a>Ahead-of-Time</h2><p>daScript умеет транспилироваться в C++ код, для сравнения с nim попробуем скомпилировать интерпретатор, без внесения каких-либо изменений в код.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">daScript.exe -aot brainfuck.das brainfuck.das.cpp</span><br></pre></td></tr></table></figure><p>Полученный C++-файл проще всего подсунуть в пример <a href="https://github.com/GaijinEntertainment/daScript/blob/master/examples/tutorial/tutorial02aot.cpp" target="_blank" rel="noopener">tutorial02aot</a>, который настроен на использование AoT варианта кода. Скомпилированный файл можно запустить:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">e:\src\daScript\bin\Release&gt;tutorial02aot.exe</span><br><span class="line">[I] total <span class="number">34.27342399999999856</span> sec</span><br></pre></td></tr></table></figure><p>34 секунды — уже быстрее, чем nim, который сам по себе достаточно быстрый!</p><h2 id="Just-in-Time"><a href="#Just-in-Time" class="headerlink" title="Just-in-Time"></a>Just-in-Time</h2><p>Можно попробовать двигаться дальше, подключив экспериментальный модуль <a href="https://github.com/borisbat/dasLLVM" target="_blank" rel="noopener">dasLLVM</a>. Чтобы собрать его, необходимо:</p><ul><li>включить сборку модуля в cmake:</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">option(DAS_LLVM_DISABLED &quot;Disable dasLLVM (llvm bindings)&quot; OFF)</span><br></pre></td></tr></table></figure><ul><li>собрать проект llvm, или скачать собранный (например, от <a href="https://download.qt.io/development_releases/prebuilt/libclang/" target="_blank" rel="noopener">qt</a>) и положить на уровень выше корневой директории проекта daScript, напрммер:</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:&#x2F;dascript</span><br><span class="line">C:&#x2F;libclang</span><br></pre></td></tr></table></figure><ul><li>сгенерировать решение и пересобрать dascript:</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">generate_msvc_2019.bat</span><br></pre></td></tr></table></figure><p>Теперь можно воспользоваться аннотацией <code>[jit]</code>, чтобы код функциии интерпретатора без AoT-компиляции перед первым выполнением компилировался с помощью <code>llvm-c</code>.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[jit,unsafe_deref]</span><br><span class="line"><span class="function">def <span class="title">run</span><span class="params">(code: uint8?; lengthOfCode:<span class="keyword">int</span>; var tape: uint8?; var codePos, tapePos: <span class="keyword">int</span>&amp;; skip: <span class="keyword">bool</span>)</span>: <span class="keyword">bool</span></span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">e:\src\daScript_my\bin\Release&gt;daScript.exe brainfuck_2_jit.das</span><br><span class="line">[I] total 22.66654300000000077 sec</span><br></pre></td></tr></table></figure><p>22.6 секунды, еще лучше! Генерация daScript-кода в llvm-ассемблер быстрее, чем в C++ — генератор передаёт больше полезной для оптимизации о кода, а также, возможно, задействуется сила оптимизаций LLVM.</p><h2 id="Метапрограммирование"><a href="#Метапрограммирование" class="headerlink" title="Метапрограммирование"></a>Метапрограммирование</h2><p>Можно двигаться дальше. Вместо того, чтобы писать функцию, которая интерпретирует любой код на brainfuck, можно написать макрос, который сгенерирует код конкретной функции в compile-time, и измерить время выполнения этой функции.</p><p>Можно использовать <a href="https://dascript.org/doc/reference/language/macros.html#astreadermacro" target="_blank" rel="noopener">AstReaderMacro</a> — тип макроса, который обрабатывает отдельные символы. Синтаксис вызова такого макроса:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">% READER_MACRO_NAME ~ character_sequence %% &#x2F;&#x2F;character_sequence будет передана на вход макросу</span><br></pre></td></tr></table></figure><p>Шаблоны таких макросов можно посмотреть в модулях <code>json_boost</code> и <code>regex_boost</code></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> brainfuck_macro shared <span class="keyword">public</span></span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">generateFunction</span><span class="params">(uniqueName, code)</span></span></span><br><span class="line"><span class="function">    let seqStr </span>= <span class="built_in">string</span>(code)</span><br><span class="line"></span><br><span class="line">    var blkArr : <span class="built_in">array</span>&lt;<span class="built_in">array</span>&lt;ExpressionPtr&gt;&gt;; defer_delete(blkArr)</span><br><span class="line"></span><br><span class="line">    var blk : <span class="built_in">array</span>&lt;ExpressionPtr&gt;; defer_delete(blk)</span><br><span class="line">    blkArr |&gt; emplace(blk)</span><br><span class="line"></span><br><span class="line">    blkArr[<span class="number">0</span>] |&gt; emplace_new &lt;| qmacro_expr( $&#123; var tape: <span class="built_in">array</span>&lt;uint8&gt;; &#125;)</span><br><span class="line">    blkArr[<span class="number">0</span>] |&gt; emplace_new &lt;| qmacro_expr( $&#123; var tapePos : <span class="keyword">int</span>; &#125;)</span><br><span class="line">    blkArr[<span class="number">0</span>] |&gt; emplace_new &lt;| qmacro_expr( $&#123; tape |&gt; resize(<span class="number">1000000</span>); &#125;)</span><br><span class="line">    blkArr[<span class="number">0</span>] |&gt; emplace_new &lt;| qmacro_expr( $&#123; var ptape = addr(tape[<span class="number">0</span>]); &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> sym in seqStr</span><br><span class="line">        <span class="keyword">if</span> sym == <span class="string">'+'</span>   &#123; back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( $&#123; ptape[tapePos] = uint8(<span class="keyword">int</span>(ptape[tapePos]) + <span class="number">1</span>); &#125;); &#125;</span><br><span class="line">        elif sym == <span class="string">'-'</span> &#123; back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( $&#123; ptape[tapePos] = uint8(<span class="keyword">int</span>(ptape[tapePos]) - <span class="number">1</span>); &#125;); &#125;</span><br><span class="line">        elif sym == <span class="string">'&gt;'</span> &#123; back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( $&#123; ++tapePos; &#125;); &#125; </span><br><span class="line">        elif sym == <span class="string">'&lt;'</span> &#123; back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( $&#123; --tapePos; &#125;); &#125;</span><br><span class="line">        elif sym == <span class="string">'.'</span> &#123; back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( $&#123; print(<span class="keyword">int</span>(ptape[tapePos]) |&gt; to_char); &#125;); &#125;</span><br><span class="line">        elif sym == <span class="string">','</span> &#123; back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( $&#123; ptape[tapePos] = uint8(getchar()); &#125;); &#125;</span><br><span class="line">        elif sym == <span class="string">'['</span></span><br><span class="line">            var blk1 : <span class="built_in">array</span>&lt;ExpressionPtr&gt;; defer_delete(blk1)</span><br><span class="line">            blkArr |&gt; emplace(blk1)</span><br><span class="line">        elif sym == <span class="string">']'</span></span><br><span class="line">            var last &lt;- back(blkArr)</span><br><span class="line">            blkArr |&gt; pop()</span><br><span class="line">            var whileExpr &lt;- qmacro_expr &lt;|</span><br><span class="line">                <span class="keyword">while</span> ptape[tapePos] != uint8(<span class="number">0</span>)</span><br><span class="line">                    $b(last)</span><br><span class="line">            back(blkArr) |&gt; emplace_new &lt;| whileExpr</span><br><span class="line">        <span class="keyword">else</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    var fnArguments : <span class="built_in">array</span>&lt;VariablePtr&gt;;</span><br><span class="line">    var fn &lt;- qmacro_function(uniqueName) &lt;| $ ($a(fnArguments))</span><br><span class="line">        unsafe</span><br><span class="line">            $b(blkArr[<span class="number">0</span>])</span><br><span class="line">    defer_delete(fn)</span><br><span class="line"></span><br><span class="line">    var args:<span class="built_in">array</span>&lt; tuple&lt;argname:<span class="built_in">string</span>;argvalue:RttiValue&gt; &gt;</span><br><span class="line">    fn |&gt; append_annotation(<span class="string">"$"</span>, <span class="string">"unsafe_deref"</span>, args)</span><br><span class="line">    <span class="comment">//print(describe(fn))</span></span><br><span class="line">    compiling_module() |&gt; add_function(fn)</span><br><span class="line"></span><br><span class="line">[reader_macro(name=<span class="string">"bf"</span>)]</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">private</span> <span class="title">BrainfuckReader</span> :</span> AstReaderMacro</span><br><span class="line">    <span class="function">def <span class="keyword">override</span> <span class="title">accept</span><span class="params">( prog:ProgramPtr; mod:Module?; var expr:ExprReader?; ch:<span class="keyword">int</span>; info:LineInfo)</span> : <span class="keyword">bool</span></span></span><br><span class="line"><span class="function">        <span class="title">append</span><span class="params">(expr.sequence, ch)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">if</span> <span class="title">ends_with</span><span class="params">(expr.sequence,<span class="string">"%%"</span>)</span></span></span><br><span class="line"><span class="function">            let len </span>= length(expr.sequence)</span><br><span class="line">            resize(expr.sequence,len<span class="number">-2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    def <span class="keyword">override</span> visit( prog:ProgramPtr; mod:Module?; expr:smart_ptr&lt;ExprReader&gt;) : ExpressionPtr</span><br><span class="line">        let str &lt;- make_unique_private_name(<span class="string">"bf`exec"</span>, expr.at)</span><br><span class="line">        generateFunction(str, expr.sequence)</span><br><span class="line"></span><br><span class="line">        var ftype &lt;- <span class="keyword">new</span> [[TypeDecl() at=expr.at, baseType=Type tFunction ]]</span><br><span class="line">        ftype.firstType &lt;- <span class="keyword">new</span> [[TypeDecl() at=expr.at, baseType=Type tVoid]]</span><br><span class="line">        var funcPtr &lt;- <span class="keyword">new</span> [[ExprAddr() at=expr.at, target:=str, funcType &lt;- ftype]]</span><br><span class="line">        <span class="keyword">return</span> funcPtr</span><br></pre></td></tr></table></figure><p>Тогда вызвать такой макрос можно так:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">require brainfuck_macro</span><br><span class="line"><span class="comment">//генерируем функцию</span></span><br><span class="line">let func = %bf~++++++++[&gt;++++[&gt;++&gt;+++&gt;+++&gt;+&lt;&lt;&lt;&lt;-]&gt;+&gt;+&gt;-&gt;&gt;+[&lt;]&lt;-]&gt;&gt;.&gt;---.+++++++..+++.&gt;&gt;.&lt;-.&lt;.+++.------.--------.&gt;&gt;+.&gt;++.%%</span><br><span class="line"><span class="comment">//вызываем сгенерированную функцию</span></span><br><span class="line">invoke(func)</span><br></pre></td></tr></table></figure><p>Если раскомментировать строчку <code>print(describe(fn))</code> можно посмотреть на сгенерированное тело функции.</p><p>Например:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">let func = %bf~[-&gt;+&lt;]%%</span><br><span class="line"><span class="comment">//сгенерированный код</span></span><br><span class="line"></span><br><span class="line">[unsafe_deref]</span><br><span class="line">def <span class="keyword">public</span> bf`exec_0xd_0xc</span><br><span class="line">    unsafe</span><br><span class="line">        var tape:<span class="built_in">array</span>&lt;uint8&gt; -<span class="keyword">const</span>                          <span class="comment">//declare variables</span></span><br><span class="line">        var tapePos:<span class="keyword">int</span> -<span class="keyword">const</span></span><br><span class="line">        resize(tape,<span class="number">1000000</span>)</span><br><span class="line">        var ptape:<span class="keyword">auto</span> -<span class="keyword">const</span> = addr(tape[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ptape[tapePos] != uint8(<span class="number">0</span>)                      <span class="comment">//[</span></span><br><span class="line">            ptape[tapePos] = uint8(<span class="keyword">int</span>(ptape[tapePos]) - <span class="number">1</span>)   <span class="comment">//-</span></span><br><span class="line">            ++tapePos                                         <span class="comment">//&gt;</span></span><br><span class="line">            ptape[tapePos] = uint8(<span class="keyword">int</span>(ptape[tapePos]) + <span class="number">1</span>)   <span class="comment">//+</span></span><br><span class="line">            --tapePos                                         <span class="comment">//&lt;]</span></span><br><span class="line">let func = @@bf`exec_0xd_0xc <span class="comment">//указатель на функцию</span></span><br></pre></td></tr></table></figure><p>Для каждой функции генерируется уникальное имя, чтобы можно было создать несколько отдельных интерпретатов, и своя “лента” памяти. В дальнейшем, каждый отдельный символ brainfuck компилируется в одну или несколько ast-нод daScript, который затем могут быть просимулированы.</p><p>(Раздел <code>daScript</code> про симуляцию и устройство виртуальной машины daScript)<br><a href="/blog/2115627465/" title="Устройство интерпретаторов lua-jit и daScript">Устройство интерпретаторов lua-jit и daScript</a> </p><p>(Генерация кода с помощью <a href="https://dascript.org/doc/reference/language/reification.html" target="_blank" rel="noopener">реификации выражений</a>)<br><a href="/blog/4046309382/" title="daScript macro - 2">daScript macro - 2</a></p><p>Если говорить о терминологии, то brainfuck можно рассматривать как <code>предметно-ориентированный язык (DSL)</code>. Переменные состояния tape и tapePos вместе составляют <code>семантическую модель</code> этого языка, которая настраивается с помощью DSL, а затем транслируется в синтаксическое дерево на <code>daScript</code> (в терминах Мартина Фаулера из книги “Предметно-ориентированные языки программирования”).</p><p>Время выполнения такой скомпилированной функции <strong>в режиме интерпретации</strong>:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">e:\src\daScript_my\bin\Release&gt;daScript.exe brainfuck.das</span><br><span class="line">[I] total 29.28014399999999995 sec</span><br></pre></td></tr></table></figure><p>Это немного медленнее скомпилированной JiT-версии, но уже быстрее AoT версии интерпретатора.</p><h2 id="Macro-JiT"><a href="#Macro-JiT" class="headerlink" title="Macro + JiT"></a>Macro + JiT</h2><p>Дальше будет интереснее. Наша скомпилированная версия функции представляет собой по сути развёрнутую трассированную версию исполнения кода (и занимающую больше памяти). Попробуем применить к ней макрос [jit]:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">fn |&gt; append_annotation(<span class="string">"$"</span>, <span class="string">"unsafe_deref"</span>, args)</span><br><span class="line">fn |&gt; append_annotation(<span class="string">"$"</span>, <span class="string">"jit"</span>, args)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">e:\src\daScript_my\bin\Release&gt;daScript.exe brainfuck.das</span><br><span class="line">[I] total 0.85775599999999996 sec</span><br></pre></td></tr></table></figure><p>0.85 секунды! (плюс около секунды на само время компиляции функции). llvm jit умеет сворачивать идущие подряд повторяющиеся операторы инкремента и декремента, за счёт чего получилось ускорение в 30 раз (и соотвествующее уменьшение размера функции).</p><p>Для сравнения — compile-time версия на nim работает ~3 секунды и тратит ~20 секунд на компиляцию (nim работает медленно в compile-time режиме).</p><h2 id="Оптимизации-Brainfuck-gt-daScript-AST"><a href="#Оптимизации-Brainfuck-gt-daScript-AST" class="headerlink" title="Оптимизации Brainfuck -&gt; daScript AST"></a>Оптимизации Brainfuck -&gt; daScript AST</h2><p>Получается интересная цепочка преобразования кода:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bf --&gt; (bf macro) --&gt; dascript ast --&gt; (dascript simulate - unsafe deref macro + optimizations) --&gt; dascript ast optimized --&gt; (llvm macro) --&gt; llvm native optimized code --&gt; (execute)</span><br></pre></td></tr></table></figure><p>На каждом из шагов происходят серьёзные трансформации кода, которые могут включать оптимизации. Можно рассмотреть оптимизации в обратном порядке:</p><ul><li>llvm — бекэнд генерации кода оптимизирует байт-код, на этом этапе заметен эффект от сворачивания идущих подряд операций</li><li>dascript simulate — при симуляции ast-дерева выбираются оптимизированные частные версии нод, мелкие ноды могут “сплавляться” в более крупные, применяются кастомные макросы, трансформирующие дерево по различным правилам</li><li>bf macro — на данном уровне производится трансляция команд brainfuck в ноды dascript, пока без оптимизаций</li></ul><p>Оптимизации на стадиях трансформаций llvm были сделаны библиотекой из “комплекта” языка, на стадиях преобразования daScript — как встроенными в язык оптимизациями, так и добавленными для своего кода вручную. Можно теперь попробовать добавить пару оптимизаций на “стороне DSL”, т.е. в макрос трансформации <code>brainfuck-&gt;daScript</code>.</p><p>На данном этапе первую тупую и наивную реализацию уже получилось разогнать где-то в 20000 раз, и это отличный повод разогнать ещё немного :)</p><p>Можно выбрать несколько простых паттернов brainfuck кода и попробовать распознавать их и генерить более оптимальный код для этих частных случаев:</p><ul><li>цепочка повторяющихся операций. Например, “+++++” можно интерпретировать не как 5 отдельных инкрементов, а как одну операцию увеличения на 5. Эту свёртку делает llvm для версии <code>Macro+JiT</code>, но если сделать её в своём макросе, то она также ускорит и обычный режим интерпретации</li><li>паттерн [-] можно интерпретировать как очистку ячейки памяти одной операцией</li><li>[-&gt;+&lt;] - чуть более сложный паттерн, который часто встречается в примерах на brainfuck, “сложение двух ячеек с очисткой исходной”, может быть интерпретирован как 2 команды вместо цикла</li><li>можно продолжать обнаруживать и добавлять всё более сложные паттерны</li></ul><p>(Приём с отслеживанием паттернов подходит, естественно, не только для brainfuck-кода, но и для любых DSL)</p><p>“Продвинутая” версия макроса, отслеживающая перечисленные паттерны</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">seachRepeats</span><span class="params">(symIt; var sym:<span class="keyword">int</span>&amp;; symbolToCheck)</span></span></span><br><span class="line"><span class="function">    var count </span>= <span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">while</span> <span class="title">next</span><span class="params">(symIt, sym)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">if</span> sym </span>== symbolToCheck</span><br><span class="line">            ++count</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> count</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line">def match_reset(data: <span class="built_in">array</span>&lt;<span class="keyword">int</span>&gt;)</span><br><span class="line">    <span class="keyword">return</span> length(data) == <span class="number">3</span> &amp;&amp; data[<span class="number">0</span>] == <span class="string">'['</span> &amp;&amp; data[<span class="number">1</span>] == <span class="string">'-'</span> &amp;&amp; data[<span class="number">2</span>] == <span class="string">']'</span></span><br><span class="line"></span><br><span class="line">def match_add_right_reset(data: <span class="built_in">array</span>&lt;<span class="keyword">int</span>&gt;)</span><br><span class="line">    <span class="keyword">return</span> length(data) == <span class="number">6</span> &amp;&amp; data[<span class="number">0</span>] == <span class="string">'['</span> &amp;&amp; data[<span class="number">1</span>] == <span class="string">'-'</span> &amp;&amp; data[<span class="number">2</span>] == <span class="string">'&gt;'</span> &amp;&amp; data[<span class="number">3</span>] == <span class="string">'+'</span> &amp;&amp; data[<span class="number">4</span>] == <span class="string">'&lt;'</span> &amp;&amp; data[<span class="number">5</span>] == <span class="string">']'</span></span><br><span class="line"></span><br><span class="line">def generateFunction(uniqueName, code)</span><br><span class="line">    let seqStr = <span class="built_in">string</span>(code)</span><br><span class="line"></span><br><span class="line">    var blkArr : <span class="built_in">array</span>&lt;<span class="built_in">array</span>&lt;ExpressionPtr&gt;&gt;; defer_delete(blkArr)</span><br><span class="line"></span><br><span class="line">    var blk : <span class="built_in">array</span>&lt;ExpressionPtr&gt;; defer_delete(blk)</span><br><span class="line">    blkArr |&gt; emplace(blk)</span><br><span class="line"></span><br><span class="line">    var cyclePatternChecker:<span class="built_in">array</span>&lt;<span class="keyword">int</span>&gt;</span><br><span class="line"></span><br><span class="line">    var initBlock &lt;- quote() &lt;|</span><br><span class="line">        var tape: <span class="built_in">array</span>&lt;uint8&gt;</span><br><span class="line">        var tapePos : <span class="keyword">int</span></span><br><span class="line">        tape |&gt; resize(<span class="number">1000000</span>)</span><br><span class="line">        var ptape = addr(tape[<span class="number">0</span>])</span><br><span class="line">    <span class="comment">//blkArr[0] |&gt; emplace_new &lt;| initBlock</span></span><br><span class="line">    unsafe</span><br><span class="line">        var _block &lt;- reinterpret&lt;smart_ptr&lt;ExprBlock&gt;&gt;(reinterpret&lt;smart_ptr&lt;ExprMakeBlock&gt;&gt; initBlock)._block</span><br><span class="line">        <span class="keyword">for</span> blockItem in _block.<span class="built_in">list</span></span><br><span class="line">            blkArr[<span class="number">0</span>] |&gt; emplace_new &lt;| blockItem</span><br><span class="line">    var symIt &lt;- unsafe(each(seqStr))</span><br><span class="line">    var sym : <span class="keyword">int</span></span><br><span class="line">    var repeat = <span class="literal">false</span></span><br><span class="line">    var count : <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> repeat || next(symIt, sym)</span><br><span class="line">        repeat = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">if</span> sym == <span class="string">'+'</span></span><br><span class="line">            cyclePatternChecker |&gt; push(sym)</span><br><span class="line">            repeat = <span class="literal">true</span></span><br><span class="line">            count = seachRepeats(symIt, sym, <span class="string">'+'</span>)</span><br><span class="line">            back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( $&#123; ptape[tapePos] = uint8(<span class="keyword">int</span>(ptape[tapePos]) + $v(count)); &#125;)</span><br><span class="line">        elif sym == <span class="string">'-'</span></span><br><span class="line">            cyclePatternChecker |&gt; push(sym)</span><br><span class="line">            repeat = <span class="literal">true</span></span><br><span class="line">            count = seachRepeats(symIt, sym, <span class="string">'-'</span>)</span><br><span class="line">            back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( $&#123; ptape[tapePos] = uint8(<span class="keyword">int</span>(ptape[tapePos]) - $v(count)); &#125;)</span><br><span class="line">        elif sym == <span class="string">'&gt;'</span></span><br><span class="line">            cyclePatternChecker |&gt; push(sym)</span><br><span class="line">            repeat = <span class="literal">true</span></span><br><span class="line">            count = seachRepeats(symIt, sym, <span class="string">'&gt;'</span>)</span><br><span class="line">            back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( $&#123; tapePos +=  $v(count); &#125;)</span><br><span class="line">        elif sym == <span class="string">'&lt;'</span></span><br><span class="line">            cyclePatternChecker |&gt; push(sym)</span><br><span class="line">            repeat = <span class="literal">true</span></span><br><span class="line">            count = seachRepeats(symIt, sym, <span class="string">'&lt;'</span>)</span><br><span class="line">            back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( $&#123; tapePos -= $v(count); &#125;)</span><br><span class="line"></span><br><span class="line">        elif sym == <span class="string">'.'</span> &#123; back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( $&#123; print(<span class="keyword">int</span>(ptape[tapePos]) |&gt; to_char); &#125;); &#125;</span><br><span class="line">        elif sym == <span class="string">','</span> &#123; back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( $&#123; ptape[tapePos] = uint8(getchar()); &#125;); &#125;</span><br><span class="line">        elif sym == <span class="string">'['</span></span><br><span class="line">            cyclePatternChecker |&gt; clear</span><br><span class="line">            cyclePatternChecker |&gt; push(sym)</span><br><span class="line">            var blk1 : <span class="built_in">array</span>&lt;ExpressionPtr&gt;; defer_delete(blk1)</span><br><span class="line">            blkArr |&gt; emplace(blk1)</span><br><span class="line">        elif sym == <span class="string">']'</span></span><br><span class="line">            cyclePatternChecker |&gt; push(sym)</span><br><span class="line">            <span class="keyword">if</span> match_reset(cyclePatternChecker)</span><br><span class="line">                <span class="comment">//match [-]</span></span><br><span class="line">                blkArr |&gt; pop()</span><br><span class="line">                back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( $&#123; ptape[tapePos] = uint8(<span class="number">0</span>); &#125;)</span><br><span class="line">            elif match_add_right_reset(cyclePatternChecker)</span><br><span class="line">                <span class="comment">//match [-&gt;+&lt;]</span></span><br><span class="line">                blkArr |&gt; pop()</span><br><span class="line">                back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( $&#123; ptape[tapePos+$v(count)] = uint8(<span class="keyword">int</span>(ptape[tapePos+$v(count)]) + <span class="keyword">int</span>(ptape[tapePos])); &#125;)</span><br><span class="line">                back(blkArr) |&gt; emplace_new &lt;| qmacro_expr( $&#123; ptape[tapePos] = uint8(<span class="number">0</span>); &#125;)</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">//usual cycle</span></span><br><span class="line">                var last &lt;- back(blkArr)</span><br><span class="line">                blkArr |&gt; pop()</span><br><span class="line">                var whileExpr &lt;- qmacro_expr &lt;|</span><br><span class="line">                    <span class="keyword">while</span> ptape[tapePos] != uint8(<span class="number">0</span>)</span><br><span class="line">                        $b(last)</span><br><span class="line">                back(blkArr) |&gt; emplace_new &lt;| whileExpr</span><br><span class="line"></span><br><span class="line">            cyclePatternChecker |&gt; clear</span><br><span class="line">        <span class="keyword">else</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    var fnArguments : <span class="built_in">array</span>&lt;VariablePtr&gt;;</span><br><span class="line">    var fn &lt;- qmacro_function(uniqueName) &lt;| $ ($a(fnArguments))</span><br><span class="line">        unsafe</span><br><span class="line">            $b(blkArr[<span class="number">0</span>])</span><br><span class="line">    defer_delete(fn)</span><br><span class="line"></span><br><span class="line">    var args:<span class="built_in">array</span>&lt; tuple&lt;argname:<span class="built_in">string</span>;argvalue:RttiValue&gt; &gt;</span><br><span class="line">    fn |&gt; append_annotation(<span class="string">"$"</span>, <span class="string">"jit"</span>, args)</span><br><span class="line">    fn |&gt; append_annotation(<span class="string">"$"</span>, <span class="string">"unsafe_deref"</span>, args)</span><br><span class="line">    <span class="comment">//print(describe(fn))</span></span><br><span class="line">    compiling_module() |&gt; add_function(fn)</span><br></pre></td></tr></table></figure><p>Результат:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">e:\src\daScript_my\bin\Release&gt;daScript.exe brainfuck.das</span><br><span class="line">[I] total 0.70142899999999999 sec</span><br></pre></td></tr></table></figure><p>Еще на 17% быстрее<br><em>Из замеров явно стоило бы еще вынести print</em></p><h2 id="Немного-выводов"><a href="#Немного-выводов" class="headerlink" title="Немного выводов"></a>Немного выводов</h2><ul><li>Основа оптимизации — написание грамотного кода на основном языке.</li><li>Техники JiT-компиляции (особенно в сочетании с кодогенерацией или замерами hot участков) могут давать крутые результаты, в том числе превосходящие статическую компиляцию</li><li>Организация цепочки преобразований кода в одной среде НАМНОГО удобнее, чем в разных (какой-нибудь вариант “кодоген на python” + макросы/шаблоны + код на C++” - мрак с отладкой). Особенно для более длинных цепочек.</li><li>Нормальные макросы = нормальная отладка и скорость компиляции DSL.</li></ul><p><a href="https://github.com/spiiin/dascript_brainfuck" target="_blank" rel="noopener">Код примеров</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Попробовал портировать с &lt;code&gt;nim&lt;/code&gt; на &lt;code&gt;daScript&lt;/code&gt; &lt;a href=&quot;https://howistart.org/posts/nim/1/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;интерпретатор&lt;/a&gt; &lt;code&gt;brainfuck&lt;/code&gt; кода. Брейфак предельно простой язык, и базовая реализация интерпретатора занимает полчаса, но на нём можно потренироваться в ускорении кода и продемонстрировать возможности daScript в оптимизации.&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="dascript" scheme="http://spiiin.github.io/tags/dascript/"/>
    
      <category term="llvm" scheme="http://spiiin.github.io/tags/llvm/"/>
    
  </entry>
  
  <entry>
    <title>ECS - типы и проблемы</title>
    <link href="http://spiiin.github.io/blog/1601029690/"/>
    <id>http://spiiin.github.io/blog/1601029690/</id>
    <published>2022-11-05T22:13:02.000Z</published>
    <updated>2022-11-06T09:38:35.748Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><h2 id="Where-is-my-components"><a href="#Where-is-my-components" class="headerlink" title="Where is my components"></a>Where is my components</h2><p>Одна из идей <code>ecs</code> — держать компоненты рядом в памяти и обходить в порядке хранения в памяти. По способу организации хранения <a href="https://github.com/SanderMertens/ecs-faq#what-are-the-different-ways-to-implement-an-ecs" target="_blank" rel="noopener">ECS FAQ</a> выделяет такие группы:</p><ul><li>Реактивные ECS</li></ul><p><a href="https://github.com/sschmid/Entitas/blob/main/src/Entitas/src/Entity/Entity.cs#L96" target="_blank" rel="noopener">Entitas</a> - компоненты валяются где-то на хипе, entity хранит указатели на компоненты. Добавление и удаление компонентов с помощью событий уведомляет системы, чтобы они обновили свои списки. О хранении рядом речи не идёт. На самом деле, по типу хранения тут скорее “Entity based”. Идея с тем, чтобы уведомлять системы при изменении списка компонента на сущности реализована и в других типах ECS</p><ul><li>Bitset based</li></ul><p><a href="hhttps://github.com/alecthomas/entityx/blob/82ab2d304ef5e6933cf6622721f086a1f4731e80/entityx/Entity.h#L641">EntityX</a> - компоненты хранятcя в отдельных пулах, entity хранит битовую маску, присутствует ли компонент в конкретной entity. Быстро, но очень расточительно в плане количества потребляемой памяти.</p><ul><li>Sparse set</li></ul><p><a href="https://github.com/skypjack/entt" target="_blank" rel="noopener">EnTT</a> - компоненты хранятся в системах, в структурах под названием <a href="https://github.com/skypjack/entt/blob/master/src/entt/entity/sparse_set.hpp#L151" target="_blank" rel="noopener">sparse_set</a>. Бывают структуры, владеющие компонентами, и хранящие индексы компонентов (дополнительный уровень индирекции), а также совмещенные варианты (владеет частью компонентов, но обращается к другим по индексам). Способ хранения компонент задаёт пользователь библиотеки, что позволяет выбирать наиболее быстрые способы, но взамен требуется хорошее понимание того, как правильно его выбрать.</p><p><a href="http://bitsquid.blogspot.com/2011/09/managing-decoupling-part-4-id-lookup.html" target="_blank" rel="noopener">Managing Decoupling Part 4 — The ID Lookup Table</a> - простое объяснение.<br><a href="https://skypjack.github.io/2019-03-07-ecs-baf-part-2/" target="_blank" rel="noopener">ECS back and forth Part 2 - Where are my entities?</a> - объяснение использования в EnTT.<br><a href="https://github.com/skypjack/entt/wiki/Crash-Course:-entity-component-system#groups" target="_blank" rel="noopener">Groups</a> - более детальное объяснения того, как ускорить доступ к паре компонентов, которыми владеет одна система. Совсем кратко — если система владеет компонентами A и B, то она может хранить их так, чтобы при обращении за сущностями с обоими компонентами компоненты этих сущностей всегда лежали в начале массивов.<br><a href="https://skypjack.github.io/2019-03-21-ecs-baf-part-2-insights/" target="_blank" rel="noopener">Part 2, insights - Sparse sets and grouping functionalities</a> - еще раз подробно о способе сортировки групп.</p><ul><li>Archetypes (aka “Dense ECS” or “Table based ECS”)<br><a href="https://github.com/SanderMertens/flecs" target="_blank" rel="noopener">flecs</a> - компоненты хранятся в архетипах. Архетип — сочетание уникального множества компонентов. Для каждого архетипа существует отдельный массив. Компонент хранит список архетипов, которые его включают. Сущность хранит указатель на массив архетипов, и индекс внутри этого массива (по которому получает сразу все свои компоненты).</li></ul><p>Таким образом, легко получить сразу все компоненты сущности, но при удалении/добавлении компонента необходимо “перекладывание” всей пачки компонентов из одного массива архетипов в другой. Также, если существует множество различных архетипов (сочетаний компонентов), и существует несколько систем, выбирающих одиночные компоненты, то расстояние в памяти между различными архетипами будет большим (как и если архетип достаточно большой - шаг между отдельными компонентами может быть большим)</p><p><a href="https://ajmmertens.medium.com/building-an-ecs-1-where-are-my-entities-and-components-63d07c7da742" target="_blank" rel="noopener">Building an ECS #1: Where are my Entities and Components</a> и<br><a href="https://ajmmertens.medium.com/building-an-ecs-2-archetypes-and-vectorization-fe21690805f9" target="_blank" rel="noopener">Building an ECS #2: Archetypes and Vectorization</a> - идея расскладыванием на архетипы</p><p><a href="https://github.com/GaijinEntertainment/daScript/blob/master/daslib/decs.das#L323" target="_blank" rel="noopener">decs</a> - библиотека ecs в <code>daScript</code> на архетипах<br><a href="https://github.com/GaijinEntertainment/daScript/blob/master/daslib/decs_boost.das" target="_blank" rel="noopener">decs_boost</a> - набор макросов, с помощью которых обращение с архетипами синтаксически похоже на обычный императивный код</p><p>Идеальным сочетанием для скорости выглядит использование <code>архетипов</code> в тех системах, где 1) не происходит постоянного добавления/удаления компонентов и 2) компонент используются только небольшим количеством систем (в примеры приводят низкоуровневые физические и графические подсистемы) + использование <code>sparse sets</code> там где существует большое количество типов компонент, которые постоянно добавляются/удаляются и систем, использующих разные сочетания компонентов (игровая логика).</p><h2 id="Проблемы-с-ECS"><a href="#Проблемы-с-ECS" class="headerlink" title="Проблемы с ECS"></a>Проблемы с ECS</h2><p>На чистом ECS сложно выразить некоторые распространённые в геймдеве задачи:</p><ul><li>Иерархии</li><li>Конечные автоматы</li><li>Декларативный GUI</li><li>Порядок работы систем (и повторный запуск)</li><li>Расширение/наследование компонентов</li><li>Контракты компонентов (взаимоисключающие сочетания, неудаляемые и т.п.)</li><li>Отображение объекта из нескольких сущностей как целого</li></ul><p>И более редкие</p><ul><li>Общее использование компонента сущностями</li><li>Несколько компонентов одного типа на сущности</li></ul><p><a href="https://ajmmertens.medium.com/ecs-from-tool-to-paradigm-350587cdf216" target="_blank" rel="noopener">ECS: From Tool to Paradigm</a> - список проблем<br><a href="https://takinginitiative.wordpress.com/2019/09/30/ecs-questions/" target="_blank" rel="noopener">ECS Questions</a> + <a href="https://takinginitiative.wordpress.com/2019/11/09/more-ecs-questions/" target="_blank" rel="noopener">More ECS Questions</a> - еще пара разборов ситуаций в игровом коде и способов их решения — порядок вызова систем в иерархических структурах, применительно к подсистеме анимации.</p><h2 id="Kruger-Engine-Entity-Model"><a href="#Kruger-Engine-Entity-Model" class="headerlink" title="Kruger Engine Entity Model"></a>Kruger Engine Entity Model</h2><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/jjEsB611kxs" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div><p><code>Game Engine Entity/Object Models</code> — большой обзор ECS подхода от Bobby Anguelov, с предложением гибридного подхода.<br><a href="https://takinginitiative.files.wordpress.com/2019/11/krgentitymodel.pdf" target="_blank" rel="noopener">Kruger Engine Entity Model</a> — презентация про демо-движок с подходом из видео-доклада.<br><a href="https://github.com/BobbyAnguelov/Esoterica" target="_blank" rel="noopener">Esoterica</a> - более позднее название демо-движка</p><p>Системы делятся на глобальные и локальные.</p><ul><li>Глобальные</li></ul><p>Чтобы передавать информацию между сущностями, и обновлять состояние мира</p><ul><li>Локальные<br>Чтобы передавать информацию между компонентами одной сущности (сущность не может получить доступ к компонентам напрямую, не через локальную систему, компоненты не могут ссылаться друг на друга или обновляться сами)<br>Чтобы гарантированно обновлять все компоненты родителя раньше дочерних, для систем, которым необходим порядок обновления</li></ul><p><img src="/blog/1601029690/slide_1_small.png" alt=""></p><p>Разрешено добавление нескольких компонентов одного типа на сущность, чтобы упростить построение иерархий (меш + сабмеши).<br>Разрешено явное задание пространственной иерархии между сущностями (с помощью <code>Spatial Component</code>, который имеет список дочерних Spatial Component и хранит пространственные матрицы)</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;h2 id=&quot;Where
      
    
    </summary>
    
    
    
      <category term="link" scheme="http://spiiin.github.io/tags/link/"/>
    
      <category term="ecs" scheme="http://spiiin.github.io/tags/ecs/"/>
    
  </entry>
  
  <entry>
    <title>daScript. SFML, dasBox и спайны</title>
    <link href="http://spiiin.github.io/blog/887709799/"/>
    <id>http://spiiin.github.io/blog/887709799/</id>
    <published>2022-11-05T16:42:25.000Z</published>
    <updated>2022-11-05T18:49:02.297Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Вкрутил в <a href="https://github.com/spiiin/dasbox_sfml" target="_blank" rel="noopener">dasbox_sfml</a> поддержку <a href="http://ru.esotericsoftware.com/" target="_blank" rel="noopener">spine-runtime</a>.</p><p>Добавлена минимальная поддержка — <a href="https://github.com/spiiin/dasbox_sfml/blob/main/src/sfmlSpine.cpp" target="_blank" rel="noopener">модуль</a> с кастомной обёрткой над типом и несколькими функциями настройки.</p><p>Сделан для того, чтобы детальнее разобраться с байндингом (проверить, как работает вручную, в отличие от автоматической генерации)<br><a href="/blog/500729544/" title="daScript: C++ auto-bindings, assimp">daScript: C++ auto-bindings, assimp</a><br>И чтобы улучшить визуал примеров<br><a href="/blog/4060902549/" title="daScript. SFML, dasBox и semi-transparent render target">daScript. SFML, dasBox и semi-transparent render target</a></p><p>Примеры:</p><h2 id="Рендер-спайна-в-текстуру"><a href="#Рендер-спайна-в-текстуру" class="headerlink" title="Рендер спайна в текстуру"></a>Рендер спайна в текстуру</h2><p><img src="/blog/887709799/spine_sfml_1_small.png" alt=""><br><a href="https://github.com/spiiin/dasbox_sfml/blob/main/samples/sfml_spines/demo_spines_2_rt.das" target="_blank" rel="noopener">https://github.com/spiiin/dasbox_sfml/blob/main/samples/sfml_spines/demo_spines_2_rt.das</a></p><p>Способ отрендерить полупрозрачный объект в рендер-таргет текстуру детально описан в первой части статьи (<code>source-over</code> и <code>premultiply alpha</code>). Также для сравнения выведена текстура с обычным режимом блендинга (посередине) — полупрозрачный шлем излишне чёрный.</p><h2 id="Shader"><a href="#Shader" class="headerlink" title="Shader"></a>Shader</h2><p><img src="/blog/887709799/spine_sfml_2_small.png" alt=""><br><a href="https://github.com/spiiin/dasbox_sfml/blob/main/samples/sfml_spines/demo_spines_3_shader.das" target="_blank" rel="noopener">https://github.com/spiiin/dasbox_sfml/blob/main/samples/sfml_spines/demo_spines_3_shader.das</a></p><p>Спайны чаще всего состоят из большого количества аттачментов (чаще всего 2d-меши), которые рендерятся послойно, так что для наложения некоторых эффектов, влияющих на изображение целиком (outline, различные виды distortion, motion-эффекты, glow), необходимо также предварительно отрендерить спайн целиком в текстуру. Отдельное приключение — получить размеры render-target текстуры, в которые поместиться спайн во время анимации. Чаще всего эти сведения можно получить только от артиста, либо просчитать в real-time/compile-time (анимации могут накладываться друг на друга различными способами).</p><p>В live-режиме удобно, что нет особой необходимости писать gui для настройки параметров шейдера, можно играться с ними, мгновенно получая фидбек на экране.</p><h2 id="Реверс-блендинг"><a href="#Реверс-блендинг" class="headerlink" title="Реверс-блендинг"></a>Реверс-блендинг</h2><p><img src="/blog/887709799/spine_sfml_3_small.png" alt=""><br><a href="https://github.com/spiiin/dasbox_sfml/blob/main/samples/sfml_spines/demo_spines_4_reverse_blending.das" target="_blank" rel="noopener">https://github.com/spiiin/dasbox_sfml/blob/main/samples/sfml_spines/demo_spines_4_reverse_blending.das</a></p><p>Напоследок — интересный и сложный в реализации через sfml и spine-runtime эффект, описанный в статье <a href="https://habr.com/ru/company/playrix/blog/487250/" target="_blank" rel="noopener">Отложенный Alpha blending</a>. Способ позволяет отрендерить “дырки” в спайнах любой формы за один проход, без использования предзаготовленных масок и рендер-таргет текстур. На скриншоте — анимированный спайн лианы, через которую сквозь основной спайн видно фоновый спрайт.</p><p>Реализация требует обратного порядка отрисовки и специальных формул блендинга. Порядок отрисовки:</p><ul><li>экран очищается цветом [0,255,0,0] - в альфа-компоненте должен быть 0, а не 255!</li><li>передний спайн с обычным режимом блендинга</li><li>спайн-“дырка”, с режимом блендинга “вычитание” - glBlendFunc(GL_ZERO, GL_ONE_MINUS_SRC_ALPHA)</li><li>фон, который “просвечивает” через основной спрайт только там, где была нарисована дырка - glBlendFuncSeparate(GL_SRC_ALPHA_SATURATE, GL_ONEU, GL_ONEU, GL_ONE_MINUS_SRC_ALPHA)</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">def initialize</span><br><span class="line">    ...</span><br><span class="line">    spine = <span class="keyword">new</span> SpineWrapper(<span class="string">"spineboy-pro.skel"</span>,  <span class="string">"spineboy-pma.atlas"</span>)</span><br><span class="line">    spine |&gt; set_position(<span class="number">320.0</span>, <span class="number">590.0</span>)</span><br><span class="line">    spine |&gt; set_animation(<span class="number">0</span>, <span class="string">"walk"</span>, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">    spineHole = <span class="keyword">new</span> SpineWrapper(<span class="string">"vine-pro.skel"</span>,  <span class="string">"vine-pma.atlas"</span>)</span><br><span class="line">    spineHole |&gt; set_premultiply_alpha(<span class="literal">false</span>) <span class="comment">//отключаем режим premultiply</span></span><br><span class="line">    spineHole |&gt; set_position(<span class="number">320.0</span>, <span class="number">640.0</span>)</span><br><span class="line">    spineHole |&gt; set_animation(<span class="number">0</span>, <span class="string">"grow"</span>, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">def draw</span><br><span class="line">    withRenderTarget &lt;| $(var rt: RenderTarget&amp;)</span><br><span class="line">        rt |&gt; clear(Color(<span class="number">0u</span>,<span class="number">255u</span>,<span class="number">0u</span>,<span class="number">0u</span>))</span><br><span class="line">        <span class="comment">//draw base spine</span></span><br><span class="line">        rt |&gt; draw(spine, RenderStates_Default())</span><br><span class="line"></span><br><span class="line">        <span class="comment">//draw hole spine</span></span><br><span class="line">        <span class="keyword">using</span>(Factor Zero, Factor OneMinusSrcAlpha, Equation Add) &lt;| $(var blendMode: BlendMode#)</span><br><span class="line">            <span class="keyword">using</span>(blendMode) &lt;| $(var renderState: RenderStates#)</span><br><span class="line">                rt |&gt; draw(spineHole, renderState)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//draw triangle, special render mode</span></span><br><span class="line">        <span class="comment">//raw opengl</span></span><br><span class="line">        glBlendFuncSeparate(GL_SRC_ALPHA_SATURATE, GL_ONEU, GL_ONEU, GL_ONE_MINUS_SRC_ALPHA)</span><br><span class="line">        glUseProgram(program)</span><br><span class="line">        vs_main_bind_uniform(program)</span><br><span class="line">        fs_main_bind_uniform(program)</span><br><span class="line">        glBindVertexArray(vao)</span><br><span class="line">        glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">6</span>)</span><br><span class="line">        glBindVertexArray(<span class="number">0u</span>)</span><br><span class="line">        glUseProgram(<span class="number">0u</span>)</span><br></pre></td></tr></table></figure><ul><li>spine-runtime позволяет аниматорам выставлять и переключать режимы блендинга самостоятельно, поэтому чтобы спайн был отрисован с кастомным режимом блендинга, необходимо использовать не “нормальный” блендинг, а <a href="https://github.com/spiiin/spine_cpp_sfml/blob/main/spine-sfml/spine-sfml.cpp#L171" target="_blank" rel="noopener">тот</a>, который был выставлен в sfml. Также спайн-“дырка” не должен использовать каких-либо дополнительный режимов блендинга в ходе анимации.</li><li>режим блендинга GL_SRC_ALPHA_SATURATE почему-то вообще не прокинут в <a href="https://www.sfml-dev.org/documentation/2.5.1/structsf_1_1BlendMode.php" target="_blank" rel="noopener">SFML</a>, поэтому фон отрисован с помощью функций opengl (<a href="https://www.sfml-dev.org/tutorials/2.5/window-opengl.php" target="_blank" rel="noopener">sfml+opengl</a> без проблем уживаются вместе).</li></ul><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;Вкрутил в 
      
    
    </summary>
    
    
    
      <category term="opengl" scheme="http://spiiin.github.io/tags/opengl/"/>
    
      <category term="dascript" scheme="http://spiiin.github.io/tags/dascript/"/>
    
  </entry>
  
  <entry>
    <title>daScript. SFML, dasBox и semi-transparent render target</title>
    <link href="http://spiiin.github.io/blog/4060902549/"/>
    <id>http://spiiin.github.io/blog/4060902549/</id>
    <published>2022-10-22T12:29:18.000Z</published>
    <updated>2022-10-23T17:36:01.564Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Пример работы с SFML в dasBox — рендер полупрозрачных объектов в рендер-таргет. Тривиальная задача для графического программиста, но почему-то многие разработчики игр не знают, как это корректно сделать.</p><h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>Изначальная задумка поста — собрать небольшой пример, показывающий алгоритм рендеринга полупрозрачных объектов в текстуру, с последующим корректным отображением этой текстуры, как если бы объекты рендерились на экран напрямую, без использования этой текстуры. Но попутно оказалось, что можно запилить фреймворк для таких демок, с возможноостью в live-режиме поиграться с параметрами и посмотреть результат.</p><h2 id="dasSFML"><a href="#dasSFML" class="headerlink" title="dasSFML"></a>dasSFML</h2><p>Примеры на <code>Opengl+GLFW</code>:<br><a href="/blog/4232971949/" title="daScript OpenGL">daScript OpenGL</a><br><a href="/blog/3006126295/" title="daScript - live-режим">daScript - live-режим</a></p><p>В отличие от GLFW, <code>SFML</code> представляет простые объекты-обёртки над функциями OpenGL для работы с текстурами, шейдерами, рендер-таргетами, и прочими примитивами библиотеки рендера, в то же время представляя для кастомизации практически все параметры рендера (во всяком случае необходимые для задуманного примера), для того, чтобы можно было писать небольшие примеры алгоритмов рендера на OpenGL.</p><p>Для начала, можно “завести” простейший <a href="https://github.com/borisbat/dasSFML/blob/main/examples/graphics.das" target="_blank" rel="noopener">пример</a> из комплекта привязки <code>SFML</code> к <code>daScript</code>.</p><p>Для его сборки выкачиваем сабмодули <code>daScript</code>:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git submodule update --init --recursive</span><br></pre></td></tr></table></figure></p><p>Затем включаем сборку этого модуля в CmakeLists.txt и добавляем линковку статической библиотеки с модулем libDasSFML и самих библиотек SFML:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">option(DAS_SFML_DISABLED &quot;Disable dasSFML (SFML multimedia library)&quot; OFF)</span><br><span class="line">...</span><br><span class="line">target_link_libraries(sfmlApp</span><br><span class="line">  libDasModuleSFML</span><br><span class="line">  sfml-graphics</span><br><span class="line">  sfml-network</span><br><span class="line">  sfml-system</span><br><span class="line">  sfml-window</span><br><span class="line">  #для windows также:</span><br><span class="line">  legacy_stdio_definitions</span><br><span class="line">  winmm</span><br><span class="line">  Opengl32</span><br><span class="line">  sfml-main</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>и перегененируем проект<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;generate_msvc_2019.bat</span><br></pre></td></tr></table></figure></p><p>Затем в хост-приложении на C++:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//подключение заголовка с определением модуля</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dasSFML/src/dasSFML.h&gt;</span></span></span><br><span class="line">...</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span>, <span class="keyword">char</span> * [] )</span> </span>&#123;</span><br><span class="line">    NEED_ALL_DEFAULT_MODULES;</span><br><span class="line">    NEED_MODULE(Module_dasSFML); <span class="comment">//&lt;---создаём модуль sfml</span></span><br><span class="line">    Module::Initialize();</span><br><span class="line">    run_script();</span><br><span class="line">    Module::Shutdown();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>run_script</code> вызывает метод <code>main</code> из примера, который создаёт SFML-окно и запускает цикл обработки сообщений в нём.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main</span><br><span class="line">    <span class="keyword">using</span>(VideoMode(<span class="number">640u</span>,<span class="number">480u</span>), <span class="string">"SFML window"</span>, uint(WindowStyle Default), ContextSettings()) &lt;| $ ( var window : RenderWindow# )</span><br><span class="line">        <span class="keyword">while</span> window |&gt; isOpen()</span><br><span class="line">            var event : Event</span><br><span class="line">            <span class="keyword">while</span> window |&gt; pollEvent(event)</span><br><span class="line">                <span class="keyword">if</span> event._type == EventType Closed</span><br><span class="line">                    window |&gt; close()</span><br><span class="line">            interface(window) &lt;| $ ( var rt : RenderTarget )</span><br><span class="line">                rt |&gt; clear( Color(<span class="number">64u</span>,<span class="number">0u</span>,<span class="number">0u</span>,<span class="number">255u</span>) )</span><br><span class="line">                <span class="keyword">using</span>(<span class="number">50.0f</span>,<span class="number">0x1e</span>ul) &lt;| $ ( var shape : CircleShape# )</span><br><span class="line">                    interface(shape) &lt;| $ ( var tr : Transformable )</span><br><span class="line">                        tr |&gt; move(<span class="number">20.</span>,<span class="number">30.</span>)</span><br><span class="line">                    shape |&gt; setFillColor(Color(<span class="number">150u</span>,<span class="number">50u</span>,<span class="number">250u</span>,<span class="number">255u</span>))</span><br><span class="line">                    shape |&gt; setOutlineThickness(<span class="number">10.f</span>)</span><br><span class="line">                    shape |&gt; setOutlineColor(Color(<span class="number">250u</span>,<span class="number">150u</span>,<span class="number">100u</span>,<span class="number">255u</span>))</span><br><span class="line">                    rt |&gt; draw(shape, RenderStates_Default())</span><br><span class="line">            window |&gt; display()</span><br></pre></td></tr></table></figure><p>В качестве фреймворка для создания окна используется имеющийся в SFML класс <code>Window</code>. Однако проще воспользоваться другим фреймворком, в который уже внедрены возможности daScript-а по перезагрузке кода.</p><h2 id="dasbox"><a href="#dasbox" class="headerlink" title="dasbox"></a>dasbox</h2><p><a href="https://github.com/imp5imp5/dasbox" target="_blank" rel="noopener">dasbox</a> — примитивный движок для 2d-игр, который Gaijin-ы использовали для проведения конкурса <a href="https://gaijinjam.net/ru" target="_blank" rel="noopener">Gaijin Jam</a> (<a href="https://github.com/AlexLemminG/TheFarmers" target="_blank" rel="noopener">игра-победитель</a>). Движок имеет простую <a href="https://github.com/imp5imp5/dasbox/blob/main/doc/api.txt" target="_blank" rel="noopener">апишку</a>, на которой можно потренироваться использованию языка на уровне “как будто типизированная lua”, а также настроен для подключения отладчика языка, веб-инспектора для отображения состояния ecs-модуля и горячей перезагрузке кода.</p><p>Но для меня интереснее другое — <code>dasbox</code> использует в качестве бекэнда <code>SFML</code>. И хотя это осознанно скрыто от пользователей для того, чтобы можно было сменить бекэнд, можно немного “поломать инкапсуляцию”, для того, чтобы воспользоваться в нём модулем <code>dasSFML</code>, и получить доступ к более богатому API, получив от самого dasbox-а фичи и инструменты по работе с кодом.</p><p><a href="https://github.com/spiiin/dasbox_sfml" target="_blank" rel="noopener">dasbox_sfml</a> — порт дасбокса с включенным модулем dasSFML.</p><p>Базовый пример на нём выглядит так:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">require daslib/media</span><br><span class="line">require sfml</span><br><span class="line">require dasbox_sfml</span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def initialize</span><br><span class="line">    set_window_title(<span class="string">"sfml"</span>)</span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line"><span class="function">def <span class="title">act</span><span class="params">(dt: <span class="keyword">float</span>)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">if</span> <span class="title">get_key</span><span class="params">(VK_ESCAPE)</span></span></span><br><span class="line"><span class="function">        <span class="title">schedule_quit_game</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">[export]</span><br><span class="line">def draw</span><br><span class="line">    withRenderTarget &lt;| $(var rt: RenderTarget&amp;)</span><br><span class="line">        rt |&gt; clear(Color(<span class="number">0u</span>,<span class="number">255u</span>,<span class="number">0u</span>,<span class="number">255u</span>))</span><br><span class="line">        <span class="keyword">using</span>(<span class="number">50.0f</span>,<span class="number">0x1e</span>ul) &lt;| $(var shape: CircleShape#)</span><br><span class="line">            interface(shape) &lt;| $(var tr: Transformable)</span><br><span class="line">                tr |&gt; move(<span class="number">20.</span>,<span class="number">30.</span>)</span><br><span class="line">            shape |&gt; setFillColor(Color(<span class="number">150u</span>,<span class="number">50u</span>,<span class="number">250u</span>,<span class="number">255u</span>))</span><br><span class="line">            shape |&gt; setOutlineThickness(<span class="number">10.f</span>)</span><br><span class="line">            shape |&gt; setOutlineColor(Color(<span class="number">250u</span>,<span class="number">150u</span>,<span class="number">100u</span>,<span class="number">255u</span>))</span><br><span class="line">            rt |&gt; draw(shape, RenderStates_Default())</span><br></pre></td></tr></table></figure><br><img src="/blog/4060902549/screen1_small.png" alt=""></p><p><code>dasBox_sfml</code> подхватывает изменения в файле с кодом, а также отображает в своей консоли ошибки в этом файле.</p><p>Идиомы <code>daScript</code> в примере:</p><ul><li><code>using()</code> - создание переменной <a href="https://dascript.org/doc/reference/language/temporary.html" target="_blank" rel="noopener">временного типа</a>, который существует только в пределах блока using</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span>() &lt;| $(var fs: das_string#)</span><br><span class="line">    fs := <span class="string">"hello world"</span></span><br><span class="line">    <span class="comment">//тут можно использовать переменную, в том числе передавать в другие функции</span></span><br><span class="line">    some_func(fs)</span><br><span class="line">    <span class="comment">//но нельзя как-либо сохранить указатель на эту переменную</span></span><br><span class="line">    <span class="comment">//var s = fs //ошибка, нельзя копировать временный тип</span></span><br></pre></td></tr></table></figure><ul><li><code>interface</code> - приведение к базовому типу</li></ul><p>Генератор привязок на C++ позволяет передать отношение наследования двух C++ типов в daScript так:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">addExtern&lt; <span class="keyword">decltype</span>(&amp;with_interface&lt;sf::Sprite,sf::Transformable&gt;), with_interface&lt;sf::Sprite,sf::Transformable&gt; &gt;(*<span class="keyword">this</span>,lib,<span class="string">"interface"</span>,SideEffects::invoke,<span class="string">"with_interface&lt;sf::Sprite,sf::Transformable&gt;"</span>);</span><br></pre></td></tr></table></figure></p><p><code>daScript</code> заставляет думать о типах и их времени жизни немного больше, чем C++, но и позволяет выразить больше таких утверждений, которые сможет проверить компилятор, чтобы уберечься от ошибок.</p><h2 id="RenderTarget"><a href="#RenderTarget" class="headerlink" title="RenderTarget"></a>RenderTarget</h2><p>Следующий пример — рендер в текстуру и отображение её на экране. В SFML для этого можно использовать класс <a href="https://www.sfml-dev.org/documentation/2.5.1/classsf_1_1RenderTexture.php" target="_blank" rel="noopener">RenderTexture</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">def draw</span><br><span class="line">    withRenderTarget &lt;| $(var rt: RenderTarget&amp;)</span><br><span class="line">        clear(rt, Color(<span class="number">0u</span>,<span class="number">255u</span>,<span class="number">0u</span>,<span class="number">255u</span>))</span><br><span class="line">        <span class="keyword">using</span>() &lt;| $(var rtTex: RenderTexture#)</span><br><span class="line">            rtTex |&gt; create(<span class="number">300u</span>, <span class="number">300u</span>, <span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">using</span>(<span class="number">50.0f</span>,<span class="number">0x1e</span>ul) &lt;| $(var shape: CircleShape#)</span><br><span class="line">                interface(shape) &lt;| $(var tr: Transformable)</span><br><span class="line">                    tr |&gt; move(<span class="number">20.</span>,<span class="number">30.</span>)</span><br><span class="line">                shape |&gt; setFillColor(Color(<span class="number">150u</span>,<span class="number">50u</span>,<span class="number">250u</span>,<span class="number">255u</span>))</span><br><span class="line">                shape |&gt; setOutlineThickness(<span class="number">10.f</span>)</span><br><span class="line">                shape |&gt; setOutlineColor(Color(<span class="number">250u</span>,<span class="number">150u</span>,<span class="number">100u</span>,<span class="number">255u</span>))</span><br><span class="line">                rtTex |&gt; draw(shape, RenderStates_Default())</span><br><span class="line">            <span class="keyword">using</span>(rtTex |&gt; getTexture()) &lt;| $(var sprite: Sprite#)</span><br><span class="line">                rt |&gt; draw(sprite, RenderStates_Default())</span><br></pre></td></tr></table></figure><p>Пока всё хорошо, и круг отрендеренный в текстуру выглядит также, как если бы был выведен на экран напрямую</p><h2 id="Полупрозрачные-объекты-в-RenderTarget"><a href="#Полупрозрачные-объекты-в-RenderTarget" class="headerlink" title="Полупрозрачные объекты в RenderTarget"></a>Полупрозрачные объекты в RenderTarget</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//рендер двух полупрозрачных кругов</span></span><br><span class="line"><span class="function">def <span class="title">drawCircles</span><span class="params">(var rt: RenderTarget&amp;)</span></span></span><br><span class="line">    using(125.0f, 128ul) &lt;| $(var shape: CircleShape#)</span><br><span class="line">        shape |&gt; setFillColor(Color(<span class="number">0u</span>,<span class="number">255u</span>,<span class="number">0u</span>,<span class="number">128u</span>))</span><br><span class="line">        rt |&gt; draw(shape, RenderStates_Default())</span><br><span class="line">    <span class="keyword">using</span>(<span class="number">125.0f</span>, <span class="number">128u</span>l) &lt;| $(var shape: CircleShape#)</span><br><span class="line">        interface(shape) &lt;| $(var tr: Transformable) &#123; tr |&gt; move(<span class="number">125.0f</span>, <span class="number">0.0f</span>); &#125;</span><br><span class="line">        shape |&gt; setFillColor(Color(<span class="number">255u</span>,<span class="number">05u</span>,<span class="number">0u</span>,<span class="number">128u</span>))</span><br><span class="line">        rt |&gt; draw(shape, RenderStates_Default())</span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def draw</span><br><span class="line">    withRenderTarget &lt;| $(var rt: RenderTarget&amp;)</span><br><span class="line">        rt |&gt; clear(Color(<span class="number">255u</span>,<span class="number">255u</span>,<span class="number">255u</span>,<span class="number">255u</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment">//простой рендер</span></span><br><span class="line">        text_out(<span class="number">0</span>, <span class="number">0</span>, <span class="string">"Simple"</span>, <span class="number">0xFF000000</span>)</span><br><span class="line">        drawCircles(rt)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//рендер в текстуру</span></span><br><span class="line">        text_out(<span class="number">0</span>, <span class="number">300</span>, <span class="string">"Texture"</span>, <span class="number">0xFF000000</span>)</span><br><span class="line">        <span class="keyword">using</span>() &lt;| $(var rtTex: RenderTexture#)</span><br><span class="line">            rtTex |&gt; create(<span class="number">250u</span> + <span class="number">125u</span>, <span class="number">250u</span>, <span class="literal">false</span>)</span><br><span class="line">            rtTex |&gt; clear(Color(<span class="number">0u</span>, <span class="number">0u</span>, <span class="number">0u</span>, <span class="number">0u</span>))</span><br><span class="line">            drawCircles(rtTex)</span><br><span class="line">            <span class="keyword">using</span>(rtTex |&gt; getTexture()) &lt;| $(var sprite: Sprite#)</span><br><span class="line">                interface(sprite) &lt;| $(var tr: Transformable)</span><br><span class="line">                    tr |&gt; move(<span class="number">0.0f</span>, <span class="number">300.0f</span>)</span><br><span class="line">                rt |&gt; draw(sprite, RenderStates_Default())</span><br></pre></td></tr></table></figure><p><img src="/blog/4060902549/screen2_small.png" alt=""></p><p>Полупрозрачные круги, отрендеренные в текстуру, выглядят темнее, чем отрисованные на экране напрямую. С реальными текстурами (или отрендеренными в текстуру шрифтами), проблема обычно выглядит как темная рамка на краях объекта (там где края ради сглаживания плавно “уходят” в прозрачность).</p><p>Из-за чего это возникает?</p><p>Цвет пиксела отрисованного объекта смешивается в пикселем, уже находящимся в буфере цвете по настраиваемым формулам. При прямой отрисовке порядок рендера получается таким:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">рисуется пиксел красного круга -&gt; смешивается с цветом dst1 фона (белое изображение) &#x3D; получаем цвет dst2</span><br><span class="line">рисуется пиксел зеленого круга -&gt; смешивается с цветом dst2 (фон + красный круг)</span><br></pre></td></tr></table></figure></p><p>Тогда как в случае рендера в текстуру происходит:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">рисуется пиксел красного круга -&gt; смешивается с фоновым цветом рендер таргет текстуры dst_rt1 (&quot;пустой&quot; rgba цвет, rgb каналы по умолчанию чёрные) &#x3D; получаем dst_rt2</span><br><span class="line">рисуется пиксел зелёного круга -&gt; смешивается с цветом dst_rt2 (пустой цвет текстуры + красный круг)</span><br><span class="line">текстура выводится на экран -&gt; смешивается цвет фона dst1 с цветом рендер таргет текстуры (пустой цвет текстуры + красный круг + зелёный круг)</span><br></pre></td></tr></table></figure></p><p>Видно, что в итоговом цвете на экрана присутствует влияние цвета render-target текстуры — прозрачного по альфа каналу, но в итоговой формуле кроме альфа канала влияение оказывают также и RGB каналы цвета (чёрного или любого другого — неважно, но избавиться от влияния этого фонового цвета без изменения формулы смешивания невозможно, “невидимый” цвет начинает быть видимым).</p><h2 id="Настройка-режимов-смешивания"><a href="#Настройка-режимов-смешивания" class="headerlink" title="Настройка режимов смешивания"></a>Настройка режимов смешивания</h2><p><code>OpenGL</code> (и <code>SFML</code> над ней) дают возможность переключать формулы режимов смешивания. Важно отойти от представления “определенная формула магическим образом включает полупрозрачность” к тому, что графический API просто даёт возможность изменить уравнение смешивание, а вывод конкретных формул ложится на плечи программиста.</p><p>Стандартное уравнение смешивания для полупрозрачности смешивает цвета в пропорции:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); </span><br><span class="line">GL_SRC_ALPHA - коэффициент смешивания рисуемого цвета - чем прозрачнее рисуемая фигура, тем меньше видно её цвет</span><br><span class="line">GL_ONE_MINUS_SRC_ALPHA - коэффициент смешивания фонового цвета - обратный, чем прозрачнее рисуемая фигура, тем больше видно цвет за ней</span><br><span class="line"></span><br><span class="line">r1 - цвет фона</span><br><span class="line">r2 - цвет 1-го круга</span><br><span class="line">r3 - цвет 2-го круга</span><br><span class="line">после отрисовки фона m1 &#x3D; (a1 * r1)</span><br><span class="line">смешанный цвет после отрисовки первого круга m2 &#x3D; (a2 * r2 + (1.0 - a2) * a1 * r1)</span><br><span class="line">смешанный цвет после отрисовки второго круга m3 &#x3D; (a3 * r3 + (1.0 - a3) * (a2 * r2 + (1.0 - a2) * a1 * r1)) &#x3D; </span><br><span class="line"> &#x3D; (a3 * r3 + (1.0 - a3) * a2 * r2 + (1.0 - a3) * (1.0 - a2) * a1 * r1)</span><br></pre></td></tr></table></figure></p><p>При рендере в текстуру по умолчанию используется другая формула, которая разделяет рассчёты для RGB-каналов цвета и для A-канала.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ONE_MINUS_SRC_ALPHA);</span><br><span class="line">для RGB-каналов - аналогично предыдущей формуле</span><br><span class="line">для A-канала:</span><br><span class="line">  Asrc + Adst * (1-Asrc) - альфа значение рисуемого цвета берётся &quot;как есть&quot; и складывается с уменьшенным фоновым значением </span><br><span class="line"></span><br><span class="line">Цвет и альфа для рендер-таргет текстуры - glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ONE_MINUS_SRC_ALPHA);</span><br><span class="line">цвет в рендер-таргет текстуре rt1 &#x3D; r1 * a1 (берём черный прозрачный цвет r1&#x3D;(0,0,0), a1&#x3D;0 - четвёртый компонент важен)</span><br><span class="line">цвет после добавления круга rt2 &#x3D; (a2 * r2 + (1.0 - a2) * a1 * r1) &#x3D; a2 * r2     &#x2F;&#x2F;premultiply alpha</span><br><span class="line">альфа после добавления круга rta2 &#x3D; a2 + a1 * (1-a2) &#x3D; a2</span><br><span class="line">цвет после добавления второго круга rt3 &#x3D; (a3 * r3 + (1.0 - a3) * a2 * r2)</span><br><span class="line">альфа после добавления второго круга rta3 &#x3D; a3 + a2 * (1 - a3)</span><br></pre></td></tr></table></figure><p>Эта формула годится только для рендера полностью непрозрачных объектов. Если какие-то части объекта прозрачные, необходимо использовать другую пару формул (для рендера в текстуру + для рендера полученной текстуры на экране). Для рендера в текстуру при этом можно даже получать “неправильные” цвета, которые можно потом смешать с изображением на экране так, чтобы смешанный итоговый цвет стал корректным.</p><p>Хороший разбор проблемы на <a href="https://stackoverflow.com/questions/24346585/opengl-render-to-texture-with-partial-transparancy-translucency-and-then-rende" target="_blank" rel="noopener">stackoverflow</a><br>Формулы смешивания также разжеваны в статье <a href="https://habr.com/ru/post/468067/" target="_blank" rel="noopener">Как работает альфа-композитинг</a></p><h2 id="Source-Over"><a href="#Source-Over" class="headerlink" title="Source-Over"></a>Source-Over</h2><p>Одно из возможных решений — смешать цвет полученной render target текстуры в режиме <code>Source-Over</code> (термин из статьи выше, из списка операторов смешивания Портера-Даффа):<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA)</span><br><span class="line">итоговый цвет m3 &#x3D; rt3 + m1 * (1.0 - rta3)</span><br><span class="line"></span><br><span class="line">подставим сюда значения значения из предудыщей формулы для рендерт-таргет цвета и текстуры:</span><br><span class="line">m3 &#x3D; (a3 * r3 + (1.0 - a3) * a2 * r2) + (a1 * r1) * (1.0 - a3 - a2 * (1 - a3))</span><br><span class="line"></span><br><span class="line">Теперь можно сравнить полученные значения итогового цвета m3 из формулы прямого рендера и этой формулы:</span><br><span class="line">m3_direct &#x3D;&#x3D; m3_sourceover</span><br><span class="line">(a3 * r3 + (1.0 - a3) * a2 * r2 + (1.0 - a3) * (1.0 - a2) * a1 * r1) &#x3D;&#x3D; (a3 * r3 + (1.0 - a3) * a2 * r2) + (a1 * r1) * (1.0 - a3 - a2 * (1 - a3))</span><br><span class="line">(1.0 - a3) * (1.0 - a2) &#x3D;&#x3D; (1.0 - a3 - a2 * (1 - a3)</span><br><span class="line">1.0 - a3 - a2 + a2*a3 &#x3D;&#x3D; 1.0 - a3 - a2 + a2*a3</span><br><span class="line"></span><br><span class="line">Тада! убедились в равенстве</span><br></pre></td></tr></table></figure></p><p>Код смешивания в режиме <code>Source-Over</code>, правильный результат:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">def draw</span><br><span class="line">    withRenderTarget &lt;| $(var rt: RenderTarget&amp;)</span><br><span class="line">        rt |&gt; clear(Color(<span class="number">255u</span>,<span class="number">255u</span>,<span class="number">255u</span>,<span class="number">255u</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment">//simple draw</span></span><br><span class="line">        text_out(<span class="number">0</span>, <span class="number">0</span>, <span class="string">"Simple"</span>, <span class="number">0xFF000000</span>)</span><br><span class="line">        drawCircles(rt)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//render texture draw</span></span><br><span class="line">        text_out(<span class="number">0</span>, <span class="number">300</span>, <span class="string">"Texture: Satsub"</span>, <span class="number">0xFF000000</span>)</span><br><span class="line">        <span class="keyword">using</span>() &lt;| $(var rtTex: RenderTexture#)</span><br><span class="line">            rtTex |&gt; create(<span class="number">250u</span> + <span class="number">125u</span>, <span class="number">250u</span>, <span class="literal">false</span>)</span><br><span class="line">            rtTex |&gt; clear(Color(<span class="number">0u</span>, <span class="number">0u</span>, <span class="number">0u</span>, <span class="number">0u</span>))</span><br><span class="line">            drawCircles(rtTex)</span><br><span class="line">            <span class="keyword">using</span>(rtTex |&gt; getTexture()) &lt;| $(var sprite: Sprite#)</span><br><span class="line">                interface(sprite) &lt;| $(var tr: Transformable)</span><br><span class="line">                    tr |&gt; move(<span class="number">0.0f</span>, <span class="number">300.0f</span>)</span><br><span class="line">                <span class="keyword">using</span>(Factor One, Factor OneMinusSrcAlpha, Equation Add) &lt;| $(var blendMode: BlendMode#)</span><br><span class="line">                    <span class="keyword">using</span>(blendMode) &lt;| $(var renderState: RenderStates#)</span><br><span class="line">                        rt |&gt; draw(sprite, renderState)</span><br></pre></td></tr></table></figure><br><img src="/blog/4060902549/screen3_small.png" alt=""></p><h2 id="Premultiply-alpha"><a href="#Premultiply-alpha" class="headerlink" title="Premultiply alpha"></a>Premultiply alpha</h2><p>Если посмотреть на коэффициенты смешивания в “неправильном” блендинге, и в <code>Sourse-Over</code>, можно прийти к более правильному интуитивному пониманию лишнего влияния цвета в неправильной версии. В неё не “вмешан” лишний чёрный цвет, а добавлено лишнее умножение цвета на альфа канал, которое “гасит” этот цвет больше, чем необходимо при корректном смешивании.</p><p>Можно пойти другим путём — убрать умножение цвета на альфу при смешивании совсем, но производить его 1 раз в шейдере — тогда не нужно переключать режим прозрачности, но нужно переключать шейдер, с которым отрисован объект. Преимуществом такого способами может быть то, что исходное изображение часто можно домножить на альфа-канал еще до запуска приложения (в демо-примере изображение генерится динамически, поэтому умножение сделано в шейдере).</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var fragmentShaderTex = (</span><br><span class="line"><span class="string">"uniform sampler2D texture;</span></span><br><span class="line"><span class="string">void main()</span></span><br><span class="line"><span class="string">\&#123;</span></span><br><span class="line"><span class="string">    gl_FragColor = texture2D(texture, gl_TexCoord[0].st);</span></span><br><span class="line"><span class="string">\&#125;"</span>)</span><br><span class="line"></span><br><span class="line">var fragmentShaderPremultiply = (</span><br><span class="line"><span class="string">"void main()</span></span><br><span class="line"><span class="string">\&#123;</span></span><br><span class="line"><span class="string">    //gl_FragColor = gl_Color;  //for testing no premultiply</span></span><br><span class="line"><span class="string">    gl_FragColor = vec4(gl_Color.rgb * gl_Color.a, gl_Color.a);</span></span><br><span class="line"><span class="string">\&#125;"</span>)</span><br><span class="line"></span><br><span class="line">var rsPremultiplySatSub, rsSatSub : RenderStates?</span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def initialize</span><br><span class="line">    set_window_title(<span class="string">"sfml"</span>) </span><br><span class="line"></span><br><span class="line">    var shaderPremult = <span class="keyword">new</span> Shader()</span><br><span class="line">    shaderPremult |&gt; load_fragment_shader_from_string(fragmentShaderPremultiply)</span><br><span class="line"></span><br><span class="line">    var shaderTex = <span class="keyword">new</span> Shader()</span><br><span class="line">    shaderTex |&gt; load_fragment_shader_from_string(fragmentShaderTex)    </span><br><span class="line">    shaderTex |&gt; bind_current_texture_to_uniform(<span class="string">"texture"</span>)</span><br><span class="line">    </span><br><span class="line">    var blendModeSatSubSeparate = <span class="keyword">new</span> BlendMode(Factor One, Factor OneMinusSrcAlpha, Equation Add, Factor OneMinusDstAlpha, Factor One, Equation Add)</span><br><span class="line"></span><br><span class="line">    rsPremultiplySatSub = makeRenderTarget(shaderPremult, blendModeSatSubSeparate)</span><br><span class="line">    rsSatSub = makeRenderTarget(shaderTex, blendModeSatSubSeparate)</span><br><span class="line"></span><br><span class="line">def drawCircles(var rt: RenderTarget&amp;; rs: RenderStates&amp; implicit)</span><br><span class="line">    <span class="keyword">using</span>(<span class="number">125.0f</span>, <span class="number">128u</span>l) &lt;| $(var shape: CircleShape#)</span><br><span class="line">        shape |&gt; setFillColor(Color(<span class="number">0u</span>,<span class="number">255u</span>,<span class="number">0u</span>,<span class="number">128u</span>))</span><br><span class="line">        rt |&gt; draw(shape, rs)</span><br><span class="line">    <span class="keyword">using</span>(<span class="number">125.0f</span>, <span class="number">128u</span>l) &lt;| $(var shape: CircleShape#)</span><br><span class="line">        interface(shape) &lt;| $(var tr: Transformable) &#123; tr |&gt; move(<span class="number">125.0f</span>, <span class="number">0.0f</span>); &#125;</span><br><span class="line">        shape |&gt; setFillColor(Color(<span class="number">255u</span>,<span class="number">05u</span>,<span class="number">0u</span>,<span class="number">128u</span>))</span><br><span class="line">        rt |&gt; draw(shape, rs)</span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">render_with_blend_and_premultiply</span><span class="params">(var rt: RenderTarget&amp;)</span></span></span><br><span class="line"><span class="function">    <span class="title">drawCircles</span><span class="params">(rt, *rsPremultiplySatSub)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">def <span class="title">render_sprite_with_blend</span><span class="params">(var rt: RenderTarget&amp;; var sprite: Sprite&amp; implicit)</span></span></span><br><span class="line">    rt |&gt; draw(sprite, *rsSatSub)</span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def draw</span><br><span class="line">    withRenderTarget &lt;| $(var rt: RenderTarget&amp;)</span><br><span class="line">        rt |&gt; clear(Color(<span class="number">255u</span>,<span class="number">255u</span>,<span class="number">255u</span>,<span class="number">255u</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment">//simple draw</span></span><br><span class="line">        text_out(<span class="number">0</span>, <span class="number">0</span>, <span class="string">"Simple"</span>, <span class="number">0xFF000000</span>)</span><br><span class="line">        drawCircles(rt, RenderStates_Default())</span><br><span class="line"></span><br><span class="line">        <span class="comment">//render texture draw</span></span><br><span class="line">        text_out(<span class="number">0</span>, <span class="number">300</span>, <span class="string">"Texture: Premult"</span>, <span class="number">0xFF000000</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">using</span>() &lt;| $(var rtTex: RenderTexture#)</span><br><span class="line">            rtTex |&gt; create(<span class="number">250u</span> + <span class="number">125u</span>, <span class="number">250u</span>, <span class="literal">false</span>)</span><br><span class="line">            rtTex |&gt; clear(Color(<span class="number">0u</span>, <span class="number">0u</span>, <span class="number">0u</span>, <span class="number">0u</span>))</span><br><span class="line">            render_with_blend_and_premultiply(rtTex)</span><br><span class="line">            <span class="keyword">using</span>(rtTex |&gt; getTexture()) &lt;| $(var sprite: Sprite#)</span><br><span class="line">                interface(sprite) &lt;| $(var tr: Transformable)</span><br><span class="line">                    tr |&gt; move(<span class="number">0.0f</span>, <span class="number">300.0f</span>)</span><br><span class="line">                render_sprite_with_blend(rt, sprite)</span><br></pre></td></tr></table></figure><p><img src="/blog/4060902549/screen4_small.png" alt=""></p><p>Универсальный режим смешивания для premultiply изображений:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">glBlendFuncSeparate(GL_ONE, GL_ONE_MINUS_SRC_ALPHA, GL_ONE_MINUS_DST_ALPHA, GL_ONE);</span><br><span class="line"></span><br><span class="line">Порядок рендера:</span><br><span class="line">1. Вывод в изображения в рендер-таргет текстуру с premultiply-шейдером (или же вывод подготовленного заранее изображения с обычным шейдером)</span><br><span class="line">2. Вывод рендер-таргет текстуры на экран с обычным шейдером (чтобы избежать лишнего умножения)</span><br><span class="line"></span><br><span class="line">математика (скопипащена с stackoverflow ответа):</span><br><span class="line">after layer 2: (a2 * r2, a2)</span><br><span class="line">after layer 3: (a3 * r3 + (1.0 - a3) * a2 * r2, (1.0 - a2) * a3 + a2)</span><br><span class="line"></span><br><span class="line">srcR &#x3D; a3 * r3 + (1.0 - a3) * a2 * r2</span><br><span class="line">srcA &#x3D; (1.0 - a2) * a3 + a2</span><br><span class="line">dstR &#x3D; a1 * r1</span><br><span class="line">ONE * srcR + ONE_MINUS_SRC_ALPHA * dstR</span><br><span class="line">    &#x3D; srcR + (1.0 - srcA) * dstR</span><br><span class="line">    &#x3D; a3 * r3 + (1.0 - a3) * a2 * r2 + (1.0 - ((1.0 - a2) * a3 + a2)) * a1 * r1</span><br><span class="line">    &#x3D; a3 * r3 + (1.0 - a3) * a2 * r2 + (1.0 - a3 + a2 * a3 - a2) * a1 * r1</span><br><span class="line">    &#x3D; a3 * r3 + (1.0 - a3) * a2 * r2 + (1.0 - a3) * (1.0 - a2) * a1 * r1</span><br></pre></td></tr></table></figure></p><p>Заметки по daScript:</p><ul><li>Вывод объекта с изменённым режимом блендинга и шейдером в <code>SFML</code> инкапуслирован в объекте <code>RenderStates</code></li><li>Вместо создания временных типов в этом примере используются “обычные” для <code>daScript</code> указатели:</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var shaderPremult : Shader? = <span class="keyword">new</span> Shader()</span><br></pre></td></tr></table></figure><p>Такие <a href="https://dascript.org/doc/reference/language/datatypes.html#pointers" target="_blank" rel="noopener">указатели</a> хранят объект в куче и владеют им, по семантике близко к <code>std::unique_ptr</code>. При желании можно освободить объект вручную, присвоив указателю <code>nullptr</code>.</p><ul><li>ключевое слово implicit после имени типа в аргументах функции позволяет функции работать с обычными типами, так и с временными.</li></ul><p>Код примеров - <a href="https://github.com/spiiin/dasbox_sfml/tree/main/samples/sfml_blending" target="_blank" rel="noopener">https://github.com/spiiin/dasbox_sfml/tree/main/samples/sfml_blending</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;Пример раб
      
    
    </summary>
    
    
    
      <category term="opengl" scheme="http://spiiin.github.io/tags/opengl/"/>
    
      <category term="dascript" scheme="http://spiiin.github.io/tags/dascript/"/>
    
  </entry>
  
  <entry>
    <title>daScript - решение задачек</title>
    <link href="http://spiiin.github.io/blog/2385889062/"/>
    <id>http://spiiin.github.io/blog/2385889062/</id>
    <published>2022-10-16T13:00:11.000Z</published>
    <updated>2022-10-16T13:55:33.792Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Решение нескольких алгоритмических задачек на <code>daScript</code>.<br><a id="more"></a></p><p>Задачки со старого собеса Nokia на C++ программиста (уже закрыли офис в России), <a href="https://twitter.com/st_1ena/status/1419689924505260032" target="_blank" rel="noopener">разбор</a></p><h2 id="Вычислить-первые-N-простых-чисел"><a href="#Вычислить-первые-N-простых-чисел" class="headerlink" title="Вычислить первые N простых чисел"></a>Вычислить первые N простых чисел</h2><p>.. и вернуть результат в качестве массива.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">calc_primes</span><span class="params">(n: <span class="keyword">int</span>; var a:<span class="built_in">array</span>&lt;<span class="keyword">int</span>&gt;)</span></span></span><br><span class="line">    a |&gt; clear</span><br><span class="line">    a |&gt; reserve(n)</span><br><span class="line"></span><br><span class="line">    a |&gt; push(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    a |&gt; push(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    let gen &lt;- generator&lt;<span class="keyword">int</span>&gt;() &lt;| $()</span><br><span class="line">        var t = <span class="number">6</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">true</span></span><br><span class="line">            yield t<span class="number">-1</span></span><br><span class="line">            yield t+<span class="number">1</span></span><br><span class="line">            t += <span class="number">6</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    var iterVal: <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">while</span> length(a) &lt; n</span><br><span class="line">        next(gen, iterVal)</span><br><span class="line">        var simple = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">for</span> prim in a</span><br><span class="line">            <span class="keyword">if</span> iterVal % prim == <span class="number">0</span></span><br><span class="line">                simple = <span class="literal">false</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> prim * prim &gt; iterVal</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> simple</span><br><span class="line">            a |&gt; push(iterVal)</span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main</span><br><span class="line">    var a: <span class="built_in">array</span>&lt;<span class="keyword">int</span>&gt;</span><br><span class="line">    calc_primes(<span class="number">1000000</span>, a)</span><br><span class="line">    print(<span class="string">"&#123;a[length(a)-1]&#125;\n"</span>)</span><br></pre></td></tr></table></figure><p><a href="https://github.com/spiiin/dascript_trivial_examples/blob/main/primes/primes.das" target="_blank" rel="noopener">https://github.com/spiiin/dascript_trivial_examples/blob/main/primes/primes.das</a></p><p>Тривиальная версия:</p><ul><li>чуть более улучшенная формула перебора чисел-кандидатов (вместо всех нечётных — t*6+/-1) + проверка границы не корнем, а квадратом.</li><li>не совсем понял, как хочет применить решето Эратосфена в варианте на C++ сама st_1ena, если нужны первые N простых чисел, а не “все числа меньшие N”, то возникает подзадача оценить минимальное натуральное число, меньше которого точно окажутся N простых чисел, что также нетривиально, или построить ленивых фильтров, что совсем нетривиально на C++, и требует оценки памяти под эти фильтры.</li><li>вместо этого, версия решения, которая может вычислить первые N чисел в compile-time — в предположении, что у нас есть некоторое количество памяти, для сохранения решета эратосфена, эффективнее тогда потратить всю эту память на хранение предпросчитанных первых значений, и начинать рассчёт только сверх этих предпросчитанных чисел. На языках с макросами — предпросчёт в compile-time выполняется той же функцией, что в run-time, т.е. не требует написания дополнительного кода.<br><a href="https://github.com/spiiin/dascript_trivial_examples/blob/main/primes/primes_mix_compile_runtime.das" target="_blank" rel="noopener">Версия</a>, которая сохраняет первый числа в кеш (макрос [cached_primes (count=200)] - с параметром, сколько чисел будет предпросчитано заранее)</li></ul><h2 id="Посчитать-статистику-слов-в-тексте-по-длине-слова"><a href="#Посчитать-статистику-слов-в-тексте-по-длине-слова" class="headerlink" title="Посчитать статистику слов в тексте по длине слова"></a>Посчитать статистику слов в тексте по длине слова</h2><p>Задача на то, чтобы найти в стандартной библиотеке языка нужные функциии</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">require fio</span><br><span class="line">require strings</span><br><span class="line">require daslib/strings_boost</span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line"><span class="function">def <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    var strings : <span class="built_in">array</span>&lt;<span class="built_in">string</span>&gt;</span></span><br><span class="line">    fopen("eng_to_rus.txt","rt") &lt;| $(f)</span><br><span class="line">        <span class="keyword">if</span> f != null</span><br><span class="line">            <span class="keyword">while</span> !feof(f)</span><br><span class="line">                strings |&gt; push &lt;| fgets(f)</span><br><span class="line"></span><br><span class="line">    var counter : table&lt;<span class="keyword">int</span>; <span class="keyword">int</span>&gt;</span><br><span class="line">    <span class="keyword">for</span> str in strings</span><br><span class="line">        var words &lt;- str |&gt; split_by_chars(<span class="string">" .,:-\n\t()%\"'"</span>)</span><br><span class="line">        <span class="keyword">for</span> word in words</span><br><span class="line">            <span class="keyword">if</span> word != <span class="string">""</span></span><br><span class="line">                counter[length(word)] += <span class="number">1</span>   <span class="comment">//word length</span></span><br><span class="line">                <span class="comment">//counter[word] += 1         //word</span></span><br><span class="line">    </span><br><span class="line">    var freq_pairs : <span class="built_in">array</span>&lt;tuple&lt;<span class="keyword">int</span>;<span class="keyword">int</span>&gt;&gt;</span><br><span class="line">    for k, v in keys(counter), values(counter)</span><br><span class="line">        freq_pairs |&gt; push &lt;| [[ tuple&lt;<span class="keyword">int</span>;<span class="keyword">int</span>&gt; k, v]]</span><br><span class="line">    freq_pairs |&gt; sort($(a,b) =&gt; !(a._1 &lt; b._1))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> pair in freq_pairs</span><br><span class="line">        print(<span class="string">"&#123;pair._0&#125; : &#123;pair._1&#125;\n"</span>)</span><br></pre></td></tr></table></figure><p><a href="https://github.com/spiiin/dascript_trivial_examples/blob/main/sort_words_stat_by_word_len/sort_words_stat_by_word_len.das" target="_blank" rel="noopener">https://github.com/spiiin/dascript_trivial_examples/blob/main/sort_words_stat_by_word_len/sort_words_stat_by_word_len.das</a></p><p>Решение в лоб - прочитать файл построчно, разбить на символы <code>split_by_chars</code>, обновляя в словаре значения количество слов. Дальше переложить значение в список пар, который отсортировать по первому элементу, и вывести на экран.</p><ul><li>Можно упороться по тому, чтобы выяснять у интервьюера, какие допустимы кодировки, разделители или что есть слова, как кажется подразумевали авторы задачи, которые потом расстроились, что ни один кандидат не учёл все возможные кейсы.</li><li>Можно сохранять данные не в словаре, а сразу в списке пар <code>(длина слова, частота)</code>, не так то и много возможных длин слов. Сортировка такого списка пар в daScript - либо с помощью явной передачи функции сортировки, либо определением <a href="https://github.com/GaijinEntertainment/daScript/blob/17941ef0b0199dff0db27a2bee603db1a45b69b3/examples/test/unit_tests/sort.das#L20" target="_blank" rel="noopener">оператора &lt;</a> для своего типа.</li></ul><h2 id="Удалить-из-односвязного-списка-каждый-пятый-элемент"><a href="#Удалить-из-односвязного-списка-каждый-пятый-элемент" class="headerlink" title="Удалить из односвязного списка каждый пятый элемент"></a>Удалить из односвязного списка каждый пятый элемент</h2><p>Интересно посмотреть на разницу в работе с памятью между C++ и daScript</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListItem</span></span></span><br><span class="line"><span class="class">    <span class="title">value</span>:</span> <span class="keyword">int</span></span><br><span class="line">    [[do_not_delete]] next: ListItem?</span><br><span class="line"></span><br><span class="line">def makeDemoList</span><br><span class="line">    var head =  <span class="keyword">new</span> [[ListItem value=<span class="number">1</span>]]</span><br><span class="line">    var current = head</span><br><span class="line">    <span class="keyword">for</span> i in range(<span class="number">2</span>, <span class="number">21</span>)</span><br><span class="line">        current.next = <span class="keyword">new</span> [[ListItem value=i]]</span><br><span class="line">        current = current.next</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">[sideeffects]</span><br><span class="line">def deleteEveryFifth(lst: ListItem?)</span><br><span class="line">    var counter = <span class="number">1</span></span><br><span class="line">    var current = lst</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> current != null</span><br><span class="line">        <span class="keyword">if</span> counter++ % <span class="number">4</span> == <span class="number">0</span></span><br><span class="line">            var toDelete = current.next</span><br><span class="line">            current.next = current.next?.next</span><br><span class="line">            unsafe &#123; <span class="keyword">delete</span> toDelete; &#125;</span><br><span class="line">        current = current.next</span><br><span class="line"></span><br><span class="line">def printList(lst: ListItem?)</span><br><span class="line">    <span class="keyword">if</span> lst != null</span><br><span class="line">        print(<span class="string">"&#123;lst.value&#125; "</span>)</span><br><span class="line">        printList(lst.next)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        print(<span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main</span><br><span class="line">    var <span class="built_in">list</span> = makeDemoList()</span><br><span class="line">    printList(<span class="built_in">list</span>)</span><br><span class="line">    deleteEveryFifth(<span class="built_in">list</span>)</span><br><span class="line">    printList(<span class="built_in">list</span>)</span><br><span class="line">    <span class="comment">//freeList //or just kill context</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Output:</span></span><br><span class="line"><span class="comment">// 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20</span></span><br><span class="line"><span class="comment">// 1 2 3 4 6 7 8 9 11 12 13 14 16 17 18 19</span></span><br></pre></td></tr></table></figure><p><a href="https://github.com/spiiin/dascript_trivial_examples/blob/main/delete_list_every_5/delete_every_fifth.das" target="_blank" rel="noopener">https://github.com/spiiin/dascript_trivial_examples/blob/main/delete_list_every_5/delete_every_fifth.das</a></p><ul><li>Раз мы “играем в C++”, то попробуем при удалении элемента из списка сразу же звать <a href="https://dascript.org/doc/reference/language/finalizers.html?highlight=finalizer" target="_blank" rel="noopener">финализатор</a> для него. Финализатор по умолчанию рекурсивно зовёт финализаторы для всех полей структуры. Это поведение можно изменить, если переопределить функцию <code>finalize</code>, или если пометить поле атрибутом <code>[[do_not_delete]]</code> (так как мы вручную измененяем указатели при удалении элемента, то элемент списка не отвечает за удаление следующего элемента по ссылке next).</li><li>С помощью <code>options persistent_heap = true</code>, можно настроить также освобождение памяти после вызова финализатора (иначе за освобождение памяти отвечает хост-программа, один из паттернов быстрой работы с памятью — грохнуть всю выделенную в цикле работы скрипта память разом).</li></ul><h2 id="Вывести-максимальное-число-составленное-из-единиц-двоичного-представления-заданного-числа"><a href="#Вывести-максимальное-число-составленное-из-единиц-двоичного-представления-заданного-числа" class="headerlink" title="Вывести максимальное число, составленное из единиц двоичного представления заданного числа"></a>Вывести максимальное число, составленное из единиц двоичного представления заданного числа</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">popcount</span><span class="params">(x)</span></span></span><br><span class="line"><span class="function">    var temp </span>= x</span><br><span class="line">    var count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> temp != <span class="number">0</span></span><br><span class="line">        temp &amp;= temp - <span class="number">1</span></span><br><span class="line">        count++</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line">def maxFrom1s(x)</span><br><span class="line">    let count1s = popcount(x)</span><br><span class="line">    var res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i in range(count1s)</span><br><span class="line">        res++</span><br><span class="line">        res&lt;&lt;=<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i in range(<span class="number">31</span> - count1s) <span class="comment">//assume 32 bits</span></span><br><span class="line">        res&lt;&lt;=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res </span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main</span><br><span class="line">    print(<span class="string">"&#123;uint(maxFrom1s(256-1))&#125;\n"</span>)  <span class="comment">//'0xff000000'</span></span><br></pre></td></tr></table></figure><p><a href="https://github.com/spiiin/dascript_trivial_examples/blob/main/max_value_from_1s/max_value_from_1s.das" target="_blank" rel="noopener">https://github.com/spiiin/dascript_trivial_examples/blob/main/max_value_from_1s/max_value_from_1s.das</a></p><p>Тоже без заморочек, в лоб.</p><p>В продакшен-варианте, если нужно действительно быстро, решение прокидывается в C++, где задействуются всевозможные интринсики компилятора для того, чтобы получать кол-во битов так, как умеет процессор, или другие трюки для минимизации количества инструкций (развернуть циклы, и наложить кучу масок — <a href="https://en.wikipedia.org/wiki/Hamming_weight" target="_blank" rel="noopener">Hamming weight</a>).</p><h2 id="Вывести-список-всех-самых-длинных-путей-в-дереве"><a href="#Вывести-список-всех-самых-длинных-путей-в-дереве" class="headerlink" title="Вывести список всех самых длинных путей в дереве"></a>Вывести список всех самых длинных путей в дереве</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">require daslib/functional</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span></span></span><br><span class="line"><span class="class">    <span class="title">data</span> :</span> <span class="keyword">int</span></span><br><span class="line">    left, right : Tree?</span><br><span class="line"></span><br><span class="line">var tree = <span class="keyword">new</span> [[ Tree data = <span class="number">5</span>,</span><br><span class="line">    left = <span class="keyword">new</span> [[Tree data = <span class="number">1</span>, </span><br><span class="line">        right = <span class="keyword">new</span> [[Tree data = <span class="number">2</span>]]</span><br><span class="line">    ]],</span><br><span class="line">    right = <span class="keyword">new</span> [[Tree data = <span class="number">7</span>,</span><br><span class="line">        right = <span class="keyword">new</span> [[Tree data = <span class="number">10</span>]]</span><br><span class="line">    ]]</span><br><span class="line">]]</span><br><span class="line"></span><br><span class="line"><span class="comment">//<span class="doctag">TODO:</span> optimize</span></span><br><span class="line">def clone_array(a: <span class="built_in">array</span>&lt;<span class="keyword">int</span>&gt;; newData:<span class="keyword">int</span>)</span><br><span class="line">    unsafe</span><br><span class="line">        var newArr &lt;- to_array(each(a))</span><br><span class="line">        newArr |&gt; push &lt;| newData</span><br><span class="line">        <span class="keyword">return</span> &lt;- newArr</span><br><span class="line"></span><br><span class="line">def each_element(var tree:Tree?; path: <span class="built_in">array</span>&lt;<span class="keyword">int</span>&gt;; depth:<span class="keyword">int</span>; blk:lambda&lt;(what: <span class="keyword">int</span>; path: <span class="built_in">array</span>&lt;<span class="keyword">int</span>&gt;; depth: <span class="keyword">int</span>):<span class="keyword">void</span>&gt;)</span><br><span class="line">    <span class="keyword">if</span> tree.left != null</span><br><span class="line">        each_element(tree.left, clone_array(path, tree.data), depth+<span class="number">1</span>, blk)</span><br><span class="line">    invoke(blk, tree.data, path, depth)</span><br><span class="line">    <span class="keyword">if</span> tree.right != null</span><br><span class="line">        each_element(tree.right, clone_array(path, tree.data), depth+<span class="number">1</span>, blk)</span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main</span><br><span class="line">    let startPath: <span class="built_in">array</span>&lt;<span class="keyword">int</span>&gt;</span><br><span class="line">    var globalResult : table&lt;<span class="keyword">int</span>; <span class="built_in">array</span>&lt;<span class="built_in">array</span>&lt;<span class="keyword">int</span>&gt;&gt;&gt;</span><br><span class="line">    unsafe</span><br><span class="line">        tree |&gt; each_element(startPath, <span class="number">0</span>) &lt;| @[[&amp;globalResult]](value: <span class="keyword">int</span>; path: <span class="built_in">array</span>&lt;<span class="keyword">int</span>&gt;; depth: <span class="keyword">int</span>)</span><br><span class="line">            globalResult[depth] |&gt; push_clone &lt;| clone_array(path, value)</span><br><span class="line">    <span class="comment">//find max depth</span></span><br><span class="line">    let maxDepth = reduce(keys(globalResult)) &lt;| $(left, right : <span class="keyword">int</span>)</span><br><span class="line">        <span class="keyword">return</span> left &gt; right ? left : right</span><br><span class="line">    <span class="comment">//print all pathes</span></span><br><span class="line">    print(<span class="string">"All pathes with longest depth:\n"</span>)</span><br><span class="line">    <span class="keyword">for</span> path in globalResult[maxDepth]</span><br><span class="line">        print(<span class="string">"&#123;path&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//All pathes with longest depth:</span></span><br><span class="line"><span class="comment">//[[ 5; 1; 2]]</span></span><br><span class="line"><span class="comment">//[[ 5; 7; 10]]</span></span><br></pre></td></tr></table></figure><p><a href="https://github.com/spiiin/dascript_trivial_examples/blob/main/all_pathes_max_depth/all_pathes_max_depth.das" target="_blank" rel="noopener">https://github.com/spiiin/dascript_trivial_examples/blob/main/all_pathes_max_depth/all_pathes_max_depth.das</a></p><p>Туповатое решение, с кучей лишних копирований путей.</p><p>Можно оптимайзить. Либо по памяти, разделив обход на 2 — сначала найти максимальную глубину, затем собрать только самые длинные пути. Либо в один проход, но сохраняя не полные копии путей, а альтернативное дерево с записью глубины каждой ветви рядом с указателем на оригинальные ноды left и right, по которому можно будет восстановить пути + обновляя максимальное значение глубины каждую итерацию.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Решение нескольких алгоритмических задачек на &lt;code&gt;daScript&lt;/code&gt;.&lt;br&gt;
    
    </summary>
    
    
    
      <category term="dascript" scheme="http://spiiin.github.io/tags/dascript/"/>
    
  </entry>
  
  <entry>
    <title>Устройство интерпретаторов lua-jit и daScript</title>
    <link href="http://spiiin.github.io/blog/2115627465/"/>
    <id>http://spiiin.github.io/blog/2115627465/</id>
    <published>2022-10-14T09:37:34.000Z</published>
    <updated>2022-11-11T13:45:00.037Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Устройство виртуальных машин для самых быстрых скриптовых языков — <a href="https://luajit.org/" target="_blank" rel="noopener">lua-jit</a> и <a href="https://dascript.org/" target="_blank" rel="noopener">daScript</a>.<br>Более развёрнутое продолжение беглой заметки <a href="/blog/1067581840/" title="daScript - скорость">daScript - скорость</a></p><a id="more"></a><h2 id="Lua"><a href="#Lua" class="headerlink" title="Lua"></a>Lua</h2><p>По <a href="https://github.com/r-lyeh-archived/scriptorium" target="_blank" rel="noopener">бенчмаркам языков</a> <code>lua</code> находится высоко даже в режиме интерпретации.</p><p>Первые стадии трансформации текста скрипта — лексический и синтаксический анализ. Текст разбивается на отдельные лексемы/токены, которые затем собираются парсером во что-то, что можно интерпретировать. Чаще всего это или поток последовательных инструкций (байт код для интерпретатора) в случае с <code>lua</code>, или AST(дерево, которое будет обходить интерпретатор) в случае с <code>daScript</code>.</p><p>Я не буду заострять внимание на отличиях типов интерпретаторов, детально можно прочитать про это в книге <a href="http://craftinginterpreters.com/" target="_blank" rel="noopener">Crafting Interpreters</a>, с примерами интерпретаторов обоих типов (или даже более <a href="https://gameprogrammingpatterns.com/bytecode.html" target="_blank" rel="noopener">сжато</a>). Интереснее следующий шаг — посмотреть почему именно эти интерпретаторы быстрее других.</p><p>“Традиционный” подход к дизайну языков с байт-кодом — динамическая типизация, управление памятью с помощью подсчёта ссылок/garbage collector, небольшой набор базовых типов (примитивы + строки + массивы + функции/замыкания + таблицы, опционально - итераторы, корутины, исключения). Из таблиц (пары ключ-значения) можно построить объекты и “собрать” классы — некоторые ключи таблицы делаем зарезервированными, вызывая их для создания/удаления объектов, ссылки на родительскую таблицу, перегрузки операторов и т.п.</p><p>Возможные оптимизации:</p><ul><li>Так как чаще всего данные группируются в объекты (представленные таблицами) — то очень важна быстрая реализация этих хеш-таблиц, в чём lua традиционна считается хорошей.</li><li><a href="http://craftinginterpreters.com/optimization.html#nan-boxing" target="_blank" rel="noopener">Nan-tagging</a> — распространённая паковка базовых типов языка виртуальной машины в тип <code>double</code>. Возникает отчасти из желания хранить примитивные типы в той же форме, что и сложные — в динамически типизированном языке нужно где-то сохранить в том числе и тип аргумента, чтобы знать, как его интерпретировать, и при этом не хочется иметь оверхед для примитивных типов. </li></ul><p>Отчасти из этой оптимизаций возникает ограничение на количество базовых типов языка — с точки зрения скриптового языка два класса будут иметь разные типы, но для интерпретатора виртуальной машины они оба будут представлены типом “таблица”, и отличаться только значением ключа “название класса”. Также любой вызов метода означает поиск его в таблице. Ещё один минус — требование “раскодировать” аргументы из запакованной формы при взаимодействии с нативным кодом, из-за чего замедляется передача управления в хост язык и обратно. Т.е. нельзя оптимизировать код, просто переносом мелких функций в хост-язык — необходимо переписывать сразу большие куски кода.</p><ul><li>Поиск частых паттернов в инструкциях. <a href="http://craftinginterpreters.com/methods-and-initializers.html#optimized-invocations" target="_blank" rel="noopener">Optimizing invocation</a> — пример слияния пары инструкций “получение метода класса + вызов метода”. В общем случае, метод может быть получен не для вызова, а для сохранения в переменную, но чаще всего вызывается напрямую, так что две инструкции, идущие подряд, можно “слить” в одну. В lua вроде не применяется, но повсеместно юзается в daScript, примеры приведу дальше. Оптимизация известна под названиями <code>Instruction fusion</code> или <code>Super-instructions</code>.</li></ul><h2 id="Tracing-JIT"><a href="#Tracing-JIT" class="headerlink" title="Tracing JIT"></a>Tracing JIT</h2><p>Основная сила lut-jit - just-in-time компиляция. Каждый раз, при вызовах функций и циклов (<code>thermal function/cycle</code>), интерпретатор подсчитывает количество таких вызовов, и таким образом, определяет “горячий” код. Алгоритм подсчёта (NLF region-selection) также умеет обнаруживать вложенные циклы и вызовы.</p><p>При достижении предельного количества вызовов, интерпретатор выполняет отмеченный участок кода с “трассированием”, то есть кроме выполнения инструкции дополнительно сохраняет её же в список инструкций — уже на другом байт-код языке (intermediate representation, <a href="http://webcache.googleusercontent.com/search?q=cache:U5V-zQuM-ikJ:wiki.luajit.org/SSA-IR-2.0&amp;cd=1&amp;hl=ru&amp;ct=clnk&amp;gl=am" target="_blank" rel="noopener">спек</a>).</p><p>После записи всех инструкций из IR генерируется машинный код, и следующий вызов этого участка кода уже приведёт к тому, чтобы будет вызвана нативная версия кода. Подмена способов вызова функции реализована с помощью патчинга оп-кодов байт-кода lua (call gates).</p><p>Генерация нативного машинного кода разрешена не на всех платформах/ОС (память для выполнения нативного кода защищена от записи), поэтому недоступна для части платформ. Также нативный код для различных архитектур отличается, поэтому добавление новой платформы может требовать написания отдельного генератора кода.</p><p><a href="http://lua-users.org/lists/lua-l/2009-11/msg00089.html" target="_blank" rel="noopener">Список особенностей</a> jit-компилятора lua:</p><ul><li>оптимизация IR-кода - сворачивание и выбрасывание неиспользуемых блоков</li><li>при возврате из нативной части кода в интерпретируемую, оптимизиуется восстановление состояния виртуальной машины, сохраняются “дифы” между состояниями</li><li>типизация аргументов, при трассировании кода записываются реальные типы переменных</li></ul><p>Тривиальный пример, с неизвестными типами аргументов:<br><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(t, k)</span></span></span><br><span class="line">    <span class="keyword">return</span> t[k]</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><br>Может быть интерпретирован различными способами - t может быть таблицей или любым типом, у которого установлена метатаблица, k - числом, строкой или любым типом, и даже [] - метаметодом. В принципе, этот код может со всеми возможными комбинациями задействовать половину ветвей интерпретации ядра lua. Но если трассирующий компилятор запишет реально используемые типы, то он может сгенерировать быстрый нативный код, к примеру индексации массива (сгенерировав предварительно код проверки типов аргументов). Это даёт ускорение ~3 раза, по <a href="https://staff.fnwi.uva.nl/h.vandermeer/docs/lua/luajit/luajit_intro.html#:~:text=As%20the%20name%20says%20LuaJIT,are%20not%20compiled%20at%20all." target="_blank" rel="noopener">замерам</a> авторов.</p><h2 id="daScript"><a href="#daScript" class="headerlink" title="daScript"></a>daScript</h2><p>daScript серьёзно отличается от “традиционных” скриптовых языков.</p><p>В первую очередь — на выходе синтаксического анализатора получается на байт-код, а абстрактное синтаксическое дерево, причём типизированное.</p><p>Типизация немного усложняет изучение языка, но позволяет избавиться от огромного количества ошибок типов. Если рассмотреть синтетический пример на lua, то обнаружить фактические типы аргменутов t и k может быть сложно в цепочке вызовов, а проверить их корректность можно только в рантайме. Представьте, что <code>foo</code> ожидает в качестве t список из строк и выбирает из него первый элемент (допустим, сортированный список допустимых фраз персонажа игры). Список составляется и сортируется динамически. На каком-то этапе в ходе рефактора программист добавляет дополнительную функцию в цепочку вызовов, которая проверяет граничное условие (не то, чтобы это хороший код или пример, но подобную ошибку с подменой списка строкой встречал много раз):</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkIfGameOver</span><span class="params">(t, k)</span></span></span><br><span class="line">    <span class="keyword">if</span> life &lt;= <span class="number">0</span> <span class="keyword">then</span> </span><br><span class="line">        foo(<span class="string">"game over!"</span>, k) //вместо foo([<span class="string">"game over!"</span>], k)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        foo(t, k)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>Если условие редкое, и код кажется программисту слишком тривиальным, чтобы его проверить в рантайме, баг может остаться незамеченным для ревьюера, а то и для QA. В типизированном языке ошибка бы скорее всего обнаружилась компилятором.</p><p>Представление в виде AST, а не байт-кода, упрощает генерацию и анализ кода, например — с ним работают <a href="/blog/1547564887/" title="макросы">макросы</a>, а также упрощается написание тулзов, анализирующих код.</p><p>На уровне AST намного удобнее проводить оптимизации, в этот момент интерпретатор иметь достаточно много информации о коде. <code>daScript</code> позволяет изучить код на каждом шаге оптимизации. Простейший пример:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//log_optimization_passes - выводит результаты всех промежуточных стадий оптимизации AST</span></span><br><span class="line">options optimize=<span class="literal">true</span>, log_optimization_passes = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">def test(cond, a, b)</span><br><span class="line">    <span class="keyword">if</span> cond</span><br><span class="line">        <span class="keyword">return</span> a + b</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main()</span><br><span class="line">    print(<span class="string">"&#123;test(true, 2, 2)&#125;\n"</span>)</span><br></pre></td></tr></table></figure><p>После стадии <code>CONST_FOLDING</code> можно увидеть, что AST “свернулся” до:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;4&#125;\n"</span>)</span></span></span><br></pre></td></tr></table></figure></p><p>После оптимизаций <code>daScript</code> <strong>не интерпретирует AST</strong> и <strong>не генерирует</strong> байт-код. Вместо этого генерируется <a href="https://github.com/GaijinEntertainment/daScript/blob/master/src/ast/ast_simulate.cpp#L2912" target="_blank" rel="noopener">дерево симуляции</a>. На этом этапе также происходит оптимизация — AST ноды “отбрасывают” ненужную для симуляции информацию, например, информацию о типах (она больше не нужна, типы известны и статически проверены на уровне AST), и умеют генерировать более оптимизированные частные случаи (<a href="simulate">симуляция</a> simulate-ноды из ast-ноды ifThenElse, ветка <em>//good old if</em> - дефолтный вариант, остальные — оптимизированные).</p><p>Базовый класс нод simulate-ноды<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SimNode</span> &#123;</span></span><br><span class="line">    SimNode ( <span class="keyword">const</span> LineInfo &amp; at ) : debugInfo(at) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> SimNode * <span class="title">copyNode</span> <span class="params">( Context &amp; context, NodeAllocator * code )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> vec4f <span class="title">eval</span> <span class="params">( Context &amp; )</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> SimNode * <span class="title">visit</span> <span class="params">( SimVisitor &amp; vis )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> *      <span class="title">evalPtr</span> <span class="params">( Context &amp; context )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span>        <span class="title">evalBool</span> <span class="params">( Context &amp; context )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span>       <span class="title">evalFloat</span> <span class="params">( Context &amp; context )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span>      <span class="title">evalDouble</span> <span class="params">( Context &amp; context )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int32_t</span>     <span class="title">evalInt</span> <span class="params">( Context &amp; context )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">uint32_t</span>    <span class="title">evalUInt</span> <span class="params">( Context &amp; context )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int64_t</span>     <span class="title">evalInt64</span> <span class="params">( Context &amp; context )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">uint64_t</span>    <span class="title">evalUInt64</span> <span class="params">( Context &amp; context )</span></span>;</span><br><span class="line">    LineInfo debugInfo;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">rtti_node_isSourceBase</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>;  &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">rtti_node_isBlock</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">rtti_node_isInstrument</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">rtti_node_isInstrumentFunction</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">rtti_node_isJit</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~SimNode() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>У Sim-ноды есть универсальная функция <code>eval</code>, и частные случаи <code>evalXXX</code> для того, чтобы не делать лишние касты. <code>vec4f</code> в данном случае можно рассматривать не только как конкретный тип (очень полезный именно в геймдеве), но и как 128-битный “передатчик” данных, который в случае необходимости кастится в другим типам с помощью библиотеки <a href="https://github.com/GaijinEntertainment/vecmath" target="_blank" rel="noopener">vecmath</a>, в которой реализован быстрый каст для различных архитектур (HAL) вызовом интринсик-функций.</p><p>Сравнение дерева симуляции и байт-код представления:</p><ul><li>Ноды лежат в памяти плоско в линейном аллокаторе, как и байт-код</li><li>Обход дерева не требует интерпретации. Т.е. 1) не нужно сопоставлять байт-коду функцию, и 2) связь между нодами осуществляется по указателям, а не байт-кодом команд передачи управления/через регистры/стек</li><li>Типы данных хранятся также, как и в нативном коде, нет кодирования/декодирования аргументов, результатов</li><li>Нет ограничения на количество типов нод, когда bind-ится функция, то создаётся кастомная нода, за счёт чего вызов функций быстрый</li></ul><p>С таким дизайном возможны оптимизации добавлением частных случаев новых типов нод:</p><ul><li>Упомянутые выше уникальные типы нод для вызова функции</li><li>Специализированные версии нод для отдельных типов для чуть более быстрой математики, конкретных специализаций контейнеров (<a href="https://github.com/GaijinEntertainment/daScript/blob/master/include/daScript/simulate/sim_policy.h" target="_blank" rel="noopener">SimPolicy</a>)</li><li>Из-за того, что можно не экономить на типах нод, можно в полную силу использовать fusion нескольких нод в одну специализированную</li></ul><p>Цена большого количества специализированных версий нод — увеличение размера бинарника приложения, поэтому уровень “сплава” нескольких нод в одну регулируется через дефайн <code>DAS_FUSION</code>. 0 - не включать fusion-движок, 1 - “нормальный” уровень слияния, 2 - максимальное количество специализированных нод.</p><p>Пример работы fusion-движка:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">options log_nodes=<span class="literal">true</span>, optimize=<span class="literal">false</span></span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>] <span class="comment">//оставляем, чтобы оптимизатор не выбросил функцию</span></span><br><span class="line">def test(a, b)</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br></pre></td></tr></table></figure></p><p>Если изменить значение <code>optimize=true</code>, можно увидеть разницу в количестве нод:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; неоптимизированная версия, 6 нод</span><br><span class="line">(Return (Add_TT&lt;int&gt; (Ref2Value_TT&lt;int&gt; (GetArgumentRef #0)) (Ref2Value_TT&lt;int&gt; (GetArgumentRef #1))))</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; оптимизированная версия, 2 ноды</span><br><span class="line">(Return (AddArgArg_TT&lt;int&gt; #0 #1))</span><br></pre></td></tr></table></figure><p>Резюмируя — на скорость в режиме симуляции тут влияют:</p><ul><li>линейное расположение в памяти</li><li>отсутствие оверхеда интерпретации байт-кода</li><li>быстрый интероп с хост-языком - отсутствие конвертации аргументов, быстрые вызовы функций</li><li>уменьшение количества нод - проходы оптимизации, специализированные и объединённые ноды</li></ul><p>В сумме это позволяет в режиме интерпретации (без jit, и aot) обогнать самые быстрые интерпретаторы байт-кода с jit-компиляцией.</p><p>Опционально ещё:</p><ul><li>возможность с помощью макросов обработать AST и изменить семантику объявлений для более оптимального расположения в памяти</li><li>переопределить для своих типов кастомный <code>simulate</code> для генерации кастомного быстрого кода для их обработки</li></ul><h2 id="daJIT"><a href="#daJIT" class="headerlink" title="daJIT"></a>daJIT</h2><p>Кроме режима интерпретации, daScript тоже немного умеет jit-титься:<br><a href="https://github.com/borisbat/dasXbyak" target="_blank" rel="noopener">dasXbyak</a> - для x84/x64 (приостановлен, можно допилить при наличии энтузиазма)<br><a href="https://github.com/borisbat/dasLLVM" target="_blank" rel="noopener">dasLLVM</a> - для всего что может llvm (пока на начальной стадии, перспективнее)<br>jit-компиляция разрешена на PC/Unix/Mac/Web, запрещена на телефонах и консолях (везде, где разрешен запуск только подписанного кода)</p><p>А также хорошо AoT транспилироваться в C++-код. Перегонка “руками”:<br><code>daScript.exe -aot test.das test.das.cpp</code><br>или на уровне <a href="https://github.com/GaijinEntertainment/daScript/blob/master/examples/tutorial/CMakeLists.txt#L36" target="_blank" rel="noopener">cmake сборки</a>, настройки AoT кастомизируется на уровне отдельных модулей, функций и типов.<br><a href="/blog/1160489034/" title="daScript in imaginery world">daScript in imaginery world</a> - немного про прирост скорости от AoT-прекомпиляции. В отличие от jit, этим можно воспользоваться на всех платформах.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Устройство виртуальных машин для самых быстрых скриптовых языков — &lt;a href=&quot;https://luajit.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;lua-jit&lt;/a&gt; и &lt;a href=&quot;https://dascript.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;daScript&lt;/a&gt;.&lt;br&gt;Более развёрнутое продолжение беглой заметки &lt;a href=&quot;/blog/1067581840/&quot; title=&quot;daScript - скорость&quot;&gt;daScript - скорость&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="lua" scheme="http://spiiin.github.io/tags/lua/"/>
    
      <category term="dascript" scheme="http://spiiin.github.io/tags/dascript/"/>
    
      <category term="llvm" scheme="http://spiiin.github.io/tags/llvm/"/>
    
  </entry>
  
  <entry>
    <title>Важность простых языков</title>
    <link href="http://spiiin.github.io/blog/3121981810/"/>
    <id>http://spiiin.github.io/blog/3121981810/</id>
    <published>2022-10-09T16:52:06.000Z</published>
    <updated>2022-10-09T21:44:57.290Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Про важность использования простых языков в геймдеве и не только.</p><a id="more"></a><p><a href="https://kristoff.it/blog/why-go-and-not-rust/" target="_blank" rel="noopener">Why Go and not Rust?</a> - статья вообще про преимущества простого go перед более сложным rust в блоге про zig :) Но в ней есть развернутый ответ на вопрос “почему обычно в корпоративном мире качество кода оставляет желать лучшего. В мире геймдева (там где я видел, во всяком случае), ситуация такая же — длительные в разработке проекты с большим количеством кода и широкой предметной областью, в которой эксперты предметной области слабо разбираются в технологии, а программисты — в особенностях предметной области, поэтому необходим <em>процесс</em>.</p><h2 id="Процесс"><a href="#Процесс" class="headerlink" title="Процесс"></a>Процесс</h2><p>Разработка больших систем — это всегда про масштаб. Понятие масштаба касается не количества данных или пользователей, а количества фич (scope) и процесса разработки. Опыт масштабирования как его понимают программисты часто неприменим к такому типу сложности, нетехнические трудности перевешивают технические.</p><p>Чтобы разобраться с масштабированием, менеджеры пытаются настроить процесс разработки, и привлекают экспертов и аналитиков, которые “знают как правильно” побороть сложности масштабирования.</p><p>Ссылки про “процессы” в геймдеве:<br><a href="https://sim0nsays.livejournal.com/38168.html" target="_blank" rel="noopener">Древние логи из IRC</a>, про то, как в геймдеве в принципе приходили к тому, чтобы разработка стала хоть как-то предсказуемее (если не ошибаюсь, обсуждается <code>Midway</code>).<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[09:17] &lt;look4awhile&gt; когда технические сложности - это всего-лишь технические сложности</span><br><span class="line">[09:17] &lt;look4awhile&gt; а оценивается работа продюсера</span><br><span class="line">[09:18] &lt;look4awhile&gt; наглядный пример, из последнего - дум-3.</span><br></pre></td></tr></table></figure><br>При этом забавно, что описанный там подход, начало 2000х — как будто попытка адаптировать к геймдеву методы, разработанные еще в 80х.</p><p><a href="/blog/1687824628/" title="Паттерны организации разработки уровней игр">Паттерны организации разработки уровней игр</a> — мои попытки обнаружить интересные идеи среди принятых сейчас Agile/Lean подходов.</p><p>Из этого взаимодействия бизнеса/управления/команды возникает несколько хорошо известных “причуд” корпоративной разработки.</p><h2 id="Джуниоры"><a href="#Джуниоры" class="headerlink" title="Джуниоры"></a>Джуниоры</h2><p>В командах всегда много джуниоров, которые учатся программировать на работе. И большинству из них не повезло найти работу, где они действительно могут научиться полезным практикам. Код больших систем далёк от того, что они видели в универе, или в своих в своих пет-проджектах.</p><p>Бывает, что джуниор вынужден реализовывать фичу, вообще впервые сталкиваясь с какой-либо технологией. Примеры из мобильной разработки — интеграция sdk с использованием нативных языков (java/kotlin/obj c/swift) в C++ код, программирование на gpu, скриптовые языки.</p><h2 id="Код-быстро-становится-запутанным"><a href="#Код-быстро-становится-запутанным" class="headerlink" title="Код быстро становится запутанным"></a>Код быстро становится запутанным</h2><p>Причин множество.</p><p>Для создания сложных систем требуется время, за которое приходят и уходят разработчики или целые команды. Постоянно рефакторить или переписывать код невозможно, так как время на разработку сильно ограниченно, так что разные части системы всегда будут находиться в очень разном состоянии по качеству и стилю кода.</p><p>Команды, работающие независимо, неизбежно будут создавать избыточный код.</p><p>Из-за сжатых сроков также кривой код попадает в релиз. “Когда-нибудь перепишем”.</p><p>С течением времени предметная область меняется, что неизбежно делает недействительными старые предположения и, следовательно, приводит к утечке абстракций. Чем сложнее абстракция, тем выше риск того, что она станет проблемой, когда гейм-дизайнер вернется с серьезным запросом на изменение. Проект никогда не может быть достаточно гибким, чтобы учесть все возможные пожелания и фантазии. Бизнес может прийти с запросами вроде “ситуация на рынке изменилась, меняем жанр/платформу/удваиваем количество фич”.</p><h2 id="Пайплайн-устаревший-жуткий"><a href="#Пайплайн-устаревший-жуткий" class="headerlink" title="Пайплайн устаревший/жуткий"></a>Пайплайн устаревший/жуткий</h2><p>Большое количество старого кода привязывает к определенным подходам, серьёзные технологические решения по улучшению принимать сложно, и не все менеджеры готовы вообще на это идти. Многие избегают рисков, результате чего происходят попытки копирования действий успешных конкурентов (или того, что, по утверджениям аналитиков, делают успешные конкуренты).</p><h2 id="Что-с-этим-делать"><a href="#Что-с-этим-делать" class="headerlink" title="Что с этим делать"></a>Что с этим делать</h2><p>Что может предоставить язык программирования, чтобы бороться с перечисленными проблемами?</p><p>Краткий ответ — быть максимально <strong>простым</strong> (только не примитивным, а именно незапутанным), <strong>гибким</strong> (не настраиваемым на все случаи жизни, а готовым к быстрым изменениям), и позволяющим мгновенно <strong>проверять гипотезы</strong>. </p><p>Именно возможность писать код так, чтобы он соответствовал этим критериям стоит использовать при сравнении языков между собой — они влияют на конечную продуктивность команды (продуктивность это не просто скорость, с которой можно делать фичи, а способность сделать продукт, который будет приносить деньги). Язык стимулирует писать код определенным способом — и этот способ может быть общепринятым для одного языка, но контр-интуитивным для другого. </p><p>Идти “против языка” при этом достаточно сложно в перспективе. Как в рамках одного проекта, так и распространяя паттерны работы — создание библиотек/тулзов/общепринятных подходов к разработке. Несколько случайных примеров не прижившихся или экспериментальных идей на C++ из русского геймдева (это не какие-то особенно продвинутые идеи, просто как пример подхода “против языка”, отчасти не прижившихся из-за необычности, отчасти из-за того, что это “не касается” языка, не выразимо на языке == будет отброшено, программист навряд ли наткнётся на такие подхода, если будет искать “как реализовать XXX”; старые ссылки выбраны отчасти потому, что я видел развитие каких-то из этих идей в движках, отчасти потому что, в современной геймдев культуре менее принято делиться интересными подходами, во всяком случае, если мониторить конференции и доклады, отчасти потому, что сохранились в коллекции ссылок):<br><a href="https://gamedev.ru/code/articles/?id=4234" target="_blank" rel="noopener">Compile-time vs run-time: назад в будущее</a> — генерация кода из данных в “build-time”<br><a href="https://sim0nsays.livejournal.com/27342.html" target="_blank" rel="noopener">Component-oriented design на консолях, лобзиком по шаблонам</a> — распиливание классов на компоненты на шаблонах<br><a href="https://plakhov.livejournal.com/201698.html" target="_blank" rel="noopener">Data structures baking</a> — чтение структур языка с диска без кода инициализации (еще <a href="https://probablydance.com/2015/12/19/quickly-loading-things-from-disk/" target="_blank" rel="noopener">пара</a> <a href="https://www.gamedeveloper.com/programming/delicious-data-baking" target="_blank" rel="noopener">ссылок</a>)<br><a href="https://plakhov.livejournal.com/101443.html" target="_blank" rel="noopener">Дзен-3, скрипт</a> — триггеры с минимальным функционалом вместо скриптов, создание минимального интерпретатора dsl на стороне игры. Хех, ну и почти <a href="https://twitter.com/YarKravtsov/status/1566004371044827137" target="_blank" rel="noopener">блюпринты</a> в движке SkyForge</p><p>При этом, почти любые современные языки дают возможность писать код, используя различныме парадигмы, так что команда должна уметь использовать язык именно так, чтобы эти свойства реально проявлялись.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Про важность использования простых языков в геймдеве и не только.&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="dev_method" scheme="http://spiiin.github.io/tags/dev-method/"/>
    
  </entry>
  
  <entry>
    <title>LLVM - обзор</title>
    <link href="http://spiiin.github.io/blog/315556844/"/>
    <id>http://spiiin.github.io/blog/315556844/</id>
    <published>2022-10-09T12:41:32.000Z</published>
    <updated>2022-11-11T13:44:20.326Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Попытка очень бегло пройтись по тому, что можно найти в LLVM.<br><a id="more"></a></p><h2 id="Инфраструктура-для-авторов-языков-программирования"><a href="#Инфраструктура-для-авторов-языков-программирования" class="headerlink" title="Инфраструктура для авторов языков программирования"></a>Инфраструктура для авторов языков программирования</h2><p>LLVM - это огромный проект. Чаще всего, когда говорят о нём - имеют ввиду возможность написать только фронтэнд для какого-нибудь языка - из языка в биткод llvm. Дальше автоматом можно получить следующие стадии трансформации: из <code>ir llvm -&gt; оптимизации различные -&gt;mir под конкретные платформы -&gt; бинарный код под платформы</code>.</p><p>Биткод может быть представлен в 3х формах: текстовый псевдоассемблер, бинарный формат, и in-memory api, с помощью которого можно нагенерить всё с помощью кода, в том числе сделать jit-компилятор.</p><p>В теории, jit быстрее статической компиляции, потому что:</p><ul><li>может задействовать динамические данные о том, какой код “горячее” (статическому компилятору тоже можно передать эту инфу, полученную уже после запуска приложения, при повторной компиляции/линковке)</li><li>может инлайнить больше, чем статический - например, библиотечные функции, которые иначе нельзя</li><li>может подстроиться под особенностью архитектуры или ос</li></ul><p>Java vm, .net или js-двики чаще всего jit так или иначе делают, быстрые версии интерпретаторов тоже. Jit-компиляция большая отдельная тема.<br><a href="https://github.com/borisbat/dasLLVM" target="_blank" rel="noopener">dasLLVM</a> — пример jit-компиляции из <a href="https://spiiin.github.io/tags/dascript/">daScript</a> на LLVM, пока на начальной стадии.</p><p>Если хочется погрузиться в теорию компиляции, можно читать что-нибудь типа:</p><ul><li>Learn LLVM 12</li><li>Классическую “Компиляторы: принципы, технологии и инструменты”</li><li><a href="http://craftinginterpreters.com/" target="_blank" rel="noopener">Crafting Interpreters</a></li></ul><p>Последняя интересна тем, что нацелена на практику, от автора <code>Game Programming Patterns</code>, а также нескольких скриптовых языков: <a href="https://wren.io/" target="_blank" rel="noopener">wren</a>, <a href="https://magpie-lang.org/" target="_blank" rel="noopener">magpie</a>. В его блоге также много <a href="https://journal.stuffwithstuff.com/category/language/" target="_blank" rel="noopener">статей</a> об устройстве языков программирования. В третьей части много продвинутого материала об оптимизации вызовов функций, замыканий и методам ускорения интерпретатора байт кода.</p><p>Несколько нестандартных применений:</p><ul><li><a href="https://andrewkelley.me/post/jamulator.html" target="_blank" rel="noopener">Statically Recompiling NES Games into Native Executables with LLVM and Go</a> - попытка перекомпилировать байт-код для NES в LLVM-биткод, без эмуляции от автора языка <code>Zig</code>, не очень успешная, так как в NES ассемблере очень много трюков, которые требуют реальной эмуляции особенностей железа (синхронизация с процессором, прыжки в середину инструкции, самомодифицирующийся код).</li><li>“Компиляция данных” — создание микроязыков для того, чтобы добавить возможность “положить” в игровые ресурсы код.</li></ul><p><a href="https://www.youtube.com/watch?v=3QQuhL-dSys" target="_blank" rel="noopener">2019 LLVM Developers’ Meeting: J. Paquette &amp; F. Hahn “Getting Started With LLVM: Basics”</a> — доклад про IR LLVM<br><a href="https://llvm.org/docs/WritingAnLLVMPass.html" target="_blank" rel="noopener">Writing an LLVM Pass</a> — как написать свой проход LLVM</p><h2 id="Clang-фронтэнд-компилятор-C"><a href="#Clang-фронтэнд-компилятор-C" class="headerlink" title="Clang - фронтэнд компилятор C++"></a>Clang - фронтэнд компилятор C++</h2><p>Отдельный проект — фронтэнд для С++ (а также С и  Objective C/C++) - <code>clang</code>. Собственно, у него есть несколько ключей, чтобы получать промежуточные представления кода, но это тоже прикладным разработчикам не особо надо чаще всего. Один из вариантов его использования - написание своих проходов при компиляции. Cобирается плагин в dll/dylib/a и компилятору clang ключом передаётся, чтобы он дёргал функции-колбека из этого плагина при каждой компиляции кода.</p><p>Apple в xcode clang не совсем из стандартной репы собирала, поэтому он у них с такими плагинами не работает, но в принципе пересобрав самому из исходников можно и им под ios код генерить. Вот <a href="https://railsware.com/blog/creation-and-using-clang-plugin-with-xcode/" target="_blank" rel="noopener">“hello world”</a> с плагинами. Таким способом можно решать что-то типа “хочу, чтобы если в лямбду кто-то захватил this неявно, то компиляция крешилась с сообщением, потому что в половине случаев автор забыл проверить время жизни this и упадёт в рантайме” (или другие правила, обычно написанные кровью в code convention проекта, которые невозможно выразить семантикой C++).</p><p>Так редко кто делает, но вот примеры проектов с набором плагинов, дополнительно проверяющих код:<br><a href="https://github.com/LibreOffice/core/tree/master/compilerplugins/clang" target="_blank" rel="noopener">libreoffice</a><br><a href="https://chromium.googlesource.com/chromium/src.git/+/master/docs/clang.md#using-plugins" target="_blank" rel="noopener">chrome</a> + <a href="https://ehsanakhgari.org/blog/2015-12-07/c-static-analysis-using-clang/" target="_blank" rel="noopener">Статья</a><br><a href="https://hg.mozilla.org/mozilla-central/file/tip/build/clang-plugin/" target="_blank" rel="noopener">firefox</a></p><p>Более основательный туториал про то, как писать плагины, и что с их помощью можно делать<br><a href="https://github.com/banach-space/llvm-tutor" target="_blank" rel="noopener">https://github.com/banach-space/llvm-tutor</a></p><h2 id="API-для-работы-с-Clang"><a href="#API-для-работы-с-Clang" class="headerlink" title="API для работы с Clang"></a>API для работы с Clang</h2><p>Особенность компилятора Clang — он предоставляет несколько API для того, чтобы можно было получать информацию о коде программы.</p><p>К примеру, можно пропарсить заголовочный файлы и автоматом нагенерить привязок к другим языкам. Из особенностей - не очень быстро работает (поэтому некоторые предпочитают велосипедить свои парсеры, передавая мета-информацию комментариями), и не очень хорошо работает с сложным шаблонным кодом. Но в целом можно целиком какую-нибудь либу привязать им к другому языку с небольшим количеством ручной работы.</p><p>Один из интерфейсов - <code>libclang</code>, библиотека на C++, к которой есть привязки на других языках.</p><p>Примеры использования <strong><code>генерации привязок</code></strong>:<br><a href="/blog/4090909622/" title="daScript: C++ auto-bindings, msgpack">daScript: C++ auto-bindings, msgpack</a> — генерация из daScript привязок к <code>msgpack</code><br><a href="/blog/500729544/" title="daScript: C++ auto-bindings, assimp">daScript: C++ auto-bindings, assimp</a> — генерация из daScript привязок к <code>assimp</code>, без написания кода (почти)<br>(с помощью <a href="https://github.com/GaijinEntertainment/daScript/tree/master/modules/dasClangBind" target="_blank" rel="noopener">dasClangBind</a>)<br><a href="https://floooh.github.io/2020/08/23/sokol-bindgen.html" target="_blank" rel="noopener">Automatic Language Bindings</a> — генерация из Python привязок к <code>solol</code> для различных языков (zig/nim/odin)</p><p><strong><code>Интерактивное получение данных из кода</code></strong><br><a href="https://root.cern/cling/" target="_blank" rel="noopener">Cling</a> - интерактивная комплиляция С++ кода, для использования с инструментами типа <code>Jupyter</code><br><a href="https://cppyy.readthedocs.io/en/latest/examples.html" target="_blank" rel="noopener">cppyy</a> - привязка cling к python, работает в том числе и под windows</p><p><strong><code>Написание тулзов для IDE</code></strong><br><a href="https://github.com/def-/ycmd" target="_blank" rel="noopener">ycmd</a> - сервер автодополнения кода для различных IDE<br><a href="https://marketplace.visualstudio.com/items?itemName=RamonViladomat.StructLayout" target="_blank" rel="noopener">StructLayout</a> - расширение для VS code, которое может показать то, как компилятор будет размещать структуру в памяти (надо помнить, что libclang, который использует это расширение, должен быть той же версии, что и сам компилятор, который будет генерировать код).</p><p>Можно также решать всякие задачи вроде “отсортировать функции по количеству байт и напечатать 10 самых больших”.</p><p><strong><code>Туториалы, как научиться пользоваться</code></strong><br><a href="https://jonasdevlieghere.com/understanding-the-clang-ast/" target="_blank" rel="noopener">Understanding the Clang AST</a> - 3 API для работы с AST в clang<br><a href="https://clang.llvm.org/docs/IntroductionToTheClangAST.html" target="_blank" rel="noopener">Introduction to the Clang AST</a> - ссылки на диаграммы классов AST, во что трансформируется код на C++<br><a href="https://clang.llvm.org/docs/RAVFrontendAction.html" target="_blank" rel="noopener">How to write RecursiveASTVisitor based ASTFrontendActions</a> - пример того, как сделать свой визитор для AST<br><a href="https://clang.llvm.org/docs/LibASTMatchersTutorial.html" target="_blank" rel="noopener">Tutorial for building tools using LibTooling and LibASTMatchers</a> - использование других интерфейсов для написания визиторов<br><a href="https://www.youtube.com/watch?v=VqCkCDFLSsc" target="_blank" rel="noopener">The Clang AST - a Tutorial</a> - доклад всё про то же<br><a href="http://www.goldsborough.me/c++/clang/llvm/tools/2017/02/24/00-00-06-emitting_diagnostics_and_fixithints_in_clang_tools/" target="_blank" rel="noopener">Emitting Diagnostics in Clang</a> — вывод своих сообщений об ошибках</p><p>В каком-то смысле, интерфейс для того, чтобы иметь доступ к AST языка, необходим из-за того, что этого не умеет сам C++ - шаблоны умеют заставить компилятор произвести эффекты, но не имеют доступа к самому коду. В языках вроде <code>daScript</code> аналогичную плагинам компилятора работы могут выполнять макросы.<br><a href="https://github.com/GaijinEntertainment/daScript/blob/master/daslib/jobque_boost.das#L142" target="_blank" rel="noopener">Пример</a> макроса в daScript, применяемого к замыканию и выполняющего дополнительную работу, если в замыкание передаются примитивы синхронизации <code>Channel</code> или <code>Job</code>.<br><a href="/blog/1547564887/" title="daScript macro">daScript macro</a> — пример генерации AST daScript из кода<br><a href="/blog/4046309382/" title="daScript macro - 2">daScript macro - 2</a> — пример работы с DSL, упрощающим написание AST</p><p>Также, для Clang, чтобы упростить работу с C++ AST, существует DSL для составления запросов - <strong><code>clang query</code></strong><br><a href="https://www.youtube.com/watch?v=yqi8U8Q0h2g" target="_blank" rel="noopener">2019 EuroLLVM Developers’ Meeting: S. Kelly “The Future of AST Matcher-based Refactoring</a> - использование запросов clang query для визуальной работы с кодом, расширение godbolt + интерфейс к qt контролам<br><a href="https://www.youtube.com/watch?v=38tYYrnfNrs" target="_blank" rel="noopener">Extending clang-tidy in the Present and in the Future - Stephen Kelly</a> - и для модификации кода/рефакторинга</p><p>Ещё один способ использования — глубже изучить, как устроена какая-либо абстракция в языке<br><a href="https://www.youtube.com/watch?v=8C8NnE1Dg4A" target="_blank" rel="noopener">CppCon 2016: Gor Nishanov “C++ Coroutines: Under the covers”</a> — реализация корутин в новом стандарте C++<br><a href="https://llvm.org/docs/LangRef.html" target="_blank" rel="noopener">LLVM Language Reference Manual</a> - справка по псевдо-ассемблеру LLVM</p><h2 id="Исходный-код-и-архитектура-LLVM"><a href="#Исходный-код-и-архитектура-LLVM" class="headerlink" title="Исходный код и архитектура LLVM"></a>Исходный код и архитектура LLVM</h2><p><a href="http://rus-linux.net/MyLDP/BOOKS/Architecture-Open-Source-Applications/Vol-1/llvm.html" target="_blank" rel="noopener">Глава в книге “Архитектура приложений с открытым исходным кодом”</a><br><a href="https://blog.regehr.org/archives/1453" target="_blank" rel="noopener">A Tourist’s Guide to the LLVM Source Code</a> - обзор исходников<br><a href="https://llvm.org/docs/ProgrammersManual.html" target="_blank" rel="noopener">Обзор используемых структур данных</a> + <a href="https://llvm.org/devmtg/2014-04/PDFs/LightningTalks/data_structure_llvm.pdf" target="_blank" rel="noopener">Ещё один</a></p><h2 id="LLDB"><a href="#LLDB" class="headerlink" title="LLDB"></a>LLDB</h2><p>Отладчик, также использующий инфраструктуру llvm. Одна из интересных возможностей — наличие <a href="https://lldb.llvm.org/python_reference/" target="_blank" rel="noopener">python api</a>.</p><p>Пример использования API:<br><a href="/blog/1170009669/" title="Расположение объектов C++ в памяти. Часть 2">Расположение объектов C++ в памяти. Часть 2</a> — рекурсивный обход структур, для запроса из отладчика выравнивания их в памяти, с отображением “дырок”</p><h2 id="Общие-ссылки"><a href="#Общие-ссылки" class="headerlink" title="Общие ссылки"></a>Общие ссылки</h2><p><a href="https://llvm.org/devmtg/" target="_blank" rel="noopener">https://llvm.org/devmtg/</a> + <a href="https://www.youtube.com/c/LLVMPROJ/playlists" target="_blank" rel="noopener">https://www.youtube.com/c/LLVMPROJ/playlists</a><br><a href="https://blog.llvm.org/" target="_blank" rel="noopener">https://blog.llvm.org/</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Попытка очень бегло пройтись по тому, что можно найти в LLVM.&lt;br&gt;
    
    </summary>
    
    
    
      <category term="dev" scheme="http://spiiin.github.io/tags/dev/"/>
    
      <category term="dascript" scheme="http://spiiin.github.io/tags/dascript/"/>
    
      <category term="cpp" scheme="http://spiiin.github.io/tags/cpp/"/>
    
      <category term="llvm" scheme="http://spiiin.github.io/tags/llvm/"/>
    
  </entry>
  
  <entry>
    <title>Git. ссылки</title>
    <link href="http://spiiin.github.io/blog/1186660544/"/>
    <id>http://spiiin.github.io/blog/1186660544/</id>
    <published>2022-09-29T19:04:35.000Z</published>
    <updated>2022-09-29T19:10:22.235Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Различные доки по git<br><a id="more"></a><br>  <a href="https://fabiensanglard.net/git_code_review/index.php" target="_blank" rel="noopener">https://fabiensanglard.net/git_code_review/index.php</a> - коллекция доков по гиту<br>  <a href="https://learngitbranching.js.org/?locale=ru_RU&amp;demo=" target="_blank" rel="noopener">https://learngitbranching.js.org/?locale=ru_RU&amp;demo=</a> - игра-практика<br>  <a href="https://github.com/pluralsight/git-internals-pdf/releases" target="_blank" rel="noopener">https://github.com/pluralsight/git-internals-pdf/releases</a> - книжка git internals<br>  <a href="https://gitimmersion.com/index.html" target="_blank" rel="noopener">https://gitimmersion.com/index.html</a> - практические команды<br>  <a href="http://marklodato.github.io/visual-git-guide/index-en.html" target="_blank" rel="noopener">http://marklodato.github.io/visual-git-guide/index-en.html</a> - туториал с картинками<br>  <a href="https://www.atlassian.com/git/tutorials" target="_blank" rel="noopener">https://www.atlassian.com/git/tutorials</a> - набор туториалов, advanced<br>  <a href="https://git-scm.com/book/en/v2" target="_blank" rel="noopener">https://git-scm.com/book/en/v2</a> - Pro Git ещё одна книжка</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Различные доки по git&lt;br&gt;
    
    </summary>
    
    
    
      <category term="dev" scheme="http://spiiin.github.io/tags/dev/"/>
    
      <category term="link" scheme="http://spiiin.github.io/tags/link/"/>
    
  </entry>
  
  <entry>
    <title>Файберы, диспетчеры, асинки</title>
    <link href="http://spiiin.github.io/blog/2826376146/"/>
    <id>http://spiiin.github.io/blog/2826376146/</id>
    <published>2022-09-04T16:11:33.000Z</published>
    <updated>2022-10-16T12:59:17.785Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><a href="/blog/2550823652/" title="Итераторы, колстеки, корутины">Итераторы, колстеки, корутины</a> -- первая часть статьи про итераторы и асинхронное программирование. В ней были перечислены особенности абстракций обхода коллекций в нескольких языках, а также описана связь между ними и возобновляемыми функциями. В конце статьи рассмотрено представление возобновляемых функций в различных языках и различная терминология для их обозначений. Дальше можно постепенно перейти к способам управления этими функциями.<a id="more"></a><h2 id="Ссылки"><a href="#Ссылки" class="headerlink" title="Ссылки"></a>Ссылки</h2><p>(также см. ссылки из первой статьи)<br>[1] Иван Чукич - Функциональное программирование на C++ — глава 7 Диапазоны<br>[2] Alex Davies - Async in C# 5.0<br>[3] <a href="https://www.researchgate.net/publication/220802950_The_F_Asynchronous_Programming_Model" target="_blank" rel="noopener">Don Syme - F Asynchronous Programming Model</a><br>[4] <a href="http://www.kegel.com/c10k.html" target="_blank" rel="noopener">The C10K problem</a><br>[5] <a href="https://www.youtube.com/watch?v=i0RB7UqxERE" target="_blank" rel="noopener">Async await in Nim A demonstration of the flexibility metaprogramming can bring to a language</a>. Еще несколько ссылок про async в Nim - <a href="https://nim-lang.org/blog/2014/04/21/version-094-released.html" target="_blank" rel="noopener">1</a>, <a href="https://nim-lang.org/docs/asyncdispatch.html" target="_blank" rel="noopener">2</a>, <a href="https://peterme.net/asynchronous-programming-in-nim.html" target="_blank" rel="noopener">3</a><br>[6] <a href="https://cpratt.co/async-tips-tricks/" target="_blank" rel="noopener">C# async tips and tricks</a> -  sequence tasks vs parallel. Tasks return “hot”<br>[7] <a href="https://docs.python.org/3/library/asyncio-task.html" target="_blank" rel="noopener">Python asyncio-task</a><br>[8] <a href="https://www.youtube.com/watch?v=OE45F3iKtv4" target="_blank" rel="noopener">Павел Новиков — Учимся готовить C++ корутины на практике</a><br>[9] <a href="https://developer.apple.com/videos/play/wwdc2021/10132/" target="_blank" rel="noopener">Meet async/await in Swift</a><br>[10] <a href="https://marek-g.github.io/posts/projects/archive/nemerle_async_await/" target="_blank" rel="noopener">Nemerle macro async/await</a>, еще одна реализация через <a href="https://habr.com/ru/post/108184/" target="_blank" rel="noopener">монады</a><br>[11] <a href="https://www.youtube.com/watch?v=yJxFPoxqzWE" target="_blank" rel="noopener">“Clojure core.async” by Rich Hickey (2013)</a><br>[12] <a href="http://hueypetersen.com/posts/2013/08/02/the-state-machines-of-core-async/" target="_blank" rel="noopener">The State Machines of core.async</a><br>[13] <a href="https://www.youtube.com/watch?v=R3PZMIwXN_g" target="_blank" rel="noopener">Core Async Go Macro Internals - Part I</a> - реализация goroutine-макроса в closure<br>[14] <a href="https://github.com/scylladb/seastar/blob/master/doc/tutorial.md" target="_blank" rel="noopener">Scylla DB Tutorial</a> - туториал по библиотеке c++, интенсивно использующий корутины. Еще больше статей - <a href="https://www.scylladb.com/2020/03/26/avi-kivity-at-core-c-2019/" target="_blank" rel="noopener">1</a>, <a href="https://www.scylladb.com/2020/05/05/how-io_uring-and-ebpf-will-revolutionize-programming-in-linux/" target="_blank" rel="noopener">2</a></p><h2 id="Асинхронность"><a href="#Асинхронность" class="headerlink" title="Асинхронность"></a>Асинхронность</h2><p>Если рассматривать итераторы как абстракцию способов обхода коллекции, то в первую очередь они напоминают “умный” индекс в коллекции, который может пропускать какие-либо элементы, менять направление, или даже управляться элементами самой коллекции (например, можно описать вектором цепь Маркова, и сделать итератор, который реализует переключение состояний в этой цепи).</p><p>Есть ещё одно важное свойство отделения итерации от вызывающего её кода — на момент запроса следующего элемента коллекции сама коллекция не обязана существовать целиком. Процесс создания следующих элементов коллекции может быть описан в виде функции — коллекция всех натуральных чисел, передача запроса на получение элемента из файла/от внешнего устройства/по сети (само чтение данных может происходит в других потоках, которые каким-либо образом вернут данные итератору).</p><h2 id="Описание-коллекции-в-виде-функции"><a href="#Описание-коллекции-в-виде-функции" class="headerlink" title="Описание коллекции в виде функции"></a>Описание коллекции в виде функции</h2><p>Простейший пример на <code>daScript</code> — бесконечная коллекция натуральных чисел, заданная в виде генератора:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var natural &lt;- generator&lt;<span class="keyword">int</span>&gt;() &lt;| $()</span><br><span class="line">  var i = <span class="number">1</span></span><br><span class="line">  <span class="keyword">while</span> <span class="literal">true</span></span><br><span class="line">    yield i</span><br><span class="line">    i++</span><br></pre></td></tr></table></figure></p><p>Мы не можем использовать её в цикле foreach напрямую, потому что этот цикл пытается пройти по всем элементам коллекции. Но можно сделать другой генератор, который возьмёт несколько элементов из бесконечной коллекции и остановится.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">take</span><span class="params">(var src:iterator&lt;<span class="keyword">auto</span>(TT)&gt;; count:<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">  unsafe</span></span><br><span class="line">    var gen &lt;- generator&lt;TT&gt;() &lt;| $()</span><br><span class="line">      var aValue : TT-&amp;</span><br><span class="line">      <span class="function"><span class="keyword">for</span> i in <span class="title">range</span><span class="params">(count)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">if</span> <span class="title">next</span><span class="params">(src, aValue)</span></span></span><br><span class="line"><span class="function">          yield aValue</span></span><br><span class="line"><span class="function">        <span class="keyword">else</span></span></span><br><span class="line"><span class="function">          <span class="keyword">return</span> <span class="literal">false</span></span></span><br><span class="line"><span class="function">      <span class="keyword">return</span> <span class="literal">false</span></span></span><br><span class="line">    return &lt;-gen</span><br><span class="line"><span class="keyword">for</span> num in natural |&gt; take(<span class="number">3</span>)</span><br><span class="line">  print(<span class="string">"&#123;num&#125; "</span>)</span><br><span class="line"><span class="comment">//Output: "1 2 3"</span></span><br></pre></td></tr></table></figure><h2 id="Композиция-функций-и-ленивые-вычисления"><a href="#Композиция-функций-и-ленивые-вычисления" class="headerlink" title="Композиция функций и ленивые вычисления"></a>Композиция функций и ленивые вычисления</h2><p>Попробуем “просеять” натуральные числа, оставив только простые. Пример реализации функции <a href="https://github.com/spiiin/dascript_trivial_examples/tree/main/primes/primes_mix_compile_runtime.das" target="_blank" rel="noopener">prime</a> (самая быстрая реализация, без учёта потребляемой памяти — просто посчитать первые n чисел заранее в compile-time :) ).</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> num in natural |&gt; filter(@@is_prime) |&gt; take(<span class="number">10</span>)</span><br><span class="line">  print(<span class="string">"&#123;num&#125; "</span>)</span><br><span class="line"><span class="comment">//Output: 2, 3, 5, 7, 11, 13, 17, 19, 23, 29</span></span><br></pre></td></tr></table></figure><p>Можно заметить, что не существует вычисленной промежуточной коллекции <code>natural |&gt; filter(@@is_prime)</code>, которая представляла бы собой бесконечный список всех простых чисел). Вычисление следующего элемента коллекции, описанного композицией этих функций, вычисляется только по запросу этого элемента или <strong>лениво</strong> (lazy) — <code>take</code> запрашивает следующий элемент из <code>filter</code>, которая может запросить и вычислить один или несколько элементов из коллекции <code>natural</code>.</p><p>Если попробовать реализовать такую композицию на C++ с помощью итераторов и алгоритмов STL, окажется, что они не годятся для этого, функция <a href="https://en.cppreference.com/w/cpp/algorithm/copy" target="_blank" rel="noopener">std::copy_if</a>, с помощью которой можно было бы провести фильтр элементов, ожидает на вход итераторы <strong>существующей</strong> коллекции, что требует создания временной копии и её заполнения элементами. Но вместо итераторов можно воспользоваться библиотекой <code>ranges</code> - <a href="https://en.cppreference.com/w/cpp/algorithm/ranges/copy" target="_blank" rel="noopener">стандарт C++20</a>, <a href="https://github.com/ericniebler/range-v3" target="_blank" rel="noopener">range-v3</a>, она позволяет строить ленивые итераторы (<code>std::views</code>) или инплейсно изменять коллекции (<code>std::actions</code>).</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::views;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : iota(<span class="number">1</span>) | filter(is_prime) | take(<span class="number">10</span>)) &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2 3 5 7 11 13 17 19 23 29</span></span><br></pre></td></tr></table></figure><h2 id="Коллекция-как-данные-из-внешнего-источника"><a href="#Коллекция-как-данные-из-внешнего-источника" class="headerlink" title="Коллекция как данные из внешнего источника"></a>Коллекция как данные из внешнего источника</h2><p>В отличие от всех предыдущих случаев, при получении данных от внешнего источника мы не всегда знаем когда именно данные будут получены, что приводит к следующей проблеме — что делать, если все данные готовые данные обработаны, а новых ещё нет? Как и с итераторами, возможны два основных подхода — либо вызывающий код регулярно опрашивает источник данных, есть ли новые данные для обработки, либо же источнику данных передаётся колбек, который будет вызван, когда появятся новые данные для обработки.</p><h2 id="Опрос-источника-данных"><a href="#Опрос-источника-данных" class="headerlink" title="Опрос источника данных"></a>Опрос источника данных</h2><p>Игрушечная симуляция длительно выполняющейся задачи — счётчик до 100, который позволяет информировать внешний код о прогрессе каждые 10 итераций<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> </span><br><span class="line">  ValueOrReady = variant&lt;value:<span class="keyword">int</span>; ready:<span class="keyword">bool</span>&gt;</span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line"><span class="function">def <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  <span class="comment">//создаём генератор, который может возвращать значение или флаг "значение не готово"</span></span></span><br><span class="line">  var gen &lt;- generator&lt;ValueOrReady&gt;() &lt;| $()</span><br><span class="line">    var i = <span class="number">1</span></span><br><span class="line">    var answer: ValueOrReady</span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="number">100</span></span><br><span class="line">      unsafe</span><br><span class="line">        <span class="comment">//каждый 10 шагов выдаём значение</span></span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">10</span> == <span class="number">0</span></span><br><span class="line">          answer = [[ValueOrReady value = i]]</span><br><span class="line">        <span class="comment">//иначе выдаём флаг "работа в процессе", данных пока нет</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          answer = [[ValueOrReady ready = <span class="literal">false</span>]]</span><br><span class="line">      yield answer</span><br><span class="line">      i++</span><br><span class="line">    <span class="comment">//задача выполнена</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> num in gen</span><br><span class="line">    unsafe</span><br><span class="line">      <span class="keyword">if</span> num is value</span><br><span class="line">        print(<span class="string">"&#123;num.value&#125; "</span>)</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        print(<span class="string">"x "</span>)</span><br><span class="line">  print(<span class="string">"\ndone"</span>)</span><br><span class="line"><span class="comment">//Output: x x x x x x x x x 10 x x x x x x x x x 20 x x x x x x x x x 30 x x x x x x x x x 40 x x x x x x x x x 50 x x x x x x x x x 60 x x x x x x x x x 70 x x x x x x x x x 80 x x x x x x x x x 90 x x x x x x x x x</span></span><br><span class="line"><span class="comment">//done</span></span><br></pre></td></tr></table></figure></p><p>Видно, что опрос генератор требует двух специальных флагов — выполнена ли задача полностью, и готовы ли данные. Для возврата признака, готовы ли данные, использован тип <code>variant&lt;value:int; ready:bool&gt;</code> (задача возвращает либо данные, либо флаг неготовности, но не их одновременно).</p><p>Вместо такой искусственной задержки генератор может совершать реальную работу — например опрос сокетов операционной системы, и предоставлять не результат, а интерфейс для чтения данных, когда они будут готовы (один из подходов к решению проблемы 10000 соединений к серверу [2])</p><p>Такое примитивное описание асинхронной выполняемой задачи оставляет сразу серию вопросов и возможных улучшений:</p><ul><li>пока что наш “опрос” источника внешних данных заключался в том, чтобы проверить какой-то флаг, выставляемый этим источником, в основном потоке. Реальное получение данных после того, как был получен сигнал о готовности, требует синхронизации при чтении данных из источника, что можно выразить в виде паттерна с использованием примитивов синхронизации.</li><li>в программе может существовать несколько выполняемых задач, ожидающих данных. Где-то может существовать диспетчер, опрашивающий все ожидающие задачи, чтобы не писать цикл их опроса вручную. Диспетчер может даже раскидывать выполнение задач на несколько потоков выполнения.</li><li>различные ожидающие задачи могут требовать результатов других ожидающих задач. Какие-то результаты могут потребоваться раньше, какие-то позже. Есть различные способы выражения того, что в конкретном месте выполнения программа должна дождаться данных от одной или нескольких подзадач.</li><li>если задача полностью зависит от внешнего источника, недоступного для управления из программы, логично предусмотреть возможность её завершения не дожидаясь окончания</li></ul><h2 id="Ожидание-колбеков"><a href="#Ожидание-колбеков" class="headerlink" title="Ожидание колбеков"></a>Ожидание колбеков</h2><p>Можно переписать задачу вычисления чисел так, чтобы она информировала вызывающий код о прогрессе сама (аналог внутреннего итератора):<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">makeLongCalculation</span><span class="params">(blk)</span></span></span><br><span class="line"><span class="function">  var i </span>= <span class="number">1</span></span><br><span class="line">  <span class="keyword">while</span> i &lt; <span class="number">100</span></span><br><span class="line">    unsafe</span><br><span class="line">      <span class="keyword">if</span> i % <span class="number">10</span> == <span class="number">0</span></span><br><span class="line">        invoke(blk, [[ValueOrReady value = i]], <span class="literal">false</span>)</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        invoke(blk, [[ValueOrReady ready = <span class="literal">false</span>]], <span class="literal">false</span>)</span><br><span class="line">    i++</span><br><span class="line">  invoke(blk, [[ValueOrReady ready = <span class="literal">false</span>]], <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//использование функции</span></span><br><span class="line">makeLongCalculation &lt;| $(num: ValueOrReady; done: <span class="keyword">bool</span>)</span><br><span class="line">  <span class="keyword">if</span> !done</span><br><span class="line">    unsafe</span><br><span class="line">      <span class="keyword">if</span> num is value</span><br><span class="line">        print(<span class="string">"&#123;num.value&#125; "</span>)</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        print(<span class="string">"x "</span>)</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    print(<span class="string">"\ndone"</span>)</span><br><span class="line"><span class="comment">//Output: x x x x x x x x x 10 x x x x x x x x x 20 x x x x x x x x x 30 x x x x x x x x x 40 x x x x x x x x x 50 x x x x x x x x x 60 x x x x x x x x x 70 x x x x x x x x x 80 x x x x x x x x x 90 x x x x x x x x x</span></span><br><span class="line"><span class="comment">//done</span></span><br></pre></td></tr></table></figure></p><p>Таким способом часто выглядят функции запроса данных по сети — в колбек приходит информация о массиве частично-скачанных данных, и флаги — ожидать ли ещё данных, и были ли ошибки.</p><p>Рассмотрим эволюцию паттернов работы с колбеками на примере .Net, в дань тому, что в F# и затем в C# впервые ушли от них к более свежим подходам. Microsoft в C# называет паттерны асинхронного вызова с использованием колбеков умными аббревиатурами <code>EAP</code> и <code>APM</code>. Примеры кода:</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//.NET 1, APM (Asynchronous Programming Model)</span></span><br><span class="line">file.BeginCall(buffer, <span class="number">0</span>, maxLength, asyncResult =&gt; &#123;</span><br><span class="line">  <span class="comment">//вызовется через какое-то время</span></span><br><span class="line">  <span class="keyword">int</span> numBytesRead = file.EndRead(asyncResult);</span><br><span class="line">&#125;, <span class="literal">null</span>)</span><br></pre></td></tr></table></figure><p>В некоторых вызовах неочевидно, в каком контексте будет вызван колбек (из какого потока, нужно ли синхронизироваться и передавать результат обратно в поток, в котором будет обработан результат)<br>Если же нужно из колбека вызвать еще несколько вложенных операций, получается колбек-хелл, с жутким синтаксисом и смутным представлением контекста выполнения каждого из колбеков.</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//.NET 2, APM (Asynchronous Programming Model)</span></span><br><span class="line">webClient.DownloadStringCompleted += (sender, args) =&gt; &#123;</span><br><span class="line">  <span class="keyword">string</span> html = args.Result;</span><br><span class="line">&#125;</span><br><span class="line">webClient.DownloadStringAsync(<span class="keyword">new</span> Uri(<span class="string">"http://example.com"</span>));</span><br></pre></td></tr></table></figure><p>Примерно то же самое, но с необходимостью явно оторвать колбек от вызова (и возможностью навесить несколько обработчиков) — чуть меньше “лесенок” в коде</p><h2 id="Future-async-await"><a href="#Future-async-await" class="headerlink" title="Future, async/await"></a>Future, async/await</h2><p>Future (или Task в C#) — обёртка для результата, которая запускает задачу, и возвращает управление вызывающему коду. Код сам может решить что ему делать с объектом задачи, когда остановиться, чтобы дождаться результата, или как скомбинировать полученный объект с другими задачами.</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//.NET 4</span></span><br><span class="line">Task&lt;<span class="keyword">string</span>&gt; htmlTask = webClient.DownloadStringTaskAsync(url);</span><br><span class="line"><span class="comment">//тот можно выполнить код, которому не требуется результат hmtlTask</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">string</span> html = htmlTask.Result; <span class="comment">//тут блокировка до ожидания результата</span></span><br><span class="line"><span class="comment">//или прикрепить к задаче продолжение</span></span><br><span class="line">htmlTask.ContinueWith(task=&gt; &#123;</span><br><span class="line">  <span class="keyword">string</span> html = task.Result;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Следующий шаг, сделанный в F# и перенятый в других языках — продвинутый синтаксический сахар, который позволяет записать <code>ContinueWith</code> не в виде лямбда-функции, а кодом, который выглядит, ка<br><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//.NET 5</span></span><br><span class="line">Task&lt;<span class="keyword">string</span>&gt; htmlTask = webClient.DownloadStringTaskAsync(url);</span><br><span class="line"><span class="keyword">string</span> html = <span class="keyword">await</span> htmlTask; <span class="comment">//то же что и в прошлом примере с ContinueWith</span></span><br><span class="line">doSomething(html)             <span class="comment">//строки ниже await также "переписываются" внутрь ContinueWith</span></span><br></pre></td></tr></table></figure></p><p>Другие языки с async/await в похожем виде адаптируют эти идеи из C#</p><ul><li>[5] - вкручивание их в Nim синтаксическими макросами.</li><li>[8] приводится пример разбора устройства Task в стандарте C++</li><li>[9] Swift. Достаточно подробное объяснение, тайминги<br>22:14 — трансформация кода на колбеках в async код<br>22:53 — про “цвета” функций<br>30:38 — continuation pattern cc/resume<br>32:19 — сохранение continuation %)</li><li>[10] Nemerle</li><li>[11] Closure, [12]<br> 8:24 C# async, linear code -&gt; callbacks + state machine, обзор подходов async и channel</li></ul><p>Проще говоря, <code>co_await</code> в C++ позволяет записать:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">task&lt;&gt; <span class="title">tcp_echo_server</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> data[<span class="number">1024</span>];</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> n = <span class="keyword">co_await</span> socket.async_read_some(buffer(data));</span><br><span class="line">    <span class="function"><span class="keyword">co_await</span> <span class="title">async_write</span><span class="params">(socket, buffer(data, n))</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"resended\n"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>вместо чего-то типа:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">socket.async_read_some(buffer(data)).continueWith([&amp;](<span class="keyword">auto</span> task)&#123;</span><br><span class="line">  n = task.result();</span><br><span class="line">  async_write(socket, buffer(data, n)).continueWith([&amp;](<span class="keyword">auto</span> task)&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"resended\n"</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>(специально не хочу вникать в особенности именно С++ реализации переписывания из-за её вырвиглазности, при желании можно покопаться в этом в [8]).</p><p>Можно рассматривать оператор <code>co_await</code> как возможность приостановить выполнение и “подписаться” на уведомление о завершении или приостановке выражения-аргумента.</p><p>Разбор некоторых проблем сочетания синхронных функций с асинхронными в статье <a href="http://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/" target="_blank" rel="noopener">What Color is Your Function?</a>. Библиотечные функции для синхронной и асинхронной работы “разных цветов”, и необходимо иметь 2 версии функций для того, чтобы вызывающий код мог выбирать из них (к примеру, синхронный <a href="https://github.com/redis/redis-py" target="_blank" rel="noopener">redispy</a> и его асихронный двойник <a href="https://github.com/aio-libs/aioredis-py" target="_blank" rel="noopener">aioredis</a>, или асинхронная копия <a href="https://pypi.org/project/asynctkinter/" target="_blank" rel="noopener">tkinter</a>, <a href="https://github.com/aio-libs" target="_blank" rel="noopener">десятки их</a>). Язык <code>Zig</code> кажется, один из немногих, в котором реализована поддержка универсальных бесцветных функций, которые могут работать синхронно или асинхронно, решение переносится на вызывающий кода (см ссылки [26], [27] в первой части статьи).</p><p>Интересно, насколько просто добавляются подобные операторы в языки с поддержкой синтаксических макросов. Например, модуль <a href="https://github.com/GaijinEntertainment/daScript/blob/138f625c7f95943341a5e96cca114ae7d0772ba6/daslib/coroutines.das" target="_blank" rel="noopener">coroutine</a> в <code>daScript</code>, реализующий макрос <code>co_await</code>, и примеры его использования <a href="https://github.com/GaijinEntertainment/daScript/blob/138f625c7f95943341a5e96cca114ae7d0772ba6/examples/test/misc/coroutines_example_2.das" target="_blank" rel="noopener">1</a> и <a href="https://github.com/GaijinEntertainment/daScript/blob/110bb4313fa479d7b837413700ed7f6c68601e24/examples/test/misc/coroutines_example.das" target="_blank" rel="noopener">2</a>.</p><p>Первый пример — последовательная передача управления между двумя функциями:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[coroutine]</span><br><span class="line"><span class="function">def <span class="title">subcr</span><span class="params">(name:<span class="built_in">string</span>)</span></span></span><br><span class="line"><span class="function">  <span class="title">print</span><span class="params">(<span class="string">"&#123;name&#125; sub 1\n"</span>)</span></span></span><br><span class="line"><span class="function">  <span class="title">co_continue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  <span class="title">print</span><span class="params">(<span class="string">"&#123;name&#125; sub 2\n"</span>)</span></span></span><br><span class="line"><span class="function">  <span class="title">co_continue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  <span class="title">print</span><span class="params">(<span class="string">"&#123;name&#125; sub 3\n"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">[coroutine]</span><br><span class="line"><span class="function">def <span class="title">coroutine_example</span><span class="params">(name:<span class="built_in">string</span>;count:<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">  <span class="title">print</span><span class="params">(<span class="string">"&#123;name&#125; step 1\n"</span>)</span></span></span><br><span class="line"><span class="function">  <span class="title">co_continue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  <span class="title">print</span><span class="params">(<span class="string">"&#123;name&#125; step 2\n"</span>)</span></span></span><br><span class="line"><span class="function">  <span class="title">co_continue</span><span class="params">()</span></span></span><br><span class="line">  co_await &lt;| subcr(name)</span><br><span class="line">  co_continue()</span><br><span class="line">  print(<span class="string">"&#123;name&#125; step 3\n"</span>)</span><br><span class="line">  co_continue()</span><br><span class="line">  <span class="function"><span class="keyword">for</span> i in <span class="title">range</span><span class="params">(<span class="number">4</span>,<span class="number">4</span>+count)</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;name&#125; step &#123;i&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">co_continue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">[export]</span><br><span class="line">def main</span><br><span class="line">    var crs &lt;- [&#123;<span class="keyword">auto</span></span><br><span class="line">        coroutine_example(<span class="string">"co1"</span>,<span class="number">1</span>);</span><br><span class="line">        coroutine_example(<span class="string">"co2"</span>,<span class="number">2</span>)</span><br><span class="line">    &#125;]</span><br><span class="line">    cr_run_all(crs)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Output:</span></span><br><span class="line"><span class="comment">//co2 step 1</span></span><br><span class="line"><span class="comment">//co1 step 1</span></span><br><span class="line"><span class="comment">//co2 step 2</span></span><br><span class="line"><span class="comment">//co1 step 2</span></span><br><span class="line"><span class="comment">//co2 sub 1</span></span><br><span class="line"><span class="comment">//co1 sub 1</span></span><br><span class="line"><span class="comment">//co2 sub 2</span></span><br><span class="line"><span class="comment">//co1 sub 2</span></span><br><span class="line"><span class="comment">//co2 sub 3</span></span><br><span class="line"><span class="comment">//co1 sub 3</span></span><br><span class="line"><span class="comment">//co2 step 3</span></span><br><span class="line"><span class="comment">//co1 step 3</span></span><br><span class="line"><span class="comment">//co2 step 4</span></span><br><span class="line"><span class="comment">//co1 step 4</span></span><br><span class="line"><span class="comment">//co2 step 5</span></span><br></pre></td></tr></table></figure></p><p>Второй пример — это внутренний итератор по дереву из первой части статьи (раздел <strong><code>Файберы</code></strong>), оформленный в виде корутины:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[coroutine]</span><br><span class="line"><span class="function">def <span class="title">each_async</span><span class="params">(tree : Tree?)</span> : <span class="keyword">int</span></span></span><br><span class="line">  if tree.left != null</span><br><span class="line">    <span class="keyword">co_await</span> &lt;| each_async(tree.left)</span><br><span class="line">  yield tree.data</span><br><span class="line">  <span class="keyword">if</span> tree.right != null</span><br><span class="line">    <span class="keyword">co_await</span> &lt;| each_async(tree.right)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> t in each_async(tree)</span><br><span class="line">  print(<span class="string">"&#123;t&#125;\n"</span>)</span><br></pre></td></tr></table></figure></p><p>Макрос corountine превращает функцию в генератор, который может быть приостановлен и возобновлён. Как показывает пример, асинхронные значения могут возвращаться в том числе и из рекурсивной функции. Теперь можно как в <code>ruby</code>, возвращать управление из вложенных функций!</p><h2 id="Каналы"><a href="#Каналы" class="headerlink" title="Каналы"></a>Каналы</h2><p>Отойдём ненадолго от асинхронных функций, и посмотрим на работу с потоками. В <code>daScript</code> функции для работы с ними собраны в модуле <a href="https://github.com/GaijinEntertainment/daScript/blob/d60f0a310086458d28bf4726e93aa0e6c1e06abe/daslib/jobque_boost.das" target="_blank" rel="noopener">jobque_boost</a>. Примеры использования - <a href="https://github.com/GaijinEntertainment/daScript/blob/fdc48d4d4cfc46f08f0ca2fd8938a05896b973a6/examples/test/unit_tests/test_job_que.das" target="_blank" rel="noopener">test_job_que</a> и <a href="https://github.com/GaijinEntertainment/daScript/blob/master/examples/test/misc/producer-consumer.das" target="_blank" rel="noopener">produser-consumer</a>.</p><p>Новый поток создаётся функцией <code>new_thread</code>, а передача данных осуществляется через каналы (<code>channel</code>), которые объединяют примитив синхронизации (мьютекс) и результат, который может быть отправлен в канал из одного потока и принят из другого.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Answer</span></span></span><br><span class="line"><span class="class">    <span class="title">text</span>:</span><span class="built_in">string</span></span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">work_in_thread</span><span class="params">(var channel)</span></span></span><br><span class="line"><span class="function"><span class="comment">//создаём потока (в реальном коде нужно обернуть в job, чтобы иметь возможность дождаться завершения)</span></span></span><br><span class="line">new_thread &lt;| @</span><br><span class="line">    print(<span class="string">"in thread\n"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">for</span> i in <span class="title">range</span><span class="params">(<span class="number">3</span>)</span></span></span><br><span class="line">      channel |&gt; push_clone([[Answer text="work in progress &#123;i&#125;"]])  //передаём данные в канал</span><br><span class="line">      sleep(<span class="number">1000u</span>)</span><br><span class="line">    channel |&gt; notify_and_release                                    <span class="comment">//закрываем канал</span></span><br><span class="line">    <span class="comment">//completion |&gt; notify_and_release</span></span><br><span class="line">    print(<span class="string">"done thread\n"</span>)</span><br><span class="line">  print(<span class="string">"work_in_thread done\n"</span>)</span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main</span><br><span class="line">  with_channel(<span class="number">1</span>) &lt;| $(channel)</span><br><span class="line">    work_in_thread(channel)</span><br><span class="line">    print(<span class="string">"thread created\n"</span>)</span><br><span class="line">    for_each(channel) &lt;| $(ans:Answer#)              <span class="comment">//принимаем данные из канала</span></span><br><span class="line">        print(<span class="string">"result from thread: &#123;ans.text&#125;\n"</span>)</span><br><span class="line">    print(<span class="string">"done"</span>)</span><br><span class="line"><span class="comment">//Output</span></span><br><span class="line"><span class="comment">//work_in_thread done</span></span><br><span class="line"><span class="comment">//thread created</span></span><br><span class="line"><span class="comment">//in thread</span></span><br><span class="line"><span class="comment">//result from thread: work in progress 0</span></span><br><span class="line"><span class="comment">//result from thread: work in progress 1</span></span><br><span class="line"><span class="comment">//result from thread: work in progress 2</span></span><br><span class="line"><span class="comment">//done thread</span></span><br><span class="line"><span class="comment">//done</span></span><br></pre></td></tr></table></figure><p>Каналы по интерфейсу похожи на итераторы, однако в <code>dascript</code> не встроены в язык, поэтому работают не с встроенной функцией <code>for</code>, а с функцией из модуля joque_boost <code>for_each</code>, которая на очередной итерации достаёт из канала очередное значение или блокирует поток до тех пор, пока канал пуст. Итерация заканчивается после того, как канал будет закрыт (<code>release/notify_and_release</code>).</p><p>Но можно попробовать переписать код так, чтобы работа выполнялась в потоке, но была спрятана внутри асинхронной функции-корутине, которая предоставляет интерфейс в виде стандартного итератора. Используем предыдущий игрушечный пример с асинхронным счётчиком.<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">require daslib/coroutines</span><br><span class="line">require daslib/jobque_boost</span><br><span class="line">require fio</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> </span><br><span class="line">    ValueOrReady = variant&lt;value:<span class="keyword">int</span>; ready:<span class="keyword">bool</span>&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Answer</span></span></span><br><span class="line"><span class="class">    <span class="title">value</span>:</span><span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">work_in_thread</span><span class="params">(var channel: Channel?)</span></span></span><br><span class="line">    new_thread &lt;| @</span><br><span class="line">        <span class="function"><span class="keyword">for</span> i in <span class="title">range</span><span class="params">(<span class="number">100</span>)</span></span></span><br><span class="line">            if i % 10 == 0</span><br><span class="line">                channel |&gt; push_clone([[Answer value=i]])</span><br><span class="line">            sleep(<span class="number">10u</span>)</span><br><span class="line">        channel |&gt; append(<span class="number">1</span>) <span class="comment">//create buffer to inform that channel finish send data increase size to satisfy assert inside channel::release </span></span><br><span class="line">        channel |&gt; release   <span class="comment">//we need to call release satisfy the condition of the ChannelAndStatusCapture macro </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//completion |&gt; notify_and_release //for thread completion logic</span></span><br><span class="line"></span><br><span class="line">[coroutine]</span><br><span class="line"><span class="function">def <span class="title">makeLongCalculationInThread</span><span class="params">(work)</span> : ValueOrReady</span></span><br><span class="line">    var channel : Channel?</span><br><span class="line">    unsafe &#123; channel = channel_create(); &#125;</span><br><span class="line">    invoke(work, channel)</span><br><span class="line">    <span class="keyword">while</span> channel.size == <span class="number">0</span> <span class="comment">// channel.size==1 is a signal to stop receiving</span></span><br><span class="line">        sleep(<span class="number">10u</span>)</span><br><span class="line">        var answer: ValueOrReady</span><br><span class="line">        <span class="keyword">if</span> !channel.isEmpty</span><br><span class="line">            let void_data = _builtin_channel_pop(channel)</span><br><span class="line">            unsafe</span><br><span class="line">                let typed_data = reinterpret&lt;Answer?#&gt; void_data</span><br><span class="line">                answer = [[ValueOrReady value = typed_data.value]]</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            answer = [[ValueOrReady ready = <span class="literal">false</span>]]</span><br><span class="line">        yield answer</span><br><span class="line">    unsafe &#123; channel_remove(channel); &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">[<span class="keyword">export</span>]</span><br><span class="line">def main</span><br><span class="line">    <span class="function"><span class="keyword">for</span> num in <span class="title">makeLongCalculationInThread</span><span class="params">(@@work_in_thread)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">if</span> num is value</span></span><br><span class="line"><span class="function">            <span class="title">print</span><span class="params">(<span class="string">"&#123;num as value&#125; "</span>)</span></span></span><br><span class="line"><span class="function"><span class="comment">//Output (async):</span></span></span><br><span class="line"><span class="function"><span class="comment">//0 10 20 30 40 50 60 70 80 90</span></span></span><br></pre></td></tr></table></figure></p><p><em>channel_create и channel_remove тут - функции, добавленные в библиотеку работы с каналами, потому что стандартное и безопасное api каналов daScript (with_channel) предоставляет доступ к созданному каналу только внутри блока, а из блока нельзя возвращать значение с помощью yield</em></p><p>Теперь внешний интерфейс — это асинхронная функция,  которая запускает вычисление в потоке и возвращает управление, но сохранит результат вычислений из потока в канале, как только он будет готов. Основной поток при этом не блокируется и может продолжать выполнение, до тех пор пока этот результат не потребуется. Когда результат потребуется — функция main либо приостановится, чтобы его дождаться, либо сразу прочитает его из канала, если он уже готов.</p><h2 id="Communicating-sequential-processes"><a href="#Communicating-sequential-processes" class="headerlink" title="Communicating sequential processes"></a>Communicating sequential processes</h2><p>Каналы повсеместно используются в <code>Go</code>, примитивы и паттерны работы с ними рассмотрены в [22] и [23] по ссылкам в первой части статьи (теорию по работе с каналами можно гуглить по аббревиатуре <a href="https://en.wikipedia.org/wiki/Communicating_sequential_processes" target="_blank" rel="noopener">CSP</a>). Поиграться с примерами в браузере в можно <a href="https://go.dev/tour/concurrency/1" target="_blank" rel="noopener">тут</a>. Go позволяет создавать буферизированные и небуферизированные каналы. Отличие в том, что при попытке отправить второе сообщение в канал, пока не прочитано первое, тред блокируется до тех пор, пока сообщение не будет прочитано. Каналы в <code>daScript</code> буферизированы, так что можно отправить сразу несколько сообщений без блокировки отправителя, даже если читатель ещё не принял эти сообщения.</p><p>В <code>Go</code> есть удобные примитивы для соединения выходов нескольких каналов:<br><img src="/blog/2826376146/dataflow.png" alt=""><br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Funnel_receiveOrTimeout</span><span class="params">(c &lt;- <span class="keyword">chan</span> <span class="keyword">int</span>, duration time.Duration)</span> <span class="params">(data <span class="keyword">int</span>, more, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> data, more = &lt;- c :       <span class="comment">//канал с данными</span></span><br><span class="line">      <span class="keyword">return</span> data, more, <span class="literal">true</span></span><br><span class="line">    <span class="keyword">case</span> &lt;- time.After(duration):  <span class="comment">//канал таймаута, выдаёт сообщение после указанного времени</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>, <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fanout</span><span class="params">(in &lt;- <span class="keyword">chan</span> <span class="keyword">int</span>, out1, out2 <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> data := <span class="keyword">range</span> in &#123; <span class="comment">//получает новые данные</span></span><br><span class="line">    <span class="keyword">select</span> &#123;             <span class="comment">//отправляет в первый попавшийся незаблокированный канал</span></span><br><span class="line">      <span class="keyword">case</span> out1 &lt;- data</span><br><span class="line">      <span class="keyword">case</span> out2 &lt;- data</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>select</code> в первом случае позволяет либо получить сообщение с данными из канала, либо сообщение из канала таймаута, если данных не поступило в течение определенного времени. Во втором — отправить данные в первый свободный канал из списка.</p><p><code>Go</code> также отличается тем, что имеет встроенный диспетчер горутин, который распределяет выполнений по нескольким потокам. Таким образом горутины в го — это корутины, которые могут быть выполнены или перенесены в другой поток. Выполнение горутины приостанавливается при ожидании при ожиданнии данных из канала.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;a href=&quot;/blog/2550823652/&quot; title=&quot;Итераторы, колстеки, корутины&quot;&gt;Итераторы, колстеки, корутины&lt;/a&gt; -- первая часть статьи про итераторы и асинхронное программирование. В ней были перечислены особенности абстракций обхода коллекций в нескольких языках, а также описана связь между ними и возобновляемыми функциями. В конце статьи рассмотрено представление возобновляемых функций в различных языках и различная терминология для их обозначений. Дальше можно постепенно перейти к способам управления этими функциями.
    
    </summary>
    
    
    
      <category term="dev" scheme="http://spiiin.github.io/tags/dev/"/>
    
      <category term="link" scheme="http://spiiin.github.io/tags/link/"/>
    
      <category term="dascript" scheme="http://spiiin.github.io/tags/dascript/"/>
    
      <category term="cpp" scheme="http://spiiin.github.io/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>Системы поиска сокровищ</title>
    <link href="http://spiiin.github.io/blog/3309518526/"/>
    <id>http://spiiin.github.io/blog/3309518526/</id>
    <published>2022-08-09T18:08:42.000Z</published>
    <updated>2022-08-20T19:33:55.779Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>В эссе <a href="https://probablydance.com/2019/06/08/treasure-hunting-systems-found-in-the-history-of-video-games/" target="_blank" rel="noopener">Treasure Hunting Systems Found in the History of Video Games</a> Malte Skarupke рассуждает о том, что в истории игр было несколько примеров случаев, когда появлялась платформа, в итоге порождающая сразу несколько новых успешных жанров. Он пытается выделить характеристики и свойства, общие для таких платформ, которые он называет “Системы поиска сокровищ”. Я не согласен со всеми наблюдениями автора, но попробую немного расширить его эссе. Это не перевод, а дополнение к оригинальной статье.</p><a id="more"></a><h2 id="Неравномерность-распределения-неизвестных-нам-величин"><a href="#Неравномерность-распределения-неизвестных-нам-величин" class="headerlink" title="Неравномерность распределения неизвестных нам величин"></a>Неравномерность распределения неизвестных нам величин</h2><p>Почему вообще на мой взгляд могут возникать такие системы?</p><p>Для начала два факта. Первый — в <strong><code>геймдеве очень много ОЧЕНЬ неравномерно распределённых величин</code></strong>. Главная из этих величин — количество фана от игры. Несколько примеров других:</p><ul><li>Большинство игр скучные, но есть очень небольшое количество очень весёлых и увлекательных. Они настолько лучше для нас, что затягивают невероятно сильнее — мы можем забывать про сон или важные дела, и возвращаемся к таким играм годами. У нас нет численной оценки удовольствия от игры, но вероятно, что эта разница этой нашей субъективной оценки между любимыми играми и просто хорошими была бы колоссально больше, чем между хорошими и плохими. Условно, все игры получили бы от нас от 1 до 9 баллов, а любимая, не 10, а скажем 1000000.</li></ul><ul><li>Как возможноое следствие, разница между доходами от игры от среднего игрока и от фаната — колоссальная. Это одна из причин существования модели условно-бесплатных игр. Несколько человек-фанатов могут принести дохода больше чем 1000000 человек, которым игра не понравилась.  </li></ul><p>Моя заметка про очень известное явление в геймдеве: <a href="/blog/1402387497/" title="Суперфанаты">Суперфанаты</a> — не называйте их китами!</p><blockquote><p>Отсюда следует одно важное правила гейм-дизайна: не ограничивайте сверху возможности потратить деньги в вашей игре, вы не знаете, как много игроки будут готовы вам заплатить, не надо запрещать им платить много</p></blockquote><ul><li>Но в то же время разница между хорошей игрой и средней по количеству потраченного труда небольшая. То есть, чтобы сделать игру, которая увлечёт в 1000000 раз сильнее (или в 1000000 раз больше игроков), не нужно в 1000000 раз больше усилий. Не нужно даже в 2 раза больше усилий. Возможно, достаточно всего несколько процентов. Важнее не количество усилий, а что-то другое — какие-то отдельные фичи или небольшие кусочки работы стоят в 1000000 раз больше других, именно от них может зависеть.</li></ul><p>Тайнан Сильвестр в статье <a href="https://tynansylvester.com/2013/12/email-dredging-cutting-polish-and-nonlinear-results/" target="_blank" rel="noopener">Email dredging: Cutting polish and nonlinear results</a> развёрнуто расписывает эту нелинейность между временем, потраченным на такие “золотые” фичи и тем, что они приносят в результате. Дальше я ещё буду ссылаться на эту статью и методы из неё.</p><ul><li>Суммарная разница в доходах между лучшими играми и хорошими тоже колоссально отличается — как от мультипликативности перечисленных выше факторов (лучшие игры притягивают в 1000 раз больше игроков И ОДНОВРЕМЕННО лучшие ещё и больше игроков конвертируют в суперфанатов), так и от положительной обратной связи — лучшие игры получают больше ресурсов для привлечения новых игроков, все хотят поиграть в лучшую игру.</li></ul><p>Я использовал разницу в 1000000 раз в примерах, но разница здесь может быть даже намного существеннее, причём настолько сильнее, что <strong>мы постоянно ошибаемся пытаясь её оценить</strong>. Главное — нельзя недооценивать её. Книга <code>Черный лебедь</code> Насима Талеба практически полностью о том, что мы плохо справляемся с прогнозами такого типа величин, из-за чего прогнозы часто бывают ошибочными. В совокупности с тем, насколько значима правильная оценка величины для нас, ошибки могут приводить к катастрофам (в узком смысле — будет ли наша компания продолжать делать игры или закроется).</p><p>Некоторые примеры разница нашего восприятия из книги приведены в статье <a href="https://ru.wikipedia.org/wiki/%D0%98%D0%B3%D1%80%D0%BE%D0%B2%D0%BE%D0%B5_%D0%B7%D0%B0%D0%B1%D0%BB%D1%83%D0%B6%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5" target="_blank" rel="noopener">Игровое заблуждение</a>.</p><p>Второй факт — <strong><code>мы всё ещё мало знаем о том, как именно сделать игру увлекательной, но знаем, что в процессе экспериментов можем обнаружить сверх-увлекательные идеи, которые мы затем сможем использовать в игре</code></strong>.</p><p>Случайная находка такого самородка в процессе экспериментов называется <code>серендипным открытием</code>. Самое известное такое открытие — случайное обнаружение механики <code>Тетриса</code>. Менее известные — небольшое изменение, превратившее прототип <code>Diablo</code> и пошаговой игры в ту, которую мы знаем. В статье <a href="/blog/2537188794/" title="Прототипирование в геймдеве">Прототипирование в геймдеве</a> я приводил ещё несколько известных примеров таких серьёзных трансформаций жанров игр (раздел <code>Путь от прототипа к результату</code>).</p><p>Несколько примеров занятий из мира компьютеров и разработки, связанных с исследованием неизвестного, которые требуют исключительной внимательности к каждой обнаруженной “необычной” мелочи:</p><ul><li>Тестирование и отладка програм. На этапе поиска причин возникновения очень редких ошибок. Часто первая зацепка, позволяющая обнаружить всю цепочку действий, приводящую к крешу, это случайное незапланированное наблюдение необычного поведения.</li><li>Реверс инжиниринг. Сама цель процесса — понять внутреннее устройство программы или данных, которые она интерпретирует, изначально не зная о нём ничего. Необходимо большое количество предположений и проверок, причём необходимо уметь отбрасывать варианты, которые “почти объясняют поведение”, но некоторые мелочи портят всё объяснение или меняют его смысл.</li><li>Аналитика. Наблюдение за поведением пользователей — процесс работы с очень “грязными” данными. Тенденции, видимые на графиках, сложно интерпретировать, и требуется умение не только придумать гипотезу и проверить её, но и достаточно быстро изменить и уточнить интерпретацию в случае расхождений с реальностью.</li><li>Плейтесты. Люди <a href="https://ru.wikipedia.org/wiki/%D0%A0%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F_(%D0%BF%D1%81%D0%B8%D1%85%D0%BE%D0%BB%D0%BE%D0%B3%D0%B8%D1%8F" target="_blank" rel="noopener">рационализируют</a> своё поведение, поэтому они не могут даже сказать вам, почему им понравилась или не понравилась игра — они будут неосознанно врать вам. Невозможно составить точный опросник, по которому игрок что-то расскажет вам, нужно отслеживать влияния изменений в игре на реальное, а не декларируемое поведение игроков.</li></ul><p>Однако, не смотря на возможности, экспериментирование не очень распространёно в реальных компаниях — зачем лезть в неизвестное (с неизвестными результатами!), если можно повторять “формулу успеха”? Делать игры дорого, и для инвесторов надёжнее вкладываться в то, что с большей вероятностью будет хорошо продаваться — проверенные жанры и франшизы.</p><p>Про элементы подхода с исследованиями в геймдеве я писал в статье — <a href="/blog/2486671624/" title="Метод Lean Startup">Метод Lean Startup</a>. Одна из основных идей — как можно раньше и дешевле собрать <code>Minimum Awesome Product</code>, игру, которая уже будет интересна игрокам, и начинать изучать свою аудиторию, выстроив процесс разработки так, чтобы данные экспериментов позволяли изменять дальнейшие планы разработки насколько это потребуется.</p><h2 id="Залежи-артефактов"><a href="#Залежи-артефактов" class="headerlink" title="Залежи артефактов"></a>Залежи артефактов</h2><p>Объединим эти два факта вместе — перед нами бесконечное поле неизвестных интересных механик для наших игр, <strong><code>&quot;зарытые в землю артефакты&quot;</code></strong>. Они очень сильно отличаются по характеристикам. Мы копаем наугад и рано или поздно откапываем часть артефакта — делаем прототип игры. Выкапывать весь артефакт дорого, поэтому для нас очень важно прикинуть стоимость как полную стоимость раскопок, так и то, за сколько мы сможем его продать. И всё это — только по торчащей из-под земли верхушке!</p><p>Часто хорошим решением является не копание артефакта сразу вглубь (фиксированное решение делать игру по плану несколько лет), а неглубокое копание окрестностей в <strong>разные</strong> стороны — создание ещё нескольких прототипов, проверяющих <strong>различные</strong> гипотезы. Потому что мы кое-что знаем про наше поле.</p><p>Например, артефакт может оказаться больше, чем кажется, и мы можем понять, в какую сторону лучше копать, чтобы быстрее его вытащить — обнаруженная нами неплохая механика для шутера может хорошо или плохо работать в паре с другими задуманными механиками. Или наоборот, артефакт мельче чем кажется, и развивать идею бесполезно, хотя они и выглядела интересно. Лучше не тратить время, и попробовать что-то другое.</p><p>Или же, редко, но бывает, что в окрестностях от того, что мы начали раскапывать, обнаруживается ещё множество артефактов. Мы просто не сможем выкопать и продать их все сами. К примеру мы обнаружили, что нашли механику для шутера, которая отлично работает с множеством различных других механик, и мы просто не можем взять их все в свою игру. Но мы можем поделиться находкой с игроками — пускай копают вместе с нами! Это и есть в терминологии автора — <strong><code>системы поиска сокровищ</code></strong>.</p><blockquote><p>Системы поиска сокровищ хорошо продаются</p></blockquote><p>Скрин из <a href="https://youtu.be/GxthbWfSak8?t=1275" target="_blank" rel="noopener">доклада</a> How Modding Made Bethesda Better, топовые игры в Steam по числу пользователей 2015 года, большинство игр в нём попадают в определение системы поиска сокровищ или даже просто сделаны в этих системах!<br><img src="/blog/3309518526/rate.png" alt="bench"></p><h2 id="Примеры-систем-поиска-сокровищ"><a href="#Примеры-систем-поиска-сокровищ" class="headerlink" title="Примеры систем поиска сокровищ"></a>Примеры систем поиска сокровищ</h2><p>Malte приводит три примера таких систем — моды к Warcraft 3, чехословацкое сообщество разработчиков игр 80х и Flash-игры, и сосредотачивается на общих характеристиках таких систем. Это интересный пример обобщения — рассматривать систему <code>игра + платформа + сообщество</code>, в которой границы между игрой и платформой сильно размыты (платформа может быть интегрирована в игру, быть “встроенным магазином” или внешним сайтом, а сама “игра” отсутствовать вообще, или быть условной, как например в RPG Maker), а сообщество геймеров иногда перерастает в субкультуру, представители которой не только играют в игру или занимаются её модификацией, но и воспринимает это как часть своего образа жизни (ролевики, проводящие LARP-ы по Fallout, или конвенты косплейеров — продолжение игры в реальной жизни).</p><p><strong><code>Сообщество-центричные системы</code></strong></p><p>Примеры сверхактивных сообществ моддеров различных периодов — пиратская сцена, в период, когда никто особо не заморачивался защитой игр, и копирование с изменениями часто были “фишками” команд, модифицирующих софт и игры.</p><p>Насколько я понял после пролистывания книжки про разработчивов Чехословакии, что-то подобное происходило и там. ZX-спектрум и кассеты в 80х, дискеты в 90х и CD в 2000х являлись платформой, новым способом передачи информации, вокруг которой объединялись геймеры, хакеры (переводчики, дизайнеры “оболочек”, читеры), коллекцинеры, продавцы, журналисты. Возможности для “креатива” здесь — открытые ресурсы для модификации и простота копирования, а также то, что в ходе распространения открывались возможность заработать немного денег и “очков престижа” — релиз группы соревновались и просто ради известности своей группировки внутри сообщества. Пример деятельности такого пиратского сообщества можно почитать и на русском в художественной форме — “Дневник тестировщика”/“Хроники тестировщика”, или посмотреть на английском — сериал “Сцена”.</p><p>Чехословацкая сцена выделилась тем, что в диком количестве насоздавала текстовых квестов. Похожий “взрыв” жанра игр произошёл с клонами <code>MUD</code>, его эволюция описана в книге Бартла <code>Designing Virtual Worlds</code>, средой распространения стал ранний интернет.</p><p>Нескольких “невзрывных” примеров хакерских сообществ (в СНГ было много модификаций игр/игры, но недостаточно для “критической массы” интересных модификаций, созданием занималось очень ограниченное количество людей) — <code>китайские клоны NES-картриджей</code>, в которых модифицировалась графика и отдельные элементы сюжета (видимо, было относительно просто хакать, но сложно тиражировать), и бесчисленные <code>модификации GTA 3/Vice City</code>, которые продавалась на отдельных компактах (к моменту пика популярности было относительно просто тиражировать CD-RW дома, но создание требовало как минимум навыков в 3D-моделировании, а как максимум — полноценного инструментария).</p><p>Своеобразным примером “взрыва” в прото-жанре игр песочниц может послужить <a href="https://www.youtube.com/watch?v=oKYiWb2W97k" target="_blank" rel="noopener">Infiminer</a>, исходники которого “утекли” в сеть. Модификаций было много, но из-за перекоса системы “игра-платформа-сообщество” в сторону хакерского сообщества, без общей игры и платформы оригинал умер, а мы все знаем одну из них на базе этих исходников, <code>Minecraft</code>, который уже и сам может служить примером системы поиска сокровищ с помощью внутриигровых модов.</p><p><strong><code>Игро-центричные системы</code></strong></p><p>Среди перечисленных автором примеров отсуствует возможно самый большой, который можно не заметить, так же как не можно не заметить изменения, которые принесли в геймдев социальные сети — мы просто живём в мире, где последствия этого “кембрийского взрыва”, повсюду и не задумываемся о том, что могло быть по другому. Это семейство игр и движков <code>Quake</code> от id software. Кроме крутости самих игр в техническом плане, авторы ещё и специально уделяли внимание ещё и тому, чтобы игры стали системой поиска сокровищ.</p><ul><li>Распространение. У id и до выхода Doom был опыт распространения игр по системе shareware, которая в тот момент была средством инди-разработчиков не зависеть от издателя. Можно было получить бесплатную демо-версию на дискетах, или скачать по сети.</li></ul><ul><li>Легкость в модификации. Кармак сознательно отделил ресурсы игры от приложения так, чтобы можно легче хакать игру. В дальнейшем, он принял революционное для того времени решение выложить в открытый доступ инструменты для модификации игры. Некоторые мультиплейерные режимы из современных шутеров родились из модов и тотальных коверсий Дума и Квейка. Один из примеров из книги “Властелины DOOM” — режимы “freeze tag” (салки) и “царь горы” из какого-то мода doom 2 по фильму “Aliens”.</li></ul><ul><li>Сама концепция движка как отделяемой от игры системы. Во-первых, возможность его лицензирования для сторонних разработчиков (Hexen и Eretic на движке Doom), и позже, взрыв игр и движков <a href="https://ru.wikipedia.org/wiki/Id_Tech_3" target="_blank" rel="noopener">на базе Quake 3</a>. Кроме игр, движок также прямо или косвенно повлиял на другие коммерческие движки — например, в книге “Архитектура игрового движка” есть схема происхождения движка <code>Medal of Honor</code> от этой “ветки эволюции”.</li></ul><ul><li>Отдельно от возможности лицензировать движок стоит выделить то, что исходники движков со временем традиционно выкладываются для свободного изучения и использования. Код Doom считают качественным (<a href="https://fabiensanglard.net/doom3/index.php" target="_blank" rel="noopener">1</a>, <a href="https://habr.com/ru/post/166113/" target="_blank" rel="noopener">2</a>, <a href="https://news.ycombinator.com/item?id=24921161" target="_blank" rel="noopener">3</a>). Часто он может служить не только историческим, но и образовательным целям.</li></ul><ul><li>Мультиплейер. Id уделили много внимания возможности и способам играть совместно, в разные периоды распространения сетевых технологий: по локально соединённым компьютерам, отдельным сереверам для клубов, игре через интернет. С их игр начался киберспорт и большие соревнования по играм.</li></ul><p>Другая система генерации сокровщ — движок и редактор <code>Warcraft</code> + матчи по Battle.net. Malte в своей статье рассуждает о том, чем Warcraft выделяется на основе других игр с мощными редакторами уровней. Основа здесь — гибкая базовая механика и возможность быстро попробовать и улучшить созданные карты. Можно выбросить/изменить/добавить некоторые механики (и редактор позволяет это делать!) и может получиться, что играть будет только интереснее. Дота — результат такого эксперимента, и постоянного тюнинга на основе тестов на игроках (описание <a href="https://dota2.fandom.com/ru/wiki/%D0%92%D0%B5%D1%80%D1%81%D0%B8%D0%B8_%D0%B8%D0%B3%D1%80%D1%8B" target="_blank" rel="noopener">327 патчей</a> карты).</p><p>Может быть, важным в случае Варкрафта является также хороший набор базовых элементов в песочнице редактора — можно посмотреть на реализацию карт из самой игры, и взять их них примеры расстановки “солдатиков” и “историй” про них.</p><p>Механики жанра стратегий позволяют много экспериментировать — <code>Civilization</code> также допускает создание карт-тотальных конверсий изначальной механики (некоторые из добавленных цивилизаций в последней части игры сами являются такими серьёзными экспериментами с переделками механик, ломающих правила).</p><p>Также хорошей платформой для экспериментов являются шутеры — <code>Counter-Strike</code>, <code>DayZ</code>, <code>PUBG</code> как примеры игр на движках шутеров с другими механиками, <code>Unreal Engine</code> как пример движка для шутера, выросшего в целую платформу.</p><p>На удивление, хуже работают модификации RPG, <code>Neverwinter Nights</code>, <code>The Elder Scrolls</code> предоставляют отличные редакторы, но они не породили новых жанров или серьёзно отличающихся механик. Автор связывает это с тем, что новые механики сложнее вписываются в существующие механики (и легче ломают баланс основной игры, если не являются изолированными модификациями), и часто требуют большего времени на плейтесты и получение обратной связи от игроков. Возможно, жанр ждёт своего взрыва.</p><blockquote><p>Если в редакторе уровней можно сделать только новые уровни для игры (неважно сколько) — это ещё не система генерации сокровищ. Сокровища появляются, когда редактор позволяет воплощать новые идеи</p></blockquote><p>Отдельное направление поиска — попытка создать игру, в которой сокровища будут генерировать пользователи внутри самой игры или встраивая контент прямо в игру (user-generated content). Примеры — творческие песочницы типа <code>Minecraft</code> или <code>Terraria</code>, в которых можно воссоздать известное здание или даже город, а также с помощью каких-нибудь простых логических триггеров выстроить несложную механику в рамках позволенного игрой (фабрики, механизмы, двигатели). Серьёзное ограничение при это — базовая механика и сеттинг игры.</p><p>Чем абстрактнее мир, тем проще воображению дорисовать что-то (хорошее объяснение эффекта можно найти в книге “Понимание комиксов”), и чем абстрактнее сеттинг, тем шире возможности того, что туда можно добавить, чтобы игроки посчитали это приемлемым в этом мире (виртуальный концерт рэпера в Fortnite будет нормально смотреться, но в World of Tanks будет неуместен, как и многое другое).</p><p><em>Свободное творчество игроков в виде возможности “построить что угодно”, часто требует цензуры со стороны разработчиков. Джесси Шел в книге по геймдизайну приводит пример “Disney Infinity”, в которой команда была вынуждена содержать отдел по борьбе с созданием в игре членов.</em></p><p>Самый удачный из существующих пример попыток создать такую систему — <code>Roblox</code>. Абстрактный мир, и “конструктор механик”, выданный игрокам в виде объектной модели, к которой можно получить доступ с помощью языка Lua. Наверное, где-то в этих серых горах тоже есть золото в виде новых механик и жанров. User-generated content системы не очень хорошо ложаться на экономику реального мира, поэтому вокруг вознаграждения за созданный контент витают идеи вроде NFT в блокчейнах.</p><p>Попытки создания мета-вселенных — это желание создать еще большую универсальную систему, в которую можно засунуть что угодно, однако часто разработчики не принимают во внимание идеи статьи. Они копают, но забывают, что поле мета-вселенных еще неизведано, и сколько там сокровищ еще предстоит узнать.</p><p><strong><code>Жанро-центричные системы</code></strong></p><p>По сути, это те же игроцентричные системы, только без самой игры. Есть платформы, направленные на создание игр строго определенного жанра. Кажется парадоксальным, что при таких ограничениях эти платформы также могут является системами генерации сокровищ в случаях, когда на них делают игры другого жанра, существующего или нового. Примеры таких платформ: <code>RpgMaker</code> для 2d-jrpg-style игр (самая известная игра на нём — To The Moon, в которой выброшены бои и оставлена только история). <code>Mugen</code> (2d-файтинги), <code>OpenBOR</code> (2d beat-them-up), <code>RenPy</code> (визуальные новеллы). Из-за серьёзных ограничений платформы, могут служить базой для экспериментов с механиками в самом жанре, но требуют out of the box мышления, чтобы делать с ними что-то отличное от задуманного, но сама лёгкость старта иногда позволяет проверить какую-нибудь небольшую идею быстрее, чем используя полноценную более универсальную платформу (особенно если доступны качественные строительные “кирпичики”, также как редакторе Warcraft доступны “солдатики” и “истории”).</p><p>Интересен пример с <code>Mario Maker</code>, как жанро-центричная система, оторванная от серии игр.</p><p><strong><code>Платформо-центричные системы</code></strong></p><p>Пример из оригинальной статьи — игры на <code>Flash</code>. Легко и быстро делать, просто выкладывать. Квинтэссенция подобных платформ, для которых главное, что “можно сделать игру быстро и с минимальными навыками программирования” (и бесплатно) — <code>Unity</code>. Unity хотела и стала системой, которую выбирают “по умолчанию”, когда ещё не знают, какие игры хотят делать и зачем. Кроме того, в Asset store можно дешево или бесплатно собрать пачку ассетов, эффектов или даже кусков кода, чтобы еще ускорить процесс, а также посмотреть, что сделали другие и показать, что сделал сам — это важные элементы для возможного “взрыва” творчества.</p><p>Контр-пример, когда для взрыва потенциально есть и платформа и жанры (навскидку — andry birds, cut the rope), но не хватает активного сообщества — <code>мобильные игры</code> в целом. Казуальные игроки менее склонны к исследованию и изменению игр (хотя, все любят кастомизацию), а владельцы апп-сторов блокируют возможность изучения и распостранения изменённых версий (нет своего аналога грин-лайта в steam для пк, или специальной поддержки начинающих разработчиков, строгая политика борьбы с нарушениями правил, высокий порог входа для запуска своей игры на телефоне). </p><blockquote><p>С этой точки зрения война за права распространять приложения и товары в приложениях через свои сторы и победа в ней, ДОЛЖНА БЫТЬ очень полезной в плане возможностй для разработчиков игр, в том числе и для создания систем поиска сокровищ</p></blockquote><h2 id="Свойства-систем-поиска-сокровищ"><a href="#Свойства-систем-поиска-сокровищ" class="headerlink" title="Свойства систем поиска сокровищ"></a>Свойства систем поиска сокровищ</h2><p>Что нужно, чтобы искать сокровища в таких системах, и какие у них отличия от менее удачных и популярных конкурентов?</p><ul><li>Легко начать и сделать что-то законченное:<ul><li>бесплатность</li><li>“батарейки” в комплекте (экосистема — набор библиотек, тулзов, и ассетов)</li><li>запуск одной кнопкой</li><li>возможность использования готовых компонентов</li><li>кросс-дисциплинарные возможности (если я программист — где взять ассеты? если я артист — как я буду писать код?).<br><em>(в презентации <a href="https://youtu.be/GxthbWfSak8?t=199" target="_blank" rel="noopener">How Modding Made Bethesda Better</a> Joel Burgess называет это эпифанией)</em></li></ul></li><li>Легко изменять сделанное:<ul><li>быстрый запуск</li><li>быстрое превью сделанного</li><li>как можно более быстрое внесение изменений, лучше всего вообще без перезапуска игры! — стимуляция к исследованию (тинкерингу)<br><em>(хех, про быстрые изменения, одна из причин, почему я слежу за <a href="https://spiiin.github.io/tags/dascript/">daScript</a> — это ключевая идея языка)</em></li></ul></li><li>Легко распространять сделанное:<ul><li>наличие среды распространения (игровые сервера, соцсети, спец. магазины, активное использование новых только появившихся медиа)</li><li>социальное доказательство в этой среде (система оценок игроками, простота выкладывания, наличие удобных фильтров для поиска, небольшой контроль за соблюдением правил — запреты на абьюз системы)</li><li>стимуляция возможностью заработать или стать популярным</li><li>доступность (не нужно регистрироваться или покупать что-то)</li><li>обратная совместимость (однажды сделанное должно продолжать работать всегда, без переделок)</li></ul></li><li>Легко получить обратную свзять:<ul><li>возможность эффективно получить оценки, критику и отзывы от игроков или других разработчиков</li></ul></li><li>Легко изучать и развиваться:<ul><li>наличие большого количества примеров</li><li>наличие ХОРОШИХ примеров</li><li>неограниченные возможности реализации сложных идей</li></ul></li></ul><h2 id="Ещё-несколько-около-игровых-систем"><a href="#Ещё-несколько-около-игровых-систем" class="headerlink" title="Ещё несколько около-игровых систем"></a>Ещё несколько около-игровых систем</h2><p> <strong><code>Креативы маркетинга</code></strong></p><p> Если отбросить лгбт-фанфики и прочий треш, то среди рекламных креативов от маркетологов, которые завлекают игроков в очередную казуалку, бывают и интересные идеи. По сложности реализации — примерно как флеш-игры, с требованием показать что-то игроку, быстрее чем за несколько десятков секунд, пока он пролистывает свои ленты новостей. Стимулирует к творчеству и необычным идеям здесь то, что ставки очень высоки — реклама стоит дорого, и если игроки не заинтересуются, то в рекламируемую игру просто никто не будет играть. </p><p> <strong><code>Хакатоны</code></strong></p><p> Искуственные ограничения, и необходимость слепить игру за ограниченное время стимулирует разработчиков искать необычные идеи там, где они не попробовали бы в обычных условиях. Изредка (очень изредка!) игры или идеи из хакатонов эволюционируют в полноценные игры.</p><p><strong><code>Генерация картинок</code></strong></p><p>Malte рассматривает уже мёртвый сайт picbreeder, позволяющий генерировать картинки эволюционным алгоритмом, как систему генерации сокровищ (в этом случае, интересных картинок, которые “вывели” пользователи). В <a href="https://youtu.be/dKazBM3b74I" target="_blank" rel="noopener">докладе</a>, выделена пара свойств этой системы:</p><ul><li>Лучший результат получается внезапно, а  не в результате итераций. Вывести случайными изменениями красивую картинку целенаправленно сложно (условный чайник получается не последовательным выведением носика или крышки, а из чего-то, похожего на яйцо в шляпе).</li><li>Картинки, полученные в результате голосований, хуже, чем в ходе индивидуального исследования системы (тинкеринга).</li></ul><p>Неизвестно, насколько выводы применимы к другим системам генерации сокровищ. Новая итерация “разведения картинок” — нейросеть <code>Dall-E</code>. Она умеет рисовать картинки по текстовому описанию, и также позволяет итеративные эксперименты — уточнение текста описания, перерисовка понравившейся пользователю картинки, с возможностью оставить нетронутой какую-то часть изображения. Где-то в её недрах определенно есть сокровища, которыми ещё предстоит научиться пользоваться.</p><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/84Wnp7lx3io" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div><p><em>сны нейросети о коммунизме, автора оригинала не смог найти</em></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;В эссе &lt;a href=&quot;https://probablydance.com/2019/06/08/treasure-hunting-systems-found-in-the-history-of-video-games/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Treasure Hunting Systems Found in the History of Video Games
&lt;/a&gt; Malte Skarupke рассуждает о том, что в истории игр было несколько примеров случаев, когда появлялась платформа, в итоге порождающая сразу несколько новых успешных жанров. Он пытается выделить характеристики и свойства, общие для таких платформ, которые он называет “Системы поиска сокровищ”. Я не согласен со всеми наблюдениями автора, но попробую немного расширить его эссе. Это не перевод, а дополнение к оригинальной статье.&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="dev_method" scheme="http://spiiin.github.io/tags/dev-method/"/>
    
      <category term="gamedesign" scheme="http://spiiin.github.io/tags/gamedesign/"/>
    
  </entry>
  
  <entry>
    <title>Карта блога</title>
    <link href="http://spiiin.github.io/blog/3774050611/"/>
    <id>http://spiiin.github.io/blog/3774050611/</id>
    <published>2022-08-06T13:50:31.000Z</published>
    <updated>2022-08-20T12:47:03.418Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Про что я пишу.</p><h2 id="Разработка"><a href="#Разработка" class="headerlink" title="Разработка"></a>Разработка</h2><p><a href="https://spiiin.github.io/tags/gamedev/">Gamedev</a> - разработка игр<br><a href="https://spiiin.github.io/tags/dev/">Dev</a> - общее<br><a href="https://spiiin.github.io/tags/dev-evolution/">Dev_evolution</a> - развитие в геймдеве<br><a href="https://spiiin.github.io/tags/dev-method/">Dev_method</a> - идеи, методы и подходы к разработке (в основном игр)<br><a href="https://spiiin.github.io/tags/gamedesign/">Gamedesign</a> - геймдизайн (больше лудология, чем практика)</p><h2 id="Программирование"><a href="#Программирование" class="headerlink" title="Программирование"></a>Программирование</h2><p><a href="https://spiiin.github.io/tags/dascript/">daScript</a><br><a href="https://spiiin.github.io/tags/cpp/">C++</a><br><a href="https://spiiin.github.io/tags/python/">Python</a><br><a href="https://spiiin.github.io/tags/asm/">Assembler</a> - ассемблер, в основном старых консолей</p><p>Много по мелочи в тегах — 3d, c#, nim, opengl, lua, squirell, scala, objc, codespell</p><h2 id="Ромхакинг"><a href="#Ромхакинг" class="headerlink" title="Ромхакинг"></a>Ромхакинг</h2><p><a href="https://spiiin.github.io/tags/hack">Hack</a> - ромхакинг, исследования игр, CadEditor, переделки игр</p><p>Отдельно по платформам — nes, sega, gba</p><h2 id="Личное"><a href="#Личное" class="headerlink" title="Личное"></a>Личное</h2><p><a href="https://spiiin.github.io/tags/log/">Log</a> - личные заметки<br><a href="https://spiiin.github.io/tags/%D0%BA%D0%BD%D0%B8%D0%B3%D0%B8/">Книги</a> - рецензии на книги<br><a href="https://spiiin.github.io/tags/games/">Игры</a> - про игры<br><a href="https://spiiin.github.io/tags/juggling/">Juggling</a> - жонглирование<br><a href="https://spiiin.github.io/tags/hardware/">Hardware</a> - баловство с электроникой<br><a href="https://spiiin.github.io/tags/fun/">Fun</a> - развлечения<br><a href="https://spiiin.github.io/tags/link/">Link</a> - ссылки<br><a href="https://spiiin.github.io/tags/%D0%BA%D1%80%D0%B8%D0%BF%D1%82%D0%BE/">Крипто</a> - блокчейны и криптовалюты<br><a href="https://spiiin.github.io/tags/%D0%BB%D1%8E%D0%B4%D0%B8/">Люди</a> - краткие биографии крутых чуваков</p><h2 id="Страница-всех-тегов"><a href="#Страница-всех-тегов" class="headerlink" title="Страница всех тегов"></a>Страница всех тегов</h2><p><a href="https://spiiin.github.io/tags/meta/">Meta</a> - все теги и мета-посты вроде этого</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;Про что я 
      
    
    </summary>
    
    
    
      <category term="meta" scheme="http://spiiin.github.io/tags/meta/"/>
    
  </entry>
  
  <entry>
    <title>Итераторы, колстеки, корутины</title>
    <link href="http://spiiin.github.io/blog/2550823652/"/>
    <id>http://spiiin.github.io/blog/2550823652/</id>
    <published>2022-08-01T18:39:01.000Z</published>
    <updated>2022-08-08T15:26:58.811Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Малость нырнул в кучу статей про асинхронность и корутины в различных языках. Напишу небольшую выдержку (с переводами примеров на <code>daScript</code> там, где актуально), о том, что корутины можно начинать рассматривать как расширение возможностей итераторов и колбеков (функторов), а не с более часто встречающихся генерации последовательностей или реализации паттерна “продюсер-консюмер”.</p><p>Ссылки<br> [1] <a href="http://journal.stuffwithstuff.com/2013/01/13/iteration-inside-and-out/" target="_blank" rel="noopener">Iterators Inside and Out</a> - обзор итераторов в различных языках, для каких задач удобны<br> [2] <a href="http://journal.stuffwithstuff.com/2013/02/24/iteration-inside-and-out-part-2/" target="_blank" rel="noopener">Iterators Inside and Out. Part 2</a> - подводка к тому, что абстракция итераторов требует примитивов работы с параллельным кодом<br> [3] <a href="http://journal.stuffwithstuff.com/2013/04/17/well-done/" target="_blank" rel="noopener">Well Done: A Sentinel Value</a> - каналы<br> [4] <a href="https://users.livejournal.com/-winnie/421941.html" target="_blank" rel="noopener">Итератор: внутрь и наружу</a> - совсем краткий вывод из статей [1] и [2], и дополнения в комментариях<br> [5] <a href="https://fprog.ru/lib/ferguson-dwight-call-cc-patterns/" target="_blank" rel="noopener">Паттерны использования «call with current continuation»</a> - перевод статьи про паттерны использования call with continuations в Lisp, среди которых — реализация корутин<br> [6] Журнал “Практика функционального программирования”. Статья “Продолжения на практике” - пример “выворачивания” внутреннего итератора во внешний<br> [7] <a href="https://yehudakatz.com/2010/02/07/the-building-blocks-of-ruby/" target="_blank" rel="noopener">The building blocks of Ruby</a> - особенности блоков в Ruby, нелокальные возвраты из итераторов<br> [8] <a href="https://okmij.org/ftp/Scheme/enumerators-callcc.html" target="_blank" rel="noopener">General ways to traverse collections</a> - обзоры способов обхода коллекций, примеры на Scheme. Итератор с памятью (стейт-машина) в функциональном стиле<br> [9] <a href="https://okmij.org/ftp/papers/LL3-collections-enumerators.txt" target="_blank" rel="noopener">Towards the best collection API</a> - пример “выворачивания” итераторов на Scheme<br> [10] <a href="https://legacy.cs.indiana.edu/~sabry/papers/yield.pdf" target="_blank" rel="noopener">Yield: Mainstream Delimited Continuations</a> - yield в разных языках. <a href="https://en.wikipedia.org/wiki/Delimited_continuation" target="_blank" rel="noopener">Delimited continuations</a><br> [11] <a href="http://pllab.is.ocha.ac.jp/~asai/cw2011tutorial/main-e.pdf" target="_blank" rel="noopener">Introduction to Programming with Shift and Reset</a> - операторы shift и reset<br> [12] <a href="https://probablydance.com/2015/01/11/ideas-for-a-programming-language-part-2-a-more-liberal-call-stack/" target="_blank" rel="noopener">Ideas for a Programming Language Part 2: A more liberal call stack</a> - про недостатки абстракции стека вызовов<br> [13] <a href="https://www.chiark.greenend.org.uk/~sgtatham/coroutines.html" target="_blank" rel="noopener">Coroutines in C</a> - классическая статья про проблемы реализации корутин в C. Трюк с реализацией корутин с помощью <a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%B5%D1%82%D0%BE%D0%B4_%D0%94%D0%B0%D1%84%D1%84%D0%B0" target="_blank" rel="noopener">метода Даффа</a><br> [14] <a href="https://probablydance.com/2021/10/31/c-coroutines-do-not-spark-joy" target="_blank" rel="noopener">C++ Coroutines Do Not Spark Joy</a> - обзор реализации корутин в стандарте C++<br> [15] <a href="https://www.scs.stanford.edu/~dm/blog/c++-coroutines.html#the-promise-object" target="_blank" rel="noopener">My tutorial and take on C++20 coroutines</a> - ещё одна статья про корутины в C++ 20, трюк с хранением результата корутины на стеке через Promise Object<br> [16] <a href="https://github.com/lewissbaker/cppcoro" target="_blank" rel="noopener">CppCoro - A coroutine library for C++</a> - библиотека обёрток над корутинами из стандарта C++<br> [17] <a href="https://www.youtube.com/watch?v=8C8NnE1Dg4A" target="_blank" rel="noopener">CppCon 2016: Gor Nishanov “C++ Coroutines: Under the covers”</a> - доклад про реализацию корутин в стандарте C++, особенности реализации генерируемого кода в LLVM, возможности по оптимизации кода на уровне LLVM. Хорошо для понимания того, когда возможна элиминация выделения памяти. <a href="https://llvm.org/docs/Coroutines.html" target="_blank" rel="noopener">LLVM coroutines</a> - интринсики для корутины в LLVM.<br> [18] <a href="https://probablydance.com/2013/02/20/handmade-coroutines-for-windows/" target="_blank" rel="noopener">Handmade Coroutines for Windows</a> - альтернативные реализации корутин для windows. Раз C++ не даёт прямого доступа к указателю на стек, можно подменить его на ассемблере<br> [19] <a href="https://probablydance.com/2012/11/18/implementing-coroutines-with-ucontext/" target="_blank" rel="noopener">Implementing coroutines with ucontext</a> - реализация корутин через posix ucontext<br> [20] <a href="https://www.boost.org/doc/libs/1_79_0/libs/context/doc/html/index.html" target="_blank" rel="noopener">Boost::Context</a> - реализации переключения контекста из boost. Используют обёртки над posix или платформенные заголовки для переключения контекста, или <a href="https://gcc.gnu.org/wiki/SplitStacks" target="_blank" rel="noopener">ассемблерный трюк</a> из gcc (<a href="https://gcc.gnu.org/legacy-ml/gcc-help/2012-03/msg00395.html" target="_blank" rel="noopener">особенности реализации</a>)<br> [21] <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0534r3.pdf" target="_blank" rel="noopener">call/cc (call-with-current-continuation): A low-level API for stackful context switching</a> - пропозал по добавлению в стандарт c++ функционала call/cc<br> [22] <a href="https://go.dev/doc/effective_go#goroutines" target="_blank" rel="noopener">Goroutines</a> - горутины из go, управляются рантаймом языка. <a href="https://go.dev/tour/concurrency/1" target="_blank" rel="noopener">Tour of Go. Goroutines</a>. Планировщик горутин кооперативный, но “ощущается”, как вытесняющий<br> [23] <a href="https://www.youtube.com/watch?v=YEKjSzIwAdA" target="_blank" rel="noopener">Concurrency Patterns In Go</a> - каналы, оператор select выбора из нескольких каналов<br> [24] <a href="https://www.raywenderlich.com/books/kotlin-coroutines-by-tutorials/v2.0/chapters/5-async-await" target="_blank" rel="noopener">Kotlin coroutines. async/await</a> - многопоточные async/await в Kotlin. Идиомы future/promise, async/await/deferred<br> [25] <a href="http://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/" target="_blank" rel="noopener">What Color is Your Function?</a> - проблемы с комбинированием синхронных и асинхронных функций<br> [26] <a href="https://kristoff.it/blog/zig-colorblind-async-await/" target="_blank" rel="noopener">What is Zig’s “Colorblind” Async/Await?</a> - необычный подход Zig, трансформация синхронных функций в асинхронные и наоборот<br> [27] <a href="https://ziglearn.org/chapter-5/" target="_blank" rel="noopener">Zyg’s Async</a> - Async в Zig (<a href="https://ziglang.org/documentation/master/#Async-Functions" target="_blank" rel="noopener">документация</a>)</p><h2 id="Внешние-итераторы"><a href="#Внешние-итераторы" class="headerlink" title="Внешние итераторы"></a>Внешние итераторы</h2><p>Внешний итератор — объект, реализующий некоторый интерфейс Iterator (<a href="http://msdn.microsoft.com/en-us/library/system.collections.ienumerable.aspx" target="_blank" rel="noopener">C#</a>, <a href="https://docs.python.org/2/library/stdtypes.html#iterator-types" target="_blank" rel="noopener">Python</a>), у которого есть методы получения первого элемента коллекции (метод у коллекции или свободная функция), перехода на следующий элемент, и проверки на то, есть ли ещё элементы. На шаблонах C++ — явного интерфейса нет, но есть протокол, декларирующий способы описания итератора для своих типов.</p><p>Рассматривается в книге Банды Четырёх. В [8] критикуется название за активный суффикс -or, хотя методы итератор зовёт внешний код, предлагается название iteratee. Итераторы в стиле C++ также называют курсорами.</p><p><a href="https://dascript.org/doc/reference/language/iterators.html?highlight=iterator" target="_blank" rel="noopener">Итераторы</a> в <code>daScript</code>:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var it &lt;- each ([[<span class="keyword">int</span> <span class="number">1</span>;<span class="number">2</span>;<span class="number">3</span>;<span class="number">4</span>;<span class="number">5</span>]]) <span class="comment">//создание итератора</span></span><br><span class="line">var x : <span class="keyword">int</span></span><br><span class="line"><span class="function"><span class="keyword">while</span> <span class="title">next</span><span class="params">(it, x)</span>      <span class="comment">// получение следующего значения</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"x = &#123;x&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">verify</span><span class="params">(empty(it))</span>      <span class="comment">// функция проверки проверки существования следующего значения</span></span></span><br></pre></td></tr></table></figure><p>Часто в языках есть синтаксический сахар для того, чтобы записывать выражение выше как <code>for-each</code> цикл:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var it &lt;- each ([[<span class="keyword">int</span> <span class="number">1</span>;<span class="number">2</span>;<span class="number">3</span>;<span class="number">4</span>;<span class="number">5</span>]])</span><br><span class="line"><span class="keyword">for</span> x in it</span><br><span class="line">  print(<span class="string">"x = &#123;x&#125;\n"</span>)</span><br></pre></td></tr></table></figure></p><p>Элегантно решаемая внешним итератором задача:</p><p><strong><code>Поиск элемента</code></strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//TT - generic-тип, TT-&amp; - "убрать из определения типа символ ссылки"</span></span><br><span class="line"><span class="function">def <span class="title">find</span><span class="params">(it: iterator&lt;<span class="keyword">auto</span>(TT)&gt;; value:TT-&amp;)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">for</span> x in it</span></span><br><span class="line"><span class="function">    <span class="keyword">if</span> x </span>== value &#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>Более неаккуратное решение</p><p><strong><code>Проверка двух коллекций на равенство</code></strong><br>(и эквивалентные задачи, требуюшие поочередного обращения к двум или более коллекциям — функция <code>zip</code>; итератор выдающий по очереди элементы каждой коллекции)</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">is_equal</span><span class="params">(it1, it2: iterator&lt;<span class="keyword">auto</span>(TT)&gt;)</span></span></span><br><span class="line">  var i2: TT-&amp;</span><br><span class="line">  var it2Ended: <span class="keyword">bool</span></span><br><span class="line">  <span class="keyword">for</span> i1 in it1               <span class="comment">//обращение к первому итератору</span></span><br><span class="line">    it2Ended = next(it2, i2)  <span class="comment">//обращение ко второму итератору</span></span><br><span class="line">    <span class="keyword">if</span> !it2Ended || (i1 != i2)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  <span class="keyword">return</span> !next(it2, i2)</span><br></pre></td></tr></table></figure><p>Неэлегантный пример</p><p><strong><code>Итератор в дереве</code></strong></p><p>Рекурсивная функция печати дерева на экран занимает 4 строки<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span></span></span><br><span class="line"><span class="class">  <span class="title">data</span>:</span> <span class="keyword">int</span></span><br><span class="line">  left, right: Tree?</span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">printTree</span><span class="params">(a: Tree?)</span></span></span><br><span class="line">  if a != null</span><br><span class="line">    printTree(a.left)</span><br><span class="line">    print(<span class="string">"&#123;a.data&#125;\n"</span>)</span><br><span class="line">    printTree(a.right)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">let tree = <span class="keyword">new</span> [[ Tree </span><br><span class="line">    data = <span class="number">5</span>,</span><br><span class="line">    left = <span class="keyword">new</span> [[Tree </span><br><span class="line">      data = <span class="number">1</span></span><br><span class="line">    ]],</span><br><span class="line">    right = <span class="keyword">new</span> [[Tree</span><br><span class="line">      data = <span class="number">7</span>,</span><br><span class="line">      right = <span class="keyword">new</span> [[Tree</span><br><span class="line">        data = <span class="number">10</span></span><br><span class="line">      ]]</span><br><span class="line">    ]]</span><br><span class="line">  ]] </span><br><span class="line">printTree(tree)</span><br></pre></td></tr></table></figure></p><p>Попробуем написать итератор для дерева. Строительным блоком для кастомных внешних итераторов в <code>daScript</code> служат <a href="https://dascript.org/doc/reference/language/lambdas.html?highlight=lambda#iterators" target="_blank" rel="noopener">лямбда-функции</a>.<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IterateState</span></span></span><br><span class="line"><span class="class">  <span class="title">tree</span>:</span> Tree?</span><br><span class="line">  step: <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">var <span class="built_in">stack</span>: <span class="built_in">array</span>&lt;IterateState?&gt;</span><br><span class="line"><span class="built_in">stack</span> |&gt; push(<span class="keyword">new</span> [[IterateState tree = tree]])</span><br><span class="line">unsafe</span><br><span class="line">  let treeIterator &lt;- @ &lt;| (var current: <span class="keyword">int</span>&amp;) : <span class="keyword">bool</span></span><br><span class="line">    var hasValue = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">while</span> !empty(<span class="built_in">stack</span>) &amp;&amp; !hasValue</span><br><span class="line">      var state = back(<span class="built_in">stack</span>)</span><br><span class="line">      <span class="keyword">if</span> state.step == <span class="number">0</span></span><br><span class="line">        state.step = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (state.tree.left != null)</span><br><span class="line">          push(<span class="built_in">stack</span>, <span class="keyword">new</span> [[IterateState tree = state.tree.left]])</span><br><span class="line">      elif state.step == <span class="number">1</span></span><br><span class="line">        state.step = <span class="number">2</span></span><br><span class="line">        current = state.tree.data</span><br><span class="line">        hasValue = <span class="literal">true</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        pop(<span class="built_in">stack</span>)</span><br><span class="line">        <span class="keyword">if</span> (state.tree.right != null)</span><br><span class="line">          push(<span class="built_in">stack</span>, <span class="keyword">new</span> [[IterateState tree = state.tree.right]])</span><br><span class="line">    <span class="keyword">return</span> hasValue</span><br><span class="line">  <span class="keyword">for</span> v in each(treeIterator)</span><br><span class="line">    print(<span class="string">"&#123;v&#125;\n"</span>)</span><br></pre></td></tr></table></figure></p><p>Можно также написать итератор в ООП стиле, определив класс в C++ и перегрузив функцию <a href="https://github.com/GaijinEntertainment/daScript/blob/6f0f1a7025f20cb5a0fc73838e97ba371eb5c263/include/daScript/ast/ast.h#L415" target="_blank" rel="noopener">isIterable</a>, но пример в ООП-стиле есть в [1], он там занимает также занимает 50 строк.</p><p>На <code>daScript</code> получилось 26, но всё равно, как, во имя Святой Матери Тьюринга, из четырёх-строчной рекурсивной функции получилась такая каша?</p><h2 id="Колстек"><a href="#Колстек" class="headerlink" title="Колстек"></a>Колстек</h2><p>Часть работы в функции <code>printTree</code> за нас выполнила скрытая структура данных, <strong><code>callstack</code></strong>. </p><p>Во время рекурсивного первого рекурсивного вызова программа кладёт в стек адрес возврата, и осуществляет вызов этой функции, затем проделывает работу по вызову “полезной нагрузки” (<code>print</code>). После чего в следует второй рекурсивный вызов.</p><blockquote><p>Если на собеседовании у вас спросят, какая у вас любимая структура данных, смело отвечайте “стек вызовов”, и рассказывайте про то, как было бы плохо писать программы без него</p></blockquote><p>Если внимательно посмотреть на структуру функции <code>treeIterator</code>, можно заметить, что она выполняет те же шаги, в той же последовательности!</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">printTree</span><span class="params">(a: Tree?)</span></span></span><br><span class="line"><span class="function">    <span class="comment">//step 0 - кладём в стек адрес возврата, и начинаем новую итерацию вызова функции</span></span></span><br><span class="line"><span class="function">    <span class="title">printTree</span><span class="params">(a.left)</span></span></span><br><span class="line"><span class="function">    <span class="comment">//step 1 - выполняем "полезную нагрузку"</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">"&#123;a.data&#125;\n"</span>)</span></span></span><br><span class="line"><span class="function">    <span class="comment">//step 2 - кладём в стек адрес возврата</span></span></span><br><span class="line"><span class="function">    <span class="title">printTree</span><span class="params">(a.right)</span></span></span><br><span class="line"><span class="function">    <span class="comment">//невидимый</span></span></span><br><span class="line"><span class="function">    <span class="comment">//step 3 - ..выходим из функции, удаляем из стека верхнее значение, возвращаемся выше по стеку</span></span></span><br></pre></td></tr></table></figure><p>Можно заметить небольшое различие на шаге 2 — в реализации <code>printTree</code> сначала происходит второй рекурсивный вызов, и затем возврат из основной функции, а в <code>treeIterator</code> значение сначала удаляется из стека, а затем в него кладётся новое. Это похоже на то, как происходит <a href="https://en.wikipedia.org/wiki/Tail_call" target="_blank" rel="noopener">tail call optimization</a> — вместо того, чтобы положить в стек второе значение, а потом удалить и два верхних значения, мы сразу же удаляем ненужный более адрес возврата, т.е. выполняем step3, еще до step2.</p><p>Также функция <code>printTree</code> приостанавливается в точках 0 и 2, на момент вызова подпрограммы, и продолжает выполнение после возврата из подпрограммы. Это вторая крутая возможность, которую предоставляет колстек, и о которой при программировании обычно даже не задумываются. Однако при кастомной реализации итератора мы сталкиваемся с тем, что без каких-либо особых трюков приостановить выполнение функции и продолжить его с того же места невозможно. Вместо этого приходится эмулировать паузы с помощью конечного автомата, реализуемого с помощью цикла и переключения пути выполнения изменением переменной <code>state</code>.</p><p>Собственно, большинство идей, связанных с сопрограммами (википедия <a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B0" target="_blank" rel="noopener">напоминает</a>, что ни в коем случае не следует путать их с копрограммами!), так или иначе связаны с тем, чтобы предоставить нам возможность приостанавливать выполнение функции и продолжать его.</p><p>Уже может стать понятно, что для этого язык должен каким-либо образом предоставить языковые конструкции, которые позволили бы нам не определять переменную <code>var stack: array&lt;IterateState?&gt;</code> явно, а “отдавать команду” положить туда что-то неявно, в идеале так же прозрачно, как это происходит в момент вызова функции.</p><p>Также стоит обратить внимание на то, где выделяется и хранится эта переменная. Здесь это просто локальная переменная, захваченная лямбда-функцией, но перед компилятором при реализации сопрограмм стоит серьёзная задача — где разместить этот “другой” стек. С одной стороны — его можно выделить в куче, чтобы он мог “пережить” область создания итератора, с другой — такая аллокация замедляет создание сопрограмм.</p><p>В общем-то, практически все отличия в реализации сопрограмм в разных языках сводятся к тому, чтобы различными способами решить эти вопросы — где и как будут выделяться <em>“другие стеки”</em>, и каким образом к ним можно обращаться из языка. Различных подходов много, и они имеют свои плюсы и минусы. Если с этого момента <em>прояснилось</em>, можно походить по ссылкам, заглянуть, кто что придумал в различных языках. Впрочем, можно снова зависнуть где-нибудь на Лиспе, или языках с ленивыми вычислениями.</p><p>Но пока вернёмся к колстеку — стоит ещё раз сравнить функции <code>printTree</code> и более общую <code>treeIterator</code>, и помедитировать на способ, которым сделано обобщение. Такое представление “невидимого” в коде колстека в явном виде называется <a href="https://en.wikipedia.org/wiki/Reification_(computer_science" target="_blank" rel="noopener">реификацией</a>.</p><h2 id="Внутренние-итераторы"><a href="#Внутренние-итераторы" class="headerlink" title="Внутренние итераторы"></a>Внутренние итераторы</h2><p>Внутренний итератор — функция-callback, которая передаётся в функцию обхода коллекции.</p><p>Итерация разделяет код на 2 части: (1) код ответственный за генерацию серии объектов, и  (2) код, который выполняет над переданным ему объектом некоторую операцию. Для внешних итераторов это (1) тип, который может реализовывать протокол итерации и (2) тело цикла обхода. В этом стиле (2) является главным, он решает, когда запросить следующее значение, или когда прекратить итерации. Внутренние итераторы выворачивают всё наизнанку. Код, который генерирует значения, решает, когда ему вызвать переданный ему колбек.</p><p>Внешние функции, перебирающие значения, могут быть реализованы как методы объекта (<a href="https://apidock.com/ruby/Array/each" target="_blank" rel="noopener">array.each</a> в Ruby), или generic-функции (<a href="https://en.cppreference.com/w/cpp/algorithm/ranges/find" target="_blank" rel="noopener">std::find_if</a> в C++)</p><p>Элегантно решаемые внутренними итераторами задачи:</p><p><strong><code>Итерация по дереву</code></strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">each</span><span class="params">(var tree:Tree?; blk:lambda&lt;(what: <span class="keyword">int</span>):<span class="keyword">void</span>&gt;)</span></span></span><br><span class="line"><span class="function">  <span class="title">if</span> <span class="params">(tree.left != null)</span>  </span>&#123; each(tree.left, blk); &#125;</span><br><span class="line">  invoke(blk, tree.data)</span><br><span class="line">  <span class="keyword">if</span> (tree.right != null) &#123; each(tree.right, blk); &#125;</span><br><span class="line"></span><br><span class="line">tree |&gt; each() &lt;| @(value: <span class="keyword">int</span>)</span><br><span class="line">  print(<span class="string">"&#123;value&#125;\n"</span>)</span><br></pre></td></tr></table></figure><p>Отлично, в 3 строчки.</p><p><strong><code>Поиск элемента</code></strong></p><p>Возьмём общий внутренний генератор <code>map</code> из стандартной-библиотеки <a href="https://github.com/GaijinEntertainment/daScript/blob/master/daslib/functional.das" target="_blank" rel="noopener">functional</a> функцию поиска индекса элемента в массиве по условию (это синтетический пример, в модуле <code>buildin</code> есть более эффективная реализация этой <a href="https://github.com/GaijinEntertainment/daScript/blob/a7c6565f652b56d0eee82b6e27974cdc09f06574/src/builtin/builtin.das#L701" target="_blank" rel="noopener">функции</a>)</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">my_find_index_if</span><span class="params">(var arr: iterator&lt;<span class="keyword">auto</span>(TT)&gt; <span class="keyword">explicit</span>; blk:lambda&lt;(what:TT -&amp;):<span class="keyword">auto</span>(QQ)&gt;)</span></span></span><br><span class="line">  for value, i in map(arr, blk), range(INT_MAX)</span><br><span class="line">    <span class="keyword">if</span> value</span><br><span class="line">      <span class="keyword">return</span> i</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//using</span></span><br><span class="line">var it &lt;- each ([[<span class="keyword">int</span> <span class="number">0</span>;<span class="number">1</span>;<span class="number">2</span>;<span class="number">3</span>;<span class="number">4</span>]])</span><br><span class="line">var answer = it |&gt; my_find_index_if &lt;| @(value: <span class="keyword">int</span>)</span><br><span class="line">  print(<span class="string">"check: &#123;value&#125;\n"</span>)</span><br><span class="line">  <span class="keyword">return</span> value &gt; <span class="number">1</span></span><br><span class="line">print(<span class="string">"&#123;answer&#125;\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">check: <span class="number">0</span></span><br><span class="line">check: <span class="number">1</span></span><br><span class="line">check: <span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>Здесь таится интересный момент, связанный с прерыванием итерации. Почему функция <code>map</code> не выполнила проверку 3 и 4 элемента массива? Каким именно образом функция <code>map</code> “узнала”, что нужно остановить итерацию?<br>Если вы попробуете реализовать функцию <code>find_index</code> с помощью <code>std::for_each</code> в C++, то стокнётесь в проблемой, что <code>return</code> не может остановить итерацию <code>for_each</code>.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_index</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; myvector, <span class="built_in">std</span>::function&lt;<span class="keyword">bool</span>(<span class="keyword">int</span>)&gt; checker)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> answer = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">bool</span> answerFound = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">auto</span> fn = <span class="built_in">std</span>::for_each(myvector.begin(), myvector.end(), [&amp;](<span class="keyword">int</span> i) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"check:"</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span> (!answerFound) &#123;</span><br><span class="line">            <span class="keyword">if</span>(checker(i)) &#123;</span><br><span class="line">                answer = i;</span><br><span class="line">                answerFound = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">//невозможно остановить выполнение for_each</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; find_index(myvector, [](<span class="keyword">int</span> i) &#123;</span><br><span class="line">      <span class="keyword">return</span> i &gt; <span class="number">1</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; find_index(myvector);</span><br><span class="line"><span class="comment">//Output</span></span><br><span class="line">check:<span class="number">0</span></span><br><span class="line">check:<span class="number">1</span></span><br><span class="line">check:<span class="number">2</span></span><br><span class="line">check:<span class="number">3</span></span><br><span class="line">check:<span class="number">4</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>Что именно мешает лямбда-функции, переданной в <code>for_each</code> прекратить итерацию? Ответ - колстек, а точнее стекфрейм функций. В момент вызова лямбда-функции внутри for_each он выглядит так:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main</span><br><span class="line">  find_index</span><br><span class="line">    for_each</span><br><span class="line">    стекфрейм for_each</span><br><span class="line">      for_each_lambda</span><br><span class="line">        checker_lambda</span><br></pre></td></tr></table></figure></p><p><code>for_each</code> как и любая функция, может выделить себе дополнительную память на стеке под свои нужны, и если <code>for_each_lambda</code> или <code>checker_lambda</code> захотят выйти на уровень выше <code>for_each</code>, им нужно уметь раскручивать стек (скорее всего, конкретно для for_each там ничего нет, но сама необходимость раскрутки всего, что находится между функциями разного уровня на стеке блокирует возможность выхода)</p><p>Конечно, раскручивать стек в C++ умеют исключения, но… просто посмотрите на этот код и никогда так не делайте:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_index</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; myvector, <span class="built_in">std</span>::function&lt;<span class="keyword">bool</span>(<span class="keyword">int</span>)&gt; checker)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">auto</span> fn = <span class="built_in">std</span>::for_each(myvector.begin(), myvector.end(), [&amp;](<span class="keyword">int</span> i) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"check:"</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">if</span>(checker(i)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> i; <span class="comment">//"выбрасываем" ответ из foreach</span></span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (<span class="keyword">int</span> throwedAnswer) &#123;</span><br><span class="line">        <span class="keyword">return</span> throwedAnswer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Возможность раскручивать стек называется <code>non-local returns</code> и присутствует в языках типа <code>Ruby</code> (пример в [1]) или <code>Kotlin</code> [24]:<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">val</span> value = <span class="number">3</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="string">""</span></span><br><span class="line">list.forEach &#123; </span><br><span class="line">  result += <span class="string">"<span class="variable">$it</span>"</span></span><br><span class="line">  <span class="keyword">if</span> (it == value)</span><br><span class="line">    <span class="keyword">return</span><span class="symbol">@forEach</span> <span class="comment">//выход из foreach</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//result="123"</span></span><br></pre></td></tr></table></figure></p><p>Другой более универсальный подход, реализованный в <code>daScript</code> и других языках с поддержкой генераторов — приостанавливать выполнение <code>map/for_each</code> и передавать промежуточные результаты “вовне”, с возможностью по желанию прекратить приостановленную итерацию на уровень выше (генераторы также известны как “елды” среди добравшихся до Unity артистов).</p><p>Совсем нехороший пример</p><p><strong><code>Проверка двух коллекций на равенство</code></strong></p><p>Без задействования генераторов, корутин, потоков или продолжений, или других способов приостановить функцию, не пишется. Мешают, как и в предыдущем примере, всё те же стекфреймы в колстеке. Но если в примере с ранним выходом из внутреннего итератора удавалось хотя бы выкрутиться хаком и “выпрыгнуть” с помощью исключений, необратимо раскрутив стек, то здесь для приостановки каждой из двух функций-колбеков нужно хранить оба состояния обеих функций.</p><h2 id="Генераторы"><a href="#Генераторы" class="headerlink" title="Генераторы"></a>Генераторы</h2><p>Генераторы — это возобновляемые функции. Возвращаемый тип генератора — итератор (гибрид между внутренним и внешним)</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">let gen &lt;- generator&lt;<span class="keyword">int</span>&gt;() &lt;| $()</span><br><span class="line">  <span class="function"><span class="keyword">for</span> t in <span class="title">range</span><span class="params">(<span class="number">0</span>,<span class="number">10</span>)</span></span></span><br><span class="line"><span class="function">    yield t</span></span><br><span class="line"><span class="function">  <span class="keyword">return</span> <span class="literal">false</span></span></span><br></pre></td></tr></table></figure><p><code>map</code>, как и большинство функций из модуля <code>functional</code> в <code>daScript</code>, возвращают генераторы, так что с помощью неё должно быть возможно (хотя и не нужно) реализовать проверку двух коллекций на равенство, недоступную для внутренних итераторов в языках без поддержки генераторов:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">is_equal</span><span class="params">(var it1, it2: iterator&lt;<span class="keyword">auto</span>(TT)&gt;)</span></span></span><br><span class="line"><span class="function">  unsafe</span></span><br><span class="line"><span class="function">    var equalResult </span>= <span class="literal">true</span></span><br><span class="line">    <span class="comment">//один из генераторов возвращает значения из коллекции</span></span><br><span class="line">    var aGenerator &lt;- it1 |&gt; <span class="built_in">map</span> &lt;| @(aValue:TT-&amp;)</span><br><span class="line">      <span class="keyword">return</span> aValue</span><br><span class="line">    //второй генератор берёт значение из второй коллекции и сравниваем со значением из другого генератора</span><br><span class="line">    //лямбда-функция захватывает первый генератор для получения значений из него</span><br><span class="line">    var bGenerator &lt;- it2 |&gt; <span class="built_in">map</span> &lt;| @ [[&amp;aGenerator]](bValue:TT-&amp;)</span><br><span class="line">      var aValue : TT-&amp;</span><br><span class="line">      <span class="keyword">if</span> !next(aGenerator, aValue)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      print("&#123;bValue&#125; &#123;aValue&#125;\n")</span><br><span class="line">      <span class="keyword">return</span> bValue == aValue</span><br><span class="line">    //продолжаем брать из генераторов значения, пока она эквивалентны</span><br><span class="line">    <span class="keyword">while</span> equalResult &amp;&amp; next(bGenerator, equalResult)</span><br><span class="line">      pass</span><br><span class="line">    //коллекции эквивалентны, если оба итератора обработали все значения</span><br><span class="line">    var aLast : <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">return</span> !next(aGenerator, aLast) &amp;&amp; empty(bGenerator)</span><br></pre></td></tr></table></figure><p><strong><code>Двунаправленные генераторы</code></strong></p><p><code>Python</code> поддерживает также <a href="https://docs.python.org/3/reference/expressions.html#generator.send" target="_blank" rel="noopener">отправку</a> данных генератору из вызывающего кода</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">double_inputs</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="meta">... </span>        x = <span class="keyword">yield</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">yield</span> x * <span class="number">2</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gen = double_inputs()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(gen)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gen.send(<span class="number">10</span>)</span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(gen)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gen.send(<span class="number">6</span>)</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure><h2 id="Разворачивание-итераторов"><a href="#Разворачивание-итераторов" class="headerlink" title="Разворачивание итераторов"></a>Разворачивание итераторов</h2><p>Теперь рассмотрим возможность “выворачивания” итераторов. К примеру, у нас есть “красивая” версия внутреннего итератора <code>each</code> для дерева, и функция сравнения, принимающая внешние итераторы, в которую хочется передать итератор обхода дерева.</p><p>Для начала посмотрим, как можно передать значения из лямбда функции “наружу”, с помощью захвата в замыкание (closure) лямбда-функции:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">to_array</span><span class="params">(var tree : Tree?)</span></span></span><br><span class="line"><span class="function">  unsafe</span></span><br><span class="line"><span class="function">    var arr: <span class="built_in">array</span>&lt;<span class="keyword">int</span>&gt;</span></span><br><span class="line"><span class="function">    <span class="comment">//захватываем arr в замыкание по ссылке</span></span></span><br><span class="line">    each(tree) &lt;| @[[&amp;arr]](value: int)</span><br><span class="line">      arr |&gt; push(value)</span><br><span class="line">    <span class="keyword">return</span> &lt;- arr</span><br></pre></td></tr></table></figure><p>Функция накапливает все значения в переменной <code>arr</code> и возвращает полностью собранный массив. Следующим шагом попробуем избавиться от этого накопления и вернуть управление вызывающему коду, как только будет получено следующее значение из <code>each</code>. Но тут возникает следующая проблема. Если <code>each</code> не задизайнена так, чтобы её можно было останавливать, то её и невозможно будет остановить из колбека. Т.е. нам нужна другая функция <code>each_async</code>, которая будет возвращать значение через генератор <code>yield</code>.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">each_async</span><span class="params">(tree:Tree?)</span> : iterator&lt;<span class="keyword">int</span>&gt;</span></span><br><span class="line">    return &lt;- generator&lt;int&gt;() &lt;| $ ()</span><br><span class="line">      <span class="keyword">if</span> tree.left != null</span><br><span class="line">        <span class="keyword">for</span> newVal in each_async(tree.left)</span><br><span class="line">          yield newVal</span><br><span class="line">      yield tree.data</span><br><span class="line">      <span class="keyword">if</span> tree.right != null</span><br><span class="line">        <span class="keyword">for</span> newVal in each_async(tree.right)</span><br><span class="line">          yield newVal</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">var eq = is_equal(each_async(tree1), each_async(tree2))</span><br></pre></td></tr></table></figure><p>Чуть менее компактно, чем первоначальная версия, за счёт того, что из вложенных генераторов приходится доставать данные с помощью дополнительных циклов обхода (<code>yield</code> должно возвращать <code>int</code>, а вложенный генератор возвращает <code>iterator&lt;int&gt;</code>, из которого нужно достать данные для выдачи внешнему генератору).</p><p><code>Python</code> и некоторые другие языки поддерживают <strong><code>делегацию генераторов</code></strong> — синтаксический сахар, который позволяет избежать написания таких циклов<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">concat</span><span class="params">(a, b)</span>:</span></span><br><span class="line">  <span class="comment">#for item in walkFirst(a): yield item</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">#"берём значение из генератора и передаём дальше</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="keyword">from</span> walkFirst(a)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">walkFirst</span><span class="params">(a)</span>:</span></span><br><span class="line">  <span class="keyword">for</span> item <span class="keyword">in</span> a: <span class="keyword">yield</span> item</span><br></pre></td></tr></table></figure></p><p><strong>update</strong><br>Аналогичный макрос <a href="https://github.com/GaijinEntertainment/daScript/commit/3acb98e7c13456f59c73f482ef4396481cf30293" target="_blank" rel="noopener">yield_from</a> для <code>daScript</code></p><p>Но тут есть важный момент, снова возвращающий нас к колстекам. Делегация генераторов — это просто синтаксический сахар, но мы не можем написать возврат значения из вложенных функций, не прокидывая эту делегацию через каждый уровень вложенности. Чтобы полноценно выйти на несколько уровней вверх, в затем вернуться, нам потребуется структура, которая реифицирует не один уровень стека, а весь стек. Следующий пример на <code>ruby</code> показывает такую структуру.</p><h2 id="Файберы"><a href="#Файберы" class="headerlink" title="Файберы"></a>Файберы</h2><p>В [2] есть пример разворачивания итераторов из <code>Ruby</code>:</p><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyEnumerator</span></span></span><br><span class="line">  <span class="keyword">include</span> Enumerable</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(obj)</span></span></span><br><span class="line">    @fiber = Fiber.new <span class="keyword">do</span>  <span class="comment"># Spin up a new fiber.</span></span><br><span class="line">      obj.each <span class="keyword">do</span> <span class="params">|value|</span>  <span class="comment"># Run the internal iterator on it.</span></span><br><span class="line">        Fiber.<span class="keyword">yield</span>(value) <span class="comment"># When it yields a value, suspend</span></span><br><span class="line">                          <span class="comment"># the fiber and emit the value.</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      raise StopIteration  <span class="comment"># Then signal that we're done.</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">next</span></span></span><br><span class="line">    @fiber.resume          <span class="comment"># When the next value is requested,</span></span><br><span class="line">                           <span class="comment"># resume the fiber.</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><code>Yield</code> происходит прямо из <code>each</code> во внешнюю функцию! Если обратиться к предыдущим замечаниям про колстеки, то здесь будет:</p><ul><li><code>each</code> для дерева создаёт стек, в котором хранит адреса возвратом рекурсивных вызовов</li><li>метод <code>next</code> полностью “замораживает” этот стек, и переключается на другой, в управляющем коде.</li></ul><p>Так что <code>Fiber</code> здесь — структура, которая реифицирует не только фрейм стека, как генераторы, но весь стек полностью.<br><code>Файберы</code> имеют свой стек и копии локальных переменных. Один выполняются в одном потоке, и передача управления между ними управляется кодом пользователя — пока один файбер не передаст управление следующему, переключения не будет.</p><p>Файберы — своеобразная “точка связи” итерации с параллелизмом.</p><h2 id="Функции-без-стекфрейма"><a href="#Функции-без-стекфрейма" class="headerlink" title="Функции без стекфрейма"></a>Функции без стекфрейма</h2><p>В [12] рассматриваются альтернативы хранению временных переменных функции в стеке. В качестве примера рассматривается создание языков для визуального программирования типа <code>Kismet</code>/<code>Blueprint</code> из Unreal. Каждая функция-строительный кирпич заранее выделяет необходимую ей память и просто использует её повторно, если вызывается вновь. Если нужно вызвать функцию дважды — выделяется два блока памяти. Преимущество такого подхода — можно легко связывать цепочки функций вида “пойти в точку А, подождать секунду, затем проиграть анимацию и звук одновременно”.</p><p>Чтобы создать код связи нод на C++, может потребоваться код вида:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> bMoved = <span class="literal">false</span>;</span><br><span class="line">CompareBoolNode * cmp = <span class="keyword">new</span> CompareBoolNode(bMoved);</span><br><span class="line">DelayNode * first_delay = <span class="keyword">new</span> DelayNode(some_hardcoded_number);</span><br><span class="line">DelayNode * second_delay = <span class="keyword">new</span> DelayNode(another_hardcoded_number);</span><br><span class="line">DelayNode * third_delay = <span class="keyword">new</span> DelayNode(a_third_hardcoded_number);</span><br><span class="line">MatineeNode * matinee = <span class="keyword">new</span> MatineeNode(Matinee_0, Interior_Elevator_3);</span><br><span class="line">BoolNode * set_moved = <span class="keyword">new</span> BoolNode(bMoved, <span class="literal">true</span>);</span><br><span class="line">BoolNode * clear_moved = <span class="keyword">new</span> BoolNode(bMoved, <span class="literal">false</span>);</span><br><span class="line">cmp-&gt;onFalse += &amp;first_delay-&gt;start</span><br><span class="line">first_delay-&gt;onFinished += &amp;matinee-&gt;play;</span><br><span class="line">matinee-&gt;onCompleted += &amp;second_delay-&gt;start;</span><br><span class="line">second_delay-&gt;onFinished += &amp;matinee-&gt;reverse;</span><br><span class="line">second_delay-&gt;onFinished += &amp;set_moved-&gt;in;</span><br><span class="line">set_moved-&gt;out += &amp;third_delay-&gt;start;</span><br><span class="line">third-&gt;delay-&gt;onFinished = &amp;clear_moved-&gt;in;</span><br><span class="line"> </span><br><span class="line">RTriggerVolume_0.onTouched += &amp;cmp-&gt;in;</span><br></pre></td></tr></table></figure></p><p> При этом, на самом деле программист хотел бы написать этот же код, в таком виде:</p> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> bMoved = <span class="literal">false</span>;</span><br><span class="line">RTriggerVolume_0.Touched = [bMoved]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (bMoved)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    Delay(some_hardcoded_delay);</span><br><span class="line">    Matinee_0.Play(Interior_Elevator_3);</span><br><span class="line">    Delay(another_hardcoded_delay);</span><br><span class="line">    bMoved = <span class="literal">true</span>;</span><br><span class="line">    Matinee_0.Reverse(Interior_Elevator_3);</span><br><span class="line">    Delay(a_third_hardcoded_delay);</span><br><span class="line">    bMoved = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> Проблема в том, что в C++ сложно нет функции <code>Delay</code>. Файберы могут помочь с её реализацией, но иметь отдельный стек для каждой мелкой сопрограммы может быть дорого. Вместо этого компиляторы визуальных языков могут подсчитать, сколько памяти потребуется для всего скрипта, и выделить ему это весь этот блок целиком. Таким образом, во время выполнения нет аллокаций. Это не особо влияет на скорость, но влияет на то, все функции такого языка могут быть в любой момент прерваны и возобновлены — функции без фреймов на стеке не страдают от того, что кто-то другой перехватывает управление.</p><h2 id="Корутины-в-C"><a href="#Корутины-в-C" class="headerlink" title="Корутины в C++"></a>Корутины в C++</h2><p><strong><code>Реализация замаскированным конечным автоматом</code></strong><br>В [13] приведён хак-пример с тем, чтобы реализовать корутины с ограничениями на макросах с помощью объединения цикла и <code>switch</code> (грязный трюк, названный метод Даффа).</p><p><strong><code>Реализации корутин в виде платформо-зависимых библиотек</code></strong><br>Серьёзные реализации, использующие трюки на ассемблере или ucontext — [18] и [19] от Malte Skarupke и [20] <code>Boost::Context</code> от Oliver Kowalke. От него же, <a href="https://www.boost.org/doc/libs/?view=category_concurrent" target="_blank" rel="noopener">реализации</a> <code>coroutine2</code>(с выделением стеков на хипе, и first-class продолжениями) и <code>fiber</code> (<a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4024.pdf" target="_blank" rel="noopener">отличия</a> между ними, файбер здесь — green thread, поток, управляемый диспетчером. Файберы “живут” в одном кернел-треде. Ключевое отличие - корутины передают управление друг другу, буст-файберы — планировщику).</p><p>Бекграунд для реализации буст библиотек — переключатели контекста (через примитив <code>call/cc</code> из <code>Boost::Context</code>).</p><ul><li>fcontext_t - переключение асм-кодом (самое быстрое)</li><li>ucontext_t и WinFiber - в <a href="https://www.boost.org/doc/libs/1_79_0/libs/fiber/doc/html/fiber/overview/implementations__fcontext_t__ucontext_t_and_winfiber.html" target="_blank" rel="noopener">10-100 раз</a> более медленное переключение с использованием функций ядра ОС</li></ul><blockquote><p>Хороший ответ на вопросы из собеседований вроде “зачем может потребоваться писать код на ассемблере в 20XX году?”</p></blockquote><p><strong><code>Корутины из стандарта C++20</code></strong></p><p>В стандарте C++ 20 года реализована минимальная поддержка корутин. Корутины из стандарта, в отличие от <code>boost:coroutine</code> не имеют своего стека (стандарт отделался тем, что заявил “если хотите возвращать управление из вложенных функций — вам нужны файберы, а не корутины”). Также не содержит в std готовых примитивов-паттернов для удобной работы, вариант их реализации можно посмотреть в библиотеке <code>cppcoro</code> [16].</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Visitor</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">f</span>(<span class="title">Visitor</span>&amp; <span class="title">v</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//stackfull-корутина с передачей управления, boost::context</span></span><br><span class="line">asymmetric_coroutine&lt;T&gt;::<span class="function">pull_type <span class="title">pull_from</span><span class="params">([](asymmetric_coroutine&lt;T&gt;::push_type&amp; yield) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    f(yield);</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//stackless-корутина, C++ 20</span></span><br><span class="line"><span class="function">generator&lt;T&gt; <span class="title">pull_from</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// yield может быть вызвана только отсюда</span></span><br><span class="line">    f(???);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Можно вернуться к примерам с разворачиванием итераторов на <code>daScript</code> и <code>ruby</code>, и попробовать “спроецировать” их на синтаксис stackful-корутин.</p><p>В <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3708.pdf" target="_blank" rel="noopener">пропозале</a> по добавлению <code>boost::coroutine</code> в стандарт <code>C++</code> приведён как раз аналогичный пример с деревом, с явным продолжением-аргументом он выглядит впечатляюще круто:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> ContPush = boost::coroutines::coroutine&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;::push_type;</span><br><span class="line"><span class="keyword">using</span> ContPull = boost::coroutines::coroutine&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;::pull_type;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(tree* n, ContPush&amp; out)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n-&gt;left) traverse(n-&gt;left, out);</span><br><span class="line">  out(n-&gt;value);</span><br><span class="line">  <span class="keyword">if</span>( n-&gt;right) traverse(n-&gt;right, out);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tree* tree1 = testCreateTree1(), tree2 = testCreateTree2();</span><br><span class="line"></span><br><span class="line"><span class="comment">//трансформация внутреннего итератора во внешний</span></span><br><span class="line"><span class="function">ContPull&amp; <span class="title">iterator1</span><span class="params">([&amp;](ContPush&amp; out) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  traverse(tree1, out);</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ContPull&amp; <span class="title">iterator2</span><span class="params">([&amp;](ContPush&amp; out) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  traverse(tree2, out);</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//у boost::coroutines::coroutine&lt;std::string&gt;::pull_type есть iterator</span></span><br><span class="line"><span class="keyword">bool</span> isEqual = <span class="built_in">std</span>::equal(<span class="built_in">std</span>::begin(iterator1), <span class="built_in">std</span>::end(iterator1), <span class="built_in">std</span>::begin(itertor2));</span><br></pre></td></tr></table></figure><p>Stackless-корутины не позволяют таких трюков, так как используют стек вызывающего их кода, но более эффективны.<br>Benchmark из либы <a href="https://github.com/jamboree/co2" target="_blank" rel="noopener">CO2</a>, эмулирующей stackless-корутины (цена вызова корутины):<br><img src="/blog/2550823652/co2_benchmark.png" alt="bench"></p><p>Кроме вызова важна также стоимость создания корутины. В случае с <code>CO2</code> корутина — это только синтаксический сахар, и код работает быстро (но в этой библиотеки и нельзя “захватить” переменные на стеке в корутину после восстановления). В корутинах из стандарта C++, генерируется код с аллокацией таких данных в куче, и затем компилятор <strong>может</strong> оптимизировать эти аллокации в случае, если код удастся трансформировать и инлайнить. Сделает он это или нет — неизвестно.</p><p>В [14] Malte Skarupke приводит примеры, когда это не работало даже в относительно простых случаях, когда должно быть возможно. Узнать, будет или нет выполнена оптимизация — сложно, а разница в скорости между двумя вариантами — на два порядка, так что часто создавать корутины, полагаясь на то, что будет быстро, без постоянных проверок сгенерированного кода невозможно. Как происходит трансформация кода в LLVM детально рассматривается в [17] (ещё один большой кусок информации, которую должен держать в голове хороший C++ программист). Вдобавок меня пугает то, что такая трансформация требует повторного прохода всех стадий оптимизации (если я правильно понял презентацию, 32:14), время сборки большой программы — больное место языка.</p><p>Кому хотелось конкурентности, много лет как запилили себе файберы (чаще всего пулом, чтобы без переаллокаций, и с явным или неявным разбросом по тредам):<br><a href="https://www.gdcvault.com/play/1022186/Parallelizing-the-Naughty-Dog-Engine" target="_blank" rel="noopener">Naughty Dog: Parallelizing the Naughty Dog Engine Using Fibers</a><br><a href="https://www.youtube.com/watch?v=v2Q_zHG3vqg" target="_blank" rel="noopener">Multithreading the Entire Destiny Engine</a></p><p>Где-то дочитав досюда можно почитать туториал [15] по корутинам в C++ 20 и посмотреть на libcoro [16].</p><h2 id="Различия-в-терминологии"><a href="#Различия-в-терминологии" class="headerlink" title="Различия в терминологии"></a>Различия в терминологии</h2><p>Стоит отметить различие в определении файберов в различных языках. В некоторых файберы отличаются от генераторов только тем, что имеют стек. Такую таксономию например предлагает стандарт <code>C++ 20</code>. В других языках файберы может отличать ещё и то, что они передают управление не другому файберу, а диспетчеру, который выбирает, кому передать управление дальше.</p><p>Например, <code>boost::coroutine</code> называет корутину со стеком не файбером а <code>stackful coroutine</code>, а <code>fiber</code> — это то же + управление через диспетчер. Я тут встану на сторону C++ 20, потому что для корутин со стеком (файберов), которые вдобавок ещё и управляемые диспетчером, и так придумана куча названий. Встречаются:</p><ul><li><a href="http://www.lua.org/pil/9.html" target="_blank" rel="noopener">просто корутины</a> (в <code>lua</code> для большей путаницы назвали это так)</li><li><a href="https://github.com/stackless-dev/stackless/wiki/" target="_blank" rel="noopener">тасклеты</a> (<code>Stackless Python</code>, вообще богат на термины)</li><li><a href="https://go.dev/doc/effective_go#goroutines" target="_blank" rel="noopener">горутины</a> из <code>golang</code> ([22], [23]), причисляемыми в статьях к файберам, отличаются по функционалу, и могут раскидываться по различным тредам планировщиком задач языка (а следовательно, требуют синхронизации доступа к общим ресурсам), так что должны рассматривать отдельно.</li><li>зелёные потоки, протопотоки, микропотоки</li></ul><p>На этом закончу первую половину статьи. Вторая будет про диспетчеры, способы блокирования и комбинирования различных корутин между собой.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;Малость ны
      
    
    </summary>
    
    
    
      <category term="dev" scheme="http://spiiin.github.io/tags/dev/"/>
    
      <category term="link" scheme="http://spiiin.github.io/tags/link/"/>
    
      <category term="dascript" scheme="http://spiiin.github.io/tags/dascript/"/>
    
      <category term="cpp" scheme="http://spiiin.github.io/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>daScript - скорость</title>
    <link href="http://spiiin.github.io/blog/1067581840/"/>
    <id>http://spiiin.github.io/blog/1067581840/</id>
    <published>2022-07-27T14:05:01.000Z</published>
    <updated>2022-11-05T16:41:41.326Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Рассказывал о <code>daScript</code> коллеге в отпуске, в ответ на то, почему он такой быстрый, задумался, что особо коротко и не ответишь, не влезая в детали реализации, проще замерить. Очень поверхностно:</p><h2 id="Заявленное-авторами"><a href="#Заявленное-авторами" class="headerlink" title="Заявленное авторами"></a>Заявленное авторами</h2><p>(<a href="https://dascript.org/doc/reference/introduction.html#performance" target="_blank" rel="noopener">Performance</a>, <a href="https://dascript.org/" target="_blank" rel="noopener">overview</a>, <a href="https://dascript.org/doc/reference/embedding/vm.html" target="_blank" rel="noopener">VM</a>):</p><ul><li>Быстрый интероп в C++ и обратно.</li><li>AoT, чтобы вообще убрать интероп, в случаях, когда можно транспилировать в C++ вместо интерпретации.</li><li>Кастомные аллокаторы для строк и хипа. Плюс политика для отдельных скриптов, в которых не нужно хранить выделенное — быстро перезапустить всю виртуальную машину, прибив всё аллоцированное без освобождения. Политика управления памятью или сохранения состояния может быть кастомизирована на стороне C++ — модель памяти daScript максимально простая и быстрая.</li><li>Использование hardware-friendly типов для нод, поддержка векторных типов в языке (в геймдеве повсюду встречаются vec4 и mat4 — многие алгоритмы просто векторизировать).</li></ul><h2 id="AoT"><a href="#AoT" class="headerlink" title="AoT"></a>AoT</h2><p>Код, скомпиленный из daScript в C++, может получиться быстрее среднего C++ кода, так же как компилятор может перевести C++ в более быстрый ассемблерный код, чем средний код, написанный на ассемблере. Причина в том, что при выборе вариантов реализации asm инструкций может быть много вариантов, из которых компилятор может выбрать более быстрый, чем рядовой программист. Т.е. если авторы языка хорошо представляют себе, во что скомпилиться сгенерированный C++ код, то теоретически, они могут сгенерировать код лучше, чем написанный средним программистом.</p><p>Кроме <code>daScript</code>, транспиляцию в C++ поддерживает <code>Nim</code>, который на тестах также выдаёт очень хорошие результаты. Скорее всего, генерировать LLVM код было бы эффективнее, что и планируют делать авторы языка в будущем, однако и генерация быстрого C++-кода делает эти языки очень быстрыми уже сейчас.</p><h2 id="Перестройка-кода"><a href="#Перестройка-кода" class="headerlink" title="Перестройка кода"></a>Перестройка кода</h2><p>Данные и код на daScript можно кастомизировать (<a href="/blog/1547564887/" title="макросы">макросы</a>, преобразовывающие AST, а также <a href="https://github.com/GaijinEntertainment/daScript/blob/250c5124dc1ce5e56933d42d15ef5e209d30dd20/include/daScript/ast/ast.h#L340" target="_blank" rel="noopener">перегрузка</a> simulate и visit, <a href="https://github.com/GaijinEntertainment/daScript/blob/985eaeda9ec6d4c594f9f9583ce3b14aed023d91/include/daScript/das_config.h#L74" target="_blank" rel="noopener">fusion engine</a> для паковки инструкций), это делать намного легче чем на C++. Пример из <a href="https://youtu.be/IvHGczF6Go0?t=2565" target="_blank" rel="noopener">доклада</a>, про разницу подходов при задаче раскладывания данных data-oriented для ECS фреймворка, на C++ и на daScript.</p><p>Наверное, чё-то ещё есть, лучше у авторов уточнить.</p><h2 id="Доверие-авторам"><a href="#Доверие-авторам" class="headerlink" title="Доверие авторам"></a>Доверие авторам</h2><p>Отдельный очевидный момент — быстрый код на языке следует из идеи языка. Если авторы всячески <a href="/blog/2630317622/" title="декларируют">декларируют</a> желание сделать быстрый язык и продолжать разгонять его — то они и будут делать именно это.</p><p>Косвенный признак возможности сделать что-то в языке быстро — наличие специализированных оптимизированных конструкций/структур/алгоритмов (block+lambda, string+das_string, array<T>+int[N] etc).</p><p>Почему я верю конкретно в этот язык — потому что давно видел изнутри движки <code>Gaijin</code>, их тулзы, и знаю качество их кода и используемые скриптовые языки. Ковырял все доступные материалы по скриптовым языкам <code>Naughty Dogs</code> (книга “Архитектура игровых движков”, доклады про использование Lisp-а как языка описания данных и скриптового языка в играх), некоторые идеи из которых, по интервью с автором, реализованны в <code>daScript</code>. Ну и сам Борис Баткин, небезызвестен в русском геймдев-комьюнити еще образца 2000х годов (<a href="https://web.archive.org/web/20071218053755/http://blog.gamedeff.com/?p=64" target="_blank" rel="noopener">интервью глазами пострадавшего</a>), да и просто <a href="https://www.mobygames.com/developer/sheet/view/developerId,53108/" target="_blank" rel="noopener">интересный человек</a>, скорее всего знает толк в быстром коде.</p><p><em>update</em><br><a href="/blog/2115627465/" title="Устройство интерпретаторов lua-jit и daScript">Устройство интерпретаторов lua-jit и daScript</a> — продолжение</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;Рассказыва
      
    
    </summary>
    
    
    
      <category term="dascript" scheme="http://spiiin.github.io/tags/dascript/"/>
    
  </entry>
  
  <entry>
    <title>Эволюция программиста в геймдеве</title>
    <link href="http://spiiin.github.io/blog/4256110900/"/>
    <id>http://spiiin.github.io/blog/4256110900/</id>
    <published>2022-07-27T09:50:03.000Z</published>
    <updated>2022-11-18T18:35:26.706Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Модели развития сотрудника в геймдеве.</p><h2 id="Т-модель-от-Valve"><a href="#Т-модель-от-Valve" class="headerlink" title="Т-модель от Valve"></a>Т-модель от Valve</h2><p><img src="/blog/4256110900/tmodel.png" alt="tmodel"><br>Из <a href="http://media.steampowered.com/apps/valve/hbook-RU.pdf" target="_blank" rel="noopener">руководства новых сотрудников Valve</a><br>Программист растёт не линейно, а в нескольких областях, и чтобы отразить это, в <code>Valve</code> придумали T-модель развития сотрудников:</p><p>На картинке Heavy - класс из Team Fortress 2. Он широко расставил руки, что показывает его атрибуты — Хэви понемногу разбирается в:</p><ul><li>Приготовлении бутербродов,</li><li>Убийстве людей</li><li>Русских народных танцах</li><li>Уберзарядах.<br>Он прокачивает широкий спектр навыков, чтобы уметь всего понемногу, но основная его компетенция - это Тяжёлое оружие (высокий скилл -&gt; рост персонажа)</li></ul><p>Похожая схема от <a href="https://www.dropbox.com/s/0z2p0qokdmm6eaw/Roblox%20Rendering%20-%20Career%20Guide%20v1.1public.pdf?dl=0" target="_blank" rel="noopener">Roblox</a> — приоритет отдаётся не узконаправленным “дельта-диракам”, а “гауссиана-специалистам”, который кроме основного навыка немного ориентируются в других (им проще взаимодействовать со специалистами из других областей и могут принести инсайты из других областей в своей основной специализации)</p><h2 id="Модель-костюмов-Марио-от-Betheda"><a href="#Модель-костюмов-Марио-от-Betheda" class="headerlink" title="Модель костюмов Марио от Betheda"></a>Модель костюмов Марио от Betheda</h2><p><img src="/blog/4256110900/mario_model.png" alt="mario_model"><br><a href="https://www.slideshare.net/JoelBurgess/3-10gdc2014-iterativeleveldesignprocess" target="_blank" rel="noopener">Отсюда</a><br><code>Betheda</code> практически не расширяет команды в ходе разработки проекта, поэтому  незанятые на текущем этапе отделы могут заняться чем-либо другим (переодеваются в другой костюм-профессию). В примере из доклада, на ранних стадиях левел-дизайнеры могут помогать в написании сюжета, геймдизайне механик (Layout, Gameplay, Markup, Scripting, Performance, Writing, Systems, Prototyping, Tools, more…), попутно прокачиваясь в том, что может быть полезно команде. Цель — создание небольших команд, состоящих из широкопрофильных специалистов.</p><h2 id="Модель-профессий-из-Final-Fantasy-Tactics"><a href="#Модель-профессий-из-Final-Fantasy-Tactics" class="headerlink" title="Модель профессий из Final Fantasy Tactics"></a>Модель профессий из Final Fantasy Tactics</h2><p>Если выбирать аналогии из игр, на мой взгляд профессии в геймдеве напоминают систему профессий из <code>Final Fintasy Tactics</code>.</p><p>Изначально специалисту доступны “примитивные” профессии, совершенствуясь в которых он осваивает некоторые навыки. После полноценного освоения нескольких навыков специалист может как оставаться в рамках этой же профессии и продолжать качаться в ней. Более продвинутые профессии имеют требования к наличию навыков в более низких.</p><p><img src="/blog/4256110900/viera_jobs.png" alt="viera_jobs"><br>(ветка профессий для одной из рас в FFTA)</p><p>Профессии 2го уровня требует всего нескольких очков навыков в простых профессиях (к примеру, чтобы стать <code>Sniper</code> достаточно набрать 2х очков в профессии <code>Archer</code>), но продвинутые профессии могут иметь намного более сложные требования (чтобы стать <code>Assasin</code>, нужно получить как минимум по 2 очка способностей из профессий <code>Archer</code>, <code>Elementalist</code> и 1 очку в <code>White Mage</code>, <code>Fencer</code> и <code>Sniper</code>).</p><p><img src="/blog/4256110900/fft_jobs.png" alt="fft_jobs"><br>(все профессии fft)</p><p>Возможна линейная прокачка профессий, без отхода от основной ветки (<code>Squire</code>-&gt;<code>Knight</code>-&gt;<code>Monk</code> в ветке воина). Например, рост программиста в направлении:<br><code>Джуниор программист</code>-&gt;<code>Мидл</code>-&gt;<code>Сениор</code>-&gt;<code>Суперсеньор 100500 ранга</code>.</p><p>Другой вариант — прокачка в целом дереве одной ветки, которая может дать более продвинутую профессию (<code>Knight+Monk+Lancer</code>-&gt;<code>Samurai</code>).<br>Пример:<br><code>Engine Programmer + Team Lead + Build pipeline tools programmer</code> -&gt; <code>CTO/VP of programming</code><br>Ну или, допустим<br><code>Джуниор + Математика + Понимание API и железок -&gt; Render программист</code></p><p>Это один за самых частых вариантов — в геймдеве встречаются очень разные задачи, от создания бекэнда и серверов для мультиплейерных игр до программирования графики, обычные гуи приложения (тулзы), скрипты автоматизации, оптимизации, архитектура движков. Так что несмотря на то, что есть специализации, за длительное время работы скорее всего окажется, что позанимаешься почти всем. Это и плюс - расширяет кругозор, и не возникнет ощущения, что постоянно занимаешься чем-то одним, и минус - нельзя просто выучить что-то одно и бездумно пользоваться этим много лет.</p><p>Возможны также “уходы от основной ветки” (был воином, ушёл в маги). Что-нибудь типа:<br><code>Джуниор программист -&gt; Графический программист -&gt; (бам) -&gt; техартист</code><br><code>Сениор -&gt; Тим Лид-&gt;(бам) -&gt; Проджект менеджер/Продюссер/Руководитель отдела</code><br><code>Технический геймдизайнер -&gt; (бам) -&gt; программист блюпринтов -&gt; (бам) -&gt; инди-одиночка, который и кодит, и дизайнит, и рисует</code><br>В таких случаях важно не забыть своевременно подкачать необходимые скиллы из ранних профессий другой ветки (программист, артист, геймдизайнер, менеджер команды)</p><p><img src="/blog/4256110900/dark_knight.png" alt="dark_knight"><br>Ну, или аналоги <code>Dark Knight</code>, которые кроме 1-2 сильных веток умеют делать по чуть-чуть практически что угодно (<code>Гейм-дизайнер/Артист/Программист + CEO</code>), и ухитряются понемногу заниматься обоими основными профессиями.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;Модели раз
      
    
    </summary>
    
    
    
      <category term="gamedev" scheme="http://spiiin.github.io/tags/gamedev/"/>
    
      <category term="dev_evolution" scheme="http://spiiin.github.io/tags/dev-evolution/"/>
    
  </entry>
  
</feed>
