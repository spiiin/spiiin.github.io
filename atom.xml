<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Spiiin&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://spiiin.github.io/"/>
  <updated>2024-03-23T18:18:47.427Z</updated>
  <id>http://spiiin.github.io/</id>
  
  <author>
    <name>spiiin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Push/Pull/Event model, Reactive GUI</title>
    <link href="http://spiiin.github.io/blog/3145708234/"/>
    <id>http://spiiin.github.io/blog/3145708234/</id>
    <published>2024-03-23T10:25:20.000Z</published>
    <updated>2024-03-23T18:18:47.427Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><h1 id="Push-Pull-Events-модели"><a href="#Push-Pull-Events-модели" class="headerlink" title="Push/Pull/Events модели"></a>Push/Pull/Events модели</h1><p>Регулярно повторяющаяся задача проектирования — выбор способа взаимодействия вызывающего и вызываемого кода.</p><p><strong><code>Pull-модель</code></strong> — “вам надо, вы и мучаетесь”. Часто реализовывается проще. Вызывающий код в том месте, в котором удобно, запрашивает данные.</p><p>Примеры<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">считывание настроек в стиле &#96;game::get_setting&lt;string&gt;(&quot;blabla&quot;)&#96;</span><br><span class="line">считывание 3D модели через render::load3dmodel(&quot;balbalb.xxx&quot;)</span><br><span class="line">опрос сервера клиентом для получения новых сообщений или обновлений</span><br><span class="line">игровой цикл, где игровой движок &quot;запрашивает&quot; состояние игрока или ввод данных в начале каждого кадра</span><br></pre></td></tr></table></figure><br>Все загрузки, всё определение конфигурации и т.п. - размазано по коду и делается ad hoc.  </p><p><strong><code>Push-модель</code></strong> — “то же самое, но вывернутое наизнанку”. Вам приходит callback/event/change propagation “blabla setting changed old-&gt;new”. В системе жёстко вшито, когда именно происходит событие, и имеется возможность добавить свою реакцию на него.</p><p>Примеры<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">системы реального времени, где сенсоры отправляют данные на сервер или обработчик событий немедленно, как только они доступны</span><br><span class="line">системы уведомлений, где сервер пушит уведомления на устройства клиентов без необходимости запроса со стороны клиента</span><br></pre></td></tr></table></figure></p><p>Все загрузки, конфигурации, управление ресурсами - вынесено наружу, делается более-менее централизованно. Вы регистрируетесь где попало и реагируете на обновления. Зато система без вас знает, когда, как и что делать.</p><p>Место определения колбека отделено от момента его вызова, вызывающий код должен понимать контекст, в котором будет вызван колбек — необходимо ли проверять на существование необходимые колбеку ресурсы, доступны ли они или заняты, безопасно ли создавать или удалять какие-либо типы объектов. Один из самых примитивных примеров — инвалидация итератора stl-контейнера в цикле в c++.</p><p><strong><code>Events-модель</code></strong></p><p>В push-моделях можно встретить элементы pull-модели:</p><ul><li>если объём данных для push большой и может быть не нужен клиентам полностью или сразу, система может только уведомить об изменившихся данных (послать сообщение) и предоставить pull-интерфейс для запроса этих данных, когда будет удобно клиенту</li><li>если удобно отложить обработку данных, коллбек может вместо выполнения работы положить сообщение в очередь. Дальше на клиента ложиться задача спуллить сообщения из очереди и обработать их. Удобно, если необходимо обработать все сообщения вместе. </li></ul><p>Примеры<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">отложенная обработка сгенерированных команд для подсистемы рендера</span><br><span class="line">отложенная обработка сообщений о столкновениях, чтобы проверить, что суммарные силы воздействии на физический объект не разрушат его</span><br></pre></td></tr></table></figure></p><p><a href="http://www.kegel.com/c10k.html" target="_blank" rel="noopener">The C10K problem</a> — взаимодействие большого количества сообщений в ОС.<br><a href="https://bitsquid.blogspot.com/2011/02/managing-decoupling-part-2-polling.html" target="_blank" rel="noopener">Managing Coupling Part 2 — Polling, Callbacks and Events</a> — о push/pull/events модели от дизайнеров движка Stingray</p><h2 id="Паттерны-идиомы-узоры"><a href="#Паттерны-идиомы-узоры" class="headerlink" title="Паттерны/идиомы/узоры"></a>Паттерны/идиомы/узоры</h2><p>В различных языках или библиотеках идеи и модели могут быть:<br><strong><code>прозрачные для пользователя</code></strong> — доступны в виде примитивов языка<br><strong><code>выражаемые формально</code></strong> — для использования можно переопределить функцию для своего типа/отнаследоваться от языка/написать синтаксический макрос/воспользоваться принятым в языке способом<br><strong><code>выражаемые неформально</code></strong> — для использования необходимо каждый раз повторно реализовывать функционал</p><p>Когда-то паттернами считались процедуры (1957, <a href="https://www.norvig.com/design-patterns/design-patterns.pdf" target="_blank" rel="noopener">Design Patterns in Dynamic Programming</a>) и классы (1972, <a href="https://blog.plover.com/prog/design-patterns.html" target="_blank" rel="noopener">Design patterns of 1972</a>). Прозрачные для пользователя  практически не обсуждаются (или даже не называются!), формально выраженные также часто принимаются как правило хорошего программирования. Разве что когда кому-нибудь не нравится производительность или ограничения в интерфейсе. В этом случае даже прозрачные идиомы могут быть реифицированны и переделаны. Пример — <a href="/blog/1552834708/" title="Runtime-полиморфизм в C++">Runtime-полиморфизм в C++</a>, альтернативный полиморфизм.</p><p>Может показаться, что называть что-то очень простое и примитивное паттерном слишком сёрьзно, но это всего лишь ярлыки.</p><p><a href="https://probablydance.com/2015/06/16/ideas-for-a-programming-language-part-4-reactive-programming/" target="_blank" rel="noopener">Ideas for a Programming Language Part 4: Reactive Programming</a> — про поиск синтаксиса для того, чтобы ввернуть асинхронное программирование в язык прозрачно для пользователя</p><h2 id="Итераторы-колстеки-корутины-файберы-диспетчеры-асинки-—-revisited"><a href="#Итераторы-колстеки-корутины-файберы-диспетчеры-асинки-—-revisited" class="headerlink" title="Итераторы, колстеки, корутины, файберы, диспетчеры, асинки — revisited"></a>Итераторы, колстеки, корутины, файберы, диспетчеры, асинки — revisited</h2><ul><li><a href="/blog/2550823652/" title="Итераторы, колстеки, корутины">Итераторы, колстеки, корутины</a></li><li><a href="/blog/2826376146/" title="Файберы, диспетчеры, асинки">Файберы, диспетчеры, асинки</a></li></ul><p>Две большие статьи выше посвящены, по большому счёту, паттернам работы с коллекциями в различных языках (где-то эти “паттерны” уже вшиты в примитивы языка, где-то их нет и в стандартной библиотеке и приходилось писать самому).</p><p>Всё описанное в статьях можно классифицировать по 4 группам:<br><strong><code>операции с pull-итераторами в синхронных коллекциях</code></strong><br><strong><code>операции с push-итераторами в синхронных коллекциях</code></strong><br><strong><code>операции с pull-итераторами в асинхронных коллекциях</code></strong><br><strong><code>операции с push-итераторами в асинхронных коллекциях</code></strong></p><p>pull-итераторы — c++ stl-итераторы, <a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.ienumerator-1?view=net-8.0" target="_blank" rel="noopener">IEnumerator<T></a> C#<br>push-итераторы — колбеки<br>синхронные коллекции — контейнеры<br>асинхронные коллекции — генераторы (могут описывать как space-distributed коллекции, так и time-distributed)</p><p>Как и в общем для pull-моделей, pull-итераторы проще для использования/комбинирования — результаты, возвращаемый pull-итератором — стандартные типы языка, с которым учатся работать с самого начала знакомства с языком.</p><p>Push-итератор не возвращает ничего, и является отложенным вычислением (замыкания/указатели на функции/функциональные объекты). Отложенные вычисленя тоже можно комбинировать, но вместо привычных прикладному программисту на императивных языках способов требуются привычные математикам.</p><p><a href="https://aras-p.info/blog/2018/12/28/Modern-C-Lamentations/" target="_blank" rel="noopener">“Modern” C++ Lamentations</a> — про разницу в синтаксисе и времени компиляции между C++ и C# при работе с лямбдами.<br><a href="https://www.youtube.com/watch?v=6mTbuzafcII" target="_blank" rel="noopener">“Transducers” by Rich Hickey</a> — типичные проблемы комбинирования колбеков, как оторвать комбинирование вычислений от коллекций.</p><p>Даже просто запись цепочки выполняющихся друг за другом после окончания предыдущего колбеков превращается в анти-паттерн <code>callback hell</code> (синтаксический сахар async/await - количество скобок уменьшается)</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//.NET 4</span></span><br><span class="line">Task&lt;<span class="keyword">string</span>&gt; htmlTask = webClient.DownloadStringTaskAsync(url);</span><br><span class="line"><span class="comment">//тот можно выполнить код, которому не требуется результат hmtlTask</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">string</span> html = htmlTask.Result; <span class="comment">//тут блокировка до ожидания результата</span></span><br><span class="line"><span class="comment">//или прикрепить к задаче продолжение</span></span><br><span class="line">htmlTask.ContinueWith(task=&gt; &#123;</span><br><span class="line">  <span class="keyword">string</span> html = task.Result;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//.NET 5</span></span><br><span class="line">Task&lt;<span class="keyword">string</span>&gt; htmlTask = webClient.DownloadStringTaskAsync(url);</span><br><span class="line"><span class="keyword">string</span> html = <span class="keyword">await</span> htmlTask; <span class="comment">//то же что и в прошлом примере с ContinueWith</span></span><br><span class="line">doSomething(html)             <span class="comment">//строки ниже await также "переписываются" внутрь ContinueWith</span></span><br></pre></td></tr></table></figure><p>Паттерн <code>Task</code> (где-то встречается название <code>Future</code>) является обёрткой для асинхронной работы над примитивом. В статьях не хватает разбора способов асинхронной работы с коллекциями (синхронными и асинхронными).</p><h2 id="Обобщения-паттерна-Task-в-C"><a href="#Обобщения-паттерна-Task-в-C" class="headerlink" title="Обобщения паттерна Task в C"></a>Обобщения паттерна Task в C</h2><p><strong><code>pull-based работа синхронными коллекциями</code></strong> — если просто заменить <code>Task&lt;int&gt;</code> на <code>Task&lt;IEnumerable&lt;int&gt;&gt;</code>, то можно использовать <code>await</code> для коллекции, но при этом все элементы коллекции будут собираться синхронно за один вызов, в чём собственно нет особого смысла<br><strong><code>pull-based работа с асинхронными коллекциями</code></strong> — <a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.iasyncenumerable-1?view=net-8.0" target="_blank" rel="noopener"><code>IAsyncEnumerable&lt;T&gt;</code></a> и <code>await foreach</code> позволяет получать элементы коллекции асинхронно<br><strong><code>push-based работа с асинхронными коллекциями</code></strong> — push-вариант работы с асинхронными коллекциями — паттерн <code>Observer</code> (<a href="https://learn.microsoft.com/en-us/dotnet/api/system.iobserver-1?view=net-8.0" target="_blank" rel="noopener"><code>IObserver&lt;T&gt;</code></a> в C#). Если <code>Task</code> представляет собой одно асинхронное событие, то <code>Observable</code> — это асинхронная коллекция (источник) событий, на которые могут подписываться <code>Observer</code>-ы.</p><h2 id="Observable-Observer"><a href="#Observable-Observer" class="headerlink" title="Observable/Observer"></a>Observable/Observer</h2><p><code>Observer</code> — давно известный паттерн, популяризованный в GoF, и активно используемый в smalltalk-версии паттерна <code>MVC</code>.<br><a href="https://stlab.cc/tips/about-mvc.html" target="_blank" rel="noopener">How did MVC get so F’ed up?</a> — деградация MVC в языках с не-observable примитивами в качестве модели, мешает композиции.</p><p><code>Observable</code> в C# зовёт 3 метода <code>Observer</code> (<em>продолжение/окончание/ошибка</em>):<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OnCompleted() - последовательность закончилась</span><br><span class="line">OnError(exception) - при генерации данных произошла ошибка</span><br><span class="line">OnNext(value) - было сгенерированно следующее значение</span><br></pre></td></tr></table></figure></p><p><code>Observable</code> можно представить как обобщение примитивного обхода коллекции (синхронной или асинхронной). При этом, как и для примитивного foreach, так и любых более сложных реализаций, должно соблюдаться простое правило: OnCompleted/OnError — это последний колбек, после которого Observable не будет присылать других.</p><p>Паттерн сам по себе не защищен от возможностей кривой композиции, так что периодически появляются теоретические попытки сделать что-то более чистое (но не всегда более простое).<br><a href="https://core.ac.uk/download/pdf/147982753.pdf" target="_blank" rel="noopener">Deprecating the Observer Pattern with Scala.React</a> от Мартина Одерски, умершая либа. Вместо неё сейчас и сам Одерски <a href="https://stackoverflow.com/questions/21546456/what-happened-to-scala-react" target="_blank" rel="noopener">предлагает</a> JavaRx, надстроенную над observer-ами.</p><p><strong><code>Reactive-подход</code></strong><br>Observer имеет те же особенности композиции, что и push-итераторы — близкие математикам или функциональным программистам примитивы, в C# местами завёрнутые в linq-синтаксис.</p><p><a href="https://reactivex.io/" target="_blank" rel="noopener">ReactiveX</a> — библиотека реактивного программирования, набор примитивов для композиции и конвертеров между различными типами итераторов.<br><a href="https://kirkshoop.github.io/introductionToRxcpp" target="_blank" rel="noopener">Introduction to ReactiveX in C++ (rxcpp)</a> — презентация по С++ версии библиотеки, heavy templates-based.<br><a href="https://introtorx.com/chapters/foreword" target="_blank" rel="noopener">Introduction to RX.Net</a> — книга по C# версии.</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//kotlin example</span></span><br><span class="line">getDataFromNetwork()</span><br><span class="line">  .skip(<span class="number">10</span>)</span><br><span class="line">  .take(<span class="number">5</span>)</span><br><span class="line">  .map(&#123; s -&gt; <span class="keyword">return</span> s + <span class="string">" transformed"</span> &#125;)</span><br><span class="line">  .subscribe(&#123; println <span class="string">"onNext =&gt; "</span> + it &#125;)</span><br></pre></td></tr></table></figure><h1 id="GUI"><a href="#GUI" class="headerlink" title="GUI"></a>GUI</h1><p>Можно разделить GUI-библиотеки на <code>imperative/declarative</code> и <code>retained/immediate/reactive</code>.</p><h2 id="Imperative-Declarative"><a href="#Imperative-Declarative" class="headerlink" title="Imperative/Declarative"></a>Imperative/Declarative</h2><p><strong><code>Imperative</code></strong> — установка состояние контролов описывается в коде<br><strong><code>Declarative</code></strong> — установка состояния вынесена куда-нибудь в JSON/XML/HTML или в динамический язык (lua/squirrel — бестиповые таблицы + лямбды удобны для описания представления и кода) и загружается с помощью <code>control-&gt;loadFromFile</code>. Из преимуществ — gui можно менять без перекомпиляции, программиста и с помощью тулзы, которая позволяет менять состояние мышкой.</p><p><a href="https://habr.com/ru/articles/719908/" target="_blank" rel="noopener">WPF: контролы лишенные внешнего вида и неразрешимая задача выбора конфигурации темплейта</a> — более развернуто про то, что даёт декларативный подход<br><blockquote><p>Разработчики хотят, чтобы библиотека «угадала» их представление о том, как должен выглядеть и как должен работать тот или иной элемент визуального интерфейса. Соответственно, разработчики, как пользователи библиотеки, оказываются не готовы, что вместо того, чтобы искать готовые компоненты, надо научиться создавать их самому в парадигме того инструментария и тех концепций, которые реализованы в библиотеке.</p></blockquote></p><h2 id="Retained"><a href="#Retained" class="headerlink" title="Retained"></a>Retained</h2><p><strong><code>Retained</code></strong> — клиентский код не занимается рендером сам, а заполняет и обновляет модель. Push-модель, очень распространённая в GUI-библиотеках.</p><p>Пример, как может выглядеть код:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">&#125; state;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> window = GUI::createRootWindow();</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> label = GUI::createLabel(<span class="string">"Click counter %d"</span>, state.value);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> button = GUI::createButton();</span><br><span class="line">button-&gt;setText(<span class="string">"Increase counter"</span>);</span><br><span class="line">button-&gt;setClickCallback([]()&#123;</span><br><span class="line">    state.value++;</span><br><span class="line">    <span class="comment">//нужно не забыть руками обновить внутреннее состояние контрола, отображающего значение</span></span><br><span class="line">    label-&gt;updateText(<span class="string">"Click counter %d"</span>, state.value);</span><br><span class="line">&#125;);</span><br><span class="line">window-&gt;addChild(button);</span><br><span class="line"></span><br><span class="line"><span class="comment">//somewhere</span></span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">exit</span>) &#123;</span><br><span class="line">    GUI::updateRootWindow();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Минусы — код обновления состояния модели (всего, что вне GUI), нужно синхронизировать с состоянием GUI.</p><p>Примеры либ - <a href="https://github.com/cegui/cegui" target="_blank" rel="noopener">cegui</a></p><h2 id="Immediate"><a href="#Immediate" class="headerlink" title="Immediate"></a>Immediate</h2><p><strong><code>Immediate</code></strong> — Pull-подход (“вам надо, вы и рисуйте”), <a href="https://caseymuratori.com/blog_0001" target="_blank" rel="noopener">родившийся</a> в головах гейм-девелоперов. Если “вывернуть” наизнанку логику, и отдать обязанность рисования контролов клиенту, то логика местами станет проще (вместо угадывания потребностей клиента сложность переезжает в клиентский код, и отпадает необходимость синхронизации состояния). Функции рисования не имеют своего состояния, а принимают указатели на данные, которые они могут изменить.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> value;</span><br><span class="line">&#125; state;</span><br><span class="line"></span><br><span class="line">Gui::Begin(<span class="string">"My window"</span>);</span><br><span class="line">Gui::Text(<span class="string">"Counter %d"</span>, state.value);</span><br><span class="line"><span class="keyword">if</span> (Gui::Button(<span class="string">"Increate counter"</span>)) <span class="comment">//without explicit callback function</span></span><br><span class="line">    state.value++;</span><br><span class="line">Gui::End();</span><br></pre></td></tr></table></figure><p>Примеры либ — <code>Unity Imgui, Dear Imgui, Nuklear</code>.</p><h2 id="Reactive"><a href="#Reactive" class="headerlink" title="Reactive"></a>Reactive</h2><p>Если под рукой есть язык или библиотека, который может описать зависимости между данными, то можно было бы устранить недостаток retained gui без перехода к immediate.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    GUI::MagicObservable&lt;<span class="keyword">int</span>&gt; value; <span class="comment">//при изменении уведомлять всех наблюдателей</span></span><br><span class="line">&#125; state;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> window = GUI::createRootWindow();</span><br><span class="line"><span class="keyword">auto</span> label = GUI::createLabel(<span class="string">"Click counter %d"</span>, state.value);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> button = GUI::createButton();</span><br><span class="line">button-&gt;setText(<span class="string">"Increase counter"</span>);</span><br><span class="line">button-&gt;setClickCallback([]()&#123;</span><br><span class="line">    <span class="comment">//обновляем значение, observer уведомит об изменении все контролы. Прямого обновления label в коде больше нет</span></span><br><span class="line">    GUI::updateObservable(state.value); </span><br><span class="line">&#125;);</span><br><span class="line">window-&gt;addChild(button);</span><br></pre></td></tr></table></figure><p>Примеры либ — <code>knockout.js, rivets</code> для js, <a href="https://www.reactiveui.net/" target="_blank" rel="noopener">ReactiveUI</a> для C#,  <a href="https://github.com/tetsurom/rxqt" target="_blank" rel="noopener">rxqt</a> для C++.<br><a href="https://www.youtube.com/watch?v=_d65qS0GzWM" target="_blank" rel="noopener">MIX11 Knockout JS Helping you build dynamic JavaScript UIs with MVVM and ASP NET</a> — knockout.js demo<br><a href="https://knockoutjs.com/documentation/computed-dependency-tracking.html" target="_blank" rel="noopener">How dependency tracking works</a> — knockout.js how it works</p><p>Knockout.js использует тривиальный динамический метод ослеживания зависимостей.</p><ul><li>Когда объявляется observable, вычисляется его initial-значение.</li><li>В ходе вычисления, устанавливается подписка на любые другие observables (включая computed observables), значения которых читаются (язык должен поддерживать хук на чтение значений). Подписка означает, что будет вызвано вычисление этого observable (шаг 1), при этом любые старые подписки удаляются.</li><li>После завершения вычисления, вызываются все подписки о том, что новое значение этого observable доступно.<br>Так что зависимости не вычисляются при первом запуске и их не нужно объявлять, они просто перерасчитываются каждый раз при обновлении, и могут изменяться динамически. Если эвалуатор observable не читает ни одного другого observable, от которого он зависит, то повторное вычисление никогда не произойдёт, и сам эвалуатор может быть заменён на вычисленное значение.</li><li>Декларативные биндинги данных к состоянию контролов — это просто computed observables.</li></ul><p><a href="https://habr.com/ru/articles/303650/" target="_blank" rel="noopener">Введение в ReactiveUI: прокачиваем свойства во ViewModel</a> — В C# -&gt; WPF + XAML бекэнд + RX.Net для описания зависимостей + ReactiveUI.Fody для генерации</p><h2 id="Reactive-Gui-на-C-и-геймдеве"><a href="#Reactive-Gui-на-C-и-геймдеве" class="headerlink" title="Reactive Gui на C++ и геймдеве"></a>Reactive Gui на C++ и геймдеве</h2><p>Систему реактивного GUI можно разделить на 4 части:</p><ul><li>язык реализации (и, возможно, расширения) системы (C++)</li><li>язык для декларативного описания gui и байндингов контролов к данным</li><li>язык для описания скриптового поведения контролов (если хотим декларативно описывать поведение — в C++ сложно с рефлексией и интерпретацией кода)</li><li>тулза для визуального изменения декларативного описания</li></ul><p><a href="https://ru.wikipedia.org/wiki/Model-View-ViewModel" target="_blank" rel="noopener">Model-View-ViewModel</a><br><a href="https://guide.elm-lang.org/architecture/" target="_blank" rel="noopener">The Elm Architecture</a></p><p>Примеры Reactive GUI для геймдева встречаются не очень часто, но встречаются.</p><p><strong><code>imvue</code></strong><br><a href="https://github.com/Unix4ever/imvue/" target="_blank" rel="noopener">imvue</a> — минималистичный проект-пример</p><ul><li>sdl/glew/imgui в качестве бекэнда для рендера gui, плюс кодоген ооп-обёртки вокруг imgui</li><li>lua в качестве скриптового языка и reactive-системы</li><li>libcss — html/css декларативное описание, в стиле шаблонов vue.js</li><li>без визуального редактора, так как игрушечная либа</li></ul><p><strong><code>xui</code></strong><br><a href="https://github.com/JayDT/XUI" target="_blank" rel="noopener">XUI</a> — еще один демо-пример</p><ul><li>irrlicht в качестве бекэнда</li><li>C++ clang-based парсер для рефлексии, rxcpp и cpplinq для реактивности</li><li>xaml для декларативного описания, порт OmniXaml на C++</li></ul><p><strong><code>noesisengine</code></strong><br><a href="https://www.noesisengine.com/" target="_blank" rel="noopener">noesisengine</a> — коммерческий проект</p><ul><li>свой рендер-бекэнд, рефлексия, редактор (+ экспорт из microsoft blend)</li><li>xaml в качестве декларативного описания</li></ul><p><strong><code>daRg</code></strong><br><a href="https://github.com/GaijinEntertainment/DagorEngine/tree/d3499602af19410703e6248439916778231f3878/prog/gameLibs/daRg" target="_blank" rel="noopener">Dagor Reactive GUI</a> — гайдзиновский reactive gui</p><ul><li>своей рендер-бекэнд</li><li>quirrel (свой порт squirrel) в качестве декларативного описания, рефлексии и скриптового языка</li><li>свой визуальный редактор Dargbox</li></ul><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;h1 id=&quot;Push-
      
    
    </summary>
    
    
    
      <category term="cpp" scheme="http://spiiin.github.io/tags/cpp/"/>
    
      <category term="dev_method" scheme="http://spiiin.github.io/tags/dev-method/"/>
    
      <category term="gamedev" scheme="http://spiiin.github.io/tags/gamedev/"/>
    
      <category term="dev" scheme="http://spiiin.github.io/tags/dev/"/>
    
  </entry>
  
  <entry>
    <title>Game Engines - Rendering Abstraction Layer</title>
    <link href="http://spiiin.github.io/blog/1364570417/"/>
    <id>http://spiiin.github.io/blog/1364570417/</id>
    <published>2024-03-10T07:50:05.000Z</published>
    <updated>2024-03-17T21:36:15.164Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><ul><li><a href="/blog/2721099263/" title="Ещё о проектировании (движки и история)">Ещё о проектировании (движки и история)</a> — заметка о GameObject в движках</li></ul><h2 id="SceneGraph-False-start"><a href="#SceneGraph-False-start" class="headerlink" title="SceneGraph (False start)"></a>SceneGraph (False start)</h2><p>GameObject-ы на сцене часто собраны в иерархию, которую нужно как-то отрисовывать на экране. Наивная идея — отрисовка дерева GameObject-ов в порядке обхода.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameObject</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preRender</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">render</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postRender</span><span class="params">()</span></span>;</span><br><span class="line">    TArray&lt;GameObject*&gt; children;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GameObject::preRender() &#123;</span><br><span class="line">    <span class="comment">//set render state</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GameObject::render() &#123;</span><br><span class="line">    <span class="comment">//render self</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//render children</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> child : children) &#123;</span><br><span class="line">        child-&gt;preRender();</span><br><span class="line">        child-&gt;render();</span><br><span class="line">        child-&gt;postRender();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GameObject::postRender() &#123;</span><br><span class="line">    <span class="comment">//restore render state</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Имеет множество проблем в реализации даже для старых render api — различные алгоритмы требуют различных способов обхода сцены, не укладывающихся в единый граф (как для 2D сцен, так и для 3D). Возникают альтернативные Visitor-ы, списки, флаги управления порядком. Примеры задач:</p><ul><li>для оптимизации выполнения команд рендера данные могут не отправляться на отрисовку сразу, а группироваться (batching) — добавляются хранимые списки данных для рендера и условия синхронизации этих списков с основным обходом объектов</li><li>опция рендера в текстуру - ещё один проход или альтернативное состояние рендера</li><li>трики с блендингом, для которых необходимо изменить порядок вывода на обратный (<a href="/blog/887709799/" title="daScript. SFML, dasBox и спайны">daScript. SFML, dasBox и спайны</a>)</li><li>другие методы отрисовки, требующие изменения порядка — полупрозрачные объекты (до OIT), тени, зеркала</li><li>композиция нескольких из этих приёмов. НЕ решается тем, чтобы ввести наследника GameObject, который бы переопределил preRender/postRender и втыкать его в нужные места графа. Если и решается, то прикручиваением колоссального количества хаков проверки и хранения текущего состояния.</li></ul><p>Тем не менее, подход был достаточно живучий (и оживший на какое-то время с приходом ранних OpenGL ES и WebGL), судя по количеству обсуждений его вредности:<br><a href="https://tomforsyth1000.github.io/blog.wiki.html#%5B%5BScene%20Graphs%20-%20just%20say%20no%5D%5D" target="_blank" rel="noopener">Scene Graphs - just say no</a><br><a href="http://diaryofagraphicsprogrammer.blogspot.com/2009/01/handling-scene-geometry.html" target="_blank" rel="noopener">Handling Scene Geometry</a><br><a href="https://www.stevestreeting.com/2009/01/05/spatialgraph-scenetree-renderqueue-sound-familiar/" target="_blank" rel="noopener">SpatialGraph, SceneTree, RenderQueue - sound familiar?</a><br><a href="https://solid-angle.blogspot.com/2009/01/animation-and-physics-sitting-in-tree.html" target="_blank" rel="noopener">The world is not a SceneTree</a>, <a href="https://solid-angle.blogspot.com/2009/01/world-is-not-scenetree.html" target="_blank" rel="noopener">The world is not a SceneTree</a>, <a href="https://solid-angle.blogspot.com/2009/01/characters-are-special-sort-of-tree-but.html" target="_blank" rel="noopener">Characters are a special sort of tree but not a SceneTree</a>, <a href="https://solid-angle.blogspot.com/2009/01/world-is-world.html" target="_blank" rel="noopener">The world is… the world</a></p><h2 id="Списки-команд-отрисовки"><a href="#Списки-команд-отрисовки" class="headerlink" title="Списки команд отрисовки"></a>Списки команд отрисовки</h2><p>Дизайн способа передачи данных отрисовки от игровых объектов к API видеокарты эволюционировал вместе с дизайном самих API отрисовки. Вместо отдельных команд переключения состояний и создания графических ресурсов постепенно появлялись буферы с данными (вершины, индексы, команды отрисовки) и команды отрисовки использующие эти буферы (“вот указатель на блоб данных, вот описание раскладки этих данных, выведи их”). </p><p>Соответственно, со стороны игрового движка так или иначе возникало формирование списка команд на отрисовку. Чаще отдельным слоем над графическим API (с названиями вроде Rendering Hardware Interface). Причины, по которым удобнее иметь отдельный уровень команд:</p><ul><li><strong>возможность отсортировать команды оптимальным образом перед передачей в графический API</strong> (или же в Data-Oriented style — заранее иметь фиксированный набор списков, в которые можно добавить объекты):<br>  <a href="https://realtimecollisiondetection.net/blog/?p=86" target="_blank" rel="noopener">Order your graphics draw calls around!</a> — пример обоих вариантов<br>  <a href="https://bitsquid.blogspot.com/2017/02/stingray-renderer-walkthrough-4-sorting.html" target="_blank" rel="noopener">Stingray Renderer Walkthrough #4: Sorting</a></li><li><strong>кеширование</strong><br>  <a href="https://www.youtube.com/watch?v=UJ6f1pm_sdU" target="_blank" rel="noopener">Refactoring the Mesh Drawing Pipeline</a> — пайплайн в Unreal, добавляется ещё один этап кеширования команд отрисовки, статические меши могут не создавать команды каждый кадр повторно, чтобы не тратить время не повторное формирование команд<br>  <img src="/blog/1364570417/journey_of_draw.png" alt=""></li><li><strong>многопоточность</strong> — передачу состояния можно вынести в отдельный поток (а если потоков много, то ещё и отделить процесс декодирования из RHI-команд в списки команд графического API)<br>  <a href="https://bitsquid.blogspot.com/2016/09/state-reflection.html" target="_blank" rel="noopener">State reflection</a> — 2 класса, состояние и прокси для его передачи<br>  <a href="https://github.com/donaldwuid/unreal_source_explained/blob/master/main/rendering.md" target="_blank" rel="noopener">Unreal Source Explained, Rendering</a> — то же в Unreal, <code>UPrimitiveComponent-&gt;FPrimitiveSceneProxy-&gt;FPrimitiveSceneInfo</code> и другие</li><li><strong>разные стратегии на разных платформах</strong> — для различных платформ можно эмпирически настроить поведение, например, эмулировать устравшие immediate api,  подобрать оптимальный размер данных в очереди команд перед передачей на отрисовку (flush несколько раз за кадр), или настроить размер конвейера в зависимости от количества потоков (iOS - great single core/Android - many cores)<br>  <a href="https://github.com/donaldwuid/unreal_source_explained/blob/master/main/rendering_parallel.md" target="_blank" rel="noopener">Unreal Source Explained, Parallel Rendering</a> — настройки параллельного рендера в Unreal</li></ul><p>Получается API вроде такого:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameObject</span> &#123;</span></span><br><span class="line">    ResourceHandler resHandler;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initResources</span><span class="params">(RenderCommandList cmdList)</span> </span>&#123; resHandler = cmdList.addCommand(CreateSomeResource&#123;Parameters&#125;); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">freeResourses</span><span class="params">(RenderCommandList cmdList)</span> </span>&#123; cmdList.addCommand(FreeResourceAsync&#123; resHandler &#125;); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">render</span><span class="params">(RenderCommandList cmdList)</span> </span>&#123; cmdList.addCommand(DrawSomeResourceCommand &#123; resHandler &#125;); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RenderCommandList</span> &#123;</span></span><br><span class="line">    <span class="comment">//threading, commands optimization, and batching things</span></span><br><span class="line">    DelayedCommandListMT delayedCommands;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addCommand</span><span class="params">(Command cmd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (inRenderThread() &amp;&amp; allowImmediate()) &#123;</span><br><span class="line">            translateCommandToRenderDevice(cmd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//maybe not just add, but also pre-process</span></span><br><span class="line">            delayedCommands.addNew(MOVE(cmd))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> processDelayedCommands()&#123;</span><br><span class="line">        ENSURE_IN_RENDER_THREAD();</span><br><span class="line">        delayedCommands.preprocessCommands(); <span class="comment">//sort/optimize/fuse/batch</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> cmd: delayedCommands) &#123;</span><br><span class="line">            translateCommandToRenderDevice(cmd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://medium.com/realities-io/creating-a-custom-mesh-component-in-ue4-part-1-an-in-depth-explanation-of-vertex-factories-4a6fd9fd58f2" target="_blank" rel="noopener">Creating a Custom Mesh Component in UE4</a> — серия из 4х статей, про добавление в пайплайн своего компонента, и структур для его обработки.<br><a href="https://medium.com/@lordned" target="_blank" rel="noopener">Unreal Engine 4 Rendering</a> — ещё одна серия, небольшой обзор структур рендера.</p><h2 id="Intermediate-3D-API"><a href="#Intermediate-3D-API" class="headerlink" title="Intermediate 3D API"></a>Intermediate 3D API</h2><p>Так как графических API много и они разные, а движки часто хотят быть мультиплатформенными, то возникают попытки выделения нижнего уровня абстракции RHI в отдельные библиотеки-прослойки между DirectX 11/12/Vulkan/Metal/Opengl desktop/web/mobile. На этом уровне библиотека на заботится ни о чём, кроме быстрого формирования картинки из команд, не вникая в то, что представляют из себя эти команды (чем-то похоже на видеоплейеры).</p><p><a href="https://alain.xyz/blog/comparison-of-modern-graphics-apis" target="_blank" rel="noopener">A Comparison of Modern Graphics APIs</a><br><a href="https://alextardif.com/RenderingAbstractionLayers.html" target="_blank" rel="noopener">An Opinionated Post on Modern Rendering Abstraction Layers</a><br><a href="http://www.gijskaerts.com/wordpress/?p=98" target="_blank" rel="noopener">Musings on cross-platform graphics engine architectures</a> + <a href="https://www.gijskaerts.com/wordpress/?p=112" target="_blank" rel="noopener">Multi-threaded command recording and submission</a><br><a href="https://www.gamedeveloper.com/programming/designing-a-modern-cross-platform-low-level-graphics-library" target="_blank" rel="noopener">Designing a Modern Cross-Platform Low-Level Graphics Library</a><br><a href="https://bitsquid.blogspot.com/2017/02/stingray-renderer-walkthrough.html" target="_blank" rel="noopener">Stingray Renderer Walkthrough #5: RenderDevice</a></p><p><a href="https://dev.to/funatsufumiya/comparison-of-c-low-level-graphics-cross-platform-frameworks-and-libraries-58e5#llgl-low-level-graphics-library" target="_blank" rel="noopener">Comparison of C++ Low-Level Graphics, Cross-Platform Frameworks and Libraries</a> — обзор нескольких библиотек.</p><p><code>sokol</code><br><a href="https://github.com/floooh/sokol" target="_blank" rel="noopener">sokol-gfx</a> — thin-решение на C. Графическая обёртка отделена от всего, что только можно. Часто связанные с обёрткой решения выделены в отдельные библиотеки — <a href="https://github.com/floooh/sokol-tools/" target="_blank" rel="noopener">sokol-shdc</a> для кросс-платформенных шейдеров, транспилируемых в нативные языки (annotated GLSL -&gt; platform shaders + c header) и <a href="https://github.com/floooh/oryol" target="_blank" rel="noopener">oryol</a> для обёртки над окнами и IO.</p><p><code>bgfx</code><br><a href="https://github.com/bkaradzic/bgfx" target="_blank" rel="noopener">bgfx</a> — кроме составления списка команд, умеет их <a href="https://bkaradzic.github.io/bgfx/internals.html" target="_blank" rel="noopener">сортировать</a>, а также заполнять из нескольких потоков. Shaderc — компилятор шейдеров, надстройка на GLSL-like языком, транспилируемым в нативные языки.<br>Настраивается на использование с различными оконными обёртками (glfw/sdl/native os), имеет отдельные base-library <a href="https://github.com/bkaradzic/bx/" target="_blank" rel="noopener">bx</a> (обёртки над io/threads primitives/math/memory/hash) и <a href="https://github.com/bkaradzic/bnet" target="_blank" rel="noopener">bnet</a> (tcp protocol wrapper).</p><p><code>llgl</code><br><a href="https://github.com/LukasBanana/LLGL" target="_blank" rel="noopener">llgl</a> — еще одна thin-прослойка для большинства платформ, без window- и shader- слоёв (из-за чего в примерах 100500 вариантов шейдеров на всех языках). Многопоточный command buffer поддерживается только для OpenGL-wrapper (<a href="https://github.com/LukasBanana/LLGL/blob/master/docu/GettingStarted/Getting%20Started%20with%20LLGL.pdf" target="_blank" rel="noopener">не поддерживается</a> для DX12 и Vulkan). Имеет c-api для генерации привязок к языками (как и sokol/bgfx).</p><p><code>Diligent Engine</code><br><a href="https://github.com/DiligentGraphics/DiligentCore" target="_blank" rel="noopener">Diligent Engine Core</a> — декларирует полную поддержку новых API, и ограниченную поддержку старых. Поддерживает генерацию команд из нескольких потоков, и вшитую на низком уровне систему <a href="http://diligentgraphics.com/diligent-engine/architecture/cross-platform/reference-counting/" target="_blank" rel="noopener">Reference Counting</a>. Имеет C API для привязок к языкам (C++/C#). <a href="https://github.com/DiligentGraphics/DiligentFX" target="_blank" rel="noopener">DiligentFX</a> - high-level слой поверх Core. <a href="http://diligentgraphics.com/" target="_blank" rel="noopener">Блог</a> с обновлениями и описанием дизайна.</p><p><code>The Forge</code><br><a href="https://github.com/ConfettiFX/The-Forge" target="_blank" rel="noopener">The Forge</a> — open-source прослойка, industry-level качества, разработчики предлагают услуги по помощи в интеграции в существующие движки (примеры — Forza Motorspirt и Starfield). Больше оптимизаций, высокий порог для старта, постепенное обрастание необходимыми для движка системами, не связанными с прослойкой для рендера (скорее всего, связанное с потребностями компаний, интегрирующих библиотеку).</p><h2 id="Shader-abstraction"><a href="#Shader-abstraction" class="headerlink" title="Shader abstraction"></a>Shader abstraction</h2><p>Так как языки для описания шейдеров похожие, но чуть отличающиеся, и требуют описания соотвествующих им структур и кода на C++, то библиотеки используют мета-языки — надстройки над одним из базовых языков (GLSL/HLSL + транспиляция в другие базовые языки) и/или DSL/схемы данных, по которым генерируется код привязки параметров к шейдеру.</p><p>Также, шейдеры требуют оптимизаций, поэтому опциональные фичи рендера, которые могут присутствовать или отсутствовать в материале, генерируют различные варианты шейдеров (с включенным и выключенным вариантом фичи). Поскольку каждая новая опция вдвое увеличивает количество вариантов шейдеров, необходимо предусмотреть возможности заданий ограничений вариантов в тех частях движка, которые взаимодействуют с системой материалов (скомпилировать заранее все варианты быстро становится невозможным).<br><a href="https://aras-p.info/blog/2017/02/05/Every-Possible-Scalability-Limit-Will-Be-Reached/" target="_blank" rel="noopener">Every Possible Scalability Limit Will Be Reached</a> - эволюция системы материалов в Unity, от 5 вариантов шейдеров, до 100 миллиардов.</p><p>Идиомы систем материалов:</p><ul><li>code reuse (include-based)</li><li>uber-shader (substractive)</li><li>additive (nodes-based)</li><li>templates (material domain в unreal, surface shader в unity)</li></ul><p><img src="/blog/1364570417/destiny_shaders_small.png" alt=""><br><a href="https://www.gdcvault.com/play/1024231/-Destiny-Shader" target="_blank" rel="noopener">Destiny’ Shader Pipeline</a></p><p><a href="https://aras-p.info/blog/2014/05/05/shader-compilation-in-unity-4-dot-5/" target="_blank" rel="noopener">Shader compilation in Unity 4.5</a><br>GPU Pro 6 - Semantic-BasedShaderGenerationUsingShaderShaker</p><h2 id="Frame-Graph"><a href="#Frame-Graph" class="headerlink" title="Frame Graph"></a>Frame Graph</h2><p>Отрисовка кадра игры состоит из большого количества этапов.</p><p>Примеры реверс-инжинирига пайплайна отрисовки кадра из различных игр:<br><a href="http://www.adriancourreges.com/blog/2016/09/09/doom-2016-graphics-study/" target="_blank" rel="noopener">DOOM (2016) - Graphics Study</a><br><a href="https://80.lv/articles/world-of-tanks-graphical-update-technical-overview/" target="_blank" rel="noopener">World of Tanks: Graphical Update Technical Overview</a><br><a href="https://astralcode.blogspot.com/2018/11/reverse-engineering-rendering-of.html" target="_blank" rel="noopener">Reverse engineering the rendering of The Witcher 3</a><br><a href="https://godotengine.org/article/godot-3-renderer-design-explained" target="_blank" rel="noopener">Godot 3’s Renderer Design Explained</a><br><a href="http://www.adriancourreges.com/blog/2015/11/02/gta-v-graphics-study/" target="_blank" rel="noopener">GTA V - Graphics Study</a><br><a href="https://interplayoflight.wordpress.com/2017/10/25/how-unreal-renders-a-frame/amp/" target="_blank" rel="noopener">How Unreal Renders a Frame</a><br><a href="https://c0de517e.blogspot.com/2020/12/hallucinations-re-rendering-of.html" target="_blank" rel="noopener">Hallucinations re: the rendering of Cyberpunk 2077</a><br><a href="https://mamoniem.com/behind-the-pretty-frames-god-of-war/" target="_blank" rel="noopener">Behind the Pretty Frames: God of War</a><br><a href="https://gamedev.ru/community/gamedev_lecture/articles/?id=718" target="_blank" rel="noopener">Oblivion</a><br><a href="https://gamedev.ru/community/gamedev_lecture/articles/r_e_n_de_r" target="_blank" rel="noopener">Stalker</a><br><a href="https://www.elopezr.com/" target="_blank" rel="noopener">https://www.elopezr.com/</a> — Mafia, Nanite, Jurassic World, Rise of Tomb Raider, Shadow of Mordor, Castlevania<br><a href="https://users.livejournal.com/--vortex--/" target="_blank" rel="noopener">https://users.livejournal.com/--vortex--/</a> — старенькое: Diablo 3, Starcraft 2, Jericho, Dirt, Company Of Heroes, Warhammer 40K: Dawn of War, Gothic 3, NFS Carbon, Painkiller, Flatout 2</p><p><a href="https://github.com/GaijinEntertainment/DagorEngine/blob/main/samples/skiesSample/prog/test_app.cpp" target="_blank" rel="noopener">skySample</a> - тестовый пример из DagorEngine, описание рендера кадра на ~2к строк.<br><a href="https://github.com/ConfettiFX/The-Forge/blob/master/Examples_3/Aura/src/Aura.cpp" target="_blank" rel="noopener">Aura</a> - аналогично из The-Forge, ~2к строк<br><a href="https://www.gdcvault.com/play/1024612/FrameGraph-Extensible-Rendering-Architecture-in" target="_blank" rel="noopener">FrameGraph: Extensible Rendering Architecture in Frostbite</a> - список проходов Battlefield 4<br><img src="/blog/1364570417/frame_graph_1_small.png" alt=""></p><p>В универсальных движках возможны также настраиваемые этапы или различные пайплайны для различных платформ, а также дополнительный отладочный вывод, что делает описание еще более сложным.</p><p><a href="https://logins.github.io/graphics/2021/05/31/RenderGraphs.html" target="_blank" rel="noopener">Why Talking About Render Graphs</a> — граф для описания этапов, и compile-time/runtime вычисления зависимостей используемых ресурсов меджу этапами.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;ul&gt;
&lt;li&gt;&lt;a h
      
    
    </summary>
    
    
    
      <category term="dev_method" scheme="http://spiiin.github.io/tags/dev-method/"/>
    
      <category term="dev_evolution" scheme="http://spiiin.github.io/tags/dev-evolution/"/>
    
      <category term="3d" scheme="http://spiiin.github.io/tags/3d/"/>
    
      <category term="unreal" scheme="http://spiiin.github.io/tags/unreal/"/>
    
  </entry>
  
  <entry>
    <title>Скриптовые языки в Unreal Engine</title>
    <link href="http://spiiin.github.io/blog/770184585/"/>
    <id>http://spiiin.github.io/blog/770184585/</id>
    <published>2024-03-02T16:02:18.000Z</published>
    <updated>2024-03-04T12:16:03.374Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><ul><li><a href="/blog/2721099263/" title="Ещё о проектировании (движки и история)">Ещё о проектировании (движки и история)</a> — про идею разделения игрового объекта на части “для программистов” и “для гейм-дизайнеров”.</li></ul><p>Схема создания разделённых типов в Unreal Engine выглядит приблизительно так:</p><h1 id="C-lt-—-gt-Blueprints"><a href="#C-lt-—-gt-Blueprints" class="headerlink" title="C++ &lt;—&gt; Blueprints"></a>C++ &lt;—&gt; Blueprints</h1><h2 id="Общая-схема"><a href="#Общая-схема" class="headerlink" title="Общая схема"></a>Общая схема</h2><p><img src="/blog/770184585/unreal1_small.png" alt=""><br><em><a href="/blog/770184585/unreal1.png">full size</a></em></p><ul><li>Исходный код обрабатывается препроцессором <code>Unreal Header Tool</code> (DSL), который генерирует метаинформацию для системы рефлексии</li><li>Код на C++ собирается в exe-файл редактора/игры</li><li>Код на С++ также может собираться в динамическую библиотеку, которая загружается уже после запуска редактора</li><li>После запуска редактор загружает мета-информацию о типах (Reflection data), и может использовать для визуального отображения и редактирования типов</li><li>Runtime geneated reflection data — новые типы могут быть созданы в рантайме, с помощью наследования от уже существующих типов и определения/переопределения новых полей, и кода из языка Blueprints (который компилируется в байткод виртуальной машины)</li></ul><p>Некоторые неотмеченные на схеме связи:</p><ul><li>Нативизация скриптов (вместо компиляции в байт-код происходит транспиляция в C++ код)</li><li>Типы могут использоваться не в качестве базовых для настройки и расширения из скриптов Blueprint, а ради расширения редактора (макросы) или самого языка Blueprint (регистрация новых типов нод)</li></ul><p><a href="https://www.youtube.com/watch?v=wJqOn88cU7o" target="_blank" rel="noopener">Building Tools Quickly: Blueprints, Menus, Utilities, and Widgets</a> — доклад про различные способы расширения редактора Unreal от Embark Studios</p><h2 id="Рефлексия"><a href="#Рефлексия" class="headerlink" title="Рефлексия"></a>Рефлексия</h2><p>Поскольку C++ не имеет встроенных средств рефлексии, движки изобретают свои средства для описания метаинформации. Так как часто уже существует основа движка на C++, выбирается вариант с добавлением разметки в сам C++ код, и стадии препроцессинга перед компиляцией (<code>Unreal Header Tool</code> в случае с Unreal), на которой разбирается метаинформация и генерируется мета-класс и код работы с ним.</p><p>Кроме генерация мета-класса в виде C++-типа, необходим способ создания типов в ран-тайме — генерация кода регистрации типа в системе рефлексии времени выполнения.</p><p><a href="https://awforsythe.com/unreal/blueprints_vs_cpp/" target="_blank" rel="noopener">Blueprints vs C++</a> — статья с разбором системы рефлексии, а также способов ссылок на типы C++-&gt;Blueprint и Blueprint-&gt;C++<br><a href="https://www.tomlooman.com/unreal-engine-cpp-guide/" target="_blank" rel="noopener">Unreal Engine C++ Complete Guide</a> — гайд по DSL для описания метаинформации, а также других макросов Unreal (<code>Unrealisms</code>)</p><ul><li><a href="/blog/1728194429/" title="С++ в геймдеве">С++ в геймдеве</a> — раздел “Высокоуровневый C++”, про ограничения языка в рефлексии, кодогенерации, compile-time вычислениях</li><li><a href="/blog/4174799834/" title="C++ Metaprogramming - ссылки">C++ Metaprogramming - ссылки</a> — возможности мета-программирования</li></ul><h1 id="Привязка-текстового-скриптового-языка"><a href="#Привязка-текстового-скриптового-языка" class="headerlink" title="Привязка текстового скриптового языка"></a>Привязка текстового скриптового языка</h1><h2 id="Выбор-между-визуальным-текстовым-программированием"><a href="#Выбор-между-визуальным-текстовым-программированием" class="headerlink" title="Выбор между визуальным/текстовым программированием"></a>Выбор между визуальным/текстовым программированием</h2><ul><li><a href="/blog/2721099263/" title="Ещё о проектировании (движки и история)">Ещё о проектировании (движки и история)</a></li></ul><p>Выбор можно типом скриптового языка (визуальный/текстовый) зависит от конфигурации команды (кто будет пользоваться этим языком).</p><ul><li>По статистике от Epic — до 80% кода в больших проектах переписывается с Blueprint на C++ (<a href="https://www.youtube.com/watch?v=0YMS2wnykbc&amp;t=1276s" target="_blank" rel="noopener">линк</a>).</li></ul><p>Т.е. с визуальным языком вместо идеи “делаем игру без программистов” получается “программисты регулярно занимаются переписыванием логики игры на нативный язык”. Текстовые языки удобнее в плане того, что могут быть быстрее визуальных, и ближе к натуральному представлению программистов (переписывать с текстового скрипта на C++ проще, чем с Blueprint).</p><p>Скриптовый язык должен быть быстрым, или хотя бы иметь возможности для ускорения (транспиляция/jit/профайлер/управление памятью/быстрый интероп с C++/примитивные типы/опции оптимизаций компиляции), чтобы минимизировать необходимость переписывания.</p><ul><li>Дизайн некоторых игр может подразумевать наличие большого количества level one-offs (мест с кастомной логикой), что требует большого объёма кода. Объёмные Blueprint-скрипты нечитаемы.</li></ul><p>Из старых примеров игр, в которых уровней с кастомной логикой больше, чем основной — Earth World Jim 2, BattleToads, сборники мини-игр (Mario Party, Adventures in The Magic Kingdom, Tiny Toon 2, симуляторы олимпиад и многоборий). Из новых — <code>It Takes Two</code>. Разработчики выбрали для этого <a href="https://angelscript.hazelight.se/" target="_blank" rel="noopener">AngelScript</a>.</p><ul><li><p>Текстовый язык не заменяет полностью Blueprint, небольшие кусочки всё равно удобнее реализовывать в виде Blueprint-скриптов, чтобы сохранять возможность использовать уже накопленные Unreal-разработчиками приёмы. Т.е. язык должен быть интегрирован не только с C++, так и с системой рефлексии и виртуальной машиной Blueprint.</p></li><li><p>В идеале, язык должен быть не хуже Blueprint в том, в чем силён Blueprint, и не хуже C++ в том, в чём хорош C++</p></li></ul><h2 id="Группы-скриптовых-языков"><a href="#Группы-скриптовых-языков" class="headerlink" title="Группы скриптовых языков"></a>Группы скриптовых языков</h2><p><code>Lua/AngelScript/Wren/Squirrel</code></p><p>Lightweight-языки с простой виртуальной машиной, и небольшой стандартной библиотекой, дополнительные фичи могут реализовываться дописыванием функционала на C++.<br><a href="https://www.angelcode.com/angelscript/sdk/docs/manual/doc_addon_script.html" target="_blank" rel="noopener">Аддоны AngelScript</a>, <a href="https://github.com/Hazelight/UnrealEngine-Angelscript/blob/6b9c9a776cd339ba2b44f175a3677106ef1c8dbe/Engine/Plugins/Angelscript/Source/AngelscriptCode/Private/Preprocessor/AngelscriptPreprocessor.cpp" target="_blank" rel="noopener">препроцессор UnrealAngelScript</a> на 4к строк.</p><p><code>C#/Python/JavaScript</code></p><p>Языки с тяжелой виртуальной машиной, развесистой стандартной библиотекой и большим количеством готовых 3rdParty библиотек.</p><p><code>Odin/Jai/daScript/Nim/Haxe</code></p><p>Языки с gamedev-related фичами. Рефлексия, настройка управления памятью, компайл-тайм eval и макросы, транспиляция в C++, выбор между исполнением байт-кода и компиляцией, jit-компиляция (полный набор не поддерживает ни один язык из списка, но все поддерживают хотя бы несколько).</p><p>Эта группа представляет наибольший интерес, потому что потенциально может заменить не только Blueprint, но и большую часть C++.</p><h1 id="C-lt-—-gt-Nim-lt-—-gt-Blueprint"><a href="#C-lt-—-gt-Nim-lt-—-gt-Blueprint" class="headerlink" title="C++ &lt;—&gt; Nim &lt;—&gt; Blueprint"></a>C++ &lt;—&gt; Nim &lt;—&gt; Blueprint</h1><p><a href="https://github.com/jmgomez/NimForUE" target="_blank" rel="noopener">NimForUE</a> — привязка Nim к Unreal Engine, в разработке.</p><h2 id="Общая-схема-1"><a href="#Общая-схема-1" class="headerlink" title="Общая схема"></a>Общая схема</h2><p><img src="/blog/770184585/unreal2_small.png" alt=""><br><em><a href="/blog/770184585/unreal2.png">full size</a></em></p><p>Макросы позволяют написать на Nim DSL описания метаинформации.</p><p>Код на Nim может компилироваться в статическую библиотеку, как и код на C++. Также существует возможность собрать код в DLL для хот-релоадинга и транспилировать в C++.<br>Для рантайм выполнения без компиляции существует формат интерпретации байт-кода виртуальной машиной NimVM.</p><h2 id="Задачи-NimForUE"><a href="#Задачи-NimForUE" class="headerlink" title="Задачи NimForUE"></a>Задачи NimForUE</h2><ul><li>Привязки методов C++ для динамического добавления типов в систему рефлексии Unreal (создание модуля, типа, полей и функций в нём, информирования рантайма о новых типах)</li><li>Привязки базовых типов Unreal, строк, указателей, контейнеров, делегатов и вспомогательных классов системы рефлексии (UObject, UClass, UFunction, TSubclassOf, TSoftObjectPtr)</li><li>Соответствие базовых типов языки типам системы рефлексии, идиоматические для nim хелперы вокруг unreal-типов</li><li>Обёртки вокруг конвенций Unreal - конструкторов, создания компонент, статических данных и связью с системой сборки мусора, Out-параметры для Blueprint-нод</li><li>Базовая инфраструктура Nim — виртуальная машина, мониторинг библиотеки для hot-reload, тесты и отладка</li><li>DSL для создания типов, похожий на тот, который используется Unreal Header Tool, прокидка типов и флагов описания метаинформации</li><li>Генерация привязок для всех типов системы рефлексии</li><li>Генерация привязок для типов C++ (и допривязка свойств/функций), которые не добавлены в систему рефлексии, но необходимы для удобной работы со скриптами</li><li>Override свойств и функций системы рефлексии (наследование от Blueprint-типов)</li><li>Override для C++ функций (генерацией c++-типа обёртки)</li><li>Разделение кода обёрток игры/редактора, поддержка всех платформ</li></ul><h2 id="Способы-связи-между-языками"><a href="#Способы-связи-между-языками" class="headerlink" title="Способы связи между языками"></a>Способы связи между языками</h2><p><code>Nim &lt;--&gt; Cpp</code></p><p>Nim может описать используемый метод и тип из C++ из самого языка (pragma importcpp). Аналогично код на C++ может описать прототип extern функции, которая находится в lib-файле, собранном из nim-кода.<br>Для динамической привязки — стандартные для ОС методы вызова функций из библиотек (со стороны Nim — обмазанные макросами).</p><p><code>Nim &lt;--&gt; Blueprint</code></p><p>Связь через систему рефлексии (Emit Type + Broadcast Asset -&gt; Blueprint знает о типе).</p><p><a href="https://github.com/jmgomez/NimForUE/blob/17049537e0e92f2f796dfbc18c645939b0199629/Source/NimForUEBindings/Public/UFunctionCaller.h" target="_blank" rel="noopener">UFunctionCaller</a> — вызов зарестрированной функции по имени.</p><p>Пример сгенерённой привязки функции</p><figure class="highlight nim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">proc</span> getPingInMilliseconds*(self : <span class="type">APlayerStatePtr</span>): <span class="built_in">float32</span> =</span><br><span class="line">  <span class="keyword">var</span> call  = <span class="type">UECall</span>(self: <span class="number">0</span>, value: <span class="type">RuntimeField</span>(kind: <span class="type">FieldKind</span>(<span class="number">0</span>),</span><br><span class="line">      intVal: <span class="number">0</span>), kind: <span class="type">UECallKind</span>(<span class="number">0</span>), fn: <span class="type">UEFunc</span>(name: <span class="string">"GetPingInMilliseconds"</span>,</span><br><span class="line">      className: <span class="string">"APlayerState"</span>))</span><br><span class="line">  call.value = ().toRuntimeField()</span><br><span class="line">  call.self = <span class="keyword">cast</span>[<span class="built_in">int</span>](self)</span><br><span class="line">  <span class="keyword">let</span> returnVal <span class="meta">&#123;.used, inject.&#125;</span> = uCall(call)</span><br><span class="line">  <span class="keyword">when</span> <span class="built_in">float32</span> <span class="keyword">is</span> <span class="keyword">ptr</span>:</span><br><span class="line">    <span class="keyword">if</span> returnVal.get.intVal == <span class="number">0</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">nil</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">cast</span>[<span class="built_in">float32</span>](returnVal.get.intVal)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> returnVal.get.runtimeFieldTo(<span class="built_in">float32</span>)</span><br></pre></td></tr></table></figure><h2 id="Установка"><a href="#Установка" class="headerlink" title="Установка"></a>Установка</h2><p><a href="https://github.com/jmgomez/NimTemplate" target="_blank" rel="noopener">NimTemplate</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">choosenim devel # скачать nim</span><br><span class="line">nimble nue      # установка nue, утилиты для работы с NimForUE</span><br><span class="line">nue setup       # компиляция движка, плагина и генерация байндингов</span><br><span class="line">                # .Plugins&#x2F;NimForUE&#x2F;NimForUE.win.json - путь к движку</span><br><span class="line">...</span><br><span class="line">nue starteditor # запуск редактора</span><br><span class="line">nue game        # перекомпиляция game.dll, hot-reload библиотеки с nim-кодом</span><br><span class="line">                # .&#x2F;NimForUE&#x2F;config.nims - настройки путей</span><br><span class="line">                # .&#x2F;NimForUE&#x2F;game.nim - код примера</span><br></pre></td></tr></table></figure><p><img src="/blog/770184585/unreal3_small.png" alt=""><br><em><a href="/blog/770184585/unreal3.png">full size</a></em></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;ul&gt;
&lt;li&gt;&lt;a h
      
    
    </summary>
    
    
    
      <category term="nim" scheme="http://spiiin.github.io/tags/nim/"/>
    
      <category term="unreal" scheme="http://spiiin.github.io/tags/unreal/"/>
    
  </entry>
  
  <entry>
    <title>Итоги второй половины 2023 года</title>
    <link href="http://spiiin.github.io/blog/978393967/"/>
    <id>http://spiiin.github.io/blog/978393967/</id>
    <published>2024-02-22T13:43:25.000Z</published>
    <updated>2024-03-05T15:10:01.723Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Предыдущие</p><ul><li><a href="/blog/307513906/" title="Итоги 2020">Итоги 2020</a></li><li><a href="/blog/2738337723/" title="Итоги 2021-2022">Итоги 2021-2022</a></li><li><a href="/blog/3525050862/" title="Итоги первой половины 2023">Итоги первой половины 2023</a></li></ul><p><strong><code>Личное/путешествия</code></strong><br>Когда-то отмечал 2022-й год, потом 5783-й, следующий будет 2567-й<br><img src="/blog/978393967/thai1_small.png" alt=""></p><p><strong><code>Музыка</code></strong></p><p><code>MNISHEK - Душко моя</code><br><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/8Ox2Sw9MX4Y" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></p><p><code>Мельница - Дороги</code><br><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/P_g3sYGuuEA" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></p><p><code>Friendship (feat.Lee Ritenour) - Let&#39;s Not Talk About It</code> (Super Mario Level 1-2)<br><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/ZX5ef_KAZlY" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></p><p><code>Atlantida Project - Круги</code><br><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/LTlH_BfwgrY" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></p><p><code>Антон Птушкін - Карпати без слів</code><br><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/tVBepI8elAA" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div><br>Видео без музыки, но с атмосферой, как будто первое погружение в <code>Breath of the Wild</code></p><p><strong><code>Игры</code></strong><br><code>Baldurs Gate 3</code> - прошёл за лесную-гномиху друида.<br><code>Fantasy Strike</code> - максимально простой файтинг, хорош для изучения проёмов гейм-дизайна в жанре.<br><code>Super Mario Bros Wonder</code>- Марио как всегда отличный, но, как и все 2d части, показался слишком коротким.<br><code>Hogwarts Legacy</code> - странное сочетание, гриндилка для фанатов с клёвым окружением, но стандартными open-world механиками, почти без отыгрыша школьной жизни.<br><code>Songs of conquest</code> - отличная инди-тактика.</p><p><strong><code>Книги</code></strong><br><code>Лекции Дыбовского про игры</code> на Страдающем Средневековье. Всегда интересно слушать.<br><code>Шрайдер</code> - книги про гейм-дизайн и баланс.<br><code>Крис Колер. Power Up! Как Япония вдохнула в игровую индустрию новую жизнь</code> - история.<br><code>Chris Solarski. Drawing Basics and Video Game Art + Interactive stories and video game art</code> - язык форм в геймдизайне.<br><a href="https://en.wikipedia.org/wiki/Pattern-Oriented_Software_Architecture" target="_blank" rel="noopener">Pattern-Oriented Software Architecture</a> - вполне себе timeless методы проектирования софта.<br><a href="https://en.wikipedia.org/wiki/List_of_cognitive_biases" target="_blank" rel="noopener">List of cognitive biases</a> - хорошая стартовая точка для подробного изучения<br><a href="http://ithare.com/contents-of-development-and-deployment-of-massively-multiplayer-games-from-social-games-to-mmofps-with-stock-exchanges-in-between/" target="_blank" rel="noopener">D&amp;D of MOGs</a> - серьёзный разбор вариантов дизайнна MMO.<br><a href="/blog/30406011/" title="Agner Fog&#39;s Optimization manuals">Agner Fog&#39;s Optimization manuals</a> - мануалы Агнера Фога по оптимизации.</p><p><strong><code>Развитие</code></strong><br>Занялся изучением <code>Unreal Engine</code>. Также немного — процедурной генерацией и генерацией изображений с помощью нейросетей.<br><a href="/blog/2455145615/" title="Про изучение английского">Про изучение английского</a> — наконец-то увлёкся английским. Минус - уходит много времени на практику.</p><p><img src="/blog/978393967/fox_2023_small.png" alt=""></p><p>YOLO, всё пройдёт, и это тоже.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;Предыдущие
      
    
    </summary>
    
    
    
      <category term="log" scheme="http://spiiin.github.io/tags/log/"/>
    
  </entry>
  
  <entry>
    <title>Почему я недолюбливаю программирование графики</title>
    <link href="http://spiiin.github.io/blog/245490442/"/>
    <id>http://spiiin.github.io/blog/245490442/</id>
    <published>2024-02-22T13:01:21.000Z</published>
    <updated>2024-02-27T16:43:27.103Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Графическое программирование — гештальт, нужно одновременно разбираться в API/алгоритмах/железе, в идеале еще и чувствовать эстетику, нельзя специализироваться на чём-то одном. Всё связано между собой и простоянно развивается/меняется</p><ul><li>API - несколько, разные, по разному работающие, разные языки шейдеров</li><li>для одного API, но разного железа best practices по оптимизациям могут отличаться</li><li>В движках над API — слой кроссплатформенной абстракции, над ними ещё один-два, через которые нужно продираться. Как будто, иногда проще написать прототип на каком-нибудь playground приложении, чтобы потом перенести в основной. Вниз вообще <a href="https://kunaifusu.livejournal.com/514770.html" target="_blank" rel="noopener">черепахи до самого дна</a></li><li>на любом рынке полно лоу-енд железа, которое надо поддерживать (древние ноутбуки/телефоны)</li><li>алгоритмы - зависят от железа, постоянно обновляются. Постоянное обновление знаний, плюс накоплнение ради узнавания готовых решений. <a href="https://www.youtube.com/watch?v=eviSykqSUUw" target="_blank" rel="noopener">A Deep Dive into Nanite Virtualized Geometry</a>, <a href="https://kunaifusu.livejournal.com/598964.html" target="_blank" rel="noopener">Продавцы инжинов</a>, ну или какой-нибудь HDR из Uncharted. То все рендерят похоже, то наоборот, каждый делает по разному.</li><li>часто вообще решает не графика и код, а геймплей и арт</li><li>тяжело отлаживать граничные случаи, нужны референсные тупые алгоритмы</li><li>с <a href="https://ru.wikipedia.org/wiki/%D0%90%D1%84%D0%B0%D0%BD%D1%82%D0%B0%D0%B7%D0%B8%D1%8F" target="_blank" rel="noopener">афантазией</a>(на самом деле, “авизуализацией”) достаточно сложно мысленно связать код с тем, что он отобразит. Но возможно</li></ul><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;Графическо
      
    
    </summary>
    
    
    
      <category term="dev" scheme="http://spiiin.github.io/tags/dev/"/>
    
  </entry>
  
  <entry>
    <title>Связь daScript классов с C++-классами</title>
    <link href="http://spiiin.github.io/blog/2757704498/"/>
    <id>http://spiiin.github.io/blog/2757704498/</id>
    <published>2024-02-22T11:46:32.000Z</published>
    <updated>2024-02-22T12:10:43.918Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><ul><li><a href="/blog/1023396573/" title="daScript: ООП и всякое">daScript: ООП и всякое</a> - перенёс часть про связь с C++-типами в отдельную заметку</li></ul><h1 id="Связь-с-C-типами"><a href="#Связь-с-C-типами" class="headerlink" title="Связь с C++ типами"></a>Связь с C++ типами</h1><p><a href="https://github.com/GaijinEntertainment/daScript/blob/master/examples/tutorial/tutorial03.cpp#L15" target="_blank" rel="noopener">https://github.com/GaijinEntertainment/daScript/blob/master/examples/tutorial/tutorial03.cpp#L15</a><br>Базовый пример прокидывания C++ класса в daScript. Похоже на другие скриптовые языки, создаётся класс-обёртка (<code>ManagedStructureAnnotation</code>) над типом, которая позволяет привязать и настроить отображение полей и методов структуры на тип в daScript, а также переопределить группу методов, определяющих свойства этого типа в daScript.</p><figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> Color &#123;</span><br><span class="line">    uint8_t r, g, b, a;</span><br><span class="line">&#125;;</span><br><span class="line">MAKE_TYPE_FACTORY(Color, Color);</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> ColorAnnotation : <span class="keyword">public</span> ManagedStructureAnnotation&lt;Color,<span class="keyword">true</span>,<span class="keyword">true</span>&gt; &#123;</span><br><span class="line">    ColorAnnotation(ModuleLibrary &amp; ml) : ManagedStructureAnnotation (<span class="string">"Color"</span>, ml) &#123;</span><br><span class="line">        <span class="comment">//type fields</span></span><br><span class="line">        addField&lt;DAS_BIND_MANAGED_FIELD(r)&gt;(<span class="string">"r"</span>);</span><br><span class="line">        addField&lt;DAS_BIND_MANAGED_FIELD(g)&gt;(<span class="string">"g"</span>);</span><br><span class="line">        addField&lt;DAS_BIND_MANAGED_FIELD(b)&gt;(<span class="string">"b"</span>);</span><br><span class="line">        addField&lt;DAS_BIND_MANAGED_FIELD(a)&gt;(<span class="string">"a"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//type behaviour</span></span><br><span class="line">    virtual bool isLocal() const <span class="keyword">override</span> &#123; <span class="keyword">return</span> <span class="keyword">true</span>; &#125;</span><br><span class="line">    virtual bool canCopy() const <span class="keyword">override</span> &#123; <span class="keyword">return</span> <span class="keyword">true</span>; &#125; </span><br><span class="line">    virtual bool canMove() const <span class="keyword">override</span> &#123; <span class="keyword">return</span> <span class="keyword">true</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Module_Tutorial03 : <span class="keyword">public</span> Module &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Module_Tutorial03() : Module(<span class="string">"tutorial_03"</span>) &#123;</span><br><span class="line">        ModuleLibrary lib;</span><br><span class="line">        lib.addModule(this);</span><br><span class="line">        addAnnotation(make_smart&lt;ColorAnnotation&gt;(lib));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">REGISTER_MODULE(Module_Tutorial03);</span><br></pre></td></tr></table></figure><p>Более продвинутые <a href="https://github.com/GaijinEntertainment/daScript/blob/master/examples/test/test_handles.cpp" target="_blank" rel="noopener">примеры</a>, также можно смотреть код <a href="https://github.com/GaijinEntertainment/daScript/tree/master/modules" target="_blank" rel="noopener">модулей</a>.</p><h2 id="Наследование"><a href="#Наследование" class="headerlink" title="Наследование"></a>Наследование</h2><p>Отнаследоваться от C++ типа нельзя (<em>ну, или я не нашёл способа сделать такой тип</em>).</p><p>Существует возможность передать в daScript связь родитель-потомок между C++-типами (<a href="https://github.com/borisbat/dasSFML/blob/4501a9167692180d138da4a487a42375a377db68/src/dasSFML.struct.add.inc#L134" target="_blank" rel="noopener">пример</a>), для upcast-приведения типов аргументов функций.</p><p>Пример организации связи между С++ и daScript-классами - <a href="https://github.com/GaijinEntertainment/daScript/blob/master/examples/tutorial/tutorial04.cpp#L45" target="_blank" rel="noopener">tutorial04</a>.</p><img style="background-color:white;" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjk3IiBoZWlnaHQ9IjE5OSIgdmVyc2lvbj0iMS4xIiBiYXNlUHJvZmlsZT0iZnVsbCIgdmlld2JveD0iMCAwIDY5NyAxOTkiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHhtbG5zOmV2PSJodHRwOi8vd3d3LnczLm9yZy8yMDAxL3htbC1ldmVudHMiIHN0eWxlPSJmb250LXdlaWdodDpib2xkOyBmb250LXNpemU6MTJwdDsgZm9udC1mYW1pbHk6J0NhbGlicmknLCBIZWx2ZXRpY2EsIHNhbnMtc2VyaWY7O3N0cm9rZS13aWR0aDozO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbGluZWNhcDpyb3VuZCI+PHBhdGggZD0iTTE4NC4xIDQ0LjUgTDExMiA2NC41IEwxMTIgODQuNSBMMTEyIDg0LjUgIiBzdHlsZT0ic3Ryb2tlOiMzMzMyMkU7ZmlsbDpub25lO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTsiPjwvcGF0aD4KPHBhdGggZD0iTTEwNi43IDcxLjIgTDExMiA3Ny44IEwxMTcuMyA3MS4yIEwxMTIgODQuNSBaIiBzdHlsZT0ic3Ryb2tlOiMzMzMyMkU7ZmlsbDojMzMzMjJFO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTsiPjwvcGF0aD4KPHBhdGggZD0iTTI5NS45IDQ0LjUgTDM2OCA2NC41IEwzNjggODQuNSBMMzY4IDg0LjUgIiBzdHlsZT0ic3Ryb2tlOiMzMzMyMkU7ZmlsbDpub25lO3N0cm9rZS1kYXNoYXJyYXk6NiA2OyI+PC9wYXRoPgo8cGF0aCBkPSJNMzYyLjcgNzEuMiBMMzY4IDc3LjggTDM3My4zIDcxLjIgTDM2OCA4NC41IFoiIHN0eWxlPSJzdHJva2U6IzMzMzIyRTtmaWxsOiMzMzMyMkU7c3Ryb2tlLWRhc2hhcnJheTpub25lOyI+PC9wYXRoPgo8cGF0aCBkPSJNNjA1IDExNS41IEw2MDUgMTM1LjUgTDUzOC4yIDE1NS41IEw1MzguMiAxNTUuNSAiIHN0eWxlPSJzdHJva2U6IzMzMzIyRTtmaWxsOm5vbmU7c3Ryb2tlLWRhc2hhcnJheTpub25lOyI+PC9wYXRoPgo8cGF0aCBkPSJNNTQ5LjUgMTQ2LjYgTDU0NC42IDE1My42IEw1NTIuNSAxNTYuOCBMNTM4LjIgMTU1LjUgWiIgc3R5bGU9InN0cm9rZTojMzMzMjJFO2ZpbGw6IzMzMzIyRTtzdHJva2UtZGFzaGFycmF5Om5vbmU7Ij48L3BhdGg+CjxwYXRoIGQ9Ik0zNjggMTE1LjUgTDM2OCAxMzUuNSBMNDM0LjggMTU1LjUgTDQzNC44IDE1NS41ICIgc3R5bGU9InN0cm9rZTojMzMzMjJFO2ZpbGw6bm9uZTtzdHJva2UtZGFzaGFycmF5Om5vbmU7Ij48L3BhdGg+CjxwYXRoIGQ9Ik00MjAuNSAxNTYuOCBMNDI4LjQgMTUzLjYgTDQyMy41IDE0Ni42IEw0MzQuOCAxNTUuNSBaIiBzdHlsZT0ic3Ryb2tlOiMzMzMyMkU7ZmlsbDojMzMzMjJFO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTsiPjwvcGF0aD4KPHJlY3QgeD0iMTIyLjUiIHk9IjEzLjUiIGhlaWdodD0iMzEiIHdpZHRoPSIyMzUiIHN0eWxlPSJzdHJva2U6IzMzMzIyRTtmaWxsOnBpbms7c3Ryb2tlLWRhc2hhcnJheTpub25lOyI+PC9yZWN0Pgo8dGV4dCB4PSIxMzAuOCIgeT0iMzUiIHN0eWxlPSIiPlR1dG9yaWFsQmFzZUNsYXNzIChkYXMpPC90ZXh0Pgo8cmVjdCB4PSIxMy41IiB5PSI4NC41IiBoZWlnaHQ9IjMxIiB3aWR0aD0iMTk3IiBzdHlsZT0ic3Ryb2tlOiMzMzMyMkU7ZmlsbDpwaW5rO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTsiPjwvcmVjdD4KPHRleHQgeD0iMjEuOCIgeT0iMTA2IiBzdHlsZT0iIj5FeGFtcGxlT2JqZWN0IChkYXMpPC90ZXh0Pgo8cmVjdCB4PSIyNTAuNSIgeT0iODQuNSIgaGVpZ2h0PSIzMSIgd2lkdGg9IjIzNSIgc3R5bGU9InN0cm9rZTojMzMzMjJFO2ZpbGw6I2VlZThkNTtzdHJva2UtZGFzaGFycmF5Om5vbmU7Ij48L3JlY3Q+Cjx0ZXh0IHg9IjI1OC44IiB5PSIxMDYiIHN0eWxlPSIiPlR1dG9yaWFsQmFzZUNsYXNzIChjcHApPC90ZXh0Pgo8cmVjdCB4PSI1MjUuNSIgeT0iODQuNSIgaGVpZ2h0PSIzMSIgd2lkdGg9IjE1OSIgc3R5bGU9InN0cm9rZTojMzMzMjJFO2ZpbGw6I2VlZThkNTtzdHJva2UtZGFzaGFycmF5Om5vbmU7Ij48L3JlY3Q+Cjx0ZXh0IHg9IjUzMy44IiB5PSIxMDYiIHN0eWxlPSIiPkJhc2VDbGFzcyAoY3BwKTwvdGV4dD4KPHJlY3QgeD0iMzc0LjUiIHk9IjE1NS41IiBoZWlnaHQ9IjMxIiB3aWR0aD0iMjI1IiBzdHlsZT0ic3Ryb2tlOiMzMzMyMkU7ZmlsbDojZWVlOGQ1O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTsiPjwvcmVjdD4KPHRleHQgeD0iMzgyLjUiIHk9IjE3NyIgc3R5bGU9IiI+QmFzZUNsYXNzQWRhcHRlciAoY3BwKTwvdGV4dD48L3N2Zz4=" /><p>В примере связь организуется через класс <code>BaseClassAdapter</code>, который наследуется одновременно от базового C++-класса и сгенерированного по das-коду C++-классу-адаптеру</p><figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">options remove_unused_symbols = <span class="keyword">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//interface C++/daScript</span></span><br><span class="line"><span class="keyword">class</span> TutorialBaseClass</span><br><span class="line">    def <span class="keyword">abstract</span> update ( dt : float ) : <span class="keyword">void</span></span><br><span class="line">    def <span class="keyword">abstract</span> get_position : float3</span><br><span class="line"></span><br><span class="line"><span class="comment">// uncomment the section to generate C++ bindings for the TutorialBaseClass</span></span><br><span class="line"><span class="comment">// this code will generate tutorial04_gen.inc which contains C++ bindings</span></span><br><span class="line"></span><br><span class="line">require fio</span><br><span class="line">require ast</span><br><span class="line">require daslib/cpp_bind</span><br><span class="line">[init]</span><br><span class="line">def generate_cpp_bindings</span><br><span class="line">    <span class="keyword">let</span> root = get_das_root() + <span class="string">"/examples/tutorial/"</span></span><br><span class="line">    fopen(root + <span class="string">"tutorial04_gen.inc"</span>,<span class="string">"wb"</span>) &lt;| $ ( cpp_file )</span><br><span class="line">        <span class="comment">//generate c++ code from dascript rtti class information</span></span><br><span class="line">        log_cpp_class_adapter(cpp_file, <span class="string">"TutorialBaseClass"</span>, typeinfo(ast_typedecl <span class="class"><span class="keyword">type</span>&lt;TutorialBaseClass&gt;))</span></span><br></pre></td></tr></table></figure><p><code>TutorialBaseClass</code> - интерфейс между C++/daScript, который используется генератором C++-обёрток <code>log_cpp_class_adapter</code>, на выходе получается примерно такой C++-код:</p><figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> TutorialBaseClass &#123;</span><br><span class="line">protected:</span><br><span class="line">  enum &#123;</span><br><span class="line">    __fn_update = <span class="number">0</span>,</span><br><span class="line">    __fn_get_position = <span class="number">1</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">protected:</span><br><span class="line">  <span class="keyword">static</span> int _das_class_method_offset[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  TutorialBaseClass ( const StructInfo * info ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( _das_class_method_offset[<span class="number">0</span>]==<span class="number">0</span> ) &#123;</span><br><span class="line">      _das_class_method_offset[__fn_update] = adapt_field_offset(<span class="string">"update"</span>,info);</span><br><span class="line">      _das_class_method_offset[__fn_get_position] = adapt_field_offset(<span class="string">"get_position"</span>,info);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">static</span> __forceinline Func get_get_position ( <span class="keyword">void</span> * self ) &#123;</span><br><span class="line">    <span class="keyword">return</span> getDasClassMethod(self,_das_class_method_offset[__fn_get_position]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> __forceinline float3 invoke_get_position ( Context * __context__, Func __funcCall__, <span class="keyword">void</span> * self ) &#123;</span><br><span class="line">    <span class="keyword">return</span> das_invoke_function&lt;float3&gt;::invoke</span><br><span class="line">      &lt;<span class="keyword">void</span> *&gt;</span><br><span class="line">        (__context__,nullptr,__funcCall__,</span><br><span class="line">          self);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int TutorialBaseClass::_das_class_method_offset[<span class="number">2</span>];</span><br></pre></td></tr></table></figure><p>Вызов:<br><figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> BaseClassAdapter : <span class="keyword">public</span> BaseClass, <span class="keyword">public</span> TutorialBaseClass &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// in the constructor we store pointer to the original class and context</span></span><br><span class="line">    <span class="comment">// we also pass StructInfo of the daScript class to the generated class</span></span><br><span class="line">    BaseClassAdapter ( char * pClass, const StructInfo * info, Context * ctx )</span><br><span class="line">        : TutorialBaseClass(info), classPtr(pClass), context(ctx) &#123; &#125;</span><br><span class="line">    ...</span><br><span class="line">    virtual float3 getPosition() <span class="keyword">override</span> &#123;</span><br><span class="line">        <span class="comment">// we check if daScript class has 'get_position'</span></span><br><span class="line">        <span class="keyword">if</span> ( auto fn = get_get_position(classPtr) ) &#123;</span><br><span class="line">            <span class="comment">// we invoke it, and return it's result</span></span><br><span class="line">            <span class="keyword">return</span> invoke_get_position(context, fn, classPtr);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> float3(<span class="number">0.0</span>f);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">protected:</span><br><span class="line">    <span class="keyword">void</span> *      classPtr;   <span class="comment">// stored pointer to the daScript class</span></span><br></pre></td></tr></table></figure></p><p>Класс не содержит особой магии, а просто хранит адреса daScript-функций и позволяет прозрачно для вызывающего C++-кода их вызывать и изменять.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;ul&gt;
&lt;li&gt;&lt;a h
      
    
    </summary>
    
    
    
      <category term="cpp" scheme="http://spiiin.github.io/tags/cpp/"/>
    
      <category term="dascript" scheme="http://spiiin.github.io/tags/dascript/"/>
    
  </entry>
  
  <entry>
    <title>Agner Fog&#39;s Optimization manuals</title>
    <link href="http://spiiin.github.io/blog/30406011/"/>
    <id>http://spiiin.github.io/blog/30406011/</id>
    <published>2024-02-20T14:54:39.000Z</published>
    <updated>2024-02-20T19:14:10.539Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p><a href="https://www.agner.org/optimize/#manuals" target="_blank" rel="noopener">https://www.agner.org/optimize/#manuals</a> - отличные мануалы по оптимизациям от датского эволюционного биолога (программирует, наверное, для души).</p><h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><p><a href="https://www.agner.org/optimize/optimizing_cpp.pdf" target="_blank" rel="noopener">Optimizing software in C++: An optimization guide for Windows, Linux and Mac platforms</a> — стоимость абстракций в C++ коде.</p><ul><li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/TR18015.pdf" target="_blank" rel="noopener">ISO/IEC TR 18015, “Technical Report on C++ Performance”</a></li></ul><p>Большая часть и так должна быть хорошо известна программистам.</p><p>Многие знают также способ борьбы с виртуальными функциями с помощью <a href="https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern" target="_blank" rel="noopener">CRTP+static_cast</a>.</p><ul><li><a href="/blog/1552834708/" title="Runtime-полиморфизм в C++">Runtime-полиморфизм в C++</a> - еще про способы реифицировать полиморфизм</li></ul><p><a href="https://www.youtube.com/watch?v=xpomlTd41hg" target="_blank" rel="noopener">A Journey Into Non-Virtual Polymorphism in C++ - Rudyard Merriam</a> - C++23 способ провернуть то же самое через <code>deducing this</code>, немного менее сuriously</p><p><a href="https://www.youtube.com/watch?v=jXf--bazhJw" target="_blank" rel="noopener">Deducing this Patterns - Ben Deane</a> - более детально.<br>Один из прикольных паттернов оттуда:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_vector</span> :</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::<span class="built_in">vector</span>;</span><br><span class="line">    auto sorted_by(this my_vector self, auto comp)-&gt;my_vector &#123;</span><br><span class="line">        sort(self.begin(), self.end(), comp);</span><br><span class="line">        <span class="keyword">return</span> self;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//прокидывается в функцию как rvalue</span></span><br><span class="line">my_vector&#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">2</span>&#125;.sorted_by(less_than);</span><br></pre></td></tr></table></figure><h2 id="Asm"><a href="#Asm" class="headerlink" title="Asm"></a>Asm</h2><p><a href="https://www.agner.org/optimize/microarchitecture.pdf" target="_blank" rel="noopener">The microarchitecture of Intel, AMD, and VIA CPUs</a> - позиционируется как гайд для ассемблерщиков и компиляторщиков. Но всё еще понятно для gamedev программистов и любителей почитать дизассемблированный листинг сгенерированного компилятором C++-кода.</p><p>Для меня мануал оказался интересен объяснением архитектуры современных процессоров языком, всё еще понятным программистам, а не железячникам. Плюс в универе когда-то был курс по архитектуре компьютеров, который начинался с 8086 и заканчивался очень беглым описанием первых Pentium, а тут как раз продолжение ровно с того места, на котором он заканчивался.</p><p>Для примера, многие C++-программисты могут ответить, что <code>++i</code> лучше чем <code>i+=1</code>, так как у процессора есть специальная инструкция <code>inc</code>, оптимизированная для прибавления единицы. Однако можно проверить, что современные компиляторы вставляют вместо этого <code>add eax, 1</code> (а с оптимизациями и вообще <code>lea eax, [rdi + 1]</code>). Почему же они не используют “быстрый” <code>inc</code>?</p><ul><li>современные процессоры умеют <code>Out-of-order execution</code>. Инструкции разбиваются на микро-операции.</li></ul><p>Какой-нибудь <code>push eax</code> может разделяться на операцию вычисления нового адреса верхушки стека (для чего есть отдельный пайплайн stack engine), и операцию перемещения из регистра по этому адресу. Выполнить первую микро-операцию можно отдельно от второй и даже раньше, чем предыдущию инструкцию, которая записывает значение в этот регистр. Соответственно, процессор “знает” о том, какие микрооперации можно выполнять независимо от других, а какие должны дождаться выполнения предыдущих</p><p><em>Забавно, что микро-операции затем снова могут склеиваться в одну макро-операцию(instruction fusion), для экономии памяти. Существует кеш декодированных инструкций, чтобы не тратить время на повторное декодирование для коротких циклов. Интересно, если ли в каких-нибудь процессорах регистры, в которые можно загрузить инструкции (хотя бы в архитектурах, где инструкции одинакового размера)</em></p><ul><li>еще одна фича процессоров — вместо прямого использования указанного регистра, может использоваться временный невидимый регистр.</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov eax, [mem1] # допустим, что mem1 в кеше</span><br><span class="line">mov ebx, [mem2] #     а mem2 нет</span><br><span class="line">add ebx, eax    # нужно дождаться чтения mem2</span><br><span class="line">imul eax, 6     # можно начинать выполнять умножение раньше сложения, так как копия eax</span><br><span class="line">                #    необходимая для выполнения сложения сохранится</span><br><span class="line">                #    для предыдущей операции во временном регистре</span><br><span class="line">mov [mem3], eax</span><br><span class="line">mov [mem4], ebx</span><br></pre></td></tr></table></figure><ul><li>многие инструкции меняют значения флагов. Флаги хранятся в регистре, который тоже может быть заменён на временный. Некоторые операции требуют синхронизации временного регистра с обычным (retirement).</li><li>по <em>историческим причинам</em> inc не меняет значения carry-флага процессора, в отличие от add. Из-за этого следующие за ней инструкции, использующие значения регистра флагов, должны собрать актуальное значение этого регистра флагов (дополнительная микро-операция). lea же хороша тем, что вообще не трогает флаги.</li></ul><p>Еще один ненормальный факт из мира асма, непонятный C++ программистам: у некоторых процессоров с несколькими декодировщиками инструкций эти декодировщики обладают неодинаковыми возможностями - например, первый может декодировать инструкции, которые генерируют от 1 до 4 микроопераций, а второй и третий - только инструкции с 1 микрооперацией. В этом случае для достижения максимальной скорости выполнения инструкции должны быть расставлены “в стихотворной форме”, по паттерну 4-1-1, чтобы занять одновременно все 3 декодировщика (генерация одновременно по 6 микроопераций за цикл, а при ритме 2-2-2 - по 2 микрооперации за цикл).</p><p>Инструкции могут декодироваться заранее, если следующие стадии заняты вычислениями. Корректному декодированию могут мешать инструкции условных переходов (<code>if/loop</code>) и indirect jump с несколькими вариантами перехода(<code>switch/function pointers/virtual</code>). Аппаратный способ борьбы с неправильным декодированием — предсказания переходов.</p><p>Простейший “предсказатель” логического перехода — таблица из адреса перехода и соотвествующего ему двухбитного saturating-счётчика (“почти точно правда/скорее правда/скорее ложь/почти точно ложь”). Другой вариант трактовки бит в счётчике — вместо “переход произойдёт/не произойдёт” - “будет ли как в прошлый раз/будет не так, как прошлый раз” (позволяет предсказывать flip-flop переходы). Более сложные варианты могут содержать “память” на несколько предыдущих значений, например, 4 saturating-счётчика, каждый из которых показывает, какая вероятность перехода в следующее состояние в зависимости от 2х предыдущих состояний. Для indirect jump также необходимы несколько saturating-счётчиков для каждого из вариантов перехода. Предсказатели циклов могут запоминать количество повторов цикла. Различные варианты могут объединяться в гибридные предсказатели.</p><p>Если отойти от магии инструкций и их предсказаний — важными являются также предсказуемые паттерны доступа к данным. Чтобы данные эффективно попадали в кеши, они должны лежать в памяти последовательно. Кеш-строк много, так что удобная тактика для циклов — за первый проход захватить все нужные для последующих проходов данные в кеш-строки, чтобы второй и последующий проходы использовали данные из этих кеш-строк.<br><a href="https://en.wikipedia.org/wiki/AoS_and_SoA#Array_of_structures_of_arrays" target="_blank" rel="noopener">Array of structures of arrays</a> - Array of structures of arrays - способ раскладывания в памяти данных, чтобы и в кеш побольше попало, и чтобы обрабатывать пачками. В плане возможностей описания данных в памяти, си не очень далеко ушёл от ассемблера.</p><h2 id="Оптимизации-компиляторов"><a href="#Оптимизации-компиляторов" class="headerlink" title="Оптимизации компиляторов"></a>Оптимизации компиляторов</h2><p>Chandler Carruth, но в ту же тему:<br><a href="https://www.youtube.com/watch?v=eR34r7HOU14" target="_blank" rel="noopener">Optimizing the Emergent Structures of C++</a> — про возможности в оптимизации инструкций и данных компилятором.<br><a href="https://www.youtube.com/watch?v=fHNmRkzxHWs" target="_blank" rel="noopener">Efficiency with Algorithms, Performance with Data Structures</a> — как обычно, векторы и хеш-таблицы без списков внутри эффективные, списки и графы (и структуры в которых они неявно спрятаны) — нет.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;&lt;a href=&quot;h
      
    
    </summary>
    
    
    
      <category term="cpp" scheme="http://spiiin.github.io/tags/cpp/"/>
    
      <category term="asm" scheme="http://spiiin.github.io/tags/asm/"/>
    
      <category term="link" scheme="http://spiiin.github.io/tags/link/"/>
    
  </entry>
  
  <entry>
    <title>Уровень программирования: Lead</title>
    <link href="http://spiiin.github.io/blog/1633438451/"/>
    <id>http://spiiin.github.io/blog/1633438451/</id>
    <published>2024-02-19T10:45:44.000Z</published>
    <updated>2024-02-19T11:11:19.428Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Развитие программиста в геймдеве.</p><p>Предыдущие:</p><ul><li><a href="/blog/1048/" title="Как устроиться на работу программистом">Как устроиться на работу программистом</a></li><li><a href="/blog/15798/" title="Уровень программирования: Middle">Уровень программирования: Middle</a></li><li><a href="/blog/3652741154/" title="10 лет в геймдеве">10 лет в геймдеве</a></li><li><a href="/blog/258274191/" title="Уровень программирования: Senior">Уровень программирования: Senior</a></li><li><a href="/blog/1976052536/" title="Уровень программирования: Senior++">Уровень программирования: Senior++</a></li></ul><p>Развитие скиллов выглядит примерно так:<br><img src="/blog/1633438451/dev_evolution.png" alt=""></p><p>Сначала учится базовый язык и алгоритмы.</p><p>Затем постепенно накапливаются знания advanced-фич языка, скиллы создания/настройки/использования инфраструктуры работы с проектом, и специфические для разработки игр приёмы/практики/методы.</p><p>Дальше кружок с domain-specific навыками/знаниями постепенно расширяется и охватывает все остальные. Также начинают появляться и накапливаться знания в “соседних” дисциплинах (как вообще работают и чем именно занимаюотся коллеги в команде).</p><ul><li><a href="/blog/2897492989/" title="Архетипы high-level программистов в геймдеве">Архетипы high-level программистов в геймдеве</a> — ещё более продвинутые архитипы программистов в геймдеве</li><li><a href="/blog/4256110900/" title="Эволюция программиста в геймдеве">Эволюция программиста в геймдеве</a> — модель развития сотрудников в стиле Final Fantasy Tactics</li><li><a href="/blog/3299387993/" title="Геймдизайн, заметки">Геймдизайн, заметки</a> — соседний кружок гейм-дизайнеров</li></ul><p>Проектирование/архитектура</p><ul><li><a href="/blog/1337028819/" title="Немного о проектировании">Немного о проектировании</a></li><li><a href="/blog/2721099263/" title="Ещё о проектировании (движки и история)">Ещё о проектировании (движки и история)</a></li></ul><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;Развитие п
      
    
    </summary>
    
    
    
      <category term="meta" scheme="http://spiiin.github.io/tags/meta/"/>
    
      <category term="dev_evolution" scheme="http://spiiin.github.io/tags/dev-evolution/"/>
    
  </entry>
  
  <entry>
    <title>Ещё о проектировании (движки и история)</title>
    <link href="http://spiiin.github.io/blog/2721099263/"/>
    <id>http://spiiin.github.io/blog/2721099263/</id>
    <published>2024-02-02T07:40:32.000Z</published>
    <updated>2024-03-05T14:48:05.354Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Навеяно статьёй <a href="https://habr.com/ru/articles/774972/" target="_blank" rel="noopener">Вы точно хотите пойти программистом в gamedev?</a> dalerank-a и лекцией <a href="https://gamedev.ru/community/gamedev_lecture/articles/?id=571" target="_blank" rel="noopener">Лекция #14. Паттерны revisited</a> aruslan-а 2006 года. Иногда и просто пересказ мыслей оттуда, а также много истории.</p><p>Кажется (судя по linkedin + иногда из личного общения), что осмысленно рассуждать и обобщать в геймдеве, можно <em>начать</em> только где-то после 8-10 лет работы в индустрии. Может быть, если есть хороший учитель, то раза в 2 быстрее.</p><blockquote><p>Мудрость не всегда приходит с возрастом, иногда возраст приходит один</p></blockquote><p>Естественно, нужно не только время. Прокачка хард-скиллов важна, но для понимания динамики процессов развития геймдев-компаний необходимо ещё как минимум:</p><ul><li>выборка нескольких компаний и наблюдение за ними, и процессы перехода между стадиями (с поправкой на меняющие условия рынка)</li><li>пронаблюдать и проанализировать долгосрочные последствия принятых решений</li><li>понимание уровня абстракции, на котором можно об этом рассуждать, терминология (системное мышление? язык паттернов? свой язык?). Слишком общая мешает описывать явления, специфичные для геймдева, слишком частная уводит в необходимость пояснять каждый свой термин</li><li>время на то, чтобы поковыряться с тем, что уже надумали другие. Врубиться в чужие рассуждения 15-летней давности и терминологию, как и в чужой код, непросто.</li></ul><p>Но если хочется залезть на плечи гигантов, то стоит попробовать<br><img src="/blog/2721099263/giants_small.png" alt=""></p><p>История в этом посте не для ностальгии, и не для того, чтобы оспорить аргументы дискуссий 10-20 летней давности, а для дела:</p><ul><li>Эволюция движков и используемые практики связаны не только с какими-то “абсолютными” характеристиками кода, а с внешними условиями (чаще всего — у кого сколько денег, и кто сколько денег может заработать с игроков). Чтобы продать движок нужна команда продажников, которые будут его продавать. По ссылкам при желании можно восстановить контекст. Часть продуктов, вроде Unreal, на слуху и сейчас, часть того, что казалось большим и серьёзным, уже не существует (XNA, Renderware).<br><img src="/blog/2721099263/unity_vs_small.png" alt=""><br>Конкуренты Unity 2010, попробуйте разгадать все логотипы. <a href="https://aras-p.info/texts/files/2017-VVK-Unity.pdf" target="_blank" rel="noopener">Random Stories About Unity</a></li></ul><ul><li>Если для окупаемости игры достаточно нескольких программистов, пишущих приложение, и соответствующего качества кода/арта, то они такие и будут. Примеры: ранние состояния appstore, <a href="https://vas3k.club/post/20571/" target="_blank" rel="noopener">hyper casual</a>, windows, появление домашних пк.</li><li>В интернете информация живёт не вечно, что особенно заметно при археологических раскопках блогов 2000х (особенно если походить ещё там по ссылкам), пересказ помогает сохранить информацию, которая и сейчас не потеряла актуальности.</li><li>Мониторить устройство даже нескольких движков непросто. Движки отличаются не только дизайном/архитектурой, но и количеством и качеством фич. Кроме оценки используемых паттернов с высоты птичьего полёта, существует еще и качество реализации. Aruslan в лекции говорит в том, что сравнивает только “правильные” реализации паттернов. Это необходимое допущение для его уровня рассуждений, но в реальных достигших зрелости движках и библиотеках всё равно существует много грязи, или кривых реализаций. Из-за объёма кода, трудоёмкости и наличия легаси-кода. Публичная информация о движках поступает от маркетинга, а не программистов, её же можно увидеть и на ресурсах типа википедии. Старые записи — чуть ли не единственное место с субъективными оценками от программистов.</li></ul><p>Шутейки и афоризмы про музыку и дзен захвачены и пересказаны вместе с идеями.</p><p>Стартовые моменты:</p><h2 id="Архитектура-и-проектирование-design-это-не-одно-и-тоже-Архитектор-и-проектировщик-—-разные-должности"><a href="#Архитектура-и-проектирование-design-это-не-одно-и-тоже-Архитектор-и-проектировщик-—-разные-должности" class="headerlink" title="Архитектура и проектирование (design), это не одно и тоже. Архитектор и проектировщик — разные должности"></a>Архитектура и проектирование (design), это не одно и тоже. Архитектор и проектировщик — разные должности</h2><p>Архитектура - про процессы и результаты, дизайн — про решения (иногда в терминах паттернов и идиом).  Основной смысл деятельности дизайнера — в выборе решения. Именно в выборе, поиске компромисса. Дизайн не про выбор хорошего вместо плохого, в этом случае просто: если можешь сделать хорошо — сделай.</p><p>Но бывает необходим выбор точки на шкале, в которой обе крайние положения “хорошие”, и при этом присутствуют различные глобальные силы, которые тянут в разные стороны, и у решения будут различные далекоидущие последствия. Глобальные силы — не про программирование, а про распределение обязанностей.</p><ul><li><a href="/blog/2897492989/" title="Архетипы high-level программистов в геймдеве">Архетипы high-level программистов в геймдеве</a> - по моим архетипам программистов, дизайнер там же, где и архитектор, разве что наверное чуток сдвинут в сторону продюссера</li></ul><p><img src="/blog/2721099263/triada_small.png" alt=""></p><h2 id="Работа-дизайнера-—-сделать-так-чтобы-попасть-в-желаемую-точку-на-каждой-шкале"><a href="#Работа-дизайнера-—-сделать-так-чтобы-попасть-в-желаемую-точку-на-каждой-шкале" class="headerlink" title="Работа дизайнера — сделать так, чтобы попасть в желаемую точку на каждой шкале"></a>Работа дизайнера — сделать так, чтобы попасть в желаемую точку на каждой шкале</h2><p>К примеру, тут — <a href="/blog/1337028819/" title="Немного о проектировании">Немного о проектировании</a>.<br><code>Зависимости от компонентов и свойства API</code> выбор по шкалам:</p><ul><li>Разделяемость (Granularity) -&gt; шкала “Гибкость vs простота”</li><li>Избыточность (Redundancy) -&gt; Удобство vs ортогональность</li><li>Cвязанность (Coupling) -&gt; Несвязанность vs запутанность (не надо выбирать запутанность, “дзен-даунизм” в терминах aruslan-а)</li><li>Запоминание (Retention) -&gt; Сложность синхронизации состояний vs автоматизация работы после настройки</li><li>Порядок вызовов (Flow Control) -&gt; Контроль на стороне приложения vs на стороне библиотеки</li></ul><p>И немного тут — <a href="/blog/1152347544/" title="Хорошие библиотеки">Хорошие библиотеки</a> (но большая часть критериев на луче “хорошо/плохо”)</p><ul><li>покупать vs брать готовое</li><li>framework vs library</li><li>простота vs гибкость</li></ul><p>Тут не шкала — <a href="/blog/1363625753/" title="Мотивация &quot;честного&quot; программиста">Мотивация &quot;честного&quot; программиста</a>, а просто необходимый дзен-майндсет для начала перехода компании с фазы 1 на фазу 2 (про фазы дальше, простыми словами это “начать разгребать авгиевы конюшни”).</p><p>Один из инструментов дизайнера — паттерны.</p><h2 id="Паттерны-не-обязательно-связаны-с-языками-программирования"><a href="#Паттерны-не-обязательно-связаны-с-языками-программирования" class="headerlink" title="Паттерны не обязательно связаны с языками программирования"></a>Паттерны не обязательно связаны с языками программирования</h2><p><em>Насчёт перевода “паттерн”, в русском встречается ещё “шаблон”. На курсах английского (в котором тоже бывают “грамматические паттерны”) преподаватель предложил вариант “узор”, который мне кажется более красивым и подходящим словом для описания того, про что писал Кристофер Александер изначально. “Шаблон” - это жёсткая форма, не допускающая вариативности, а “узор” — название для подобных друг другу, но отличающихся структур, замеченных в хаосе вселенной. Но менять что-то, кажется, уже поздно</em></p><p>Паттерны проектирования иногда ошибочно сводят к идеям GoF, но почти все идеи оттуда — <strong><code>design for change</code></strong>, организация борьбы с изменениями, инкапсуляция устойчивости к изменениям В КОДЕ , то есть уже в рамках картины мира “как нам это программировать”.</p><h2 id="Паттерны-нулевого-порядка"><a href="#Паттерны-нулевого-порядка" class="headerlink" title="Паттерны нулевого порядка"></a>Паттерны нулевого порядка</h2><p>Пример паттерна “нулевого порядка” — направление дизайна. Игра не дизайнится сверху вниз или снизу вверх или из середины. Направление дизайна и есть решение, зависящее от реальных проблем, которые стоят. По изначальным данным от маркетинга ещё не понятно, что нужно делать. 10 миллионов долларов (по нынешним временам может и 100) тоже сразу никто не выделит. Найти 15 программистов тоже не мгновенно. Так что для первых 1-3 программистов в начале нужны такие задачи, которые позволят двигаться дальше.</p><p>Собственно паттерны этого уровня — это <strong><code>способ организации компании/команды</code></strong>.</p><ul><li>Кто что будет делать.</li><li>Какие специализации у вас возникнут, когда вы взлетите.</li><li>Что важнее - время, качество кода, масштабируемость процесса, средние специалисты (которых легко нанять) и т.п.</li></ul><ul><li><a href="/blog/3914071471/" title="Иерархические компании vs плоские">Иерархические компании vs плоские</a> — про последствия разницы в начальном организационном выборе</li></ul><p>Шкала здесь — <code>небольшая компания VS большая</code>.</p><p>Способы организации, как и в любом паттерне, могут отличаться. Например, для организации небольшой компании <em>могут</em> использоваться принципы <a href="/blog/2486671624/" title="Метод Lean Startup">Метод Lean Startup</a>, или идеи Стэффорда Бира из <a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%BE%D0%B7%D0%B3_%D1%84%D0%B8%D1%80%D0%BC%D1%8B" target="_blank" rel="noopener">кибернетики</a>. Ограничением размера будет скорее <a href="https://ru.wikipedia.org/wiki/%D0%A7%D0%B8%D1%81%D0%BB%D0%BE_%D0%94%D0%B0%D0%BD%D0%B1%D0%B0%D1%80%D0%B0" target="_blank" rel="noopener">Число Данбара</a>. Пока оно не превышено, можно использовать различные способы организации небольших групп.</p><p>После превышения система все равно становится похожа на иерархию, т.е. можно смотреть на то, как организовываются корпорации, армии и государства. Альтернативные идеи — в децентрализованных системах без доверия или <a href="https://en.wikipedia.org/wiki/Free_and_open-source_software" target="_blank" rel="noopener">FOSS</a> (<a href="https://paulgraham.com/opensource.html" target="_blank" rel="noopener">What Business Can Learn from Open Source</a>).</p><p>Еще одна шкала уровня организации компании/команды — <strong><code>отношения между управляющими и подчинёнными</code></strong>. С одной стороны, целью компании является заработок денег. С другой — если требовать от небольшого количества людей за минимальную зарплату выдавать результат в кратчайшие сроки, отношения с исполнителями будут не дружеские.</p><p><em>Если дизайнер одновременно и менеджер и враждует с программистами — это не выбор на шкале, это всегда неправильно, люди разбегутся</em></p><p><strong>Есть только три способа сделать продукт дешевле: меньше людей, меньше зарплаты и меньше сроки. И есть только один способ сделать игру интереснее: дать возможность “двигать ползунки” тем, кто в этом понимает.</strong> Типично это не программисты.</p><blockquote><p>Разделение на подсистемы (и соответствующая специализация персонала), выбор системы на основе микроядра и т.п. - это всё первые, архитектурные паттерны. Будет ли система распределенной, будет ли игра просто игрой или это будет здоровый тулсет для её разработки и т.п. Первые решения потребуют от вас первого простого дзена - оценка масштаба проекта. Пет-прожекты не требуют мощных сложных комплексов паттернов.  Это будет для них overkill. Реальные игровые проекты - это не только и не столько программирование.  И программирование там сильно разное.  Масштаб другой.</p></blockquote><p><strong><code>YOLO-кодинг</code></strong></p><p>Угадать с масштабом не просто, многие начинают с <a href="https://github.com/a327ex/blog/issues/31" target="_blank" rel="noopener">YOLO-кодинга</a> (aka “Coding like it’s 1999”)<br><img src="/blog/2721099263/yolo_small.png" alt=""><br>(вместо ecs тут можно подставить другие архитектурные решения)</p><p>Почему происходит именно так? Да миллион причин.</p><ul><li>Проверить идею в виде прототипа кинули миддла (без разницы, как его в компании называют, пусть будет “23-летний бородатый сеньор”). Все более грамотные заняты чем-то неотложным</li><li>Компания не доросла до уровня, когда можно стартовать с чего-то серьёзного (у aruslan-а есть разделение компаний по 4-м уровням, перескажу дальше), приходиться форкаться от того, что есть в наличии</li><li>Не угадали с масштабом (например, в потолок своего задуманного масштаба, кажется, упирается <a href="https://godotengine.org/" target="_blank" rel="noopener">Godot</a>). Про игровые прототипы вспоминают, что они прототипы иногда лет через 5.</li></ul><ul><li><a href="/blog/3121981810/" title="Важность простых языков">Важность простых языков</a> — тут есть про проблему масштаба и на то, как влияет на неё используемый язык.</li></ul><p><strong><code>Выбор языка -- паттерн нулевого уровня</code></strong>. В геймдеве редко совершают выбор основного языка, выбирают сразу “пакет” из движка и тулзов. Шкала тут <code>Modern C++ VS Orthodox C++</code>. Может еще через 5 лет расширится.<br>(здесь именно про выбор языка для “скелета” игры, про баланс между “системный язык VS язык логики игры” будет дальше)</p><p>Принятые решения на уровне паттернов нулевого порядка — самые страшные и самые сильные.</p><p>Поэтому всем хочется найти тут серебряную пулю, но одновременно все консервативны относительно решений, которые “вроде уже сработали где-то”.</p><p>Так, допустим дизайнер не испугался и определился с этими абстрактными и страшными “паттернами нулевого уровня”. Несмотря на кажущееся огромным пространство возможностей, существует не очень много реально работающих вариантов развития. Один из типичных путей описан в другой заметке aruslan-а. Этот путь состоит из четырёх фаз развития геймдев-компаний, в некоторых местах будут ссылки на названия паттернов без объяснений, а то получится совсем длинно.</p><p>Про паттерны архитектуры софта можно почитать:</p><ul><li><a href="https://en.wikipedia.org/wiki/Pattern-Oriented_Software_Architecture" target="_blank" rel="noopener">Pattern-Oriented Software Architecture</a></li><li><a href="https://wiki.c2.com/?CategoryPattern" target="_blank" rel="noopener">c2 wiki</a></li><li><a href="https://web.archive.org/web/20040608074336/http://www.jcurley.com/software/design-patterns/design-patterns.html" target="_blank" rel="noopener">John Curley Design Patterns</a></li></ul><h2 id="Journey-from-Object-Oriented-Design-to-Data-Driven-Design"><a href="#Journey-from-Object-Oriented-Design-to-Data-Driven-Design" class="headerlink" title="Journey from Object Oriented Design to Data Driven Design"></a>Journey from Object Oriented Design to Data Driven Design</h2><p><a href="https://gamedev.ru/community/oo_design/forum/?id=886&amp;page=2&amp;m=12750#m22" target="_blank" rel="noopener">Оригинал</a></p><blockquote><p>В жизни многих игровых компаний есть фаза конструирования data-driven (table-driven, blabla-driven, Общая Шина (тм) - driven) движка. Конец этой фазы обычно совпадает с концом непрофильного инвестора глубоко в недрах компании.</p></blockquote><p>Описание того, как в компаниях рождаются идеи “давайте сделаем свой конструктор”.</p><p><code>Фаза 1</code><br>Есть наколбашенный код одной или больше игр, YOLO-style. Всё сделано классами. Есть GodObject aka GameObject, есть какой-нибудь GameLevel, который знаёт всё обо всех и передаётся повсюду. Всё связано со всем.</p><p><code>Фаза 2</code><br>Кто-нибудь решает “так жить нельзя”. И думает, как уменьшить связность<br>Начинается наведение красоты. Модули/системы, более стройные классы. Больше динамики с запросами “а есть ли у объекта что-то с таким именем такого-то типа?”</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">GameObject* player = Scene.findGameObject(<span class="string">"Player"</span>);</span><br><span class="line"><span class="keyword">if</span> (!player-&gt;hasComponent(<span class="string">"ControlComponent"</span>))</span><br><span class="line">&#123;</span><br><span class="line">    player-&gt;addComponent(<span class="keyword">new</span> ControlComponent());</span><br><span class="line">&#125;</span><br><span class="line">player-&gt;update();</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span>* window = createWindow(WINDOW_TYPE::BASIC_WINDOW);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span> buttonOk = cast&lt;MyCoolButton*&gt;(window-&gt;find(<span class="string">"ButtonOk"</span>))) &#123;</span><br><span class="line">  buttonOk-&gt;setHighlight(<span class="literal">true</span>);</span><br><span class="line">  buttonOk-&gt;setMessageHandler(window-&gt;getMessageHandler())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GameObject немного худеет, появляются всякие менеджеры, описания данных, всё обрастает умными указателями (поскольку в коде становится невозможным отличить полную сущность от её частей). Как следствие - резкое падение связности кода, обилие приведений типов, паттерн-матчинг и поиск подобъектов руками, frameworks, layers, messaging. Самый треш всегда в итоге почему-то остаётся в системе GUI и туториалах.</p><p><code>Фаза 3</code><br>Следующая фаза:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span>* window = createWindowFromJsonWithAllSubcomponentsAndLogic();</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Почему я должен писать вот такой вот код:  </span><br><span class="line">main_window   </span><br><span class="line">  find_control  &quot;ok_button&quot;   </span><br><span class="line">    cast_to_button   </span><br><span class="line">        find_control  &quot;button_text&quot;   </span><br><span class="line">          cast_to_text  </span><br><span class="line">              set_text &quot;Ok&quot;</span><br><span class="line"></span><br><span class="line">Я его не пишу? Как так?  </span><br><span class="line">Ах да, мне его генерят, автоматически.  </span><br><span class="line">То есть не мне, конечно...  </span><br><span class="line">Я и языка-то этого не знаю, на котором пол-приложения написано...</span><br><span class="line"></span><br><span class="line">И вообще - почему, блин, у меня описание моего простого окошка уехало куда-то в набор XML?  </span><br><span class="line">Что это за парень возле меня, которому я выплачиваю деньги, а он пишет какие-то координаты в XML?  </span><br><span class="line">Ой, а это кто?  Художник?</span><br><span class="line">Всё просто: </span><br><span class="line">  ОО-модель _моего_ приложения</span><br><span class="line">  была _вытеснена_ метамоделью _оконной системы_, </span><br><span class="line">  которую _настроили_, чтобы она воплотила моё приложение.</span><br></pre></td></tr></table></figure><p>Появление внеязыкового метаописания игровых объектов, обширное применение фабрик стратегий. Часто - скрипты в той или иной форме. Всё выносится из кода. В движковом коде остаётся только структура метаописания.</p><p><a href="https://www.gamearchitect.net/Articles/GameObjectRoundtable.html" target="_blank" rel="noopener">The GDC 2003 Game Object Structure Roundtable</a> - 20 лет, всё об одном.<br>Вариант 1 - Убираем coupling, привет, dungeon-siege-style компоненты. Только одинокие Naughty Dog говорят, что у них 99% кода на скриптах и почти ничего не повторяется в их Jak &amp; Daxter (у них там не ооп, а lisp-подобная vm). Оттого, что у них программистов больше чем дизайнеров, скрипты фигачат тоже программисты. Другие же попробовали UnrealScript в Unreal 2, и он не особо зашёл, поэтому хотят data-driven, оттого что у них на 1 программиста 10 артистов/геймдизайнеров, которые хотят настраивать компоненты.</p><p>Дискуссия не то чтобы устарела. Там где в компании программерская культура — хотят скрипты. Там где арт — хотят компоненты.</p><ul><li><a href="/blog/381238762/" title="ECS. Ссылки">ECS. Ссылки</a> - да, да, ECS и all that jazz</li></ul><p>Здесь у нас заканчиваются возможности C++ и начинается полёт фантазии. Как сериализовать? Если данные извне, и хотим их настраивать отдельными редакторами, то как хранить информацию для визуализации этих данных. Если начинать выносить логику, то как её отлаживать, мерджить, как делать композицию данных и скриптов? Те вопросы, у которых уже были решения пока мы “жили в мире С++”, нужно решать заново. Баланс между кодом на исходном языке и кодом на скриптах сам становится “ползунком”, который можно менять динамически, т.е. переписывая код со скриптов обратно на C++.</p><p>Начинаются идеи — а зачем нам собирать код вида <code>buttonOk = cast&lt;MyCoolButton*&gt;(window-&gt;find(&quot;ButtonOk&quot;)))</code>, если у нас уже есть описание данных (рефлексия), и можно было бы сгенерить код вида <code>window.buttonOk</code> по этим данным (быстрый и верифицируемый компилятором, ошибиться негде). Но при этом хотелось бы возможность и динамической загрузки, вдруг нам захочется сгенерировать описанием динамически, нужно уже оба представления данных (желательно, с лёгким переключением). А то и ещё навернуть вокруг опцию с ленивой загрузкой по первому обращению.</p><p>Хорошо тут то, что контент могут делать непрограммисты, которые лучше в этом производстве контента разбираются.</p><p>А плохо, что переползающая в скрипты и описание данных логика требует выполнения на виртуальной машине. А значит, отладки, профилирования, оптимизации, верификации, способов мерджа конфликтующих версий, паттернов работы с этим контентом. Геймдизайнеры и артисты начинают хотеть себе не только evaluation flow, но и execution flow — условия, циклы, асинхронность и параллельное выполнение.</p><p><a href="https://ru.wikipedia.org/wiki/%D0%94%D0%B5%D1%81%D1%8F%D1%82%D0%BE%D0%B5_%D0%BF%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D0%BE_%D0%93%D1%80%D0%B8%D0%BD%D1%81%D0%BF%D0%B5%D0%BD%D0%B0" target="_blank" rel="noopener">Десятое правило Гринспена</a></p><p>В этой схеме нужны у игровых программистов появляется дополнительная обязанность переписывания кода за геймдизайнерами и артистами, что выглядит странным, и плохо подходит для выделения в специализацию — переписывать чужой плохой код (а чужой код всегда плохой) утомительно.</p><p>Типичные дизайн паттерны: content/engine, table-driven design, frameworks, scripting.<br>Создание новых узких специальностей в команде.</p><p><code>Фаза 4</code><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">LoadGame(argv[<span class="number">1</span>])-&gt;PlayGame()</span><br></pre></td></tr></table></figure></p><blockquote><p>Вынесение всего игрового кода вовне, круг полностью замыкается. Движок становится виртуальной машиной. Окончательно фиксируются процессы make/debug/edit-and-continue. Большинство технических проблем третьей фазы превращаются в вопросы оптимизации контента. На этой фазе начинается новый виток спирали. Если вынесенная вовне модель страдает аналогичной C++ ригидностью - всё неминуемо начнётся с начала.</p></blockquote><p>Проблема со старыми скриптовыми языками в том, что они создавались для склейки частей кода, и не совсем подходили для того, чтобы быть основой игры (чтобы убрать роль программистов-“переписывальщиков”), или обладают недостатками C++.</p><ul><li><a href="/blog/2297379949/" title="Заметки о языках программирования">Заметки о языках программирования</a> - что даёт язык</li><li><a href="/blog/1728194429/" title="С++ в геймдеве">С++ в геймдеве</a> - что умеет C++, и чего не умеет</li><li><a href="https://spiiin.github.io/tags/dascript/">daScript</a> (естественно), 2 года первому моего посту про него</li></ul><h2 id="Уроки-истории"><a href="#Уроки-истории" class="headerlink" title="Уроки истории"></a>Уроки истории</h2><p>Тут стоит обратить внимание на даты. Я пересказываю компиляцию наблюдений и выводов 2006 года, обсуждение с GDC, на которое он ссылается, 2003 года. В 2005 Tim Sweeney рассуждает о The Next Mainstream Programming Language, к этому моменту где-то 2 года в разработке Unreal Engine 4, с блюпринтами. Минус пару лет на то, когда эти обсуждения из прототипов и идей перешли в публичную плоскость. 20 лет назад. Как дела сейчас?<br><img src="/blog/2721099263/gagarin_small.png" alt=""></p><p>Можно бьло бы подумать, что “сейчас уже наверное все точно пишут, как описано в фазе 4”, но в реальности встречаются компании, находящиеся на любом из 4х уровней. Почему — описано в начале в разделе <code>YOLO-кодинг</code>.</p><p>Объектный дизайн, на 1-й фазе, заключающийся в решении, что “один тип игрового объекта == один C++ класс, осталось выстроить их в дерево”, позволяет быстро начать. Между моментом, когда такое отношение приведёт к торможению игры или моментом, когда начнут тормозить программисты, проходит много времени.</p><p>То есть вот эта зелёная вертикальная линия на графике про YOLO-кодинг, она достаточно далеко во времени от старта разработки. Настолько, что можно не заморачиваться достаточно долго, что накопить много легаси-кода. Можно даже попробовать прикинуть, насколько. Возьмём доклад <code>Playrix</code>:</p><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/kT2ZI8Uq6ps" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div><p><em>GameDev<em>Сказ о том, как Playrix свой движок делал</em>Федор Ефтимица_Playrix</em> + <a href="https://habr.com/ru/companies/playrix/articles/467827/" target="_blank" rel="noopener">Как мы делали нашу маленькую Unity с нуля</a></p><p><em>дисклеймер: тут не про то, что что-то плохо или неправильно, цифры из видео для того, чтобы оценивать сроки. их кейс не отличительный, а типовой. За точность цифр тут не ручаюсь, считал с доклада и википедии “на глаз”</em></p><p>Интересно, что признаки фаз вот прямо из лекции Руслана, хрестоматийно.</p><p><code>2007-2018</code> - фаза 1. Есть 5 игр (Fishdom по википедии шипнулся в 2008, скорее всего надо брать еще несколько месяцев на разработку, плюс портирование, +/- год не особо важно).<br>Ключевые признаки — vfx программируются по видео от художников, рендер из набора функций thin-wrapper над opengl, ui делают программеры (“хаос и анархия”), в 2 проектах свои кастомные gui, 3 - прикручена lua.<br>На небольшом фреймворке можно штамповать относительно простые игры программистами. Новая казуальная аудитория, mobile+social, которая играет по чуть-чуть, но регулярно. Игры в сторах и до сих пор. 10 лет апдейтов, полёт нормальный.<br><code>2018</code> - фаза 2. Попытка попробовать навести порядок. Не на 10-летней кодовой базе! На небольшом Wildscapes. Предположу, что к тому моменту форкнутом от какой-нибудь игры на продакшене, и немного зачищенной.<br>Характерные шаги:</p><ul><li>scene graph+компоненты</li><li>создан слой, за которым спрятано прямое общение с 3rdParty библиотеками, вроде работы с xml </li><li>выброс тонн ручного кода заменённого на примитивный кодоген</li><li>попытки точечно использовать в другом проекте</li><li>первый непрограммист, vfx-художник может сделать эффекты<br>Итог - 8 месяцев с несколькими программистами.</li></ul><p>Первые признаки фазы 3:</p><ul><li>попробовали точечно отдать другому проекту (framework)</li><li>столкнулись с тем, что наколенным инструментам требуется инфраструктура, набросанный за 3 дня кодоген на python требует поддержки в виде отслеживания системой сборки актуальности и оптимизаций</li></ul><p><code>2019-2021 (3.5 года на момент доклада)</code> - фаза 3.</p><ul><li>система ui, вынос полностью из С++ в метаинформацию и внешние редакторы. Тадам, первая попытка помахать ручкой C++</li><li>вложенные префабы, проблемы консистентности, настройка реакции на события в тулзах</li><li>поддержка версионности, система миграции чисто в тулзах</li><li>зарождаются специальности “верстальщик интерфейса”</li><li>потребовались тесты, тестировщик и CI</li><li>хочется попробовать “а что мы еще можем сделать на этом”. Граф состояний, node editor, импорт анимаций из flash (ещё один момент прямо из лекции Руслана 2006 года)</li><li>хочется “как бы unreal blueprint, но простой” (не просто так хочется, а есть желание писать сценарии сложной анимации управляемой логикой игры). Первый признак 4-й фазы</li><li>появляется специализация “технический писатель”, доки и видео</li><li>пайплайн ресурсов</li><li>сбор хотелок хотелок пользователей</li><li>game library, ещё один слой</li><li>10 программистов, 5 qa, тех. писатель, продюсер-аналитик<br>В презентации по срокам упоминается принцип Паретто, 80% делается за 20% времени, оставшиеся 20% за 80%. Если он там не для красоты, можно прикинуть длительность фазы ~4 года.</li></ul><p>Презентация заканчивается, но попробуйте догадаться, что будет дальше. <a href="https://habr.com/ru/companies/playrix/articles/595385/" target="_blank" rel="noopener">Движок VSO: причиняем добро сценаристам</a> и <a href="https://habr.com/ru/companies/playrix/articles/589399/" target="_blank" rel="noopener">Как устроена система игровых событий в проектах Playrix</a> — тадам.<br><code>2022-?</code> - фаза 4, проигрыватель и отладчик сценариев, сценаристы без программистов собирают логику.</p><p>Получается примерно так:<br>фаза 1 - ~10 лет до осознания “так дальше жить нельзя”<br>фаза 2 - ~1 год (может варьироваться в зависимости от уровня фарша в коде, год говорит о том, что состояние было очень неплохим) (под очень неплохим я подразумеваю “очень хорошим”)<br>фаза 3 - ~4 года (тут есть один неуточнённый в докладе момент. Новые игры пишутся на новом сделанном фреймворке, но нет слайда, который показывал бы, какое-то относительное соотношение, насколько те самые 5 первых проектов, которые делались 10 лет, перешли на новый фреймворк и “очистились”)<br>фаза 4 - пока не наболит иметь свой текстовый язык?</p><p>Можно попробовать предположить также динамику: следом за попыткой сделать на визуальном языке всю игру захочется производительности. Т.е. оптимизации исполнения визуальных скриптов. А также научиться лучше управлять схемой данных в игре, зная декларативное описание (тут скорее всего придётся отказываться от решения кодогенить на python вместо clang-а).</p><p>Точность совпадения анамнеза 2006 и 2021 года впечатляет (ребята из Playrix и aruslan вроде не пересекались в одних компаниях, просто держали курс в сторону Unity/Unreal). Такой вот повторившийся через 15 лет узор.<br>В других компаниях пост-2007 встречаются похожие трансформации. Дизайнерские решения не произвольны, а диктуются внешними силами.</p><p>Т.е. даже если компании лет 15-20, всё равно можно встретить “стадию перехода”, занимающую лет 5. Вероятно, похожим путём, потому что есть флагманы и этот путь проверен. Могут, конечно, быть отличные архитектуры, в которых всё повернуто на 90 градусов или вообще сделано задом наперед, но для этого проектировщик должен был понимать, почему, как и зачем он это делает.</p><h2 id="Имперсонификация-и-поиск-паттернов-вокруг"><a href="#Имперсонификация-и-поиск-паттернов-вокруг" class="headerlink" title="Имперсонификация и поиск паттернов вокруг"></a>Имперсонификация и поиск паттернов вокруг</h2><p>Интересная цитата из доклада Playrix — “самое сложное, изучить готовые решения и подходы в целом” насчёт сериализации. Это тоже характерно. Дизайнер постоянно находится в ситуации существования внешних сил:</p><ul><li>нужно поддерживать тонну легаси yolo-кода</li><li>одновременно попытаться предугадать, как будут пользоваться твоим кодом</li><li>предвидеть, как переезжать со старого кода на новый (если слишком сложно, но вероятно и не будут)</li><li>готовых решений и подходов много и так, даже чтобы просто их изучить</li><li>вдобавок нужно хотя бы попробовать представлять дальнодействующие последствия</li></ul><p>Выглядит страшно? Так и есть, нормально мониторить существующие решения в геймдеве сложно, и делать это систематически могут позволить себе только очень крупные студии, вроде <a href="https://habr.com/ru/articles/770244/" target="_blank" rel="noopener">EA</a>. Кроме опыта и интуиции, можно воспользоваться таким методом:</p><blockquote><p>здесь важны следующие дзен-моменты в архитекторе.<br>имперсонификация.<br>каждый ваш пук должен сопровождаться мыслями “я пукнул”, “пук - это я”, “я чувствую запах”.<br>то есть любая ассоциация - это и участники, и сама ассоциация, - и вы должны почувствовать это как человек.<br>“я послал сообщение рендеру”, “я и есть сообщение рендеру”, “меня преобразовали в”, “я получил какое-то странное сообщение”  “я ошибка ДНК”<br>имперсонификация - очень важный приём, который позволяет вам отождествить себя со всеми элементами системы.<br>смысл - почувствовать себя в шкуре другого программиста.  в реальной жизни к вам этот другой программист потом обязательно придёт и популярно отождествит в любом случае.учитесь работать с инструментом художников, смотрите, как работает, геймдизайнер. это совсем другая область. много ошибок делается просто потому, что люди не понимают, что художник не рисует сразу правильным цветом, грубо говоря. он раз пять пройдётся разными цветами, смешивая их друг с другом.<br>в общем, не забывайте о людях.</p></blockquote><ul><li><a href="/blog/3299387993/" title="Геймдизайн, заметки">Геймдизайн, заметки</a> - главный друг архитектора-дизайнера это гейм-дизайнер</li></ul><p>Ещё одна техника</p><blockquote><p>“посмотри вокруг” - базовая техника архитектора.  Паттерны - везде. объяснять, думаю, не надо. Посмотрите, как работает бизнес. Везде одно и то же. Половина паттернов пришла из жизни. Здесь важно понимать, что архитектор, не пишущий код, не может быть архитектором. С другой стороны, основное количество кода и его поддержкой будут заниматься другие люди. Поэтому чем чётче вы выражаете мысли - тем лучше. В идеале - вы должны назубок знать паттерны, чтобы помогать человеку в реализации.</p></blockquote><p>Или так:</p><blockquote><p>Необходимо чувство a’la музыкальный слух. Чтобы стукнуть камертоном по концепции - и слышать. Отзовется она нежным звонким звуком или станет надтреснуто дребезжать.</p></blockquote><h2 id="Переход-к-data-driven-неизбежен"><a href="#Переход-к-data-driven-неизбежен" class="headerlink" title="Переход к data-driven неизбежен?"></a>Переход к data-driven неизбежен?</h2><p>Совершенно нет. Для маленьких команд, с преобладанием программистов, он вреден, потому что смысл data-driven — введение новых специальностей, типично не программерских. И стоимость перехода можно оценить. Программисты это data-driven долго и много будут поддерживать. Окупить это можно только ценой масштаба. Кроме того, в отличие от 2006, сейчас проще пробовать взять Unity/Unreal/Godot и использовать его хоть как data-driven, хоть в yolo-стиле, устроить кашу в них не проблема.<br><a href="https://habr.com/ru/articles/792060/" target="_blank" rel="noopener">7 причин некачественного кода в Unity-проектах</a> — почему так (хех, в первом абзаце статьи, всё те же 10 лет опыта, чтобы начать замечать)</p><p>Специалисты и состав команды варьируются от того, как делались/делаются игры. Чтобы посмотреть на это, нужен ещё один нырок в историю.</p><h2 id="Как-работает-игровая-студия"><a href="#Как-работает-игровая-студия" class="headerlink" title="Как работает игровая студия"></a>Как работает игровая студия</h2><p>Всего 3 важных важных вопроса — <strong>где брать деньги на разработку/как делается игра/как игра приносит доход</strong></p><p><strong><code>Где брать деньги</code></strong><br><a href="https://www.youtube.com/watch?v=O1zP6yJjc1o&amp;t=1193s" target="_blank" rel="noopener">Game Studio Leadership: You Can Do It</a> - 4 варианта от Джесси Шелла</p><ul><li>Собственные деньги. Вложить в первую игру, на часть заработанных с первой сделать вторую, повторить. Если вы достаточно богаты для старта, это лучший вариант.</li><li>Работа по найму. Команда делает игру на заказ для кого-то. Может сочетаться с другими вариантами (сделали игру на заказ, на полученные деньги делаем свою).</li><li>Издатель. При этом чаще всего небольшая часть денег всё равно должна вкладываться самим разработчиком (сделать прототип, чтобы показать). Распределение доходов зависит от договора с издателем (“вас ждёт рестлинг-битва с издателем, чтобы определить, кто и сколько может забрать”).</li><li>Инвестор. Часть студии тоже становится не вашей, а инвесторов. Рестлинг происходит не вокруг доходов, а вокруг того, какая часть студии кому принадлежит. Инвесторы часто не из мира игр, и видят не игру, а платформу для заработка денег.</li></ul><p><em>Если вам неинтересно эти заниматься, возможно, вам не стоит делать игры. Ну или удобно иметь брата, который будет вам помогать, как у Уолта Диснея</em></p><p><a href="https://kunaifusu.livejournal.com/376795.html" target="_blank" rel="noopener">Куда пойдет индустрия</a> + <a href="https://kunaifusu.livejournal.com/468179.html" target="_blank" rel="noopener">Индустрия во мгле (тм)</a> - 2010-2012 годы. Про аналогии из кино, студии (издатели) сначала владели павильонами, а потом стали заниматься инвестициями в продакшен — нанимать команды актёров и режиссёров.</p><p><em>Если посмотреть в кредиты, то там после студии-мажора будет какой-нибудь Six Over Five или Crazy Dildo Lawyer или подобное одноразовое название, это на самом деле корпорация, которая по документам нанимала актеров, платила аренду, билы за электречиестов и все-все-все, а по завершении проекта уволила всех актеров, сдала все офисные причиндалы назад в рентовку, откуда их брала и мирно испустила дух.</em></p><p>Ни один из 4х вариантов не доминирует. Сначала студия может делать маленькие игры и издавать сама (ну как сама, владельца платформы можно считать <del>незаметным слоном</del> издателем), потом делать игры для издателя, потом сама становиться издателем (забавно смотрятся в этой фазе “инди-издатели”), который потом захочет найти инвесторов. Паблишеры или владельцы платформы стремятся иметь свои команды и их контроллировать. Издатели разрастаются до гигантских размеров. Разработчики ищут новые способы делать игры без денег.</p><p>Рестлинг с издателем заключается в том, что издатель рисует себе невероятные расходы, чтобы не платить часть доходов от игры разработчику, разработчики в ответ рисуют себе невероятные расходы на производство игры, чтобы получить больше денег от издателя. Платформодержатель рисует себе расходы на то, чтобы брать от разработчика 30% с каждой продажи.</p><p><strong><code>Как делается игра</code></strong></p><ul><li>“Берётся и делается”. Самый ранний этап. Программист/геймдизайнер (<a href="https://en.wikipedia.org/wiki/Nasir_Gebelli" target="_blank" rel="noopener">иногда в одном лице</a>) играется с игрой, как с комком глины, пока не вылепит что-то интересное.</li><li>Каскадная модель. Когда сложность игр выросла настолько, что первый метод перестал работать, команды стали пробовать известные методы разработки ПО. Этот пришёл в начале 2000х — сначала изучаем рынок, потом проектируем, после утверждения по этому плану делаем игру, тестируем и выпускаем. На названия этапов повлияла киноиндустрия: препродакш (пишем детальный гейм-дизайн документ)-&gt;продакшн-&gt;постпродакшн(тестирование и исправление ошибок).</li><li>Гибкая разработка. Сидеть и делать игру по детальному плану год-полтора оказалось не самой хорошей идеей, стали пробовать методы, которые позволяют получить обратную связь от целевой аудитории. Дергаются всякие элементы lean/agile/scrum, пробуются сбор статистики от игроков на всех этапах (Rovio одни из первых суперуспешных), ранние доступы, софт-ланчи, гринлайты, краудфандинги и другие методы работы с сообществом игроков. Становится важна скорость итераций при разработке, а также после выхода игры (оперирование). <a href="/blog/2486671624/" title="Метод Lean Startup">Метод Lean Startup</a> - применение в геймдеве. Период перехода — поздние 2000-е.</li></ul><p><strong><code>Как игра приносит доход</code></strong><br>Картинки из книги Джесси Шелла “Геймдизайн. Как создать игру, в которую будут играть все”</p><ul><li>Продажи на носителях<br><img src="/blog/2721099263/cash1_small.png" alt=""><br>Без носителей проще. Плата за скачивание распределяется между разработчиком/издателем и владельцем маркета автоматически</li></ul><ul><li>Free-to-play<br><img src="/blog/2721099263/cash2_small.png" alt=""><br>Это то, что знают, видят и “любят” игроки, особых пояснений не требуется. Средний LTV - сколько всего потратит игрок, пока не уйдёт. Ключевое слово “средняя”. Можно привлекать за деньги много игроков, которые ничего не купят в игре, главное чтобы небольшое число тратящих игроков в сумме покрывали расходы. Покупатели помимо того, что “заносят денег жадным разработчикам”, оплачивают возможность играть бесплатно всем (покрывают расходы разработчика на поддержку игры, аренду серверов и привлечение новых игроков). С большим количеством фанатов получается хорошо.<br><a href="https://app2top.ru/news/pervaya-platnaya-loshad-v-world-of-warcraft-za-15-zarabotala-bol-she-chem-starcraft-ii-wings-of-liberty-212554.html" target="_blank" rel="noopener">Первая платная лошадь в World of Warcraft за $15 заработала больше, чем StarCraft II: Wings of Liberty</a></li></ul><h2 id="Переходы-программистов-между-компаниями-разных-уровней"><a href="#Переходы-программистов-между-компаниями-разных-уровней" class="headerlink" title="Переходы программистов между компаниями разных уровней"></a>Переходы программистов между компаниями разных уровней</h2><p><strong><code>Downgrade case</code></strong></p><p>Если вы работали в компании, которая находится на 3-4 стадиях, а при смене работы карма закинет встретить стадию 1-2, то есть два варианта. Либо компании переход выше особо и не нужен, и вам там будет грустно “программировать json-ки”, либо получите возможность стать дизайнером и архитектором. По статье можно прикинуть стоимость этого.</p><p><strong>Желательно иметь лет 10 опыта, и быть готовым заниматься процессом перехода еще около 5</strong></p><p>Если кто-то обещает меньше, то скорее всего ошибается. Ну или вы увидите “универсальный движок” в котором будет всё настолько универально, что писать код придётся вам, а не разработчику движка. Привет тем, кто хочет “перейти с Unreal/Unity на движок XXX, потому что Unreal/Unity стал слишком сложным и запутанным, а XXX проще, классный, быстро развивается и на нём уже <em>почти</em> можно сделать то же самое”.</p><p>Кроме этого, иногда возникает такой незапланированный момент, что специалистов, которые вам оказываются нужны, нет на рынке (или в природе). Например, потребовался технический артист на кастомный движок. Большинство из них не хочет работать с чем-то, отличным от Unity/Unreal. Его найти невозможно, но возможно заместить комбинацией скриптов, и part-time аниматора и программиста.</p><p><strong><code>Upgrade case</code></strong></p><p>Если вы наоборот, окажетесь после компании фазы 1-2 в компании фазы 3-4, то скорее всего, сначала будете переучиваться с stl на местные контейнеры/указатели/аллокаторы/алгоритмы, запоминать названия подсистем и wrapper-ов, разбираться с системами сборки, скриптов, тулзами и вообще вникать в то, как странный код на странном языке генерит что-то исполняемое виртуальной машиной, которое нужно отлаживать. Вообщем, менять майндсет и забывать большинство С++-“common-wises”. Хорошо, если при этом где-то в процессе проектирования уже дошли до стадии “нам нужен технический писатель”. Чаще бывает, что код сам себе документация, ну или можно найти дизайнера и спросить у него, что происходит (<code>настоящий дзен-архитектор заранее знает, когда вы к нему придёте, и что именно спросите</code>). Но неизбежно, изучать нужно будет много. С одной стороны, если знаешь внутренности одного движка, то знаешь приблизительно что увидишь и в других. С другой, всегда будут <em>особенности</em>.</p><ul><li><a href="/blog/1160101424/" title="Как разобраться в большой кодовой базе">Как разобраться в большой кодовой базе</a> - учиться разбираться в большой кодовой базе, это тоже скилл</li></ul><blockquote><p>Нужно смириться с тем, что большие кодовые базы:<br>содежат много legacy кода<br>плохо документированы<br>содержат места, про которые никто не знает как/зачем/почему они были добавлены<br>(но большая часть кода всё же была добавлена с определенной целью, и выбросить/переделать - часто плохая идея)<br>Если что-то выглядит странно/непонятно/неправильно:<br>30% что есть причина (неочевидная) почему сделано так<br>30% что когда-то БЫЛА причина<br>30% что причины нет, и код просто кривой<br>10% что Ктулху Рльех Фтагн</p></blockquote><p>(это вольно переведённая мной инструкция из доклада Unity Training Academy, от одного из ведущих разработчиков Unity, с in-house движками 40% что ситуация такая же, 40% что хуже, 20% что Ктулху Рльех Фтагн)</p><p>Если в компании налажен процесс онбоардинга, то джун/мидл учиться пользоваться всем за 3-6 месяцев, если его тупо бросают и ждут, пока поплывёт — раза в 2 дольше.</p><p>Большой минус inhouse-движков, с ними сложно познакомиться заранее. Вы не можете прочитать книгу, поиграться дома с примерами, пройти курс или найти ответ на форумах. Достаточно быстро нужно будет начинать выполнять задачи. Собственно, задачи будут всегда. Учиться на закрытом движке достаточно сложно.</p><p>Для компании (и дизайнера) выбор между in-house движком или готовым — это дизайнерское решение по шкале (<a href="http://ithare.com/chapter-iv-diy-vs-re-use-in-search-of-balance/" target="_blank" rel="noopener">DIY vs Re-Use: In Search of Balance from upcoming book “Design&amp;Development of MMOG”</a> — критерии выбора для MMOG-игры).</p><p>Для изучения же сильно проще готовый. Просто, случайные примеры документации для Unreal, которыми приходилось пользоваться:</p><ul><li>миллионы начальных курсов и обзоров разного уровня качества. Среднего качества, но доступная, хоть и запутанная, официальная документация.</li><li><a href="https://courses.tomlooman.com/courses/enrolled/1320807" target="_blank" rel="noopener">Tom Looman Unreal Course</a> — платный продвинутый курс advanced.</li><li><a href="https://nikoladimitroff.github.io/Game-Engine-Architecture/" target="_blank" rel="noopener">Game Engine Architecture Lectures</a> — средний уровень с английскими слайдами и лекциями на болгарском</li><li><a href="https://awforsythe.com/unreal/blueprints_vs_cpp/#perf_comparison" target="_blank" rel="noopener">Alex Forsythe Performance: Comparing Compiled C++ and BP</a> - разбор виртуальной машины blueprint</li><li><a href="https://benui.ca/unreal/" target="_blank" rel="noopener">Unreal Engine Tutorials, tips and tricks</a> - различные материалы, упор на систему gui<br>и т.п. — разных уровней (от начального до мега-продвинутых) и специализации (программисту, артисту, гейм-дизайнеру), и от людей со всего мира.</li></ul><h2 id="GameObject-на-каждой-из-фаз-“кто-какой-что-делает”"><a href="#GameObject-на-каждой-из-фаз-“кто-какой-что-делает”" class="headerlink" title="GameObject на каждой из фаз, “кто/какой/что делает”"></a>GameObject на каждой из фаз, “кто/какой/что делает”</h2><p><em>Говорят, японские самураи могли оценить мастерство друг друга сразу по тому, как самурай держал самурайскую саблю</em></p><p>Ещё раз вернёмся к фазам. Как приблизительно выглядит игровой объект, пусть будет, например, элитный враг в RPG, гоблин-вожак (а то надоели танки и самолёты), на разных фазах, с точки зрения программиста.<br>Мысли могут повторяться, потому что выше был в основном пересказ описания архитектуры aruslan-а, теперь от меня.</p><p><code>Фаза 1</code><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GoblinLeader</span> :</span> Goblin &#123;</span><br><span class="line">  <span class="comment">//настройка параметров</span></span><br><span class="line">  <span class="comment">//описание уникального поведения</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//иерархия классов может быть типа такой GoblinLeader-&gt;Goblin-&gt;Enemy-&gt;AiObject-&gt;MoveableObject-&gt;GameObject</span></span><br><span class="line"><span class="comment">// ну или убрали diamond problem, создали интерфейсы</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GoblinLeader</span> :</span> GameObject, IEnemy, IMoveable, IBoss &#123;</span><br><span class="line">  <span class="comment">//тут всё так же</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Программист знает о вожаке-гоблинов всё:</p><ul><li>кто (существительные, построение зашито в наследовании)</li><li>какой (значения параметров) </li><li>что делает (глаголы, код поведения)</li></ul><blockquote><p>Со свиньями, кстати, был связан еще один серьезный баг, из-за которого падала игра. В какой-то момент программисты что-то такое подкрутили, и свиньи перестали быть нейтральными — принадлежали кому-то из игроков. Управлять ими было нельзя, но формально они могли быть «наши» и «не наши». Так вот, свиньи приводили к вылету игры. А все потому, что, видя «неприятеля», патриотически настроенная поросятина немедленно хотела дать врагу отпор и лезла за оружием, которого у нее, естественно, не было. Если мне не изменяет память, программисты исправили баг, просто выдав свинье парабеллум без патронов.<br><a href="https://www.igromania.ru/article/14805/A_delo_bylo_tak_Kak_na_samom_dele_razrabatyvayutsya_igry.html" target="_blank" rel="noopener">“Блицкриг 2”</a></p></blockquote><p>“Кто” и “что делает” смешались (классы = данные + код). Вероятно, свиньи отнаследовались от Unit, в который были вшиты IsEnemy и WeaponPointer.<br><a href="https://plakhov.livejournal.com/235446.html" target="_blank" rel="noopener">CThingy-&gt;CFlingy-&gt;CDoodad-&gt;CUnit из Starcraft</a></p><p><code>Фаза 2</code><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GoblinLeader</span> :</span> GameObject &#123;</span><br><span class="line">  <span class="comment">//создание компонентов EnemyComponent, MoveableComponent, BossComponent</span></span><br><span class="line">  <span class="comment">//(динамически или статически - пришито темплейтными параметрами)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// + настройка, возможно чтением из файла</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameObject</span> &#123;</span> TArray&lt;Component&gt; components; ... &#125;</span><br></pre></td></tr></table></figure></p><p>Из такого описания по сравнению с первым программист теряет часть знаний:</p><ul><li>чуть сложнее узнать “кто”. Компоненты могут быть добавлены динамически, в зависимости от файла настроек, но всё ещё можно посмотреть код чтения файла настроек</li><li>зато всё еще легко понять, “что делает” (максимум геймдизайнер может отключить через настройки компонент, изменив поведение, например отключение BossComponent может изменить стратегию преследования игрока)</li><li>непонятно “какой” (теперь гейм-дизайнер решает, 100 или 500 жизней будет у босса, может изменить ему цвет одежды или способности)</li></ul><p><a href="http://thegamedesignforum.com/features/GDH_4.html" target="_blank" rel="noopener">Part 4: The Set Piece Period</a> — заметка про <code>Set Piece Game Design</code>, направление гейм-дизайна, возникшее в ранних там же ~2000х. Про то, что большая часть работы гейм-дизайнера в некоторых играх стала сводиться к настройке параметров. В отличие от идеи “шедевры создаются на основе глаголов” (из книги New Game Design Satoshi Tajiri, создателя покемонов), тут происходит смещение на прилагательные, гейм-дизайнер настраивает игру, выбирая “каких” и “сколько” врагов встретит игрок. Сколько свободы есть у гейм-дизайнеров, так они и будут работать. К этой идее надо вернуться в разделе “Визуальное программирование VS текстовые скриптовые языки”.</p><p><code>Фаза 3</code><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//класса GoblinLeader нет, создание из внешнего файла</span></span><br><span class="line">GamePtr&lt;GameObject&gt; goblinLeader = CreateGameObject(<span class="string">"GoblinLeader"</span>);</span><br><span class="line">...</span><br><span class="line"><span class="comment">//файл с описаниями классов</span></span><br><span class="line">&#123; <span class="string">"GoblinLeader"</span>: &#123;</span><br><span class="line">  <span class="string">"EnemyComponent"</span>: &#123;...&#125;,</span><br><span class="line">  <span class="string">"MoveableComponent"</span>: &#123;...&#125;,</span><br><span class="line">  <span class="string">"BossComponent"</span>: &#123;...&#125;</span><br><span class="line">&#125;&#125;</span><br><span class="line">^----в файл настроек переползли не только константы, но и описание процесса сборки класса</span><br></pre></td></tr></table></figure></p><ul><li>программист не знает “кто” перед ним. Гоблина-вожака нет в коде. Есть части. Для кода обработки отрисовки гоблин-вожак ничем не отличается от камня (если гейм-дизайнер добавляет им меши), для кода обработки поведения — отличается. Про конкретные объекты на уровне теперь знает гейм-дизайнер, но может вообще не знать программист. Гейм-дизайнер может исправить подобные истории про свиней ошибки логики без программиста, и быстрее него (если для этого всё ещё нужно привлекать программиста, что-то просто не доделано в тулзах отладки или визуализации).</li><li>программист знает только, что делают отдельные части. Гейм-дизайнер может собрать из компонентов объекты, которые не задумывал программист. Характерный признак приближения к этой фазе, когда программист знает все отдельные компоненты, но смотрит на что-то в игре и не понимает, как гейм-дизайнерам вообще удалось это собрать.</li><li>“какой” уже описывается не просто числами, а представляется визуально. Например, визуальный редактор кривых, в котором можно задать и посмотреть изменения переменной в динамике (например, для описания сложной формулы разбега и остановки гоблина). Под капот в идеале больше не заглядывают.</li></ul><p>На этой фазе важный момент — <code>у программиста нет понимания &quot;кто&quot;</code>. Потому что больше “тип игрового объекта == C++ класс”. Если нет никакого класса GoblinLeader, то что тогда в самом примитивном виде есть со стороны C++? Просто отображение пар “ключ-значение” <code>engine::map&lt;engine::string, engine::anyWrapper&gt;</code>? Как-то так и может выглядеть объект на lua-подобном языке с точки зрения C++. </p><p><strong><code>Это конец объектного дизайна и начало дизайна данных</code></strong>. Чтобы улучшать это представление дальше, нужно думать не в терминах объектов, а в терминах данных.</p><p>На каком языке и как их описывать, и как связать это описать с представлением на C++ (<strong><code>встраивать ли в C++ теги VS отдельный язык описания</code></strong>), как хранить мета-данные, нужные тулзам, но не нужные игре. Как в игре делать десериализацию из различных форматов? Если до этого вопросом дизайна было “как представить данные классами C++” (как удобно программистам), то теперь “как представить данные ЧЕМ-ТО, чтобы было удобно всем” (и гейм-дизайнерам, и программистам).</p><blockquote><p>Три категории программистов<br>Не умеешь играть ровно.<br>Умеешь играть ровно.<br>Умеешь играть неровно.</p></blockquote><p>Вот тут возникает необходимость начать “играть неровно”.</p><p><a href="https://www.youtube.com/watch?v=VAT9E-M-PoE" target="_blank" rel="noopener">Pitfalls of Object Oriented Programming, Revisited - Tony Albrecht</a> — переключение фокуса на то, как представлять данные даёт возможность разбиения целого на части. Это удобно не только для уменьшения coupling и увеличения свободы гейм-дизайнера, но и потому, что даёт возможность выбрать различные способы хранения в частей в памяти, что позволяет существенно улучшить производительность. Первая версия доклада — 2009 год.</p><p><code>Фаза 4</code><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ScriptEngine::ExecuteScript(<span class="string">"GoblinLeader"</span>);</span><br><span class="line"><span class="comment">//"GoblinLeader" -- файл, в котором описана сущность GoblinLeader, параметры и логика поведения</span></span><br></pre></td></tr></table></figure></p><p>На предыдущем шаге программист знает только о том, как работают части (его задача делать их и отдавать гейм-дизайнерам).</p><p>Финальный шаг — давайте дадим гейм-дизайнерам возможность создавать части самостоятельно, без программистов.</p><ul><li>программист знает только о существовании некоторых “частей”, и что гейм-дизайнеры могут не только настраивать их, но и создавать свои.</li><li>то же самое происходит с “что делают” части. Сложно сделать полноценную часть, только комбинируя готовые, необходимо описывать поведение. Программисты могут специально спрятать некоторые неважные геймдизайнеру вещи (навряд ли для игровой логики необходимо опускаться на уровень способов аллокации и освобождения памяти), но чем больше возможностей описания логики он отдаёт гейм-дизайнеру, тем лучше.</li></ul><p>Вопрос, что доступно гейм-дизайнеру, а что могут делать только программисты, решает дизайнер, учитывая состав команды и жанр (<strong><code>&quot;системный язык VS язык логики игры&quot;</code></strong>)</p><p>Как выяснили еще 20 лет назад, типично программисты хотят скрипты, что программировать (желательно, чтобы уметь хорошо то же, что и C++, и то, чего он не умеет тоже), а гейм-дизайнеры — окошки, ползунки и визуальное программирование.</p><blockquote><p>Программисты делают НЕправильные скриптосистемы. Они ориентируют её на программистов, в результате только программисты и могут её использовать. Скрипты делаются для упрощения и удешевления продукта и для удешевления и оптимизации процесса создания/модификации контента.</p></blockquote><p><a href="https://plakhov.livejournal.com/101443.html" target="_blank" rel="noopener">Дзен-3, скрипт</a> — про то, почему такой подход лучше, чем “прикрутили lua, и посылаем на неё гейм-дизайнеров, если что-то хотят”.<br>“Скрипт в такой системе ест памяти и процессорного времени заведомо не больше, чем O большое от времени, потраченного на его изготовление”<br>Это одновременно и хорошо, и плохо.</p><p>Способ, который годится, если мы уверены, что делаем “конструктор игр в жанре XXX” — выдать гейм-дизайнерам набор строительных блоков, например “события/условия/действия”.<br><img src="/blog/2721099263/war3_small.png" alt=""><br>Ещё не блюпринты, но уже возможность собирать кастомные карты в Варкрафте (вообще триггеры в Blizzard вроде с первого старкратфа)</p><ul><li>Переделать представления из “дерево с панельками”, как на скриншоте, на граф — достаточно дешёво и просто (2-3 недели, если в дзене)</li><li>Сшить с редактором, чтобы выбирать не комбо-боксом, а “пипеткой” — легко</li><li>Просимулировать выполнение триггеров различными способами — относительно легко. Например, оценить производительность сразу из редактора, пример из доклада “Самая парадная фича: я сделал в редакторе “раскраску” скриптовых юнитов и зон в разные цвета, и выделял те триггеры, которые на них ссылались, пометками того же цвета”</li><li>Верифицировать типичные ошибки (“герой Снайпер, упомянутый в условии триггера СекретныйЯщик, не может появиться на этой миссии”) — легко</li></ul><p>Важно то, что гейм-дизайнеры и программисты не находятся в разных мирах. Гейм-дизайнеры постоянно хотят больше возможностей (часть из которых нужно отбрасывать, а часть нужно реализовывать, даже если они вообще не вписываются в стройную и красивую задуманную систему). Программисты должны следить за тем, что делают гейм-дизайнеры, потому что:</p><ul><li>У гейм-дизайнеров в организации логики будет бардак, они не читали книг про паттерны, рефакторинг и чистый код (не потому что они глупые, а потому что им в своей дисциплине и так есть что изучать, их задача не красивый код, а фан от игры). См. раздел “Дизайнеры” в <a href="https://habr.com/ru/articles/774972/" target="_blank" rel="noopener">Вы точно хотите пойти программистом в gamedev?</a> или в <code>Дзен-3</code>.</li><li>Даже в примитивных системах скриптов возможны баги, с которыми гейм-дизайнеры не разберутся сами. То, как скриптовые функции работают в игре, и то, как гейм-дизайнеры это себе представляют - две большие разницы Особенно, если у вас есть что-нибудь типа “Execute parallel actions”</li></ul><p><strong>Периодически неизбежно код со скриптов нужно переносить обратно на C++, если задуманное гейм-дизайнерами не решается или решается <a href="https://blueprintsfromhell.tumblr.com/" target="_blank" rel="noopener">адскими способами</a></strong><br>Это то, что ненавидят делать все программисты.</p><h2 id="Скорость-итераций"><a href="#Скорость-итераций" class="headerlink" title="Скорость итераций"></a>Скорость итераций</h2><ul><li><a href="/blog/1687824628/" title="Паттерны организации разработки уровней игр">Паттерны организации разработки уровней игр</a> — паттерны левел-дизайнеров, большая часть возникает, когда можно прототипировать уже не только геометрию уровня, но и механики<br>В частности:</li><li><a href="https://www.gdcvault.com/play/1012473/Prototyping-Based-Design-A-Better" target="_blank" rel="noopener">Prototyping Based Design: A Better, Faster Way to Design Your Game</a> — Lee Perry, гейм-дизайнер Gears of War, рассказывает о том, как меняется процесс прототипирования с Unreal Engine 3 (с помощью скриптов на Kismet, можно представить эту его версию как “конструктор шутеров”), который можно отнести к фазе 4.</li></ul><p>Было:</p><ul><li>Дизайн в голове</li><li><del>Документирование</del></li><li><del>Дебаты с обсуждением идеи</del></li><li><del>Сбор команды прототипирования</del></li><li><del>Наигрывание и тюнинг, пока не станет интересно</del></li><li>Ревью перед отправкой в продакшн<br>Стало:</li><li>Дизайн в голове</li><li><strong>Сделать прототип</strong></li><li>Ревью перед отправкой в продакшн</li><li><strong>Задокументировать находки</strong></li></ul><p>Применяли для разработки существ, оружия, игровых механик, level one-offs (уровней или подуровней с кастомной неповторяющейся в других местах игры логикой).<br>В презентации много скриншотов с результатами, ~40% прототипов доходило до продакшена (цифра плюс-минус средняя для всех игр, но из-за того, что прототипировалось быстро, негодные идеи тоже получается выбрасывать быстро).</p><ul><li><a href="/blog/3309518526/" title="Системы поиска сокровищ">Системы поиска сокровищ</a> - если прикрутить быстрые итерации, взаимодействие с пользователями, то редактор может превратиться в “песочницу”, в которой можно прототипировать не только игры в рамках задуманного жанра, но и полностью менять механики.</li></ul><h2 id="Визуальное-программирование-VS-текстовые-скриптовые-языки"><a href="#Визуальное-программирование-VS-текстовые-скриптовые-языки" class="headerlink" title="Визуальное программирование VS текстовые скриптовые языки"></a>Визуальное программирование VS текстовые скриптовые языки</h2><p>Движок в фазе 4 — это <strong><code>&quot;конструктор игр в жанре XXX&quot;</code></strong> (в особо удачных случаях <strong><code>&quot;система поиска сокровищ&quot;</code></strong>).<br><a href="https://www.slideshare.net/GerkeMaxPreussner/gdc-europe-2014" target="_blank" rel="noopener">GDC Europe 2014: Unreal Engine 4 for Programmers - Lessons Learned &amp; Things to Come</a></p><ul><li>Движок Playrix из презентации <em>Сказ о том, как Playrix свой движок делал</em> — конструктор match-3 (может, с перспективой “конструктор казуалок”)</li><li>Unreal 3 — конструктор шутеров<br><img src="/blog/2721099263/ue_history_small.png" alt=""></li></ul><p>В ней можно находиться также, как и в первой фазе, долго. Десятки, в особо успешных случаях <a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_%D0%B8%D0%B3%D1%80_%D0%BD%D0%B0_%D0%B4%D0%B2%D0%B8%D0%B6%D0%BA%D0%B5_Unreal_Engine#Unreal_Engine_3" target="_blank" rel="noopener">сотни</a> игр.</p><p>Но бывает, что возникает желание довести движок до состояния “конструктор игр”. Условия могут различными:</p><ul><li>Сделали хорошую технологию, архитектура позволяет попробовать отслоить genre-specific кусок. Например, мультиплейерный шутер -&gt; сессионный шутер</li><li>Появился новый растущий рынок. Например, на мобилках не играют в AAA-шутеры, зато сессионные игры вполне кросс-платформенные. Ещё шире — потенциальный метаверс (со своими дизайн-требованиями, например, verse, который не про удобство гейм-дизайнеров, а про верифицируемость и надёжность).</li><li>Накопили денег, чтобы попробовать</li></ul><p>Можно назвать это <strong><code>фазой 4.5</code></strong>.</p><p><a href="https://aras-p.info/texts/files/201410-TUM-HobbyEngineToGameEngine.pdf" target="_blank" rel="noopener">Hobby engine to game engine</a> — отличия между “конструктором игр в жанре XXX” и общим “конструктор игр”</p><p>Этап “конструктор игр для жанра XXX” хорош тем, что процесс разработки становится как будто предсказуемым по срокам, по составу команды, необходимой на различных стадиях, геймдев из ремесла стал индустрией.</p><p><a href="https://sim0nsays.livejournal.com/38168.html" target="_blank" rel="noopener">Винтажный publish: Когда мы были молодыми</a> — 2004 год, логи с IRC. Действующие лица — мастодонты геймдева. Обсуждение про то, что мир геймдева переходит из фазы 4 в фазу 4.5. Пересказывать сложно, там важно настроение. Про то, что геймдев из ремесла стал индустрией. Инструменты готовы. Игры теперь делают не программисты, а продюссеры с командой гейм-дизайнеров. Программисты поддерживают инструменты или поддерживают гейм-дизайнеров. Выглядело страшно - майкрософт с XNA, Java/Idea/автоматические рефакторинги, в EA есть программисты, которые даже не знают об OpenGL/DirectX, за ними туда же очень быстро двигаются японцы и Ubisoft, магия утекает из мира.</p><p><a href="https://ironpeter.livejournal.com/2068.html" target="_blank" rel="noopener">Депрессивное постаттестационное</a>. Процесс — не про отжиг. Nival, 2006 год, в индустрии темнеет (<a href="/blog/2786387393/" title="Индустрия снова во мгле">Индустрия снова во мгле</a>).</p><p><a href="https://kunaifusu.livejournal.com/523974.html" target="_blank" rel="noopener">Инжины</a>, <a href="https://kunaifusu.livejournal.com/598964.html" target="_blank" rel="noopener">Продавцы инжинов</a> и <a href="https://kunaifusu.livejournal.com/604105.html" target="_blank" rel="noopener">Оказывается у Аутодеска тоже был свой инжин</a> — взгляд на проблему со стороны графического программиста (с сильно альтернативными взглядами на реальность, странными прогнозами, развитой фантазией, и ненавистью к геймдизайнерам, менеджерам, другим программистам и людям вообще, но с <a href="https://www.mobygames.com/person/128123/basil-milanich/credits/" target="_blank" rel="noopener">опытом</a> на консолях). В принципе, рациональные претензии можно свести к “отпилить бы движок 3d-рендера от этого вашего игрового движка, потому что требования, фичи и пайплайн рендера у игр разные, а неграфические программисты и гейм-дизайнеры всё равно заниматься рендером не умеют”.</p><p>Программисты по прежнему нужны, как игровые, так и движковые, немного магии осталось, колесо Сансары продолжает крутиться.</p><p>Но с движками общего назначения возникает вопрос. С конструкторами игр определенного жанра было примерно понятно соотношение команд, делающих эти жанры. Инструменты движка проектируются так, чтобы соответствовать пайплайну специалистов, которые нужны для производства контента в том жанре игр, для которых предназначен движок. Если же жанр может быть любым, то неизвестен состав специалистов, которые нужны для производства. Нужен мета-язык, который будет основой для создания других языков для специалистов.</p><p>Можно представить себе способ создания такого мета-языка как процесс переноса в скриптовую часть всё более низкоуровневых слоёв движка и описание следующих слоёв на этом скриптовом языке (с использованием его идиом и техник). Тогда с точки зрения неспециалистов начинает казаться, что весь движок сделан на этом языке (<em>“Unity написан на C#”</em>). Удобный способ построения универсального языка — виртуальная машина.</p><p>Для <strong>выполнения</strong> команд нужна виртуальная машина, которая умеет выполнять байт-код. Обзор вариантов дизайна того, как это происходит потянет на отдельную статью такого же размера. Возможный способы генерации байт-кода — компилятором скриптового языка, интерпретацией команд, загрузкой сериализованного представления из бинарного файла, или генерацией через API виртуальной машины.<br>Очень беглые заметки:</p><ul><li><a href="/blog/2115627465/" title="Устройство интерпретаторов lua-jit и daScript">Устройство интерпретаторов lua-jit и daScript</a></li><li><a href="/blog/1067581840/" title="daScript - скорость">daScript - скорость</a></li><li><a href="https://gamedev.ru/community/gamedev_lecture/articles/?id=4446" target="_blank" rel="noopener">Лекция #36. Обзор VM скриптовых языков (Lua, AngelScript). Часть 1</a> (и <a href="https://gamedev.ru/community/gamedev_lecture/articles/lecture36" target="_blank" rel="noopener">вторая часть</a>) - ещё один пример из прошлого, начальный обзор того, как выглядит из C++ выполнения скриптов.</li></ul><p><strong>Представление</strong> кода. Трансформации от фазы 1 к фазе 4 происходили в направлении передачи контроля над игрой геймдизайнерам. В случае с Unreal на практике (см. <code>The GDC 2003 Game Object Structure Roundtable</code> выше) произошло так, что для многих Kismet зарулил UnrealScript, что привело к появлению Blueprint как мета-языка для дизайнеров. Для геймдизайнеров это блок-схемы описания логики игры.<br>Для программиста — возможность создать свои блоки, быстро собрать что-то для отладки/прототипирования, а также настраивать связь между C++ и скриптом (вызывать скрипт из C++ или C++ из скрипта).</p><p>Независимо от представления скриптов в виде текста или графа, они компилируются в байт-коды — блюпринты транслируются в байт-код, который выполняется на той же виртуальной машине, что и текстовый UnrealScript. Байт-код также может “нативизироваться” в C++ (в мире текстовых языков — AoT-компиляция).</p><p><a href="https://github.com/GaijinEntertainment/dasflow" target="_blank" rel="noopener">Dasflow</a> — визуальное скриптование, с трансляцией в daScript.</p><p><a href="https://awforsythe.com/unreal/blueprints_vs_cpp/#bp_refactor" target="_blank" rel="noopener">Blueprints vs. C++</a> — статья с разбором вариантов разного дизайна кода между C++ и блюпринтами.</p><p>Представление, которое будет доминировать, зависит от конфигурации команды, хотя и диктуется дизайном самого движка. На Unreal можно сделать игру, написав всю логику на C++, но это будет неудобно. Соотношение скорее должно варьироваться от 80%/20% в пользу Blueprints в начале разработки, и до 60%/40% в конце (ну пока не дойдёт до плановой производительности, может и 30%/70% в пользу C++, цифры для примера, реальных замеров не искал).</p><p><em>update</em><br><a href="https://youtu.be/0YMS2wnykbc?si=8RJ_DEWidFIWmiTW&amp;t=1276" target="_blank" rel="noopener">20% Blueprints/80% C++</a> - Blueprints In-depth - Part 2. Примерные замеры из Epic. Т.е. ~60% от общего кода будет необходимо переписать, если у вас медленный скриптовый язык.</p><h2 id="Неэволюционный-путь"><a href="#Неэволюционный-путь" class="headerlink" title="Неэволюционный путь"></a>Неэволюционный путь</h2><p>Движки не всегда вырастают из игры. Движок может делаться не для того, чтобы компания зарабатавала на играх на нём, а на продажу, ну или вообще бизнес в рекламе или платформе. В качестве примера всех вариантов подходит Unity (“делаем Flash в 3d”) различных периодов. Тогда можно и сразу метить в стадию 4.5, если ресурсов хватит.<br><img src="/blog/2721099263/unity_features_small.png" alt=""><br>Фичи Unity, <a href="https://aras-p.info/texts/files/StoriesFromUnityBarCamp2.pdf" target="_blank" rel="noopener">Stories from Unity</a></p><h2 id="Связь-движка-и-игры"><a href="#Связь-движка-и-игры" class="headerlink" title="Связь движка и игры"></a>Связь движка и игры</h2><p><a href="https://nikoladimitroff.github.io/Game-Engine-Architecture/revealjs/presentation-iframe.html?lecture=01.intro.md#/14" target="_blank" rel="noopener">Connecting the tools to the engine</a></p><p><img src="/blog/2721099263/tools_to_engine_1_small.png" alt=""><br><img src="/blog/2721099263/tools_to_engine_2_small.png" alt=""><br>Первый тип чаще встречается, если в компании нет накопленного software capital — проще взять за основу тулзов QT/.NET. Альтернативные варианты — использовать другой движок только для создания на нём тулзов (Unreal/Unity/Godot), или экспериментальные вроде “делаем все тулзы в браузере”.</p><p>Второй — если хочется похожести на то, как выглядит игра и тулзы.<br>Данные во время разработки шарятся между игрой и движком через файлы, код может интерпретироваться из текста или пересобираться в библиотеки. Другой возможный канал связи — rpc, игра запускает сервер и принимает команды от тулзов.</p><p><img src="/blog/2721099263/tools_to_engine_3_small.png" alt=""><br>Более связанная система, либо редактор встроен в игру (cheats/debug gui), либо игра запускается из редактора.</p><h2 id="Про-пришивание-языков"><a href="#Про-пришивание-языков" class="headerlink" title="Про пришивание языков"></a>Про пришивание языков</h2><p>Общение между движком и скриптовой системой происходит через VM, “пришить” ещё один язык можно общаясь с этой VM через её систему рефлексии, <a href="https://github.com/insthync/awesome-unreal?tab=readme-ov-file#scripting" target="_blank" rel="noopener">примеры для Unreal</a>.</p><p>Для GUI:<br><a href="https://github.com/rdeioris/LuaMachine" target="_blank" rel="noopener">Lua</a><br><a href="https://github.com/ncsoft/Unreal.js" target="_blank" rel="noopener">Unreal.js</a> (“мы зафигачим себе движок v8, react, примитивы из three.js соберём это js-&gt;cpp и сэкспортим в веб-пример”, omg)</p><p>Для того, чтобы писать логику текстом вместо блюпринтов:<br><a href="https://github.com/EpicSkookumScript/SkookumScript-Plugin" target="_blank" rel="noopener">SkookumScript</a><br><a href="https://github.com/Hazelight/UnrealEngine-Angelscript" target="_blank" rel="noopener">Angelscript</a> (требует форкнутого похаченного движка)<br><a href="https://github.com/jmgomez/NimForUE" target="_blank" rel="noopener">NimForUE</a> (пока WiP)<br>(<em>если хотим универсальный движок, то нужен и язык для команд, которые пишут текстом</em>)</p><p><em>to be continued</em></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;Навеяно ст
      
    
    </summary>
    
    
    
      <category term="dev_method" scheme="http://spiiin.github.io/tags/dev-method/"/>
    
      <category term="dev_evolution" scheme="http://spiiin.github.io/tags/dev-evolution/"/>
    
      <category term="longread" scheme="http://spiiin.github.io/tags/longread/"/>
    
      <category term="unreal" scheme="http://spiiin.github.io/tags/unreal/"/>
    
  </entry>
  
  <entry>
    <title>Геймдизайн, заметки</title>
    <link href="http://spiiin.github.io/blog/3299387993/"/>
    <id>http://spiiin.github.io/blog/3299387993/</id>
    <published>2024-01-16T13:35:23.000Z</published>
    <updated>2024-02-25T16:40:58.258Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p><a href="/blog/3649678047/" title="Путь гейм-дизайнера">Путь гейм-дизайнера</a> — схема с книжками</p><p>Сгруппированные кусочки заметок и ссылок, не склеивающиеся пока в одну цельную. Программистские линзы для взгляда на геймдизайн и геймдизайнеров.</p><h2 id="1-История"><a href="#1-История" class="headerlink" title="1. История"></a>1. История</h2><p>Среди гейм-дизайнеров, знакомых по компаниям, в которых работал, раньше многие приходили с опытом работа в редакторах карт (Warcraft 3, CS, HoMM), сейчас — больше с опытом дизайна настолок или вообще с курсов.<br><code>Тристан Донован: Играй! История видеоигр</code> — описание ранних этапов индустрии в разных регионах и поворотных моментов.<br><code>Крис Колер: Power Up! Как Япония вдохнула в игровую индустрию новую жизнь</code> — история японских игр.<br><a href="https://www.youtube.com/watch?v=a9DlhDRZ0yA" target="_blank" rel="noopener">Shigeru Miyamoto’s 1999 GDC Keynote</a></p><p><a href="https://thegamedesignforum.com/features/GDH_1.html" target="_blank" rel="noopener">An Intro to Videogame Design History</a><br>В статье выделяется несколько этапов дизайна игр</p><ul><li>Arcade Era - усложнение за счёт регулирования 1-2 параметров</li><li>Composite Era - композитный дизайн, смешивание двух жанров (простейший пример — Марио, прыжки из платформеров, атаки из экшенов)</li><li>Set Piece Period - количественная настройка сложности (где-то от HL2), настройка волн противников<br>Более детальное описание такого разделения — в серии статей на том же сайте, про дизайн Super Mario World, HL2, Chrono Trigger.<br>Ну и сейчас, что-то типа Meta/Session Period - социальные игры, широкий доступ к статистике, условно-бесплатность, длительный цикл жизни игр, разделение на core и meta геймплей.</li></ul><p><a href="https://disgustingmen.com/podkasts/the-house-of-the-dev-season-2-john-romero/" target="_blank" rel="noopener">The House of the Dev: Джон Ромеро</a> — Ромеро рассказывает о своих кумирах, поколения перед ним.<br><a href="https://www.idlethumbs.net/designernotes" target="_blank" rel="noopener">Designer Notes</a> — на подкасте много гостей, геймдизайнеров эпохи первых Fallot и Civilization.</p><h2 id="2-Организация"><a href="#2-Организация" class="headerlink" title="2. Организация"></a>2. Организация</h2><p>Продюссерская сторона дизайна.<br><a href="https://www.youtube.com/playlist?list=PLk55LIt7jzkFjVuOW4PTXU0UX9-so3Ya8" target="_blank" rel="noopener">Продюсирование f2p мобильных игр</a> — бесплатный курс по free2play продиссированию<br>Кроме дизайна core механик существует: дизайн меты(прогрессии), финансы, маркетинг, оперирование, аналитика, работа с людьми, разработка, арт, market view, BizDev, оценка идей с точки зрения бизнеса.<br><a href="https://vas3k.club/post/20571/" target="_blank" rel="noopener">Инсайды из мира гиперкежа</a> — история появления и развития hyper-casual. В чём-то повторяет историю развития мобильных игр.</p><p>Также много чего про огранизацию можно откопать у Джесси Шелла.</p><h2 id="3-Кор-геймдизайн-механики"><a href="#3-Кор-геймдизайн-механики" class="headerlink" title="3. Кор-геймдизайн, механики"></a>3. Кор-геймдизайн, механики</h2><p>“Классический” гейм-дизайн, механики, взаимодействие различных систем, эмерджентность, прототипирование.</p><p><code>Ernest Adams, Joris Dormans : Game mechanics advanced game design</code> — использование фреймворка Machinery (для описания потоков ресурсов и более общего дизайна игровых систем)<br><code>Joris Dormans: Engineering Emergence Applied Theory for Game Design</code> — эмерджентность, и снова о Machinery<br><code>Роберт Зубек: Элементы гейм-дизайна. Как создавать игры, от которых невозможно оторваться</code><br><a href="http://aushestov.ru/%d1%88%d1%80%d0%b0%d0%b9%d0%b1%d0%b5%d1%80/" target="_blank" rel="noopener">Шрайбер - Game Design Concepts</a> — теория гейм-дизайна. MDA - механика/динамика/эстетика.</p><p>Каналы про гейм-дизайн<br><a href="https://www.youtube.com/@lutsayspeech/videos" target="_blank" rel="noopener">Луцай</a><br><a href="https://www.youtube.com/@GMTK" target="_blank" rel="noopener">Game Maker’s Toolkit</a></p><h2 id="4-Fun"><a href="#4-Fun" class="headerlink" title="4. Fun"></a>4. Fun</h2><p>Психология игрока, понимание, почему людям нравится играть и что именно входит в понятие “играть”, плейтесты</p><p>“Большая тройка”:<br><code>Тайнан Сильвестр: Геймдизайн. Рецепты успеха лучших компьютерных игр от Super Mario и Doom до Assassin&#39;s Creed и дальше</code><br><code>Джесси Шелл: Геймдизайн: Как создать игру, в которую будут играть все</code><br><code>Raph Koster: Theory of Fun for Game Design</code></p><p><a href="https://stradarium.ru/gaming" target="_blank" rel="noopener">Николай Дыбовский: Человек играющий: шесть причин потратить время просто так</a> — хороший разбор базовых понятий игр<br><a href="http://aushestov.ru/%d1%83-%d0%bc%d0%b5%d0%bd%d1%8f-%d0%bd%d0%b5-%d1%85%d0%b2%d0%b0%d1%82%d0%b0%d0%b5%d1%82-%d1%81%d0%bb%d0%be%d0%b2-%d1%8f-%d0%b4%d0%be%d0%bb%d0%b6%d0%b5%d0%bd-%d0%b4%d0%b8%d0%b7%d0%b0%d0%b9%d0%bd/" target="_blank" rel="noopener">Грег Костикян: I Have No Words and I Must Design</a> — хрестоматийная статья о гейм-дизайне 1994 года</p><h2 id="5-Некомпьютерные-игры-и-развлечения"><a href="#5-Некомпьютерные-игры-и-развлечения" class="headerlink" title="5. Некомпьютерные игры и развлечения"></a>5. Некомпьютерные игры и развлечения</h2><p>Индустрия развлечений существовала и до компьютерных игр, со своим опытом и наработками.</p><p><a href="http://aushestov.ru/%D0%BD%D0%B5-%D0%B1%D1%83%D0%B4%D1%8C-%D0%B2%D0%B8%D0%B4%D0%B8%D0%BE%D1%82%D0%BE%D0%BC-%D0%B8%D0%BB%D0%B8-%D1%87%D0%B5%D0%BC%D1%83-%D0%B4%D0%B8%D0%B7%D0%B0%D0%B9%D0%BD%D0%B5%D1%80-%D0%BA%D0%BE%D0%BC/" target="_blank" rel="noopener">Грег Костикян: Don’t be a vidiot</a></p><p><blockquote><p>В качестве поиска источников вдохновения не останавливаться на видеоиграх, а исследовать другие области развлечений — настольные игры, варгеймы, ролевые и коллекционнык карточные игры, а также LARP-ы. Я бы добавил еще тематические развлекательные фестивали, комиконы, технологические фестивали, геймдев конференции, подобные бёрнинг-мэну мероприятия, парки и комнаты развлечений, квест-румы, городские квесты, спортивные и киберспортивные шоу, внедорожное ориентирование (трофи-рейд).</p></blockquote><br></p><p><a href="https://vk.com/bnmidv" target="_blank" rel="noopener">Больше не мастерю и другое враньё</a> — книга про LARP.</p><p>Детские ощущения — наблюдение за насекомыми, снежки и катания с горок, походы, горы и леса, сплавы по речкам (себя, или построенных моделей, с последующим вылавливанием), кукольные дома, железные дороги, дворовые игры, исследование заброшенных зданий, строительство из чего угодно,рисование карт, разгадывание секретов, залезание на высоту, соревнования с друзьями, водяные бои, игры с животными, игра в магазины, собирание коллекций, ночёвки не дома, дворовые и комнатные игры и их модификации. </p><p>Детские забавы и игрушки. У моего поколения — как остатки советских игрушек старших братьев и сестёр, сломанные и забытые на чердаках и в подвалах, без инструкций, так и 90е с киндерами, Тамагочи, ну погоди, нес/сега, коллекционирование вкладышей, чупакепсов, альбомы с наклейками, йойо, крышки с гвоздями, лизуны, попрыгунчики, лего и другие конструкторы.<br>(всё, что вызывало эмоции)</p><p><code>Durchin, Jesyca. GDC 2000. “Developing Software for Girls</code><br><strong><code>Fashion play, Glamour play, Nurture play(Pokemon, monster farmer, nintendog), Collection play, Communication &amp; social play</code></strong></p><p><a href="https://www.raphkoster.com/2010/03/18/what-core-gamers-should-know-about-social-games/" target="_blank" rel="noopener">What core gamers should know about social games</a><br>First big ideas -  <strong><code>sports, dragons, robots, guns, jumping &amp; climbing, and car</code></strong></p><p>Если делается игра для определенной возрастной группы - надо не забывать исследовать,  какие игры были популярны, когда они были детьми, так как все игровые действия связаны с детством. Всё детство игра. Чтобы общаться в виде игры с кем-то по-настоящему, нужно говорить на языке его детства!</p><p>Насчет источников идей для игр:</p><ul><li>переиграть во все игры жанра.<ul><li>популярные все (знать конкурентов)</li><li>старые (найти старые полезные идеи, понять те, от которых отказались. понять эволюцию механик)</li><li>посмотреть менее популярные и инди (в поиска новых механих и идей, то что сделано лучше чем в популярных, возможно найти “слиперы”)</li></ul></li><li>некомпьютерные игры и не-игры<ul><li>настолки</li><li>живые игры (квесты, ларпы)</li><li>фильмы/литература/комиксы/новости</li></ul></li><li>природа<ul><li>получить референсы первого уровня (референс на объект в реальном мире, а не из другого произведения)</li><li>в природе миллиарды идей (наша цивилизация бесконечно моложе природы) - игры про жуков - зерги/тираниды, покемоны</li></ul></li><li>ощущения<ul><li>фокусироваться на эмоциях ради попытки передачи именно их (музыка в марио, механика охоты в монстер хантере). </li><li>ощущения от разных типов движения. castlevania, souls-like</li></ul></li></ul><h2 id="6-Game-feel"><a href="#6-Game-feel" class="headerlink" title="6. Game-feel"></a>6. Game-feel</h2><p><code>Steve Swink: Game Feel. A Game Designer&#39;s Guide to Virtual Sensation</code><br><code>Chris Solarski. Drawing Basics and Video Game Art + Interactive stories and video game art</code> - язык форм в геймдизайне.</p><p><strong>Ощущения слияния с персонажем</strong></p><p>Человек в потоке “сливается” с системой, которой управляет (<a href="https://ru.wikipedia.org/wiki/%D0%A0%D0%B0%D1%81%D1%88%D0%B8%D1%80%D0%B5%D0%BD%D0%BD%D1%8B%D0%B9_%D1%84%D0%B5%D0%BD%D0%BE%D1%82%D0%B8%D0%BF" target="_blank" rel="noopener">Расширенный фенотип</a>, <a href="https://www.youtube.com/watch?v=DphlhmtGRqI" target="_blank" rel="noopener">Is That My Real Hand?</a>), и ощущает её как продолжение себя.</p><p>Десятки мелочей вроде:</p><ul><li>Ощущение “тяжелого” персонажа или оружия, за счёт инерции и задержки в управлении (торможение после разгона или мощной атаки занимает время)</li><li>Замирание в несколько фреймов для ощущения тяжести удара (“впечатывание” топора в босса)</li><li>Ракурсы и эффекты камеры</li></ul><p>Игры, в которых мне вспоминается ощущение от клёвого движения впервые:</p><ul><li>NES Duck Tales 2. Pogo jump - даёт возможность распрыжки выше, чем обычный прыжок, и атаки. Кольца на боссе в пиратском корабле — могут мешать прыжкам с пола, но помогают перемещаться ещё выше, если освоить прыжки по ним.</li><li>NES Jungle Book. Разгон с прыжками на большие расстояния, вертикальный тип прыжка с места (особенно на уровне с падающими платформами).<br>Из более современных — “клейкость” капель в Worlds of Goo.</li></ul><p>Кроме физического ощущения от движения, также возникает эмоциональное сопереживание — что ощущает персонаж с таким набором ограничений в движении, с такими возможностях, и с такими задачами, которые перед ним возникают. Может быть, он почувстсвует себя всесильным? Или испуганным от того, что ему предстоит пройти? Этот опыт возникает из сочетания того, что игрок уже видел, переживал до этого — в жизни, в книгах, в кино (в детстве или недавно — может сработать любой культурный код), или в самой игре в предыдущем уровне.</p><p>Brothers: A Tale of Two Sons — управляем старшим братом правым стиком, когда брат умирает, стик отключается</p><p>Управление может быть связано с дизайном игры, в Super Mario World — 4 цвета кнопок нинтендо и 4 типа Yoshi, соответстующих цветам кнопок, а также 2 кнопки для бега, чтобы можно было нажимать на вторую, не отпуская первую (использование способностей также привязано к кнопкам бега). Другой пример связи механики, дизайна и управления — игры Blizzard, особенно Starcraft (отличия в gui для каждой из рас).</p><p><a href="/blog/1998861373/" title="Скрытые игровые механики">Скрытые игровые механики</a> — среди скрытых механик много направленных на улучшение ощущения от игры</p><p><a href="https://eggplant.show/into-the-depths-super-mario-world-part-4" target="_blank" rel="noopener">Into the Depths: Super Mario World - Part 4</a> — подкаст про Kaizo-хаки Super Mario World, повышенной сложности. По описанию ощущений от игроков — отключается мозг, и управление происходит на уровне звериных инстинктов.</p><p><strong>Синхронизация с ритмами музыки</strong></p><p><a href="https://www.youtube.com/watch?v=KuyA12ezwS4" target="_blank" rel="noopener">Как устроен звук в Марио. Гармонизация. Секрет звукодизайна Nintendo</a><br><a href="https://www.youtube.com/watch?v=9H7B0n-Gk1A" target="_blank" rel="noopener">Как устроена музыка в играх Нинтендо</a></p><p>В серии Марио звук встроен в мелодию, синхронизирован с ритмом, и иногда меняется вместе с музыкой. Анимации также могут быть подстроены под ритм музыки</p><p><strong>Особенности контроллера</strong></p><p>На ощущение от игры влияет latency и сам тип контроллера<br><a href="https://www.youtube.com/watch?v=vOvQCPLkPt4" target="_blank" rel="noopener">Applied Sciences Group: High Performance Touch</a></p><p>Кроме задержки от ввода, существют еще <strong><code>задержки при запуске игры, загрузке между уровнями, сетевые</code></strong> и другие, которые можно и нужно убирать, чтобы улучшить game feel. Например, если игра может запускаться без части ресурсов или с low-res моделями или текстурами, их можно подгрузить потом (с диска или вообще по сети). Игрок запомнит, что игра запустилась быстро.</p><p>Цитата коллеги</p><blockquote><p>Ещё крутой штрих на пс5 - стрельба как обычно, правым курком, но когда заканчиваются патроны в револьвере - у курка снижается упругость, и прям чувствуешь когда в пылу битвы патроны закончились<br><br></p></blockquote><p>В качестве примеров можно взять Mario 3D Land, где в некоторых местах нужно подуть в микрофон, ну или почти весь геймплей Mario Party.</p><p>VR/AR контроллеры даже сами по себе дают необычные ощущения от геймплея.</p><p><strong>Особенности игрового места</strong><br>Пространство, в котором находится игрок, так определяет опыт. Джесси Шелл выделяет типы пространств (явно прослеживают идеи Кристофера Александера), можно перерабатывать и уточнять схему бесконечно, важно понимание существования разных типов пространств:</p><ul><li>Очаг (телевизор). Семейные игры, Wii</li><li>Рабочее место. Мультиплейерные игры, steam, vr</li><li>Уголок для чтения. iPad</li><li>Театр. ?Larp</li><li>Арена. Спорт, киберспорт</li><li>Музей. ?Игры в дополненной реальности</li><li>Игровой стол. Настолки</li><li>Игровая площадка. ?Парки аттракционов</li><li>Где угодно. Словесные игры</li></ul><p><a href="/blog/1152742413/" title="Города, которые мы выбираем">Города, которые мы выбираем</a> — места влияют и на то, как делаются игры</p><h2 id="7-Баланс"><a href="#7-Баланс" class="headerlink" title="7. Баланс"></a>7. Баланс</h2><p><code>Ромеро Шрайбер: Игровой баланс. Точная наука геймдизайна</code><br>Баланс часто рассматривается кратко вместе с проектированием кор-механик, но тут ему посвящена отдельная книга. Связано вероятно с тем, что правила очень практические и мало обобщаются на различные типы игр.<br>Большинство принципов связано с глубоким изучением поведения основных функций (чем-то похоже на изучение <a href="https://thebookofshaders.com/05/" target="_blank" rel="noopener">формообразующих функций</a> у creative-кодеров), а также с тем, чтобы соотносить эти функции с тем, что получает игрок.</p><p>Вроде чего-нибудь типа “если скилл развивается в игре от 0 до 100. Допустим на старте около 20, и потом быстро подтягивается до 80, но очень медленно доходит до 100. Тогда круто дать игроку пройти игру на этих восьмидесяти, но с каждым небольшим повышением его скилла давать ему возможность открывать в игре что-то новое и отличающееся”.</p><p>Пример такого подхода в Final Fantasy Tactics Advance — игрок проходит игру первый раз не особо задумываясь за классическую ролевую команду из тяжёлого воина, лёгкого воина/вора, лучника, мага поддержки, лекаря и боевого мага. Но при этом игра оставляет несколько хуков — миссии, которые открываются только после прохождения “финальной” (около 30%), ненайденные предметы и необычные профессии. За следующие прохождения игрок, набираясь опыта, может попробовать (в порядке того, как растёт его понимание игры):</p><ul><li>Разобраться в механиках, чтобы получить наиболее сильную партию. Этот тип прохождения и прокачки будет сильно отличаться от обычного. <a href="https://gamefaqs.gamespot.com/gba/560436-final-fantasy-tactics-advance/faqs/25820" target="_blank" rel="noopener">Statistic Growth Charts</a>.</li><li>Попробовать использовать игровые механики, чтобы собрать партию из тех классов, которые при обычном прохождении будут слабыми, но становятся сильными, если качать их специальным образом. Например, для получения сильного иллюзиониста нужно специально качать его другим классом, для сильного синего мага нужно заранее рассчитать миссии, в которых он будет получать способности от редких монстров, а для эффективного использования гаджетов и способностей, которые могут ударить по своим персонажам нужно подобрать способности/предмета для инверсии отрицательных эффектов. Также интересно, что вокруг некоторых профессий можно собрать целую партию с нестандартными ролевыми архетипами. Например, синий маг получает способности, когда соперники применяют их против него, и чтобы не полагаться на случайность соперников, можно использовать: повелителя зверей для контроля на соперниками, охотника, который может поймать монстров и получить их души, и морфера, который сам может превратиться в пойманного охотником зверя. (<a href="https://gamefaqs.gamespot.com/gba/560436-final-fantasy-tactics-advance/faqs/25929" target="_blank" rel="noopener">Blue Mage Guide</a>, <a href="https://gamefaqs.gamespot.com/gba/560436-final-fantasy-tactics-advance/faqs/26587" target="_blank" rel="noopener">Capture FAQ</a>)</li><li>Попробовать собрать в игре всё, что не прибито гвоздями (<a href="https://gamefaqs.gamespot.com/gba/560436-final-fantasy-tactics-advance/faqs/25875" target="_blank" rel="noopener">Stealing Guide</a>). Интересный пример механики воровства, 99% задуманной именно так геймдизайнерами, но игроки уверены, что они “обманули систему”. В игре есть способность “похитить способность” и “похитить оружие врага”. Это редкие и мощные способности, открывающиеся в лейт-гейме. Но! Игрок, который знает об этой способности, при повторном прохождении может заметить, что уже на 4-м уровне стоит враг, со способностью Steal Weapon. Единственный способ получить её себе так рано — прокачать навык клана до 30, что при нормальном прохождении получается ближе к концу игры. Однако, если в начале игры выгнать одного из персонажей, то открываются миссии по подбору новых персонажей в клан, которые как раз и качают нужный навык. Таким образом, можно одновременно заменить стартовых персонажей на более сильных (сюда добавлен элемент гринда, изредка приходят более сильные персонажи с крутыми профессиями) и насобирать очки для получения кинжала, который позволит отобрать у врага “похищение оружия”. Процесс занимает 5-6 часов (что для японского геймера и не считается гриндом). Дальше в начальных миссиях также специально расставлены несколько соперников с очень редкими предметами, которые можно отобрать. Причём предметы не разрушают баланс, а лишь немного усиливают партию.</li><li>Игроки, которые собрали всё, дополнительно устраивают себе челленджи вроде <a href="https://gamefaqs.gamespot.com/gba/560436-final-fantasy-tactics-advance/faqs/41494" target="_blank" rel="noopener">Single Class Challenge Guide</a> или переигравают в хаки с усложнённым балансом, созданные другими хардкорными игроками.</li></ul><p>Другой хороший пример, тоже связанный с комбинаторикой скиллов различных классов, и нестандартным подходом в квестам — Divinity Original Sin 2 (<a href="https://www.youtube.com/watch?v=-kj6zhLpmME" target="_blank" rel="noopener">Секретный опыт в форте Радости</a>, <a href="https://www.youtube.com/watch?v=ddZ7--ZBJWo" target="_blank" rel="noopener">Как просто и красиво победить Даллис на корабле и собрать много опыта</a>). Или <a href="https://dtf.ru/games/1043703-vsyo-chto-vy-hoteli-znat-o-lore-i-syuzhete-serii-dark-souls" target="_blank" rel="noopener">Ветка Кааса</a> в Dark Souls, которая открывает альтернативную точку зрения на сюжет.</p><p>Из более простых примеров — в инди-платформерах часто создаются специальные условия для спидраннеров.</p><p>Одна из задач гейм-дизайнера, занимающего балансом — найти общий язык с другими гейм-дизами и программистами, чтобы вообще получить какие-нибудь управляемые параметры.</p><p>Игроки не любят и не понимают случайности. Как в случайных, так и в непредсказуемых отрицательных событиях, игроки видят злой умысел со стороны программы или разработчика. В положительных случайных исходах игрок видят собственную заслугу.</p><h2 id="8-Инди"><a href="#8-Инди" class="headerlink" title="8. Инди"></a>8. Инди</h2><p>Инди — в первую очередь отличный от мейнстрима майнд-сет. Создание игры — это большие расходы ресурсов, объём работ, и риски. Подход инди заключается в том, чтобы уменьшить расходы и объём работ (жертвуя в том числе и от качествов), для того, чтобы получить возможность действовать быстрее, смелее и свободнее.</p><p><code>Слава Грис: Сделай видеоигру один и не свихнись</code> — инди подход<br><code>Indie Game: The Movie</code> — документальный фильм о нескольких инди-разработчиках. Отдельно можно много смотреть и слушать Jonathan Blow.</p><p>Инди-игры не направлены на то, чтобы становиться хитами, но истории успеха привлекают много внимания<br><code>Джейсон Шрейер: Кровь, пот и пиксели</code> — боль Pillars of Eternity, Stardew Valley, Shovel Knight</p><h2 id="9-Онлайн-и-социальные"><a href="#9-Онлайн-и-социальные" class="headerlink" title="9. Онлайн и социальные"></a>9. Онлайн и социальные</h2><p>Кроме кор-геймплея, дизайнеры планируют также прогрессию в игре. Строятся модели, чем именно будет заниматься игрок в 30 и больше дней игры, и какой именно процент игроков пройдёт путь от запуска до того, чтобы стать суперфанатом и провести в игре месяцы и годы. Игры изначально проектируются не как продукты, а как сервисы с длительной поддержкой. Ранний доступ, кампании на кикстартере, открытая разработка, загружаемый контент, приёмы ретеншена, лут боксы - приёмы игр-сервисов.</p><p><code>Lovell Nicholas: The Pyramid of Game Design Designing, Producing and Launching Service Games</code> — основная книга, в которой рассматривается дизайн прогрессии</p><p><a href="/blog/1402387497/" title="Суперфанаты">Суперфанаты</a> — про самых заядлых фанатов игр</p><p>Игра должна содержать <strong><code>&quot;эндогенную ценность&quot;</code></strong>. Намного интереснее играть в карты на реальные деньги, чем на спички. Также и с играми — сама возможность покупок за реальные деньги делает игру интереснее. Даже без реальных денег — абстрактный сбор бонусных предметов менее интересный, чем колец в Sonic, которые можно потерять.</p><p><code>Richard A. Bartle: Designing Virtual Worlds</code> — интересна описанием типов игров в виртуальных мирах, их взаимодействия и динамики развития онлайн сообществ. MUD-ы скопили приличное количество информации о поведении игроков.</p><p><a href="https://www.raphkoster.com/" target="_blank" rel="noopener">Raph’s Website</a> — блог Рафа Костера, много статей про виртуальные миры</p><p>EVE, Ultima — игра с большой свободой действий и мета-геймплеем, выходящим далеко за рамки игры.</p><p>Axie Infinity — NFT игра с интересным кор-геймплеем и мета-игрой с покупкой и выращиванием персонажей на блокчейне. Много новых аспектов гейм-дизайна:</p><ul><li>кто-то из разработчиков потерял ключ, и из блокчейна потерялось 100 млн долларов</li><li>разводчики аксей вложили 50к$ в ферму, чтобы вывести наиболее мощных по мете аксей, а разрабы в середине сезона решили поправить баланс, и цена упала в 10 раз</li><li>разработчики не обновили описание способностей на сайте-магазине с апдейтом, в итоге на рынке акси отображаются со способностями, которые не работают в игре</li><li>разработчики вообще поменяли правила и выпустили новую игру, и все старые мощные акси превратились в тыкву. ну и еще десяток вариаций, в которых ради привлечения новых игроков разработчики ослабляют уже существующих аксей. Или просто исправляют ошибки дизайна игровой экономики, обесценивая слишком щедрые призы на руках у игроков.<br>(изначально, разработчики и планировали выпуск нескольких игр, в которых можно играть одними и теми же NFT предметами)<br>(та же проблема с балансом <a href="http://aushestov.ru/why-dota-sucks-08/" target="_blank" rel="noopener">dota</a>)</li><li>рынок всей крипты упал вниз, и все способы заработка перестали работать</li><li>Разработчики думали, что коллекционирование интересно само по себе, но 99% игроков интересовались только спекуляциями, и не особо понятно, зачем им играть теперь</li><li>“теперь любой может зарабатывать на игре” звучит заманчиво вначале, но когда нужно обязательно играть в день по 4-8 часов просто, чтобы отбить вложенное, это уже не выглядит так привлекательно. Каждый неотыгранный полностью день начинает восприниматься как потеря денег (спасает сдача аксей в аренду, в некоторых странах возможность заработка в месяц по 20-40 долларов выглядит привлекательной)</li><li>манипуляции с ценами на рынке, если неверно оценил стоимость, что достаточно сложно, можешь переплатить раз в 10, или случайно продать что-то дорогое за копейки. Отдельно веселят новички, которым посоветовали “мощную” команду за 500$, которая стоит 20-30$</li><li>разработчики автоматическим алгоритмом борьбы с ботами забанили несколько тысяч аксей обычных игроков на 99 лет. Также забавляет, что в рамках правил один игрок может играть с одного телефона одним аккаунтом. При этом проверить это владельцу аксей сложно, те кто берет аксей в аренду дают честное слово, что будут играть со своего телефона только с этого арендованного аккаунта, и не будут брать других. В итоге банят аксей первоначальному владельцу.</li><li>платформодержатели совсем не рады денежной системе внутри игры</li><li>честный рандом при выведении, когда условно на 99% чистые родители (которые сами по себе стоят дофига) могут дать именно тебе мутировавшее потомство (и стоит оно … вообще ничего не стоит)</li><li>на разных рейтингах “обитают” различные акси, команда, которая хорошо показывает себя в топ-100 мест, может проигрывать на низких рейтингах. Для полноценной игры нужно больше чем одна команда<br><a href="https://github.com/spiiin/axie_test" target="_blank" rel="noopener">https://github.com/spiiin/axie_test</a> — я делал когда-то сбор статистики, какие команды встречаются на различных рейтингах</li></ul><h2 id="10-Level-Design"><a href="#10-Level-Design" class="headerlink" title="10. Level Design"></a>10. Level Design</h2><p>Отдельная большая область. Уровни определяют <strong><code>эстетику, являются пространством, в котором существуют игровые механики и содержат визуальную разметку, которая будет направлять внимание игрока</code></strong>.</p><p><a href="https://level-design.ru/pro-ld-book-index/pro-ld-book-about/" target="_blank" rel="noopener">Михаил Кадиков: проектирование виртуальных миров</a><br><a href="/blog/1687824628/" title="Паттерны организации разработки уровней игр">Паттерны организации разработки уровней игр</a> — паттерны дизайна уровней</p><p><img src="/blog/3299387993/level_small.png" alt=""><br><em>картинка из <a href="https://youtu.be/aVb6-Rkz7W4?si=FnMvpqNxg0Hn2SUZ&amp;t=2242" target="_blank" rel="noopener">[2019 TGDF] Making Games in 2019 and Beyond (Jonathan Blow)</a>. Расположение колонн заставляет игрока искать секреты на нижним ярусе.</em></p><p><strong>Эстетика</strong><br><code>Кристофер Александер: Язык шаблонов</code>, и другие книги, The Nature of Order<br><code>Крис Соларски</code>, все книги (Drawing Basics and Video Game Art,  Interactive Stories and Video Game Art, Interactive Empathy and Embodiment), <a href="https://www.youtube.com/watch?v=W5U_5eL1bGY" target="_blank" rel="noopener">Adaptive Gameplay Aesthetics: A Disruptive Game Design Framework</a> + <a href="https://solarskistudio.gumroad.com/l/TtrHn" target="_blank" rel="noopener">pdf</a>. Автор начинает с арта, и дальше расширяет повествование до дизайна всей игры. Он выделяет применение форм в <strong><code>формах персонажей, их движениях, формах окружения, путях, диалогах, кадре, звуке и жестах игрока</code></strong><br><code>Molly Bang: How Pictures Work</code><br><code>Скотт Макклауд: Понимание комикса</code></p><p><a href="https://www.youtube.com/watch?v=QHHg99hwQGY&amp;t=366s" target="_blank" rel="noopener">‘Magic: the Gathering’: 20 Years, 20 Lessons Learned</a><br><a href="https://www.youtube.com/watch?v=lLQJiEpCLQE" target="_blank" rel="noopener">Геометрия в фильмах - Формирование образов</a></p><h2 id="11-Сюжет-и-нарратив"><a href="#11-Сюжет-и-нарратив" class="headerlink" title="11. Сюжет и нарратив"></a>11. Сюжет и нарратив</h2><p><code>Джозеф Кэмпбелл: Тысячеликий герой</code><br><code>Роберт Макки История на миллион долларов: Мастер-класс для сценаристов, писателей и не только</code></p><p>Работают общие сценарные правила. У игр есть отличные от других медиа сценарные приёмы (<a href="https://thegamedesignforum.com/features/architecture_of_dreams.html" target="_blank" rel="noopener">Architecture of Dreams</a>)</p><p>Кроме сценария игры существует история игрока. Одни из первых игр, сфокусированных на различных способах решения проблем — immersive sims (Ultime Underworld, Deus Ex)</p><p><a href="https://www.youtube.com/watch?v=64Rzt5oSHB0" target="_blank" rel="noopener">Как погибли иммёрсив симы и почему это хорошо</a>, также 1-я глава <code>Шрейер Джейсон - Нажми Reset. Как игровая индустрия рушит карьеры и дает второй шанс</code> (про взаимоотношения Уоррена Спектера и издателей).</p><h2 id="12-Психология"><a href="#12-Психология" class="headerlink" title="12. Психология"></a>12. Психология</h2><p>Игроки иррациональны, но эту иррациональность можно изучать и использовать особенности реакций людей. Минимум — книги Роберта Чалдини и Дэна Ариели для понимания когнитивных искажений. А также Талеба и Дёрнера Дитриха (кстати, его <a href="https://ru.wikipedia.org/wiki/%D0%9B%D0%BE%D1%85%D1%85%D0%B0%D1%83%D0%B7%D0%B5%D0%BD" target="_blank" rel="noopener">Лоххаузен</a>, использовавшийся для психологических экспериментов, возможно, был прообразом игр в жанре градостроительных симуляторов, сильно раньше SimCity и прочих цезарей и фараонов) для понимания особенностей работы с неравномерными величинами.</p><p><a href="/blog/3309518526/" title="Системы поиска сокровищ">Системы поиска сокровищ</a> — про неравномерные величины</p><h2 id="Ссылки"><a href="#Ссылки" class="headerlink" title="Ссылки"></a>Ссылки</h2><p>Интересные механики и игры, в которых их можно посмотреть:<br><a href="http://aushestov.ru/%d0%b8%d0%b3%d1%80%d1%8b-%d0%b4%d0%be%d1%81%d1%82%d0%be%d0%b9%d0%bd%d1%8b%d0%b5-%d0%b8%d0%b7%d1%83%d1%87%d0%b5%d0%bd%d0%b8%d1%8f/" target="_blank" rel="noopener">Игры достойный изучения</a><br><a href="http://aushestov.ru/gold-reserve/" target="_blank" rel="noopener">«Золотой фонд» геймдева</a><br>Также часто используются в качестве примеров гейм-дизайна — игры Nintendo, Naughty Dog, Valve, аркадная классика и инди игры.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;&lt;a href=&quot;/
      
    
    </summary>
    
    
    
      <category term="gamedesign" scheme="http://spiiin.github.io/tags/gamedesign/"/>
    
      <category term="longread" scheme="http://spiiin.github.io/tags/longread/"/>
    
  </entry>
  
  <entry>
    <title>Искусственный интеллект в играх. Ссылки</title>
    <link href="http://spiiin.github.io/blog/3627525605/"/>
    <id>http://spiiin.github.io/blog/3627525605/</id>
    <published>2024-01-16T12:28:41.000Z</published>
    <updated>2024-01-26T07:52:27.660Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p><a href="https://gameprogrammingpatterns.com/state.html" target="_blank" rel="noopener">Game Programming Patterns. State</a> - введение, FSM и вариации<br><a href="https://habr.com/ru/articles/420219/" target="_blank" rel="noopener">Обзор техник реализации игрового ИИ</a></p><p><a href="https://www.gamedevs.org/uploads/three-states-plan-ai-of-fear.pdf" target="_blank" rel="noopener">Three-states plan AI of F.E.A.R.</a> - GOAP в F.E.A.R, введение<br><a href="https://habr.com/ru/articles/774506/" target="_blank" rel="noopener">Хочешь сделать интересного монстра, думай как монстр</a> - Behaviour Tree, ссылки на доклады про реализации behaviour tree в играх<br><a href="https://dev.epicgames.com/community/learning/tutorials/qzZ2/behavior-tree-theory" target="_blank" rel="noopener">Behaviour Tree Theory</a> - введение в BT в Unreal Engine<br><a href="https://courses.tomlooman.com/courses/enrolled/1320807?" target="_blank" rel="noopener">Basic AI &amp; Behavior Trees. Lectures 10-14</a> - часть платного курса по Unreal</p><ul><li><a href="https://www.tomlooman.com/unreal-engine-utility-ai-part1/" target="_blank" rel="noopener">Journey into Utility AI with Unreal Engine</a></li><li><a href="https://www.youtube.com/watch?v=tq-ULFuNyig" target="_blank" rel="noopener">Unreal Engine AI Tutorial: Create AI with Behavior Trees</a><br><a href="https://www.youtube.com/@BobbyAnguelov/streams" target="_blank" rel="noopener">Bobby Anguelov channel</a></li><li><a href="https://www.youtube.com/watch?v=G5A0-_4dFLg" target="_blank" rel="noopener">Game AI Basics</a></li><li><a href="https://www.youtube.com/watch?v=5ZXfDFb4dzc" target="_blank" rel="noopener">Simple and Scalable Game AI Decision Making</a></li><li><a href="https://takinginitiative.files.wordpress.com/2020/01/behaviortrees_breaking-the-cycle-of-misuse.pdf" target="_blank" rel="noopener">Behavior Trees: Breaking the Cycle of Misuse</a></li><li><a href="https://www.youtube.com/watch?v=Qq_xX1JCreI" target="_blank" rel="noopener">AI Arborist: Proper Cultivation and Care for Your Behavior Trees</a><br><a href="https://web.archive.org/web/20140402204854/http://www.altdevblogaday.com/2011/02/24/introduction-to-behavior-trees/" target="_blank" rel="noopener">Introduction to behavior trees</a> - серия из 5 статей, также много ссылок на реализации, периода середины 2000х-начала 2010х.<br><em>Alex J. Champandard’s Getting Started with Decision Making and Control Systems, AI Game Programming Wisdom 4</em></li></ul><p><a href="https://www.youtube.com/user/tthompso" target="_blank" rel="noopener">AI and Games channel</a></p><p><a href="https://web.archive.org/web/20190506024808/http://aigamedev.com/open/article/bugs-caught-on-tape/" target="_blank" rel="noopener">18 Embarrassing Game AI Bugs Caught On Tape… and Fixed!</a></p><p>Open-source либы<br><a href="https://github.com/bjoernknafla/liz" target="_blank" rel="noopener">https://github.com/bjoernknafla/liz</a><br><a href="https://github.com/BehaviorTree/BehaviorTree.CPP" target="_blank" rel="noopener">https://github.com/BehaviorTree/BehaviorTree.CPP</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;&lt;a href=&quot;h
      
    
    </summary>
    
    
    
      <category term="gamedev" scheme="http://spiiin.github.io/tags/gamedev/"/>
    
      <category term="link" scheme="http://spiiin.github.io/tags/link/"/>
    
  </entry>
  
  <entry>
    <title>Архетипы high-level программистов в геймдеве</title>
    <link href="http://spiiin.github.io/blog/2897492989/"/>
    <id>http://spiiin.github.io/blog/2897492989/</id>
    <published>2024-01-10T18:34:38.000Z</published>
    <updated>2024-01-15T14:22:46.169Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p><a href="/blog/503948690/" title="Про строителей и ломателей">Про строителей и ломателей</a> — при стиль мышления программистов<br><a href="/blog/4256110900/" title="Эволюция программиста в геймдеве">Эволюция программиста в геймдеве</a> — про то, куда расти сениорам</p><p>3 архетипических пути развития программиста в геймдеве:</p><ul><li>Архитектор</li><li>Хакер</li><li>Продюсер</li></ul><h2 id="Архитектор"><a href="#Архитектор" class="headerlink" title="Архитектор"></a>Архитектор</h2><p>Проектируют масштабные системы.<br>Соотношение программирования/управления - 50%/50% (где-то могут не программировать вообще, где-то делают в одиночку шаблоны систем, но объём работ требует привлечения человеческих ресурсов). Область интереса — взаимосвязь систем между собой.</p><p>Примеры:</p><p><code>Sergey Ignatchenko</code><br><a href="https://ithare.com/" target="_blank" rel="noopener">Development and Deployment of Multiplayer Online Games: from social games to MMOFPS, with stock exchanges in between</a></p><p><code>Максим Барышников</code><br><a href="https://www.youtube.com/watch?v=KxQpDIKwGUw" target="_blank" rel="noopener">6 лет развития движка BigWorld благодаря успеху World of Tanks</a><br><a href="https://www.youtube.com/watch?v=5y23xezgQKE" target="_blank" rel="noopener">Миллион пользователей онлайн в World of Tanks с инженерной точки зрения</a></p><p><code>Bret Victor</code><br><a href="https://www.youtube.com/watch?v=PUv66718DII" target="_blank" rel="noopener">Inventing on Principle</a><br><a href="https://www.youtube.com/watch?v=8pTEmbeENF4" target="_blank" rel="noopener">The Future of Programming</a></p><h2 id="Хакер"><a href="#Хакер" class="headerlink" title="Хакер"></a>Хакер</h2><p>Разбираются в технологиях. Больше программируют и исследуют. Область интереса — подсистема, которой в данной момент занимаются, и связь её с другими.</p><p>Примеры:</p><p><code>John Carmack</code> - олицетворение архетипа</p><p><code>Robert Nystrom</code><br><a href="https://gameprogrammingpatterns.com/contents.html" target="_blank" rel="noopener">Game programming patterns</a><br><a href="https://craftinginterpreters.com/" target="_blank" rel="noopener">Crafting Interpreters</a></p><p><code>Mike Acton</code><br><a href="https://www.youtube.com/watch?v=rX0ItVEVjHc" target="_blank" rel="noopener">CppCon 2014: Mike Acton “Data-Oriented Design and C++</a></p><h2 id="Продюсер"><a href="#Продюсер" class="headerlink" title="Продюсер"></a>Продюсер</h2><p>(или Founder)<br>Далеко от программистов, делают не игры, делают бизнес. Важно больше знать о продукте, рынке, работе с людьми и пайплайнах. Почти всегда больше не программируют. Область интереса — производимый продукт.</p><p><code>Jonathan Blow</code><br>(как тру-инди, периодически одевает шляпу архитектора или хакера)<br><a href="https://www.youtube.com/watch?v=aVb6-Rkz7W4" target="_blank" rel="noopener">Making Games in 2019 and Beyond</a></p><p><code>Jessie Schell</code><br><a href="https://www.youtube.com/watch?v=y92-vkyHKbY" target="_blank" rel="noopener">Information Flow: The Secret to Studio Structure</a><br><a href="https://www.youtube.com/watch?v=h4JuD5k9rg4" target="_blank" rel="noopener">Game Studio Management</a></p><p><code>Nick Atamas</code> - по профессии скорее хакер (делал slate в <a href="https://habr.com/ru/articles/409969/" target="_blank" rel="noopener">unreal</a>), на по типу общения и рассматриваемых проблем скорее продюссер<br><a href="https://kdicast.com/e/289-unreal-engine-5/" target="_blank" rel="noopener">КДИ #289. Unreal Engine 5</a><br><a href="https://kdicast.com/e/369-sozdanie-pesochnicz-s-ocp/" target="_blank" rel="noopener">КДИ #369. Создание песочниц OCP</a> - логичный для типа мышления переход в стартап</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;&lt;a href=&quot;/
      
    
    </summary>
    
    
    
      <category term="gamedev" scheme="http://spiiin.github.io/tags/gamedev/"/>
    
      <category term="dev_evolution" scheme="http://spiiin.github.io/tags/dev-evolution/"/>
    
  </entry>
  
  <entry>
    <title>Блендинг анимаций</title>
    <link href="http://spiiin.github.io/blog/2762077600/"/>
    <id>http://spiiin.github.io/blog/2762077600/</id>
    <published>2024-01-01T12:17:29.000Z</published>
    <updated>2024-01-01T12:30:20.363Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/Jkv0pbp0ckQ" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div><p>Animation Programming Basics</p><p>В дополнение - глава <code>Системы анимации</code> из книги Джейсона Грегори “Игровой движок”</p><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/LNidsMesxSE" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div><p>Animation Bootcamp: An Indie Approach to Procedural Animation</p><p>О том, как использовать методы блендинга, чтобы собирать анимации из 2-3 фреймов</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;style&gt;.embed
      
    
    </summary>
    
    
    
      <category term="link" scheme="http://spiiin.github.io/tags/link/"/>
    
      <category term="3d" scheme="http://spiiin.github.io/tags/3d/"/>
    
  </entry>
  
  <entry>
    <title>Super Mario Факты</title>
    <link href="http://spiiin.github.io/blog/2382849215/"/>
    <id>http://spiiin.github.io/blog/2382849215/</id>
    <published>2023-12-27T10:22:36.000Z</published>
    <updated>2023-12-30T10:21:44.733Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><h2 id="Дизайн"><a href="#Дизайн" class="headerlink" title="Дизайн"></a>Дизайн</h2><p><a href="https://eggplant.show/into-the-depths-super-mario-world-part-1" target="_blank" rel="noopener">Into the Depth: Super Mario World</a> — разбор механик Super Mario World в 6 частях, от авторов инди-платформеров <code>Spelunky</code> и <code>Celeste</code>.</p><ul><li>Геймдизайн “Марио” (и “Зельды”) вплетён в днк современных геймдизайнеров (даже если кто-то больше играл в Соника)</li><li>Изначально была идея чтобы игра воспринималась как атлетическая - <a href="https://purenintendo.com/miyamoto-talks-about-the-original-super-mario-bros/" target="_blank" rel="noopener">https://purenintendo.com/miyamoto-talks-about-the-original-super-mario-bros/</a></li><li>Миямото описывает игру как challenge, чтобы всегда была “коробка с челленджами”</li><li>Туториал по механикам - <a href="https://www.youtube.com/watch?v=QpgPLsNv9uE" target="_blank" rel="noopener">https://www.youtube.com/watch?v=QpgPLsNv9uE</a>, для тренировки в kaizo-хаках</li><li>Цвета йоши и домиков соответствуют 4м кнопкам джойпада snes <a href="https://www.youtube.com/watch?v=zgtYV41yXbU" target="_blank" rel="noopener">https://www.youtube.com/watch?v=zgtYV41yXbU</a></li><li>Две кнопки для бега позволяют не переставая бежать выполнять действия, которые требуют нажать кнопку для бега (выпустить снаряд или ударить хвостом)</li></ul><p><a href="https://thegamedesignforum.com/features/RD_SMW_1.html" target="_blank" rel="noopener">Reverse game design SMW</a><br><a href="https://habr.com/ru/companies/plarium/articles/307428/" target="_blank" rel="noopener">Дополнение</a><br><a href="https://thegamedesignforum.com/features/GDH_2.html" target="_blank" rel="noopener">An Intro to Videogame Design History. Part2. The Composite Era</a> - Super Mario открыл эру игр с композитным дизайном (прыжки от аркады, выстрелы и борьба с врагами из экшенов)</p><h2 id="Tech-art"><a href="#Tech-art" class="headerlink" title="Tech-art"></a>Tech-art</h2><ul><li>Super Mario 64 - первая игра со скелетной анимацией</li><li>Модель Марио из Super Mario Wonder содержит множество мешей, которые включаются и отключаются динамически для создания мультяшных эффектов (<a href="https://twitter.com/DMeville/status/1740873118099661013" target="_blank" rel="noopener">link</a>) - 3 ноги, 18 мешей рта, 6 пар рук и 3 пары бровей.<br><img src="/blog/2382849215/smw_model.png" alt=""></li></ul><h2 id="Звук"><a href="#Звук" class="headerlink" title="Звук"></a>Звук</h2><p><a href="https://www.youtube.com/watch?v=KuyA12ezwS4" target="_blank" rel="noopener">Как устроен звук в Марио. Гармонизация. Секрет звукодизайна Nintendo</a><br><a href="https://www.youtube.com/watch?v=9H7B0n-Gk1A" target="_blank" rel="noopener">Как устроена музыка в играх Нинтендо</a></p><ul><li>В серии Марио звук встроен в мелодию, синхронизирован с ритмом, и иногда меняется вместе с музыкой. Анимации также могут быть подстроены под ритм музыки</li><li>Заимствования. Музыка из 1-2 - <a href="https://youtu.be/ZX5ef_KAZlY?si=WSnDh-Iw0hy-FrPF" target="_blank" rel="noopener">https://youtu.be/ZX5ef_KAZlY?si=WSnDh-Iw0hy-FrPF</a></li></ul><h2 id="Бонус"><a href="#Бонус" class="headerlink" title="Бонус"></a>Бонус</h2><p><a href="https://shedevr.org.ru/cgi-bin/parse.cgi?id=super_mario_bros_tas_review" target="_blank" rel="noopener">If you look hard enough…</a> — TAS игры<br><a href="https://www.youtube.com/watch?v=OPcV9uIY5i4" target="_blank" rel="noopener">Super Mario World “Arbitrary Code Execution”</a> — произвольное испольнение кода<br><a href="https://andrewkelley.me/post/jamulator.html" target="_blank" rel="noopener">Statically Recompiling NES Games</a></p><ul><li>Из-за оптимизаций игры применяются приёмы вроде jmp на середину инструкции</li></ul><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;h2 id=&quot;Дизай
      
    
    </summary>
    
    
    
      <category term="nes" scheme="http://spiiin.github.io/tags/nes/"/>
    
      <category term="link" scheme="http://spiiin.github.io/tags/link/"/>
    
      <category term="gamedesign" scheme="http://spiiin.github.io/tags/gamedesign/"/>
    
  </entry>
  
  <entry>
    <title>Design Review</title>
    <link href="http://spiiin.github.io/blog/2511486836/"/>
    <id>http://spiiin.github.io/blog/2511486836/</id>
    <published>2023-12-26T15:38:58.000Z</published>
    <updated>2023-12-26T15:55:27.750Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>В статье <a href="https://habr.com/ru/articles/774972/" target="_blank" rel="noopener">Вы точно хотите пойти программистом в gamedev?</a> и комментариях к ней попалась пара докладов с описанием проблем code review, и предложениями ревьюить дизайн, до написания кода</p><p><a href="https://www.youtube.com/watch?v=WQg_339CcBY" target="_blank" rel="noopener">Артём Титов - TDD WTF ?! Или как написать код геймплея без ошибок</a><br><a href="https://www.youtube.com/watch?v=4Y0XJXRZv6k" target="_blank" rel="noopener">Design Review и другие друзья разработчика, Дельгядо Филипп</a></p><p>Выглядит будто бы здраво — вынести важную часть проверки как можно раньше, и дать возможность непрограммистам читать/проверять.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;В статье &lt;
      
    
    </summary>
    
    
    
      <category term="dev_method" scheme="http://spiiin.github.io/tags/dev-method/"/>
    
      <category term="dev_evolution" scheme="http://spiiin.github.io/tags/dev-evolution/"/>
    
  </entry>
  
  <entry>
    <title>Про изучение английского</title>
    <link href="http://spiiin.github.io/blog/2455145615/"/>
    <id>http://spiiin.github.io/blog/2455145615/</id>
    <published>2023-12-23T20:40:52.000Z</published>
    <updated>2023-12-26T12:32:32.801Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Так случилось, что английский я изучал максимально лениво, ровно настолько насколько он был нужен на практике. Т.е. почти никак. Изучение большого количества слов (которых можно нахвататься откуда угодно) и трёх времён уже достаточно, чтобы ухватывать смысл текстов.</p><p>Для новостей — достаточно понять всего несколько предложений. Для программерских материалов, как книг, так и докладов, тоже необходимо на удивление мало. Ну и по сути, в технических материалах английский используется в служебных целях — максимально просто объяснить идею. Возможно, выраженную неносителями для неносителей. Помимо английского, там используются несколько других нотаций — примеры на языках и псевдоязыках программирования, математические формулы, несколько типов блок схем и графиков. И эти нотации часто важнее, пояснения нужны только там, где нотация оставляет пространство для неоднозначной трактовки. Помимо этого, большая часть важной литературы переводится, или <em>пересказывается</em> русскоязычными авторами. Не вся, часто с опозданием и некачественно, но недостатка в информации не было. Ну и понятно, что серьёзная часть технических знаний просто получается на практике.</p><p>Барьером были только фильмы/сериалы и игры с большим количеством текста, но как раз это достаточно быстро локализуется, так что никогда особо не мешало. Наверное, первый раз столкнулся с тем, что не могу понять книги, когда решил попробовать изучать материалы по геймдизайну, чтобы разобраться, как работают мобильные/социальные (ну и современные сессионные тоже) игры. Есть отличный перевод Джесси Шелла, но дальше — пустота, в которой находятся и некоторые профессиональные геймдизайнеры.</p><p>Ключевой автор — Николас Ловелл, на русский не переводился, и даже не смотря на то, что у него есть вполне доступные доклады и cheet-sheet (<code>The F2P Toolbox</code>), основная книга <code>The Pyramid of Game Design</code> не переведена. Сложности возникли от того, что автор, кроме профессионального сленга геймдева, использует экономический, а помимо этого больше использует британский, а не американский английский, а также, видимо, не особо старался адаптировать книгу для иностранных читателей. В общем, пришлось читать и переводить её со словарём, каждой отдельное предложение. Получилось выписать около 1500 слов. По итогу я даже зачем-то отправил Ловеллу мейл с благодарностью и рассказом, как я задолбался её переводить. Неожиданно, он даже ответил и сказал, что пообщался со своим издателем и разрешил выложить три главы перевода, если будет желание. Более лайтовый вариант — <code>Designing Virtual Worlds</code> Ричарда Бартла. Немного устаревшая в технической части, но по прежнему интересная и сейчас как исследование сообществ игроков MMO игр. Наверное, эти две книги (<em>ну,и эмиграция…</em>) подвели к мысли, что пора бы разобраться не только с переводом слов.</p><h2 id="Грамматика"><a href="#Грамматика" class="headerlink" title="Грамматика"></a>Грамматика</h2><p>До этого я пробовал заниматься на онлайн платформе skyeng (бонусом от работодателя), но без особой пользы, разговаривать на базовом уровне получалось уже и так, но особого прогресса в этом не наблюдалось. Хотелось найти что-то отличное от коммуникативного подхода. Ну и собственно, нашёл <a href="https://habr.com/ru/users/LeonidFirstov/publications/articles/" target="_blank" rel="noopener">CT-School</a>. Описанное сильно отличалось от стандартного подхода, и совпадало с тем, что мне казалось было нужно.</p><ul><li>разбор грамматики не минимально, а хорошо. Знание слов и выражений полезно (и легче даётся) поверх этого. Теория &gt; практика в начале</li><li>говорящий с тобой на одном языке преподаватель лучше носителя, так как может объяснить связи между языками</li><li>преподаватель нужен</li><li>ощутимый прогресс должен быть быстрее, чем за полгода-год, как на “разговорных” курсах</li><li>учиться лучше в короткий промежуток времени (<a href="https://ailev.livejournal.com/1130190.html" target="_blank" rel="noopener">Как зажечь мастерство</a>)</li></ul><p>Сама методика тоже сильно отличается от стандартного подхода:</p><ul><li>занятия “до талого”, пока не разобрана тема, иногда по 4 часа</li><li>небольшое количество точных формулировок, заучиваются за время занятий, нет требований учить что-то самостоятельно</li><li>курс начинается с самого начала, но достаточно быстро разгоняется. Полезно для заполнения пробелов в знаниях</li><li>пропускать занятия нельзя, домашние задания обязательны к выполнению и тщательно проверяются. Шанс не обучиться минимальный</li></ul><p>На занятиях разбираются упражнения из  <code>Grammar In Use</code> Мерфи, и <code>Round Up</code> 4 уровня.</p><p>В дополнение я занимался тем, что смотрел видео <a href="https://www.engvid.com/topic/grammar/" target="_blank" rel="noopener">engVid</a></p><p>Самое главное - <code>ChatGPT</code>, как “компилятор” естественного языка. Удобно скармливать ему грамматические конструкции и просить проверить “а можно ли так”, и просить генерировать примеры использования.<br>(Например <em>There lived a hobbit</em> vs <em>There lived the hobbit</em> — второе тоже возможно, но будет означать немного другое)<br><img src="/blog/2455145615/t2.png" alt=""><br><em>ии никогда не устанет, не накричит, не скажет что занят и ему некогда, он всегда будет рядом…</em></p><p>В какой-то момент ощутил “формульность” грамматического языка, какие-то слова или конструкции имеют <em>валентность</em>, и прикрепляют к себе другие готовые куски. Ну и понимание, с каким массивом информации вообще столкнулся, прошло ощущение, что нужно только немного заполнить пробелы.</p><p>Для практики перевода с русского на английский - <code>Современная английская грамматика</code> Комаровской. Там подобраны несколько типов предложений — коряво звучащие на русском, но “сворачивающиеся” в элегантные на английском, и наоборот, сложные русские, не имеющие буквального перевода. Полезно, чтобы научиться выбирать максимально близкий перевод слова на английский.</p><h2 id="Чтение"><a href="#Чтение" class="headerlink" title="Чтение"></a>Чтение</h2><ul><li>Толкиен как энциклопедия языка. Читаю с целью подмечать нестандартные предложения и разбирать их</li><li>Книжки по методу Франка. Вроде удобно иметь перевод без напряга, но читать особо некогда</li><li>Газеты и новости. Современный язык в плане слов, но грамматически часто свой отдельный стиль</li><li>Книжки с близким к разговорному языком. Примеры — <code>Sh*t my dad says</code> Justin Hulpers, <code>The lost continent, travels in small town America</code> Bill Bryson.</li><li>История английского языка. <code>Приключения английского языка</code> Брэгг М.</li></ul><h2 id="Аудирование"><a href="#Аудирование" class="headerlink" title="Аудирование"></a>Аудирование</h2><p><a href="https://www.youtube.com/@PhoneticFanatic" target="_blank" rel="noopener">PhoneticPhanatic</a> — для начала, можно научиться правильны <em>слышать</em> звуки. Безумно крутой дядька<br><a href="https://www.youtube.com/@dailydictation" target="_blank" rel="noopener">Daily Dictation</a> — упражнения<br><a href="https://www.languagereactor.com/m/yt_en_-" target="_blank" rel="noopener">Language Reactor</a> — ролики на ютубе с двойными субтитрами, и возможностью настроить паузы/хоткеи на отдельные фразы<br><a href="https://youglish.com/" target="_blank" rel="noopener">Youglish</a> — находит ролики на ютубе, в которых можно послушать варианты произношения слова или фразы</p><p>Для себя поставил целью научиться слушать профессиональные подкасты:<br><a href="https://eggplant.show/into-the-depths-super-mario-world-part-1" target="_blank" rel="noopener">Into the Depth: Super Mario World</a> — серия подкастов про <em>Super Mario World</em> от известных инди-разработчиков. Вот прямо очень хороший тест, у ведущих и гостей диалекты из Британии, США, Германии, Австралии и ЮАР.<br><a href="https://www.idlethumbs.net/designernotes" target="_blank" rel="noopener">Designer Notes</a> — не знаю автора, но регулярно зовёт к себе гостей типа Сида Мейера или Криса Авеллона<br><a href="https://www.youtube.com/@jblow888/videos" target="_blank" rel="noopener">Jonathan Blow</a> — стримы, или любые другие материалы, про программирование и инди-разработку</p><p>Из общего — можно слушать локальные радиостанции (non commercial national radio stations).</p><p>Там где было пока сложно, сделал для себя хаки:<br><a href="https://github.com/spiiin/eng_helpers/blob/main/AutoKeyPress.ipynb" target="_blank" rel="noopener">AutoKeyPress</a> — скрипт к плагину <a href="https://addons.videolan.org/p/1154027" target="_blank" rel="noopener">Subtitler lite mod</a>, для отображения одновременно двух субтитров для <code>VLC</code>. Плагин зачем-то требует регулярного нажатия кнопки для обновления вторых субтитров. Классическое “после сборки обработать напильником”.<br><a href="https://github.com/spiiin/eng_helpers/blob/main/Split%20subtitles%20from%20chrome.ipynb" target="_blank" rel="noopener">Split subtitles from chrome</a> — Chrome умеет преобразовывать в текст любой звук из браузера (Live Caption), но отрисовывает текст на отдельном канвасе, с которого нельзя скопировать. Это не очень подходит для учебных целей, но можно включить <a href="https://www.reddit.com/r/chrome/comments/mcw75z/is_there_a_way_to_copy_and_paste_the_text_that_is/" target="_blank" rel="noopener">логгирование событий</a>, в котором среди прочему пролетают и уведомления об изменении текста в этом канвасе. Скрипт позволяет собрать сообщения из этого лога и превратить в осмысленный текст (с некоторым шаманством в виде проверки расстояния Левенштейна и склейки строк после переносов).</p><h2 id="Слова"><a href="#Слова" class="headerlink" title="Слова"></a>Слова</h2><p>Куча приложений с карточками для изучения, но мне чё-то не очень нравится такой метод. Нужно будет какой-нибудь генератор майнд-карт замутить, что ли.<br>Из того, что +/- показалось полезным/интересным</p><ul><li>сканворды. Полно приложений, или просто сайтов с вопросами.</li><li>инструмент отслеживания списка слов в languagereactor. Интегрирован с другими инструментами сайта, окрашивает знакомые, незнакомые, изучаемые и редкие слова разными цветами. + тест, который определяет базовый уровень словарного запаса, чтобы не заполнять с нуля. Требует платной регистрации.</li><li>толковый словарь + chatgpt. Запрос типа “объясни происхождение слова, приведи примеры употребления, синонима и однокоренные слова”.</li></ul><h2 id="Разговор"><a href="#Разговор" class="headerlink" title="Разговор"></a>Разговор</h2><p><a href="https://www.youtube.com/@KirillsEnglish" target="_blank" rel="noopener">Kirill’s English</a> - конкретные фразы для диалогов, произношение звуков и фраз, методология</p><h2 id="Тесты"><a href="#Тесты" class="headerlink" title="Тесты"></a>Тесты</h2><p><a href="https://learnenglish.britishcouncil.org/english-levels/online-english-level-test" target="_blank" rel="noopener">https://learnenglish.britishcouncil.org/english-levels/online-english-level-test</a><br><a href="https://www.kaplaninternational.com/free-english-test-online" target="_blank" rel="noopener">https://www.kaplaninternational.com/free-english-test-online</a><br><a href="https://practicum.yandex.ru/english/placement_test/" target="_blank" rel="noopener">https://practicum.yandex.ru/english/placement_test/</a></p><p>Также у многих онлайн-школ есть бесплатное разговорное занятие с определением уровня.</p><p>Пока получается B1-B1+</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;Так случил
      
    
    </summary>
    
    
    
      <category term="english" scheme="http://spiiin.github.io/tags/english/"/>
    
  </entry>
  
  <entry>
    <title>Формат сжатия уровней в Jurassic Park [NES]</title>
    <link href="http://spiiin.github.io/blog/17440519/"/>
    <id>http://spiiin.github.io/blog/17440519/</id>
    <published>2023-12-19T12:37:09.000Z</published>
    <updated>2024-01-01T12:14:53.341Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Давно не затрагивал тему реверс-инжиниринга NES игр. После разбора блочного формата описания <a href="(https://spiiin.github.io/CadEditor/cadeditor-supported-games.html">уровней</a>), остались несколько игр, отмеченных как <em>comp</em> (уровень в ROM сжат). Сжатие уровней редко используется в играх NES, чаще сжимается текст или данные описания графики. Да и сам блочный формат уровня уже является формой экономии информации.</p><p>Тем не менее некоторые игры используют сжатие <a href="https://en.wikipedia.org/wiki/Run-length_encoding" target="_blank" rel="noopener">RLE</a>. В простых формах, как в <code>Contra</code>, или в более сложных, как в <a href="/blog/1486764983/" title="Felix The Cat">Felix The Cat</a> , где применяется гибрид RLE и словарного метода. Другие применяют формы <strong><code>&quot;описания на холсте&quot;</code></strong>, когда команды отрисовки задаются в виде “нарисуй что-то в координатах X,Y” (описание карты мира в играх <code>Capcom</code> или уровней в <code>Super Mario Bros</code>).</p><p>Это относительно простые алгоритмы. Но отдельные игры идут дальше и применяют более совершенные формы сжатия:</p><p><a href="https://romhack.github.io/doc/halCompression/" target="_blank" rel="noopener">Kirby</a> и другие игры <code>HAL</code> - гибрид LZ алгоритмов и RLE, с несколькими командами вроде “следующие биты развернуть”.<br><a href="https://github.com/romhack/codemastersMarkov" target="_blank" rel="noopener">Dizzy</a> и другие игры <code>Codemasters</code> - сжатие графики цепями Маркова.</p><p>Формат уровней этих игр описан. Однако, в моём списке игр, добавленных в <a href="https://github.com/spiiin/CadEditor/blob/master/CadEditor/cad_editor_supported_games.txt" target="_blank" rel="noopener">CadEditor</a> были ещё две — <code>Jurassic Park</code> и <code>James Bond Jr</code>. Я выбрал для разбора <code>Jurassic Park</code>, потому что знал, что в нём используется разновидность <a href="https://en.wikipedia.org/wiki/LZ77_and_LZ78" target="_blank" rel="noopener">LZ</a>, потому что хотел заодно прочитать про сам алгоритм и его разновидности.</p><a id="more"></a><h2 id="Вступление"><a href="#Вступление" class="headerlink" title="Вступление"></a>Вступление</h2><p>(оно же отступление)</p><p>При исследовании нового ты оказываешься перед уникальной задачей <strong>один на один</strong>. В CadEditor-е есть пара кусков кода, связанных с LZ-сжатием ( <a href="https://spiiin.github.io/CadEditor/cadeditor-using-lzkn.html">LZKN</a>, написанный <code>DrMephisto</code>, и <a href="/blog/1579894033/" title="карты FFTA">карты FFTA</a> авторства <code>DarcyMiles</code>), но я не касался этого алгоритма на NES.</p><p>Я не реверсил NES-игры на протяжении пяти лет, и успел забыть, что это скорее не навык, а состояние. </p><blockquote><p>“Глядя на мерцающие экраны и на безбрежный поток данных, поднятый моими алгоритмами и мчащийся в никуда по виртуальному пространству цифрового мира, я часто думаю: где я в этом потоке битов и байтов?”</p><footer><strong>ChatGPT который плагиатит Анонима который плагиатит Чингизхана</strong></footer></blockquote><p>Когда результат УЖЕ найден, алгоритм кажется тривиальным. Но до этого смотришь на матрицу байт, и бесконечный ассемблерный листинг, вообще без понятия, что перед тобой. Потом, когда нашёл свой Диснейленд (<a href="https://exsistencia.livejournal.com/3261.html" target="_blank" rel="noopener">Бодрийаровский</a>) в пещере, забываешь о состоянии, в котором был, пока смотрел в темноту. Поэтому я ценю описание состояния, а не откомментированный результат.</p><h2 id="Блоки"><a href="#Блоки" class="headerlink" title="Блоки"></a>Блоки</h2><p>Первое, что можно сделать — закинуть в темноту <a href="/blog/2598119234/" title="лидар">лидар</a> (<code>autocorrupter + blockfinder</code>), который покажет “общую форму пещеры”.</p><p>Он отлично работает и на сжатых картах, единственное, что запускать его нужно не на область ROM, а на область RAM, в которой находятся расжатые данные. Он показывает, что:</p><ul><li><p>описание карты уровня расположено по адресам 0x60C8-0x72CB, индексами блоков, по 2 байта на блок. 3 нибла кодируют номер блока, 4-й - физические свойства блока<br>(является ли блок выходом из уровня, препятствием, передним или задним фоном)</p></li><li><p>размер блока 2x2, описание которых асположено по адресам 0x76CC, блоков 352 штуки</p></li><li><p>слой бит палитры блоков описан отдельно от описания блоков. Т.е. любой блок можно окрасить в любую из 4х палитр<br><img src="/blog/17440519/jp_map0_small.png" alt=""></p></li></ul><p>Также обнаруживается интересная особенность — игра переключает активный банк видеопамяти блоков, когда игрок выходит из нижней или верхней трети экрана в центральную часть. Так что блоки с индексами &gt;0x80 могут распологаться только в нижней трети уровня (ими в первом уровне отрисованы здания).<br><img src="/blog/17440519/jp_map1_small.png" alt=""></p><p>(<a href="https://github.com/spiiin/CadEditor/blob/master/CadEditor/settings_nes/jurassic_park/Settings_JurassicPark_1.cs" target="_blank" rel="noopener">Конфиг для CadEditor-а</a>)</p><p>Область 0x1000-0x7FFF - это 6-кб CHR-RAM, память доступная для записи, располагается на картридже, в дополнение к 2кб памяти NES (это один из самых больших <a href="https://nescartdb.com/profile/view/1038/jurassic-park" target="_blank" rel="noopener">картриджей</a>)</p><h2 id="Декомпрессия"><a href="#Декомпрессия" class="headerlink" title="Декомпрессия"></a>Декомпрессия</h2><p>Если поставить брейкпоинт на запись в 0x60C8 (это значение прописано в игре хардкодом как область распаковки), можно выйти на адрес архива в ROM - 0x9D94 (адрес записан в ячейки памяти 95-96).</p><p>Также, изучай трейслог между чтением байта из ROM и записью в RAM, стоит запомнить все ячейки, которые изменяются походу — 6F, 70, 73, 74, 75.<br>(<em>меня восхищает, что трейслог команд на ассемблере 6502 может разобрать chatgpt, очень интересно было бы узнать, на каких входных данных он обучился</em>)</p><p>Первые байты архива в ROM и соответствующие им байты распакованных данных:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x9D94: 18 00 20 04 0C 84 00 64</span><br><span class="line">0x60C8: 30 00 30 00 06 84 00 84</span><br></pre></td></tr></table></figure></p><p>Пока что связь между сжатыми данными и расжатыми неочевидна. Просто изменять наугад байты архива в ROM (например 0x648C) бесполезно, меняется большая группа распакованных данных, на стенках нашей тёмной пещеры из байт оказывается калейдоскоп из зеркал, отражающих лучи по непредсказуемым траекториям<br><img src="/blog/17440519/jp3.png" alt=""></p><p>Более изящный способ — написать lua-скрипт для эмулятора, который будет трассировать в файл все чтения из архива и записи распакованных данных, а также состояние управляющих распаковкой ячеек.</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> logFile = <span class="built_in">io</span>.<span class="built_in">open</span>(<span class="string">"jp_unpack1.txt"</span>, <span class="string">"w"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">readMemoryValues</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        memory.readbyte(<span class="number">0x73</span>),</span><br><span class="line">        memory.readbyte(<span class="number">0x74</span>),</span><br><span class="line">        memory.readbyte(<span class="number">0x75</span>),</span><br><span class="line">        memory.readbyte(<span class="number">0x6F</span>),</span><br><span class="line">        memory.readbyte(<span class="number">0x70</span>)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">logMemoryOperation</span><span class="params">(operation, address, value)</span></span></span><br><span class="line">    <span class="keyword">local</span> values = readMemoryValues()</span><br><span class="line">    logFile:<span class="built_in">write</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">"%s %04X %s %02X --- 73: %02X, 74: %02X, 75: %02X, 6F: %02X, 70: %02X\n"</span>,</span><br><span class="line">                                operation, address, operation == <span class="string">"WRITE"</span> <span class="keyword">and</span> <span class="string">"-&gt;"</span> <span class="keyword">or</span> <span class="string">"&lt;-"</span>, value,</span><br><span class="line">                                <span class="built_in">table</span>.<span class="built_in">unpack</span>(values)))</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">onRead</span><span class="params">(address, size, value)</span></span></span><br><span class="line">    logMemoryOperation(<span class="string">"READ "</span>, address, value)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">onWrite</span><span class="params">(address, size, value)</span></span></span><br><span class="line">    logMemoryOperation(<span class="string">"WRITE"</span>, address, value)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">onWriteExt</span><span class="params">(address, size, value)</span></span></span><br><span class="line">    logMemoryOperation(<span class="string">"     "</span>, address, value)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">registerMemoryCallbacks</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> readRangeStart, readRangeEnd = <span class="number">0x9D94</span>, <span class="number">0xA4B1</span></span><br><span class="line">    <span class="keyword">local</span> writeRangeStart, writeRangeEnd = <span class="number">0x60C8</span>, <span class="number">0x72CB</span></span><br><span class="line">    <span class="keyword">local</span> extendedWriteAddresses = &#123;<span class="number">0x6F</span>, <span class="number">0x70</span>, <span class="number">0x73</span>, <span class="number">0x74</span>, <span class="number">0x75</span>&#125;</span><br><span class="line"></span><br><span class="line">    memory.registerread(readRangeStart, readRangeEnd - readRangeStart + <span class="number">1</span>, onRead)</span><br><span class="line">    memory.registerwrite(writeRangeStart, writeRangeEnd - writeRangeStart + <span class="number">1</span>, onWrite)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, address <span class="keyword">in</span> <span class="built_in">ipairs</span>(extendedWriteAddresses) <span class="keyword">do</span></span><br><span class="line">        memory.registerwrite(address, <span class="number">1</span>, onWriteExt)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">registerMemoryCallbacks()</span><br><span class="line"></span><br><span class="line">emu.registerexit(<span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">if</span> logFile <span class="keyword">then</span></span><br><span class="line">        logFile:<span class="built_in">close</span>()</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>)</span><br></pre></td></tr></table></figure><p>Получается такой лог (большая часть незначащей информации вырезана)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">READ  9D94 &lt;- 18    --- 73: 00, 74: 00, 75: 00, 6F: 00, 70: 00</span><br><span class="line">READ  9D95 &lt;- 00    --- 73: 00, 74: 02, 75: 00, 6F: 18, 70: 00</span><br><span class="line">   WRITE 60C8 -&gt; 30 --- 73: 00, 74: 00, 75: 00, 6F: 30, 70: 00</span><br><span class="line">READ  9D96 &lt;- 20    --- 73: 00, 74: 03, 75: 00, 6F: 00, 70: 00</span><br><span class="line">   WRITE 60C9 -&gt; 00 --- 73: 80, 74: 00, 75: 00, 6F: 00, 70: 00</span><br><span class="line">                 75 --- 73: 00, 74: 00, 75: 02, 6F: 02, 70: 00</span><br><span class="line">                 74 --- 73: 00, 74: 0A, 75: 02, 6F: 02, 70: 00</span><br><span class="line">                 73 --- 73: 00, 74: 0A, 75: 02, 6F: 02, 70: 00</span><br><span class="line">                 6F --- 73: 00, 74: 0A, 75: 02, 6F: 04, 70: 00</span><br><span class="line">                 70 --- 73: 00, 74: 0A, 75: 02, 6F: 04, 70: 00</span><br><span class="line">                 74 --- 73: 00, 74: 09, 75: 02, 6F: 04, 70: 00</span><br><span class="line">                 73 --- 73: 00, 74: 09, 75: 02, 6F: 04, 70: 00</span><br><span class="line">                 6F --- 73: 00, 74: 09, 75: 02, 6F: 08, 70: 00</span><br><span class="line">                 70 --- 73: 00, 74: 09, 75: 02, 6F: 08, 70: 00</span><br><span class="line">                 74 --- 73: 00, 74: 08, 75: 02, 6F: 08, 70: 00</span><br><span class="line">                 73 --- 73: 00, 74: 08, 75: 02, 6F: 08, 70: 00</span><br><span class="line">                 6F --- 73: 00, 74: 08, 75: 02, 6F: 10, 70: 00</span><br><span class="line">                 70 --- 73: 00, 74: 08, 75: 02, 6F: 10, 70: 00</span><br><span class="line">                 74 --- 73: 00, 74: 07, 75: 02, 6F: 10, 70: 00</span><br><span class="line">                 73 --- 73: 00, 74: 07, 75: 02, 6F: 10, 70: 00</span><br><span class="line">                 6F --- 73: 00, 74: 07, 75: 02, 6F: 20, 70: 00</span><br><span class="line">                 70 --- 73: 00, 74: 07, 75: 02, 6F: 20, 70: 00</span><br><span class="line">READ  9D97 &lt;- 04    --- 73: 00, 74: 07, 75: 02, 6F: 20, 70: 00</span><br><span class="line">   WRITE 60CA -&gt; 30 --- 73: 00, 74: 00, 75: 02, 6F: 01, 70: 00</span><br><span class="line">   WRITE 60CB -&gt; 00 --- 73: 00, 74: 00, 75: 01, 6F: 01, 70: 00</span><br><span class="line">READ  9D98 &lt;- 0C    --- 73: 00, 74: 08, 75: 00, 6F: 04, 70: 00</span><br><span class="line">   WRITE 60CC -&gt; 06 --- 73: 00, 74: 00, 75: 00, 6F: 06, 70: 00</span><br><span class="line">READ  9D99 &lt;- 84    --- 73: 00, 74: 01, 75: 00, 6F: 0C, 70: 00</span><br><span class="line">READ  9D9A &lt;- 00    --- 73: 00, 74: 01, 75: 00, 6F: 84, 70: 00</span><br><span class="line">   WRITE 60CD -&gt; 84 --- 73: 00, 74: 00, 75: 00, 6F: 84, 70: 00</span><br><span class="line">READ  9D9B &lt;- 64    --- 73: 00, 74: 02, 75: 00, 6F: 00, 70: 00</span><br><span class="line">   WRITE 60CE -&gt; 00 --- 73: C8, 74: 00, 75: 00, 6F: 00, 70: 00</span><br><span class="line">READ  9D9C &lt;- 01    --- 73: 00, 74: 09, 75: 03, 6F: 64, 70: 00</span><br><span class="line">READ  9D9D &lt;- 00    --- 73: 00, 74: 01, 75: 03, 6F: 01, 70: 64</span><br><span class="line">   WRITE 60CF -&gt; 84 --- 73: 00, 74: 00, 75: 03, 6F: 01, 70: 00</span><br><span class="line">   WRITE 60D0 -&gt; 00 --- 73: 00, 74: 00, 75: 02, 6F: 01, 70: 00</span><br><span class="line">   WRITE 60D1 -&gt; 84 --- 73: 00, 74: 00, 75: 01, 6F: 01, 70: 00</span><br><span class="line">READ  9D9E &lt;- A1    --- 73: 00, 74: 02, 75: 00, 6F: 00, 70: 00</span><br></pre></td></tr></table></figure><p>Из этого лога уже можно извлечь почти всё, что нужно для понимания распаковки.</p><p>Это очень важный момент! Можно реверс-инжинирить алгоритм в IDA, или долго играться с отладчиком. А можно и не делать этого и перечитать раздел “вступление” ещё раз. <strong>РЕВЕРС НЕ НАВЫК, А СОСТОЯНИЕ</strong>. Т.е. можно обнаружить, что ты уже знаешь решение, просто глядя на трейс-лог, или гуляя по улице — это не фигура речи. Для проверки правильности решения придётся, конечно, использовать листик и ручку, или отладчик, и скорее всего первичная идея будет содержать ошибки, на само понимание находится где-то до использования инструментов. Всё, что дальше — уже просто проверка, тривиальная часть.</p><ul><li><p>Байты на выход выдаются не сразу после команды чтения, а с задержкой на какие-то операции, т.е. скорее всего команды кодируются некратным 8 числом бит</p></li><li><p>в ячейке 75 хранится число байт, который будут скопированы из самого выходного потока. Так как это значение не зависит от других управляющих ячеек, вероятно, существуют специальные команды, в которых количество повторов кодируется самой командой. Это важный вывод, который можно и нужно перепроверить</p></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">07:D4B0: A9 02     LDA #$02 &#x2F;&#x2F;immediate set</span><br><span class="line">07:D4B2: 85 75     STA $75 repeats &#x3D; #$02</span><br></pre></td></tr></table></figure><ul><li>в ячейке 74 — количество оставшихся для считывания бит для текущей команды. Если при этом “заканчиваются” биты в очередном байте из входной последовательности, считывается следующий</li></ul><p>Осталось разобрать, как именно работают команды, выдающие в выходой поток значения, которые уже находились в нём ранее.<br>Можно поставить точки остановки на область записи распакованных данных и внимательно посмотреть на байты на выходе в тех случаях, когда они не читаются из входного архива.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WRITE 60C8 -&gt; 30  &lt;-----------\</span><br><span class="line">WRITE 60C9 -&gt; 00              |</span><br><span class="line">WRITE 60CA -&gt; 30 00 (2 байта) |</span><br><span class="line">WRITE 60CC -&gt; 06</span><br><span class="line">WRITE 60CD -&gt; 84  &lt;--------------\</span><br><span class="line">WRITE 60CE -&gt; 00                 |</span><br><span class="line">WRITE 60CF -&gt; 84 00 84 (3 байта) |</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>Это и есть основной принцип работы алгоритма <code>LZSS</code> — он умеет ссылаться на уже существующие в выходной последовательности цепочки байт.</p><p>Можно заодно обратить внимание на интересную особенность — цепочка байт 60CF-60D1 использует ссылку на 60CD-60CF - конец этой цепочки еще не существует в выходной последовательности к моменту использования ссылки на неё (<code>overlapping-lookingahead</code>).</p><p><code>LZSS</code> можно считать обобщением <code>RLE</code> — <code>RLE</code> умеет ссылаться лишь 1 последний символ в выходной последовательности, а <code>LZSS</code> — на любую уже встреченную цепочку символов. Различные разновидности <code>LZSS</code>, в зависимости от выделенных на кодирование бит, ограничены в том, насколько далеко назад они могут заглянуть (<strong><code>размер скользящего окна</code></strong>) и на длину цепочки повторяющихся байт.</p><p>Раз входной поток работает на уровне бит, а не байт, то удобно было бы представить его в трейслоге в виде бит. Можно или вписать дополнительную информацию в скрипт трейса (чаще всего работа с битами осуществляется через сдвиги + проверку флага, в который попадаёт сдвинутый бит). Ну или просто набросать скрипт, который парсит уже имеющийся лог, но следит при этом за накопленными битами:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract_byte_from_read_line</span><span class="params">(line)</span>:</span></span><br><span class="line">    hex_value = line.split(<span class="string">'&lt;-'</span>)[<span class="number">1</span>].strip()[:<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">return</span> format(int(hex_value, <span class="number">16</span>), <span class="string">'08b'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract_argument_from_74_line</span><span class="params">(line)</span>:</span></span><br><span class="line">    hex_argument = line.split(<span class="string">'74:'</span>)[<span class="number">1</span>].split(<span class="string">','</span>)[<span class="number">0</span>].strip()</span><br><span class="line">    <span class="keyword">return</span> int(hex_argument, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_write_command</span><span class="params">(accumulated_bits)</span>:</span></span><br><span class="line">    bit_string = <span class="string">''</span>.join(accumulated_bits)</span><br><span class="line">    print(<span class="string">f"<span class="subst">&#123;bit_string&#125;</span> (<span class="subst">&#123;len(accumulated_bits)&#125;</span> bits)"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_and_print_bits</span><span class="params">(lines)</span>:</span></span><br><span class="line">    current_byte = <span class="literal">None</span></span><br><span class="line">    bit_index = <span class="number">0</span></span><br><span class="line">    accumulated_bits = []</span><br><span class="line">    command_lengths = set()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        line = line.strip()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> line.startswith(<span class="string">'READ'</span>):</span><br><span class="line">            current_byte = extract_byte_from_read_line(line)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> line.startswith(<span class="string">'74 ---'</span>):</span><br><span class="line">            argument = extract_argument_from_74_line(line)</span><br><span class="line">            <span class="keyword">if</span> argument != <span class="number">0</span> <span class="keyword">and</span> current_byte <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                accumulated_bits.append(current_byte[bit_index])</span><br><span class="line">                bit_index = (bit_index + <span class="number">1</span>) % <span class="number">8</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> line.startswith(<span class="string">'WRITE'</span>):</span><br><span class="line">            <span class="keyword">if</span> accumulated_bits:</span><br><span class="line">                command_lengths.add(len(accumulated_bits))</span><br><span class="line">                process_write_command(accumulated_bits)</span><br><span class="line">                print(<span class="string">"  "</span> + line.split(<span class="string">"---"</span>)[<span class="number">0</span>])</span><br><span class="line">            accumulated_bits = []</span><br><span class="line">            </span><br><span class="line">    print(<span class="string">f"Commands lengths: <span class="subst">&#123;command_lengths&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"jp_unpack_60C8_72CB.txt"</span>, <span class="string">"rt"</span>) <span class="keyword">as</span> file:</span><br><span class="line">    lines = file.readlines()</span><br><span class="line">parse_and_print_bits(lines)</span><br></pre></td></tr></table></figure><p>(тривиальная логика, следим за состоянием 74 - ячейки которая контроллирует, сколько бит осталось прочитать в текущей команде)</p><p>Обнаруживаем, что есть всего 4 типа команд - из 9, 13, 15 и 23 бит:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">000110000 (9 bits)</span><br><span class="line">  WRITE 60C8 -&gt; 30</span><br><span class="line">100000000001 (12 bits)</span><br><span class="line">  WRITE 60CA -&gt; 30 </span><br><span class="line">  WRITE 60CB -&gt; 00</span><br><span class="line">110010000000001 (15 bits)</span><br><span class="line">  WRITE 60CF -&gt; 84 </span><br><span class="line">  WRITE 60D0 -&gt; 00 </span><br><span class="line">  WRITE 60D1 -&gt; 84</span><br><span class="line">11000000001100001011101 (23 bits)</span><br><span class="line">  WRITE 729F -&gt; 84 </span><br><span class="line">  WRITE 72A0 -&gt; 3A </span><br><span class="line">  WRITE 72A1 -&gt; 84 </span><br><span class="line">  WRITE 72A2 -&gt; 3A </span><br><span class="line">  WRITE 72A3 -&gt; 84 </span><br><span class="line">  WRITE 72A4 -&gt; 3A </span><br><span class="line">  WRITE 72A5 -&gt; 84 </span><br><span class="line">  WRITE 72A6 -&gt; 3A </span><br><span class="line">  WRITE 72A7 -&gt; 84 </span><br><span class="line">  WRITE 72A8 -&gt; 3A </span><br><span class="line">  WRITE 72A9 -&gt; 84 </span><br><span class="line">  WRITE 72AA -&gt; 3A </span><br><span class="line">  WRITE 72AB -&gt; 84 </span><br><span class="line">  WRITE 72AC -&gt; 34 </span><br><span class="line">  WRITE 72AD -&gt; 84</span><br></pre></td></tr></table></figure><p>Такого лога достаточно для расшифровки формата команд (в полном логе их сотни)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 00110000</span><br><span class="line">команда выдачи несжатого байта из входного потока, 0 - код команды</span><br><span class="line"></span><br><span class="line">10 0000000001</span><br><span class="line">команда копирования 2х байт (2 - константа, не закодировано в команде)</span><br><span class="line">Биты 10 - код команды</span><br><span class="line">Байты считываются по 10-битному смещению назад от текушей позиции выходного потока</span><br><span class="line"></span><br><span class="line">11000 00000110 0001011101</span><br><span class="line">команда копирования 9+X байт из выходного потока</span><br><span class="line">Биты 11000 - код команды</span><br><span class="line">Количество закодировано 8 битами (9+0b00000110 &#x3D; 15 байт)</span><br><span class="line">Смещение закодировано 10 битами</span><br><span class="line"></span><br><span class="line">11 001 0000000001</span><br><span class="line">команда копирования 2+X байт из выходного потока</span><br><span class="line">Количество закодировано 3 битами - (2+0b001 &#x3D; 3 байта)</span><br><span class="line">Смещение закодировано 10 битами</span><br></pre></td></tr></table></figure></p><p>Или в виде блок-схемы:<br><img src="/blog/17440519/diagram.png" alt=""></p><p>4612 байт карты сжимаются этим алгоритмом в 1822 байт архива.</p><h2 id="Семейство-LZSS"><a href="#Семейство-LZSS" class="headerlink" title="Семейство LZSS"></a>Семейство LZSS</h2><p>В отличие от классического <a href="https://ru.wikipedia.org/wiki/LZSS" target="_blank" rel="noopener">LZSS</a>, здесь использованы 3 типа команд копирования фразы разной длины, чтобы сэкономить немного места на более коротких повторяющихся последовательностях.</p><p>Алгоритм активно использовался еще как минимум 2 поколения консолей, так что похожие трюки и вариации можно найти в большинстве компрессоров для Sega Mega Drive или SNES:<br><a href="https://github.com/lab313ru/lzkn" target="_blank" rel="noopener">lzkn</a> — 3 варианта сжатия <code>Konami</code><br><a href="https://github.com/flamewing/mdcomp" target="_blank" rel="noopener">mdcomp</a> — компрессоры из <code>Sonic</code> (Kosinski, Nemesis, Saxman и другие). Generic код, с поддержкой нескольких вариантов алгоритма.</p><p>Отличия в вариациях алгоритмов:</p><ul><li>Часто биты команд сгруппированаы в отдельные байты (description fields), а не перемешаны с битами данных. Связано это с тем, что считывать и работать с целыми байтами быстрее — можно передать 8 несжатых байт выравненными блоками</li><li>С этим же связана подстройка размера команд и сжатых данных под выравнивание</li><li>Биты/байты команд могут вообще храниться в отдельном потоке, независимом от потока аргументов этих команд (смещений и длин цепочек). Опционально — в little или big-endian.</li><li>Некоторые вариации умеют брать данные не только из окна выходного буфера, а откуда-нибудь ещё (захардкоженные словари или просто нули)</li><li>Небольшие отличия в порядке хранения байт данных и байт команд из сжатого потока:<ul><li>пишется ли следующий байт команд сразу, как заканчиваются биты предыдущего, или только когда потребуются новые биты </li><li>необходим ли финальный байт команд (например, если в нём могут содержаться биты окончания потока)</li></ul></li></ul><p>В <strong><code>mdcomp</code></strong> эти настройки вынесены в шаблонный класс-адаптор <a href="https://github.com/flamewing/mdcomp/blob/26bfc205b96afe04e0941d3092865eaf6c972f81/include/mdcomp/lzss.hh#L223" target="_blank" rel="noopener">LZSSAdaptor</a></p><p>Кроме различий в кодировании команд могут отличаться также и алгоритмы компрессии. Большинство компрессоров реализуют примитивный алгоритм поиска подстроки в скользящем окне. Возможные оптимизации:</p><ul><li>использование структур для более быстрого поиска подстроки (<a href="https://github.com/flamewing/mdcomp/blob/26bfc205b96afe04e0941d3092865eaf6c972f81/include/mdcomp/lzss.hh#L223" target="_blank" rel="noopener">сравнение</a>).</li><li>проверка не только самой длинной подстроки, не и более коротких — с набором укороченных команд это может дать лучший результат (<a href="https://sonicresearch.org/community/index.php?threads/konami-compression-tools.5937/#post-84424" target="_blank" rel="noopener">пример</a> для Kosinki)</li><li>учёт самопересечения цепочки — байт начала цепочки, выданные в выходной буфер, могут служить концом этой же цепочки (<a href="https://stackoverflow.com/questions/31347593/matches-overlapping-lookahead-on-lz77-lzss-with-suffix-trees" target="_blank" rel="noopener">overlapping-lookahead</a>)</li></ul><p>Репо со скриптами и логами<br><a href="https://github.com/spiiin/nes_compression/tree/main/jurassic_park" target="_blank" rel="noopener">https://github.com/spiiin/nes_compression/tree/main/jurassic_park</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Давно не затрагивал тему реверс-инжиниринга NES игр. После разбора блочного формата описания &lt;a href=&quot;(https://spiiin.github.io/CadEditor/cadeditor-supported-games.html&quot;&gt;уровней&lt;/a&gt;), остались несколько игр, отмеченных как &lt;em&gt;comp&lt;/em&gt; (уровень в ROM сжат). Сжатие уровней редко используется в играх NES, чаще сжимается текст или данные описания графики. Да и сам блочный формат уровня уже является формой экономии информации.&lt;/p&gt;
&lt;p&gt;Тем не менее некоторые игры используют сжатие &lt;a href=&quot;https://en.wikipedia.org/wiki/Run-length_encoding&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;RLE&lt;/a&gt;. В простых формах, как в &lt;code&gt;Contra&lt;/code&gt;, или в более сложных, как в &lt;a href=&quot;/blog/1486764983/&quot; title=&quot;Felix The Cat&quot;&gt;Felix The Cat&lt;/a&gt; , где применяется гибрид RLE и словарного метода. Другие применяют формы &lt;strong&gt;&lt;code&gt;&amp;quot;описания на холсте&amp;quot;&lt;/code&gt;&lt;/strong&gt;, когда команды отрисовки задаются в виде “нарисуй что-то в координатах X,Y” (описание карты мира в играх &lt;code&gt;Capcom&lt;/code&gt; или уровней в &lt;code&gt;Super Mario Bros&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Это относительно простые алгоритмы. Но отдельные игры идут дальше и применяют более совершенные формы сжатия:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://romhack.github.io/doc/halCompression/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Kirby&lt;/a&gt; и другие игры &lt;code&gt;HAL&lt;/code&gt; - гибрид LZ алгоритмов и RLE, с несколькими командами вроде “следующие биты развернуть”.&lt;br&gt;&lt;a href=&quot;https://github.com/romhack/codemastersMarkov&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Dizzy&lt;/a&gt; и другие игры &lt;code&gt;Codemasters&lt;/code&gt; - сжатие графики цепями Маркова.&lt;/p&gt;
&lt;p&gt;Формат уровней этих игр описан. Однако, в моём списке игр, добавленных в &lt;a href=&quot;https://github.com/spiiin/CadEditor/blob/master/CadEditor/cad_editor_supported_games.txt&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CadEditor&lt;/a&gt; были ещё две — &lt;code&gt;Jurassic Park&lt;/code&gt; и &lt;code&gt;James Bond Jr&lt;/code&gt;. Я выбрал для разбора &lt;code&gt;Jurassic Park&lt;/code&gt;, потому что знал, что в нём используется разновидность &lt;a href=&quot;https://en.wikipedia.org/wiki/LZ77_and_LZ78&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LZ&lt;/a&gt;, потому что хотел заодно прочитать про сам алгоритм и его разновидности.&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="nes" scheme="http://spiiin.github.io/tags/nes/"/>
    
      <category term="hack" scheme="http://spiiin.github.io/tags/hack/"/>
    
  </entry>
  
  <entry>
    <title>Подсветка daScript для hexo</title>
    <link href="http://spiiin.github.io/blog/3460926079/"/>
    <id>http://spiiin.github.io/blog/3460926079/</id>
    <published>2023-09-28T10:21:41.000Z</published>
    <updated>2023-09-28T10:50:22.738Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>daScript в <code>vscode</code> для подсветки может использовать файл с описанием <a href="https://github.com/GaijinEntertainment/vscode-dascript/blob/master/syntaxes/dascript.tmLanguage.yaml" target="_blank" rel="noopener">синтаксиса</a>, или <a href="https://github.com/profelis/daScript-plugin" target="_blank" rel="noopener">language server</a> (само хост приложение знает больше о своих данных и коде, чтобы подсказывать редактору).</p><p>Формат описания синтаксиса языков подсветки для <code>hexo</code> отличается, поэтому всё время до этого я использовал для подсветки похожие на <code>daScript</code> языки — <code>c++, python, ml</code>. Я немного повозился с попытками перевода, но решил попробовать взять результаты от самой <code>vscode</code>. Она не предназначена для того, чтобы работать со сторонними скриптами в двустороннем режиме (принимать данные и отдавать обратно), но и не запрещает сделать это.</p><p><a href="https://github.com/spiiin/hexo_vscode_dascript_highlight/tree/main/highlight-server" target="_blank" rel="noopener">Наколенный плагин</a> - добавляет команду <strong><code>Start highlight server</code></strong>, которая стартует http-сервер и слушает порт, по которому можно передать текст для подсветки.<br>Для работы плагина необходимы:</p><ul><li>один из указанных выше <a href="https://marketplace.visualstudio.com/items?itemName=eguskov.dascript" target="_blank" rel="noopener">плагинов для подсветки в vscode</a></li><li>плагин <a href="https://github.com/d3v-one/vscode-paste-special" target="_blank" rel="noopener">Paste special</a>, который позволяет заменить подсвеченный код на его html эквивалент</li></ul><p><a href="https://github.com/spiiin/hexo_vscode_dascript_highlight/blob/main/highlight-client/hexo_search_all_post_snippets.py" target="_blank" rel="noopener">Клиент на python</a> - тоже наколенный скрипт, который проходит по всем постам моего блога, и заменяет сниппеты кода на их html эквивалент в сгенерированной статической версии (чтобы не потерять исходник). Криво и косо, но выполняет задачу, теперь код постом про <a href="https://spiiin.github.io/tags/dascript/">daScript</a> подсвечен красивее.</p><p><img src="/blog/3460926079/fix_small.png" alt=""></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;daScript в
      
    
    </summary>
    
    
    
      <category term="log" scheme="http://spiiin.github.io/tags/log/"/>
    
      <category term="hexo" scheme="http://spiiin.github.io/tags/hexo/"/>
    
      <category term="dascript" scheme="http://spiiin.github.io/tags/dascript/"/>
    
  </entry>
  
  <entry>
    <title>daScript. BGFX и WeightedBlended Order-Independent Transparency</title>
    <link href="http://spiiin.github.io/blog/3778037319/"/>
    <id>http://spiiin.github.io/blog/3778037319/</id>
    <published>2023-09-19T13:24:06.000Z</published>
    <updated>2023-09-28T08:50:10.252Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p><a href="https://github.com/bkaradzic/bgfx" target="_blank" rel="noopener">bgfx</a> - обёртка над низкоуровневыми графическими api (все основные под desktop, телефоны и web).<br><a href="https://github.com/borisbat/dasBGFX" target="_blank" rel="noopener">dasBGFX</a> - байндинги библиотеки к daScript.</p><p><code>bgfx</code> умеет использовать <code>glfw</code> или <code>sdl</code> для создания окна, <code>dasBGFX</code> использует <code>dasGlfw</code>. Также модуль содержит DSL для трансляции шейдеров с daScript-like языка на BGFX (glsl-like)</p><p>В качестве инструкции по сборке можно использовать заметки:<br><a href="/blog/3006126295/" title="daScript - live-режим">daScript - live-режим</a> - сборка с glfw<br><a href="/blog/4060902549/" title="daScript. SFML, dasBox и semi-transparent render target">daScript. SFML, dasBox и semi-transparent render target</a> - сборка байндингов для sfml</p><p>По аналогии:</p><ul><li>выкачиваем сабмодули из git</li><li>включаем дефайны в cmake</li><li>добавляем зависимости от модулей dasGlfw и dasBGFX в какой-нибудь из тестовых проектов</li><li>перегенерируем решение</li><li>проверяем, что настройках проекта добавились пути к include и lib от модулей</li><li>запускаем простые <a href="https://github.com/borisbat/dasBGFX/blob/main/examples/01_hello_triangle.das" target="_blank" rel="noopener">примеры</a></li></ul><h2 id="Независимая-от-порядка-рендера-полупрозрачность"><a href="#Независимая-от-порядка-рендера-полупрозрачность" class="headerlink" title="Независимая от порядка рендера полупрозрачность"></a>Независимая от порядка рендера полупрозрачность</h2><p>Попробуем портировать чуть более сложный пример - <code>Weighted Blended Order-Independent Transparency</code> с <code>bgfx</code> (иначе вообще зачем он нужен?)</p><p>Очень кратко об идее:<br>“Традиционный” рендер полупрозрачных полигонов чувствителен и порядку рендера, для корректного смешивания необходимо выводить объекты от дальнего к ближнему по отношению к наблюдателю. Это не всегда удобно, так как:</p><ul><li>объекты могут быть “сплетены”, из-за чего их невозможно отсортировать</li><li>трата времени на сортировку<br><em>непрозрачные объекты могут при определенных условиях требовать рендеринга как полупрозрачные - забор с дырками на большом отдалении может содержать прозрачный и непрозрачный полигон, и начать “просвечивать”</em></li></ul><p>Способы избавиться от необходимости сортировки:</p><ul><li>порезать объекты на части (требует сложной подготовки)</li><li>хранить не только цвет/альфу ближайшего к наблюдателю пикселя, а список из нескольких (требует расхода памяти)</li><li>переопределить оператор смешивания на коммутативный</li></ul><p>К третьей группе относится метод <code>Weighted Blended Order-Independent Transparency</code></p><p><a href="https://casual-effects.blogspot.com/2014/03/weighted-blended-order-independent.html" target="_blank" rel="noopener">пост</a> от автора, <a href="https://casual-effects.blogspot.com/2015/03/implemented-weighted-blended-order.html" target="_blank" rel="noopener">дополнение</a> и <a href="https://jcgt.org/published/0002/02/09/" target="_blank" rel="noopener">пейпер</a>. Также - [движок] с реализацией, и описание в книге <code>Computer graphics. Principles and practice</code> (всё - от него же).<br>Пара других примеров - имплементация в движке <a href="https://bagnell.github.io/cesium/Apps/Sandcastle/gallery/OIT.html" target="_blank" rel="noopener">cesium</a> (webgl) и пример на <a href="https://bkaradzic.github.io/bgfx/examples.html#oit" target="_blank" rel="noopener">bgfx</a></p><p>Собственно, спортить пример напрямую не получилось, поэтому реализация скорее не перевод примера, а из поста, “в лоб”, возможно некорректная, но вроде похожая не референсный скриншот из оригинала.</p><p>Других прямых референсов откопать не удалось, а сравнить с “традиционной” прозрачность нельзя, так как независимые от порядка методы содержат погрешности, конкретно <code>weighted blended</code>, как следует из названия, содержит “веса” объектов, в зависимости от их прозрачности и удаленности от камеры, так что для корректного использования необходимо представлять себе диапазоны возможных значений. Так что тут скорее “<strong><code>проба API</code></strong>“, а не нормальная реализация.</p><h2 id="Инициализация"><a href="#Инициализация" class="headerlink" title="Инициализация"></a>Инициализация</h2><p>После создания окна</p><p><strong><code>Создание двух view</code></strong><br>Один - для рендера в 2 текстуры, второй - для смешивания текстур с восстановлением альфы на экране<br><figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">var display_w, display_h : int</span><br><span class="line">glfwGetWindowSize(window, safe_addr(display_w), safe_addr(display_h))</span><br><span class="line">bgfx_reset(uint(display_w), uint(display_h), BGFX_RESET_VSYNC, bgfx_texture_format COUNT)</span><br><span class="line">bgfx_set_view_rect(<span class="number">0</span>u, <span class="number">0</span>u, <span class="number">0</span>u, uint(display_w), uint(display_h))</span><br><span class="line">bgfx_set_view_rect(<span class="number">1</span>u, <span class="number">0</span>u, <span class="number">0</span>u, uint(display_w), uint(display_h))</span><br></pre></td></tr></table></figure></p><p><strong><code>Создание 2х RT-текстур, в сумме 5 каналов 16-битных float-каналов - RGBA + модификатор</code></strong><br><figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">var fb_textures = [[auto </span><br><span class="line">    bgfx_create_texture_2d(<span class="number">1280</span>u, <span class="number">720</span>u, <span class="keyword">false</span>, <span class="number">1</span>u, bgfx_texture_format RGBA16F, BGFX_TEXTURE_RT, <span class="keyword">null</span>);</span><br><span class="line">    bgfx_create_texture_2d(<span class="number">1280</span>u, <span class="number">720</span>u, <span class="keyword">false</span>, <span class="number">1</span>u, bgfx_texture_format R16F, BGFX_TEXTURE_RT, <span class="keyword">null</span>)</span><br><span class="line">]]</span><br><span class="line"></span><br><span class="line"><span class="comment">//создаём фреймбуффер, к которому прикрепляем обе текстуры, и привязываем его к первому view</span></span><br><span class="line">var fbh = bgfx_create_frame_buffer_from_handles(<span class="number">2</span>u, safe_addr(fb_textures),<span class="keyword">true</span>)</span><br><span class="line">bgfx_set_view_frame_buffer(<span class="number">0</span>u, fbh)</span><br></pre></td></tr></table></figure></p><p><strong><code>Заливка текстур начальным значением</code></strong><br><figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> pal0 = [[float <span class="number">0.0</span>; <span class="number">0.0</span>; <span class="number">0.0</span>; <span class="number">0.0</span>]] <span class="comment">//для RGBA каналов</span></span><br><span class="line"><span class="keyword">let</span> pal1 = [[float <span class="number">1.0</span>; <span class="number">1.0</span>; <span class="number">1.0</span>; <span class="number">1.0</span>]] <span class="comment">//для канала с весами</span></span><br><span class="line">bgfx_set_view_frame_buffer(<span class="number">0</span>u, fbh)</span><br><span class="line">bgfx_set_palette_color(<span class="number">0</span>u, safe_addr(pal0))</span><br><span class="line">bgfx_set_palette_color(<span class="number">1</span>u, safe_addr(pal1))</span><br><span class="line">bgfx_set_view_clear_mrt(<span class="number">0</span>u , BGFX_CLEAR_COLOR|BGFX_CLEAR_DEPTH, <span class="number">1.0</span>f, <span class="number">0</span>u, <span class="number">0</span>u, <span class="number">1</span>u, <span class="number">0</span>u, <span class="number">0</span>u, <span class="number">0</span>u, <span class="number">0</span>u, <span class="number">0</span>u, <span class="number">0</span>u)</span><br></pre></td></tr></table></figure></p><h2 id="Проход-1-рендер-полупрозрачных-объектов"><a href="#Проход-1-рендер-полупрозрачных-объектов" class="headerlink" title="Проход 1 - рендер полупрозрачных объектов"></a>Проход 1 - рендер полупрозрачных объектов</h2><p><em>(алгоритм позволяет использовать уже накопленный буфер глубины и совмещается с другими техниками рендера, но тут - наиболее простая референсная сцена с тремя полупрозрачными квадами)</em></p><p><strong><code>Шейдер</code></strong></p><figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">var [[<span class="keyword">in</span>]] a_position : float3</span><br><span class="line">var [[<span class="keyword">in</span>]] a_color0 : float4</span><br><span class="line">var [[inout, semantics=POSITION1]] v_pos : float4</span><br><span class="line">var [[inout]] v_color0 : float4</span><br><span class="line">var [[uniform]] v_ortho : float4x4</span><br><span class="line"></span><br><span class="line">[bgfx_vertex_buffer]</span><br><span class="line"><span class="keyword">struct</span> Vertex</span><br><span class="line">    position : float3</span><br><span class="line">    color0 : float4</span><br><span class="line"></span><br><span class="line">[bgfx_vertex_program]</span><br><span class="line">def vs_main</span><br><span class="line">    v_color0 = a_color0</span><br><span class="line">    gl_Position = v_ortho * float4(a_position, <span class="number">1.0</span>)</span><br><span class="line">    v_pos = gl_Position</span><br><span class="line"></span><br><span class="line">[bgfx_fragment_program]</span><br><span class="line">def fs_main</span><br><span class="line">    var color = v_color0</span><br><span class="line">    <span class="comment">//не важно для 2d референсной сцены</span></span><br><span class="line">    <span class="keyword">let</span> depth = v_pos.z/v_pos.w</span><br><span class="line">    <span class="comment">//не забыть alpha-premultiply</span></span><br><span class="line">    color.xyz *= color.w</span><br><span class="line">    <span class="comment">//настройка веса</span></span><br><span class="line">    <span class="keyword">let</span> weight = color.w * clamp(<span class="number">0.03</span> / (<span class="number">1e-5</span> + pow(depth, <span class="number">5.0</span>) ), <span class="number">0.01</span>, <span class="number">3000.0</span>)</span><br><span class="line">    <span class="comment">//запись в 1-ю rt текстуру RGBA, умноженного на вес</span></span><br><span class="line">    gl_FragData[<span class="number">0</span>] = color * weight</span><br><span class="line">    <span class="comment">//отдельное сохранение веса</span></span><br><span class="line">    gl_FragData[<span class="number">1</span>] = color.wwww</span><br></pre></td></tr></table></figure><p>Небольшое необходимое дополнение к <a href="https://github.com/GaijinEntertainment/daScript/blob/master/modules/dasGlsl/glsl/glsl_common.das#L121" target="_blank" rel="noopener">DSL-шейдеров</a>:<br><figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//объявление переменной для записи нескольких output-цветов (в несколько RT-текстур) в пиксельном шейдере</span></span><br><span class="line">var gl_FragData = [[float4[<span class="number">4</span>] float4(); float4(); float4(); float4()]]</span><br></pre></td></tr></table></figure></p><p><strong><code>Настройка смешивания и отрисовка</code></strong></p><figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">vs_main_bind_uniform()</span><br><span class="line">fs_main_bind_uniform()</span><br><span class="line">var stateNoDepth = ( uint64(<span class="number">0</span>)</span><br><span class="line">    | BGFX_STATE_CULL_CW</span><br><span class="line">    | BGFX_STATE_WRITE_RGB</span><br><span class="line">    | BGFX_STATE_WRITE_A</span><br><span class="line">    | BGFX_STATE_DEPTH_TEST_ALWAYS</span><br><span class="line">    | BGFX_STATE_MSAA</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//флажки для задания режима прозрачности (ONE, ONE) для первой RT1 и (ZERO, SRC_COLOR) для RT2</span></span><br><span class="line"><span class="comment">//separate blendState for RT2</span></span><br><span class="line"><span class="keyword">let</span> rt2_blendState =uint(</span><br><span class="line">    BGFX_STATE_BLEND_ZERO &gt;&gt; uint64(BGFX_STATE_BLEND_SHIFT) |</span><br><span class="line">    BGFX_STATE_BLEND_SRC_COLOR &gt;&gt; uint64(BGFX_STATE_BLEND_SHIFT) &lt;&lt; uint64(<span class="number">4</span>)</span><br><span class="line">)</span><br><span class="line">bgfx_set_state(</span><br><span class="line">    stateNoDepth | BGFX_STATE_BLEND_FUNC(BGFX_STATE_BLEND_ONE, BGFX_STATE_BLEND_ONE) | BGFX_STATE_BLEND_INDEPENDENT,</span><br><span class="line">    rt2_blendState</span><br><span class="line">)</span><br><span class="line">bgfx_submit(<span class="number">0</span>u, program, <span class="number">1</span>u, BGFX_DISCARD_NONE)</span><br></pre></td></tr></table></figure><p><em>В пейпере автора рассматривается этот подход и альтернативный, для gpu без поддержки задания раздельных режимов смешивания для различных render target. Они немного отличаются в коде шейдера и смешивании, важно не перепутать сочетание</em></p><p>Задание раздельных функций смешивания для render-target выглядят в BGFX страшно - в первый параметр передаётся флаг <code>BGFX_STATE_BLEND_INDEPENDENT</code>, а во второй (который 32-битный и называется _rgba) - битовая маска для описания режима смешивания второй RT. В c-api это спрятано за макросом для немного менее страшной записи.</p><p>На этой стадии можно попробовать отрисовать сцену и подключиться к приложению через графический отладчик, чтобы проверить состояние RT-текстур (например, <strong><code>RenderDoc</code></strong>):<br><img src="/blog/3778037319/bgfx_renderdoc_small.png" alt=""><br><em>текстура развёрнута по y</em></p><h2 id="Проход-2-восстановление-альфа-канала-по-текстуре-с-весами"><a href="#Проход-2-восстановление-альфа-канала-по-текстуре-с-весами" class="headerlink" title="Проход 2 - восстановление альфа канала по текстуре с весами"></a>Проход 2 - восстановление альфа канала по текстуре с весами</h2><p><strong><code>Шейдер</code></strong></p><figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">[bgfx_vertex_buffer]</span><br><span class="line"><span class="keyword">struct</span> VertexTex</span><br><span class="line">    position : float3</span><br><span class="line">    color0 : float4</span><br><span class="line">    [[<span class="class"><span class="keyword">type</span></span>=FLOAT, size=<span class="number">2</span>, semantics=TEXCOORD0, normalized=<span class="keyword">false</span>, as_int=<span class="keyword">false</span>]] uv : float2</span><br><span class="line"></span><br><span class="line">var [[uniform, stage=<span class="number">0</span>]] s_texColor0 : sampler2D</span><br><span class="line">var [[uniform, stage=<span class="number">1</span>]] s_texColor1 : sampler2D</span><br><span class="line"></span><br><span class="line">[bgfx_vertex_program]</span><br><span class="line">def vs_quad</span><br><span class="line">    v_texcoord0 = a_texcoord0</span><br><span class="line">    gl_Position = v_ortho * float4(a_position, <span class="number">1.0</span>)</span><br><span class="line"></span><br><span class="line">[bgfx_fragment_program]</span><br><span class="line">def fs_quad</span><br><span class="line">    <span class="keyword">let</span> accum   = texture2D(s_texColor0, v_texcoord0)</span><br><span class="line">    <span class="keyword">let</span> opacity = texture2D(s_texColor1, v_texcoord0).x</span><br><span class="line">    <span class="comment">//восстановление и ограничение диапазона</span></span><br><span class="line">    gl_FragColor  = float4(accum.xyz / clamp(accum.w, <span class="number">1e-4</span>, <span class="number">5e4</span>), opacity)</span><br></pre></td></tr></table></figure><p><strong><code>Настройка смешивания и отрисовка</code></strong></p><figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//привязка текстур к сэмплерам</span></span><br><span class="line">s_texColor0 := fb_textures[<span class="number">0</span>]</span><br><span class="line">s_texColor1 := fb_textures[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">//цвет фона и настройка смешивания</span></span><br><span class="line">bgfx_set_view_clear(<span class="number">1</span>u, BGFX_CLEAR_COLOR | BGFX_CLEAR_DEPTH, RGBA_TO_BGFX_UCOLOR(<span class="number">0.75</span>, <span class="number">0.75</span>, <span class="number">0.75</span>, <span class="number">1.0</span>), <span class="number">1.0</span>f, <span class="number">0</span>u)</span><br><span class="line">bgfx_set_state(BGFX_STATE_WRITE_RGB | BGFX_STATE_BLEND_FUNC(BGFX_STATE_BLEND_INV_SRC_ALPHA, BGFX_STATE_BLEND_SRC_ALPHA), <span class="number">0</span>u)</span><br><span class="line"></span><br><span class="line"><span class="comment">//вывод fullscreen квада</span></span><br><span class="line">vs_quad_bind_uniform()</span><br><span class="line">fs_quad_bind_uniform()</span><br><span class="line">bgfx_submit(<span class="number">1</span>u, program_quad, <span class="number">1</span>u, BGFX_DISCARD_NONE)</span><br></pre></td></tr></table></figure><p><strong><code>Результат</code></strong></p><p><img src="/blog/3778037319/bgfx_oit_small.png" alt=""><br><a href="https://github.com/spiiin/dascript_trivial_examples/blob/main/das_bgfx_hello_wboit/das_bgfx_hello_wboit.das" target="_blank" rel="noopener">Код</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;&lt;a href=&quot;h
      
    
    </summary>
    
    
    
      <category term="opengl" scheme="http://spiiin.github.io/tags/opengl/"/>
    
      <category term="dascript" scheme="http://spiiin.github.io/tags/dascript/"/>
    
  </entry>
  
  <entry>
    <title>daScript - binding tricks</title>
    <link href="http://spiiin.github.io/blog/1908536621/"/>
    <id>http://spiiin.github.io/blog/1908536621/</id>
    <published>2023-09-05T15:15:38.000Z</published>
    <updated>2023-09-28T09:06:04.888Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Несколько примеров дополнительно к <a href="https://dascript.org/doc/reference/embedding/modules.html" target="_blank" rel="noopener">Modules and C++ bindings</a></p><p><strong><code>Привязка метода класса</code></strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//структура с методами</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">42</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//тип-обёртка, описание структуры для daScript</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStructTypeAnnotation</span> :</span> ManagedStructureAnnotation &lt;MyStruct&gt; &#123;</span><br><span class="line">    MyStructTypeAnnotation(ModuleLibrary&amp; ml) : ManagedStructureAnnotation(<span class="string">"MyStruct"</span>, ml) &#123;</span><br><span class="line">        <span class="comment">//тут может быть описание полей</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">MAKE_TYPE_FACTORY(MyStruct, MyStruct)</span><br><span class="line"></span><br><span class="line"><span class="comment">//описание модуля</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Module_Tutorial02</span> :</span> <span class="keyword">public</span> Module &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Module_Tutorial02() : Module(<span class="string">"tutorial_02"</span>) &#123;   <span class="comment">// module name, when used from das file</span></span><br><span class="line">        ModuleLibrary lib;</span><br><span class="line">        lib.addModule(<span class="keyword">this</span>);</span><br><span class="line">        lib.addBuiltInModule();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//описание структуры</span></span><br><span class="line">        addAnnotation(make_smart&lt;MyStructTypeAnnotation&gt;(lib));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//регистрация метода</span></span><br><span class="line">        <span class="keyword">using</span> method_test = DAS_CALL_MEMBER(MyStruct::test);</span><br><span class="line">        addExtern&lt;DAS_CALL_METHOD(method_test)&gt;(*<span class="keyword">this</span>, lib, <span class="string">"mystruct_test"</span>, SideEffects::none,</span><br><span class="line">            DAS_CALL_MEMBER_CPP(MyStruct::test));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//возможный вызов метода в daScript</span></span><br><span class="line">var c: MyStruct</span><br><span class="line">print(<span class="string">"&#123;c |&gt; mystruct_test()&#125;"</span>)</span><br></pre></td></tr></table></figure><p><strong><code>Привязка перегруженных и шаблонных функций с явным указанием сигнатуры</code></strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test2</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123; <span class="keyword">return</span> a; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">test3</span><span class="params">(T a)</span> </span>&#123; <span class="keyword">return</span> a; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//явное указание сигнатуры функции для привязки</span></span><br><span class="line">addExtern&lt;<span class="keyword">int</span>(*)(<span class="keyword">int</span>),test2&gt;(*<span class="keyword">this</span>, lib, <span class="string">"test2"</span>, SideEffects::none, <span class="string">"test2"</span>);</span><br><span class="line">addExtern&lt;<span class="keyword">int</span>(*)(<span class="keyword">int</span>), test3&gt;(*<span class="keyword">this</span>, lib, <span class="string">"test3"</span>, SideEffects::none, <span class="string">"test3"</span>);</span><br></pre></td></tr></table></figure><p><strong><code>Возврат ссылки</code></strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> gValue = <span class="number">111</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">getRef</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> gValue; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span>&amp; <span class="title">getRefInline</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> gValue; &#125;</span><br><span class="line"></span><br><span class="line">addExtern&lt;DAS_BIND_FUN(getRef), SimNode_ExtFuncCallRef&gt;(*<span class="keyword">this</span>, lib, <span class="string">"getRef"</span>, SideEffects::accessExternal, <span class="string">"getRef"</span>);</span><br><span class="line">addExternTempRef&lt;DAS_BIND_FUN(getRefInline), SimNode_ExtFuncCallRef&gt;(*<span class="keyword">this</span>, lib, <span class="string">"getRefInline"</span>, SideEffects::accessExternal, <span class="string">"getRefInline"</span>);</span><br><span class="line">```</span><br></pre></td></tr></table></figure><figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">getRef() = <span class="number">333</span></span><br><span class="line">print(<span class="string">"&#123;getRef()&#125;\n"</span>) <span class="comment">//333</span></span><br><span class="line"></span><br><span class="line">var v4&amp; = getRefInline()</span><br><span class="line">v4 = <span class="number">444</span></span><br><span class="line">print(<span class="string">"&#123;getRefInline()&#125;\n"</span>) <span class="comment">//444</span></span><br></pre></td></tr></table></figure><p><strong><code>Возврат ссылки по значению</code></strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//returns a ref type by value,</span></span><br><span class="line">addExtern&lt;DAS_BIND_FUN(float4x4_translation), SimNode_ExtFuncCallAndCopyOrMove&gt;(*<span class="keyword">this</span>, lib, <span class="string">"translation"</span>,</span><br><span class="line">        SideEffects::none, <span class="string">"float4x4_translation"</span>)-&gt;arg(<span class="string">"xyz"</span>);</span><br></pre></td></tr></table></figure><p><strong><code>Привязка других типов нод AST</code></strong><br>Способы привязать семантику вызова функции на стороне daScript к генерации других типов нод</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">__forceinline <span class="keyword">float</span> <span class="title">dot3</span><span class="params">(vec4f a, vec4f b)</span></span>&#123;<span class="keyword">return</span> v_extract_x(v_dot3_x(a, b));&#125;</span><br><span class="line">addExternEx&lt;<span class="keyword">float</span>(float3,float3),DAS_BIND_FUN(dot3)&gt;(*<span class="keyword">this</span>, lib, <span class="string">"dot"</span>, SideEffects::none, <span class="string">"dot3"</span>)-&gt;args(&#123;<span class="string">"x"</span>,<span class="string">"y"</span>&#125;);</span><br><span class="line"></span><br><span class="line">addFunction(make_smart&lt;BuiltInFn&lt;SimNode_MatrixCtor&lt;float3x3&gt;,float3x3&gt;&gt;(<span class="string">"float3x3"</span>,lib));</span><br></pre></td></tr></table></figure><p><strong><code>Хинты для аргументов</code></strong></p><p>//TODO<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TT&gt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">registerVectorFunctions</span>&lt;TT&gt; &#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    addExtern&lt;DAS_BIND_FUN(das_vector_pop&lt;TT&gt;)&gt;(*mod, lib, <span class="string">"pop"</span>,</span><br><span class="line">        SideEffects::modifyArgument, <span class="string">"das_vector_pop"</span>);</span><br><span class="line">    <span class="comment">//permanentArgFn</span></span><br><span class="line">    addExtern&lt;DAS_BIND_FUN(das_vector_clear&lt;TT&gt;),SimNode_ExtFuncCall,permanentArgFn&gt;(*mod, lib, <span class="string">"clear"</span>,</span><br><span class="line">        SideEffects::modifyArgument, <span class="string">"das_vector_clear"</span>);</span><br><span class="line">    <span class="comment">//explicitConstArgFn</span></span><br><span class="line">    addExtern&lt;DAS_BIND_FUN(das_vector_each&lt;TT&gt;),SimNode_ExtFuncCallAndCopyOrMove,explicitConstArgFn&gt;(*mod, lib, <span class="string">"each"</span>,</span><br><span class="line">        SideEffects::none, <span class="string">"das_vector_each"</span>);</span><br><span class="line">    <span class="comment">//temporaryArgFn</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong><code>Симуляция walk</code></strong></p><p>Создание своего типа-хендла, который в dascript будет обрабатываться как примитивный тип uint64</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyHandle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> id;</span><br><span class="line">    <span class="comment">//другие методы и свойства handle</span></span><br><span class="line">&#125;;</span><br><span class="line">MAKE_TYPE_FACTORY(MyHandle, MyHandle)</span><br><span class="line"></span><br><span class="line"><span class="comment">//описываем методы каста к примитивному типу и обратно</span></span><br><span class="line"><span class="keyword">namespace</span> das</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;&gt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cast</span>&lt;MyHandle&gt;</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> __forceinline MyHandle <span class="title">to</span><span class="params">(vec4f x)</span> </span>&#123; <span class="keyword">return</span> MyHandle&#123; (<span class="keyword">uint64_t</span>)v_extract_xi64(v_cast_vec4i(x)) &#125;; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> __forceinline vec4f <span class="title">from</span><span class="params">(MyHandle x)</span> </span>&#123; <span class="keyword">return</span> v_cast_vec4f(v_splatsi64(x.id)); &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//описываем аннотацию типа с перегруженным методом walk</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyHandleAnnotation</span> <span class="title">final</span> :</span> ManagedStructureAnnotation&lt;MyHandle&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyHandleAnnotation(ModuleLibrary&amp; ml) : ManagedStructureAnnotation(<span class="string">"MyHandle"</span>, ml) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasNonTrivialCtor</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125; <span class="comment">//trivial type</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canClone</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">(DataWalker&amp; walker, <span class="keyword">void</span>* data)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!walker.reading)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">const</span> MyHandle* t = (MyHandle*)data;</span><br><span class="line">            <span class="keyword">uint64_t</span> eidV = t-&gt;id;</span><br><span class="line">            walker.UInt64(eidV);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> SimNode* <span class="title">simulateClone</span><span class="params">(das::Context&amp; context, <span class="keyword">const</span> das::LineInfo&amp; at, das::SimNode* l, das::SimNode* r)</span> <span class="keyword">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> GenCloneNode&lt;MyHandle&gt;::simulateClone(context, at, l, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><code>Симуляция итератора</code></strong><br>Для кастомного контейнера можно задать прямой способ обращения к элементам (для простоты — нешаблонная версия кода)</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//кастомный вектор из элементов MyHandle</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyVector</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;MyHandle&gt; vec;</span><br><span class="line">&#125;;</span><br><span class="line">MAKE_TYPE_FACTORY(MyVector, MyVector)</span><br><span class="line"></span><br><span class="line"><span class="comment">//создаём вектор в C++ и делаем функцию доступа к нему из daScript</span></span><br><span class="line">MyVector gVector = &#123; &#123;MyHandle&#123;<span class="number">1</span>&#125;, MyHandle&#123;<span class="number">3</span>&#125;, MyHandle&#123;<span class="number">5</span>&#125;&#125; &#125;;</span><br><span class="line"><span class="function"><span class="keyword">auto</span>&amp; <span class="title">getArrayRef</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> gVector; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//кастомный итератор</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyIterator</span> :</span> Iterator</span><br><span class="line">&#123;</span><br><span class="line">    MyIterator(MyVector* ar) : <span class="built_in">array</span>(ar) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">first</span><span class="params">(das::Context&amp;, <span class="keyword">char</span>* _value)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">array</span>-&gt;vec.size())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        iterator_type* value = (iterator_type*)_value;</span><br><span class="line">        *value = <span class="built_in">array</span>-&gt;vec.begin(); <span class="comment">//пишем в память, выделенную в daScript под итератор</span></span><br><span class="line">        end = <span class="built_in">array</span>-&gt;vec.end();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">next</span><span class="params">(das::Context&amp;, <span class="keyword">char</span>* _value)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        iterator_type* value = (iterator_type*)_value;</span><br><span class="line">        ++(*value); <span class="comment">//сдвигаем курсор на следующий элемент</span></span><br><span class="line">        <span class="keyword">return</span> *value != end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(das::Context&amp; context, <span class="keyword">char</span>* _value)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//освобождаем итератор, по хорошему нужно еще занулить value</span></span><br><span class="line">        context.heap-&gt;<span class="built_in">free</span>((<span class="keyword">char</span>*)<span class="keyword">this</span>, <span class="keyword">sizeof</span>(MyIterator));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MyVector* <span class="built_in">array</span> = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(<span class="built_in">array</span>-&gt;vec.begin())</span> iterator_type</span>;</span><br><span class="line">    iterator_type end;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//в аннотации типа вектора говорим:</span></span><br><span class="line"><span class="comment">//"при обращении к итератору контейнера из daScript будет создан кастомный класс итератора и вызываться его методы"</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyVectorAnnotation</span> <span class="title">final</span> :</span> ManagedStructureAnnotation&lt;MyVector, <span class="literal">false</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    TypeDeclPtr vecType;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    MyVectorAnnotation(das::ModuleLibrary&amp; ml) : ManagedStructureAnnotation(<span class="string">"MyVector"</span>, ml)</span><br><span class="line">    &#123;</span><br><span class="line">        cppName = <span class="string">"MyVector"</span>;</span><br><span class="line"></span><br><span class="line">        vecType = makeType&lt;MyHandle&gt;(ml);</span><br><span class="line">        vecType-&gt;ref = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">isIterable</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> das::TypeDeclPtr <span class="title">makeIteratorType</span><span class="params">(<span class="keyword">const</span> das::ExpressionPtr&amp;)</span> <span class="keyword">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> das::make_smart&lt;das::TypeDecl&gt;(*vecType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//используем наш итератор для обхода</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> das::SimNode* <span class="title">simulateGetIterator</span><span class="params">(das::Context&amp; context, <span class="keyword">const</span> das::LineInfo&amp; at,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> das::ExpressionPtr&amp; src)</span> <span class="keyword">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> rv = src-&gt;simulate(context);</span><br><span class="line">        <span class="keyword">return</span> context.code-&gt;makeNode&lt;das::SimNode_AnyIterator&lt;MyVector, MyIterator&gt;&gt;(at, rv);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//не забываем добавить в модуль аннотации</span></span><br><span class="line">addAnnotation(make_smart&lt;MyHandleAnnotation&gt;(lib));</span><br><span class="line">addAnnotation(make_smart&lt;MyVectorAnnotation&gt;(lib));</span><br><span class="line">addExtern&lt;DAS_BIND_FUN(getArrayRef), SimNode_ExtFuncCallRef&gt;(*<span class="keyword">this</span>, lib, <span class="string">"getArrayRef"</span>,</span><br><span class="line">    SideEffects::accessExternal, <span class="string">"getArrayRef"</span>);</span><br></pre></td></tr></table></figure><figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//теперь можно пройти по C++-контейнеру из daScript без дополнительных затрат на итерации</span></span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> getArrayRef()</span><br><span class="line">    print(<span class="string">"&#123;v&#125;\n"</span>)</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;Несколько 
      
    
    </summary>
    
    
    
      <category term="dascript" scheme="http://spiiin.github.io/tags/dascript/"/>
    
  </entry>
  
</feed>
